/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const t$3 = globalThis, e$2 = t$3.ShadowRoot && (t$3.ShadyCSS === void 0 || t$3.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype, s$3 = Symbol(), o$3 = /* @__PURE__ */ new WeakMap();
let n$4 = class {
  constructor(X, ee, te) {
    if (this._$cssResult$ = !0, te !== s$3)
      throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    this.cssText = X, this.t = ee;
  }
  get styleSheet() {
    let X = this.o;
    const ee = this.t;
    if (e$2 && X === void 0) {
      const te = ee !== void 0 && ee.length === 1;
      te && (X = o$3.get(ee)), X === void 0 && ((this.o = X = new CSSStyleSheet()).replaceSync(this.cssText), te && o$3.set(ee, X));
    }
    return X;
  }
  toString() {
    return this.cssText;
  }
};
const r$8 = (Y) => new n$4(typeof Y == "string" ? Y : Y + "", void 0, s$3), i$5 = (Y, ...X) => {
  const ee = Y.length === 1 ? Y[0] : X.reduce((te, ne, ie) => te + ((oe) => {
    if (oe._$cssResult$ === !0)
      return oe.cssText;
    if (typeof oe == "number")
      return oe;
    throw Error("Value passed to 'css' function must be a 'css' function result: " + oe + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
  })(ne) + Y[ie + 1], Y[0]);
  return new n$4(ee, Y, s$3);
}, S$2 = (Y, X) => {
  if (e$2)
    Y.adoptedStyleSheets = X.map((ee) => ee instanceof CSSStyleSheet ? ee : ee.styleSheet);
  else
    for (const ee of X) {
      const te = document.createElement("style"), ne = t$3.litNonce;
      ne !== void 0 && te.setAttribute("nonce", ne), te.textContent = ee.cssText, Y.appendChild(te);
    }
}, c$2 = e$2 ? (Y) => Y : (Y) => Y instanceof CSSStyleSheet ? ((X) => {
  let ee = "";
  for (const te of X.cssRules)
    ee += te.cssText;
  return r$8(ee);
})(Y) : Y;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const { is: i$4, defineProperty: e$1, getOwnPropertyDescriptor: r$7, getOwnPropertyNames: h$1, getOwnPropertySymbols: o$2, getPrototypeOf: n$3 } = Object, a$1 = globalThis, c$1 = a$1.trustedTypes, l$2 = c$1 ? c$1.emptyScript : "", p$2 = a$1.reactiveElementPolyfillSupport, d$1 = (Y, X) => Y, u$2 = { toAttribute(Y, X) {
  switch (X) {
    case Boolean:
      Y = Y ? l$2 : null;
      break;
    case Object:
    case Array:
      Y = Y == null ? Y : JSON.stringify(Y);
  }
  return Y;
}, fromAttribute(Y, X) {
  let ee = Y;
  switch (X) {
    case Boolean:
      ee = Y !== null;
      break;
    case Number:
      ee = Y === null ? null : Number(Y);
      break;
    case Object:
    case Array:
      try {
        ee = JSON.parse(Y);
      } catch {
        ee = null;
      }
  }
  return ee;
} }, f$3 = (Y, X) => !i$4(Y, X), y$2 = { attribute: !0, type: String, converter: u$2, reflect: !1, hasChanged: f$3 };
Symbol.metadata ?? (Symbol.metadata = Symbol("metadata")), a$1.litPropertyMetadata ?? (a$1.litPropertyMetadata = /* @__PURE__ */ new WeakMap());
let b$1 = class extends HTMLElement {
  static addInitializer(X) {
    this._$Ei(), (this.l ?? (this.l = [])).push(X);
  }
  static get observedAttributes() {
    return this.finalize(), this._$Eh && [...this._$Eh.keys()];
  }
  static createProperty(X, ee = y$2) {
    if (ee.state && (ee.attribute = !1), this._$Ei(), this.elementProperties.set(X, ee), !ee.noAccessor) {
      const te = Symbol(), ne = this.getPropertyDescriptor(X, te, ee);
      ne !== void 0 && e$1(this.prototype, X, ne);
    }
  }
  static getPropertyDescriptor(X, ee, te) {
    const { get: ne, set: ie } = r$7(this.prototype, X) ?? { get() {
      return this[ee];
    }, set(oe) {
      this[ee] = oe;
    } };
    return { get() {
      return ne == null ? void 0 : ne.call(this);
    }, set(oe) {
      const se = ne == null ? void 0 : ne.call(this);
      ie.call(this, oe), this.requestUpdate(X, se, te);
    }, configurable: !0, enumerable: !0 };
  }
  static getPropertyOptions(X) {
    return this.elementProperties.get(X) ?? y$2;
  }
  static _$Ei() {
    if (this.hasOwnProperty(d$1("elementProperties")))
      return;
    const X = n$3(this);
    X.finalize(), X.l !== void 0 && (this.l = [...X.l]), this.elementProperties = new Map(X.elementProperties);
  }
  static finalize() {
    if (this.hasOwnProperty(d$1("finalized")))
      return;
    if (this.finalized = !0, this._$Ei(), this.hasOwnProperty(d$1("properties"))) {
      const ee = this.properties, te = [...h$1(ee), ...o$2(ee)];
      for (const ne of te)
        this.createProperty(ne, ee[ne]);
    }
    const X = this[Symbol.metadata];
    if (X !== null) {
      const ee = litPropertyMetadata.get(X);
      if (ee !== void 0)
        for (const [te, ne] of ee)
          this.elementProperties.set(te, ne);
    }
    this._$Eh = /* @__PURE__ */ new Map();
    for (const [ee, te] of this.elementProperties) {
      const ne = this._$Eu(ee, te);
      ne !== void 0 && this._$Eh.set(ne, ee);
    }
    this.elementStyles = this.finalizeStyles(this.styles);
  }
  static finalizeStyles(X) {
    const ee = [];
    if (Array.isArray(X)) {
      const te = new Set(X.flat(1 / 0).reverse());
      for (const ne of te)
        ee.unshift(c$2(ne));
    } else
      X !== void 0 && ee.push(c$2(X));
    return ee;
  }
  static _$Eu(X, ee) {
    const te = ee.attribute;
    return te === !1 ? void 0 : typeof te == "string" ? te : typeof X == "string" ? X.toLowerCase() : void 0;
  }
  constructor() {
    super(), this._$Ep = void 0, this.isUpdatePending = !1, this.hasUpdated = !1, this._$Em = null, this._$Ev();
  }
  _$Ev() {
    var X;
    this._$ES = new Promise((ee) => this.enableUpdating = ee), this._$AL = /* @__PURE__ */ new Map(), this._$E_(), this.requestUpdate(), (X = this.constructor.l) == null || X.forEach((ee) => ee(this));
  }
  addController(X) {
    var ee;
    (this._$EO ?? (this._$EO = /* @__PURE__ */ new Set())).add(X), this.renderRoot !== void 0 && this.isConnected && ((ee = X.hostConnected) == null || ee.call(X));
  }
  removeController(X) {
    var ee;
    (ee = this._$EO) == null || ee.delete(X);
  }
  _$E_() {
    const X = /* @__PURE__ */ new Map(), ee = this.constructor.elementProperties;
    for (const te of ee.keys())
      this.hasOwnProperty(te) && (X.set(te, this[te]), delete this[te]);
    X.size > 0 && (this._$Ep = X);
  }
  createRenderRoot() {
    const X = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);
    return S$2(X, this.constructor.elementStyles), X;
  }
  connectedCallback() {
    var X;
    this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this.enableUpdating(!0), (X = this._$EO) == null || X.forEach((ee) => {
      var te;
      return (te = ee.hostConnected) == null ? void 0 : te.call(ee);
    });
  }
  enableUpdating(X) {
  }
  disconnectedCallback() {
    var X;
    (X = this._$EO) == null || X.forEach((ee) => {
      var te;
      return (te = ee.hostDisconnected) == null ? void 0 : te.call(ee);
    });
  }
  attributeChangedCallback(X, ee, te) {
    this._$AK(X, te);
  }
  _$EC(X, ee) {
    var ie;
    const te = this.constructor.elementProperties.get(X), ne = this.constructor._$Eu(X, te);
    if (ne !== void 0 && te.reflect === !0) {
      const oe = (((ie = te.converter) == null ? void 0 : ie.toAttribute) !== void 0 ? te.converter : u$2).toAttribute(ee, te.type);
      this._$Em = X, oe == null ? this.removeAttribute(ne) : this.setAttribute(ne, oe), this._$Em = null;
    }
  }
  _$AK(X, ee) {
    var ie;
    const te = this.constructor, ne = te._$Eh.get(X);
    if (ne !== void 0 && this._$Em !== ne) {
      const oe = te.getPropertyOptions(ne), se = typeof oe.converter == "function" ? { fromAttribute: oe.converter } : ((ie = oe.converter) == null ? void 0 : ie.fromAttribute) !== void 0 ? oe.converter : u$2;
      this._$Em = ne, this[ne] = se.fromAttribute(ee, oe.type), this._$Em = null;
    }
  }
  requestUpdate(X, ee, te) {
    if (X !== void 0) {
      if (te ?? (te = this.constructor.getPropertyOptions(X)), !(te.hasChanged ?? f$3)(this[X], ee))
        return;
      this.P(X, ee, te);
    }
    this.isUpdatePending === !1 && (this._$ES = this._$ET());
  }
  P(X, ee, te) {
    this._$AL.has(X) || this._$AL.set(X, ee), te.reflect === !0 && this._$Em !== X && (this._$Ej ?? (this._$Ej = /* @__PURE__ */ new Set())).add(X);
  }
  async _$ET() {
    this.isUpdatePending = !0;
    try {
      await this._$ES;
    } catch (ee) {
      Promise.reject(ee);
    }
    const X = this.scheduleUpdate();
    return X != null && await X, !this.isUpdatePending;
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    var te;
    if (!this.isUpdatePending)
      return;
    if (!this.hasUpdated) {
      if (this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this._$Ep) {
        for (const [ie, oe] of this._$Ep)
          this[ie] = oe;
        this._$Ep = void 0;
      }
      const ne = this.constructor.elementProperties;
      if (ne.size > 0)
        for (const [ie, oe] of ne)
          oe.wrapped !== !0 || this._$AL.has(ie) || this[ie] === void 0 || this.P(ie, this[ie], oe);
    }
    let X = !1;
    const ee = this._$AL;
    try {
      X = this.shouldUpdate(ee), X ? (this.willUpdate(ee), (te = this._$EO) == null || te.forEach((ne) => {
        var ie;
        return (ie = ne.hostUpdate) == null ? void 0 : ie.call(ne);
      }), this.update(ee)) : this._$EU();
    } catch (ne) {
      throw X = !1, this._$EU(), ne;
    }
    X && this._$AE(ee);
  }
  willUpdate(X) {
  }
  _$AE(X) {
    var ee;
    (ee = this._$EO) == null || ee.forEach((te) => {
      var ne;
      return (ne = te.hostUpdated) == null ? void 0 : ne.call(te);
    }), this.hasUpdated || (this.hasUpdated = !0, this.firstUpdated(X)), this.updated(X);
  }
  _$EU() {
    this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = !1;
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this._$ES;
  }
  shouldUpdate(X) {
    return !0;
  }
  update(X) {
    this._$Ej && (this._$Ej = this._$Ej.forEach((ee) => this._$EC(ee, this[ee]))), this._$EU();
  }
  updated(X) {
  }
  firstUpdated(X) {
  }
};
b$1.elementStyles = [], b$1.shadowRootOptions = { mode: "open" }, b$1[d$1("elementProperties")] = /* @__PURE__ */ new Map(), b$1[d$1("finalized")] = /* @__PURE__ */ new Map(), p$2 == null || p$2({ ReactiveElement: b$1 }), (a$1.reactiveElementVersions ?? (a$1.reactiveElementVersions = [])).push("2.0.4");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const t$2 = globalThis, i$3 = t$2.trustedTypes, s$2 = i$3 ? i$3.createPolicy("lit-html", { createHTML: (Y) => Y }) : void 0, e = "$lit$", h = `lit$${(Math.random() + "").slice(9)}$`, o$1 = "?" + h, n$2 = `<${o$1}>`, r$6 = document, l$1 = () => r$6.createComment(""), c = (Y) => Y === null || typeof Y != "object" && typeof Y != "function", a = Array.isArray, u$1 = (Y) => a(Y) || typeof (Y == null ? void 0 : Y[Symbol.iterator]) == "function", d = `[ 	
\f\r]`, f$2 = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g, v$1 = /-->/g, _ = />/g, m = RegExp(`>|${d}(?:([^\\s"'>=/]+)(${d}*=${d}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g"), p$1 = /'/g, g$2 = /"/g, $ = /^(?:script|style|textarea|title)$/i, y$1 = (Y) => (X, ...ee) => ({ _$litType$: Y, strings: X, values: ee }), x$2 = y$1(1), b = y$1(2), w$1 = Symbol.for("lit-noChange"), T$1 = Symbol.for("lit-nothing"), A$1 = /* @__PURE__ */ new WeakMap(), E$1 = r$6.createTreeWalker(r$6, 129);
function C$1(Y, X) {
  if (!Array.isArray(Y) || !Y.hasOwnProperty("raw"))
    throw Error("invalid template strings array");
  return s$2 !== void 0 ? s$2.createHTML(X) : X;
}
const P$1 = (Y, X) => {
  const ee = Y.length - 1, te = [];
  let ne, ie = X === 2 ? "<svg>" : "", oe = f$2;
  for (let se = 0; se < ee; se++) {
    const ae = Y[se];
    let ue, le, he = -1, me = 0;
    for (; me < ae.length && (oe.lastIndex = me, le = oe.exec(ae), le !== null); )
      me = oe.lastIndex, oe === f$2 ? le[1] === "!--" ? oe = v$1 : le[1] !== void 0 ? oe = _ : le[2] !== void 0 ? ($.test(le[2]) && (ne = RegExp("</" + le[2], "g")), oe = m) : le[3] !== void 0 && (oe = m) : oe === m ? le[0] === ">" ? (oe = ne ?? f$2, he = -1) : le[1] === void 0 ? he = -2 : (he = oe.lastIndex - le[2].length, ue = le[1], oe = le[3] === void 0 ? m : le[3] === '"' ? g$2 : p$1) : oe === g$2 || oe === p$1 ? oe = m : oe === v$1 || oe === _ ? oe = f$2 : (oe = m, ne = void 0);
    const ye = oe === m && Y[se + 1].startsWith("/>") ? " " : "";
    ie += oe === f$2 ? ae + n$2 : he >= 0 ? (te.push(ue), ae.slice(0, he) + e + ae.slice(he) + h + ye) : ae + h + (he === -2 ? se : ye);
  }
  return [C$1(Y, ie + (Y[ee] || "<?>") + (X === 2 ? "</svg>" : "")), te];
};
let V$1 = class yY {
  constructor({ strings: X, _$litType$: ee }, te) {
    let ne;
    this.parts = [];
    let ie = 0, oe = 0;
    const se = X.length - 1, ae = this.parts, [ue, le] = P$1(X, ee);
    if (this.el = yY.createElement(ue, te), E$1.currentNode = this.el.content, ee === 2) {
      const he = this.el.content.firstChild;
      he.replaceWith(...he.childNodes);
    }
    for (; (ne = E$1.nextNode()) !== null && ae.length < se; ) {
      if (ne.nodeType === 1) {
        if (ne.hasAttributes())
          for (const he of ne.getAttributeNames())
            if (he.endsWith(e)) {
              const me = le[oe++], ye = ne.getAttribute(he).split(h), we = /([.?@])?(.*)/.exec(me);
              ae.push({ type: 1, index: ie, name: we[2], strings: ye, ctor: we[1] === "." ? k : we[1] === "?" ? H$1 : we[1] === "@" ? I$1 : R$2 }), ne.removeAttribute(he);
            } else
              he.startsWith(h) && (ae.push({ type: 6, index: ie }), ne.removeAttribute(he));
        if ($.test(ne.tagName)) {
          const he = ne.textContent.split(h), me = he.length - 1;
          if (me > 0) {
            ne.textContent = i$3 ? i$3.emptyScript : "";
            for (let ye = 0; ye < me; ye++)
              ne.append(he[ye], l$1()), E$1.nextNode(), ae.push({ type: 2, index: ++ie });
            ne.append(he[me], l$1());
          }
        }
      } else if (ne.nodeType === 8)
        if (ne.data === o$1)
          ae.push({ type: 2, index: ie });
        else {
          let he = -1;
          for (; (he = ne.data.indexOf(h, he + 1)) !== -1; )
            ae.push({ type: 7, index: ie }), he += h.length - 1;
        }
      ie++;
    }
  }
  static createElement(X, ee) {
    const te = r$6.createElement("template");
    return te.innerHTML = X, te;
  }
};
function N$1(Y, X, ee = Y, te) {
  var oe, se;
  if (X === w$1)
    return X;
  let ne = te !== void 0 ? (oe = ee._$Co) == null ? void 0 : oe[te] : ee._$Cl;
  const ie = c(X) ? void 0 : X._$litDirective$;
  return (ne == null ? void 0 : ne.constructor) !== ie && ((se = ne == null ? void 0 : ne._$AO) == null || se.call(ne, !1), ie === void 0 ? ne = void 0 : (ne = new ie(Y), ne._$AT(Y, ee, te)), te !== void 0 ? (ee._$Co ?? (ee._$Co = []))[te] = ne : ee._$Cl = ne), ne !== void 0 && (X = N$1(Y, ne._$AS(Y, X.values), ne, te)), X;
}
let S$1 = class {
  constructor(X, ee) {
    this._$AV = [], this._$AN = void 0, this._$AD = X, this._$AM = ee;
  }
  get parentNode() {
    return this._$AM.parentNode;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  u(X) {
    const { el: { content: ee }, parts: te } = this._$AD, ne = ((X == null ? void 0 : X.creationScope) ?? r$6).importNode(ee, !0);
    E$1.currentNode = ne;
    let ie = E$1.nextNode(), oe = 0, se = 0, ae = te[0];
    for (; ae !== void 0; ) {
      if (oe === ae.index) {
        let ue;
        ae.type === 2 ? ue = new M$1(ie, ie.nextSibling, this, X) : ae.type === 1 ? ue = new ae.ctor(ie, ae.name, ae.strings, this, X) : ae.type === 6 && (ue = new L$1(ie, this, X)), this._$AV.push(ue), ae = te[++se];
      }
      oe !== (ae == null ? void 0 : ae.index) && (ie = E$1.nextNode(), oe++);
    }
    return E$1.currentNode = r$6, ne;
  }
  p(X) {
    let ee = 0;
    for (const te of this._$AV)
      te !== void 0 && (te.strings !== void 0 ? (te._$AI(X, te, ee), ee += te.strings.length - 2) : te._$AI(X[ee])), ee++;
  }
}, M$1 = class vY {
  get _$AU() {
    var X;
    return ((X = this._$AM) == null ? void 0 : X._$AU) ?? this._$Cv;
  }
  constructor(X, ee, te, ne) {
    this.type = 2, this._$AH = T$1, this._$AN = void 0, this._$AA = X, this._$AB = ee, this._$AM = te, this.options = ne, this._$Cv = (ne == null ? void 0 : ne.isConnected) ?? !0;
  }
  get parentNode() {
    let X = this._$AA.parentNode;
    const ee = this._$AM;
    return ee !== void 0 && (X == null ? void 0 : X.nodeType) === 11 && (X = ee.parentNode), X;
  }
  get startNode() {
    return this._$AA;
  }
  get endNode() {
    return this._$AB;
  }
  _$AI(X, ee = this) {
    X = N$1(this, X, ee), c(X) ? X === T$1 || X == null || X === "" ? (this._$AH !== T$1 && this._$AR(), this._$AH = T$1) : X !== this._$AH && X !== w$1 && this._(X) : X._$litType$ !== void 0 ? this.$(X) : X.nodeType !== void 0 ? this.T(X) : u$1(X) ? this.k(X) : this._(X);
  }
  S(X) {
    return this._$AA.parentNode.insertBefore(X, this._$AB);
  }
  T(X) {
    this._$AH !== X && (this._$AR(), this._$AH = this.S(X));
  }
  _(X) {
    this._$AH !== T$1 && c(this._$AH) ? this._$AA.nextSibling.data = X : this.T(r$6.createTextNode(X)), this._$AH = X;
  }
  $(X) {
    var ie;
    const { values: ee, _$litType$: te } = X, ne = typeof te == "number" ? this._$AC(X) : (te.el === void 0 && (te.el = V$1.createElement(C$1(te.h, te.h[0]), this.options)), te);
    if (((ie = this._$AH) == null ? void 0 : ie._$AD) === ne)
      this._$AH.p(ee);
    else {
      const oe = new S$1(ne, this), se = oe.u(this.options);
      oe.p(ee), this.T(se), this._$AH = oe;
    }
  }
  _$AC(X) {
    let ee = A$1.get(X.strings);
    return ee === void 0 && A$1.set(X.strings, ee = new V$1(X)), ee;
  }
  k(X) {
    a(this._$AH) || (this._$AH = [], this._$AR());
    const ee = this._$AH;
    let te, ne = 0;
    for (const ie of X)
      ne === ee.length ? ee.push(te = new vY(this.S(l$1()), this.S(l$1()), this, this.options)) : te = ee[ne], te._$AI(ie), ne++;
    ne < ee.length && (this._$AR(te && te._$AB.nextSibling, ne), ee.length = ne);
  }
  _$AR(X = this._$AA.nextSibling, ee) {
    var te;
    for ((te = this._$AP) == null ? void 0 : te.call(this, !1, !0, ee); X && X !== this._$AB; ) {
      const ne = X.nextSibling;
      X.remove(), X = ne;
    }
  }
  setConnected(X) {
    var ee;
    this._$AM === void 0 && (this._$Cv = X, (ee = this._$AP) == null || ee.call(this, X));
  }
}, R$2 = class {
  get tagName() {
    return this.element.tagName;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  constructor(X, ee, te, ne, ie) {
    this.type = 1, this._$AH = T$1, this._$AN = void 0, this.element = X, this.name = ee, this._$AM = ne, this.options = ie, te.length > 2 || te[0] !== "" || te[1] !== "" ? (this._$AH = Array(te.length - 1).fill(new String()), this.strings = te) : this._$AH = T$1;
  }
  _$AI(X, ee = this, te, ne) {
    const ie = this.strings;
    let oe = !1;
    if (ie === void 0)
      X = N$1(this, X, ee, 0), oe = !c(X) || X !== this._$AH && X !== w$1, oe && (this._$AH = X);
    else {
      const se = X;
      let ae, ue;
      for (X = ie[0], ae = 0; ae < ie.length - 1; ae++)
        ue = N$1(this, se[te + ae], ee, ae), ue === w$1 && (ue = this._$AH[ae]), oe || (oe = !c(ue) || ue !== this._$AH[ae]), ue === T$1 ? X = T$1 : X !== T$1 && (X += (ue ?? "") + ie[ae + 1]), this._$AH[ae] = ue;
    }
    oe && !ne && this.j(X);
  }
  j(X) {
    X === T$1 ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, X ?? "");
  }
};
class k extends R$2 {
  constructor() {
    super(...arguments), this.type = 3;
  }
  j(X) {
    this.element[this.name] = X === T$1 ? void 0 : X;
  }
}
let H$1 = class extends R$2 {
  constructor() {
    super(...arguments), this.type = 4;
  }
  j(X) {
    this.element.toggleAttribute(this.name, !!X && X !== T$1);
  }
}, I$1 = class extends R$2 {
  constructor(X, ee, te, ne, ie) {
    super(X, ee, te, ne, ie), this.type = 5;
  }
  _$AI(X, ee = this) {
    if ((X = N$1(this, X, ee, 0) ?? T$1) === w$1)
      return;
    const te = this._$AH, ne = X === T$1 && te !== T$1 || X.capture !== te.capture || X.once !== te.once || X.passive !== te.passive, ie = X !== T$1 && (te === T$1 || ne);
    ne && this.element.removeEventListener(this.name, this, te), ie && this.element.addEventListener(this.name, this, X), this._$AH = X;
  }
  handleEvent(X) {
    var ee;
    typeof this._$AH == "function" ? this._$AH.call(((ee = this.options) == null ? void 0 : ee.host) ?? this.element, X) : this._$AH.handleEvent(X);
  }
}, L$1 = class {
  constructor(X, ee, te) {
    this.element = X, this.type = 6, this._$AN = void 0, this._$AM = ee, this.options = te;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(X) {
    N$1(this, X);
  }
};
const Z = t$2.litHtmlPolyfillSupport;
Z == null || Z(V$1, M$1), (t$2.litHtmlVersions ?? (t$2.litHtmlVersions = [])).push("3.1.2");
const j = (Y, X, ee) => {
  const te = (ee == null ? void 0 : ee.renderBefore) ?? X;
  let ne = te._$litPart$;
  if (ne === void 0) {
    const ie = (ee == null ? void 0 : ee.renderBefore) ?? null;
    te._$litPart$ = ne = new M$1(X.insertBefore(l$1(), ie), ie, void 0, ee ?? {});
  }
  return ne._$AI(Y), ne;
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
let s$1 = class extends b$1 {
  constructor() {
    super(...arguments), this.renderOptions = { host: this }, this._$Do = void 0;
  }
  createRenderRoot() {
    var ee;
    const X = super.createRenderRoot();
    return (ee = this.renderOptions).renderBefore ?? (ee.renderBefore = X.firstChild), X;
  }
  update(X) {
    const ee = this.render();
    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(X), this._$Do = j(ee, this.renderRoot, this.renderOptions);
  }
  connectedCallback() {
    var X;
    super.connectedCallback(), (X = this._$Do) == null || X.setConnected(!0);
  }
  disconnectedCallback() {
    var X;
    super.disconnectedCallback(), (X = this._$Do) == null || X.setConnected(!1);
  }
  render() {
    return w$1;
  }
};
var gY;
s$1._$litElement$ = !0, s$1.finalized = !0, (gY = globalThis.litElementHydrateSupport) == null || gY.call(globalThis, { LitElement: s$1 });
const r$5 = globalThis.litElementPolyfillSupport;
r$5 == null || r$5({ LitElement: s$1 });
(globalThis.litElementVersions ?? (globalThis.litElementVersions = [])).push("4.0.4");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const t$1 = (Y) => (X, ee) => {
  ee !== void 0 ? ee.addInitializer(() => {
    customElements.define(Y, X);
  }) : customElements.define(Y, X);
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const o = { attribute: !0, type: String, converter: u$2, reflect: !1, hasChanged: f$3 }, r$4 = (Y = o, X, ee) => {
  const { kind: te, metadata: ne } = ee;
  let ie = globalThis.litPropertyMetadata.get(ne);
  if (ie === void 0 && globalThis.litPropertyMetadata.set(ne, ie = /* @__PURE__ */ new Map()), ie.set(ee.name, Y), te === "accessor") {
    const { name: oe } = ee;
    return { set(se) {
      const ae = X.get.call(this);
      X.set.call(this, se), this.requestUpdate(oe, ae, Y);
    }, init(se) {
      return se !== void 0 && this.P(oe, void 0, Y), se;
    } };
  }
  if (te === "setter") {
    const { name: oe } = ee;
    return function(se) {
      const ae = this[oe];
      X.call(this, se), this.requestUpdate(oe, ae, Y);
    };
  }
  throw Error("Unsupported decorator location: " + te);
};
function n$1(Y) {
  return (X, ee) => typeof ee == "object" ? r$4(Y, X, ee) : ((te, ne, ie) => {
    const oe = ne.hasOwnProperty(ie);
    return ne.constructor.createProperty(ie, oe ? { ...te, wrapped: !0 } : te), oe ? Object.getOwnPropertyDescriptor(ne, ie) : void 0;
  })(Y, X, ee);
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function r$3(Y) {
  return n$1({ ...Y, state: !0, attribute: !1 });
}
const MetamaskIcon = "data:image/svg+xml,%3csvg%20width='28'%20height='28'%20viewBox='0%200%2028%2028'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%20%3e%3crect%20width='28'%20height='28'%20rx='6'%20fill='white'%20/%3e%3cpath%20d='M24.0892%203.12012L15.3447%209.61478L16.9618%205.78302L24.0892%203.12012Z'%20fill='%23E2761B'%20stroke='%23E2761B'%20stroke-width='0.0878845'%20stroke-linecap='round'%20stroke-linejoin='round'%20/%3e%3cpath%20d='M3.9021%203.12012L12.5763%209.6763L11.0383%205.78302L3.9021%203.12012Z'%20fill='%23E4761B'%20stroke='%23E4761B'%20stroke-width='0.0878845'%20stroke-linecap='round'%20stroke-linejoin='round'%20/%3e%3cpath%20d='M20.943%2018.1748L18.614%2021.7429L23.5971%2023.1139L25.0296%2018.2539L20.943%2018.1748Z'%20fill='%23E4761B'%20stroke='%23E4761B'%20stroke-width='0.0878845'%20stroke-linecap='round'%20stroke-linejoin='round'%20/%3e%3cpath%20d='M2.97925%2018.2539L4.40298%2023.1139L9.38603%2021.7429L7.05709%2018.1748L2.97925%2018.2539Z'%20fill='%23E4761B'%20stroke='%23E4761B'%20stroke-width='0.0878845'%20stroke-linecap='round'%20stroke-linejoin='round'%20/%3e%3cpath%20d='M9.10488%2012.1458L7.71631%2014.2462L12.6642%2014.4659L12.4884%209.14893L9.10488%2012.1458Z'%20fill='%23E4761B'%20stroke='%23E4761B'%20stroke-width='0.0878845'%20stroke-linecap='round'%20stroke-linejoin='round'%20/%3e%3cpath%20d='M18.8862%2012.1458L15.4587%209.0874L15.3445%2014.4659L20.2836%2014.2462L18.8862%2012.1458Z'%20fill='%23E4761B'%20stroke='%23E4761B'%20stroke-width='0.0878845'%20stroke-linecap='round'%20stroke-linejoin='round'%20/%3e%3cpath%20d='M9.38599%2021.7429L12.3565%2020.2928L9.79025%2018.2891L9.38599%2021.7429Z'%20fill='%23E4761B'%20stroke='%23E4761B'%20stroke-width='0.0878845'%20stroke-linecap='round'%20stroke-linejoin='round'%20/%3e%3cpath%20d='M15.6345%2020.2928L18.6138%2021.7429L18.2007%2018.2891L15.6345%2020.2928Z'%20fill='%23E4761B'%20stroke='%23E4761B'%20stroke-width='0.0878845'%20stroke-linecap='round'%20stroke-linejoin='round'%20/%3e%3cpath%20d='M18.6138%2021.7426L15.6345%2020.2925L15.8718%2022.2347L15.8454%2023.0521L18.6138%2021.7426Z'%20fill='%23D7C1B3'%20stroke='%23D7C1B3'%20stroke-width='0.0878845'%20stroke-linecap='round'%20stroke-linejoin='round'%20/%3e%3cpath%20d='M9.38599%2021.7426L12.1543%2023.0521L12.1368%2022.2347L12.3565%2020.2925L9.38599%2021.7426Z'%20fill='%23D7C1B3'%20stroke='%23D7C1B3'%20stroke-width='0.0878845'%20stroke-linecap='round'%20stroke-linejoin='round'%20/%3e%3cpath%20d='M12.1983%2017.0058L9.71997%2016.2763L11.4689%2015.4766L12.1983%2017.0058Z'%20fill='%23233447'%20stroke='%23233447'%20stroke-width='0.0878845'%20stroke-linecap='round'%20stroke-linejoin='round'%20/%3e%3cpath%20d='M15.7927%2017.0058L16.5222%2015.4766L18.2799%2016.2763L15.7927%2017.0058Z'%20fill='%23233447'%20stroke='%23233447'%20stroke-width='0.0878845'%20stroke-linecap='round'%20stroke-linejoin='round'%20/%3e%3cpath%20d='M9.38607%2021.7424L9.80791%2018.1743L7.05713%2018.2534L9.38607%2021.7424Z'%20fill='%23CD6116'%20stroke='%23CD6116'%20stroke-width='0.0878845'%20stroke-linecap='round'%20stroke-linejoin='round'%20/%3e%3cpath%20d='M18.1921%2018.1743L18.614%2021.7424L20.9429%2018.2534L18.1921%2018.1743Z'%20fill='%23CD6116'%20stroke='%23CD6116'%20stroke-width='0.0878845'%20stroke-linecap='round'%20stroke-linejoin='round'%20/%3e%3cpath%20d='M20.2838%2014.2461L15.3447%2014.4658L15.8017%2017.0057L16.5312%2015.4765L18.2889%2016.2762L20.2838%2014.2461Z'%20fill='%23CD6116'%20stroke='%23CD6116'%20stroke-width='0.0878845'%20stroke-linecap='round'%20stroke-linejoin='round'%20/%3e%3cpath%20d='M9.72007%2016.2762L11.4778%2015.4765L12.1984%2017.0057L12.6642%2014.4658L7.71631%2014.2461L9.72007%2016.2762Z'%20fill='%23CD6116'%20stroke='%23CD6116'%20stroke-width='0.0878845'%20stroke-linecap='round'%20stroke-linejoin='round'%20/%3e%3cpath%20d='M7.71631%2014.2461L9.79038%2018.2888L9.72007%2016.2762L7.71631%2014.2461Z'%20fill='%23E4751F'%20stroke='%23E4751F'%20stroke-width='0.0878845'%20stroke-linecap='round'%20stroke-linejoin='round'%20/%3e%3cpath%20d='M18.2888%2016.2762L18.2009%2018.2888L20.2838%2014.2461L18.2888%2016.2762Z'%20fill='%23E4751F'%20stroke='%23E4751F'%20stroke-width='0.0878845'%20stroke-linecap='round'%20stroke-linejoin='round'%20/%3e%3cpath%20d='M12.6643%2014.4658L12.1985%2017.0057L12.7785%2020.0025L12.9103%2016.0565L12.6643%2014.4658Z'%20fill='%23E4751F'%20stroke='%23E4751F'%20stroke-width='0.0878845'%20stroke-linecap='round'%20stroke-linejoin='round'%20/%3e%3cpath%20d='M15.3447%2014.4658L15.1074%2016.0477L15.2129%2020.0025L15.8017%2017.0057L15.3447%2014.4658Z'%20fill='%23E4751F'%20stroke='%23E4751F'%20stroke-width='0.0878845'%20stroke-linecap='round'%20stroke-linejoin='round'%20/%3e%3cpath%20d='M15.8017%2017.0058L15.2129%2020.0027L15.6347%2020.2927L18.201%2018.2889L18.2888%2016.2764L15.8017%2017.0058Z'%20fill='%23F6851B'%20stroke='%23F6851B'%20stroke-width='0.0878845'%20stroke-linecap='round'%20stroke-linejoin='round'%20/%3e%3cpath%20d='M9.71997%2016.2764L9.79028%2018.2889L12.3565%2020.2927L12.7784%2020.0027L12.1983%2017.0058L9.71997%2016.2764Z'%20fill='%23F6851B'%20stroke='%23F6851B'%20stroke-width='0.0878845'%20stroke-linecap='round'%20stroke-linejoin='round'%20/%3e%3cpath%20d='M15.8455%2023.0522L15.8719%2022.2348L15.6522%2022.0415H12.3389L12.1368%2022.2348L12.1543%2023.0522L9.38599%2021.7427L10.3527%2022.5336L12.3125%2023.8958H15.6785L17.6471%2022.5336L18.6139%2021.7427L15.8455%2023.0522Z'%20fill='%23C0AD9E'%20stroke='%23C0AD9E'%20stroke-width='0.0878845'%20stroke-linecap='round'%20stroke-linejoin='round'%20/%3e%3cpath%20d='M15.6348%2020.2925L15.2129%2020.0024H12.7785L12.3567%2020.2925L12.137%2022.2347L12.3391%2022.0414H15.6523L15.8721%2022.2347L15.6348%2020.2925Z'%20fill='%23161616'%20stroke='%23161616'%20stroke-width='0.0878845'%20stroke-linecap='round'%20stroke-linejoin='round'%20/%3e%3cpath%20d='M24.4581%2010.0366L25.2051%206.45094L24.089%203.12012L15.6345%209.39507L18.8862%2012.1459L23.4826%2013.4905L24.5021%2012.304L24.0626%2011.9877L24.7657%2011.3461L24.2208%2010.9243L24.9239%2010.3882L24.4581%2010.0366Z'%20fill='%23763D16'%20stroke='%23763D16'%20stroke-width='0.0878845'%20stroke-linecap='round'%20stroke-linejoin='round'%20/%3e%3cpath%20d='M2.79468%206.45094L3.5417%2010.0366L3.06712%2010.3882L3.7702%2010.9243L3.2341%2011.3461L3.93718%2011.9877L3.49775%2012.304L4.50843%2013.4905L9.10478%2012.1459L12.3565%209.39507L3.90202%203.12012L2.79468%206.45094Z'%20fill='%23763D16'%20stroke='%23763D16'%20stroke-width='0.0878845'%20stroke-linecap='round'%20stroke-linejoin='round'%20/%3e%3cpath%20d='M23.4828%2013.4901L18.8864%2012.1455L20.2838%2014.2459L18.2009%2018.2886L20.9429%2018.2535H25.0296L23.4828%2013.4901Z'%20fill='%23F6851B'%20stroke='%23F6851B'%20stroke-width='0.0878845'%20stroke-linecap='round'%20stroke-linejoin='round'%20/%3e%3cpath%20d='M9.1048%2012.1455L4.50844%2013.4901L2.97925%2018.2535H7.05709L9.7903%2018.2886L7.71622%2014.2459L9.1048%2012.1455Z'%20fill='%23F6851B'%20stroke='%23F6851B'%20stroke-width='0.0878845'%20stroke-linecap='round'%20stroke-linejoin='round'%20/%3e%3cpath%20d='M15.3447%2014.4657L15.6347%209.39477L16.9705%205.78271H11.0383L12.3566%209.39477L12.6642%2014.4657L12.7697%2016.0652L12.7784%2020.0024H15.2128L15.2304%2016.0652L15.3447%2014.4657Z'%20fill='%23F6851B'%20stroke='%23F6851B'%20stroke-width='0.0878845'%20stroke-linecap='round'%20stroke-linejoin='round'%20/%3e%3c/svg%3e", WalletConnectIcon = "data:image/svg+xml,%3csvg%20width='28'%20height='28'%20viewBox='0%200%2028%2028'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%20%3e%3crect%20width='28'%20height='28'%20rx='6'%20fill='%233B99FC'%20/%3e%3cpath%20d='M8.38969%2010.3737C11.4882%207.27518%2016.5118%207.27518%2019.6103%2010.3737L19.9832%2010.7466C20.1382%2010.9015%2020.1382%2011.1527%2019.9832%2011.3076L18.7076%2012.5833C18.6301%2012.6607%2018.5045%2012.6607%2018.4271%2012.5833L17.9139%2012.0701C15.7523%209.90851%2012.2477%209.90851%2010.0861%2012.0701L9.53655%2012.6197C9.45909%2012.6971%209.3335%2012.6971%209.25604%2012.6197L7.98039%2011.344C7.82547%2011.1891%207.82547%2010.9379%207.98039%2010.783L8.38969%2010.3737ZM22.2485%2013.0118L23.3838%2014.1472C23.5387%2014.3021%2023.5387%2014.5533%2023.3838%2014.7082L18.2645%2019.8275C18.1096%2019.9825%2017.8584%2019.9825%2017.7035%2019.8276C17.7035%2019.8276%2017.7035%2019.8276%2017.7035%2019.8276L14.0702%2016.1942C14.0314%2016.1555%2013.9686%2016.1555%2013.9299%2016.1942C13.9299%2016.1942%2013.9299%2016.1942%2013.9299%2016.1942L10.2966%2019.8275C10.1417%2019.9825%209.89053%2019.9825%209.73561%2019.8276C9.7356%2019.8276%209.7356%2019.8276%209.7356%2019.8276L4.61619%2014.7081C4.46127%2014.5532%204.46127%2014.302%204.61619%2014.1471L5.75152%2013.0118C5.90645%2012.8569%206.15763%2012.8569%206.31255%2013.0118L9.94595%2016.6452C9.98468%2016.6839%2010.0475%2016.6839%2010.0862%2016.6452C10.0862%2016.6452%2010.0862%2016.6452%2010.0862%2016.6452L13.7194%2013.0118C13.8743%2012.8568%2014.1255%2012.8568%2014.2805%2013.0118C14.2805%2013.0118%2014.2805%2013.0118%2014.2805%2013.0118L17.9139%2016.6452C17.9526%2016.6839%2018.0154%2016.6839%2018.0541%2016.6452L21.6874%2013.0118C21.8424%2012.8569%2022.0936%2012.8569%2022.2485%2013.0118Z'%20fill='white'%20/%3e%3c/svg%3e", version$k = "2.7.19", getUrl$1 = (Y) => Y, getVersion$1 = () => `viem@${version$k}`;
let BaseError$1 = class ZX extends Error {
  constructor(X, ee = {}) {
    var ie;
    super(), Object.defineProperty(this, "details", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "docsPath", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "metaMessages", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "shortMessage", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ViemError"
    }), Object.defineProperty(this, "version", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: getVersion$1()
    });
    const te = ee.cause instanceof ZX ? ee.cause.details : (ie = ee.cause) != null && ie.message ? ee.cause.message : ee.details, ne = ee.cause instanceof ZX && ee.cause.docsPath || ee.docsPath;
    this.message = [
      X || "An error occurred.",
      "",
      ...ee.metaMessages ? [...ee.metaMessages, ""] : [],
      ...ne ? [
        `Docs: https://viem.sh${ne}${ee.docsSlug ? `#${ee.docsSlug}` : ""}`
      ] : [],
      ...te ? [`Details: ${te}`] : [],
      `Version: ${this.version}`
    ].join(`
`), ee.cause && (this.cause = ee.cause), this.details = te, this.docsPath = ne, this.metaMessages = ee.metaMessages, this.shortMessage = X;
  }
  walk(X) {
    return walk(this, X);
  }
};
function walk(Y, X) {
  return X != null && X(Y) ? Y : Y && typeof Y == "object" && "cause" in Y ? walk(Y.cause, X) : X ? null : Y;
}
class IntegerOutOfRangeError extends BaseError$1 {
  constructor({ max: X, min: ee, signed: te, size: ne, value: ie }) {
    super(`Number "${ie}" is not in safe ${ne ? `${ne * 8}-bit ${te ? "signed" : "unsigned"} ` : ""}integer range ${X ? `(${ee} to ${X})` : `(above ${ee})`}`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "IntegerOutOfRangeError"
    });
  }
}
class SizeOverflowError extends BaseError$1 {
  constructor({ givenSize: X, maxSize: ee }) {
    super(`Size cannot exceed ${ee} bytes. Given size: ${X} bytes.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "SizeOverflowError"
    });
  }
}
class SizeExceedsPaddingSizeError extends BaseError$1 {
  constructor({ size: X, targetSize: ee, type: te }) {
    super(`${te.charAt(0).toUpperCase()}${te.slice(1).toLowerCase()} size (${X}) exceeds padding size (${ee}).`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "SizeExceedsPaddingSizeError"
    });
  }
}
function pad(Y, { dir: X, size: ee = 32 } = {}) {
  return typeof Y == "string" ? padHex(Y, { dir: X, size: ee }) : padBytes(Y, { dir: X, size: ee });
}
function padHex(Y, { dir: X, size: ee = 32 } = {}) {
  if (ee === null)
    return Y;
  const te = Y.replace("0x", "");
  if (te.length > ee * 2)
    throw new SizeExceedsPaddingSizeError({
      size: Math.ceil(te.length / 2),
      targetSize: ee,
      type: "hex"
    });
  return `0x${te[X === "right" ? "padEnd" : "padStart"](ee * 2, "0")}`;
}
function padBytes(Y, { dir: X, size: ee = 32 } = {}) {
  if (ee === null)
    return Y;
  if (Y.length > ee)
    throw new SizeExceedsPaddingSizeError({
      size: Y.length,
      targetSize: ee,
      type: "bytes"
    });
  const te = new Uint8Array(ee);
  for (let ne = 0; ne < ee; ne++) {
    const ie = X === "right";
    te[ie ? ne : ee - ne - 1] = Y[ie ? ne : Y.length - ne - 1];
  }
  return te;
}
function isHex(Y, { strict: X = !0 } = {}) {
  return !Y || typeof Y != "string" ? !1 : X ? /^0x[0-9a-fA-F]*$/.test(Y) : Y.startsWith("0x");
}
function size$2(Y) {
  return isHex(Y, { strict: !1 }) ? Math.ceil((Y.length - 2) / 2) : Y.length;
}
function trim(Y, { dir: X = "left" } = {}) {
  let ee = typeof Y == "string" ? Y.replace("0x", "") : Y, te = 0;
  for (let ne = 0; ne < ee.length - 1 && ee[X === "left" ? ne : ee.length - ne - 1].toString() === "0"; ne++)
    te++;
  return ee = X === "left" ? ee.slice(te) : ee.slice(0, ee.length - te), typeof Y == "string" ? (ee.length === 1 && X === "right" && (ee = `${ee}0`), `0x${ee.length % 2 === 1 ? `0${ee}` : ee}`) : ee;
}
const encoder$1 = /* @__PURE__ */ new TextEncoder();
function toBytes$2(Y, X = {}) {
  return typeof Y == "number" || typeof Y == "bigint" ? numberToBytes(Y, X) : typeof Y == "boolean" ? boolToBytes(Y, X) : isHex(Y) ? hexToBytes$1(Y, X) : stringToBytes$1(Y, X);
}
function boolToBytes(Y, X = {}) {
  const ee = new Uint8Array(1);
  return ee[0] = Number(Y), typeof X.size == "number" ? (assertSize(ee, { size: X.size }), pad(ee, { size: X.size })) : ee;
}
const charCodeMap = {
  zero: 48,
  nine: 57,
  A: 65,
  F: 70,
  a: 97,
  f: 102
};
function charCodeToBase16(Y) {
  if (Y >= charCodeMap.zero && Y <= charCodeMap.nine)
    return Y - charCodeMap.zero;
  if (Y >= charCodeMap.A && Y <= charCodeMap.F)
    return Y - (charCodeMap.A - 10);
  if (Y >= charCodeMap.a && Y <= charCodeMap.f)
    return Y - (charCodeMap.a - 10);
}
function hexToBytes$1(Y, X = {}) {
  let ee = Y;
  X.size && (assertSize(ee, { size: X.size }), ee = pad(ee, { dir: "right", size: X.size }));
  let te = ee.slice(2);
  te.length % 2 && (te = `0${te}`);
  const ne = te.length / 2, ie = new Uint8Array(ne);
  for (let oe = 0, se = 0; oe < ne; oe++) {
    const ae = charCodeToBase16(te.charCodeAt(se++)), ue = charCodeToBase16(te.charCodeAt(se++));
    if (ae === void 0 || ue === void 0)
      throw new BaseError$1(`Invalid byte sequence ("${te[se - 2]}${te[se - 1]}" in "${te}").`);
    ie[oe] = ae * 16 + ue;
  }
  return ie;
}
function numberToBytes(Y, X) {
  const ee = numberToHex(Y, X);
  return hexToBytes$1(ee);
}
function stringToBytes$1(Y, X = {}) {
  const ee = encoder$1.encode(Y);
  return typeof X.size == "number" ? (assertSize(ee, { size: X.size }), pad(ee, { dir: "right", size: X.size })) : ee;
}
function assertSize(Y, { size: X }) {
  if (size$2(Y) > X)
    throw new SizeOverflowError({
      givenSize: size$2(Y),
      maxSize: X
    });
}
function hexToBigInt(Y, X = {}) {
  const { signed: ee } = X;
  X.size && assertSize(Y, { size: X.size });
  const te = BigInt(Y);
  if (!ee)
    return te;
  const ne = (Y.length - 2) / 2, ie = (1n << BigInt(ne) * 8n - 1n) - 1n;
  return te <= ie ? te : te - BigInt(`0x${"f".padStart(ne * 2, "f")}`) - 1n;
}
function hexToNumber$1(Y, X = {}) {
  return Number(hexToBigInt(Y, X));
}
const hexes$1 = /* @__PURE__ */ Array.from({ length: 256 }, (Y, X) => X.toString(16).padStart(2, "0"));
function toHex$2(Y, X = {}) {
  return typeof Y == "number" || typeof Y == "bigint" ? numberToHex(Y, X) : typeof Y == "string" ? stringToHex(Y, X) : typeof Y == "boolean" ? boolToHex(Y, X) : bytesToHex$1(Y, X);
}
function boolToHex(Y, X = {}) {
  const ee = `0x${Number(Y)}`;
  return typeof X.size == "number" ? (assertSize(ee, { size: X.size }), pad(ee, { size: X.size })) : ee;
}
function bytesToHex$1(Y, X = {}) {
  let ee = "";
  for (let ne = 0; ne < Y.length; ne++)
    ee += hexes$1[Y[ne]];
  const te = `0x${ee}`;
  return typeof X.size == "number" ? (assertSize(te, { size: X.size }), pad(te, { dir: "right", size: X.size })) : te;
}
function numberToHex(Y, X = {}) {
  const { signed: ee, size: te } = X, ne = BigInt(Y);
  let ie;
  te ? ee ? ie = (1n << BigInt(te) * 8n - 1n) - 1n : ie = 2n ** (BigInt(te) * 8n) - 1n : typeof Y == "number" && (ie = BigInt(Number.MAX_SAFE_INTEGER));
  const oe = typeof ie == "bigint" && ee ? -ie - 1n : 0;
  if (ie && ne > ie || ne < oe) {
    const ae = typeof Y == "bigint" ? "n" : "";
    throw new IntegerOutOfRangeError({
      max: ie ? `${ie}${ae}` : void 0,
      min: `${oe}${ae}`,
      signed: ee,
      size: te,
      value: `${Y}${ae}`
    });
  }
  const se = `0x${(ee && ne < 0 ? (1n << BigInt(te * 8)) + BigInt(ne) : ne).toString(16)}`;
  return te ? pad(se, { size: te }) : se;
}
const encoder = /* @__PURE__ */ new TextEncoder();
function stringToHex(Y, X = {}) {
  const ee = encoder.encode(Y);
  return bytesToHex$1(ee, X);
}
function concatHex(Y) {
  return `0x${Y.reduce((X, ee) => X + ee.replace("0x", ""), "")}`;
}
class InvalidAddressError extends BaseError$1 {
  constructor({ address: X }) {
    super(`Address "${X}" is invalid.`, {
      metaMessages: [
        "- Address must be a hex value of 20 bytes (40 hex characters).",
        "- Address must match its checksum counterpart."
      ]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidAddressError"
    });
  }
}
class LruMap extends Map {
  constructor(X) {
    super(), Object.defineProperty(this, "maxSize", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.maxSize = X;
  }
  set(X, ee) {
    return super.set(X, ee), this.maxSize && this.size > this.maxSize && this.delete(this.keys().next().value), this;
  }
}
function number$3(Y) {
  if (!Number.isSafeInteger(Y) || Y < 0)
    throw new Error(`Wrong positive integer: ${Y}`);
}
function bytes$2(Y, ...X) {
  if (!(Y instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (X.length > 0 && !X.includes(Y.length))
    throw new Error(`Expected Uint8Array of length ${X}, not of length=${Y.length}`);
}
function exists$2(Y, X = !0) {
  if (Y.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (X && Y.finished)
    throw new Error("Hash#digest() has already been called");
}
function output$2(Y, X) {
  bytes$2(Y);
  const ee = X.outputLen;
  if (Y.length < ee)
    throw new Error(`digestInto() expects output buffer of length at least ${ee}`);
}
const U32_MASK64$2 = /* @__PURE__ */ BigInt(2 ** 32 - 1), _32n$2 = /* @__PURE__ */ BigInt(32);
function fromBig$2(Y, X = !1) {
  return X ? { h: Number(Y & U32_MASK64$2), l: Number(Y >> _32n$2 & U32_MASK64$2) } : { h: Number(Y >> _32n$2 & U32_MASK64$2) | 0, l: Number(Y & U32_MASK64$2) | 0 };
}
function split$2(Y, X = !1) {
  let ee = new Uint32Array(Y.length), te = new Uint32Array(Y.length);
  for (let ne = 0; ne < Y.length; ne++) {
    const { h: ie, l: oe } = fromBig$2(Y[ne], X);
    [ee[ne], te[ne]] = [ie, oe];
  }
  return [ee, te];
}
const rotlSH$2 = (Y, X, ee) => Y << ee | X >>> 32 - ee, rotlSL$2 = (Y, X, ee) => X << ee | Y >>> 32 - ee, rotlBH$2 = (Y, X, ee) => X << ee - 32 | Y >>> 64 - ee, rotlBL$2 = (Y, X, ee) => Y << ee - 32 | X >>> 64 - ee;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const u8a = (Y) => Y instanceof Uint8Array, u32$1 = (Y) => new Uint32Array(Y.buffer, Y.byteOffset, Math.floor(Y.byteLength / 4)), isLE$1 = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!isLE$1)
  throw new Error("Non little-endian hardware is not supported");
function utf8ToBytes$2(Y) {
  if (typeof Y != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof Y}`);
  return new Uint8Array(new TextEncoder().encode(Y));
}
function toBytes$1(Y) {
  if (typeof Y == "string" && (Y = utf8ToBytes$2(Y)), !u8a(Y))
    throw new Error(`expected Uint8Array, got ${typeof Y}`);
  return Y;
}
let Hash$8 = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
function wrapConstructor$1(Y) {
  const X = (te) => Y().update(toBytes$1(te)).digest(), ee = Y();
  return X.outputLen = ee.outputLen, X.blockLen = ee.blockLen, X.create = () => Y(), X;
}
const [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []], _0n$5 = /* @__PURE__ */ BigInt(0), _1n$7 = /* @__PURE__ */ BigInt(1), _2n$5 = /* @__PURE__ */ BigInt(2), _7n = /* @__PURE__ */ BigInt(7), _256n = /* @__PURE__ */ BigInt(256), _0x71n = /* @__PURE__ */ BigInt(113);
for (let Y = 0, X = _1n$7, ee = 1, te = 0; Y < 24; Y++) {
  [ee, te] = [te, (2 * ee + 3 * te) % 5], SHA3_PI.push(2 * (5 * te + ee)), SHA3_ROTL.push((Y + 1) * (Y + 2) / 2 % 64);
  let ne = _0n$5;
  for (let ie = 0; ie < 7; ie++)
    X = (X << _1n$7 ^ (X >> _7n) * _0x71n) % _256n, X & _2n$5 && (ne ^= _1n$7 << (_1n$7 << /* @__PURE__ */ BigInt(ie)) - _1n$7);
  _SHA3_IOTA.push(ne);
}
const [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ split$2(_SHA3_IOTA, !0), rotlH = (Y, X, ee) => ee > 32 ? rotlBH$2(Y, X, ee) : rotlSH$2(Y, X, ee), rotlL = (Y, X, ee) => ee > 32 ? rotlBL$2(Y, X, ee) : rotlSL$2(Y, X, ee);
function keccakP(Y, X = 24) {
  const ee = new Uint32Array(10);
  for (let te = 24 - X; te < 24; te++) {
    for (let oe = 0; oe < 10; oe++)
      ee[oe] = Y[oe] ^ Y[oe + 10] ^ Y[oe + 20] ^ Y[oe + 30] ^ Y[oe + 40];
    for (let oe = 0; oe < 10; oe += 2) {
      const se = (oe + 8) % 10, ae = (oe + 2) % 10, ue = ee[ae], le = ee[ae + 1], he = rotlH(ue, le, 1) ^ ee[se], me = rotlL(ue, le, 1) ^ ee[se + 1];
      for (let ye = 0; ye < 50; ye += 10)
        Y[oe + ye] ^= he, Y[oe + ye + 1] ^= me;
    }
    let ne = Y[2], ie = Y[3];
    for (let oe = 0; oe < 24; oe++) {
      const se = SHA3_ROTL[oe], ae = rotlH(ne, ie, se), ue = rotlL(ne, ie, se), le = SHA3_PI[oe];
      ne = Y[le], ie = Y[le + 1], Y[le] = ae, Y[le + 1] = ue;
    }
    for (let oe = 0; oe < 50; oe += 10) {
      for (let se = 0; se < 10; se++)
        ee[se] = Y[oe + se];
      for (let se = 0; se < 10; se++)
        Y[oe + se] ^= ~ee[(se + 2) % 10] & ee[(se + 4) % 10];
    }
    Y[0] ^= SHA3_IOTA_H[te], Y[1] ^= SHA3_IOTA_L[te];
  }
  ee.fill(0);
}
class Keccak extends Hash$8 {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(X, ee, te, ne = !1, ie = 24) {
    if (super(), this.blockLen = X, this.suffix = ee, this.outputLen = te, this.enableXOF = ne, this.rounds = ie, this.pos = 0, this.posOut = 0, this.finished = !1, this.destroyed = !1, number$3(te), 0 >= this.blockLen || this.blockLen >= 200)
      throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200), this.state32 = u32$1(this.state);
  }
  keccak() {
    keccakP(this.state32, this.rounds), this.posOut = 0, this.pos = 0;
  }
  update(X) {
    exists$2(this);
    const { blockLen: ee, state: te } = this;
    X = toBytes$1(X);
    const ne = X.length;
    for (let ie = 0; ie < ne; ) {
      const oe = Math.min(ee - this.pos, ne - ie);
      for (let se = 0; se < oe; se++)
        te[this.pos++] ^= X[ie++];
      this.pos === ee && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = !0;
    const { state: X, suffix: ee, pos: te, blockLen: ne } = this;
    X[te] ^= ee, ee & 128 && te === ne - 1 && this.keccak(), X[ne - 1] ^= 128, this.keccak();
  }
  writeInto(X) {
    exists$2(this, !1), bytes$2(X), this.finish();
    const ee = this.state, { blockLen: te } = this;
    for (let ne = 0, ie = X.length; ne < ie; ) {
      this.posOut >= te && this.keccak();
      const oe = Math.min(te - this.posOut, ie - ne);
      X.set(ee.subarray(this.posOut, this.posOut + oe), ne), this.posOut += oe, ne += oe;
    }
    return X;
  }
  xofInto(X) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(X);
  }
  xof(X) {
    return number$3(X), this.xofInto(new Uint8Array(X));
  }
  digestInto(X) {
    if (output$2(X, this), this.finished)
      throw new Error("digest() was already called");
    return this.writeInto(X), this.destroy(), X;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = !0, this.state.fill(0);
  }
  _cloneInto(X) {
    const { blockLen: ee, suffix: te, outputLen: ne, rounds: ie, enableXOF: oe } = this;
    return X || (X = new Keccak(ee, te, ne, oe, ie)), X.state32.set(this.state32), X.pos = this.pos, X.posOut = this.posOut, X.finished = this.finished, X.rounds = ie, X.suffix = te, X.outputLen = ne, X.enableXOF = oe, X.destroyed = this.destroyed, X;
  }
}
const gen = (Y, X, ee) => wrapConstructor$1(() => new Keccak(X, Y, ee)), keccak_256 = /* @__PURE__ */ gen(1, 136, 256 / 8);
function keccak256$1(Y, X) {
  const ee = X || "hex", te = keccak_256(isHex(Y, { strict: !1 }) ? toBytes$2(Y) : Y);
  return ee === "bytes" ? te : toHex$2(te);
}
function checksumAddress(Y, X) {
  const ee = X ? `${X}${Y.toLowerCase()}` : Y.substring(2).toLowerCase(), te = keccak256$1(stringToBytes$1(ee), "bytes"), ne = (X ? ee.substring(`${X}0x`.length) : ee).split("");
  for (let ie = 0; ie < 40; ie += 2)
    te[ie >> 1] >> 4 >= 8 && ne[ie] && (ne[ie] = ne[ie].toUpperCase()), (te[ie >> 1] & 15) >= 8 && ne[ie + 1] && (ne[ie + 1] = ne[ie + 1].toUpperCase());
  return `0x${ne.join("")}`;
}
function getAddress$1(Y, X) {
  if (!isAddress(Y))
    throw new InvalidAddressError({ address: Y });
  return checksumAddress(Y, X);
}
const addressRegex = /^0x[a-fA-F0-9]{40}$/, isAddressCache = /* @__PURE__ */ new LruMap(8192);
function isAddress(Y, { strict: X = !0 } = {}) {
  if (isAddressCache.has(Y))
    return isAddressCache.get(Y);
  const ee = addressRegex.test(Y) ? Y.toLowerCase() === Y ? !0 : X ? checksumAddress(Y) === Y : !0 : !1;
  return isAddressCache.set(Y, ee), ee;
}
function parseAccount(Y) {
  return typeof Y == "string" ? { address: Y, type: "json-rpc" } : Y;
}
class InvalidChainIdError extends BaseError$1 {
  constructor({ chainId: X }) {
    super(typeof X == "number" ? `Chain ID "${X}" is invalid.` : "Chain ID is invalid."), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidChainIdError"
    });
  }
}
const gweiUnits = {
  ether: -9,
  wei: 9
};
function formatUnits(Y, X) {
  let ee = Y.toString();
  const te = ee.startsWith("-");
  te && (ee = ee.slice(1)), ee = ee.padStart(X, "0");
  let [ne, ie] = [
    ee.slice(0, ee.length - X),
    ee.slice(ee.length - X)
  ];
  return ie = ie.replace(/(0+)$/, ""), `${te ? "-" : ""}${ne || "0"}${ie ? `.${ie}` : ""}`;
}
function formatGwei(Y, X = "wei") {
  return formatUnits(Y, gweiUnits[X]);
}
class FeeCapTooHighError extends BaseError$1 {
  constructor({ cause: X, maxFeePerGas: ee } = {}) {
    super(`The fee cap (\`maxFeePerGas\`${ee ? ` = ${formatGwei(ee)} gwei` : ""}) cannot be higher than the maximum allowed value (2^256-1).`, {
      cause: X
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "FeeCapTooHigh"
    });
  }
}
Object.defineProperty(FeeCapTooHighError, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /max fee per gas higher than 2\^256-1|fee cap higher than 2\^256-1/
});
class TipAboveFeeCapError extends BaseError$1 {
  constructor({ cause: X, maxPriorityFeePerGas: ee, maxFeePerGas: te } = {}) {
    super([
      `The provided tip (\`maxPriorityFeePerGas\`${ee ? ` = ${formatGwei(ee)} gwei` : ""}) cannot be higher than the fee cap (\`maxFeePerGas\`${te ? ` = ${formatGwei(te)} gwei` : ""}).`
    ].join(`
`), {
      cause: X
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "TipAboveFeeCapError"
    });
  }
}
Object.defineProperty(TipAboveFeeCapError, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /max priority fee per gas higher than max fee per gas|tip higher than fee cap/
});
function prettyPrint(Y) {
  const X = Object.entries(Y).map(([te, ne]) => ne === void 0 || ne === !1 ? null : [te, ne]).filter(Boolean), ee = X.reduce((te, [ne]) => Math.max(te, ne.length), 0);
  return X.map(([te, ne]) => `  ${`${te}:`.padEnd(ee + 1)}  ${ne}`).join(`
`);
}
class InvalidLegacyVError extends BaseError$1 {
  constructor({ v: X }) {
    super(`Invalid \`v\` value "${X}". Expected 27 or 28.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidLegacyVError"
    });
  }
}
class InvalidSerializableTransactionError extends BaseError$1 {
  constructor({ transaction: X }) {
    super("Cannot infer a transaction type from provided transaction.", {
      metaMessages: [
        "Provided Transaction:",
        "{",
        prettyPrint(X),
        "}",
        "",
        "To infer the type, either provide:",
        "- a `type` to the Transaction, or",
        "- an EIP-1559 Transaction with `maxFeePerGas`, or",
        "- an EIP-2930 Transaction with `gasPrice` & `accessList`, or",
        "- a Legacy Transaction with `gasPrice`"
      ]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidSerializableTransactionError"
    });
  }
}
class InvalidStorageKeySizeError extends BaseError$1 {
  constructor({ storageKey: X }) {
    super(`Size for storage key "${X}" is invalid. Expected 32 bytes. Got ${Math.floor((X.length - 2) / 2)} bytes.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidStorageKeySizeError"
    });
  }
}
const stringify$2 = (Y, X, ee) => JSON.stringify(Y, (te, ne) => {
  const ie = typeof ne == "bigint" ? ne.toString() : ne;
  return typeof X == "function" ? X(te, ie) : ie;
}, ee);
class HttpRequestError extends BaseError$1 {
  constructor({ body: X, details: ee, headers: te, status: ne, url: ie }) {
    super("HTTP request failed.", {
      details: ee,
      metaMessages: [
        ne && `Status: ${ne}`,
        `URL: ${getUrl$1(ie)}`,
        X && `Request body: ${stringify$2(X)}`
      ].filter(Boolean)
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "HttpRequestError"
    }), Object.defineProperty(this, "body", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "headers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "status", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "url", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.body = X, this.headers = te, this.status = ne, this.url = ie;
  }
}
class RpcRequestError extends BaseError$1 {
  constructor({ body: X, error: ee, url: te }) {
    super("RPC Request failed.", {
      cause: ee,
      details: ee.message,
      metaMessages: [`URL: ${getUrl$1(te)}`, `Request body: ${stringify$2(X)}`]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "RpcRequestError"
    }), Object.defineProperty(this, "code", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.code = ee.code;
  }
}
class TimeoutError extends BaseError$1 {
  constructor({ body: X, url: ee }) {
    super("The request took too long to respond.", {
      details: "The request timed out.",
      metaMessages: [`URL: ${getUrl$1(ee)}`, `Request body: ${stringify$2(X)}`]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "TimeoutError"
    });
  }
}
const unknownErrorCode = -1;
class RpcError extends BaseError$1 {
  constructor(X, { code: ee, docsPath: te, metaMessages: ne, shortMessage: ie }) {
    super(ie, {
      cause: X,
      docsPath: te,
      metaMessages: ne || (X == null ? void 0 : X.metaMessages)
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "RpcError"
    }), Object.defineProperty(this, "code", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.name = X.name, this.code = X instanceof RpcRequestError ? X.code : ee ?? unknownErrorCode;
  }
}
class ProviderRpcError extends RpcError {
  constructor(X, ee) {
    super(X, ee), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ProviderRpcError"
    }), Object.defineProperty(this, "data", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.data = ee.data;
  }
}
class ParseRpcError extends RpcError {
  constructor(X) {
    super(X, {
      code: ParseRpcError.code,
      shortMessage: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ParseRpcError"
    });
  }
}
Object.defineProperty(ParseRpcError, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32700
});
class InvalidRequestRpcError extends RpcError {
  constructor(X) {
    super(X, {
      code: InvalidRequestRpcError.code,
      shortMessage: "JSON is not a valid request object."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidRequestRpcError"
    });
  }
}
Object.defineProperty(InvalidRequestRpcError, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32600
});
class MethodNotFoundRpcError extends RpcError {
  constructor(X) {
    super(X, {
      code: MethodNotFoundRpcError.code,
      shortMessage: "The method does not exist / is not available."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "MethodNotFoundRpcError"
    });
  }
}
Object.defineProperty(MethodNotFoundRpcError, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32601
});
class InvalidParamsRpcError extends RpcError {
  constructor(X) {
    super(X, {
      code: InvalidParamsRpcError.code,
      shortMessage: [
        "Invalid parameters were provided to the RPC method.",
        "Double check you have provided the correct parameters."
      ].join(`
`)
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidParamsRpcError"
    });
  }
}
Object.defineProperty(InvalidParamsRpcError, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32602
});
class InternalRpcError extends RpcError {
  constructor(X) {
    super(X, {
      code: InternalRpcError.code,
      shortMessage: "An internal error was received."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InternalRpcError"
    });
  }
}
Object.defineProperty(InternalRpcError, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32603
});
class InvalidInputRpcError extends RpcError {
  constructor(X) {
    super(X, {
      code: InvalidInputRpcError.code,
      shortMessage: [
        "Missing or invalid parameters.",
        "Double check you have provided the correct parameters."
      ].join(`
`)
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidInputRpcError"
    });
  }
}
Object.defineProperty(InvalidInputRpcError, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32e3
});
class ResourceNotFoundRpcError extends RpcError {
  constructor(X) {
    super(X, {
      code: ResourceNotFoundRpcError.code,
      shortMessage: "Requested resource not found."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ResourceNotFoundRpcError"
    });
  }
}
Object.defineProperty(ResourceNotFoundRpcError, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32001
});
class ResourceUnavailableRpcError extends RpcError {
  constructor(X) {
    super(X, {
      code: ResourceUnavailableRpcError.code,
      shortMessage: "Requested resource not available."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ResourceUnavailableRpcError"
    });
  }
}
Object.defineProperty(ResourceUnavailableRpcError, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32002
});
class TransactionRejectedRpcError extends RpcError {
  constructor(X) {
    super(X, {
      code: TransactionRejectedRpcError.code,
      shortMessage: "Transaction creation failed."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "TransactionRejectedRpcError"
    });
  }
}
Object.defineProperty(TransactionRejectedRpcError, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32003
});
class MethodNotSupportedRpcError extends RpcError {
  constructor(X) {
    super(X, {
      code: MethodNotSupportedRpcError.code,
      shortMessage: "Method is not implemented."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "MethodNotSupportedRpcError"
    });
  }
}
Object.defineProperty(MethodNotSupportedRpcError, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32004
});
class LimitExceededRpcError extends RpcError {
  constructor(X) {
    super(X, {
      code: LimitExceededRpcError.code,
      shortMessage: "Request exceeds defined limit."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "LimitExceededRpcError"
    });
  }
}
Object.defineProperty(LimitExceededRpcError, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32005
});
class JsonRpcVersionUnsupportedError extends RpcError {
  constructor(X) {
    super(X, {
      code: JsonRpcVersionUnsupportedError.code,
      shortMessage: "Version of JSON-RPC protocol is not supported."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "JsonRpcVersionUnsupportedError"
    });
  }
}
Object.defineProperty(JsonRpcVersionUnsupportedError, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32006
});
class UserRejectedRequestError extends ProviderRpcError {
  constructor(X) {
    super(X, {
      code: UserRejectedRequestError.code,
      shortMessage: "User rejected the request."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "UserRejectedRequestError"
    });
  }
}
Object.defineProperty(UserRejectedRequestError, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 4001
});
class UnauthorizedProviderError extends ProviderRpcError {
  constructor(X) {
    super(X, {
      code: UnauthorizedProviderError.code,
      shortMessage: "The requested method and/or account has not been authorized by the user."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "UnauthorizedProviderError"
    });
  }
}
Object.defineProperty(UnauthorizedProviderError, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 4100
});
class UnsupportedProviderMethodError extends ProviderRpcError {
  constructor(X) {
    super(X, {
      code: UnsupportedProviderMethodError.code,
      shortMessage: "The Provider does not support the requested method."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "UnsupportedProviderMethodError"
    });
  }
}
Object.defineProperty(UnsupportedProviderMethodError, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 4200
});
class ProviderDisconnectedError extends ProviderRpcError {
  constructor(X) {
    super(X, {
      code: ProviderDisconnectedError.code,
      shortMessage: "The Provider is disconnected from all chains."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ProviderDisconnectedError"
    });
  }
}
Object.defineProperty(ProviderDisconnectedError, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 4900
});
class ChainDisconnectedError extends ProviderRpcError {
  constructor(X) {
    super(X, {
      code: ChainDisconnectedError.code,
      shortMessage: "The Provider is not connected to the requested chain."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ChainDisconnectedError"
    });
  }
}
Object.defineProperty(ChainDisconnectedError, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 4901
});
class SwitchChainError extends ProviderRpcError {
  constructor(X) {
    super(X, {
      code: SwitchChainError.code,
      shortMessage: "An error occurred when attempting to switch chain."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "SwitchChainError"
    });
  }
}
Object.defineProperty(SwitchChainError, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 4902
});
class UnknownRpcError extends RpcError {
  constructor(X) {
    super(X, {
      shortMessage: "An unknown RPC error occurred."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "UnknownRpcError"
    });
  }
}
function defineFormatter(Y, X) {
  return ({ exclude: ee, format: te }) => ({
    exclude: ee,
    format: (ne) => {
      const ie = X(ne);
      if (ee)
        for (const oe of ee)
          delete ie[oe];
      return {
        ...ie,
        ...te(ne)
      };
    },
    type: Y
  });
}
const transactionType = {
  "0x0": "legacy",
  "0x1": "eip2930",
  "0x2": "eip1559",
  "0x3": "eip4844"
};
function formatTransaction(Y) {
  const X = {
    ...Y,
    blockHash: Y.blockHash ? Y.blockHash : null,
    blockNumber: Y.blockNumber ? BigInt(Y.blockNumber) : null,
    chainId: Y.chainId ? hexToNumber$1(Y.chainId) : void 0,
    gas: Y.gas ? BigInt(Y.gas) : void 0,
    gasPrice: Y.gasPrice ? BigInt(Y.gasPrice) : void 0,
    maxFeePerBlobGas: Y.maxFeePerBlobGas ? BigInt(Y.maxFeePerBlobGas) : void 0,
    maxFeePerGas: Y.maxFeePerGas ? BigInt(Y.maxFeePerGas) : void 0,
    maxPriorityFeePerGas: Y.maxPriorityFeePerGas ? BigInt(Y.maxPriorityFeePerGas) : void 0,
    nonce: Y.nonce ? hexToNumber$1(Y.nonce) : void 0,
    to: Y.to ? Y.to : null,
    transactionIndex: Y.transactionIndex ? Number(Y.transactionIndex) : null,
    type: Y.type ? transactionType[Y.type] : void 0,
    typeHex: Y.type ? Y.type : void 0,
    value: Y.value ? BigInt(Y.value) : void 0,
    v: Y.v ? BigInt(Y.v) : void 0
  };
  return X.yParity = (() => {
    if (Y.yParity)
      return Number(Y.yParity);
    if (typeof X.v == "bigint") {
      if (X.v === 0n || X.v === 27n)
        return 0;
      if (X.v === 1n || X.v === 28n)
        return 1;
      if (X.v >= 35n)
        return X.v % 2n === 0n ? 1 : 0;
    }
  })(), X.type === "legacy" && (delete X.accessList, delete X.maxFeePerBlobGas, delete X.maxFeePerGas, delete X.maxPriorityFeePerGas, delete X.yParity), X.type === "eip2930" && (delete X.maxFeePerBlobGas, delete X.maxFeePerGas, delete X.maxPriorityFeePerGas), X.type === "eip1559" && delete X.maxFeePerBlobGas, X;
}
const defineTransaction = /* @__PURE__ */ defineFormatter("transaction", formatTransaction);
function formatBlock(Y) {
  var ee;
  const X = (ee = Y.transactions) == null ? void 0 : ee.map((te) => typeof te == "string" ? te : formatTransaction(te));
  return {
    ...Y,
    baseFeePerGas: Y.baseFeePerGas ? BigInt(Y.baseFeePerGas) : null,
    blobGasUsed: Y.blobGasUsed ? BigInt(Y.blobGasUsed) : void 0,
    difficulty: Y.difficulty ? BigInt(Y.difficulty) : void 0,
    excessBlobGas: Y.excessBlobGas ? BigInt(Y.excessBlobGas) : void 0,
    gasLimit: Y.gasLimit ? BigInt(Y.gasLimit) : void 0,
    gasUsed: Y.gasUsed ? BigInt(Y.gasUsed) : void 0,
    hash: Y.hash ? Y.hash : null,
    logsBloom: Y.logsBloom ? Y.logsBloom : null,
    nonce: Y.nonce ? Y.nonce : null,
    number: Y.number ? BigInt(Y.number) : null,
    size: Y.size ? BigInt(Y.size) : void 0,
    timestamp: Y.timestamp ? BigInt(Y.timestamp) : void 0,
    transactions: X,
    totalDifficulty: Y.totalDifficulty ? BigInt(Y.totalDifficulty) : null
  };
}
const defineBlock = /* @__PURE__ */ defineFormatter("block", formatBlock);
function getTransactionType(Y) {
  if (Y.type)
    return Y.type;
  if (typeof Y.maxFeePerGas < "u" || typeof Y.maxPriorityFeePerGas < "u")
    return "eip1559";
  if (typeof Y.gasPrice < "u")
    return typeof Y.accessList < "u" ? "eip2930" : "legacy";
  throw new InvalidSerializableTransactionError({ transaction: Y });
}
class NegativeOffsetError extends BaseError$1 {
  constructor({ offset: X }) {
    super(`Offset \`${X}\` cannot be negative.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "NegativeOffsetError"
    });
  }
}
class PositionOutOfBoundsError extends BaseError$1 {
  constructor({ length: X, position: ee }) {
    super(`Position \`${ee}\` is out of bounds (\`0 < position < ${X}\`).`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "PositionOutOfBoundsError"
    });
  }
}
class RecursiveReadLimitExceededError extends BaseError$1 {
  constructor({ count: X, limit: ee }) {
    super(`Recursive read limit of \`${ee}\` exceeded (recursive read count: \`${X}\`).`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "RecursiveReadLimitExceededError"
    });
  }
}
const staticCursor = {
  bytes: new Uint8Array(),
  dataView: new DataView(new ArrayBuffer(0)),
  position: 0,
  positionReadCount: /* @__PURE__ */ new Map(),
  recursiveReadCount: 0,
  recursiveReadLimit: 1 / 0,
  assertReadLimit() {
    if (this.recursiveReadCount >= this.recursiveReadLimit)
      throw new RecursiveReadLimitExceededError({
        count: this.recursiveReadCount + 1,
        limit: this.recursiveReadLimit
      });
  },
  assertPosition(Y) {
    if (Y < 0 || Y > this.bytes.length - 1)
      throw new PositionOutOfBoundsError({
        length: this.bytes.length,
        position: Y
      });
  },
  decrementPosition(Y) {
    if (Y < 0)
      throw new NegativeOffsetError({ offset: Y });
    const X = this.position - Y;
    this.assertPosition(X), this.position = X;
  },
  getReadCount(Y) {
    return this.positionReadCount.get(Y || this.position) || 0;
  },
  incrementPosition(Y) {
    if (Y < 0)
      throw new NegativeOffsetError({ offset: Y });
    const X = this.position + Y;
    this.assertPosition(X), this.position = X;
  },
  inspectByte(Y) {
    const X = Y ?? this.position;
    return this.assertPosition(X), this.bytes[X];
  },
  inspectBytes(Y, X) {
    const ee = X ?? this.position;
    return this.assertPosition(ee + Y - 1), this.bytes.subarray(ee, ee + Y);
  },
  inspectUint8(Y) {
    const X = Y ?? this.position;
    return this.assertPosition(X), this.bytes[X];
  },
  inspectUint16(Y) {
    const X = Y ?? this.position;
    return this.assertPosition(X + 1), this.dataView.getUint16(X);
  },
  inspectUint24(Y) {
    const X = Y ?? this.position;
    return this.assertPosition(X + 2), (this.dataView.getUint16(X) << 8) + this.dataView.getUint8(X + 2);
  },
  inspectUint32(Y) {
    const X = Y ?? this.position;
    return this.assertPosition(X + 3), this.dataView.getUint32(X);
  },
  pushByte(Y) {
    this.assertPosition(this.position), this.bytes[this.position] = Y, this.position++;
  },
  pushBytes(Y) {
    this.assertPosition(this.position + Y.length - 1), this.bytes.set(Y, this.position), this.position += Y.length;
  },
  pushUint8(Y) {
    this.assertPosition(this.position), this.bytes[this.position] = Y, this.position++;
  },
  pushUint16(Y) {
    this.assertPosition(this.position + 1), this.dataView.setUint16(this.position, Y), this.position += 2;
  },
  pushUint24(Y) {
    this.assertPosition(this.position + 2), this.dataView.setUint16(this.position, Y >> 8), this.dataView.setUint8(this.position + 2, Y & 255), this.position += 3;
  },
  pushUint32(Y) {
    this.assertPosition(this.position + 3), this.dataView.setUint32(this.position, Y), this.position += 4;
  },
  readByte() {
    this.assertReadLimit(), this._touch();
    const Y = this.inspectByte();
    return this.position++, Y;
  },
  readBytes(Y, X) {
    this.assertReadLimit(), this._touch();
    const ee = this.inspectBytes(Y);
    return this.position += X ?? Y, ee;
  },
  readUint8() {
    this.assertReadLimit(), this._touch();
    const Y = this.inspectUint8();
    return this.position += 1, Y;
  },
  readUint16() {
    this.assertReadLimit(), this._touch();
    const Y = this.inspectUint16();
    return this.position += 2, Y;
  },
  readUint24() {
    this.assertReadLimit(), this._touch();
    const Y = this.inspectUint24();
    return this.position += 3, Y;
  },
  readUint32() {
    this.assertReadLimit(), this._touch();
    const Y = this.inspectUint32();
    return this.position += 4, Y;
  },
  setPosition(Y) {
    const X = this.position;
    return this.assertPosition(Y), this.position = Y, () => this.position = X;
  },
  _touch() {
    if (this.recursiveReadLimit === 1 / 0)
      return;
    const Y = this.getReadCount();
    this.positionReadCount.set(this.position, Y + 1), Y > 0 && this.recursiveReadCount++;
  }
};
function createCursor(Y, { recursiveReadLimit: X = 8192 } = {}) {
  const ee = Object.create(staticCursor);
  return ee.bytes = Y, ee.dataView = new DataView(Y.buffer, Y.byteOffset, Y.byteLength), ee.positionReadCount = /* @__PURE__ */ new Map(), ee.recursiveReadLimit = X, ee;
}
const schedulerCache = /* @__PURE__ */ new Map();
function createBatchScheduler({ fn: Y, id: X, shouldSplitBatch: ee, wait: te = 0, sort: ne }) {
  const ie = async () => {
    const le = ae();
    oe();
    const he = le.map(({ args: me }) => me);
    he.length !== 0 && Y(he).then((me) => {
      var ye;
      ne && Array.isArray(me) && me.sort(ne);
      for (let we = 0; we < le.length; we++) {
        const { pendingPromise: Ee } = le[we];
        (ye = Ee.resolve) == null || ye.call(Ee, [me[we], me]);
      }
    }).catch((me) => {
      var ye;
      for (let we = 0; we < le.length; we++) {
        const { pendingPromise: Ee } = le[we];
        (ye = Ee.reject) == null || ye.call(Ee, me);
      }
    });
  }, oe = () => schedulerCache.delete(X), se = () => ae().map(({ args: le }) => le), ae = () => schedulerCache.get(X) || [], ue = (le) => schedulerCache.set(X, [...ae(), le]);
  return {
    flush: oe,
    async schedule(le) {
      const he = {}, me = new Promise((Ee, Re) => {
        he.resolve = Ee, he.reject = Re;
      });
      return (ee == null ? void 0 : ee([...se(), le])) && ie(), ae().length > 0 ? (ue({ args: le, pendingPromise: he }), me) : (ue({ args: le, pendingPromise: he }), setTimeout(ie, te), me);
    }
  };
}
function formatLog(Y, { args: X, eventName: ee } = {}) {
  return {
    ...Y,
    blockHash: Y.blockHash ? Y.blockHash : null,
    blockNumber: Y.blockNumber ? BigInt(Y.blockNumber) : null,
    logIndex: Y.logIndex ? Number(Y.logIndex) : null,
    transactionHash: Y.transactionHash ? Y.transactionHash : null,
    transactionIndex: Y.transactionIndex ? Number(Y.transactionIndex) : null,
    ...ee ? { args: X, eventName: ee } : {}
  };
}
async function wait(Y) {
  return new Promise((X) => setTimeout(X, Y));
}
const size$1 = 256;
let index$1 = size$1, buffer$3;
function uid$1(Y = 11) {
  if (!buffer$3 || index$1 + Y > size$1 * 2) {
    buffer$3 = "", index$1 = 0;
    for (let X = 0; X < size$1; X++)
      buffer$3 += (256 + Math.random() * 256 | 0).toString(16).substring(1);
  }
  return buffer$3.substring(index$1, index$1++ + Y);
}
function createClient(Y) {
  const { batch: X, cacheTime: ee = Y.pollingInterval ?? 4e3, key: te = "base", name: ne = "Base Client", pollingInterval: ie = 4e3, type: oe = "base" } = Y, se = Y.chain, ae = Y.account ? parseAccount(Y.account) : void 0, { config: ue, request: le, value: he } = Y.transport({
    chain: se,
    pollingInterval: ie
  }), me = { ...ue, ...he }, ye = {
    account: ae,
    batch: X,
    cacheTime: ee,
    chain: se,
    key: te,
    name: ne,
    pollingInterval: ie,
    request: le,
    transport: me,
    type: oe,
    uid: uid$1()
  };
  function we(Ee) {
    return (Re) => {
      const Ue = Re(Ee);
      for (const De in ye)
        delete Ue[De];
      const Me = { ...Ee, ...Ue };
      return Object.assign(Me, { extend: we(Me) });
    };
  }
  return Object.assign(ye, { extend: we(ye) });
}
function withRetry(Y, { delay: X = 100, retryCount: ee = 2, shouldRetry: te = () => !0 } = {}) {
  return new Promise((ne, ie) => {
    const oe = async ({ count: se = 0 } = {}) => {
      const ae = async ({ error: ue }) => {
        const le = typeof X == "function" ? X({ count: se, error: ue }) : X;
        le && await wait(le), oe({ count: se + 1 });
      };
      try {
        const ue = await Y();
        ne(ue);
      } catch (ue) {
        if (se < ee && await te({ count: se, error: ue }))
          return ae({ error: ue });
        ie(ue);
      }
    };
    oe();
  });
}
function buildRequest(Y, X = {}) {
  return async (ee, te = {}) => {
    const { retryDelay: ne = 150, retryCount: ie = 3 } = {
      ...X,
      ...te
    };
    return withRetry(async () => {
      try {
        return await Y(ee);
      } catch (oe) {
        const se = oe;
        switch (se.code) {
          case ParseRpcError.code:
            throw new ParseRpcError(se);
          case InvalidRequestRpcError.code:
            throw new InvalidRequestRpcError(se);
          case MethodNotFoundRpcError.code:
            throw new MethodNotFoundRpcError(se);
          case InvalidParamsRpcError.code:
            throw new InvalidParamsRpcError(se);
          case InternalRpcError.code:
            throw new InternalRpcError(se);
          case InvalidInputRpcError.code:
            throw new InvalidInputRpcError(se);
          case ResourceNotFoundRpcError.code:
            throw new ResourceNotFoundRpcError(se);
          case ResourceUnavailableRpcError.code:
            throw new ResourceUnavailableRpcError(se);
          case TransactionRejectedRpcError.code:
            throw new TransactionRejectedRpcError(se);
          case MethodNotSupportedRpcError.code:
            throw new MethodNotSupportedRpcError(se);
          case LimitExceededRpcError.code:
            throw new LimitExceededRpcError(se);
          case JsonRpcVersionUnsupportedError.code:
            throw new JsonRpcVersionUnsupportedError(se);
          case UserRejectedRequestError.code:
            throw new UserRejectedRequestError(se);
          case UnauthorizedProviderError.code:
            throw new UnauthorizedProviderError(se);
          case UnsupportedProviderMethodError.code:
            throw new UnsupportedProviderMethodError(se);
          case ProviderDisconnectedError.code:
            throw new ProviderDisconnectedError(se);
          case ChainDisconnectedError.code:
            throw new ChainDisconnectedError(se);
          case SwitchChainError.code:
            throw new SwitchChainError(se);
          case 5e3:
            throw new UserRejectedRequestError(se);
          default:
            throw oe instanceof BaseError$1 ? oe : new UnknownRpcError(se);
        }
      }
    }, {
      delay: ({ count: oe, error: se }) => {
        var ae;
        if (se && se instanceof HttpRequestError) {
          const ue = (ae = se == null ? void 0 : se.headers) == null ? void 0 : ae.get("Retry-After");
          if (ue != null && ue.match(/\d/))
            return parseInt(ue) * 1e3;
        }
        return ~~(1 << oe) * ne;
      },
      retryCount: ie,
      shouldRetry: ({ error: oe }) => shouldRetry(oe)
    });
  };
}
function shouldRetry(Y) {
  return "code" in Y && typeof Y.code == "number" ? Y.code === -1 || Y.code === LimitExceededRpcError.code || Y.code === InternalRpcError.code : Y instanceof HttpRequestError && Y.status ? Y.status === 403 || Y.status === 408 || Y.status === 413 || Y.status === 429 || Y.status === 500 || Y.status === 502 || Y.status === 503 || Y.status === 504 : !0;
}
function createTransport({ key: Y, name: X, request: ee, retryCount: te = 3, retryDelay: ne = 150, timeout: ie, type: oe }, se) {
  return {
    config: { key: Y, name: X, request: ee, retryCount: te, retryDelay: ne, timeout: ie, type: oe },
    request: buildRequest(ee, { retryCount: te, retryDelay: ne }),
    value: se
  };
}
class UrlRequiredError extends BaseError$1 {
  constructor() {
    super("No URL was provided to the Transport. Please provide a valid RPC URL to the Transport.", {
      docsPath: "/docs/clients/intro"
    });
  }
}
function withTimeout(Y, { errorInstance: X = new Error("timed out"), timeout: ee, signal: te }) {
  return new Promise((ne, ie) => {
    (async () => {
      let oe;
      try {
        const se = new AbortController();
        ee > 0 && (oe = setTimeout(() => {
          te ? se.abort() : ie(X);
        }, ee)), ne(await Y({ signal: se == null ? void 0 : se.signal }));
      } catch (se) {
        se.name === "AbortError" && ie(X), ie(se);
      } finally {
        clearTimeout(oe);
      }
    })();
  });
}
function createIdStore() {
  return {
    current: 0,
    take() {
      return this.current++;
    },
    reset() {
      this.current = 0;
    }
  };
}
const idCache = /* @__PURE__ */ createIdStore();
function getHttpRpcClient(Y, X = {}) {
  return {
    async request(ee) {
      var ue;
      const { body: te, fetchOptions: ne = {}, timeout: ie = X.timeout ?? 1e4 } = ee, { headers: oe, method: se, signal: ae } = { ...X.fetchOptions, ...ne };
      try {
        const le = await withTimeout(async ({ signal: me }) => await fetch(Y, {
          ...ne,
          body: Array.isArray(te) ? stringify$2(te.map((we) => ({
            jsonrpc: "2.0",
            id: we.id ?? idCache.take(),
            ...we
          }))) : stringify$2({
            jsonrpc: "2.0",
            id: te.id ?? idCache.take(),
            ...te
          }),
          headers: {
            ...oe,
            "Content-Type": "application/json"
          },
          method: se || "POST",
          signal: ae || (ie > 0 ? me : void 0)
        }), {
          errorInstance: new TimeoutError({ body: te, url: Y }),
          timeout: ie,
          signal: !0
        });
        let he;
        if ((ue = le.headers.get("Content-Type")) != null && ue.startsWith("application/json") ? he = await le.json() : he = await le.text(), !le.ok)
          throw new HttpRequestError({
            body: te,
            details: stringify$2(he.error) || le.statusText,
            headers: le.headers,
            status: le.status,
            url: Y
          });
        return he;
      } catch (le) {
        throw le instanceof HttpRequestError || le instanceof TimeoutError ? le : new HttpRequestError({
          body: te,
          details: le.message,
          url: Y
        });
      }
    }
  };
}
function http(Y, X = {}) {
  const { batch: ee, fetchOptions: te, key: ne = "http", name: ie = "HTTP JSON-RPC", retryDelay: oe } = X;
  return ({ chain: se, retryCount: ae, timeout: ue }) => {
    const { batchSize: le = 1e3, wait: he = 0 } = typeof ee == "object" ? ee : {}, me = X.retryCount ?? ae, ye = ue ?? X.timeout ?? 1e4, we = Y || (se == null ? void 0 : se.rpcUrls.default.http[0]);
    if (!we)
      throw new UrlRequiredError();
    const Ee = getHttpRpcClient(we, { fetchOptions: te, timeout: ye });
    return createTransport({
      key: ne,
      name: ie,
      async request({ method: Re, params: Ue }) {
        const Me = { method: Re, params: Ue }, { schedule: De } = createBatchScheduler({
          id: `${Y}`,
          wait: he,
          shouldSplitBatch(rt) {
            return rt.length > le;
          },
          fn: (rt) => Ee.request({
            body: rt
          }),
          sort: (rt, it) => rt.id - it.id
        }), Fe = async (rt) => ee ? De(rt) : [
          await Ee.request({
            body: rt
          })
        ], [{ error: Ke, result: tt }] = await Fe(Me);
        if (Ke)
          throw new RpcRequestError({
            body: Me,
            error: Ke,
            url: we
          });
        return tt;
      },
      retryCount: me,
      retryDelay: oe,
      timeout: ye,
      type: "http"
    }, {
      fetchOptions: te,
      url: we
    });
  };
}
function defineChain(Y) {
  return {
    formatters: void 0,
    fees: void 0,
    serializers: void 0,
    ...Y
  };
}
function toRlp(Y, X = "hex") {
  const ee = getEncodable(Y), te = createCursor(new Uint8Array(ee.length));
  return ee.encode(te), X === "hex" ? bytesToHex$1(te.bytes) : te.bytes;
}
function getEncodable(Y) {
  return Array.isArray(Y) ? getEncodableList(Y.map((X) => getEncodable(X))) : getEncodableBytes(Y);
}
function getEncodableList(Y) {
  const X = Y.reduce((ne, ie) => ne + ie.length, 0), ee = getSizeOfLength(X);
  return {
    length: X <= 55 ? 1 + X : 1 + ee + X,
    encode(ne) {
      X <= 55 ? ne.pushByte(192 + X) : (ne.pushByte(247 + ee), ee === 1 ? ne.pushUint8(X) : ee === 2 ? ne.pushUint16(X) : ee === 3 ? ne.pushUint24(X) : ne.pushUint32(X));
      for (const { encode: ie } of Y)
        ie(ne);
    }
  };
}
function getEncodableBytes(Y) {
  const X = typeof Y == "string" ? hexToBytes$1(Y) : Y, ee = getSizeOfLength(X.length);
  return {
    length: X.length === 1 && X[0] < 128 ? 1 : X.length <= 55 ? 1 + X.length : 1 + ee + X.length,
    encode(ne) {
      X.length === 1 && X[0] < 128 ? ne.pushBytes(X) : X.length <= 55 ? (ne.pushByte(128 + X.length), ne.pushBytes(X)) : (ne.pushByte(183 + ee), ee === 1 ? ne.pushUint8(X.length) : ee === 2 ? ne.pushUint16(X.length) : ee === 3 ? ne.pushUint24(X.length) : ne.pushUint32(X.length), ne.pushBytes(X));
    }
  };
}
function getSizeOfLength(Y) {
  if (Y < 2 ** 8)
    return 1;
  if (Y < 2 ** 16)
    return 2;
  if (Y < 2 ** 24)
    return 3;
  if (Y < 2 ** 32)
    return 4;
  throw new BaseError$1("Length is too large.");
}
const statuses = {
  "0x0": "reverted",
  "0x1": "success"
};
function formatTransactionReceipt(Y) {
  const X = {
    ...Y,
    blockNumber: Y.blockNumber ? BigInt(Y.blockNumber) : null,
    contractAddress: Y.contractAddress ? Y.contractAddress : null,
    cumulativeGasUsed: Y.cumulativeGasUsed ? BigInt(Y.cumulativeGasUsed) : null,
    effectiveGasPrice: Y.effectiveGasPrice ? BigInt(Y.effectiveGasPrice) : null,
    gasUsed: Y.gasUsed ? BigInt(Y.gasUsed) : null,
    logs: Y.logs ? Y.logs.map((ee) => formatLog(ee)) : null,
    to: Y.to ? Y.to : null,
    transactionIndex: Y.transactionIndex ? hexToNumber$1(Y.transactionIndex) : null,
    status: Y.status ? statuses[Y.status] : null,
    type: Y.type ? transactionType[Y.type] || Y.type : null
  };
  return Y.blobGasPrice && (X.blobGasPrice = BigInt(Y.blobGasPrice)), Y.blobGasUsed && (X.blobGasUsed = BigInt(Y.blobGasUsed)), X;
}
const defineTransactionReceipt = /* @__PURE__ */ defineFormatter("transactionReceipt", formatTransactionReceipt);
function assertTransactionEIP1559(Y) {
  const { chainId: X, maxPriorityFeePerGas: ee, gasPrice: te, maxFeePerGas: ne, to: ie } = Y;
  if (X <= 0)
    throw new InvalidChainIdError({ chainId: X });
  if (ie && !isAddress(ie))
    throw new InvalidAddressError({ address: ie });
  if (te)
    throw new BaseError$1("`gasPrice` is not a valid EIP-1559 Transaction attribute.");
  if (ne && ne > 2n ** 256n - 1n)
    throw new FeeCapTooHighError({ maxFeePerGas: ne });
  if (ee && ne && ee > ne)
    throw new TipAboveFeeCapError({ maxFeePerGas: ne, maxPriorityFeePerGas: ee });
}
function assertTransactionEIP2930(Y) {
  const { chainId: X, maxPriorityFeePerGas: ee, gasPrice: te, maxFeePerGas: ne, to: ie } = Y;
  if (X <= 0)
    throw new InvalidChainIdError({ chainId: X });
  if (ie && !isAddress(ie))
    throw new InvalidAddressError({ address: ie });
  if (ee || ne)
    throw new BaseError$1("`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid EIP-2930 Transaction attribute.");
  if (te && te > 2n ** 256n - 1n)
    throw new FeeCapTooHighError({ maxFeePerGas: te });
}
function assertTransactionLegacy(Y) {
  const { chainId: X, maxPriorityFeePerGas: ee, gasPrice: te, maxFeePerGas: ne, to: ie, accessList: oe } = Y;
  if (ie && !isAddress(ie))
    throw new InvalidAddressError({ address: ie });
  if (typeof X < "u" && X <= 0)
    throw new InvalidChainIdError({ chainId: X });
  if (ee || ne)
    throw new BaseError$1("`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid Legacy Transaction attribute.");
  if (te && te > 2n ** 256n - 1n)
    throw new FeeCapTooHighError({ maxFeePerGas: te });
  if (oe)
    throw new BaseError$1("`accessList` is not a valid Legacy Transaction attribute.");
}
function serializeAccessList(Y) {
  if (!Y || Y.length === 0)
    return [];
  const X = [];
  for (let ee = 0; ee < Y.length; ee++) {
    const { address: te, storageKeys: ne } = Y[ee];
    for (let ie = 0; ie < ne.length; ie++)
      if (ne[ie].length - 2 !== 64)
        throw new InvalidStorageKeySizeError({ storageKey: ne[ie] });
    if (!isAddress(te, { strict: !1 }))
      throw new InvalidAddressError({ address: te });
    X.push([te, ne]);
  }
  return X;
}
function serializeTransaction$1(Y, X) {
  const ee = getTransactionType(Y);
  return ee === "eip1559" ? serializeTransactionEIP1559(Y, X) : ee === "eip2930" ? serializeTransactionEIP2930(Y, X) : serializeTransactionLegacy(Y, X);
}
function serializeTransactionEIP1559(Y, X) {
  const { chainId: ee, gas: te, nonce: ne, to: ie, value: oe, maxFeePerGas: se, maxPriorityFeePerGas: ae, accessList: ue, data: le } = Y;
  assertTransactionEIP1559(Y);
  const he = serializeAccessList(ue), me = [
    toHex$2(ee),
    ne ? toHex$2(ne) : "0x",
    ae ? toHex$2(ae) : "0x",
    se ? toHex$2(se) : "0x",
    te ? toHex$2(te) : "0x",
    ie ?? "0x",
    oe ? toHex$2(oe) : "0x",
    le ?? "0x",
    he
  ];
  if (X) {
    const ye = X.v === 0n ? "0x" : X.v === 1n ? toHex$2(1) : X.v === 27n ? "0x" : toHex$2(1);
    me.push(ye, trim(X.r), trim(X.s));
  }
  return concatHex([
    "0x02",
    toRlp(me)
  ]);
}
function serializeTransactionEIP2930(Y, X) {
  const { chainId: ee, gas: te, data: ne, nonce: ie, to: oe, value: se, accessList: ae, gasPrice: ue } = Y;
  assertTransactionEIP2930(Y);
  const le = serializeAccessList(ae), he = [
    toHex$2(ee),
    ie ? toHex$2(ie) : "0x",
    ue ? toHex$2(ue) : "0x",
    te ? toHex$2(te) : "0x",
    oe ?? "0x",
    se ? toHex$2(se) : "0x",
    ne ?? "0x",
    le
  ];
  if (X) {
    const me = X.v === 0n ? "0x" : X.v === 1n ? toHex$2(1) : X.v === 27n ? "0x" : toHex$2(1);
    he.push(me, trim(X.r), trim(X.s));
  }
  return concatHex([
    "0x01",
    toRlp(he)
  ]);
}
function serializeTransactionLegacy(Y, X) {
  const { chainId: ee = 0, gas: te, data: ne, nonce: ie, to: oe, value: se, gasPrice: ae } = Y;
  assertTransactionLegacy(Y);
  let ue = [
    ie ? toHex$2(ie) : "0x",
    ae ? toHex$2(ae) : "0x",
    te ? toHex$2(te) : "0x",
    oe ?? "0x",
    se ? toHex$2(se) : "0x",
    ne ?? "0x"
  ];
  if (X) {
    const le = (() => {
      if (X.v >= 35n)
        return (X.v - 35n) / 2n > 0 ? X.v : 27n + (X.v === 35n ? 0n : 1n);
      if (ee > 0)
        return BigInt(ee * 2) + BigInt(35n + X.v - 27n);
      const he = 27n + (X.v === 27n ? 0n : 1n);
      if (X.v !== he)
        throw new InvalidLegacyVError({ v: X.v });
      return he;
    })();
    ue = [
      ...ue,
      toHex$2(le),
      X.r,
      X.s
    ];
  } else
    ee > 0 && (ue = [
      ...ue,
      toHex$2(ee),
      "0x",
      "0x"
    ]);
  return toRlp(ue);
}
function requestProviders(Y) {
  const X = (ee) => Y(ee.detail);
  return window.addEventListener("eip6963:announceProvider", X), window.dispatchEvent(new CustomEvent("eip6963:requestProvider")), () => window.removeEventListener("eip6963:announceProvider", X);
}
function createStore$1() {
  const Y = /* @__PURE__ */ new Set();
  let X = [];
  const ee = () => requestProviders((ne) => {
    X.some(({ info: ie }) => ie.uuid === ne.info.uuid) || (X = [...X, ne], Y.forEach((ie) => ie(X, { added: [ne] })));
  });
  let te = ee();
  return {
    _listeners() {
      return Y;
    },
    clear() {
      Y.forEach((ne) => ne([], { removed: [...X] })), X = [];
    },
    destroy() {
      this.clear(), Y.clear(), te();
    },
    findProvider({ rdns: ne }) {
      return X.find((ie) => ie.info.rdns === ne);
    },
    getProviders() {
      return X;
    },
    reset() {
      this.clear(), te(), te = ee();
    },
    subscribe(ne, { emitImmediately: ie } = {}) {
      return Y.add(ne), ie && ne(X, { added: X }), () => Y.delete(ne);
    }
  };
}
var define_import_meta_env_default$1 = { BASE_URL: "/", MODE: "production", DEV: !1, PROD: !0, SSR: !1 };
const subscribeWithSelectorImpl = (Y) => (X, ee, te) => {
  const ne = te.subscribe;
  return te.subscribe = (oe, se, ae) => {
    let ue = oe;
    if (se) {
      const le = (ae == null ? void 0 : ae.equalityFn) || Object.is;
      let he = oe(te.getState());
      ue = (me) => {
        const ye = oe(me);
        if (!le(he, ye)) {
          const we = he;
          se(he = ye, we);
        }
      }, ae != null && ae.fireImmediately && se(he, he);
    }
    return ne(ue);
  }, Y(X, ee, te);
}, subscribeWithSelector = subscribeWithSelectorImpl;
function createJSONStorage(Y, X) {
  let ee;
  try {
    ee = Y();
  } catch {
    return;
  }
  return {
    getItem: (ne) => {
      var ie;
      const oe = (ae) => ae === null ? null : JSON.parse(ae, X == null ? void 0 : X.reviver), se = (ie = ee.getItem(ne)) != null ? ie : null;
      return se instanceof Promise ? se.then(oe) : oe(se);
    },
    setItem: (ne, ie) => ee.setItem(
      ne,
      JSON.stringify(ie, X == null ? void 0 : X.replacer)
    ),
    removeItem: (ne) => ee.removeItem(ne)
  };
}
const toThenable = (Y) => (X) => {
  try {
    const ee = Y(X);
    return ee instanceof Promise ? ee : {
      then(te) {
        return toThenable(te)(ee);
      },
      catch(te) {
        return this;
      }
    };
  } catch (ee) {
    return {
      then(te) {
        return this;
      },
      catch(te) {
        return toThenable(te)(ee);
      }
    };
  }
}, oldImpl = (Y, X) => (ee, te, ne) => {
  let ie = {
    getStorage: () => localStorage,
    serialize: JSON.stringify,
    deserialize: JSON.parse,
    partialize: (Re) => Re,
    version: 0,
    merge: (Re, Ue) => ({
      ...Ue,
      ...Re
    }),
    ...X
  }, oe = !1;
  const se = /* @__PURE__ */ new Set(), ae = /* @__PURE__ */ new Set();
  let ue;
  try {
    ue = ie.getStorage();
  } catch {
  }
  if (!ue)
    return Y(
      (...Re) => {
        console.warn(
          `[zustand persist middleware] Unable to update item '${ie.name}', the given storage is currently unavailable.`
        ), ee(...Re);
      },
      te,
      ne
    );
  const le = toThenable(ie.serialize), he = () => {
    const Re = ie.partialize({ ...te() });
    let Ue;
    const Me = le({ state: Re, version: ie.version }).then(
      (De) => ue.setItem(ie.name, De)
    ).catch((De) => {
      Ue = De;
    });
    if (Ue)
      throw Ue;
    return Me;
  }, me = ne.setState;
  ne.setState = (Re, Ue) => {
    me(Re, Ue), he();
  };
  const ye = Y(
    (...Re) => {
      ee(...Re), he();
    },
    te,
    ne
  );
  let we;
  const Ee = () => {
    var Re;
    if (!ue)
      return;
    oe = !1, se.forEach((Me) => Me(te()));
    const Ue = ((Re = ie.onRehydrateStorage) == null ? void 0 : Re.call(ie, te())) || void 0;
    return toThenable(ue.getItem.bind(ue))(ie.name).then((Me) => {
      if (Me)
        return ie.deserialize(Me);
    }).then((Me) => {
      if (Me)
        if (typeof Me.version == "number" && Me.version !== ie.version) {
          if (ie.migrate)
            return ie.migrate(
              Me.state,
              Me.version
            );
          console.error(
            "State loaded from storage couldn't be migrated since no migrate function was provided"
          );
        } else
          return Me.state;
    }).then((Me) => {
      var De;
      return we = ie.merge(
        Me,
        (De = te()) != null ? De : ye
      ), ee(we, !0), he();
    }).then(() => {
      Ue == null || Ue(we, void 0), oe = !0, ae.forEach((Me) => Me(we));
    }).catch((Me) => {
      Ue == null || Ue(void 0, Me);
    });
  };
  return ne.persist = {
    setOptions: (Re) => {
      ie = {
        ...ie,
        ...Re
      }, Re.getStorage && (ue = Re.getStorage());
    },
    clearStorage: () => {
      ue == null || ue.removeItem(ie.name);
    },
    getOptions: () => ie,
    rehydrate: () => Ee(),
    hasHydrated: () => oe,
    onHydrate: (Re) => (se.add(Re), () => {
      se.delete(Re);
    }),
    onFinishHydration: (Re) => (ae.add(Re), () => {
      ae.delete(Re);
    })
  }, Ee(), we || ye;
}, newImpl = (Y, X) => (ee, te, ne) => {
  let ie = {
    storage: createJSONStorage(() => localStorage),
    partialize: (Ee) => Ee,
    version: 0,
    merge: (Ee, Re) => ({
      ...Re,
      ...Ee
    }),
    ...X
  }, oe = !1;
  const se = /* @__PURE__ */ new Set(), ae = /* @__PURE__ */ new Set();
  let ue = ie.storage;
  if (!ue)
    return Y(
      (...Ee) => {
        console.warn(
          `[zustand persist middleware] Unable to update item '${ie.name}', the given storage is currently unavailable.`
        ), ee(...Ee);
      },
      te,
      ne
    );
  const le = () => {
    const Ee = ie.partialize({ ...te() });
    return ue.setItem(ie.name, {
      state: Ee,
      version: ie.version
    });
  }, he = ne.setState;
  ne.setState = (Ee, Re) => {
    he(Ee, Re), le();
  };
  const me = Y(
    (...Ee) => {
      ee(...Ee), le();
    },
    te,
    ne
  );
  let ye;
  const we = () => {
    var Ee, Re;
    if (!ue)
      return;
    oe = !1, se.forEach((Me) => {
      var De;
      return Me((De = te()) != null ? De : me);
    });
    const Ue = ((Re = ie.onRehydrateStorage) == null ? void 0 : Re.call(ie, (Ee = te()) != null ? Ee : me)) || void 0;
    return toThenable(ue.getItem.bind(ue))(ie.name).then((Me) => {
      if (Me)
        if (typeof Me.version == "number" && Me.version !== ie.version) {
          if (ie.migrate)
            return ie.migrate(
              Me.state,
              Me.version
            );
          console.error(
            "State loaded from storage couldn't be migrated since no migrate function was provided"
          );
        } else
          return Me.state;
    }).then((Me) => {
      var De;
      return ye = ie.merge(
        Me,
        (De = te()) != null ? De : me
      ), ee(ye, !0), le();
    }).then(() => {
      Ue == null || Ue(ye, void 0), ye = te(), oe = !0, ae.forEach((Me) => Me(ye));
    }).catch((Me) => {
      Ue == null || Ue(void 0, Me);
    });
  };
  return ne.persist = {
    setOptions: (Ee) => {
      ie = {
        ...ie,
        ...Ee
      }, Ee.storage && (ue = Ee.storage);
    },
    clearStorage: () => {
      ue == null || ue.removeItem(ie.name);
    },
    getOptions: () => ie,
    rehydrate: () => we(),
    hasHydrated: () => oe,
    onHydrate: (Ee) => (se.add(Ee), () => {
      se.delete(Ee);
    }),
    onFinishHydration: (Ee) => (ae.add(Ee), () => {
      ae.delete(Ee);
    })
  }, ie.skipHydration || we(), ye || me;
}, persistImpl = (Y, X) => "getStorage" in X || "serialize" in X || "deserialize" in X ? ((define_import_meta_env_default$1 ? "production" : void 0) !== "production" && console.warn(
  "[DEPRECATED] `getStorage`, `serialize` and `deserialize` options are deprecated. Use `storage` option instead."
), oldImpl(Y, X)) : newImpl(Y, X), persist = persistImpl;
var define_import_meta_env_default = { BASE_URL: "/", MODE: "production", DEV: !1, PROD: !0, SSR: !1 };
const createStoreImpl = (Y) => {
  let X;
  const ee = /* @__PURE__ */ new Set(), te = (ae, ue) => {
    const le = typeof ae == "function" ? ae(X) : ae;
    if (!Object.is(le, X)) {
      const he = X;
      X = ue ?? typeof le != "object" ? le : Object.assign({}, X, le), ee.forEach((me) => me(X, he));
    }
  }, ne = () => X, se = { setState: te, getState: ne, subscribe: (ae) => (ee.add(ae), () => ee.delete(ae)), destroy: () => {
    (define_import_meta_env_default ? "production" : void 0) !== "production" && console.warn(
      "[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."
    ), ee.clear();
  } };
  return X = Y(te, ne, se), se;
}, createStore = (Y) => Y ? createStoreImpl(Y) : createStoreImpl;
var commonjsGlobal$2 = typeof globalThis < "u" ? globalThis : typeof window < "u" || typeof window < "u" ? window : typeof self < "u" ? self : {};
function getDefaultExportFromCjs$4(Y) {
  return Y && Y.__esModule && Object.prototype.hasOwnProperty.call(Y, "default") ? Y.default : Y;
}
function getAugmentedNamespace$2(Y) {
  if (Y.__esModule)
    return Y;
  var X = Y.default;
  if (typeof X == "function") {
    var ee = function te() {
      return this instanceof te ? Reflect.construct(X, arguments, this.constructor) : X.apply(this, arguments);
    };
    ee.prototype = X.prototype;
  } else
    ee = {};
  return Object.defineProperty(ee, "__esModule", { value: !0 }), Object.keys(Y).forEach(function(te) {
    var ne = Object.getOwnPropertyDescriptor(Y, te);
    Object.defineProperty(ee, te, ne.get ? ne : {
      enumerable: !0,
      get: function() {
        return Y[te];
      }
    });
  }), ee;
}
var eventemitter3$1 = { exports: {} };
(function(Y) {
  var X = Object.prototype.hasOwnProperty, ee = "~";
  function te() {
  }
  Object.create && (te.prototype = /* @__PURE__ */ Object.create(null), new te().__proto__ || (ee = !1));
  function ne(ae, ue, le) {
    this.fn = ae, this.context = ue, this.once = le || !1;
  }
  function ie(ae, ue, le, he, me) {
    if (typeof le != "function")
      throw new TypeError("The listener must be a function");
    var ye = new ne(le, he || ae, me), we = ee ? ee + ue : ue;
    return ae._events[we] ? ae._events[we].fn ? ae._events[we] = [ae._events[we], ye] : ae._events[we].push(ye) : (ae._events[we] = ye, ae._eventsCount++), ae;
  }
  function oe(ae, ue) {
    --ae._eventsCount === 0 ? ae._events = new te() : delete ae._events[ue];
  }
  function se() {
    this._events = new te(), this._eventsCount = 0;
  }
  se.prototype.eventNames = function() {
    var ue = [], le, he;
    if (this._eventsCount === 0)
      return ue;
    for (he in le = this._events)
      X.call(le, he) && ue.push(ee ? he.slice(1) : he);
    return Object.getOwnPropertySymbols ? ue.concat(Object.getOwnPropertySymbols(le)) : ue;
  }, se.prototype.listeners = function(ue) {
    var le = ee ? ee + ue : ue, he = this._events[le];
    if (!he)
      return [];
    if (he.fn)
      return [he.fn];
    for (var me = 0, ye = he.length, we = new Array(ye); me < ye; me++)
      we[me] = he[me].fn;
    return we;
  }, se.prototype.listenerCount = function(ue) {
    var le = ee ? ee + ue : ue, he = this._events[le];
    return he ? he.fn ? 1 : he.length : 0;
  }, se.prototype.emit = function(ue, le, he, me, ye, we) {
    var Ee = ee ? ee + ue : ue;
    if (!this._events[Ee])
      return !1;
    var Re = this._events[Ee], Ue = arguments.length, Me, De;
    if (Re.fn) {
      switch (Re.once && this.removeListener(ue, Re.fn, void 0, !0), Ue) {
        case 1:
          return Re.fn.call(Re.context), !0;
        case 2:
          return Re.fn.call(Re.context, le), !0;
        case 3:
          return Re.fn.call(Re.context, le, he), !0;
        case 4:
          return Re.fn.call(Re.context, le, he, me), !0;
        case 5:
          return Re.fn.call(Re.context, le, he, me, ye), !0;
        case 6:
          return Re.fn.call(Re.context, le, he, me, ye, we), !0;
      }
      for (De = 1, Me = new Array(Ue - 1); De < Ue; De++)
        Me[De - 1] = arguments[De];
      Re.fn.apply(Re.context, Me);
    } else {
      var Fe = Re.length, Ke;
      for (De = 0; De < Fe; De++)
        switch (Re[De].once && this.removeListener(ue, Re[De].fn, void 0, !0), Ue) {
          case 1:
            Re[De].fn.call(Re[De].context);
            break;
          case 2:
            Re[De].fn.call(Re[De].context, le);
            break;
          case 3:
            Re[De].fn.call(Re[De].context, le, he);
            break;
          case 4:
            Re[De].fn.call(Re[De].context, le, he, me);
            break;
          default:
            if (!Me)
              for (Ke = 1, Me = new Array(Ue - 1); Ke < Ue; Ke++)
                Me[Ke - 1] = arguments[Ke];
            Re[De].fn.apply(Re[De].context, Me);
        }
    }
    return !0;
  }, se.prototype.on = function(ue, le, he) {
    return ie(this, ue, le, he, !1);
  }, se.prototype.once = function(ue, le, he) {
    return ie(this, ue, le, he, !0);
  }, se.prototype.removeListener = function(ue, le, he, me) {
    var ye = ee ? ee + ue : ue;
    if (!this._events[ye])
      return this;
    if (!le)
      return oe(this, ye), this;
    var we = this._events[ye];
    if (we.fn)
      we.fn === le && (!me || we.once) && (!he || we.context === he) && oe(this, ye);
    else {
      for (var Ee = 0, Re = [], Ue = we.length; Ee < Ue; Ee++)
        (we[Ee].fn !== le || me && !we[Ee].once || he && we[Ee].context !== he) && Re.push(we[Ee]);
      Re.length ? this._events[ye] = Re.length === 1 ? Re[0] : Re : oe(this, ye);
    }
    return this;
  }, se.prototype.removeAllListeners = function(ue) {
    var le;
    return ue ? (le = ee ? ee + ue : ue, this._events[le] && oe(this, le)) : (this._events = new te(), this._eventsCount = 0), this;
  }, se.prototype.off = se.prototype.removeListener, se.prototype.addListener = se.prototype.on, se.prefixed = ee, se.EventEmitter = se, Y.exports = se;
})(eventemitter3$1);
var eventemitter3Exports = eventemitter3$1.exports;
const EventEmitter$1 = /* @__PURE__ */ getDefaultExportFromCjs$4(eventemitter3Exports);
var __classPrivateFieldGet$1 = function(Y, X, ee, te) {
  if (ee === "a" && !te)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof X == "function" ? Y !== X || !te : !X.has(Y))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return ee === "m" ? te : ee === "a" ? te.call(Y) : te ? te.value : X.get(Y);
}, _Emitter_emitter;
let Emitter$1 = class {
  constructor(X) {
    Object.defineProperty(this, "uid", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: X
    }), _Emitter_emitter.set(this, new EventEmitter$1());
  }
  on(X, ee) {
    __classPrivateFieldGet$1(this, _Emitter_emitter, "f").on(X, ee);
  }
  once(X, ee) {
    __classPrivateFieldGet$1(this, _Emitter_emitter, "f").once(X, ee);
  }
  off(X, ee) {
    __classPrivateFieldGet$1(this, _Emitter_emitter, "f").off(X, ee);
  }
  emit(X, ...ee) {
    const te = ee[0];
    __classPrivateFieldGet$1(this, _Emitter_emitter, "f").emit(X, { uid: this.uid, ...te });
  }
  listenerCount(X) {
    return __classPrivateFieldGet$1(this, _Emitter_emitter, "f").listenerCount(X);
  }
};
_Emitter_emitter = /* @__PURE__ */ new WeakMap();
function createEmitter(Y) {
  return new Emitter$1(Y);
}
function deserialize$1(Y, X) {
  return JSON.parse(Y, (ee, te) => {
    let ne = te;
    return (ne == null ? void 0 : ne.__type) === "bigint" && (ne = BigInt(ne.value)), (ne == null ? void 0 : ne.__type) === "Map" && (ne = new Map(ne.value)), (X == null ? void 0 : X(ee, ne)) ?? ne;
  });
}
function getReferenceKey(Y, X) {
  return Y.slice(0, X).join(".") || ".";
}
function getCutoff(Y, X) {
  const { length: ee } = Y;
  for (let te = 0; te < ee; ++te)
    if (Y[te] === X)
      return te + 1;
  return 0;
}
function createReplacer(Y, X) {
  const ee = typeof Y == "function", te = typeof X == "function", ne = [], ie = [];
  return function(se, ae) {
    if (typeof ae == "object")
      if (ne.length) {
        const ue = getCutoff(ne, this);
        ue === 0 ? ne[ne.length] = this : (ne.splice(ue), ie.splice(ue)), ie[ie.length] = se;
        const le = getCutoff(ne, ae);
        if (le !== 0)
          return te ? X.call(this, se, ae, getReferenceKey(ie, le)) : `[ref=${getReferenceKey(ie, le)}]`;
      } else
        ne[0] = ae, ie[0] = se;
    return ee ? Y.call(this, se, ae) : ae;
  };
}
function serialize$1(Y, X, ee, te) {
  return JSON.stringify(Y, createReplacer((ne, ie) => {
    let oe = ie;
    return typeof oe == "bigint" && (oe = { __type: "bigint", value: ie.toString() }), oe instanceof Map && (oe = { __type: "Map", value: Array.from(ie.entries()) }), (X == null ? void 0 : X(ne, oe)) ?? oe;
  }, te), ee ?? void 0);
}
function createStorage(Y) {
  const { deserialize: X = deserialize$1, key: ee = "wagmi", serialize: te = serialize$1, storage: ne = noopStorage } = Y;
  function ie(oe) {
    return oe instanceof Promise ? oe.then((se) => se).catch(() => null) : oe;
  }
  return {
    ...ne,
    key: ee,
    async getItem(oe, se) {
      const ae = ne.getItem(`${ee}.${oe}`), ue = await ie(ae);
      return ue ? X(ue) ?? null : se ?? null;
    },
    async setItem(oe, se) {
      const ae = `${ee}.${oe}`;
      se === null ? await ie(ne.removeItem(ae)) : await ie(ne.setItem(ae, te(se)));
    },
    async removeItem(oe) {
      await ie(ne.removeItem(`${ee}.${oe}`));
    }
  };
}
const noopStorage = {
  getItem: () => null,
  setItem: () => {
  },
  removeItem: () => {
  }
};
function createConnector(Y) {
  return Y;
}
const version$j = "2.6.5", getVersion = () => `@wagmi/core@${version$j}`;
var __classPrivateFieldGet = function(Y, X, ee, te) {
  if (ee === "a" && !te)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof X == "function" ? Y !== X || !te : !X.has(Y))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return ee === "m" ? te : ee === "a" ? te.call(Y) : te ? te.value : X.get(Y);
}, _BaseError_instances, _BaseError_walk;
class BaseError extends Error {
  get docsBaseUrl() {
    return "https://wagmi.sh/core";
  }
  get version() {
    return getVersion();
  }
  constructor(X, ee = {}) {
    var ie;
    super(), _BaseError_instances.add(this), Object.defineProperty(this, "details", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "docsPath", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "metaMessages", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "shortMessage", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "WagmiCoreError"
    });
    const te = ee.cause instanceof BaseError ? ee.cause.details : (ie = ee.cause) != null && ie.message ? ee.cause.message : ee.details, ne = ee.cause instanceof BaseError && ee.cause.docsPath || ee.docsPath;
    this.message = [
      X || "An error occurred.",
      "",
      ...ee.metaMessages ? [...ee.metaMessages, ""] : [],
      ...ne ? [
        `Docs: ${this.docsBaseUrl}${ne}.html${ee.docsSlug ? `#${ee.docsSlug}` : ""}`
      ] : [],
      ...te ? [`Details: ${te}`] : [],
      `Version: ${this.version}`
    ].join(`
`), ee.cause && (this.cause = ee.cause), this.details = te, this.docsPath = ne, this.metaMessages = ee.metaMessages, this.shortMessage = X;
  }
  walk(X) {
    return __classPrivateFieldGet(this, _BaseError_instances, "m", _BaseError_walk).call(this, this, X);
  }
}
_BaseError_instances = /* @__PURE__ */ new WeakSet(), _BaseError_walk = function Y(X, ee) {
  return ee != null && ee(X) ? X : X.cause ? __classPrivateFieldGet(this, _BaseError_instances, "m", Y).call(this, X.cause, ee) : X;
};
class ChainNotConfiguredError extends BaseError {
  constructor() {
    super("Chain not configured."), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ChainNotConfiguredError"
    });
  }
}
class ConnectorAlreadyConnectedError extends BaseError {
  constructor() {
    super("Connector already connected."), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ConnectorAlreadyConnectedError"
    });
  }
}
class ProviderNotFoundError extends BaseError {
  constructor() {
    super("Provider not found."), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ProviderNotFoundError"
    });
  }
}
function normalizeChainId(Y) {
  if (typeof Y == "string")
    return Number.parseInt(Y, Y.trim().substring(0, 2) === "0x" ? 16 : 10);
  if (typeof Y == "bigint")
    return Number(Y);
  if (typeof Y == "number")
    return Y;
  throw new Error(`Cannot normalize chainId "${Y}" of type "${typeof Y}"`);
}
const targetMap = {
  coinbaseWallet: {
    id: "coinbaseWallet",
    name: "Coinbase Wallet",
    provider(Y) {
      return Y != null && Y.coinbaseWalletExtension ? Y.coinbaseWalletExtension : findProvider(Y, "isCoinbaseWallet");
    }
  },
  metaMask: {
    id: "metaMask",
    name: "MetaMask",
    provider(Y) {
      return findProvider(Y, (X) => {
        if (!X.isMetaMask || X.isBraveWallet && !X._events && !X._state)
          return !1;
        const ee = [
          "isApexWallet",
          "isAvalanche",
          "isBitKeep",
          "isBlockWallet",
          "isKuCoinWallet",
          "isMathWallet",
          "isOkxWallet",
          "isOKExWallet",
          "isOneInchIOSWallet",
          "isOneInchAndroidWallet",
          "isOpera",
          "isPortal",
          "isRabby",
          "isTokenPocket",
          "isTokenary",
          "isZerion"
        ];
        for (const te of ee)
          if (X[te])
            return !1;
        return !0;
      });
    }
  },
  phantom: {
    id: "phantom",
    name: "Phantom",
    provider(Y) {
      var X, ee;
      return (X = Y == null ? void 0 : Y.phantom) != null && X.ethereum ? (ee = Y.phantom) == null ? void 0 : ee.ethereum : findProvider(Y, "isPhantom");
    }
  }
};
injected.type = "injected";
function injected(Y = {}) {
  const { shimDisconnect: X = !0, unstable_shimAsyncInject: ee } = Y;
  function te() {
    const ne = Y.target;
    if (typeof ne == "function") {
      const ie = ne();
      if (ie)
        return ie;
    }
    return typeof ne == "object" ? ne : typeof ne == "string" ? {
      ...targetMap[ne] ?? {
        id: ne,
        name: `${ne[0].toUpperCase()}${ne.slice(1)}`,
        provider: `is${ne[0].toUpperCase()}${ne.slice(1)}`
      }
    } : {
      id: "injected",
      name: "Injected",
      provider(ie) {
        return ie == null ? void 0 : ie.ethereum;
      }
    };
  }
  return (ne) => ({
    get icon() {
      return te().icon;
    },
    get id() {
      return te().id;
    },
    get name() {
      return te().name;
    },
    type: injected.type,
    async setup() {
      const ie = await this.getProvider();
      ie && Y.target && ie.on("connect", this.onConnect.bind(this));
    },
    async connect({ chainId: ie, isReconnecting: oe } = {}) {
      var ue, le, he, me, ye, we;
      const se = await this.getProvider();
      if (!se)
        throw new ProviderNotFoundError();
      let ae = null;
      if (!oe && (ae = await this.getAccounts().catch(() => null), !!(ae != null && ae.length)))
        try {
          ae = (me = (he = (le = (ue = (await se.request({
            method: "wallet_requestPermissions",
            params: [{ eth_accounts: {} }]
          }))[0]) == null ? void 0 : ue.caveats) == null ? void 0 : le[0]) == null ? void 0 : he.value) == null ? void 0 : me.map((Ue) => getAddress$1(Ue));
        } catch (Re) {
          const Ue = Re;
          if (Ue.code === UserRejectedRequestError.code)
            throw new UserRejectedRequestError(Ue);
          if (Ue.code === ResourceUnavailableRpcError.code)
            throw Ue;
        }
      try {
        ae != null && ae.length || (ae = (await se.request({
          method: "eth_requestAccounts"
        })).map((Ue) => getAddress$1(Ue))), se.removeListener("connect", this.onConnect.bind(this)), se.on("accountsChanged", this.onAccountsChanged.bind(this)), se.on("chainChanged", this.onChainChanged), se.on("disconnect", this.onDisconnect.bind(this));
        let Ee = await this.getChainId();
        if (ie && Ee !== ie) {
          const Re = await this.switchChain({ chainId: ie }).catch((Ue) => {
            if (Ue.code === UserRejectedRequestError.code)
              throw Ue;
            return { id: Ee };
          });
          Ee = (Re == null ? void 0 : Re.id) ?? Ee;
        }
        return X && (await ((ye = ne.storage) == null ? void 0 : ye.removeItem(`${this.id}.disconnected`)), Y.target || await ((we = ne.storage) == null ? void 0 : we.setItem("injected.connected", !0))), { accounts: ae, chainId: Ee };
      } catch (Ee) {
        const Re = Ee;
        throw Re.code === UserRejectedRequestError.code ? new UserRejectedRequestError(Re) : Re.code === ResourceUnavailableRpcError.code ? new ResourceUnavailableRpcError(Re) : Re;
      }
    },
    async disconnect() {
      var oe, se;
      const ie = await this.getProvider();
      if (!ie)
        throw new ProviderNotFoundError();
      ie.removeListener("accountsChanged", this.onAccountsChanged.bind(this)), ie.removeListener("chainChanged", this.onChainChanged), ie.removeListener("disconnect", this.onDisconnect.bind(this)), ie.on("connect", this.onConnect.bind(this)), X && (await ((oe = ne.storage) == null ? void 0 : oe.setItem(`${this.id}.disconnected`, !0)), Y.target || await ((se = ne.storage) == null ? void 0 : se.removeItem("injected.connected")));
    },
    async getAccounts() {
      const ie = await this.getProvider();
      if (!ie)
        throw new ProviderNotFoundError();
      return (await ie.request({ method: "eth_accounts" })).map((se) => getAddress$1(se));
    },
    async getChainId() {
      const ie = await this.getProvider();
      if (!ie)
        throw new ProviderNotFoundError();
      const oe = await ie.request({ method: "eth_chainId" });
      return normalizeChainId(oe);
    },
    async getProvider() {
      if (typeof window > "u")
        return;
      let ie;
      const oe = te();
      return typeof oe.provider == "function" ? ie = oe.provider(window) : typeof oe.provider == "string" ? ie = findProvider(window, oe.provider) : ie = oe.provider, ie && !ie.removeListener && ("off" in ie && typeof ie.off == "function" ? ie.removeListener = ie.off : ie.removeListener = () => {
      }), ie;
    },
    async isAuthorized() {
      var ie, oe;
      try {
        if (X && // If shim exists in storage, connector is disconnected
        await ((ie = ne.storage) == null ? void 0 : ie.getItem(`${this.id}.disconnected`)) || !Y.target && !await ((oe = ne.storage) == null ? void 0 : oe.getItem("injected.connected")))
          return !1;
        if (!await this.getProvider()) {
          if (ee !== void 0 && ee !== !1) {
            const le = async () => (typeof window < "u" && window.removeEventListener("ethereum#initialized", le), !!await this.getProvider()), he = typeof ee == "number" ? ee : 1e3;
            if (await Promise.race([
              ...typeof window < "u" ? [
                new Promise((ye) => window.addEventListener("ethereum#initialized", () => ye(le()), { once: !0 }))
              ] : [],
              new Promise((ye) => setTimeout(() => ye(le()), he))
            ]))
              return !0;
          }
          throw new ProviderNotFoundError();
        }
        return !!(await withRetry(() => withTimeout(() => this.getAccounts(), {
          timeout: 100
        }))).length;
      } catch {
        return !1;
      }
    },
    async switchChain({ chainId: ie }) {
      var ae, ue, le;
      const oe = await this.getProvider();
      if (!oe)
        throw new ProviderNotFoundError();
      const se = ne.chains.find((he) => he.id === ie);
      if (!se)
        throw new SwitchChainError(new ChainNotConfiguredError());
      try {
        return await Promise.all([
          oe.request({
            method: "wallet_switchEthereumChain",
            params: [{ chainId: numberToHex(ie) }]
          }),
          new Promise((he) => ne.emitter.once("change", ({ chainId: me }) => {
            me === ie && he();
          }))
        ]), se;
      } catch (he) {
        const me = he;
        if (me.code === 4902 || // Unwrapping for MetaMask Mobile
        // https://github.com/MetaMask/metamask-mobile/issues/2944#issuecomment-976988719
        ((ue = (ae = me == null ? void 0 : me.data) == null ? void 0 : ae.originalError) == null ? void 0 : ue.code) === 4902)
          try {
            const { default: ye, ...we } = se.blockExplorers ?? {};
            let Ee = [];
            if (ye && (Ee = [
              ye.url,
              ...Object.values(we).map((Ue) => Ue.url)
            ]), await oe.request({
              method: "wallet_addEthereumChain",
              params: [
                {
                  chainId: numberToHex(ie),
                  chainName: se.name,
                  nativeCurrency: se.nativeCurrency,
                  rpcUrls: [((le = se.rpcUrls.default) == null ? void 0 : le.http[0]) ?? ""],
                  blockExplorerUrls: Ee
                }
              ]
            }), await this.getChainId() !== ie)
              throw new UserRejectedRequestError(new Error("User rejected switch after adding network."));
            return se;
          } catch (ye) {
            throw new UserRejectedRequestError(ye);
          }
        throw me.code === UserRejectedRequestError.code ? new UserRejectedRequestError(me) : new SwitchChainError(me);
      }
    },
    async onAccountsChanged(ie) {
      var oe;
      if (ie.length === 0)
        this.onDisconnect();
      else if (ne.emitter.listenerCount("connect")) {
        const se = (await this.getChainId()).toString();
        this.onConnect({ chainId: se }), X && await ((oe = ne.storage) == null ? void 0 : oe.removeItem(`${this.id}.disconnected`));
      } else
        ne.emitter.emit("change", {
          accounts: ie.map((se) => getAddress$1(se))
        });
    },
    onChainChanged(ie) {
      const oe = normalizeChainId(ie);
      ne.emitter.emit("change", { chainId: oe });
    },
    async onConnect(ie) {
      const oe = await this.getAccounts();
      if (oe.length === 0)
        return;
      const se = normalizeChainId(ie.chainId);
      ne.emitter.emit("connect", { accounts: oe, chainId: se });
      const ae = await this.getProvider();
      ae && (ae.removeListener("connect", this.onConnect.bind(this)), ae.on("accountsChanged", this.onAccountsChanged.bind(this)), ae.on("chainChanged", this.onChainChanged), ae.on("disconnect", this.onDisconnect.bind(this)));
    },
    async onDisconnect(ie) {
      const oe = await this.getProvider();
      ie && ie.code === 1013 && oe && (await this.getAccounts()).length || (ne.emitter.emit("disconnect"), oe && (oe.removeListener("accountsChanged", this.onAccountsChanged.bind(this)), oe.removeListener("chainChanged", this.onChainChanged), oe.removeListener("disconnect", this.onDisconnect.bind(this)), oe.on("connect", this.onConnect.bind(this))));
    }
  });
}
function findProvider(Y, X) {
  function ee(ne) {
    return typeof X == "function" ? X(ne) : typeof X == "string" ? ne[X] : !0;
  }
  const te = Y.ethereum;
  if (te != null && te.providers)
    return te.providers.find((ne) => ee(ne));
  if (te && ee(te))
    return te;
}
const size = 256;
let index = size, buffer$2;
function uid(Y = 11) {
  if (!buffer$2 || index + Y > size * 2) {
    buffer$2 = "", index = 0;
    for (let X = 0; X < size; X++)
      buffer$2 += (256 + Math.random() * 256 | 0).toString(16).substring(1);
  }
  return buffer$2.substring(index, index++ + Y);
}
function createConfig(Y) {
  const { multiInjectedProviderDiscovery: X = !0, storage: ee = createStorage({
    storage: typeof window < "u" && window.localStorage ? window.localStorage : noopStorage
  }), syncConnectedChain: te = !0, ssr: ne, ...ie } = Y, oe = typeof window < "u" && X ? createStore$1() : void 0, se = createStore(() => ie.chains), ae = createStore(() => [
    ...ie.connectors ?? [],
    ...ne ? [] : (oe == null ? void 0 : oe.getProviders().map(le)) ?? []
  ].map(ue));
  function ue(Fe) {
    var rt;
    const Ke = createEmitter(uid()), tt = {
      ...Fe({ emitter: Ke, chains: se.getState(), storage: ee }),
      emitter: Ke,
      uid: Ke.uid
    };
    return Ke.on("connect", Me), (rt = tt.setup) == null || rt.call(tt), tt;
  }
  function le(Fe) {
    const { info: Ke } = Fe, tt = Fe.provider;
    return injected({ target: { ...Ke, id: Ke.rdns, provider: tt } });
  }
  const he = /* @__PURE__ */ new Map();
  function me(Fe = {}) {
    const Ke = Fe.chainId ?? Re.getState().chainId, tt = se.getState().find((it) => it.id === Ke);
    if (Fe.chainId && !tt)
      throw new ChainNotConfiguredError();
    {
      const it = he.get(Re.getState().chainId);
      if (it && !tt)
        return it;
      if (!tt)
        throw new ChainNotConfiguredError();
    }
    {
      const it = he.get(Ke);
      if (it)
        return it;
    }
    let rt;
    if (ie.client)
      rt = ie.client({ chain: tt });
    else {
      const it = tt.id, _t = se.getState().map((ze) => ze.id), Dt = {}, je = Object.entries(ie);
      for (const [ze, fe] of je)
        if (!(ze === "chains" || ze === "client" || ze === "connectors" || ze === "transports"))
          if (typeof fe == "object")
            if (it in fe)
              Dt[ze] = fe[it];
            else {
              if (_t.some((be) => be in fe))
                continue;
              Dt[ze] = fe;
            }
          else
            Dt[ze] = fe;
      rt = createClient({
        ...Dt,
        chain: tt,
        batch: Dt.batch ?? { multicall: !0 },
        transport: (ze) => ie.transports[it]({ ...ze, connectors: ae })
      });
    }
    return he.set(Ke, rt), rt;
  }
  function ye() {
    return {
      chainId: se.getState()[0].id,
      connections: /* @__PURE__ */ new Map(),
      current: void 0,
      status: "disconnected"
    };
  }
  let we;
  const Ee = "0.0.0-canary-";
  version$j.startsWith(Ee) ? we = parseInt(version$j.replace(Ee, "")) : we = parseInt(version$j.split(".")[0] ?? "0");
  const Re = createStore(subscribeWithSelector(
    // only use persist middleware if storage exists
    ee ? persist(ye, {
      migrate(Fe, Ke) {
        if (Ke === we)
          return Fe;
        const tt = ye(), rt = Fe && typeof Fe == "object" && "chainId" in Fe && typeof Fe.chainId == "number" ? Fe.chainId : tt.chainId;
        return { ...tt, chainId: rt };
      },
      name: "store",
      partialize(Fe) {
        return {
          connections: {
            __type: "Map",
            value: Array.from(Fe.connections.entries()).map(([Ke, tt]) => {
              const { id: rt, name: it, type: _t, uid: Dt } = tt.connector;
              return [Ke, { ...tt, connector: { id: rt, name: it, type: _t, uid: Dt } }];
            })
          },
          chainId: Fe.chainId,
          current: Fe.current
        };
      },
      skipHydration: ne,
      storage: ee,
      version: we
    }) : ye
  ));
  te && Re.subscribe(({ connections: Fe, current: Ke }) => {
    var tt;
    return Ke ? (tt = Fe.get(Ke)) == null ? void 0 : tt.chainId : void 0;
  }, (Fe) => {
    if (se.getState().some((tt) => tt.id === Fe))
      return Re.setState((tt) => ({
        ...tt,
        chainId: Fe ?? tt.chainId
      }));
  }), oe == null || oe.subscribe((Fe) => {
    const Ke = /* @__PURE__ */ new Map();
    for (const rt of ae.getState())
      Ke.set(rt.id, !0);
    const tt = [];
    for (const rt of Fe) {
      const it = ue(le(rt));
      Ke.has(it.id) || tt.push(it);
    }
    ae.setState((rt) => [...rt, ...tt], !0);
  });
  function Ue(Fe) {
    Re.setState((Ke) => {
      const tt = Ke.connections.get(Fe.uid);
      return tt ? {
        ...Ke,
        connections: new Map(Ke.connections).set(Fe.uid, {
          accounts: Fe.accounts ?? tt.accounts,
          chainId: Fe.chainId ?? tt.chainId,
          connector: tt.connector
        })
      } : Ke;
    });
  }
  function Me(Fe) {
    Re.getState().status === "connecting" || Re.getState().status === "reconnecting" || Re.setState((Ke) => {
      const tt = ae.getState().find((rt) => rt.uid === Fe.uid);
      return tt ? {
        ...Ke,
        connections: new Map(Ke.connections).set(Fe.uid, {
          accounts: Fe.accounts,
          chainId: Fe.chainId,
          connector: tt
        }),
        current: Fe.uid,
        status: "connected"
      } : Ke;
    });
  }
  function De(Fe) {
    Re.setState((Ke) => {
      const tt = Ke.connections.get(Fe.uid);
      if (tt && (tt.connector.emitter.off("change", Ue), tt.connector.emitter.off("disconnect", De), tt.connector.emitter.on("connect", Me)), Ke.connections.delete(Fe.uid), Ke.connections.size === 0)
        return {
          ...Ke,
          connections: /* @__PURE__ */ new Map(),
          current: void 0,
          status: "disconnected"
        };
      const rt = Ke.connections.values().next().value;
      return {
        ...Ke,
        connections: new Map(Ke.connections),
        current: rt.connector.uid
      };
    });
  }
  return {
    get chains() {
      return se.getState();
    },
    get connectors() {
      return ae.getState();
    },
    storage: ee,
    getClient: me,
    get state() {
      return Re.getState();
    },
    setState(Fe) {
      let Ke;
      typeof Fe == "function" ? Ke = Fe(Re.getState()) : Ke = Fe;
      const tt = ye();
      typeof Ke != "object" && (Ke = tt), Object.keys(tt).some((it) => !(it in Ke)) && (Ke = tt), Re.setState(Ke, !0);
    },
    subscribe(Fe, Ke, tt) {
      return Re.subscribe(Fe, Ke, tt ? { ...tt, fireImmediately: tt.emitImmediately } : void 0);
    },
    _internal: {
      mipd: oe,
      store: Re,
      ssr: !!ne,
      syncConnectedChain: te,
      transports: ie.transports,
      chains: {
        setState(Fe) {
          const Ke = typeof Fe == "function" ? Fe(se.getState()) : Fe;
          if (Ke.length !== 0)
            return se.setState(Ke, !0);
        },
        subscribe(Fe) {
          return se.subscribe(Fe);
        }
      },
      connectors: {
        providerDetailToConnector: le,
        setup: ue,
        setState(Fe) {
          return ae.setState(typeof Fe == "function" ? Fe(ae.getState()) : Fe, !0);
        },
        subscribe(Fe) {
          return ae.subscribe(Fe);
        }
      },
      events: { change: Ue, connect: Me, disconnect: De }
    }
  };
}
async function connect(Y, X) {
  var te;
  let ee;
  if (typeof X.connector == "function" ? ee = Y._internal.connectors.setup(X.connector) : ee = X.connector, ee.uid === Y.state.current)
    throw new ConnectorAlreadyConnectedError();
  try {
    Y.setState((oe) => ({ ...oe, status: "connecting" })), ee.emitter.emit("message", { type: "connecting" });
    const ne = await ee.connect({ chainId: X.chainId }), ie = ne.accounts;
    return ee.emitter.off("connect", Y._internal.events.connect), ee.emitter.on("change", Y._internal.events.change), ee.emitter.on("disconnect", Y._internal.events.disconnect), await ((te = Y.storage) == null ? void 0 : te.setItem("recentConnectorId", ee.id)), Y.setState((oe) => ({
      ...oe,
      connections: new Map(oe.connections).set(ee.uid, {
        accounts: ie,
        chainId: ne.chainId,
        connector: ee
      }),
      current: ee.uid,
      status: "connected"
    })), { accounts: ie, chainId: ne.chainId };
  } catch (ne) {
    throw Y.setState((ie) => ({
      ...ie,
      // Keep existing connector connected in case of error
      status: ie.current ? "connected" : "disconnected"
    })), ne;
  }
}
function deepEqual(Y, X) {
  if (Y === X)
    return !0;
  if (Y && X && typeof Y == "object" && typeof X == "object") {
    if (Y.constructor !== X.constructor)
      return !1;
    let ee, te;
    if (Array.isArray(Y) && Array.isArray(X)) {
      if (ee = Y.length, ee !== X.length)
        return !1;
      for (te = ee; te-- !== 0; )
        if (!deepEqual(Y[te], X[te]))
          return !1;
      return !0;
    }
    if (Y.valueOf !== Object.prototype.valueOf)
      return Y.valueOf() === X.valueOf();
    if (Y.toString !== Object.prototype.toString)
      return Y.toString() === X.toString();
    const ne = Object.keys(Y);
    if (ee = ne.length, ee !== Object.keys(X).length)
      return !1;
    for (te = ee; te-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(X, ne[te]))
        return !1;
    for (te = ee; te-- !== 0; ) {
      const ie = ne[te];
      if (ie && !deepEqual(Y[ie], X[ie]))
        return !1;
    }
    return !0;
  }
  return Y !== Y && X !== X;
}
let previousConnectors = [];
function getConnectors(Y) {
  const X = Y.connectors;
  return deepEqual(previousConnectors, X) ? previousConnectors : (previousConnectors = X, X);
}
let isReconnecting = !1;
async function reconnect(Y, X = {}) {
  var ue, le;
  if (isReconnecting)
    return [];
  isReconnecting = !0, Y.setState((he) => ({
    ...he,
    status: he.current ? "reconnecting" : "connecting"
  }));
  const ee = [];
  if ((ue = X.connectors) != null && ue.length)
    for (const he of X.connectors) {
      let me;
      typeof he == "function" ? me = Y._internal.connectors.setup(he) : me = he, ee.push(me);
    }
  else
    ee.push(...Y.connectors);
  let te;
  try {
    te = await ((le = Y.storage) == null ? void 0 : le.getItem("recentConnectorId"));
  } catch {
  }
  const ne = {};
  for (const [, he] of Y.state.connections)
    ne[he.connector.id] = 1;
  te && (ne[te] = 0);
  const ie = Object.keys(ne).length > 0 ? (
    // .toSorted()
    [...ee].sort((he, me) => (ne[he.id] ?? 10) - (ne[me.id] ?? 10))
  ) : ee;
  let oe = !1;
  const se = [], ae = [];
  for (const he of ie) {
    const me = await he.getProvider();
    if (!me || ae.some((Ee) => Ee === me) || !await he.isAuthorized())
      continue;
    const we = await he.connect({ isReconnecting: !0 }).catch(() => null);
    we && (he.emitter.off("connect", Y._internal.events.connect), he.emitter.on("change", Y._internal.events.change), he.emitter.on("disconnect", Y._internal.events.disconnect), Y.setState((Ee) => {
      const Re = new Map(oe ? Ee.connections : /* @__PURE__ */ new Map()).set(he.uid, { accounts: we.accounts, chainId: we.chainId, connector: he });
      return {
        ...Ee,
        current: oe ? Ee.current : he.uid,
        connections: Re
      };
    }), se.push({
      accounts: we.accounts,
      chainId: we.chainId,
      connector: he
    }), ae.push(me), oe = !0);
  }
  return oe ? Y.setState((he) => ({ ...he, status: "connected" })) : Y.setState((he) => ({
    ...he,
    connections: /* @__PURE__ */ new Map(),
    current: void 0,
    status: "disconnected"
  })), isReconnecting = !1, se;
}
function hydrate(Y, X) {
  const { initialState: ee, reconnectOnMount: te } = X;
  return ee && Y.setState({
    ...ee,
    connections: te ? ee.connections : /* @__PURE__ */ new Map(),
    status: te ? "reconnecting" : "disconnected"
  }), {
    async onMount() {
      var ne;
      if (Y._internal.ssr) {
        await Y._internal.store.persist.rehydrate();
        const ie = (ne = Y._internal.mipd) == null ? void 0 : ne.getProviders().map(Y._internal.connectors.providerDetailToConnector).map(Y._internal.connectors.setup);
        Y._internal.connectors.setState((oe) => [
          ...oe,
          ...ie ?? []
        ]);
      }
      te ? reconnect(Y) : Y.storage && Y.setState((ie) => ({
        ...ie,
        connections: /* @__PURE__ */ new Map()
      }));
    }
  };
}
const cookieStorage = {
  getItem(Y) {
    return typeof window > "u" ? null : parseCookie(document.cookie, Y) ?? null;
  },
  setItem(Y, X) {
    typeof window > "u" || (document.cookie = `${Y}=${X}`);
  },
  removeItem(Y) {
    typeof window > "u" || (document.cookie = `${Y}=;max-age=-1`);
  }
};
function cookieToInitialState(Y, X) {
  var ne;
  if (!X)
    return;
  const ee = `${(ne = Y.storage) == null ? void 0 : ne.key}.store`, te = parseCookie(X, ee);
  if (te)
    return deserialize$1(te).state;
}
function parseCookie(Y, X) {
  const ee = Y.split("; ").find((te) => te.startsWith(`${X}=`));
  if (ee)
    return ee.substring(X.length + 1);
}
const contracts = {
  gasPriceOracle: { address: "0x420000000000000000000000000000000000000F" },
  l1Block: { address: "0x4200000000000000000000000000000000000015" },
  l2CrossDomainMessenger: {
    address: "0x4200000000000000000000000000000000000007"
  },
  l2Erc721Bridge: { address: "0x4200000000000000000000000000000000000014" },
  l2StandardBridge: { address: "0x4200000000000000000000000000000000000010" },
  l2ToL1MessagePasser: {
    address: "0x4200000000000000000000000000000000000016"
  }
}, formatters = {
  block: /* @__PURE__ */ defineBlock({
    format(Y) {
      var ee;
      return {
        transactions: (ee = Y.transactions) == null ? void 0 : ee.map((te) => {
          if (typeof te == "string")
            return te;
          const ne = formatTransaction(te);
          return ne.typeHex === "0x7e" && (ne.isSystemTx = te.isSystemTx, ne.mint = te.mint ? hexToBigInt(te.mint) : void 0, ne.sourceHash = te.sourceHash, ne.type = "deposit"), ne;
        }),
        stateRoot: Y.stateRoot
      };
    }
  }),
  transaction: /* @__PURE__ */ defineTransaction({
    format(Y) {
      const X = {};
      return Y.type === "0x7e" && (X.isSystemTx = Y.isSystemTx, X.mint = Y.mint ? hexToBigInt(Y.mint) : void 0, X.sourceHash = Y.sourceHash, X.type = "deposit"), X;
    }
  }),
  transactionReceipt: /* @__PURE__ */ defineTransactionReceipt({
    format(Y) {
      return {
        l1GasPrice: Y.l1GasPrice ? hexToBigInt(Y.l1GasPrice) : null,
        l1GasUsed: Y.l1GasUsed ? hexToBigInt(Y.l1GasUsed) : null,
        l1Fee: Y.l1Fee ? hexToBigInt(Y.l1Fee) : null,
        l1FeeScalar: Y.l1FeeScalar ? Number(Y.l1FeeScalar) : null
      };
    }
  })
}, serializeTransaction = (Y, X) => isDeposit(Y) ? serializeTransactionDeposit(Y) : serializeTransaction$1(Y, X), serializers = {
  transaction: serializeTransaction
};
function serializeTransactionDeposit(Y) {
  assertTransactionDeposit(Y);
  const { sourceHash: X, data: ee, from: te, gas: ne, isSystemTx: ie, mint: oe, to: se, value: ae } = Y, ue = [
    X,
    te,
    se ?? "0x",
    oe ? toHex$2(oe) : "0x",
    ae ? toHex$2(ae) : "0x",
    ne ? toHex$2(ne) : "0x",
    ie ? "0x1" : "0x",
    ee ?? "0x"
  ];
  return concatHex([
    "0x7e",
    toRlp(ue)
  ]);
}
function isDeposit(Y) {
  return Y.type === "deposit" || typeof Y.sourceHash < "u";
}
function assertTransactionDeposit(Y) {
  const { from: X, to: ee } = Y;
  if (X && !isAddress(X))
    throw new InvalidAddressError({ address: X });
  if (ee && !isAddress(ee))
    throw new InvalidAddressError({ address: ee });
}
const chainConfig = {
  contracts,
  formatters,
  serializers
}, arbitrum = /* @__PURE__ */ defineChain({
  id: 42161,
  name: "Arbitrum One",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://arb1.arbitrum.io/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Arbiscan",
      url: "https://arbiscan.io",
      apiUrl: "https://api.arbiscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 7654707
    }
  }
}), avalanche = /* @__PURE__ */ defineChain({
  id: 43114,
  name: "Avalanche",
  nativeCurrency: {
    decimals: 18,
    name: "Avalanche",
    symbol: "AVAX"
  },
  rpcUrls: {
    default: { http: ["https://api.avax.network/ext/bc/C/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "SnowScan",
      url: "https://snowscan.xyz",
      apiUrl: "https://api.snowscan.xyz/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 11907934
    }
  }
}), bsc = /* @__PURE__ */ defineChain({
  id: 56,
  name: "BNB Smart Chain",
  nativeCurrency: {
    decimals: 18,
    name: "BNB",
    symbol: "BNB"
  },
  rpcUrls: {
    default: { http: ["https://rpc.ankr.com/bsc"] }
  },
  blockExplorers: {
    default: {
      name: "BscScan",
      url: "https://bscscan.com",
      apiUrl: "https://api.bscscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 15921452
    }
  }
}), fantom = /* @__PURE__ */ defineChain({
  id: 250,
  name: "Fantom",
  nativeCurrency: {
    decimals: 18,
    name: "Fantom",
    symbol: "FTM"
  },
  rpcUrls: {
    default: { http: ["https://rpc.ankr.com/fantom"] }
  },
  blockExplorers: {
    default: {
      name: "FTMScan",
      url: "https://ftmscan.com",
      apiUrl: "https://api.ftmscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 33001987
    }
  }
}), fuse = /* @__PURE__ */ defineChain({
  id: 122,
  name: "Fuse",
  nativeCurrency: { name: "Fuse", symbol: "FUSE", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://rpc.fuse.io"] }
  },
  blockExplorers: {
    default: {
      name: "Fuse Explorer",
      url: "https://explorer.fuse.io",
      apiUrl: "https://explorer.fuse.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 16146628
    }
  }
}), mainnet = /* @__PURE__ */ defineChain({
  id: 1,
  name: "Ethereum",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://cloudflare-eth.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://etherscan.io",
      apiUrl: "https://api.etherscan.io/api"
    }
  },
  contracts: {
    ensRegistry: {
      address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
    },
    ensUniversalResolver: {
      address: "0x8cab227b1162f03b8338331adaad7aadc83b895e",
      blockCreated: 18958930
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 14353601
    }
  }
}), sourceId = 1, optimism = /* @__PURE__ */ defineChain({
  ...chainConfig,
  id: 10,
  name: "OP Mainnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.optimism.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Optimism Explorer",
      url: "https://optimistic.etherscan.io",
      apiUrl: "https://api-optimistic.etherscan.io"
    }
  },
  contracts: {
    ...chainConfig.contracts,
    l2OutputOracle: {
      [sourceId]: {
        address: "0xdfe97868233d1aa22e815a266982f2cf17685a27"
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 4286263
    },
    portal: {
      [sourceId]: {
        address: "0xbEb5Fc579115071764c7423A4f12eDde41f106Ed"
      }
    },
    l1StandardBridge: {
      [sourceId]: {
        address: "0x99C9fc46f92E8a1c0deC1b1747d010903E884bE1"
      }
    }
  },
  sourceId
}), polygon = /* @__PURE__ */ defineChain({
  id: 137,
  name: "Polygon",
  nativeCurrency: { name: "MATIC", symbol: "MATIC", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://polygon-rpc.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "PolygonScan",
      url: "https://polygonscan.com",
      apiUrl: "https://api.polygonscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 25770160
    }
  }
}), polygonMumbai = /* @__PURE__ */ defineChain({
  id: 80001,
  name: "Polygon Mumbai",
  nativeCurrency: { name: "MATIC", symbol: "MATIC", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.ankr.com/polygon_mumbai"]
    }
  },
  blockExplorers: {
    default: {
      name: "PolygonScan",
      url: "https://mumbai.polygonscan.com",
      apiUrl: "https://mumbai.polygonscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 25770160
    }
  },
  testnet: !0
}), sepolia = /* @__PURE__ */ defineChain({
  id: 11155111,
  name: "Sepolia",
  nativeCurrency: { name: "Sepolia Ether", symbol: "SEP", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.sepolia.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://sepolia.etherscan.io",
      apiUrl: "https://api-sepolia.etherscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 751532
    },
    ensRegistry: { address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e" },
    ensUniversalResolver: {
      address: "0xBaBC7678D7A63104f1658c11D6AE9A21cdA09725",
      blockCreated: 5043334
    }
  },
  testnet: !0
});
walletConnect.type = "walletConnect";
function walletConnect(Y) {
  const X = Y.isNewChainsStale ?? !0;
  let ee, te;
  const ne = "eip155";
  return (ie) => ({
    id: "walletConnect",
    name: "WalletConnect",
    type: walletConnect.type,
    async setup() {
      const oe = await this.getProvider().catch(() => null);
      oe && (oe.on("connect", this.onConnect.bind(this)), oe.on("session_delete", this.onSessionDelete.bind(this)));
    },
    async connect({ chainId: oe, ...se } = {}) {
      var ae, ue;
      try {
        const le = await this.getProvider();
        if (!le)
          throw new ProviderNotFoundError();
        le.on("display_uri", this.onDisplayUri);
        let he = oe;
        if (!he) {
          const Ee = await ((ae = ie.storage) == null ? void 0 : ae.getItem("state")) ?? {};
          ie.chains.some((Ue) => Ue.id === Ee.chainId) ? he = Ee.chainId : he = (ue = ie.chains[0]) == null ? void 0 : ue.id;
        }
        if (!he)
          throw new Error("No chains found on connector.");
        const me = await this.isChainsStale();
        if (le.session && me && await le.disconnect(), !le.session || me) {
          const Ee = ie.chains.filter((Re) => Re.id !== he).map((Re) => Re.id);
          await le.connect({
            optionalChains: [he, ...Ee],
            ..."pairingTopic" in se ? { pairingTopic: se.pairingTopic } : {}
          }), this.setRequestedChainsIds(ie.chains.map((Re) => Re.id));
        }
        const ye = (await le.enable()).map((Ee) => getAddress$1(Ee)), we = await this.getChainId();
        return le.removeListener("display_uri", this.onDisplayUri), le.removeListener("connect", this.onConnect.bind(this)), le.on("accountsChanged", this.onAccountsChanged.bind(this)), le.on("chainChanged", this.onChainChanged), le.on("disconnect", this.onDisconnect.bind(this)), le.on("session_delete", this.onSessionDelete.bind(this)), { accounts: ye, chainId: we };
      } catch (le) {
        throw /(user rejected|connection request reset)/i.test(le == null ? void 0 : le.message) ? new UserRejectedRequestError(le) : le;
      }
    },
    async disconnect() {
      const oe = await this.getProvider();
      try {
        await (oe == null ? void 0 : oe.disconnect());
      } catch (se) {
        if (!/No matching key/i.test(se.message))
          throw se;
      } finally {
        oe == null || oe.removeListener("accountsChanged", this.onAccountsChanged.bind(this)), oe == null || oe.removeListener("chainChanged", this.onChainChanged), oe == null || oe.removeListener("disconnect", this.onDisconnect.bind(this)), oe == null || oe.removeListener("session_delete", this.onSessionDelete.bind(this)), oe == null || oe.on("connect", this.onConnect.bind(this)), this.setRequestedChainsIds([]);
      }
    },
    async getAccounts() {
      return (await this.getProvider()).accounts.map((se) => getAddress$1(se));
    },
    async getProvider({ chainId: oe } = {}) {
      var ae;
      async function se() {
        const ue = ie.chains.map((he) => he.id);
        if (!ue.length)
          return;
        const { EthereumProvider: le } = await import("./index.es-DOPCPaHT.mjs");
        return await le.init({
          ...Y,
          disableProviderPing: !0,
          optionalChains: ue,
          projectId: Y.projectId,
          rpcMap: Object.fromEntries(ie.chains.map((he) => [
            he.id,
            he.rpcUrls.default.http[0]
          ])),
          showQrModal: Y.showQrModal ?? !0
        });
      }
      return ee || (te || (te = se()), ee = await te, ee == null || ee.events.setMaxListeners(1 / 0)), oe && await ((ae = this.switchChain) == null ? void 0 : ae.call(this, { chainId: oe })), ee;
    },
    async getChainId() {
      return (await this.getProvider()).chainId;
    },
    async isAuthorized() {
      try {
        const [oe, se] = await Promise.all([
          this.getAccounts(),
          this.getProvider()
        ]);
        return oe.length ? await this.isChainsStale() && se.session ? (await se.disconnect().catch(() => {
        }), !1) : !0 : !1;
      } catch {
        return !1;
      }
    },
    async switchChain({ chainId: oe }) {
      var ae;
      const se = ie.chains.find((ue) => ue.id === oe);
      if (!se)
        throw new SwitchChainError(new ChainNotConfiguredError());
      try {
        const ue = await this.getProvider(), le = this.getNamespaceChainsIds(), he = this.getNamespaceMethods();
        if (!le.includes(oe) && he.includes("wallet_addEthereumChain")) {
          await ue.request({
            method: "wallet_addEthereumChain",
            params: [
              {
                chainId: numberToHex(se.id),
                blockExplorerUrls: [(ae = se.blockExplorers) == null ? void 0 : ae.default.url],
                chainName: se.name,
                nativeCurrency: se.nativeCurrency,
                rpcUrls: [...se.rpcUrls.default.http]
              }
            ]
          });
          const ye = await this.getRequestedChainsIds();
          this.setRequestedChainsIds([...ye, oe]);
        }
        return await ue.request({
          method: "wallet_switchEthereumChain",
          params: [{ chainId: numberToHex(oe) }]
        }), se;
      } catch (ue) {
        const le = typeof ue == "string" ? ue : ue == null ? void 0 : ue.message;
        throw /user rejected request/i.test(le) ? new UserRejectedRequestError(ue) : new SwitchChainError(ue);
      }
    },
    onAccountsChanged(oe) {
      oe.length === 0 ? this.onDisconnect() : ie.emitter.emit("change", {
        accounts: oe.map((se) => getAddress$1(se))
      });
    },
    onChainChanged(oe) {
      const se = normalizeChainId(oe);
      ie.emitter.emit("change", { chainId: se });
    },
    async onConnect(oe) {
      const se = normalizeChainId(oe.chainId), ae = await this.getAccounts();
      ie.emitter.emit("connect", { accounts: ae, chainId: se });
    },
    async onDisconnect(oe) {
      this.setRequestedChainsIds([]), ie.emitter.emit("disconnect");
      const se = await this.getProvider();
      se.removeListener("accountsChanged", this.onAccountsChanged.bind(this)), se.removeListener("chainChanged", this.onChainChanged), se.removeListener("disconnect", this.onDisconnect.bind(this)), se.removeListener("session_delete", this.onSessionDelete.bind(this)), se.on("connect", this.onConnect.bind(this));
    },
    onDisplayUri(oe) {
      ie.emitter.emit("message", { type: "display_uri", data: oe });
    },
    onSessionDelete() {
      this.onDisconnect();
    },
    getNamespaceChainsIds() {
      var se, ae, ue;
      return ee ? ((ue = (ae = (se = ee.session) == null ? void 0 : se.namespaces[ne]) == null ? void 0 : ae.chains) == null ? void 0 : ue.map((le) => parseInt(le.split(":")[1] || ""))) ?? [] : [];
    },
    getNamespaceMethods() {
      var se, ae;
      return ee ? ((ae = (se = ee.session) == null ? void 0 : se.namespaces[ne]) == null ? void 0 : ae.methods) ?? [] : [];
    },
    async getRequestedChainsIds() {
      var oe;
      return await ((oe = ie.storage) == null ? void 0 : oe.getItem(this.requestedChainsStorageKey)) ?? [];
    },
    /**
     * Checks if the target chains match the chains that were
     * initially requested by the connector for the WalletConnect session.
     * If there is a mismatch, this means that the chains on the connector
     * are considered stale, and need to be revalidated at a later point (via
     * connection).
     *
     * There may be a scenario where a dapp adds a chain to the
     * connector later on, however, this chain will not have been approved or rejected
     * by the wallet. In this case, the chain is considered stale.
     *
     * There are exceptions however:
     * -  If the wallet supports dynamic chain addition via `eth_addEthereumChain`,
     *    then the chain is not considered stale.
     * -  If the `isNewChainsStale` flag is falsy on the connector, then the chain is
     *    not considered stale.
     *
     * For the above cases, chain validation occurs dynamically when the user
     * attempts to switch chain.
     *
     * Also check that dapp supports at least 1 chain from previously approved session.
     */
    async isChainsStale() {
      if (this.getNamespaceMethods().includes("wallet_addEthereumChain") || !X)
        return !1;
      const se = ie.chains.map((le) => le.id), ae = this.getNamespaceChainsIds();
      if (ae.length && !ae.some((le) => se.includes(le)))
        return !1;
      const ue = await this.getRequestedChainsIds();
      return !se.every((le) => ue.includes(le));
    },
    async setRequestedChainsIds(oe) {
      var se;
      await ((se = ie.storage) == null ? void 0 : se.setItem(this.requestedChainsStorageKey, oe));
    },
    get requestedChainsStorageKey() {
      return `${this.id}.requestedChains`;
    }
  });
}
const config$1 = createConfig({
  // ssr: true,
  storage: createStorage({
    storage: cookieStorage
  }),
  chains: [
    mainnet,
    polygon,
    optimism,
    arbitrum,
    fantom,
    fuse,
    bsc,
    avalanche,
    polygonMumbai,
    sepolia
  ],
  connectors: [
    injected({
      target: "metaMask",
      shimDisconnect: !1
    }),
    walletConnect({
      projectId: "bd38d3892c8fd8bc9dabf6fced0bd3c6",
      showQrModal: !0,
      qrModalOptions: {
        themeVariables: {
          "--wcm-z-index": "9999"
        }
      }
    })
  ],
  transports: {
    [mainnet.id]: http(),
    [polygon.id]: http(),
    [optimism.id]: http(),
    [arbitrum.id]: http(),
    [fantom.id]: http(),
    [fuse.id]: http(),
    [bsc.id]: http(),
    [avalanche.id]: http(),
    [polygonMumbai.id]: http(),
    [sepolia.id]: http()
  }
});
var __defProp$3 = Object.defineProperty, __getOwnPropDesc$3 = Object.getOwnPropertyDescriptor, __decorateClass$3 = (Y, X, ee, te) => {
  for (var ne = te > 1 ? void 0 : te ? __getOwnPropDesc$3(X, ee) : X, ie = Y.length - 1, oe; ie >= 0; ie--)
    (oe = Y[ie]) && (ne = (te ? oe(X, ee, ne) : oe(ne)) || ne);
  return te && ne && __defProp$3(X, ee, ne), ne;
};
console.log("config render", config$1);
let ExternalWallets = class extends s$1 {
  constructor() {
    super(...arguments), this.darkMode = !1;
  }
  createRenderRoot() {
    return this;
  }
  render() {
    return x$2`
      <div class="w-full flex justify-center space-x-8 px-4">
        <div
          class="flex items-center cursor-pointer "
          @click="${this.clickMetamask}"
        >
          <div
            class="rounded-full flex justify-center items-center w-10 p-0.5 bg-white mr-2 transform transition-transform duration-300 ease-in-out hover:scale-110"
          >
            <img class="rounded-full w-10 flex-none " src="${MetamaskIcon}" />
          </div>
          <div class="text-white text-opacity-80 tracking-wider font-medium">
            Metamask
          </div>
        </div>

        <div
          class="flex items-center cursor-pointer"
          @click="${this.clickWalletConnect}"
        >
          <div
            class="rounded-full flex justify-center items-center w-10 p-0.5 bg-[#007bff] mr-2  transform transition-transform duration-300 ease-in-out hover:scale-110"
          >
            <img
              class="rounded-full w-10 flex-none"
              src="${WalletConnectIcon}"
            />
          </div>
          <div class="text-white text-opacity-80 tracking-wider font-medium">
            Wallet Connect
          </div>
        </div>
      </div>
    `;
  }
  async clickMetamask() {
    const Y = getConnectors(config$1), X = await connect(config$1, {
      connector: Y[0]
    });
    if (X.accounts.length > 0) {
      window.localStorage.setItem("wagmi.connected", "true");
      const ee = {
        type: "Log in",
        success: !0,
        wallet: !0,
        walletType: "metamask",
        data: {
          triaName: null,
          // Replace with actual tria name
          evm: {
            address: X.accounts[0]
            // Use the first account address from the result
          },
          nonEvm: []
          // Add non-EVM addresses if needed
        }
      }, te = new CustomEvent("TRIA_LOGIN", {
        detail: ee,
        bubbles: !0,
        composed: !0
      });
      this.dispatchEvent(te);
    }
  }
  async clickWalletConnect() {
    const Y = getConnectors(config$1), X = await connect(config$1, {
      connector: Y[1]
    });
    if (X.accounts.length > 0) {
      window.localStorage.setItem("wagmi.connected", "true");
      const ee = {
        type: "Log in",
        success: !0,
        wallet: !0,
        walletType: "metamask",
        data: {
          triaName: null,
          // Replace with actual tria name
          evm: {
            address: X.accounts[0]
            // Use the first account address from the result
          },
          nonEvm: []
          // Add non-EVM addresses if needed
        }
      }, te = new CustomEvent("TRIA_LOGIN", {
        detail: ee,
        bubbles: !0,
        composed: !0
      });
      this.dispatchEvent(te);
    }
  }
};
__decorateClass$3([
  n$1({ type: Boolean })
], ExternalWallets.prototype, "darkMode", 2);
ExternalWallets = __decorateClass$3([
  t$1("external-wallets")
], ExternalWallets);
var __defProp$2 = Object.defineProperty, __getOwnPropDesc$2 = Object.getOwnPropertyDescriptor, __decorateClass$2 = (Y, X, ee, te) => {
  for (var ne = te > 1 ? void 0 : te ? __getOwnPropDesc$2(X, ee) : X, ie = Y.length - 1, oe; ie >= 0; ie--)
    (oe = Y[ie]) && (ne = (te ? oe(X, ee, ne) : oe(ne)) || ne);
  return te && ne && __defProp$2(X, ee, ne), ne;
};
let AuthContent = class extends s$1 {
  constructor() {
    super(...arguments), this.darkMode = !1, this.iframeUrl = "";
  }
  createRenderRoot() {
    return this;
  }
  render() {
    return x$2`
      <div
        class="w-[416px] h-[365px] p-2 rounded-2xl border border-tr-purple border-opacity-30 inline-flex flex-col justify-center items-center gap-2 mx-auto"
      >
        <div class="overflow-hidden rounded-2xl w-[375px] p-1">
          <iframe
            src="${this.iframeUrl}"
            height="210px"
            width="100%"
            loading="eager"
            style="border: 0;"
          ></iframe>
        </div>
        <div
          class="w-full pt-3 pb-3 inline-flex justify-center items-center gap-2 pl-3.5 pr-5"
        >
          <div
            class="flex-1 h-0 border-2 border-solid border-white border-opacity-10"
          ></div>
          <div class="px-4 flex items-center justify-between">
            <div
              class="text-center text-white text-opacity-40 text-xs font-semibold uppercase leading-4 break-words"
            >
              or
            </div>
          </div>
          <div
            class="flex-1 h-0 border-2 border-solid border-white border-opacity-10"
          ></div>
        </div>
        <external-wallets .darkMode="${this.darkMode}"></external-wallets>
      </div>
    `;
  }
};
AuthContent.styles = i$5`
    .metamask-container {
      width: 416px;
      height: 375px;
      padding: 4px 5px;
      border-radius: 20px;
      border: 1px solid rgba(167, 139, 250, 0.3);
      display: inline-flex;
      justify-content: center;
      align-items: center;
      gap: 8px;
    }
  `;
__decorateClass$2([
  n$1({ type: Boolean })
], AuthContent.prototype, "darkMode", 2);
__decorateClass$2([
  n$1({ type: String })
], AuthContent.prototype, "iframeUrl", 2);
AuthContent = __decorateClass$2([
  t$1("auth-content")
], AuthContent);
const TriaMiniLogo = "data:image/svg+xml,%3csvg%20width='19'%20height='19'%20viewBox='0%200%2019%2019'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%20%3e%3cg%20clip-path='url(%23clip0_240_3997)'%3e%3cpath%20fill-rule='evenodd'%20clip-rule='evenodd'%20d='M19%200H0V19H19V0ZM10.079%205.60869V8.07896L14.1585%206.47031V8.29788C14.1585%208.68991%2013.9298%209.04048%2013.5854%209.17628L10.079%2010.559V8.73509C10.0767%208.34551%209.84853%207.99783%209.5059%207.86274L6.57263%206.70603C6.22823%206.57021%205.99951%206.21964%205.99951%205.82761V4.00003L10.079%205.60869ZM10.079%2010.5699V11.0459H10.0848V16.2081H8.404V12.3894L6.57263%2011.6672C6.22823%2011.5314%205.99951%2011.1809%205.99951%2010.7888V8.96124L10.079%2010.5699Z'%20fill='%23808080'%20fill-opacity='0.4'%20/%3e%3c/g%3e%3cdefs%3e%3cclipPath%20id='clip0_240_3997'%3e%3crect%20width='19'%20height='19'%20rx='5'%20fill='white'%20/%3e%3c/clipPath%3e%3c/defs%3e%3c/svg%3e";
var react_production_min = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var l = Symbol.for("react.element"), n = Symbol.for("react.portal"), p = Symbol.for("react.fragment"), q = Symbol.for("react.strict_mode"), r$2 = Symbol.for("react.profiler"), t = Symbol.for("react.provider"), u = Symbol.for("react.context"), v = Symbol.for("react.forward_ref"), w = Symbol.for("react.suspense"), x$1 = Symbol.for("react.memo"), y = Symbol.for("react.lazy"), z$1 = Symbol.iterator;
function A(Y) {
  return Y === null || typeof Y != "object" ? null : (Y = z$1 && Y[z$1] || Y["@@iterator"], typeof Y == "function" ? Y : null);
}
var B = { isMounted: function() {
  return !1;
}, enqueueForceUpdate: function() {
}, enqueueReplaceState: function() {
}, enqueueSetState: function() {
} }, C = Object.assign, D = {};
function E(Y, X, ee) {
  this.props = Y, this.context = X, this.refs = D, this.updater = ee || B;
}
E.prototype.isReactComponent = {};
E.prototype.setState = function(Y, X) {
  if (typeof Y != "object" && typeof Y != "function" && Y != null)
    throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
  this.updater.enqueueSetState(this, Y, X, "setState");
};
E.prototype.forceUpdate = function(Y) {
  this.updater.enqueueForceUpdate(this, Y, "forceUpdate");
};
function F() {
}
F.prototype = E.prototype;
function G(Y, X, ee) {
  this.props = Y, this.context = X, this.refs = D, this.updater = ee || B;
}
var H = G.prototype = new F();
H.constructor = G;
C(H, E.prototype);
H.isPureReactComponent = !0;
var I = Array.isArray, J = Object.prototype.hasOwnProperty, K$5 = { current: null }, L = { key: !0, ref: !0, __self: !0, __source: !0 };
function M(Y, X, ee) {
  var te, ne = {}, ie = null, oe = null;
  if (X != null)
    for (te in X.ref !== void 0 && (oe = X.ref), X.key !== void 0 && (ie = "" + X.key), X)
      J.call(X, te) && !L.hasOwnProperty(te) && (ne[te] = X[te]);
  var se = arguments.length - 2;
  if (se === 1)
    ne.children = ee;
  else if (1 < se) {
    for (var ae = Array(se), ue = 0; ue < se; ue++)
      ae[ue] = arguments[ue + 2];
    ne.children = ae;
  }
  if (Y && Y.defaultProps)
    for (te in se = Y.defaultProps, se)
      ne[te] === void 0 && (ne[te] = se[te]);
  return { $$typeof: l, type: Y, key: ie, ref: oe, props: ne, _owner: K$5.current };
}
function N(Y, X) {
  return { $$typeof: l, type: Y.type, key: X, ref: Y.ref, props: Y.props, _owner: Y._owner };
}
function O(Y) {
  return typeof Y == "object" && Y !== null && Y.$$typeof === l;
}
function escape$1(Y) {
  var X = { "=": "=0", ":": "=2" };
  return "$" + Y.replace(/[=:]/g, function(ee) {
    return X[ee];
  });
}
var P = /\/+/g;
function Q(Y, X) {
  return typeof Y == "object" && Y !== null && Y.key != null ? escape$1("" + Y.key) : X.toString(36);
}
function R$1(Y, X, ee, te, ne) {
  var ie = typeof Y;
  (ie === "undefined" || ie === "boolean") && (Y = null);
  var oe = !1;
  if (Y === null)
    oe = !0;
  else
    switch (ie) {
      case "string":
      case "number":
        oe = !0;
        break;
      case "object":
        switch (Y.$$typeof) {
          case l:
          case n:
            oe = !0;
        }
    }
  if (oe)
    return oe = Y, ne = ne(oe), Y = te === "" ? "." + Q(oe, 0) : te, I(ne) ? (ee = "", Y != null && (ee = Y.replace(P, "$&/") + "/"), R$1(ne, X, ee, "", function(ue) {
      return ue;
    })) : ne != null && (O(ne) && (ne = N(ne, ee + (!ne.key || oe && oe.key === ne.key ? "" : ("" + ne.key).replace(P, "$&/") + "/") + Y)), X.push(ne)), 1;
  if (oe = 0, te = te === "" ? "." : te + ":", I(Y))
    for (var se = 0; se < Y.length; se++) {
      ie = Y[se];
      var ae = te + Q(ie, se);
      oe += R$1(ie, X, ee, ae, ne);
    }
  else if (ae = A(Y), typeof ae == "function")
    for (Y = ae.call(Y), se = 0; !(ie = Y.next()).done; )
      ie = ie.value, ae = te + Q(ie, se++), oe += R$1(ie, X, ee, ae, ne);
  else if (ie === "object")
    throw X = String(Y), Error("Objects are not valid as a React child (found: " + (X === "[object Object]" ? "object with keys {" + Object.keys(Y).join(", ") + "}" : X) + "). If you meant to render a collection of children, use an array instead.");
  return oe;
}
function S(Y, X, ee) {
  if (Y == null)
    return Y;
  var te = [], ne = 0;
  return R$1(Y, te, "", "", function(ie) {
    return X.call(ee, ie, ne++);
  }), te;
}
function T(Y) {
  if (Y._status === -1) {
    var X = Y._result;
    X = X(), X.then(function(ee) {
      (Y._status === 0 || Y._status === -1) && (Y._status = 1, Y._result = ee);
    }, function(ee) {
      (Y._status === 0 || Y._status === -1) && (Y._status = 2, Y._result = ee);
    }), Y._status === -1 && (Y._status = 0, Y._result = X);
  }
  if (Y._status === 1)
    return Y._result.default;
  throw Y._result;
}
var U = { current: null }, V = { transition: null }, W$6 = { ReactCurrentDispatcher: U, ReactCurrentBatchConfig: V, ReactCurrentOwner: K$5 };
react_production_min.Children = { map: S, forEach: function(Y, X, ee) {
  S(Y, function() {
    X.apply(this, arguments);
  }, ee);
}, count: function(Y) {
  var X = 0;
  return S(Y, function() {
    X++;
  }), X;
}, toArray: function(Y) {
  return S(Y, function(X) {
    return X;
  }) || [];
}, only: function(Y) {
  if (!O(Y))
    throw Error("React.Children.only expected to receive a single React element child.");
  return Y;
} };
react_production_min.Component = E;
react_production_min.Fragment = p;
react_production_min.Profiler = r$2;
react_production_min.PureComponent = G;
react_production_min.StrictMode = q;
react_production_min.Suspense = w;
react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W$6;
react_production_min.cloneElement = function(Y, X, ee) {
  if (Y == null)
    throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + Y + ".");
  var te = C({}, Y.props), ne = Y.key, ie = Y.ref, oe = Y._owner;
  if (X != null) {
    if (X.ref !== void 0 && (ie = X.ref, oe = K$5.current), X.key !== void 0 && (ne = "" + X.key), Y.type && Y.type.defaultProps)
      var se = Y.type.defaultProps;
    for (ae in X)
      J.call(X, ae) && !L.hasOwnProperty(ae) && (te[ae] = X[ae] === void 0 && se !== void 0 ? se[ae] : X[ae]);
  }
  var ae = arguments.length - 2;
  if (ae === 1)
    te.children = ee;
  else if (1 < ae) {
    se = Array(ae);
    for (var ue = 0; ue < ae; ue++)
      se[ue] = arguments[ue + 2];
    te.children = se;
  }
  return { $$typeof: l, type: Y.type, key: ne, ref: ie, props: te, _owner: oe };
};
react_production_min.createContext = function(Y) {
  return Y = { $$typeof: u, _currentValue: Y, _currentValue2: Y, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }, Y.Provider = { $$typeof: t, _context: Y }, Y.Consumer = Y;
};
react_production_min.createElement = M;
react_production_min.createFactory = function(Y) {
  var X = M.bind(null, Y);
  return X.type = Y, X;
};
react_production_min.createRef = function() {
  return { current: null };
};
react_production_min.forwardRef = function(Y) {
  return { $$typeof: v, render: Y };
};
react_production_min.isValidElement = O;
react_production_min.lazy = function(Y) {
  return { $$typeof: y, _payload: { _status: -1, _result: Y }, _init: T };
};
react_production_min.memo = function(Y, X) {
  return { $$typeof: x$1, type: Y, compare: X === void 0 ? null : X };
};
react_production_min.startTransition = function(Y) {
  var X = V.transition;
  V.transition = {};
  try {
    Y();
  } finally {
    V.transition = X;
  }
};
react_production_min.unstable_act = function() {
  throw Error("act(...) is not supported in production builds of React.");
};
react_production_min.useCallback = function(Y, X) {
  return U.current.useCallback(Y, X);
};
react_production_min.useContext = function(Y) {
  return U.current.useContext(Y);
};
react_production_min.useDebugValue = function() {
};
react_production_min.useDeferredValue = function(Y) {
  return U.current.useDeferredValue(Y);
};
react_production_min.useEffect = function(Y, X) {
  return U.current.useEffect(Y, X);
};
react_production_min.useId = function() {
  return U.current.useId();
};
react_production_min.useImperativeHandle = function(Y, X, ee) {
  return U.current.useImperativeHandle(Y, X, ee);
};
react_production_min.useInsertionEffect = function(Y, X) {
  return U.current.useInsertionEffect(Y, X);
};
react_production_min.useLayoutEffect = function(Y, X) {
  return U.current.useLayoutEffect(Y, X);
};
react_production_min.useMemo = function(Y, X) {
  return U.current.useMemo(Y, X);
};
react_production_min.useReducer = function(Y, X, ee) {
  return U.current.useReducer(Y, X, ee);
};
react_production_min.useRef = function(Y) {
  return U.current.useRef(Y);
};
react_production_min.useState = function(Y) {
  return U.current.useState(Y);
};
react_production_min.useSyncExternalStore = function(Y, X, ee) {
  return U.current.useSyncExternalStore(Y, X, ee);
};
react_production_min.useTransition = function() {
  return U.current.useTransition();
};
react_production_min.version = "18.2.0";
var PY = Object.defineProperty, $Y = (Y, X, ee) => X in Y ? PY(Y, X, { enumerable: !0, configurable: !0, writable: !0, value: ee }) : Y[X] = ee, SY = (Y, X, ee) => ($Y(Y, typeof X != "symbol" ? X + "" : X, ee), ee);
const eventTypes = {
  logIn: "Log in",
  triaSignUp: "Tria Sign up",
  emailPwSignUp: "Email Pwd Sign up",
  socialSignUp: "Social Sign up",
  signMessage: "Sign Message",
  send: "Send",
  disconnect: "Disconnect",
  switchChain: "Switch chain",
  detected: "Detected Logged in Tria account",
  logout: "Logout",
  passMessage: "Pass Message",
  accessToken: "Access Token Pass",
  idTokenPass: "Id Token Pass",
  saveToAuth: "Save to Auth Iframe",
  triaStoreSet: "triaStoreSet"
}, TRIA_WALLET_STORE = "tria.wallet.store", TRIA_WALLET_SELECTED_CHAIN = "tria.wallet.selectedChain", storageKeys = {
  TRIA_WALLET_STORE: "tria.wallet.store",
  TRIA_WALLET_SELECTED_CHAIN: "tria.wallet.selectedChain",
  PERSIST_ROOT: "persist:root"
}, triaAuthUrl = "https://auth.tria.so";
var commonjsGlobal$1 = typeof globalThis < "u" ? globalThis : typeof window < "u" || typeof window < "u" ? window : typeof self < "u" ? self : {};
function getDefaultExportFromCjs$3(Y) {
  return Y && Y.__esModule && Object.prototype.hasOwnProperty.call(Y, "default") ? Y.default : Y;
}
function getAugmentedNamespace$1(Y) {
  if (Y.__esModule)
    return Y;
  var X = Y.default;
  if (typeof X == "function") {
    var ee = function te() {
      return this instanceof te ? Reflect.construct(X, arguments, this.constructor) : X.apply(this, arguments);
    };
    ee.prototype = X.prototype;
  } else
    ee = {};
  return Object.defineProperty(ee, "__esModule", { value: !0 }), Object.keys(Y).forEach(function(te) {
    var ne = Object.getOwnPropertyDescriptor(Y, te);
    Object.defineProperty(ee, te, ne.get ? ne : {
      enumerable: !0,
      get: function() {
        return Y[te];
      }
    });
  }), ee;
}
async function disconnect$1(Y, X = {}) {
  var ee, te;
  let ne;
  if (X.connector)
    ne = X.connector;
  else {
    const { connections: oe, current: se } = Y.state, ae = oe.get(se);
    ne = ae == null ? void 0 : ae.connector;
  }
  const ie = Y.state.connections;
  ne && (await ne.disconnect(), ne.emitter.off("change", Y._internal.events.change), ne.emitter.off("disconnect", Y._internal.events.disconnect), ne.emitter.on("connect", Y._internal.events.connect), ie.delete(ne.uid)), Y.setState((oe) => {
    if (ie.size === 0)
      return {
        ...oe,
        connections: /* @__PURE__ */ new Map(),
        current: void 0,
        status: "disconnected"
      };
    const se = ie.values().next().value;
    return {
      ...oe,
      connections: new Map(ie),
      current: se.connector.uid
    };
  });
  {
    const oe = Y.state.current;
    if (!oe)
      return;
    const se = (ee = Y.state.connections.get(oe)) == null ? void 0 : ee.connector;
    if (!se)
      return;
    await ((te = Y.storage) == null ? void 0 : te.setItem("recentConnectorId", se.id));
  }
}
function getAccount$2(Y) {
  const X = Y.state.current, ee = Y.state.connections.get(X), te = ee == null ? void 0 : ee.accounts, ne = te == null ? void 0 : te[0], ie = Y.chains.find((se) => se.id === (ee == null ? void 0 : ee.chainId)), oe = Y.state.status;
  switch (oe) {
    case "connected":
      return {
        address: ne,
        addresses: te,
        chain: ie,
        chainId: ee == null ? void 0 : ee.chainId,
        connector: ee == null ? void 0 : ee.connector,
        isConnected: !0,
        isConnecting: !1,
        isDisconnected: !1,
        isReconnecting: !1,
        status: oe
      };
    case "reconnecting":
      return {
        address: ne,
        addresses: te,
        chain: ie,
        chainId: ee == null ? void 0 : ee.chainId,
        connector: ee == null ? void 0 : ee.connector,
        isConnected: !!ne,
        isConnecting: !1,
        isDisconnected: !1,
        isReconnecting: !0,
        status: oe
      };
    case "connecting":
      return {
        address: ne,
        addresses: te,
        chain: ie,
        chainId: ee == null ? void 0 : ee.chainId,
        connector: ee == null ? void 0 : ee.connector,
        isConnected: !1,
        isConnecting: !0,
        isDisconnected: !1,
        isReconnecting: !1,
        status: oe
      };
    case "disconnected":
      return {
        address: void 0,
        addresses: void 0,
        chain: void 0,
        chainId: void 0,
        connector: void 0,
        isConnected: !1,
        isConnecting: !1,
        isDisconnected: !0,
        isReconnecting: !1,
        status: oe
      };
  }
}
const createEncodedData = (Y) => btoa(JSON.stringify(Y)), createIframe = (Y, X) => {
  const ee = document.createElement("div");
  ee.id = X, ee.className = "bg flex justify-between bg-transparent fixed bottom-4 right-2";
  const te = JSON.parse(localStorage.getItem("wallet.position") || "{}"), ne = te == null ? void 0 : te.posY, ie = te == null ? void 0 : te.posX;
  ee.style.zIndex = "9999", ee.style.position = "fixed", ee.style.top = `${ne}px`, ee.style.left = `${ie}px`;
  const oe = document.createElement("div");
  oe.className = "mb-4 mr-2 relative rounded-[20px]";
  const se = document.createElement("div");
  se.className = "h-[586px] w-[312px] rounded-[20px] overflow-hidden";
  const ae = document.createElement("iframe");
  ae.width = "312", ae.height = "586", ae.src = Y, ae.allow = "publickey-credentials-get", ae.style.border = "none", se.appendChild(ae), oe.appendChild(se), ee.appendChild(oe), document.body.appendChild(ee);
}, wagmiConnected = (Y) => {
  const { address: X } = getAccount$2(Y);
  return !!X;
}, triaConnected = () => !!localStorage.getItem("tria.wallet.store");
function b2(Y, X) {
  return function() {
    return Y.apply(X, arguments);
  };
}
const { toString: I8 } = Object.prototype, { getPrototypeOf: Qg } = Object, bd = /* @__PURE__ */ ((Y) => (X) => {
  const ee = I8.call(X);
  return Y[ee] || (Y[ee] = ee.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null)), ts = (Y) => (Y = Y.toLowerCase(), (X) => bd(X) === Y), xd = (Y) => (X) => typeof X === Y, { isArray: cc } = Array, bu = xd("undefined");
function R8(Y) {
  return Y !== null && !bu(Y) && Y.constructor !== null && !bu(Y.constructor) && ei(Y.constructor.isBuffer) && Y.constructor.isBuffer(Y);
}
const x2 = ts("ArrayBuffer");
function C8(Y) {
  let X;
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? X = ArrayBuffer.isView(Y) : X = Y && Y.buffer && x2(Y.buffer), X;
}
const P8 = xd("string"), ei = xd("function"), w2 = xd("number"), wd = (Y) => Y !== null && typeof Y == "object", O8 = (Y) => Y === !0 || Y === !1, hl$1 = (Y) => {
  if (bd(Y) !== "object")
    return !1;
  const X = Qg(Y);
  return (X === null || X === Object.prototype || Object.getPrototypeOf(X) === null) && !(Symbol.toStringTag in Y) && !(Symbol.iterator in Y);
}, B8 = ts("Date"), N8 = ts("File"), k8 = ts("Blob"), M8 = ts("FileList"), L8 = (Y) => wd(Y) && ei(Y.pipe), F8 = (Y) => {
  let X;
  return Y && (typeof FormData == "function" && Y instanceof FormData || ei(Y.append) && ((X = bd(Y)) === "formdata" || // detect form-data instance
  X === "object" && ei(Y.toString) && Y.toString() === "[object FormData]"));
}, $8 = ts("URLSearchParams"), D8 = (Y) => Y.trim ? Y.trim() : Y.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function sf(Y, X, { allOwnKeys: ee = !1 } = {}) {
  if (Y === null || typeof Y > "u")
    return;
  let te, ne;
  if (typeof Y != "object" && (Y = [Y]), cc(Y))
    for (te = 0, ne = Y.length; te < ne; te++)
      X.call(null, Y[te], te, Y);
  else {
    const ie = ee ? Object.getOwnPropertyNames(Y) : Object.keys(Y), oe = ie.length;
    let se;
    for (te = 0; te < oe; te++)
      se = ie[te], X.call(null, Y[se], se, Y);
  }
}
function v2(Y, X) {
  X = X.toLowerCase();
  const ee = Object.keys(Y);
  let te = ee.length, ne;
  for (; te-- > 0; )
    if (ne = ee[te], X === ne.toLowerCase())
      return ne;
  return null;
}
const E2 = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : window, _2 = (Y) => !bu(Y) && Y !== E2;
function Pp() {
  const { caseless: Y } = _2(this) && this || {}, X = {}, ee = (te, ne) => {
    const ie = Y && v2(X, ne) || ne;
    hl$1(X[ie]) && hl$1(te) ? X[ie] = Pp(X[ie], te) : hl$1(te) ? X[ie] = Pp({}, te) : cc(te) ? X[ie] = te.slice() : X[ie] = te;
  };
  for (let te = 0, ne = arguments.length; te < ne; te++)
    arguments[te] && sf(arguments[te], ee);
  return X;
}
const U8 = (Y, X, ee, { allOwnKeys: te } = {}) => (sf(X, (ne, ie) => {
  ee && ei(ne) ? Y[ie] = b2(ne, ee) : Y[ie] = ne;
}, { allOwnKeys: te }), Y), j8 = (Y) => (Y.charCodeAt(0) === 65279 && (Y = Y.slice(1)), Y), H8 = (Y, X, ee, te) => {
  Y.prototype = Object.create(X.prototype, te), Y.prototype.constructor = Y, Object.defineProperty(Y, "super", {
    value: X.prototype
  }), ee && Object.assign(Y.prototype, ee);
}, z8 = (Y, X, ee, te) => {
  let ne, ie, oe;
  const se = {};
  if (X = X || {}, Y == null)
    return X;
  do {
    for (ne = Object.getOwnPropertyNames(Y), ie = ne.length; ie-- > 0; )
      oe = ne[ie], (!te || te(oe, Y, X)) && !se[oe] && (X[oe] = Y[oe], se[oe] = !0);
    Y = ee !== !1 && Qg(Y);
  } while (Y && (!ee || ee(Y, X)) && Y !== Object.prototype);
  return X;
}, q8 = (Y, X, ee) => {
  Y = String(Y), (ee === void 0 || ee > Y.length) && (ee = Y.length), ee -= X.length;
  const te = Y.indexOf(X, ee);
  return te !== -1 && te === ee;
}, G8 = (Y) => {
  if (!Y)
    return null;
  if (cc(Y))
    return Y;
  let X = Y.length;
  if (!w2(X))
    return null;
  const ee = new Array(X);
  for (; X-- > 0; )
    ee[X] = Y[X];
  return ee;
}, V8 = /* @__PURE__ */ ((Y) => (X) => Y && X instanceof Y)(typeof Uint8Array < "u" && Qg(Uint8Array)), W8 = (Y, X) => {
  const ee = (Y && Y[Symbol.iterator]).call(Y);
  let te;
  for (; (te = ee.next()) && !te.done; ) {
    const ne = te.value;
    X.call(Y, ne[0], ne[1]);
  }
}, K8 = (Y, X) => {
  let ee;
  const te = [];
  for (; (ee = Y.exec(X)) !== null; )
    te.push(ee);
  return te;
}, J8 = ts("HTMLFormElement"), Y8 = (Y) => Y.toLowerCase().replace(
  /[-_\s]([a-z\d])(\w*)/g,
  function(X, ee, te) {
    return ee.toUpperCase() + te;
  }
), Pb = (({ hasOwnProperty: Y }) => (X, ee) => Y.call(X, ee))(Object.prototype), X8 = ts("RegExp"), A2 = (Y, X) => {
  const ee = Object.getOwnPropertyDescriptors(Y), te = {};
  sf(ee, (ne, ie) => {
    let oe;
    (oe = X(ne, ie, Y)) !== !1 && (te[ie] = oe || ne);
  }), Object.defineProperties(Y, te);
}, Z8 = (Y) => {
  A2(Y, (X, ee) => {
    if (ei(Y) && ["arguments", "caller", "callee"].indexOf(ee) !== -1)
      return !1;
    const te = Y[ee];
    if (ei(te)) {
      if (X.enumerable = !1, "writable" in X) {
        X.writable = !1;
        return;
      }
      X.set || (X.set = () => {
        throw Error("Can not rewrite read-only method '" + ee + "'");
      });
    }
  });
}, Q8 = (Y, X) => {
  const ee = {}, te = (ne) => {
    ne.forEach((ie) => {
      ee[ie] = !0;
    });
  };
  return cc(Y) ? te(Y) : te(String(Y).split(X)), ee;
}, e4 = () => {
}, t4 = (Y, X) => (Y = +Y, Number.isFinite(Y) ? Y : X), q0 = "abcdefghijklmnopqrstuvwxyz", Ob = "0123456789", S2 = {
  DIGIT: Ob,
  ALPHA: q0,
  ALPHA_DIGIT: q0 + q0.toUpperCase() + Ob
}, r4 = (Y = 16, X = S2.ALPHA_DIGIT) => {
  let ee = "";
  const { length: te } = X;
  for (; Y--; )
    ee += X[Math.random() * te | 0];
  return ee;
};
function n4(Y) {
  return !!(Y && ei(Y.append) && Y[Symbol.toStringTag] === "FormData" && Y[Symbol.iterator]);
}
const i4 = (Y) => {
  const X = new Array(10), ee = (te, ne) => {
    if (wd(te)) {
      if (X.indexOf(te) >= 0)
        return;
      if (!("toJSON" in te)) {
        X[ne] = te;
        const ie = cc(te) ? [] : {};
        return sf(te, (oe, se) => {
          const ae = ee(oe, ne + 1);
          !bu(ae) && (ie[se] = ae);
        }), X[ne] = void 0, ie;
      }
    }
    return te;
  };
  return ee(Y, 0);
}, s4 = ts("AsyncFunction"), o4 = (Y) => Y && (wd(Y) || ei(Y)) && ei(Y.then) && ei(Y.catch), _e = {
  isArray: cc,
  isArrayBuffer: x2,
  isBuffer: R8,
  isFormData: F8,
  isArrayBufferView: C8,
  isString: P8,
  isNumber: w2,
  isBoolean: O8,
  isObject: wd,
  isPlainObject: hl$1,
  isUndefined: bu,
  isDate: B8,
  isFile: N8,
  isBlob: k8,
  isRegExp: X8,
  isFunction: ei,
  isStream: L8,
  isURLSearchParams: $8,
  isTypedArray: V8,
  isFileList: M8,
  forEach: sf,
  merge: Pp,
  extend: U8,
  trim: D8,
  stripBOM: j8,
  inherits: H8,
  toFlatObject: z8,
  kindOf: bd,
  kindOfTest: ts,
  endsWith: q8,
  toArray: G8,
  forEachEntry: W8,
  matchAll: K8,
  isHTMLForm: J8,
  hasOwnProperty: Pb,
  hasOwnProp: Pb,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors: A2,
  freezeMethods: Z8,
  toObjectSet: Q8,
  toCamelCase: Y8,
  noop: e4,
  toFiniteNumber: t4,
  findKey: v2,
  global: E2,
  isContextDefined: _2,
  ALPHABET: S2,
  generateString: r4,
  isSpecCompliantForm: n4,
  toJSONObject: i4,
  isAsyncFn: s4,
  isThenable: o4
};
function jt(Y, X, ee, te, ne) {
  Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = Y, this.name = "AxiosError", X && (this.code = X), ee && (this.config = ee), te && (this.request = te), ne && (this.response = ne);
}
_e.inherits(jt, Error, {
  toJSON: function() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: _e.toJSONObject(this.config),
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});
const T2 = jt.prototype, I2 = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((Y) => {
  I2[Y] = { value: Y };
});
Object.defineProperties(jt, I2);
Object.defineProperty(T2, "isAxiosError", { value: !0 });
jt.from = (Y, X, ee, te, ne, ie) => {
  const oe = Object.create(T2);
  return _e.toFlatObject(Y, oe, function(se) {
    return se !== Error.prototype;
  }, (se) => se !== "isAxiosError"), jt.call(oe, Y.message, X, ee, te, ne), oe.cause = Y, oe.name = Y.name, ie && Object.assign(oe, ie), oe;
};
const a4 = null;
function Op(Y) {
  return _e.isPlainObject(Y) || _e.isArray(Y);
}
function R2(Y) {
  return _e.endsWith(Y, "[]") ? Y.slice(0, -2) : Y;
}
function Bb(Y, X, ee) {
  return Y ? Y.concat(X).map(function(te, ne) {
    return te = R2(te), !ee && ne ? "[" + te + "]" : te;
  }).join(ee ? "." : "") : X;
}
function c4(Y) {
  return _e.isArray(Y) && !Y.some(Op);
}
const u4 = _e.toFlatObject(_e, {}, null, function(Y) {
  return /^is[A-Z]/.test(Y);
});
function vd(Y, X, ee) {
  if (!_e.isObject(Y))
    throw new TypeError("target must be an object");
  X = X || new FormData(), ee = _e.toFlatObject(ee, {
    metaTokens: !0,
    dots: !1,
    indexes: !1
  }, !1, function(ye, we) {
    return !_e.isUndefined(we[ye]);
  });
  const te = ee.metaTokens, ne = ee.visitor || ue, ie = ee.dots, oe = ee.indexes, se = (ee.Blob || typeof Blob < "u" && Blob) && _e.isSpecCompliantForm(X);
  if (!_e.isFunction(ne))
    throw new TypeError("visitor must be a function");
  function ae(ye) {
    if (ye === null)
      return "";
    if (_e.isDate(ye))
      return ye.toISOString();
    if (!se && _e.isBlob(ye))
      throw new jt("Blob is not supported. Use a Buffer instead.");
    return _e.isArrayBuffer(ye) || _e.isTypedArray(ye) ? se && typeof Blob == "function" ? new Blob([ye]) : Buffer.from(ye) : ye;
  }
  function ue(ye, we, Ee) {
    let Re = ye;
    if (ye && !Ee && typeof ye == "object") {
      if (_e.endsWith(we, "{}"))
        we = te ? we : we.slice(0, -2), ye = JSON.stringify(ye);
      else if (_e.isArray(ye) && c4(ye) || (_e.isFileList(ye) || _e.endsWith(we, "[]")) && (Re = _e.toArray(ye)))
        return we = R2(we), Re.forEach(function(Ue, Me) {
          !(_e.isUndefined(Ue) || Ue === null) && X.append(
            // eslint-disable-next-line no-nested-ternary
            oe === !0 ? Bb([we], Me, ie) : oe === null ? we : we + "[]",
            ae(Ue)
          );
        }), !1;
    }
    return Op(ye) ? !0 : (X.append(Bb(Ee, we, ie), ae(ye)), !1);
  }
  const le = [], he = Object.assign(u4, {
    defaultVisitor: ue,
    convertValue: ae,
    isVisitable: Op
  });
  function me(ye, we) {
    if (!_e.isUndefined(ye)) {
      if (le.indexOf(ye) !== -1)
        throw Error("Circular reference detected in " + we.join("."));
      le.push(ye), _e.forEach(ye, function(Ee, Re) {
        (!(_e.isUndefined(Ee) || Ee === null) && ne.call(
          X,
          Ee,
          _e.isString(Re) ? Re.trim() : Re,
          we,
          he
        )) === !0 && me(Ee, we ? we.concat(Re) : [Re]);
      }), le.pop();
    }
  }
  if (!_e.isObject(Y))
    throw new TypeError("data must be an object");
  return me(Y), X;
}
function Nb(Y) {
  const X = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(Y).replace(/[!'()~]|%20|%00/g, function(ee) {
    return X[ee];
  });
}
function em(Y, X) {
  this._pairs = [], Y && vd(Y, this, X);
}
const C2 = em.prototype;
C2.append = function(Y, X) {
  this._pairs.push([Y, X]);
};
C2.toString = function(Y) {
  const X = Y ? function(ee) {
    return Y.call(this, ee, Nb);
  } : Nb;
  return this._pairs.map(function(ee) {
    return X(ee[0]) + "=" + X(ee[1]);
  }, "").join("&");
};
function f4(Y) {
  return encodeURIComponent(Y).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function P2(Y, X, ee) {
  if (!X)
    return Y;
  const te = ee && ee.encode || f4, ne = ee && ee.serialize;
  let ie;
  if (ne ? ie = ne(X, ee) : ie = _e.isURLSearchParams(X) ? X.toString() : new em(X, ee).toString(te), ie) {
    const oe = Y.indexOf("#");
    oe !== -1 && (Y = Y.slice(0, oe)), Y += (Y.indexOf("?") === -1 ? "?" : "&") + ie;
  }
  return Y;
}
class kb {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(X, ee, te) {
    return this.handlers.push({
      fulfilled: X,
      rejected: ee,
      synchronous: te ? te.synchronous : !1,
      runWhen: te ? te.runWhen : null
    }), this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(X) {
    this.handlers[X] && (this.handlers[X] = null);
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    this.handlers && (this.handlers = []);
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(X) {
    _e.forEach(this.handlers, function(ee) {
      ee !== null && X(ee);
    });
  }
}
const O2 = {
  silentJSONParsing: !0,
  forcedJSONParsing: !0,
  clarifyTimeoutError: !1
}, l4 = typeof URLSearchParams < "u" ? URLSearchParams : em, d4 = typeof FormData < "u" ? FormData : null, h4 = typeof Blob < "u" ? Blob : null, p4 = {
  isBrowser: !0,
  classes: {
    URLSearchParams: l4,
    FormData: d4,
    Blob: h4
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
}, B2 = typeof window < "u" && typeof document < "u", g4 = ((Y) => B2 && ["ReactNative", "NativeScript", "NS"].indexOf(Y) < 0)(typeof navigator < "u" && navigator.product), m4 = typeof WorkerGlobalScope < "u" && // eslint-disable-next-line no-undef
self instanceof WorkerGlobalScope && typeof self.importScripts == "function", y4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hasBrowserEnv: B2,
  hasStandardBrowserEnv: g4,
  hasStandardBrowserWebWorkerEnv: m4
}, Symbol.toStringTag, { value: "Module" })), Ui = {
  ...y4,
  ...p4
};
function b4(Y, X) {
  return vd(Y, new Ui.classes.URLSearchParams(), Object.assign({
    visitor: function(ee, te, ne, ie) {
      return Ui.isNode && _e.isBuffer(ee) ? (this.append(te, ee.toString("base64")), !1) : ie.defaultVisitor.apply(this, arguments);
    }
  }, X));
}
function x4(Y) {
  return _e.matchAll(/\w+|\[(\w*)]/g, Y).map((X) => X[0] === "[]" ? "" : X[1] || X[0]);
}
function w4(Y) {
  const X = {}, ee = Object.keys(Y);
  let te;
  const ne = ee.length;
  let ie;
  for (te = 0; te < ne; te++)
    ie = ee[te], X[ie] = Y[ie];
  return X;
}
function N2(Y) {
  function X(ee, te, ne, ie) {
    let oe = ee[ie++];
    if (oe === "__proto__")
      return !0;
    const se = Number.isFinite(+oe), ae = ie >= ee.length;
    return oe = !oe && _e.isArray(ne) ? ne.length : oe, ae ? (_e.hasOwnProp(ne, oe) ? ne[oe] = [ne[oe], te] : ne[oe] = te, !se) : ((!ne[oe] || !_e.isObject(ne[oe])) && (ne[oe] = []), X(ee, te, ne[oe], ie) && _e.isArray(ne[oe]) && (ne[oe] = w4(ne[oe])), !se);
  }
  if (_e.isFormData(Y) && _e.isFunction(Y.entries)) {
    const ee = {};
    return _e.forEachEntry(Y, (te, ne) => {
      X(x4(te), ne, ee, 0);
    }), ee;
  }
  return null;
}
function v4$2(Y, X, ee) {
  if (_e.isString(Y))
    try {
      return (X || JSON.parse)(Y), _e.trim(Y);
    } catch (te) {
      if (te.name !== "SyntaxError")
        throw te;
    }
  return (ee || JSON.stringify)(Y);
}
const tm = {
  transitional: O2,
  adapter: ["xhr", "http"],
  transformRequest: [function(Y, X) {
    const ee = X.getContentType() || "", te = ee.indexOf("application/json") > -1, ne = _e.isObject(Y);
    if (ne && _e.isHTMLForm(Y) && (Y = new FormData(Y)), _e.isFormData(Y))
      return te ? JSON.stringify(N2(Y)) : Y;
    if (_e.isArrayBuffer(Y) || _e.isBuffer(Y) || _e.isStream(Y) || _e.isFile(Y) || _e.isBlob(Y))
      return Y;
    if (_e.isArrayBufferView(Y))
      return Y.buffer;
    if (_e.isURLSearchParams(Y))
      return X.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), Y.toString();
    let ie;
    if (ne) {
      if (ee.indexOf("application/x-www-form-urlencoded") > -1)
        return b4(Y, this.formSerializer).toString();
      if ((ie = _e.isFileList(Y)) || ee.indexOf("multipart/form-data") > -1) {
        const oe = this.env && this.env.FormData;
        return vd(
          ie ? { "files[]": Y } : Y,
          oe && new oe(),
          this.formSerializer
        );
      }
    }
    return ne || te ? (X.setContentType("application/json", !1), v4$2(Y)) : Y;
  }],
  transformResponse: [function(Y) {
    const X = this.transitional || tm.transitional, ee = X && X.forcedJSONParsing, te = this.responseType === "json";
    if (Y && _e.isString(Y) && (ee && !this.responseType || te)) {
      const ne = !(X && X.silentJSONParsing) && te;
      try {
        return JSON.parse(Y);
      } catch (ie) {
        if (ne)
          throw ie.name === "SyntaxError" ? jt.from(ie, jt.ERR_BAD_RESPONSE, this, null, this.response) : ie;
      }
    }
    return Y;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: Ui.classes.FormData,
    Blob: Ui.classes.Blob
  },
  validateStatus: function(Y) {
    return Y >= 200 && Y < 300;
  },
  headers: {
    common: {
      Accept: "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
_e.forEach(["delete", "get", "head", "post", "put", "patch"], (Y) => {
  tm.headers[Y] = {};
});
const rm = tm, E4 = _e.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]), _4 = (Y) => {
  const X = {};
  let ee, te, ne;
  return Y && Y.split(`
`).forEach(function(ie) {
    ne = ie.indexOf(":"), ee = ie.substring(0, ne).trim().toLowerCase(), te = ie.substring(ne + 1).trim(), !(!ee || X[ee] && E4[ee]) && (ee === "set-cookie" ? X[ee] ? X[ee].push(te) : X[ee] = [te] : X[ee] = X[ee] ? X[ee] + ", " + te : te);
  }), X;
}, Mb = Symbol("internals");
function Lc(Y) {
  return Y && String(Y).trim().toLowerCase();
}
function pl(Y) {
  return Y === !1 || Y == null ? Y : _e.isArray(Y) ? Y.map(pl) : String(Y);
}
function A4(Y) {
  const X = /* @__PURE__ */ Object.create(null), ee = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let te;
  for (; te = ee.exec(Y); )
    X[te[1]] = te[2];
  return X;
}
const S4 = (Y) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(Y.trim());
function G0(Y, X, ee, te, ne) {
  if (_e.isFunction(te))
    return te.call(this, X, ee);
  if (ne && (X = ee), !!_e.isString(X)) {
    if (_e.isString(te))
      return X.indexOf(te) !== -1;
    if (_e.isRegExp(te))
      return te.test(X);
  }
}
function T4(Y) {
  return Y.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (X, ee, te) => ee.toUpperCase() + te);
}
function I4(Y, X) {
  const ee = _e.toCamelCase(" " + X);
  ["get", "set", "has"].forEach((te) => {
    Object.defineProperty(Y, te + ee, {
      value: function(ne, ie, oe) {
        return this[te].call(this, X, ne, ie, oe);
      },
      configurable: !0
    });
  });
}
class Ed {
  constructor(X) {
    X && this.set(X);
  }
  set(X, ee, te) {
    const ne = this;
    function ie(se, ae, ue) {
      const le = Lc(ae);
      if (!le)
        throw new Error("header name must be a non-empty string");
      const he = _e.findKey(ne, le);
      (!he || ne[he] === void 0 || ue === !0 || ue === void 0 && ne[he] !== !1) && (ne[he || ae] = pl(se));
    }
    const oe = (se, ae) => _e.forEach(se, (ue, le) => ie(ue, le, ae));
    return _e.isPlainObject(X) || X instanceof this.constructor ? oe(X, ee) : _e.isString(X) && (X = X.trim()) && !S4(X) ? oe(_4(X), ee) : X != null && ie(ee, X, te), this;
  }
  get(X, ee) {
    if (X = Lc(X), X) {
      const te = _e.findKey(this, X);
      if (te) {
        const ne = this[te];
        if (!ee)
          return ne;
        if (ee === !0)
          return A4(ne);
        if (_e.isFunction(ee))
          return ee.call(this, ne, te);
        if (_e.isRegExp(ee))
          return ee.exec(ne);
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(X, ee) {
    if (X = Lc(X), X) {
      const te = _e.findKey(this, X);
      return !!(te && this[te] !== void 0 && (!ee || G0(this, this[te], te, ee)));
    }
    return !1;
  }
  delete(X, ee) {
    const te = this;
    let ne = !1;
    function ie(oe) {
      if (oe = Lc(oe), oe) {
        const se = _e.findKey(te, oe);
        se && (!ee || G0(te, te[se], se, ee)) && (delete te[se], ne = !0);
      }
    }
    return _e.isArray(X) ? X.forEach(ie) : ie(X), ne;
  }
  clear(X) {
    const ee = Object.keys(this);
    let te = ee.length, ne = !1;
    for (; te--; ) {
      const ie = ee[te];
      (!X || G0(this, this[ie], ie, X, !0)) && (delete this[ie], ne = !0);
    }
    return ne;
  }
  normalize(X) {
    const ee = this, te = {};
    return _e.forEach(this, (ne, ie) => {
      const oe = _e.findKey(te, ie);
      if (oe) {
        ee[oe] = pl(ne), delete ee[ie];
        return;
      }
      const se = X ? T4(ie) : String(ie).trim();
      se !== ie && delete ee[ie], ee[se] = pl(ne), te[se] = !0;
    }), this;
  }
  concat(...X) {
    return this.constructor.concat(this, ...X);
  }
  toJSON(X) {
    const ee = /* @__PURE__ */ Object.create(null);
    return _e.forEach(this, (te, ne) => {
      te != null && te !== !1 && (ee[ne] = X && _e.isArray(te) ? te.join(", ") : te);
    }), ee;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([X, ee]) => X + ": " + ee).join(`
`);
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(X) {
    return X instanceof this ? X : new this(X);
  }
  static concat(X, ...ee) {
    const te = new this(X);
    return ee.forEach((ne) => te.set(ne)), te;
  }
  static accessor(X) {
    const ee = (this[Mb] = this[Mb] = {
      accessors: {}
    }).accessors, te = this.prototype;
    function ne(ie) {
      const oe = Lc(ie);
      ee[oe] || (I4(te, ie), ee[oe] = !0);
    }
    return _e.isArray(X) ? X.forEach(ne) : ne(X), this;
  }
}
Ed.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
_e.reduceDescriptors(Ed.prototype, ({ value: Y }, X) => {
  let ee = X[0].toUpperCase() + X.slice(1);
  return {
    get: () => Y,
    set(te) {
      this[ee] = te;
    }
  };
});
_e.freezeMethods(Ed);
const Es = Ed;
function V0(Y, X) {
  const ee = this || rm, te = X || ee, ne = Es.from(te.headers);
  let ie = te.data;
  return _e.forEach(Y, function(oe) {
    ie = oe.call(ee, ie, ne.normalize(), X ? X.status : void 0);
  }), ne.normalize(), ie;
}
function k2(Y) {
  return !!(Y && Y.__CANCEL__);
}
function of(Y, X, ee) {
  jt.call(this, Y ?? "canceled", jt.ERR_CANCELED, X, ee), this.name = "CanceledError";
}
_e.inherits(of, jt, {
  __CANCEL__: !0
});
function R4(Y, X, ee) {
  const te = ee.config.validateStatus;
  !ee.status || !te || te(ee.status) ? Y(ee) : X(new jt(
    "Request failed with status code " + ee.status,
    [jt.ERR_BAD_REQUEST, jt.ERR_BAD_RESPONSE][Math.floor(ee.status / 100) - 4],
    ee.config,
    ee.request,
    ee
  ));
}
const C4 = Ui.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(Y, X, ee, te, ne, ie) {
      const oe = [Y + "=" + encodeURIComponent(X)];
      _e.isNumber(ee) && oe.push("expires=" + new Date(ee).toGMTString()), _e.isString(te) && oe.push("path=" + te), _e.isString(ne) && oe.push("domain=" + ne), ie === !0 && oe.push("secure"), document.cookie = oe.join("; ");
    },
    read(Y) {
      const X = document.cookie.match(new RegExp("(^|;\\s*)(" + Y + ")=([^;]*)"));
      return X ? decodeURIComponent(X[3]) : null;
    },
    remove(Y) {
      this.write(Y, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);
function P4(Y) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(Y);
}
function O4(Y, X) {
  return X ? Y.replace(/\/?\/$/, "") + "/" + X.replace(/^\/+/, "") : Y;
}
function M2(Y, X) {
  return Y && !P4(X) ? O4(Y, X) : X;
}
const B4 = Ui.hasStandardBrowserEnv ? (
  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  function() {
    const Y = /(msie|trident)/i.test(navigator.userAgent), X = document.createElement("a");
    let ee;
    function te(ne) {
      let ie = ne;
      return Y && (X.setAttribute("href", ie), ie = X.href), X.setAttribute("href", ie), {
        href: X.href,
        protocol: X.protocol ? X.protocol.replace(/:$/, "") : "",
        host: X.host,
        search: X.search ? X.search.replace(/^\?/, "") : "",
        hash: X.hash ? X.hash.replace(/^#/, "") : "",
        hostname: X.hostname,
        port: X.port,
        pathname: X.pathname.charAt(0) === "/" ? X.pathname : "/" + X.pathname
      };
    }
    return ee = te(window.location.href), function(ne) {
      const ie = _e.isString(ne) ? te(ne) : ne;
      return ie.protocol === ee.protocol && ie.host === ee.host;
    };
  }()
) : (
  // Non standard browser envs (web workers, react-native) lack needed support.
  /* @__PURE__ */ function() {
    return function() {
      return !0;
    };
  }()
);
function N4(Y) {
  const X = /^([-+\w]{1,25})(:?\/\/|:)/.exec(Y);
  return X && X[1] || "";
}
function k4(Y, X) {
  Y = Y || 10;
  const ee = new Array(Y), te = new Array(Y);
  let ne = 0, ie = 0, oe;
  return X = X !== void 0 ? X : 1e3, function(se) {
    const ae = Date.now(), ue = te[ie];
    oe || (oe = ae), ee[ne] = se, te[ne] = ae;
    let le = ie, he = 0;
    for (; le !== ne; )
      he += ee[le++], le = le % Y;
    if (ne = (ne + 1) % Y, ne === ie && (ie = (ie + 1) % Y), ae - oe < X)
      return;
    const me = ue && ae - ue;
    return me ? Math.round(he * 1e3 / me) : void 0;
  };
}
function Lb(Y, X) {
  let ee = 0;
  const te = k4(50, 250);
  return (ne) => {
    const ie = ne.loaded, oe = ne.lengthComputable ? ne.total : void 0, se = ie - ee, ae = te(se), ue = ie <= oe;
    ee = ie;
    const le = {
      loaded: ie,
      total: oe,
      progress: oe ? ie / oe : void 0,
      bytes: se,
      rate: ae || void 0,
      estimated: ae && oe && ue ? (oe - ie) / ae : void 0,
      event: ne
    };
    le[X ? "download" : "upload"] = !0, Y(le);
  };
}
const M4 = typeof XMLHttpRequest < "u", L4 = M4 && function(Y) {
  return new Promise(function(X, ee) {
    let te = Y.data;
    const ne = Es.from(Y.headers).normalize();
    let { responseType: ie, withXSRFToken: oe } = Y, se;
    function ae() {
      Y.cancelToken && Y.cancelToken.unsubscribe(se), Y.signal && Y.signal.removeEventListener("abort", se);
    }
    let ue;
    if (_e.isFormData(te)) {
      if (Ui.hasStandardBrowserEnv || Ui.hasStandardBrowserWebWorkerEnv)
        ne.setContentType(!1);
      else if ((ue = ne.getContentType()) !== !1) {
        const [we, ...Ee] = ue ? ue.split(";").map((Re) => Re.trim()).filter(Boolean) : [];
        ne.setContentType([we || "multipart/form-data", ...Ee].join("; "));
      }
    }
    let le = new XMLHttpRequest();
    if (Y.auth) {
      const we = Y.auth.username || "", Ee = Y.auth.password ? unescape(encodeURIComponent(Y.auth.password)) : "";
      ne.set("Authorization", "Basic " + btoa(we + ":" + Ee));
    }
    const he = M2(Y.baseURL, Y.url);
    le.open(Y.method.toUpperCase(), P2(he, Y.params, Y.paramsSerializer), !0), le.timeout = Y.timeout;
    function me() {
      if (!le)
        return;
      const we = Es.from(
        "getAllResponseHeaders" in le && le.getAllResponseHeaders()
      ), Ee = {
        data: !ie || ie === "text" || ie === "json" ? le.responseText : le.response,
        status: le.status,
        statusText: le.statusText,
        headers: we,
        config: Y,
        request: le
      };
      R4(function(Re) {
        X(Re), ae();
      }, function(Re) {
        ee(Re), ae();
      }, Ee), le = null;
    }
    if ("onloadend" in le ? le.onloadend = me : le.onreadystatechange = function() {
      !le || le.readyState !== 4 || le.status === 0 && !(le.responseURL && le.responseURL.indexOf("file:") === 0) || setTimeout(me);
    }, le.onabort = function() {
      le && (ee(new jt("Request aborted", jt.ECONNABORTED, Y, le)), le = null);
    }, le.onerror = function() {
      ee(new jt("Network Error", jt.ERR_NETWORK, Y, le)), le = null;
    }, le.ontimeout = function() {
      let we = Y.timeout ? "timeout of " + Y.timeout + "ms exceeded" : "timeout exceeded";
      const Ee = Y.transitional || O2;
      Y.timeoutErrorMessage && (we = Y.timeoutErrorMessage), ee(new jt(
        we,
        Ee.clarifyTimeoutError ? jt.ETIMEDOUT : jt.ECONNABORTED,
        Y,
        le
      )), le = null;
    }, Ui.hasStandardBrowserEnv && (oe && _e.isFunction(oe) && (oe = oe(Y)), oe || oe !== !1 && B4(he))) {
      const we = Y.xsrfHeaderName && Y.xsrfCookieName && C4.read(Y.xsrfCookieName);
      we && ne.set(Y.xsrfHeaderName, we);
    }
    te === void 0 && ne.setContentType(null), "setRequestHeader" in le && _e.forEach(ne.toJSON(), function(we, Ee) {
      le.setRequestHeader(Ee, we);
    }), _e.isUndefined(Y.withCredentials) || (le.withCredentials = !!Y.withCredentials), ie && ie !== "json" && (le.responseType = Y.responseType), typeof Y.onDownloadProgress == "function" && le.addEventListener("progress", Lb(Y.onDownloadProgress, !0)), typeof Y.onUploadProgress == "function" && le.upload && le.upload.addEventListener("progress", Lb(Y.onUploadProgress)), (Y.cancelToken || Y.signal) && (se = (we) => {
      le && (ee(!we || we.type ? new of(null, Y, le) : we), le.abort(), le = null);
    }, Y.cancelToken && Y.cancelToken.subscribe(se), Y.signal && (Y.signal.aborted ? se() : Y.signal.addEventListener("abort", se)));
    const ye = N4(he);
    if (ye && Ui.protocols.indexOf(ye) === -1) {
      ee(new jt("Unsupported protocol " + ye + ":", jt.ERR_BAD_REQUEST, Y));
      return;
    }
    le.send(te || null);
  });
}, Bp = {
  http: a4,
  xhr: L4
};
_e.forEach(Bp, (Y, X) => {
  if (Y) {
    try {
      Object.defineProperty(Y, "name", { value: X });
    } catch {
    }
    Object.defineProperty(Y, "adapterName", { value: X });
  }
});
const Fb = (Y) => `- ${Y}`, F4 = (Y) => _e.isFunction(Y) || Y === null || Y === !1, L2 = {
  getAdapter: (Y) => {
    Y = _e.isArray(Y) ? Y : [Y];
    const { length: X } = Y;
    let ee, te;
    const ne = {};
    for (let ie = 0; ie < X; ie++) {
      ee = Y[ie];
      let oe;
      if (te = ee, !F4(ee) && (te = Bp[(oe = String(ee)).toLowerCase()], te === void 0))
        throw new jt(`Unknown adapter '${oe}'`);
      if (te)
        break;
      ne[oe || "#" + ie] = te;
    }
    if (!te) {
      const ie = Object.entries(ne).map(
        ([se, ae]) => `adapter ${se} ` + (ae === !1 ? "is not supported by the environment" : "is not available in the build")
      );
      let oe = X ? ie.length > 1 ? `since :
` + ie.map(Fb).join(`
`) : " " + Fb(ie[0]) : "as no adapter specified";
      throw new jt(
        "There is no suitable adapter to dispatch the request " + oe,
        "ERR_NOT_SUPPORT"
      );
    }
    return te;
  },
  adapters: Bp
};
function W0(Y) {
  if (Y.cancelToken && Y.cancelToken.throwIfRequested(), Y.signal && Y.signal.aborted)
    throw new of(null, Y);
}
function $b(Y) {
  return W0(Y), Y.headers = Es.from(Y.headers), Y.data = V0.call(
    Y,
    Y.transformRequest
  ), ["post", "put", "patch"].indexOf(Y.method) !== -1 && Y.headers.setContentType("application/x-www-form-urlencoded", !1), L2.getAdapter(Y.adapter || rm.adapter)(Y).then(function(X) {
    return W0(Y), X.data = V0.call(
      Y,
      Y.transformResponse,
      X
    ), X.headers = Es.from(X.headers), X;
  }, function(X) {
    return k2(X) || (W0(Y), X && X.response && (X.response.data = V0.call(
      Y,
      Y.transformResponse,
      X.response
    ), X.response.headers = Es.from(X.response.headers))), Promise.reject(X);
  });
}
const Db = (Y) => Y instanceof Es ? Y.toJSON() : Y;
function ja(Y, X) {
  X = X || {};
  const ee = {};
  function te(ue, le, he) {
    return _e.isPlainObject(ue) && _e.isPlainObject(le) ? _e.merge.call({ caseless: he }, ue, le) : _e.isPlainObject(le) ? _e.merge({}, le) : _e.isArray(le) ? le.slice() : le;
  }
  function ne(ue, le, he) {
    if (_e.isUndefined(le)) {
      if (!_e.isUndefined(ue))
        return te(void 0, ue, he);
    } else
      return te(ue, le, he);
  }
  function ie(ue, le) {
    if (!_e.isUndefined(le))
      return te(void 0, le);
  }
  function oe(ue, le) {
    if (_e.isUndefined(le)) {
      if (!_e.isUndefined(ue))
        return te(void 0, ue);
    } else
      return te(void 0, le);
  }
  function se(ue, le, he) {
    if (he in X)
      return te(ue, le);
    if (he in Y)
      return te(void 0, ue);
  }
  const ae = {
    url: ie,
    method: ie,
    data: ie,
    baseURL: oe,
    transformRequest: oe,
    transformResponse: oe,
    paramsSerializer: oe,
    timeout: oe,
    timeoutMessage: oe,
    withCredentials: oe,
    withXSRFToken: oe,
    adapter: oe,
    responseType: oe,
    xsrfCookieName: oe,
    xsrfHeaderName: oe,
    onUploadProgress: oe,
    onDownloadProgress: oe,
    decompress: oe,
    maxContentLength: oe,
    maxBodyLength: oe,
    beforeRedirect: oe,
    transport: oe,
    httpAgent: oe,
    httpsAgent: oe,
    cancelToken: oe,
    socketPath: oe,
    responseEncoding: oe,
    validateStatus: se,
    headers: (ue, le) => ne(Db(ue), Db(le), !0)
  };
  return _e.forEach(Object.keys(Object.assign({}, Y, X)), function(ue) {
    const le = ae[ue] || ne, he = le(Y[ue], X[ue], ue);
    _e.isUndefined(he) && le !== se || (ee[ue] = he);
  }), ee;
}
const F2 = "1.6.7", nm = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((Y, X) => {
  nm[Y] = function(ee) {
    return typeof ee === Y || "a" + (X < 1 ? "n " : " ") + Y;
  };
});
const Ub = {};
nm.transitional = function(Y, X, ee) {
  function te(ne, ie) {
    return "[Axios v" + F2 + "] Transitional option '" + ne + "'" + ie + (ee ? ". " + ee : "");
  }
  return (ne, ie, oe) => {
    if (Y === !1)
      throw new jt(
        te(ie, " has been removed" + (X ? " in " + X : "")),
        jt.ERR_DEPRECATED
      );
    return X && !Ub[ie] && (Ub[ie] = !0, console.warn(
      te(
        ie,
        " has been deprecated since v" + X + " and will be removed in the near future"
      )
    )), Y ? Y(ne, ie, oe) : !0;
  };
};
function $4(Y, X, ee) {
  if (typeof Y != "object")
    throw new jt("options must be an object", jt.ERR_BAD_OPTION_VALUE);
  const te = Object.keys(Y);
  let ne = te.length;
  for (; ne-- > 0; ) {
    const ie = te[ne], oe = X[ie];
    if (oe) {
      const se = Y[ie], ae = se === void 0 || oe(se, ie, Y);
      if (ae !== !0)
        throw new jt("option " + ie + " must be " + ae, jt.ERR_BAD_OPTION_VALUE);
      continue;
    }
    if (ee !== !0)
      throw new jt("Unknown option " + ie, jt.ERR_BAD_OPTION);
  }
}
const Np = {
  assertOptions: $4,
  validators: nm
}, Ds = Np.validators;
class Ol {
  constructor(X) {
    this.defaults = X, this.interceptors = {
      request: new kb(),
      response: new kb()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(X, ee) {
    try {
      return await this._request(X, ee);
    } catch (te) {
      if (te instanceof Error) {
        let ne;
        Error.captureStackTrace ? Error.captureStackTrace(ne = {}) : ne = new Error();
        const ie = ne.stack ? ne.stack.replace(/^.+\n/, "") : "";
        te.stack ? ie && !String(te.stack).endsWith(ie.replace(/^.+\n.+\n/, "")) && (te.stack += `
` + ie) : te.stack = ie;
      }
      throw te;
    }
  }
  _request(X, ee) {
    typeof X == "string" ? (ee = ee || {}, ee.url = X) : ee = X || {}, ee = ja(this.defaults, ee);
    const { transitional: te, paramsSerializer: ne, headers: ie } = ee;
    te !== void 0 && Np.assertOptions(te, {
      silentJSONParsing: Ds.transitional(Ds.boolean),
      forcedJSONParsing: Ds.transitional(Ds.boolean),
      clarifyTimeoutError: Ds.transitional(Ds.boolean)
    }, !1), ne != null && (_e.isFunction(ne) ? ee.paramsSerializer = {
      serialize: ne
    } : Np.assertOptions(ne, {
      encode: Ds.function,
      serialize: Ds.function
    }, !0)), ee.method = (ee.method || this.defaults.method || "get").toLowerCase();
    let oe = ie && _e.merge(
      ie.common,
      ie[ee.method]
    );
    ie && _e.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (we) => {
        delete ie[we];
      }
    ), ee.headers = Es.concat(oe, ie);
    const se = [];
    let ae = !0;
    this.interceptors.request.forEach(function(we) {
      typeof we.runWhen == "function" && we.runWhen(ee) === !1 || (ae = ae && we.synchronous, se.unshift(we.fulfilled, we.rejected));
    });
    const ue = [];
    this.interceptors.response.forEach(function(we) {
      ue.push(we.fulfilled, we.rejected);
    });
    let le, he = 0, me;
    if (!ae) {
      const we = [$b.bind(this), void 0];
      for (we.unshift.apply(we, se), we.push.apply(we, ue), me = we.length, le = Promise.resolve(ee); he < me; )
        le = le.then(we[he++], we[he++]);
      return le;
    }
    me = se.length;
    let ye = ee;
    for (he = 0; he < me; ) {
      const we = se[he++], Ee = se[he++];
      try {
        ye = we(ye);
      } catch (Re) {
        Ee.call(this, Re);
        break;
      }
    }
    try {
      le = $b.call(this, ye);
    } catch (we) {
      return Promise.reject(we);
    }
    for (he = 0, me = ue.length; he < me; )
      le = le.then(ue[he++], ue[he++]);
    return le;
  }
  getUri(X) {
    X = ja(this.defaults, X);
    const ee = M2(X.baseURL, X.url);
    return P2(ee, X.params, X.paramsSerializer);
  }
}
_e.forEach(["delete", "get", "head", "options"], function(Y) {
  Ol.prototype[Y] = function(X, ee) {
    return this.request(ja(ee || {}, {
      method: Y,
      url: X,
      data: (ee || {}).data
    }));
  };
});
_e.forEach(["post", "put", "patch"], function(Y) {
  function X(ee) {
    return function(te, ne, ie) {
      return this.request(ja(ie || {}, {
        method: Y,
        headers: ee ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: te,
        data: ne
      }));
    };
  }
  Ol.prototype[Y] = X(), Ol.prototype[Y + "Form"] = X(!0);
});
const gl = Ol;
class im {
  constructor(X) {
    if (typeof X != "function")
      throw new TypeError("executor must be a function.");
    let ee;
    this.promise = new Promise(function(ne) {
      ee = ne;
    });
    const te = this;
    this.promise.then((ne) => {
      if (!te._listeners)
        return;
      let ie = te._listeners.length;
      for (; ie-- > 0; )
        te._listeners[ie](ne);
      te._listeners = null;
    }), this.promise.then = (ne) => {
      let ie;
      const oe = new Promise((se) => {
        te.subscribe(se), ie = se;
      }).then(ne);
      return oe.cancel = function() {
        te.unsubscribe(ie);
      }, oe;
    }, X(function(ne, ie, oe) {
      te.reason || (te.reason = new of(ne, ie, oe), ee(te.reason));
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason)
      throw this.reason;
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(X) {
    if (this.reason) {
      X(this.reason);
      return;
    }
    this._listeners ? this._listeners.push(X) : this._listeners = [X];
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(X) {
    if (!this._listeners)
      return;
    const ee = this._listeners.indexOf(X);
    ee !== -1 && this._listeners.splice(ee, 1);
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let X;
    return {
      token: new im(function(ee) {
        X = ee;
      }),
      cancel: X
    };
  }
}
const D4 = im;
function U4(Y) {
  return function(X) {
    return Y.apply(null, X);
  };
}
function j4(Y) {
  return _e.isObject(Y) && Y.isAxiosError === !0;
}
const kp = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(kp).forEach(([Y, X]) => {
  kp[X] = Y;
});
const H4 = kp;
function $2(Y) {
  const X = new gl(Y), ee = b2(gl.prototype.request, X);
  return _e.extend(ee, gl.prototype, X, { allOwnKeys: !0 }), _e.extend(ee, X, null, { allOwnKeys: !0 }), ee.create = function(te) {
    return $2(ja(Y, te));
  }, ee;
}
const nr = $2(rm);
nr.Axios = gl;
nr.CanceledError = of;
nr.CancelToken = D4;
nr.isCancel = k2;
nr.VERSION = F2;
nr.toFormData = vd;
nr.AxiosError = jt;
nr.Cancel = nr.CanceledError;
nr.all = function(Y) {
  return Promise.all(Y);
};
nr.spread = U4;
nr.isAxiosError = j4;
nr.mergeConfig = ja;
nr.AxiosHeaders = Es;
nr.formToJSON = (Y) => N2(_e.isHTMLForm(Y) ? new FormData(Y) : Y);
nr.getAdapter = L2.getAdapter;
nr.HttpStatusCode = H4;
nr.default = nr;
class D2 {
  constructor(X) {
    this.triaAxios = nr.create({
      baseURL: `${X}/api/v2/`,
      withCredentials: !0
    }), this.triaAxios.interceptors.request.use(
      (ee) => (console.log("Request made with", ee), ee),
      (ee) => (console.error("Request error:", ee), Promise.reject(ee))
    ), this.triaAxios.interceptors.response.use(
      (ee) => {
        if (console.log("intercepting responseee"), ee.status === 401) {
          console.log("intercepting 401 response");
          const te = new Event("unauthorized");
          window.dispatchEvent(te);
        } else
          console.error("Non-200 status code:", ee.status);
        return ee;
      },
      (ee) => (ee.response ? console.error("Response error with status:", ee.response.status) : ee.request ? console.error("No response was received:", ee.request) : console.error("Error setting up the request:", ee.message), Promise.reject(ee))
    );
  }
}
const Qs = (Y) => {
  if (nr.isAxiosError(Y)) {
    const X = Y;
    return X.response ? X.response.data : X.request ? { message: "something went wrong, please try again", success: !1 } : { message: X.message, success: !1 };
  } else
    return Y instanceof Error ? { message: Y.message, success: !1 } : { message: Y, success: !1 };
}, z4 = (Y) => {
  var X;
  return (X = Y == null ? void 0 : Y.toString()) == null ? void 0 : X.includes("@tria");
};
class U2 extends D2 {
  constructor(X) {
    super(X);
  }
  async add(X, ee, te) {
    try {
      const { data: ne } = await this.triaAxios.post(
        "/wallet/add",
        {
          password: X,
          chainName: te,
          pin: ee
        },
        {}
      );
      return ne;
    } catch (ne) {
      return Qs(ne);
    }
  }
  async updateSubName({
    newSubName: X,
    oldSubName: ee,
    password: te,
    pin: ne
  }) {
    try {
      const { data: ie } = await this.triaAxios.post("/wallet/update-subname", {
        newSubName: X,
        oldSubName: ee,
        password: te,
        pin: ne
      });
      return ie;
    } catch (ie) {
      return Qs(ie);
    }
  }
  async removeSubname({ subname: X, password: ee, pin: te }) {
    try {
      const { data: ne } = await this.triaAxios.post("/wallet/remove-address", {
        subname: X,
        password: ee,
        pin: te
      });
      return ne;
    } catch (ne) {
      return Qs(ne);
    }
  }
  async resolveTriaName({ chainName: X, lookUpTriaName: ee }, te) {
    try {
      const { data: ne } = await this.triaAxios.post("/wallet/resolveTriaName", {
        chainName: X,
        lookUpTriaName: ee
      });
      return ne;
    } catch {
      throw Error("Unable to resolve DID.");
    }
  }
  // async resolveTriaNameSG(
  //   { chainName, lookUpTriaName }: ResolveTriaName,
  //   environment?: ENV
  // ): Promise<{ address: string }> {
  //   try {
  //     const did = lookUpTriaName;
  //     var data = JSON.stringify({
  //       query: `query MyQuery($id: ID!, $didName: String!, $chainNameVar: String!) {
  //         didToEvmAddress(id: $id) {
  //           did
  //           evmAddress
  //         }
  //         didToNonEvmAddresses(where: {did: $didName, chain_: {chainName: $chainNameVar}}) {
  //           did
  //           nonEvmAddress
  //           chain {
  //             id
  //             chainName
  //           }
  //         }
  //       }`,
  //       variables: { id: did, didName: did, chainNameVar: chainName },
  //     });
  //     var config = {
  //       method: 'post',
  //       url: getSubgraphUrl(environment),
  //       headers: {
  //         'Content-Type': 'application/json',
  //       },
  //       data: data,
  //     };
  //     const { data: didData } = await axios(config);
  //     console.log({ didData });
  //     const evmAddress = didData?.data?.didToEvmAddress?.evmAddress;
  //     if (!evmAddress) throw Error('DID does not exist!');
  //     // if chainName is not in EVM
  //     // return didData.data.didToNonEvmAddresses[0].nonEvmAddress;
  //     return { address: evmAddress };
  //   } catch (err) {
  //     throw Error('Unable to resolve DID.');
  //   }
  // }
  async addNonEvmShards({ accountKeys: X }) {
    try {
      const { data: ee } = await this.triaAxios.post("/wallet/add-nonEVMShards", {
        shardedAccountKeys: X
      });
      return ee;
    } catch (ee) {
      return Qs(ee);
    }
  }
}
class j2 extends D2 {
  constructor(X) {
    super(X);
  }
  async get_tID() {
    try {
      const { data: X } = await this.triaAxios.get("/user/get-tID");
      return X;
    } catch (X) {
      return Qs(X);
    }
  }
  async getAllAddresses() {
    try {
      const { data: X } = await this.triaAxios.get("/user/getAllAddresses");
      return X;
    } catch (X) {
      return Qs(X);
    }
  }
  async addUserActivity(X, ee) {
    try {
      const { data: te } = await this.triaAxios.post("/user/activity", {
        triaName: X,
        sentToTriaName: ee
      });
      return te;
    } catch (te) {
      return Qs(te);
    }
  }
  async getTokenData(X) {
    try {
      const { data: ee } = await this.triaAxios.get("/getTokenData", {
        params: {
          chainName: X
        }
      });
      return ee == null ? void 0 : ee.data;
    } catch (ee) {
      return Qs(ee);
    }
  }
}
var St = typeof globalThis < "u" ? globalThis : typeof window < "u" || typeof window < "u" ? window : typeof self < "u" ? self : {};
function uc(Y) {
  return Y && Y.__esModule && Object.prototype.hasOwnProperty.call(Y, "default") ? Y.default : Y;
}
function _d(Y) {
  if (Y.__esModule)
    return Y;
  var X = Y.default;
  if (typeof X == "function") {
    var ee = function te() {
      return this instanceof te ? Reflect.construct(X, arguments, this.constructor) : X.apply(this, arguments);
    };
    ee.prototype = X.prototype;
  } else
    ee = {};
  return Object.defineProperty(ee, "__esModule", { value: !0 }), Object.keys(Y).forEach(function(te) {
    var ne = Object.getOwnPropertyDescriptor(Y, te);
    Object.defineProperty(ee, te, ne.get ? ne : {
      enumerable: !0,
      get: function() {
        return Y[te];
      }
    });
  }), ee;
}
var sm = { exports: {} };
const q4 = {}, G4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: q4
}, Symbol.toStringTag, { value: "Module" })), Ta = /* @__PURE__ */ _d(G4);
(function(Y) {
  (function(X, ee) {
    function te(fe, de) {
      if (!fe)
        throw new Error(de || "Assertion failed");
    }
    function ne(fe, de) {
      fe.super_ = de;
      var be = function() {
      };
      be.prototype = de.prototype, fe.prototype = new be(), fe.prototype.constructor = fe;
    }
    function ie(fe, de, be) {
      if (ie.isBN(fe))
        return fe;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, fe !== null && ((de === "le" || de === "be") && (be = de, de = 10), this._init(fe || 0, de || 10, be || "be"));
    }
    typeof X == "object" ? X.exports = ie : ee.BN = ie, ie.BN = ie, ie.wordSize = 26;
    var oe;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? oe = window.Buffer : oe = Ta.Buffer;
    } catch {
    }
    ie.isBN = function(fe) {
      return fe instanceof ie ? !0 : fe !== null && typeof fe == "object" && fe.constructor.wordSize === ie.wordSize && Array.isArray(fe.words);
    }, ie.max = function(fe, de) {
      return fe.cmp(de) > 0 ? fe : de;
    }, ie.min = function(fe, de) {
      return fe.cmp(de) < 0 ? fe : de;
    }, ie.prototype._init = function(fe, de, be) {
      if (typeof fe == "number")
        return this._initNumber(fe, de, be);
      if (typeof fe == "object")
        return this._initArray(fe, de, be);
      de === "hex" && (de = 16), te(de === (de | 0) && de >= 2 && de <= 36), fe = fe.toString().replace(/\s+/g, "");
      var Te = 0;
      fe[0] === "-" && (Te++, this.negative = 1), Te < fe.length && (de === 16 ? this._parseHex(fe, Te, be) : (this._parseBase(fe, de, Te), be === "le" && this._initArray(this.toArray(), de, be)));
    }, ie.prototype._initNumber = function(fe, de, be) {
      fe < 0 && (this.negative = 1, fe = -fe), fe < 67108864 ? (this.words = [fe & 67108863], this.length = 1) : fe < 4503599627370496 ? (this.words = [
        fe & 67108863,
        fe / 67108864 & 67108863
      ], this.length = 2) : (te(fe < 9007199254740992), this.words = [
        fe & 67108863,
        fe / 67108864 & 67108863,
        1
      ], this.length = 3), be === "le" && this._initArray(this.toArray(), de, be);
    }, ie.prototype._initArray = function(fe, de, be) {
      if (te(typeof fe.length == "number"), fe.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(fe.length / 3), this.words = new Array(this.length);
      for (var Te = 0; Te < this.length; Te++)
        this.words[Te] = 0;
      var Ce, Pe, Se = 0;
      if (be === "be")
        for (Te = fe.length - 1, Ce = 0; Te >= 0; Te -= 3)
          Pe = fe[Te] | fe[Te - 1] << 8 | fe[Te - 2] << 16, this.words[Ce] |= Pe << Se & 67108863, this.words[Ce + 1] = Pe >>> 26 - Se & 67108863, Se += 24, Se >= 26 && (Se -= 26, Ce++);
      else if (be === "le")
        for (Te = 0, Ce = 0; Te < fe.length; Te += 3)
          Pe = fe[Te] | fe[Te + 1] << 8 | fe[Te + 2] << 16, this.words[Ce] |= Pe << Se & 67108863, this.words[Ce + 1] = Pe >>> 26 - Se & 67108863, Se += 24, Se >= 26 && (Se -= 26, Ce++);
      return this._strip();
    };
    function se(fe, de) {
      var be = fe.charCodeAt(de);
      if (be >= 48 && be <= 57)
        return be - 48;
      if (be >= 65 && be <= 70)
        return be - 55;
      if (be >= 97 && be <= 102)
        return be - 87;
      te(!1, "Invalid character in " + fe);
    }
    function ae(fe, de, be) {
      var Te = se(fe, be);
      return be - 1 >= de && (Te |= se(fe, be - 1) << 4), Te;
    }
    ie.prototype._parseHex = function(fe, de, be) {
      this.length = Math.ceil((fe.length - de) / 6), this.words = new Array(this.length);
      for (var Te = 0; Te < this.length; Te++)
        this.words[Te] = 0;
      var Ce = 0, Pe = 0, Se;
      if (be === "be")
        for (Te = fe.length - 1; Te >= de; Te -= 2)
          Se = ae(fe, de, Te) << Ce, this.words[Pe] |= Se & 67108863, Ce >= 18 ? (Ce -= 18, Pe += 1, this.words[Pe] |= Se >>> 26) : Ce += 8;
      else {
        var ke = fe.length - de;
        for (Te = ke % 2 === 0 ? de + 1 : de; Te < fe.length; Te += 2)
          Se = ae(fe, de, Te) << Ce, this.words[Pe] |= Se & 67108863, Ce >= 18 ? (Ce -= 18, Pe += 1, this.words[Pe] |= Se >>> 26) : Ce += 8;
      }
      this._strip();
    };
    function ue(fe, de, be, Te) {
      for (var Ce = 0, Pe = 0, Se = Math.min(fe.length, be), ke = de; ke < Se; ke++) {
        var ge = fe.charCodeAt(ke) - 48;
        Ce *= Te, ge >= 49 ? Pe = ge - 49 + 10 : ge >= 17 ? Pe = ge - 17 + 10 : Pe = ge, te(ge >= 0 && Pe < Te, "Invalid character"), Ce += Pe;
      }
      return Ce;
    }
    ie.prototype._parseBase = function(fe, de, be) {
      this.words = [0], this.length = 1;
      for (var Te = 0, Ce = 1; Ce <= 67108863; Ce *= de)
        Te++;
      Te--, Ce = Ce / de | 0;
      for (var Pe = fe.length - be, Se = Pe % Te, ke = Math.min(Pe, Pe - Se) + be, ge = 0, Ae = be; Ae < ke; Ae += Te)
        ge = ue(fe, Ae, Ae + Te, de), this.imuln(Ce), this.words[0] + ge < 67108864 ? this.words[0] += ge : this._iaddn(ge);
      if (Se !== 0) {
        var Ge = 1;
        for (ge = ue(fe, Ae, fe.length, de), Ae = 0; Ae < Se; Ae++)
          Ge *= de;
        this.imuln(Ge), this.words[0] + ge < 67108864 ? this.words[0] += ge : this._iaddn(ge);
      }
      this._strip();
    }, ie.prototype.copy = function(fe) {
      fe.words = new Array(this.length);
      for (var de = 0; de < this.length; de++)
        fe.words[de] = this.words[de];
      fe.length = this.length, fe.negative = this.negative, fe.red = this.red;
    };
    function le(fe, de) {
      fe.words = de.words, fe.length = de.length, fe.negative = de.negative, fe.red = de.red;
    }
    if (ie.prototype._move = function(fe) {
      le(fe, this);
    }, ie.prototype.clone = function() {
      var fe = new ie(null);
      return this.copy(fe), fe;
    }, ie.prototype._expand = function(fe) {
      for (; this.length < fe; )
        this.words[this.length++] = 0;
      return this;
    }, ie.prototype._strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, ie.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, typeof Symbol < "u" && typeof Symbol.for == "function")
      try {
        ie.prototype[Symbol.for("nodejs.util.inspect.custom")] = he;
      } catch {
        ie.prototype.inspect = he;
      }
    else
      ie.prototype.inspect = he;
    function he() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    }
    var me = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], ye = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], we = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    ie.prototype.toString = function(fe, de) {
      fe = fe || 10, de = de | 0 || 1;
      var be;
      if (fe === 16 || fe === "hex") {
        be = "";
        for (var Te = 0, Ce = 0, Pe = 0; Pe < this.length; Pe++) {
          var Se = this.words[Pe], ke = ((Se << Te | Ce) & 16777215).toString(16);
          Ce = Se >>> 24 - Te & 16777215, Te += 2, Te >= 26 && (Te -= 26, Pe--), Ce !== 0 || Pe !== this.length - 1 ? be = me[6 - ke.length] + ke + be : be = ke + be;
        }
        for (Ce !== 0 && (be = Ce.toString(16) + be); be.length % de !== 0; )
          be = "0" + be;
        return this.negative !== 0 && (be = "-" + be), be;
      }
      if (fe === (fe | 0) && fe >= 2 && fe <= 36) {
        var ge = ye[fe], Ae = we[fe];
        be = "";
        var Ge = this.clone();
        for (Ge.negative = 0; !Ge.isZero(); ) {
          var Xe = Ge.modrn(Ae).toString(fe);
          Ge = Ge.idivn(Ae), Ge.isZero() ? be = Xe + be : be = me[ge - Xe.length] + Xe + be;
        }
        for (this.isZero() && (be = "0" + be); be.length % de !== 0; )
          be = "0" + be;
        return this.negative !== 0 && (be = "-" + be), be;
      }
      te(!1, "Base should be between 2 and 36");
    }, ie.prototype.toNumber = function() {
      var fe = this.words[0];
      return this.length === 2 ? fe += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? fe += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && te(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -fe : fe;
    }, ie.prototype.toJSON = function() {
      return this.toString(16, 2);
    }, oe && (ie.prototype.toBuffer = function(fe, de) {
      return this.toArrayLike(oe, fe, de);
    }), ie.prototype.toArray = function(fe, de) {
      return this.toArrayLike(Array, fe, de);
    };
    var Ee = function(fe, de) {
      return fe.allocUnsafe ? fe.allocUnsafe(de) : new fe(de);
    };
    ie.prototype.toArrayLike = function(fe, de, be) {
      this._strip();
      var Te = this.byteLength(), Ce = be || Math.max(1, Te);
      te(Te <= Ce, "byte array longer than desired length"), te(Ce > 0, "Requested array length <= 0");
      var Pe = Ee(fe, Ce), Se = de === "le" ? "LE" : "BE";
      return this["_toArrayLike" + Se](Pe, Te), Pe;
    }, ie.prototype._toArrayLikeLE = function(fe, de) {
      for (var be = 0, Te = 0, Ce = 0, Pe = 0; Ce < this.length; Ce++) {
        var Se = this.words[Ce] << Pe | Te;
        fe[be++] = Se & 255, be < fe.length && (fe[be++] = Se >> 8 & 255), be < fe.length && (fe[be++] = Se >> 16 & 255), Pe === 6 ? (be < fe.length && (fe[be++] = Se >> 24 & 255), Te = 0, Pe = 0) : (Te = Se >>> 24, Pe += 2);
      }
      if (be < fe.length)
        for (fe[be++] = Te; be < fe.length; )
          fe[be++] = 0;
    }, ie.prototype._toArrayLikeBE = function(fe, de) {
      for (var be = fe.length - 1, Te = 0, Ce = 0, Pe = 0; Ce < this.length; Ce++) {
        var Se = this.words[Ce] << Pe | Te;
        fe[be--] = Se & 255, be >= 0 && (fe[be--] = Se >> 8 & 255), be >= 0 && (fe[be--] = Se >> 16 & 255), Pe === 6 ? (be >= 0 && (fe[be--] = Se >> 24 & 255), Te = 0, Pe = 0) : (Te = Se >>> 24, Pe += 2);
      }
      if (be >= 0)
        for (fe[be--] = Te; be >= 0; )
          fe[be--] = 0;
    }, Math.clz32 ? ie.prototype._countBits = function(fe) {
      return 32 - Math.clz32(fe);
    } : ie.prototype._countBits = function(fe) {
      var de = fe, be = 0;
      return de >= 4096 && (be += 13, de >>>= 13), de >= 64 && (be += 7, de >>>= 7), de >= 8 && (be += 4, de >>>= 4), de >= 2 && (be += 2, de >>>= 2), be + de;
    }, ie.prototype._zeroBits = function(fe) {
      if (fe === 0)
        return 26;
      var de = fe, be = 0;
      return de & 8191 || (be += 13, de >>>= 13), de & 127 || (be += 7, de >>>= 7), de & 15 || (be += 4, de >>>= 4), de & 3 || (be += 2, de >>>= 2), de & 1 || be++, be;
    }, ie.prototype.bitLength = function() {
      var fe = this.words[this.length - 1], de = this._countBits(fe);
      return (this.length - 1) * 26 + de;
    };
    function Re(fe) {
      for (var de = new Array(fe.bitLength()), be = 0; be < de.length; be++) {
        var Te = be / 26 | 0, Ce = be % 26;
        de[be] = fe.words[Te] >>> Ce & 1;
      }
      return de;
    }
    ie.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var fe = 0, de = 0; de < this.length; de++) {
        var be = this._zeroBits(this.words[de]);
        if (fe += be, be !== 26)
          break;
      }
      return fe;
    }, ie.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, ie.prototype.toTwos = function(fe) {
      return this.negative !== 0 ? this.abs().inotn(fe).iaddn(1) : this.clone();
    }, ie.prototype.fromTwos = function(fe) {
      return this.testn(fe - 1) ? this.notn(fe).iaddn(1).ineg() : this.clone();
    }, ie.prototype.isNeg = function() {
      return this.negative !== 0;
    }, ie.prototype.neg = function() {
      return this.clone().ineg();
    }, ie.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, ie.prototype.iuor = function(fe) {
      for (; this.length < fe.length; )
        this.words[this.length++] = 0;
      for (var de = 0; de < fe.length; de++)
        this.words[de] = this.words[de] | fe.words[de];
      return this._strip();
    }, ie.prototype.ior = function(fe) {
      return te((this.negative | fe.negative) === 0), this.iuor(fe);
    }, ie.prototype.or = function(fe) {
      return this.length > fe.length ? this.clone().ior(fe) : fe.clone().ior(this);
    }, ie.prototype.uor = function(fe) {
      return this.length > fe.length ? this.clone().iuor(fe) : fe.clone().iuor(this);
    }, ie.prototype.iuand = function(fe) {
      var de;
      this.length > fe.length ? de = fe : de = this;
      for (var be = 0; be < de.length; be++)
        this.words[be] = this.words[be] & fe.words[be];
      return this.length = de.length, this._strip();
    }, ie.prototype.iand = function(fe) {
      return te((this.negative | fe.negative) === 0), this.iuand(fe);
    }, ie.prototype.and = function(fe) {
      return this.length > fe.length ? this.clone().iand(fe) : fe.clone().iand(this);
    }, ie.prototype.uand = function(fe) {
      return this.length > fe.length ? this.clone().iuand(fe) : fe.clone().iuand(this);
    }, ie.prototype.iuxor = function(fe) {
      var de, be;
      this.length > fe.length ? (de = this, be = fe) : (de = fe, be = this);
      for (var Te = 0; Te < be.length; Te++)
        this.words[Te] = de.words[Te] ^ be.words[Te];
      if (this !== de)
        for (; Te < de.length; Te++)
          this.words[Te] = de.words[Te];
      return this.length = de.length, this._strip();
    }, ie.prototype.ixor = function(fe) {
      return te((this.negative | fe.negative) === 0), this.iuxor(fe);
    }, ie.prototype.xor = function(fe) {
      return this.length > fe.length ? this.clone().ixor(fe) : fe.clone().ixor(this);
    }, ie.prototype.uxor = function(fe) {
      return this.length > fe.length ? this.clone().iuxor(fe) : fe.clone().iuxor(this);
    }, ie.prototype.inotn = function(fe) {
      te(typeof fe == "number" && fe >= 0);
      var de = Math.ceil(fe / 26) | 0, be = fe % 26;
      this._expand(de), be > 0 && de--;
      for (var Te = 0; Te < de; Te++)
        this.words[Te] = ~this.words[Te] & 67108863;
      return be > 0 && (this.words[Te] = ~this.words[Te] & 67108863 >> 26 - be), this._strip();
    }, ie.prototype.notn = function(fe) {
      return this.clone().inotn(fe);
    }, ie.prototype.setn = function(fe, de) {
      te(typeof fe == "number" && fe >= 0);
      var be = fe / 26 | 0, Te = fe % 26;
      return this._expand(be + 1), de ? this.words[be] = this.words[be] | 1 << Te : this.words[be] = this.words[be] & ~(1 << Te), this._strip();
    }, ie.prototype.iadd = function(fe) {
      var de;
      if (this.negative !== 0 && fe.negative === 0)
        return this.negative = 0, de = this.isub(fe), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && fe.negative !== 0)
        return fe.negative = 0, de = this.isub(fe), fe.negative = 1, de._normSign();
      var be, Te;
      this.length > fe.length ? (be = this, Te = fe) : (be = fe, Te = this);
      for (var Ce = 0, Pe = 0; Pe < Te.length; Pe++)
        de = (be.words[Pe] | 0) + (Te.words[Pe] | 0) + Ce, this.words[Pe] = de & 67108863, Ce = de >>> 26;
      for (; Ce !== 0 && Pe < be.length; Pe++)
        de = (be.words[Pe] | 0) + Ce, this.words[Pe] = de & 67108863, Ce = de >>> 26;
      if (this.length = be.length, Ce !== 0)
        this.words[this.length] = Ce, this.length++;
      else if (be !== this)
        for (; Pe < be.length; Pe++)
          this.words[Pe] = be.words[Pe];
      return this;
    }, ie.prototype.add = function(fe) {
      var de;
      return fe.negative !== 0 && this.negative === 0 ? (fe.negative = 0, de = this.sub(fe), fe.negative ^= 1, de) : fe.negative === 0 && this.negative !== 0 ? (this.negative = 0, de = fe.sub(this), this.negative = 1, de) : this.length > fe.length ? this.clone().iadd(fe) : fe.clone().iadd(this);
    }, ie.prototype.isub = function(fe) {
      if (fe.negative !== 0) {
        fe.negative = 0;
        var de = this.iadd(fe);
        return fe.negative = 1, de._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(fe), this.negative = 1, this._normSign();
      var be = this.cmp(fe);
      if (be === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var Te, Ce;
      be > 0 ? (Te = this, Ce = fe) : (Te = fe, Ce = this);
      for (var Pe = 0, Se = 0; Se < Ce.length; Se++)
        de = (Te.words[Se] | 0) - (Ce.words[Se] | 0) + Pe, Pe = de >> 26, this.words[Se] = de & 67108863;
      for (; Pe !== 0 && Se < Te.length; Se++)
        de = (Te.words[Se] | 0) + Pe, Pe = de >> 26, this.words[Se] = de & 67108863;
      if (Pe === 0 && Se < Te.length && Te !== this)
        for (; Se < Te.length; Se++)
          this.words[Se] = Te.words[Se];
      return this.length = Math.max(this.length, Se), Te !== this && (this.negative = 1), this._strip();
    }, ie.prototype.sub = function(fe) {
      return this.clone().isub(fe);
    };
    function Ue(fe, de, be) {
      be.negative = de.negative ^ fe.negative;
      var Te = fe.length + de.length | 0;
      be.length = Te, Te = Te - 1 | 0;
      var Ce = fe.words[0] | 0, Pe = de.words[0] | 0, Se = Ce * Pe, ke = Se & 67108863, ge = Se / 67108864 | 0;
      be.words[0] = ke;
      for (var Ae = 1; Ae < Te; Ae++) {
        for (var Ge = ge >>> 26, Xe = ge & 67108863, $e = Math.min(Ae, de.length - 1), Ze = Math.max(0, Ae - fe.length + 1); Ze <= $e; Ze++) {
          var ot = Ae - Ze | 0;
          Ce = fe.words[ot] | 0, Pe = de.words[Ze] | 0, Se = Ce * Pe + Xe, Ge += Se / 67108864 | 0, Xe = Se & 67108863;
        }
        be.words[Ae] = Xe | 0, ge = Ge | 0;
      }
      return ge !== 0 ? be.words[Ae] = ge | 0 : be.length--, be._strip();
    }
    var Me = function(fe, de, be) {
      var Te = fe.words, Ce = de.words, Pe = be.words, Se = 0, ke, ge, Ae, Ge = Te[0] | 0, Xe = Ge & 8191, $e = Ge >>> 13, Ze = Te[1] | 0, ot = Ze & 8191, ct = Ze >>> 13, At = Te[2] | 0, Tt = At & 8191, dt = At >>> 13, vt = Te[3] | 0, Ut = vt & 8191, It = vt >>> 13, Er = Te[4] | 0, Fr = Er & 8191, an = Er >>> 13, wX = Te[5] | 0, Ct = wX & 8191, w_ = wX >>> 13, hX = Te[6] | 0, oX = hX & 8191, Nn = hX >>> 13, SX = Te[7] | 0, sX = SX & 8191, nX = SX >>> 13, Ye = Te[8] | 0, lt = Ye & 8191, pt = Ye >>> 13, He = Te[9] | 0, Je = He & 8191, st = He >>> 13, gt = Ce[0] | 0, kt = gt & 8191, Vt = gt >>> 13, Lr = Ce[1] | 0, Ci = Lr & 8191, Qr = Lr >>> 13, xX = Ce[2] | 0, lX = xX & 8191, rX = xX >>> 13, FX = Ce[3] | 0, BX = FX & 8191, cX = FX >>> 13, MX = Ce[4] | 0, EX = MX & 8191, yX = MX >>> 13, jX = Ce[5] | 0, AX = jX & 8191, vX = jX >>> 13, PX = Ce[6] | 0, kX = PX & 8191, qe = PX >>> 13, Qe = Ce[7] | 0, Ve = Qe & 8191, Ie = Qe >>> 13, nt = Ce[8] | 0, Et = nt & 8191, xt = nt >>> 13, Jt = Ce[9] | 0, Yt = Jt & 8191, _r = Jt >>> 13;
      be.negative = fe.negative ^ de.negative, be.length = 19, ke = Math.imul(Xe, kt), ge = Math.imul(Xe, Vt), ge = ge + Math.imul($e, kt) | 0, Ae = Math.imul($e, Vt);
      var cn = (Se + ke | 0) + ((ge & 8191) << 13) | 0;
      Se = (Ae + (ge >>> 13) | 0) + (cn >>> 26) | 0, cn &= 67108863, ke = Math.imul(ot, kt), ge = Math.imul(ot, Vt), ge = ge + Math.imul(ct, kt) | 0, Ae = Math.imul(ct, Vt), ke = ke + Math.imul(Xe, Ci) | 0, ge = ge + Math.imul(Xe, Qr) | 0, ge = ge + Math.imul($e, Ci) | 0, Ae = Ae + Math.imul($e, Qr) | 0;
      var _X = (Se + ke | 0) + ((ge & 8191) << 13) | 0;
      Se = (Ae + (ge >>> 13) | 0) + (_X >>> 26) | 0, _X &= 67108863, ke = Math.imul(Tt, kt), ge = Math.imul(Tt, Vt), ge = ge + Math.imul(dt, kt) | 0, Ae = Math.imul(dt, Vt), ke = ke + Math.imul(ot, Ci) | 0, ge = ge + Math.imul(ot, Qr) | 0, ge = ge + Math.imul(ct, Ci) | 0, Ae = Ae + Math.imul(ct, Qr) | 0, ke = ke + Math.imul(Xe, lX) | 0, ge = ge + Math.imul(Xe, rX) | 0, ge = ge + Math.imul($e, lX) | 0, Ae = Ae + Math.imul($e, rX) | 0;
      var un = (Se + ke | 0) + ((ge & 8191) << 13) | 0;
      Se = (Ae + (ge >>> 13) | 0) + (un >>> 26) | 0, un &= 67108863, ke = Math.imul(Ut, kt), ge = Math.imul(Ut, Vt), ge = ge + Math.imul(It, kt) | 0, Ae = Math.imul(It, Vt), ke = ke + Math.imul(Tt, Ci) | 0, ge = ge + Math.imul(Tt, Qr) | 0, ge = ge + Math.imul(dt, Ci) | 0, Ae = Ae + Math.imul(dt, Qr) | 0, ke = ke + Math.imul(ot, lX) | 0, ge = ge + Math.imul(ot, rX) | 0, ge = ge + Math.imul(ct, lX) | 0, Ae = Ae + Math.imul(ct, rX) | 0, ke = ke + Math.imul(Xe, BX) | 0, ge = ge + Math.imul(Xe, cX) | 0, ge = ge + Math.imul($e, BX) | 0, Ae = Ae + Math.imul($e, cX) | 0;
      var aX = (Se + ke | 0) + ((ge & 8191) << 13) | 0;
      Se = (Ae + (ge >>> 13) | 0) + (aX >>> 26) | 0, aX &= 67108863, ke = Math.imul(Fr, kt), ge = Math.imul(Fr, Vt), ge = ge + Math.imul(an, kt) | 0, Ae = Math.imul(an, Vt), ke = ke + Math.imul(Ut, Ci) | 0, ge = ge + Math.imul(Ut, Qr) | 0, ge = ge + Math.imul(It, Ci) | 0, Ae = Ae + Math.imul(It, Qr) | 0, ke = ke + Math.imul(Tt, lX) | 0, ge = ge + Math.imul(Tt, rX) | 0, ge = ge + Math.imul(dt, lX) | 0, Ae = Ae + Math.imul(dt, rX) | 0, ke = ke + Math.imul(ot, BX) | 0, ge = ge + Math.imul(ot, cX) | 0, ge = ge + Math.imul(ct, BX) | 0, Ae = Ae + Math.imul(ct, cX) | 0, ke = ke + Math.imul(Xe, EX) | 0, ge = ge + Math.imul(Xe, yX) | 0, ge = ge + Math.imul($e, EX) | 0, Ae = Ae + Math.imul($e, yX) | 0;
      var uX = (Se + ke | 0) + ((ge & 8191) << 13) | 0;
      Se = (Ae + (ge >>> 13) | 0) + (uX >>> 26) | 0, uX &= 67108863, ke = Math.imul(Ct, kt), ge = Math.imul(Ct, Vt), ge = ge + Math.imul(w_, kt) | 0, Ae = Math.imul(w_, Vt), ke = ke + Math.imul(Fr, Ci) | 0, ge = ge + Math.imul(Fr, Qr) | 0, ge = ge + Math.imul(an, Ci) | 0, Ae = Ae + Math.imul(an, Qr) | 0, ke = ke + Math.imul(Ut, lX) | 0, ge = ge + Math.imul(Ut, rX) | 0, ge = ge + Math.imul(It, lX) | 0, Ae = Ae + Math.imul(It, rX) | 0, ke = ke + Math.imul(Tt, BX) | 0, ge = ge + Math.imul(Tt, cX) | 0, ge = ge + Math.imul(dt, BX) | 0, Ae = Ae + Math.imul(dt, cX) | 0, ke = ke + Math.imul(ot, EX) | 0, ge = ge + Math.imul(ot, yX) | 0, ge = ge + Math.imul(ct, EX) | 0, Ae = Ae + Math.imul(ct, yX) | 0, ke = ke + Math.imul(Xe, AX) | 0, ge = ge + Math.imul(Xe, vX) | 0, ge = ge + Math.imul($e, AX) | 0, Ae = Ae + Math.imul($e, vX) | 0;
      var fX = (Se + ke | 0) + ((ge & 8191) << 13) | 0;
      Se = (Ae + (ge >>> 13) | 0) + (fX >>> 26) | 0, fX &= 67108863, ke = Math.imul(oX, kt), ge = Math.imul(oX, Vt), ge = ge + Math.imul(Nn, kt) | 0, Ae = Math.imul(Nn, Vt), ke = ke + Math.imul(Ct, Ci) | 0, ge = ge + Math.imul(Ct, Qr) | 0, ge = ge + Math.imul(w_, Ci) | 0, Ae = Ae + Math.imul(w_, Qr) | 0, ke = ke + Math.imul(Fr, lX) | 0, ge = ge + Math.imul(Fr, rX) | 0, ge = ge + Math.imul(an, lX) | 0, Ae = Ae + Math.imul(an, rX) | 0, ke = ke + Math.imul(Ut, BX) | 0, ge = ge + Math.imul(Ut, cX) | 0, ge = ge + Math.imul(It, BX) | 0, Ae = Ae + Math.imul(It, cX) | 0, ke = ke + Math.imul(Tt, EX) | 0, ge = ge + Math.imul(Tt, yX) | 0, ge = ge + Math.imul(dt, EX) | 0, Ae = Ae + Math.imul(dt, yX) | 0, ke = ke + Math.imul(ot, AX) | 0, ge = ge + Math.imul(ot, vX) | 0, ge = ge + Math.imul(ct, AX) | 0, Ae = Ae + Math.imul(ct, vX) | 0, ke = ke + Math.imul(Xe, kX) | 0, ge = ge + Math.imul(Xe, qe) | 0, ge = ge + Math.imul($e, kX) | 0, Ae = Ae + Math.imul($e, qe) | 0;
      var bX = (Se + ke | 0) + ((ge & 8191) << 13) | 0;
      Se = (Ae + (ge >>> 13) | 0) + (bX >>> 26) | 0, bX &= 67108863, ke = Math.imul(sX, kt), ge = Math.imul(sX, Vt), ge = ge + Math.imul(nX, kt) | 0, Ae = Math.imul(nX, Vt), ke = ke + Math.imul(oX, Ci) | 0, ge = ge + Math.imul(oX, Qr) | 0, ge = ge + Math.imul(Nn, Ci) | 0, Ae = Ae + Math.imul(Nn, Qr) | 0, ke = ke + Math.imul(Ct, lX) | 0, ge = ge + Math.imul(Ct, rX) | 0, ge = ge + Math.imul(w_, lX) | 0, Ae = Ae + Math.imul(w_, rX) | 0, ke = ke + Math.imul(Fr, BX) | 0, ge = ge + Math.imul(Fr, cX) | 0, ge = ge + Math.imul(an, BX) | 0, Ae = Ae + Math.imul(an, cX) | 0, ke = ke + Math.imul(Ut, EX) | 0, ge = ge + Math.imul(Ut, yX) | 0, ge = ge + Math.imul(It, EX) | 0, Ae = Ae + Math.imul(It, yX) | 0, ke = ke + Math.imul(Tt, AX) | 0, ge = ge + Math.imul(Tt, vX) | 0, ge = ge + Math.imul(dt, AX) | 0, Ae = Ae + Math.imul(dt, vX) | 0, ke = ke + Math.imul(ot, kX) | 0, ge = ge + Math.imul(ot, qe) | 0, ge = ge + Math.imul(ct, kX) | 0, Ae = Ae + Math.imul(ct, qe) | 0, ke = ke + Math.imul(Xe, Ve) | 0, ge = ge + Math.imul(Xe, Ie) | 0, ge = ge + Math.imul($e, Ve) | 0, Ae = Ae + Math.imul($e, Ie) | 0;
      var dX = (Se + ke | 0) + ((ge & 8191) << 13) | 0;
      Se = (Ae + (ge >>> 13) | 0) + (dX >>> 26) | 0, dX &= 67108863, ke = Math.imul(lt, kt), ge = Math.imul(lt, Vt), ge = ge + Math.imul(pt, kt) | 0, Ae = Math.imul(pt, Vt), ke = ke + Math.imul(sX, Ci) | 0, ge = ge + Math.imul(sX, Qr) | 0, ge = ge + Math.imul(nX, Ci) | 0, Ae = Ae + Math.imul(nX, Qr) | 0, ke = ke + Math.imul(oX, lX) | 0, ge = ge + Math.imul(oX, rX) | 0, ge = ge + Math.imul(Nn, lX) | 0, Ae = Ae + Math.imul(Nn, rX) | 0, ke = ke + Math.imul(Ct, BX) | 0, ge = ge + Math.imul(Ct, cX) | 0, ge = ge + Math.imul(w_, BX) | 0, Ae = Ae + Math.imul(w_, cX) | 0, ke = ke + Math.imul(Fr, EX) | 0, ge = ge + Math.imul(Fr, yX) | 0, ge = ge + Math.imul(an, EX) | 0, Ae = Ae + Math.imul(an, yX) | 0, ke = ke + Math.imul(Ut, AX) | 0, ge = ge + Math.imul(Ut, vX) | 0, ge = ge + Math.imul(It, AX) | 0, Ae = Ae + Math.imul(It, vX) | 0, ke = ke + Math.imul(Tt, kX) | 0, ge = ge + Math.imul(Tt, qe) | 0, ge = ge + Math.imul(dt, kX) | 0, Ae = Ae + Math.imul(dt, qe) | 0, ke = ke + Math.imul(ot, Ve) | 0, ge = ge + Math.imul(ot, Ie) | 0, ge = ge + Math.imul(ct, Ve) | 0, Ae = Ae + Math.imul(ct, Ie) | 0, ke = ke + Math.imul(Xe, Et) | 0, ge = ge + Math.imul(Xe, xt) | 0, ge = ge + Math.imul($e, Et) | 0, Ae = Ae + Math.imul($e, xt) | 0;
      var mX = (Se + ke | 0) + ((ge & 8191) << 13) | 0;
      Se = (Ae + (ge >>> 13) | 0) + (mX >>> 26) | 0, mX &= 67108863, ke = Math.imul(Je, kt), ge = Math.imul(Je, Vt), ge = ge + Math.imul(st, kt) | 0, Ae = Math.imul(st, Vt), ke = ke + Math.imul(lt, Ci) | 0, ge = ge + Math.imul(lt, Qr) | 0, ge = ge + Math.imul(pt, Ci) | 0, Ae = Ae + Math.imul(pt, Qr) | 0, ke = ke + Math.imul(sX, lX) | 0, ge = ge + Math.imul(sX, rX) | 0, ge = ge + Math.imul(nX, lX) | 0, Ae = Ae + Math.imul(nX, rX) | 0, ke = ke + Math.imul(oX, BX) | 0, ge = ge + Math.imul(oX, cX) | 0, ge = ge + Math.imul(Nn, BX) | 0, Ae = Ae + Math.imul(Nn, cX) | 0, ke = ke + Math.imul(Ct, EX) | 0, ge = ge + Math.imul(Ct, yX) | 0, ge = ge + Math.imul(w_, EX) | 0, Ae = Ae + Math.imul(w_, yX) | 0, ke = ke + Math.imul(Fr, AX) | 0, ge = ge + Math.imul(Fr, vX) | 0, ge = ge + Math.imul(an, AX) | 0, Ae = Ae + Math.imul(an, vX) | 0, ke = ke + Math.imul(Ut, kX) | 0, ge = ge + Math.imul(Ut, qe) | 0, ge = ge + Math.imul(It, kX) | 0, Ae = Ae + Math.imul(It, qe) | 0, ke = ke + Math.imul(Tt, Ve) | 0, ge = ge + Math.imul(Tt, Ie) | 0, ge = ge + Math.imul(dt, Ve) | 0, Ae = Ae + Math.imul(dt, Ie) | 0, ke = ke + Math.imul(ot, Et) | 0, ge = ge + Math.imul(ot, xt) | 0, ge = ge + Math.imul(ct, Et) | 0, Ae = Ae + Math.imul(ct, xt) | 0, ke = ke + Math.imul(Xe, Yt) | 0, ge = ge + Math.imul(Xe, _r) | 0, ge = ge + Math.imul($e, Yt) | 0, Ae = Ae + Math.imul($e, _r) | 0;
      var pX = (Se + ke | 0) + ((ge & 8191) << 13) | 0;
      Se = (Ae + (ge >>> 13) | 0) + (pX >>> 26) | 0, pX &= 67108863, ke = Math.imul(Je, Ci), ge = Math.imul(Je, Qr), ge = ge + Math.imul(st, Ci) | 0, Ae = Math.imul(st, Qr), ke = ke + Math.imul(lt, lX) | 0, ge = ge + Math.imul(lt, rX) | 0, ge = ge + Math.imul(pt, lX) | 0, Ae = Ae + Math.imul(pt, rX) | 0, ke = ke + Math.imul(sX, BX) | 0, ge = ge + Math.imul(sX, cX) | 0, ge = ge + Math.imul(nX, BX) | 0, Ae = Ae + Math.imul(nX, cX) | 0, ke = ke + Math.imul(oX, EX) | 0, ge = ge + Math.imul(oX, yX) | 0, ge = ge + Math.imul(Nn, EX) | 0, Ae = Ae + Math.imul(Nn, yX) | 0, ke = ke + Math.imul(Ct, AX) | 0, ge = ge + Math.imul(Ct, vX) | 0, ge = ge + Math.imul(w_, AX) | 0, Ae = Ae + Math.imul(w_, vX) | 0, ke = ke + Math.imul(Fr, kX) | 0, ge = ge + Math.imul(Fr, qe) | 0, ge = ge + Math.imul(an, kX) | 0, Ae = Ae + Math.imul(an, qe) | 0, ke = ke + Math.imul(Ut, Ve) | 0, ge = ge + Math.imul(Ut, Ie) | 0, ge = ge + Math.imul(It, Ve) | 0, Ae = Ae + Math.imul(It, Ie) | 0, ke = ke + Math.imul(Tt, Et) | 0, ge = ge + Math.imul(Tt, xt) | 0, ge = ge + Math.imul(dt, Et) | 0, Ae = Ae + Math.imul(dt, xt) | 0, ke = ke + Math.imul(ot, Yt) | 0, ge = ge + Math.imul(ot, _r) | 0, ge = ge + Math.imul(ct, Yt) | 0, Ae = Ae + Math.imul(ct, _r) | 0;
      var G_ = (Se + ke | 0) + ((ge & 8191) << 13) | 0;
      Se = (Ae + (ge >>> 13) | 0) + (G_ >>> 26) | 0, G_ &= 67108863, ke = Math.imul(Je, lX), ge = Math.imul(Je, rX), ge = ge + Math.imul(st, lX) | 0, Ae = Math.imul(st, rX), ke = ke + Math.imul(lt, BX) | 0, ge = ge + Math.imul(lt, cX) | 0, ge = ge + Math.imul(pt, BX) | 0, Ae = Ae + Math.imul(pt, cX) | 0, ke = ke + Math.imul(sX, EX) | 0, ge = ge + Math.imul(sX, yX) | 0, ge = ge + Math.imul(nX, EX) | 0, Ae = Ae + Math.imul(nX, yX) | 0, ke = ke + Math.imul(oX, AX) | 0, ge = ge + Math.imul(oX, vX) | 0, ge = ge + Math.imul(Nn, AX) | 0, Ae = Ae + Math.imul(Nn, vX) | 0, ke = ke + Math.imul(Ct, kX) | 0, ge = ge + Math.imul(Ct, qe) | 0, ge = ge + Math.imul(w_, kX) | 0, Ae = Ae + Math.imul(w_, qe) | 0, ke = ke + Math.imul(Fr, Ve) | 0, ge = ge + Math.imul(Fr, Ie) | 0, ge = ge + Math.imul(an, Ve) | 0, Ae = Ae + Math.imul(an, Ie) | 0, ke = ke + Math.imul(Ut, Et) | 0, ge = ge + Math.imul(Ut, xt) | 0, ge = ge + Math.imul(It, Et) | 0, Ae = Ae + Math.imul(It, xt) | 0, ke = ke + Math.imul(Tt, Yt) | 0, ge = ge + Math.imul(Tt, _r) | 0, ge = ge + Math.imul(dt, Yt) | 0, Ae = Ae + Math.imul(dt, _r) | 0;
      var iX = (Se + ke | 0) + ((ge & 8191) << 13) | 0;
      Se = (Ae + (ge >>> 13) | 0) + (iX >>> 26) | 0, iX &= 67108863, ke = Math.imul(Je, BX), ge = Math.imul(Je, cX), ge = ge + Math.imul(st, BX) | 0, Ae = Math.imul(st, cX), ke = ke + Math.imul(lt, EX) | 0, ge = ge + Math.imul(lt, yX) | 0, ge = ge + Math.imul(pt, EX) | 0, Ae = Ae + Math.imul(pt, yX) | 0, ke = ke + Math.imul(sX, AX) | 0, ge = ge + Math.imul(sX, vX) | 0, ge = ge + Math.imul(nX, AX) | 0, Ae = Ae + Math.imul(nX, vX) | 0, ke = ke + Math.imul(oX, kX) | 0, ge = ge + Math.imul(oX, qe) | 0, ge = ge + Math.imul(Nn, kX) | 0, Ae = Ae + Math.imul(Nn, qe) | 0, ke = ke + Math.imul(Ct, Ve) | 0, ge = ge + Math.imul(Ct, Ie) | 0, ge = ge + Math.imul(w_, Ve) | 0, Ae = Ae + Math.imul(w_, Ie) | 0, ke = ke + Math.imul(Fr, Et) | 0, ge = ge + Math.imul(Fr, xt) | 0, ge = ge + Math.imul(an, Et) | 0, Ae = Ae + Math.imul(an, xt) | 0, ke = ke + Math.imul(Ut, Yt) | 0, ge = ge + Math.imul(Ut, _r) | 0, ge = ge + Math.imul(It, Yt) | 0, Ae = Ae + Math.imul(It, _r) | 0;
      var og = (Se + ke | 0) + ((ge & 8191) << 13) | 0;
      Se = (Ae + (ge >>> 13) | 0) + (og >>> 26) | 0, og &= 67108863, ke = Math.imul(Je, EX), ge = Math.imul(Je, yX), ge = ge + Math.imul(st, EX) | 0, Ae = Math.imul(st, yX), ke = ke + Math.imul(lt, AX) | 0, ge = ge + Math.imul(lt, vX) | 0, ge = ge + Math.imul(pt, AX) | 0, Ae = Ae + Math.imul(pt, vX) | 0, ke = ke + Math.imul(sX, kX) | 0, ge = ge + Math.imul(sX, qe) | 0, ge = ge + Math.imul(nX, kX) | 0, Ae = Ae + Math.imul(nX, qe) | 0, ke = ke + Math.imul(oX, Ve) | 0, ge = ge + Math.imul(oX, Ie) | 0, ge = ge + Math.imul(Nn, Ve) | 0, Ae = Ae + Math.imul(Nn, Ie) | 0, ke = ke + Math.imul(Ct, Et) | 0, ge = ge + Math.imul(Ct, xt) | 0, ge = ge + Math.imul(w_, Et) | 0, Ae = Ae + Math.imul(w_, xt) | 0, ke = ke + Math.imul(Fr, Yt) | 0, ge = ge + Math.imul(Fr, _r) | 0, ge = ge + Math.imul(an, Yt) | 0, Ae = Ae + Math.imul(an, _r) | 0;
      var eX = (Se + ke | 0) + ((ge & 8191) << 13) | 0;
      Se = (Ae + (ge >>> 13) | 0) + (eX >>> 26) | 0, eX &= 67108863, ke = Math.imul(Je, AX), ge = Math.imul(Je, vX), ge = ge + Math.imul(st, AX) | 0, Ae = Math.imul(st, vX), ke = ke + Math.imul(lt, kX) | 0, ge = ge + Math.imul(lt, qe) | 0, ge = ge + Math.imul(pt, kX) | 0, Ae = Ae + Math.imul(pt, qe) | 0, ke = ke + Math.imul(sX, Ve) | 0, ge = ge + Math.imul(sX, Ie) | 0, ge = ge + Math.imul(nX, Ve) | 0, Ae = Ae + Math.imul(nX, Ie) | 0, ke = ke + Math.imul(oX, Et) | 0, ge = ge + Math.imul(oX, xt) | 0, ge = ge + Math.imul(Nn, Et) | 0, Ae = Ae + Math.imul(Nn, xt) | 0, ke = ke + Math.imul(Ct, Yt) | 0, ge = ge + Math.imul(Ct, _r) | 0, ge = ge + Math.imul(w_, Yt) | 0, Ae = Ae + Math.imul(w_, _r) | 0;
      var tX = (Se + ke | 0) + ((ge & 8191) << 13) | 0;
      Se = (Ae + (ge >>> 13) | 0) + (tX >>> 26) | 0, tX &= 67108863, ke = Math.imul(Je, kX), ge = Math.imul(Je, qe), ge = ge + Math.imul(st, kX) | 0, Ae = Math.imul(st, qe), ke = ke + Math.imul(lt, Ve) | 0, ge = ge + Math.imul(lt, Ie) | 0, ge = ge + Math.imul(pt, Ve) | 0, Ae = Ae + Math.imul(pt, Ie) | 0, ke = ke + Math.imul(sX, Et) | 0, ge = ge + Math.imul(sX, xt) | 0, ge = ge + Math.imul(nX, Et) | 0, Ae = Ae + Math.imul(nX, xt) | 0, ke = ke + Math.imul(oX, Yt) | 0, ge = ge + Math.imul(oX, _r) | 0, ge = ge + Math.imul(Nn, Yt) | 0, Ae = Ae + Math.imul(Nn, _r) | 0;
      var An = (Se + ke | 0) + ((ge & 8191) << 13) | 0;
      Se = (Ae + (ge >>> 13) | 0) + (An >>> 26) | 0, An &= 67108863, ke = Math.imul(Je, Ve), ge = Math.imul(Je, Ie), ge = ge + Math.imul(st, Ve) | 0, Ae = Math.imul(st, Ie), ke = ke + Math.imul(lt, Et) | 0, ge = ge + Math.imul(lt, xt) | 0, ge = ge + Math.imul(pt, Et) | 0, Ae = Ae + Math.imul(pt, xt) | 0, ke = ke + Math.imul(sX, Yt) | 0, ge = ge + Math.imul(sX, _r) | 0, ge = ge + Math.imul(nX, Yt) | 0, Ae = Ae + Math.imul(nX, _r) | 0;
      var Gt = (Se + ke | 0) + ((ge & 8191) << 13) | 0;
      Se = (Ae + (ge >>> 13) | 0) + (Gt >>> 26) | 0, Gt &= 67108863, ke = Math.imul(Je, Et), ge = Math.imul(Je, xt), ge = ge + Math.imul(st, Et) | 0, Ae = Math.imul(st, xt), ke = ke + Math.imul(lt, Yt) | 0, ge = ge + Math.imul(lt, _r) | 0, ge = ge + Math.imul(pt, Yt) | 0, Ae = Ae + Math.imul(pt, _r) | 0;
      var Wt = (Se + ke | 0) + ((ge & 8191) << 13) | 0;
      Se = (Ae + (ge >>> 13) | 0) + (Wt >>> 26) | 0, Wt &= 67108863, ke = Math.imul(Je, Yt), ge = Math.imul(Je, _r), ge = ge + Math.imul(st, Yt) | 0, Ae = Math.imul(st, _r);
      var vr = (Se + ke | 0) + ((ge & 8191) << 13) | 0;
      return Se = (Ae + (ge >>> 13) | 0) + (vr >>> 26) | 0, vr &= 67108863, Pe[0] = cn, Pe[1] = _X, Pe[2] = un, Pe[3] = aX, Pe[4] = uX, Pe[5] = fX, Pe[6] = bX, Pe[7] = dX, Pe[8] = mX, Pe[9] = pX, Pe[10] = G_, Pe[11] = iX, Pe[12] = og, Pe[13] = eX, Pe[14] = tX, Pe[15] = An, Pe[16] = Gt, Pe[17] = Wt, Pe[18] = vr, Se !== 0 && (Pe[19] = Se, be.length++), be;
    };
    Math.imul || (Me = Ue);
    function De(fe, de, be) {
      be.negative = de.negative ^ fe.negative, be.length = fe.length + de.length;
      for (var Te = 0, Ce = 0, Pe = 0; Pe < be.length - 1; Pe++) {
        var Se = Ce;
        Ce = 0;
        for (var ke = Te & 67108863, ge = Math.min(Pe, de.length - 1), Ae = Math.max(0, Pe - fe.length + 1); Ae <= ge; Ae++) {
          var Ge = Pe - Ae, Xe = fe.words[Ge] | 0, $e = de.words[Ae] | 0, Ze = Xe * $e, ot = Ze & 67108863;
          Se = Se + (Ze / 67108864 | 0) | 0, ot = ot + ke | 0, ke = ot & 67108863, Se = Se + (ot >>> 26) | 0, Ce += Se >>> 26, Se &= 67108863;
        }
        be.words[Pe] = ke, Te = Se, Se = Ce;
      }
      return Te !== 0 ? be.words[Pe] = Te : be.length--, be._strip();
    }
    function Fe(fe, de, be) {
      return De(fe, de, be);
    }
    ie.prototype.mulTo = function(fe, de) {
      var be, Te = this.length + fe.length;
      return this.length === 10 && fe.length === 10 ? be = Me(this, fe, de) : Te < 63 ? be = Ue(this, fe, de) : Te < 1024 ? be = De(this, fe, de) : be = Fe(this, fe, de), be;
    }, ie.prototype.mul = function(fe) {
      var de = new ie(null);
      return de.words = new Array(this.length + fe.length), this.mulTo(fe, de);
    }, ie.prototype.mulf = function(fe) {
      var de = new ie(null);
      return de.words = new Array(this.length + fe.length), Fe(this, fe, de);
    }, ie.prototype.imul = function(fe) {
      return this.clone().mulTo(fe, this);
    }, ie.prototype.imuln = function(fe) {
      var de = fe < 0;
      de && (fe = -fe), te(typeof fe == "number"), te(fe < 67108864);
      for (var be = 0, Te = 0; Te < this.length; Te++) {
        var Ce = (this.words[Te] | 0) * fe, Pe = (Ce & 67108863) + (be & 67108863);
        be >>= 26, be += Ce / 67108864 | 0, be += Pe >>> 26, this.words[Te] = Pe & 67108863;
      }
      return be !== 0 && (this.words[Te] = be, this.length++), de ? this.ineg() : this;
    }, ie.prototype.muln = function(fe) {
      return this.clone().imuln(fe);
    }, ie.prototype.sqr = function() {
      return this.mul(this);
    }, ie.prototype.isqr = function() {
      return this.imul(this.clone());
    }, ie.prototype.pow = function(fe) {
      var de = Re(fe);
      if (de.length === 0)
        return new ie(1);
      for (var be = this, Te = 0; Te < de.length && de[Te] === 0; Te++, be = be.sqr())
        ;
      if (++Te < de.length)
        for (var Ce = be.sqr(); Te < de.length; Te++, Ce = Ce.sqr())
          de[Te] !== 0 && (be = be.mul(Ce));
      return be;
    }, ie.prototype.iushln = function(fe) {
      te(typeof fe == "number" && fe >= 0);
      var de = fe % 26, be = (fe - de) / 26, Te = 67108863 >>> 26 - de << 26 - de, Ce;
      if (de !== 0) {
        var Pe = 0;
        for (Ce = 0; Ce < this.length; Ce++) {
          var Se = this.words[Ce] & Te, ke = (this.words[Ce] | 0) - Se << de;
          this.words[Ce] = ke | Pe, Pe = Se >>> 26 - de;
        }
        Pe && (this.words[Ce] = Pe, this.length++);
      }
      if (be !== 0) {
        for (Ce = this.length - 1; Ce >= 0; Ce--)
          this.words[Ce + be] = this.words[Ce];
        for (Ce = 0; Ce < be; Ce++)
          this.words[Ce] = 0;
        this.length += be;
      }
      return this._strip();
    }, ie.prototype.ishln = function(fe) {
      return te(this.negative === 0), this.iushln(fe);
    }, ie.prototype.iushrn = function(fe, de, be) {
      te(typeof fe == "number" && fe >= 0);
      var Te;
      de ? Te = (de - de % 26) / 26 : Te = 0;
      var Ce = fe % 26, Pe = Math.min((fe - Ce) / 26, this.length), Se = 67108863 ^ 67108863 >>> Ce << Ce, ke = be;
      if (Te -= Pe, Te = Math.max(0, Te), ke) {
        for (var ge = 0; ge < Pe; ge++)
          ke.words[ge] = this.words[ge];
        ke.length = Pe;
      }
      if (Pe !== 0)
        if (this.length > Pe)
          for (this.length -= Pe, ge = 0; ge < this.length; ge++)
            this.words[ge] = this.words[ge + Pe];
        else
          this.words[0] = 0, this.length = 1;
      var Ae = 0;
      for (ge = this.length - 1; ge >= 0 && (Ae !== 0 || ge >= Te); ge--) {
        var Ge = this.words[ge] | 0;
        this.words[ge] = Ae << 26 - Ce | Ge >>> Ce, Ae = Ge & Se;
      }
      return ke && Ae !== 0 && (ke.words[ke.length++] = Ae), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
    }, ie.prototype.ishrn = function(fe, de, be) {
      return te(this.negative === 0), this.iushrn(fe, de, be);
    }, ie.prototype.shln = function(fe) {
      return this.clone().ishln(fe);
    }, ie.prototype.ushln = function(fe) {
      return this.clone().iushln(fe);
    }, ie.prototype.shrn = function(fe) {
      return this.clone().ishrn(fe);
    }, ie.prototype.ushrn = function(fe) {
      return this.clone().iushrn(fe);
    }, ie.prototype.testn = function(fe) {
      te(typeof fe == "number" && fe >= 0);
      var de = fe % 26, be = (fe - de) / 26, Te = 1 << de;
      if (this.length <= be)
        return !1;
      var Ce = this.words[be];
      return !!(Ce & Te);
    }, ie.prototype.imaskn = function(fe) {
      te(typeof fe == "number" && fe >= 0);
      var de = fe % 26, be = (fe - de) / 26;
      if (te(this.negative === 0, "imaskn works only with positive numbers"), this.length <= be)
        return this;
      if (de !== 0 && be++, this.length = Math.min(be, this.length), de !== 0) {
        var Te = 67108863 ^ 67108863 >>> de << de;
        this.words[this.length - 1] &= Te;
      }
      return this._strip();
    }, ie.prototype.maskn = function(fe) {
      return this.clone().imaskn(fe);
    }, ie.prototype.iaddn = function(fe) {
      return te(typeof fe == "number"), te(fe < 67108864), fe < 0 ? this.isubn(-fe) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= fe ? (this.words[0] = fe - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(fe), this.negative = 1, this) : this._iaddn(fe);
    }, ie.prototype._iaddn = function(fe) {
      this.words[0] += fe;
      for (var de = 0; de < this.length && this.words[de] >= 67108864; de++)
        this.words[de] -= 67108864, de === this.length - 1 ? this.words[de + 1] = 1 : this.words[de + 1]++;
      return this.length = Math.max(this.length, de + 1), this;
    }, ie.prototype.isubn = function(fe) {
      if (te(typeof fe == "number"), te(fe < 67108864), fe < 0)
        return this.iaddn(-fe);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(fe), this.negative = 1, this;
      if (this.words[0] -= fe, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var de = 0; de < this.length && this.words[de] < 0; de++)
          this.words[de] += 67108864, this.words[de + 1] -= 1;
      return this._strip();
    }, ie.prototype.addn = function(fe) {
      return this.clone().iaddn(fe);
    }, ie.prototype.subn = function(fe) {
      return this.clone().isubn(fe);
    }, ie.prototype.iabs = function() {
      return this.negative = 0, this;
    }, ie.prototype.abs = function() {
      return this.clone().iabs();
    }, ie.prototype._ishlnsubmul = function(fe, de, be) {
      var Te = fe.length + be, Ce;
      this._expand(Te);
      var Pe, Se = 0;
      for (Ce = 0; Ce < fe.length; Ce++) {
        Pe = (this.words[Ce + be] | 0) + Se;
        var ke = (fe.words[Ce] | 0) * de;
        Pe -= ke & 67108863, Se = (Pe >> 26) - (ke / 67108864 | 0), this.words[Ce + be] = Pe & 67108863;
      }
      for (; Ce < this.length - be; Ce++)
        Pe = (this.words[Ce + be] | 0) + Se, Se = Pe >> 26, this.words[Ce + be] = Pe & 67108863;
      if (Se === 0)
        return this._strip();
      for (te(Se === -1), Se = 0, Ce = 0; Ce < this.length; Ce++)
        Pe = -(this.words[Ce] | 0) + Se, Se = Pe >> 26, this.words[Ce] = Pe & 67108863;
      return this.negative = 1, this._strip();
    }, ie.prototype._wordDiv = function(fe, de) {
      var be = this.length - fe.length, Te = this.clone(), Ce = fe, Pe = Ce.words[Ce.length - 1] | 0, Se = this._countBits(Pe);
      be = 26 - Se, be !== 0 && (Ce = Ce.ushln(be), Te.iushln(be), Pe = Ce.words[Ce.length - 1] | 0);
      var ke = Te.length - Ce.length, ge;
      if (de !== "mod") {
        ge = new ie(null), ge.length = ke + 1, ge.words = new Array(ge.length);
        for (var Ae = 0; Ae < ge.length; Ae++)
          ge.words[Ae] = 0;
      }
      var Ge = Te.clone()._ishlnsubmul(Ce, 1, ke);
      Ge.negative === 0 && (Te = Ge, ge && (ge.words[ke] = 1));
      for (var Xe = ke - 1; Xe >= 0; Xe--) {
        var $e = (Te.words[Ce.length + Xe] | 0) * 67108864 + (Te.words[Ce.length + Xe - 1] | 0);
        for ($e = Math.min($e / Pe | 0, 67108863), Te._ishlnsubmul(Ce, $e, Xe); Te.negative !== 0; )
          $e--, Te.negative = 0, Te._ishlnsubmul(Ce, 1, Xe), Te.isZero() || (Te.negative ^= 1);
        ge && (ge.words[Xe] = $e);
      }
      return ge && ge._strip(), Te._strip(), de !== "div" && be !== 0 && Te.iushrn(be), {
        div: ge || null,
        mod: Te
      };
    }, ie.prototype.divmod = function(fe, de, be) {
      if (te(!fe.isZero()), this.isZero())
        return {
          div: new ie(0),
          mod: new ie(0)
        };
      var Te, Ce, Pe;
      return this.negative !== 0 && fe.negative === 0 ? (Pe = this.neg().divmod(fe, de), de !== "mod" && (Te = Pe.div.neg()), de !== "div" && (Ce = Pe.mod.neg(), be && Ce.negative !== 0 && Ce.iadd(fe)), {
        div: Te,
        mod: Ce
      }) : this.negative === 0 && fe.negative !== 0 ? (Pe = this.divmod(fe.neg(), de), de !== "mod" && (Te = Pe.div.neg()), {
        div: Te,
        mod: Pe.mod
      }) : this.negative & fe.negative ? (Pe = this.neg().divmod(fe.neg(), de), de !== "div" && (Ce = Pe.mod.neg(), be && Ce.negative !== 0 && Ce.isub(fe)), {
        div: Pe.div,
        mod: Ce
      }) : fe.length > this.length || this.cmp(fe) < 0 ? {
        div: new ie(0),
        mod: this
      } : fe.length === 1 ? de === "div" ? {
        div: this.divn(fe.words[0]),
        mod: null
      } : de === "mod" ? {
        div: null,
        mod: new ie(this.modrn(fe.words[0]))
      } : {
        div: this.divn(fe.words[0]),
        mod: new ie(this.modrn(fe.words[0]))
      } : this._wordDiv(fe, de);
    }, ie.prototype.div = function(fe) {
      return this.divmod(fe, "div", !1).div;
    }, ie.prototype.mod = function(fe) {
      return this.divmod(fe, "mod", !1).mod;
    }, ie.prototype.umod = function(fe) {
      return this.divmod(fe, "mod", !0).mod;
    }, ie.prototype.divRound = function(fe) {
      var de = this.divmod(fe);
      if (de.mod.isZero())
        return de.div;
      var be = de.div.negative !== 0 ? de.mod.isub(fe) : de.mod, Te = fe.ushrn(1), Ce = fe.andln(1), Pe = be.cmp(Te);
      return Pe < 0 || Ce === 1 && Pe === 0 ? de.div : de.div.negative !== 0 ? de.div.isubn(1) : de.div.iaddn(1);
    }, ie.prototype.modrn = function(fe) {
      var de = fe < 0;
      de && (fe = -fe), te(fe <= 67108863);
      for (var be = (1 << 26) % fe, Te = 0, Ce = this.length - 1; Ce >= 0; Ce--)
        Te = (be * Te + (this.words[Ce] | 0)) % fe;
      return de ? -Te : Te;
    }, ie.prototype.modn = function(fe) {
      return this.modrn(fe);
    }, ie.prototype.idivn = function(fe) {
      var de = fe < 0;
      de && (fe = -fe), te(fe <= 67108863);
      for (var be = 0, Te = this.length - 1; Te >= 0; Te--) {
        var Ce = (this.words[Te] | 0) + be * 67108864;
        this.words[Te] = Ce / fe | 0, be = Ce % fe;
      }
      return this._strip(), de ? this.ineg() : this;
    }, ie.prototype.divn = function(fe) {
      return this.clone().idivn(fe);
    }, ie.prototype.egcd = function(fe) {
      te(fe.negative === 0), te(!fe.isZero());
      var de = this, be = fe.clone();
      de.negative !== 0 ? de = de.umod(fe) : de = de.clone();
      for (var Te = new ie(1), Ce = new ie(0), Pe = new ie(0), Se = new ie(1), ke = 0; de.isEven() && be.isEven(); )
        de.iushrn(1), be.iushrn(1), ++ke;
      for (var ge = be.clone(), Ae = de.clone(); !de.isZero(); ) {
        for (var Ge = 0, Xe = 1; !(de.words[0] & Xe) && Ge < 26; ++Ge, Xe <<= 1)
          ;
        if (Ge > 0)
          for (de.iushrn(Ge); Ge-- > 0; )
            (Te.isOdd() || Ce.isOdd()) && (Te.iadd(ge), Ce.isub(Ae)), Te.iushrn(1), Ce.iushrn(1);
        for (var $e = 0, Ze = 1; !(be.words[0] & Ze) && $e < 26; ++$e, Ze <<= 1)
          ;
        if ($e > 0)
          for (be.iushrn($e); $e-- > 0; )
            (Pe.isOdd() || Se.isOdd()) && (Pe.iadd(ge), Se.isub(Ae)), Pe.iushrn(1), Se.iushrn(1);
        de.cmp(be) >= 0 ? (de.isub(be), Te.isub(Pe), Ce.isub(Se)) : (be.isub(de), Pe.isub(Te), Se.isub(Ce));
      }
      return {
        a: Pe,
        b: Se,
        gcd: be.iushln(ke)
      };
    }, ie.prototype._invmp = function(fe) {
      te(fe.negative === 0), te(!fe.isZero());
      var de = this, be = fe.clone();
      de.negative !== 0 ? de = de.umod(fe) : de = de.clone();
      for (var Te = new ie(1), Ce = new ie(0), Pe = be.clone(); de.cmpn(1) > 0 && be.cmpn(1) > 0; ) {
        for (var Se = 0, ke = 1; !(de.words[0] & ke) && Se < 26; ++Se, ke <<= 1)
          ;
        if (Se > 0)
          for (de.iushrn(Se); Se-- > 0; )
            Te.isOdd() && Te.iadd(Pe), Te.iushrn(1);
        for (var ge = 0, Ae = 1; !(be.words[0] & Ae) && ge < 26; ++ge, Ae <<= 1)
          ;
        if (ge > 0)
          for (be.iushrn(ge); ge-- > 0; )
            Ce.isOdd() && Ce.iadd(Pe), Ce.iushrn(1);
        de.cmp(be) >= 0 ? (de.isub(be), Te.isub(Ce)) : (be.isub(de), Ce.isub(Te));
      }
      var Ge;
      return de.cmpn(1) === 0 ? Ge = Te : Ge = Ce, Ge.cmpn(0) < 0 && Ge.iadd(fe), Ge;
    }, ie.prototype.gcd = function(fe) {
      if (this.isZero())
        return fe.abs();
      if (fe.isZero())
        return this.abs();
      var de = this.clone(), be = fe.clone();
      de.negative = 0, be.negative = 0;
      for (var Te = 0; de.isEven() && be.isEven(); Te++)
        de.iushrn(1), be.iushrn(1);
      do {
        for (; de.isEven(); )
          de.iushrn(1);
        for (; be.isEven(); )
          be.iushrn(1);
        var Ce = de.cmp(be);
        if (Ce < 0) {
          var Pe = de;
          de = be, be = Pe;
        } else if (Ce === 0 || be.cmpn(1) === 0)
          break;
        de.isub(be);
      } while (!0);
      return be.iushln(Te);
    }, ie.prototype.invm = function(fe) {
      return this.egcd(fe).a.umod(fe);
    }, ie.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, ie.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, ie.prototype.andln = function(fe) {
      return this.words[0] & fe;
    }, ie.prototype.bincn = function(fe) {
      te(typeof fe == "number");
      var de = fe % 26, be = (fe - de) / 26, Te = 1 << de;
      if (this.length <= be)
        return this._expand(be + 1), this.words[be] |= Te, this;
      for (var Ce = Te, Pe = be; Ce !== 0 && Pe < this.length; Pe++) {
        var Se = this.words[Pe] | 0;
        Se += Ce, Ce = Se >>> 26, Se &= 67108863, this.words[Pe] = Se;
      }
      return Ce !== 0 && (this.words[Pe] = Ce, this.length++), this;
    }, ie.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, ie.prototype.cmpn = function(fe) {
      var de = fe < 0;
      if (this.negative !== 0 && !de)
        return -1;
      if (this.negative === 0 && de)
        return 1;
      this._strip();
      var be;
      if (this.length > 1)
        be = 1;
      else {
        de && (fe = -fe), te(fe <= 67108863, "Number is too big");
        var Te = this.words[0] | 0;
        be = Te === fe ? 0 : Te < fe ? -1 : 1;
      }
      return this.negative !== 0 ? -be | 0 : be;
    }, ie.prototype.cmp = function(fe) {
      if (this.negative !== 0 && fe.negative === 0)
        return -1;
      if (this.negative === 0 && fe.negative !== 0)
        return 1;
      var de = this.ucmp(fe);
      return this.negative !== 0 ? -de | 0 : de;
    }, ie.prototype.ucmp = function(fe) {
      if (this.length > fe.length)
        return 1;
      if (this.length < fe.length)
        return -1;
      for (var de = 0, be = this.length - 1; be >= 0; be--) {
        var Te = this.words[be] | 0, Ce = fe.words[be] | 0;
        if (Te !== Ce) {
          Te < Ce ? de = -1 : Te > Ce && (de = 1);
          break;
        }
      }
      return de;
    }, ie.prototype.gtn = function(fe) {
      return this.cmpn(fe) === 1;
    }, ie.prototype.gt = function(fe) {
      return this.cmp(fe) === 1;
    }, ie.prototype.gten = function(fe) {
      return this.cmpn(fe) >= 0;
    }, ie.prototype.gte = function(fe) {
      return this.cmp(fe) >= 0;
    }, ie.prototype.ltn = function(fe) {
      return this.cmpn(fe) === -1;
    }, ie.prototype.lt = function(fe) {
      return this.cmp(fe) === -1;
    }, ie.prototype.lten = function(fe) {
      return this.cmpn(fe) <= 0;
    }, ie.prototype.lte = function(fe) {
      return this.cmp(fe) <= 0;
    }, ie.prototype.eqn = function(fe) {
      return this.cmpn(fe) === 0;
    }, ie.prototype.eq = function(fe) {
      return this.cmp(fe) === 0;
    }, ie.red = function(fe) {
      return new je(fe);
    }, ie.prototype.toRed = function(fe) {
      return te(!this.red, "Already a number in reduction context"), te(this.negative === 0, "red works only with positives"), fe.convertTo(this)._forceRed(fe);
    }, ie.prototype.fromRed = function() {
      return te(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, ie.prototype._forceRed = function(fe) {
      return this.red = fe, this;
    }, ie.prototype.forceRed = function(fe) {
      return te(!this.red, "Already a number in reduction context"), this._forceRed(fe);
    }, ie.prototype.redAdd = function(fe) {
      return te(this.red, "redAdd works only with red numbers"), this.red.add(this, fe);
    }, ie.prototype.redIAdd = function(fe) {
      return te(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, fe);
    }, ie.prototype.redSub = function(fe) {
      return te(this.red, "redSub works only with red numbers"), this.red.sub(this, fe);
    }, ie.prototype.redISub = function(fe) {
      return te(this.red, "redISub works only with red numbers"), this.red.isub(this, fe);
    }, ie.prototype.redShl = function(fe) {
      return te(this.red, "redShl works only with red numbers"), this.red.shl(this, fe);
    }, ie.prototype.redMul = function(fe) {
      return te(this.red, "redMul works only with red numbers"), this.red._verify2(this, fe), this.red.mul(this, fe);
    }, ie.prototype.redIMul = function(fe) {
      return te(this.red, "redMul works only with red numbers"), this.red._verify2(this, fe), this.red.imul(this, fe);
    }, ie.prototype.redSqr = function() {
      return te(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, ie.prototype.redISqr = function() {
      return te(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, ie.prototype.redSqrt = function() {
      return te(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, ie.prototype.redInvm = function() {
      return te(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, ie.prototype.redNeg = function() {
      return te(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, ie.prototype.redPow = function(fe) {
      return te(this.red && !fe.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, fe);
    };
    var Ke = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function tt(fe, de) {
      this.name = fe, this.p = new ie(de, 16), this.n = this.p.bitLength(), this.k = new ie(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    tt.prototype._tmp = function() {
      var fe = new ie(null);
      return fe.words = new Array(Math.ceil(this.n / 13)), fe;
    }, tt.prototype.ireduce = function(fe) {
      var de = fe, be;
      do
        this.split(de, this.tmp), de = this.imulK(de), de = de.iadd(this.tmp), be = de.bitLength();
      while (be > this.n);
      var Te = be < this.n ? -1 : de.ucmp(this.p);
      return Te === 0 ? (de.words[0] = 0, de.length = 1) : Te > 0 ? de.isub(this.p) : de.strip !== void 0 ? de.strip() : de._strip(), de;
    }, tt.prototype.split = function(fe, de) {
      fe.iushrn(this.n, 0, de);
    }, tt.prototype.imulK = function(fe) {
      return fe.imul(this.k);
    };
    function rt() {
      tt.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    ne(rt, tt), rt.prototype.split = function(fe, de) {
      for (var be = 4194303, Te = Math.min(fe.length, 9), Ce = 0; Ce < Te; Ce++)
        de.words[Ce] = fe.words[Ce];
      if (de.length = Te, fe.length <= 9) {
        fe.words[0] = 0, fe.length = 1;
        return;
      }
      var Pe = fe.words[9];
      for (de.words[de.length++] = Pe & be, Ce = 10; Ce < fe.length; Ce++) {
        var Se = fe.words[Ce] | 0;
        fe.words[Ce - 10] = (Se & be) << 4 | Pe >>> 22, Pe = Se;
      }
      Pe >>>= 22, fe.words[Ce - 10] = Pe, Pe === 0 && fe.length > 10 ? fe.length -= 10 : fe.length -= 9;
    }, rt.prototype.imulK = function(fe) {
      fe.words[fe.length] = 0, fe.words[fe.length + 1] = 0, fe.length += 2;
      for (var de = 0, be = 0; be < fe.length; be++) {
        var Te = fe.words[be] | 0;
        de += Te * 977, fe.words[be] = de & 67108863, de = Te * 64 + (de / 67108864 | 0);
      }
      return fe.words[fe.length - 1] === 0 && (fe.length--, fe.words[fe.length - 1] === 0 && fe.length--), fe;
    };
    function it() {
      tt.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    ne(it, tt);
    function _t() {
      tt.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    ne(_t, tt);
    function Dt() {
      tt.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    ne(Dt, tt), Dt.prototype.imulK = function(fe) {
      for (var de = 0, be = 0; be < fe.length; be++) {
        var Te = (fe.words[be] | 0) * 19 + de, Ce = Te & 67108863;
        Te >>>= 26, fe.words[be] = Ce, de = Te;
      }
      return de !== 0 && (fe.words[fe.length++] = de), fe;
    }, ie._prime = function(fe) {
      if (Ke[fe])
        return Ke[fe];
      var de;
      if (fe === "k256")
        de = new rt();
      else if (fe === "p224")
        de = new it();
      else if (fe === "p192")
        de = new _t();
      else if (fe === "p25519")
        de = new Dt();
      else
        throw new Error("Unknown prime " + fe);
      return Ke[fe] = de, de;
    };
    function je(fe) {
      if (typeof fe == "string") {
        var de = ie._prime(fe);
        this.m = de.p, this.prime = de;
      } else
        te(fe.gtn(1), "modulus must be greater than 1"), this.m = fe, this.prime = null;
    }
    je.prototype._verify1 = function(fe) {
      te(fe.negative === 0, "red works only with positives"), te(fe.red, "red works only with red numbers");
    }, je.prototype._verify2 = function(fe, de) {
      te((fe.negative | de.negative) === 0, "red works only with positives"), te(
        fe.red && fe.red === de.red,
        "red works only with red numbers"
      );
    }, je.prototype.imod = function(fe) {
      return this.prime ? this.prime.ireduce(fe)._forceRed(this) : (le(fe, fe.umod(this.m)._forceRed(this)), fe);
    }, je.prototype.neg = function(fe) {
      return fe.isZero() ? fe.clone() : this.m.sub(fe)._forceRed(this);
    }, je.prototype.add = function(fe, de) {
      this._verify2(fe, de);
      var be = fe.add(de);
      return be.cmp(this.m) >= 0 && be.isub(this.m), be._forceRed(this);
    }, je.prototype.iadd = function(fe, de) {
      this._verify2(fe, de);
      var be = fe.iadd(de);
      return be.cmp(this.m) >= 0 && be.isub(this.m), be;
    }, je.prototype.sub = function(fe, de) {
      this._verify2(fe, de);
      var be = fe.sub(de);
      return be.cmpn(0) < 0 && be.iadd(this.m), be._forceRed(this);
    }, je.prototype.isub = function(fe, de) {
      this._verify2(fe, de);
      var be = fe.isub(de);
      return be.cmpn(0) < 0 && be.iadd(this.m), be;
    }, je.prototype.shl = function(fe, de) {
      return this._verify1(fe), this.imod(fe.ushln(de));
    }, je.prototype.imul = function(fe, de) {
      return this._verify2(fe, de), this.imod(fe.imul(de));
    }, je.prototype.mul = function(fe, de) {
      return this._verify2(fe, de), this.imod(fe.mul(de));
    }, je.prototype.isqr = function(fe) {
      return this.imul(fe, fe.clone());
    }, je.prototype.sqr = function(fe) {
      return this.mul(fe, fe);
    }, je.prototype.sqrt = function(fe) {
      if (fe.isZero())
        return fe.clone();
      var de = this.m.andln(3);
      if (te(de % 2 === 1), de === 3) {
        var be = this.m.add(new ie(1)).iushrn(2);
        return this.pow(fe, be);
      }
      for (var Te = this.m.subn(1), Ce = 0; !Te.isZero() && Te.andln(1) === 0; )
        Ce++, Te.iushrn(1);
      te(!Te.isZero());
      var Pe = new ie(1).toRed(this), Se = Pe.redNeg(), ke = this.m.subn(1).iushrn(1), ge = this.m.bitLength();
      for (ge = new ie(2 * ge * ge).toRed(this); this.pow(ge, ke).cmp(Se) !== 0; )
        ge.redIAdd(Se);
      for (var Ae = this.pow(ge, Te), Ge = this.pow(fe, Te.addn(1).iushrn(1)), Xe = this.pow(fe, Te), $e = Ce; Xe.cmp(Pe) !== 0; ) {
        for (var Ze = Xe, ot = 0; Ze.cmp(Pe) !== 0; ot++)
          Ze = Ze.redSqr();
        te(ot < $e);
        var ct = this.pow(Ae, new ie(1).iushln($e - ot - 1));
        Ge = Ge.redMul(ct), Ae = ct.redSqr(), Xe = Xe.redMul(Ae), $e = ot;
      }
      return Ge;
    }, je.prototype.invm = function(fe) {
      var de = fe._invmp(this.m);
      return de.negative !== 0 ? (de.negative = 0, this.imod(de).redNeg()) : this.imod(de);
    }, je.prototype.pow = function(fe, de) {
      if (de.isZero())
        return new ie(1).toRed(this);
      if (de.cmpn(1) === 0)
        return fe.clone();
      var be = 4, Te = new Array(1 << be);
      Te[0] = new ie(1).toRed(this), Te[1] = fe;
      for (var Ce = 2; Ce < Te.length; Ce++)
        Te[Ce] = this.mul(Te[Ce - 1], fe);
      var Pe = Te[0], Se = 0, ke = 0, ge = de.bitLength() % 26;
      for (ge === 0 && (ge = 26), Ce = de.length - 1; Ce >= 0; Ce--) {
        for (var Ae = de.words[Ce], Ge = ge - 1; Ge >= 0; Ge--) {
          var Xe = Ae >> Ge & 1;
          if (Pe !== Te[0] && (Pe = this.sqr(Pe)), Xe === 0 && Se === 0) {
            ke = 0;
            continue;
          }
          Se <<= 1, Se |= Xe, ke++, !(ke !== be && (Ce !== 0 || Ge !== 0)) && (Pe = this.mul(Pe, Te[Se]), ke = 0, Se = 0);
        }
        ge = 26;
      }
      return Pe;
    }, je.prototype.convertTo = function(fe) {
      var de = fe.umod(this.m);
      return de === fe ? de.clone() : de;
    }, je.prototype.convertFrom = function(fe) {
      var de = fe.clone();
      return de.red = null, de;
    }, ie.mont = function(fe) {
      return new ze(fe);
    };
    function ze(fe) {
      je.call(this, fe), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new ie(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    ne(ze, je), ze.prototype.convertTo = function(fe) {
      return this.imod(fe.ushln(this.shift));
    }, ze.prototype.convertFrom = function(fe) {
      var de = this.imod(fe.mul(this.rinv));
      return de.red = null, de;
    }, ze.prototype.imul = function(fe, de) {
      if (fe.isZero() || de.isZero())
        return fe.words[0] = 0, fe.length = 1, fe;
      var be = fe.imul(de), Te = be.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), Ce = be.isub(Te).iushrn(this.shift), Pe = Ce;
      return Ce.cmp(this.m) >= 0 ? Pe = Ce.isub(this.m) : Ce.cmpn(0) < 0 && (Pe = Ce.iadd(this.m)), Pe._forceRed(this);
    }, ze.prototype.mul = function(fe, de) {
      if (fe.isZero() || de.isZero())
        return new ie(0)._forceRed(this);
      var be = fe.mul(de), Te = be.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), Ce = be.isub(Te).iushrn(this.shift), Pe = Ce;
      return Ce.cmp(this.m) >= 0 ? Pe = Ce.isub(this.m) : Ce.cmpn(0) < 0 && (Pe = Ce.iadd(this.m)), Pe._forceRed(this);
    }, ze.prototype.invm = function(fe) {
      var de = this.imod(fe._invmp(this.m).mul(this.r2));
      return de._forceRed(this);
    };
  })(Y, St);
})(sm);
var V4 = sm.exports;
const bt = /* @__PURE__ */ uc(V4), W4 = "logger/5.7.0";
let jb = !1, Hb = !1;
const ml = { debug: 1, default: 2, info: 2, warning: 3, error: 4, off: 5 };
let zb = ml.default, K0 = null;
function K4() {
  try {
    const Y = [];
    if (["NFD", "NFC", "NFKD", "NFKC"].forEach((X) => {
      try {
        if ("test".normalize(X) !== "test")
          throw new Error("bad normalize");
      } catch {
        Y.push(X);
      }
    }), Y.length)
      throw new Error("missing " + Y.join(", "));
    if ("".normalize("NFD") !== "e")
      throw new Error("broken implementation");
  } catch (Y) {
    return Y.message;
  }
  return null;
}
const qb = K4();
var Mp;
(function(Y) {
  Y.DEBUG = "DEBUG", Y.INFO = "INFO", Y.WARNING = "WARNING", Y.ERROR = "ERROR", Y.OFF = "OFF";
})(Mp || (Mp = {}));
var pi;
(function(Y) {
  Y.UNKNOWN_ERROR = "UNKNOWN_ERROR", Y.NOT_IMPLEMENTED = "NOT_IMPLEMENTED", Y.UNSUPPORTED_OPERATION = "UNSUPPORTED_OPERATION", Y.NETWORK_ERROR = "NETWORK_ERROR", Y.SERVER_ERROR = "SERVER_ERROR", Y.TIMEOUT = "TIMEOUT", Y.BUFFER_OVERRUN = "BUFFER_OVERRUN", Y.NUMERIC_FAULT = "NUMERIC_FAULT", Y.MISSING_NEW = "MISSING_NEW", Y.INVALID_ARGUMENT = "INVALID_ARGUMENT", Y.MISSING_ARGUMENT = "MISSING_ARGUMENT", Y.UNEXPECTED_ARGUMENT = "UNEXPECTED_ARGUMENT", Y.CALL_EXCEPTION = "CALL_EXCEPTION", Y.INSUFFICIENT_FUNDS = "INSUFFICIENT_FUNDS", Y.NONCE_EXPIRED = "NONCE_EXPIRED", Y.REPLACEMENT_UNDERPRICED = "REPLACEMENT_UNDERPRICED", Y.UNPREDICTABLE_GAS_LIMIT = "UNPREDICTABLE_GAS_LIMIT", Y.TRANSACTION_REPLACED = "TRANSACTION_REPLACED", Y.ACTION_REJECTED = "ACTION_REJECTED";
})(pi || (pi = {}));
const Gb = "0123456789abcdef";
class ce {
  constructor(X) {
    Object.defineProperty(this, "version", {
      enumerable: !0,
      value: X,
      writable: !1
    });
  }
  _log(X, ee) {
    const te = X.toLowerCase();
    ml[te] == null && this.throwArgumentError("invalid log level name", "logLevel", X), !(zb > ml[te]) && console.log.apply(console, ee);
  }
  debug(...X) {
    this._log(ce.levels.DEBUG, X);
  }
  info(...X) {
    this._log(ce.levels.INFO, X);
  }
  warn(...X) {
    this._log(ce.levels.WARNING, X);
  }
  makeError(X, ee, te) {
    if (Hb)
      return this.makeError("censored error", ee, {});
    ee || (ee = ce.errors.UNKNOWN_ERROR), te || (te = {});
    const ne = [];
    Object.keys(te).forEach((ae) => {
      const ue = te[ae];
      try {
        if (ue instanceof Uint8Array) {
          let le = "";
          for (let he = 0; he < ue.length; he++)
            le += Gb[ue[he] >> 4], le += Gb[ue[he] & 15];
          ne.push(ae + "=Uint8Array(0x" + le + ")");
        } else
          ne.push(ae + "=" + JSON.stringify(ue));
      } catch {
        ne.push(ae + "=" + JSON.stringify(te[ae].toString()));
      }
    }), ne.push(`code=${ee}`), ne.push(`version=${this.version}`);
    const ie = X;
    let oe = "";
    switch (ee) {
      case pi.NUMERIC_FAULT: {
        oe = "NUMERIC_FAULT";
        const ae = X;
        switch (ae) {
          case "overflow":
          case "underflow":
          case "division-by-zero":
            oe += "-" + ae;
            break;
          case "negative-power":
          case "negative-width":
            oe += "-unsupported";
            break;
          case "unbound-bitwise-result":
            oe += "-unbound-result";
            break;
        }
        break;
      }
      case pi.CALL_EXCEPTION:
      case pi.INSUFFICIENT_FUNDS:
      case pi.MISSING_NEW:
      case pi.NONCE_EXPIRED:
      case pi.REPLACEMENT_UNDERPRICED:
      case pi.TRANSACTION_REPLACED:
      case pi.UNPREDICTABLE_GAS_LIMIT:
        oe = ee;
        break;
    }
    oe && (X += " [ See: https://links.ethers.org/v5-errors-" + oe + " ]"), ne.length && (X += " (" + ne.join(", ") + ")");
    const se = new Error(X);
    return se.reason = ie, se.code = ee, Object.keys(te).forEach(function(ae) {
      se[ae] = te[ae];
    }), se;
  }
  throwError(X, ee, te) {
    throw this.makeError(X, ee, te);
  }
  throwArgumentError(X, ee, te) {
    return this.throwError(X, ce.errors.INVALID_ARGUMENT, {
      argument: ee,
      value: te
    });
  }
  assert(X, ee, te, ne) {
    X || this.throwError(ee, te, ne);
  }
  assertArgument(X, ee, te, ne) {
    X || this.throwArgumentError(ee, te, ne);
  }
  checkNormalize(X) {
    qb && this.throwError("platform missing String.prototype.normalize", ce.errors.UNSUPPORTED_OPERATION, {
      operation: "String.prototype.normalize",
      form: qb
    });
  }
  checkSafeUint53(X, ee) {
    typeof X == "number" && (ee == null && (ee = "value not safe"), (X < 0 || X >= 9007199254740991) && this.throwError(ee, ce.errors.NUMERIC_FAULT, {
      operation: "checkSafeInteger",
      fault: "out-of-safe-range",
      value: X
    }), X % 1 && this.throwError(ee, ce.errors.NUMERIC_FAULT, {
      operation: "checkSafeInteger",
      fault: "non-integer",
      value: X
    }));
  }
  checkArgumentCount(X, ee, te) {
    te ? te = ": " + te : te = "", X < ee && this.throwError("missing argument" + te, ce.errors.MISSING_ARGUMENT, {
      count: X,
      expectedCount: ee
    }), X > ee && this.throwError("too many arguments" + te, ce.errors.UNEXPECTED_ARGUMENT, {
      count: X,
      expectedCount: ee
    });
  }
  checkNew(X, ee) {
    (X === Object || X == null) && this.throwError("missing new", ce.errors.MISSING_NEW, { name: ee.name });
  }
  checkAbstract(X, ee) {
    X === ee ? this.throwError("cannot instantiate abstract class " + JSON.stringify(ee.name) + " directly; use a sub-class", ce.errors.UNSUPPORTED_OPERATION, { name: X.name, operation: "new" }) : (X === Object || X == null) && this.throwError("missing new", ce.errors.MISSING_NEW, { name: ee.name });
  }
  static globalLogger() {
    return K0 || (K0 = new ce(W4)), K0;
  }
  static setCensorship(X, ee) {
    if (!X && ee && this.globalLogger().throwError("cannot permanently disable censorship", ce.errors.UNSUPPORTED_OPERATION, {
      operation: "setCensorship"
    }), jb) {
      if (!X)
        return;
      this.globalLogger().throwError("error censorship permanent", ce.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    Hb = !!X, jb = !!ee;
  }
  static setLogLevel(X) {
    const ee = ml[X.toLowerCase()];
    if (ee == null) {
      ce.globalLogger().warn("invalid log level - " + X);
      return;
    }
    zb = ee;
  }
  static from(X) {
    return new ce(X);
  }
}
ce.errors = pi;
ce.levels = Mp;
const J4 = "bytes/5.7.0", Sr = new ce(J4);
function H2(Y) {
  return !!Y.toHexString;
}
function Ia(Y) {
  return Y.slice || (Y.slice = function() {
    const X = Array.prototype.slice.call(arguments);
    return Ia(new Uint8Array(Array.prototype.slice.apply(Y, X)));
  }), Y;
}
function Ad(Y) {
  return Bt(Y) && !(Y.length % 2) || fc(Y);
}
function Vb(Y) {
  return typeof Y == "number" && Y == Y && Y % 1 === 0;
}
function fc(Y) {
  if (Y == null)
    return !1;
  if (Y.constructor === Uint8Array)
    return !0;
  if (typeof Y == "string" || !Vb(Y.length) || Y.length < 0)
    return !1;
  for (let X = 0; X < Y.length; X++) {
    const ee = Y[X];
    if (!Vb(ee) || ee < 0 || ee >= 256)
      return !1;
  }
  return !0;
}
function Ne(Y, X) {
  if (X || (X = {}), typeof Y == "number") {
    Sr.checkSafeUint53(Y, "invalid arrayify value");
    const ee = [];
    for (; Y; )
      ee.unshift(Y & 255), Y = parseInt(String(Y / 256));
    return ee.length === 0 && ee.push(0), Ia(new Uint8Array(ee));
  }
  if (X.allowMissingPrefix && typeof Y == "string" && Y.substring(0, 2) !== "0x" && (Y = "0x" + Y), H2(Y) && (Y = Y.toHexString()), Bt(Y)) {
    let ee = Y.substring(2);
    ee.length % 2 && (X.hexPad === "left" ? ee = "0" + ee : X.hexPad === "right" ? ee += "0" : Sr.throwArgumentError("hex data is odd-length", "value", Y));
    const te = [];
    for (let ne = 0; ne < ee.length; ne += 2)
      te.push(parseInt(ee.substring(ne, ne + 2), 16));
    return Ia(new Uint8Array(te));
  }
  return fc(Y) ? Ia(new Uint8Array(Y)) : Sr.throwArgumentError("invalid arrayify value", "value", Y);
}
function Br(Y) {
  const X = Y.map((ne) => Ne(ne)), ee = X.reduce((ne, ie) => ne + ie.length, 0), te = new Uint8Array(ee);
  return X.reduce((ne, ie) => (te.set(ie, ne), ne + ie.length), 0), Ia(te);
}
function _s(Y) {
  let X = Ne(Y);
  if (X.length === 0)
    return X;
  let ee = 0;
  for (; ee < X.length && X[ee] === 0; )
    ee++;
  return ee && (X = X.slice(ee)), X;
}
function Y4(Y, X) {
  Y = Ne(Y), Y.length > X && Sr.throwArgumentError("value out of range", "value", arguments[0]);
  const ee = new Uint8Array(X);
  return ee.set(Y, X - Y.length), Ia(ee);
}
function Bt(Y, X) {
  return !(typeof Y != "string" || !Y.match(/^0x[0-9A-Fa-f]*$/) || X && Y.length !== 2 + 2 * X);
}
const J0 = "0123456789abcdef";
function Oe(Y, X) {
  if (X || (X = {}), typeof Y == "number") {
    Sr.checkSafeUint53(Y, "invalid hexlify value");
    let ee = "";
    for (; Y; )
      ee = J0[Y & 15] + ee, Y = Math.floor(Y / 16);
    return ee.length ? (ee.length % 2 && (ee = "0" + ee), "0x" + ee) : "0x00";
  }
  if (typeof Y == "bigint")
    return Y = Y.toString(16), Y.length % 2 ? "0x0" + Y : "0x" + Y;
  if (X.allowMissingPrefix && typeof Y == "string" && Y.substring(0, 2) !== "0x" && (Y = "0x" + Y), H2(Y))
    return Y.toHexString();
  if (Bt(Y))
    return Y.length % 2 && (X.hexPad === "left" ? Y = "0x0" + Y.substring(2) : X.hexPad === "right" ? Y += "0" : Sr.throwArgumentError("hex data is odd-length", "value", Y)), Y.toLowerCase();
  if (fc(Y)) {
    let ee = "0x";
    for (let te = 0; te < Y.length; te++) {
      let ne = Y[te];
      ee += J0[(ne & 240) >> 4] + J0[ne & 15];
    }
    return ee;
  }
  return Sr.throwArgumentError("invalid hexlify value", "value", Y);
}
function Oo(Y) {
  if (typeof Y != "string")
    Y = Oe(Y);
  else if (!Bt(Y) || Y.length % 2)
    return null;
  return (Y.length - 2) / 2;
}
function Dr(Y, X, ee) {
  return typeof Y != "string" ? Y = Oe(Y) : (!Bt(Y) || Y.length % 2) && Sr.throwArgumentError("invalid hexData", "value", Y), X = 2 + 2 * X, ee != null ? "0x" + Y.substring(X, 2 + 2 * ee) : "0x" + Y.substring(X);
}
function Tn(Y) {
  let X = "0x";
  return Y.forEach((ee) => {
    X += Oe(ee).substring(2);
  }), X;
}
function om(Y) {
  const X = X4(Oe(Y, { hexPad: "left" }));
  return X === "0x" ? "0x0" : X;
}
function X4(Y) {
  typeof Y != "string" && (Y = Oe(Y)), Bt(Y) || Sr.throwArgumentError("invalid hex string", "value", Y), Y = Y.substring(2);
  let X = 0;
  for (; X < Y.length && Y[X] === "0"; )
    X++;
  return "0x" + Y.substring(X);
}
function hr$1(Y, X) {
  for (typeof Y != "string" ? Y = Oe(Y) : Bt(Y) || Sr.throwArgumentError("invalid hex string", "value", Y), Y.length > 2 * X + 2 && Sr.throwArgumentError("value out of range", "value", arguments[1]); Y.length < 2 * X + 2; )
    Y = "0x0" + Y.substring(2);
  return Y;
}
function lc(Y) {
  const X = {
    r: "0x",
    s: "0x",
    _vs: "0x",
    recoveryParam: 0,
    v: 0,
    yParityAndS: "0x",
    compact: "0x"
  };
  if (Ad(Y)) {
    let ee = Ne(Y);
    ee.length === 64 ? (X.v = 27 + (ee[32] >> 7), ee[32] &= 127, X.r = Oe(ee.slice(0, 32)), X.s = Oe(ee.slice(32, 64))) : ee.length === 65 ? (X.r = Oe(ee.slice(0, 32)), X.s = Oe(ee.slice(32, 64)), X.v = ee[64]) : Sr.throwArgumentError("invalid signature string", "signature", Y), X.v < 27 && (X.v === 0 || X.v === 1 ? X.v += 27 : Sr.throwArgumentError("signature invalid v byte", "signature", Y)), X.recoveryParam = 1 - X.v % 2, X.recoveryParam && (ee[32] |= 128), X._vs = Oe(ee.slice(32, 64));
  } else {
    if (X.r = Y.r, X.s = Y.s, X.v = Y.v, X.recoveryParam = Y.recoveryParam, X._vs = Y._vs, X._vs != null) {
      const ne = Y4(Ne(X._vs), 32);
      X._vs = Oe(ne);
      const ie = ne[0] >= 128 ? 1 : 0;
      X.recoveryParam == null ? X.recoveryParam = ie : X.recoveryParam !== ie && Sr.throwArgumentError("signature recoveryParam mismatch _vs", "signature", Y), ne[0] &= 127;
      const oe = Oe(ne);
      X.s == null ? X.s = oe : X.s !== oe && Sr.throwArgumentError("signature v mismatch _vs", "signature", Y);
    }
    if (X.recoveryParam == null)
      X.v == null ? Sr.throwArgumentError("signature missing v and recoveryParam", "signature", Y) : X.v === 0 || X.v === 1 ? X.recoveryParam = X.v : X.recoveryParam = 1 - X.v % 2;
    else if (X.v == null)
      X.v = 27 + X.recoveryParam;
    else {
      const ne = X.v === 0 || X.v === 1 ? X.v : 1 - X.v % 2;
      X.recoveryParam !== ne && Sr.throwArgumentError("signature recoveryParam mismatch v", "signature", Y);
    }
    X.r == null || !Bt(X.r) ? Sr.throwArgumentError("signature missing or invalid r", "signature", Y) : X.r = hr$1(X.r, 32), X.s == null || !Bt(X.s) ? Sr.throwArgumentError("signature missing or invalid s", "signature", Y) : X.s = hr$1(X.s, 32);
    const ee = Ne(X.s);
    ee[0] >= 128 && Sr.throwArgumentError("signature s out of range", "signature", Y), X.recoveryParam && (ee[0] |= 128);
    const te = Oe(ee);
    X._vs && (Bt(X._vs) || Sr.throwArgumentError("signature invalid _vs", "signature", Y), X._vs = hr$1(X._vs, 32)), X._vs == null ? X._vs = te : X._vs !== te && Sr.throwArgumentError("signature _vs mismatch v and s", "signature", Y);
  }
  return X.yParityAndS = X._vs, X.compact = X.r + X.yParityAndS.substring(2), X;
}
function Wb(Y) {
  return Y = lc(Y), Oe(Br([
    Y.r,
    Y.s,
    Y.recoveryParam ? "0x1c" : "0x1b"
  ]));
}
const z2 = "bignumber/5.7.0";
var Bl = bt.BN;
const ls = new ce(z2), Y0 = {}, Kb = 9007199254740991;
function Z4(Y) {
  return Y != null && (Be.isBigNumber(Y) || typeof Y == "number" && Y % 1 === 0 || typeof Y == "string" && !!Y.match(/^-?[0-9]+$/) || Bt(Y) || typeof Y == "bigint" || fc(Y));
}
let Jb = !1;
class Be {
  constructor(X, ee) {
    X !== Y0 && ls.throwError("cannot call constructor directly; use BigNumber.from", ce.errors.UNSUPPORTED_OPERATION, {
      operation: "new (BigNumber)"
    }), this._hex = ee, this._isBigNumber = !0, Object.freeze(this);
  }
  fromTwos(X) {
    return Sn(Mt(this).fromTwos(X));
  }
  toTwos(X) {
    return Sn(Mt(this).toTwos(X));
  }
  abs() {
    return this._hex[0] === "-" ? Be.from(this._hex.substring(1)) : this;
  }
  add(X) {
    return Sn(Mt(this).add(Mt(X)));
  }
  sub(X) {
    return Sn(Mt(this).sub(Mt(X)));
  }
  div(X) {
    return Be.from(X).isZero() && qn("division-by-zero", "div"), Sn(Mt(this).div(Mt(X)));
  }
  mul(X) {
    return Sn(Mt(this).mul(Mt(X)));
  }
  mod(X) {
    const ee = Mt(X);
    return ee.isNeg() && qn("division-by-zero", "mod"), Sn(Mt(this).umod(ee));
  }
  pow(X) {
    const ee = Mt(X);
    return ee.isNeg() && qn("negative-power", "pow"), Sn(Mt(this).pow(ee));
  }
  and(X) {
    const ee = Mt(X);
    return (this.isNegative() || ee.isNeg()) && qn("unbound-bitwise-result", "and"), Sn(Mt(this).and(ee));
  }
  or(X) {
    const ee = Mt(X);
    return (this.isNegative() || ee.isNeg()) && qn("unbound-bitwise-result", "or"), Sn(Mt(this).or(ee));
  }
  xor(X) {
    const ee = Mt(X);
    return (this.isNegative() || ee.isNeg()) && qn("unbound-bitwise-result", "xor"), Sn(Mt(this).xor(ee));
  }
  mask(X) {
    return (this.isNegative() || X < 0) && qn("negative-width", "mask"), Sn(Mt(this).maskn(X));
  }
  shl(X) {
    return (this.isNegative() || X < 0) && qn("negative-width", "shl"), Sn(Mt(this).shln(X));
  }
  shr(X) {
    return (this.isNegative() || X < 0) && qn("negative-width", "shr"), Sn(Mt(this).shrn(X));
  }
  eq(X) {
    return Mt(this).eq(Mt(X));
  }
  lt(X) {
    return Mt(this).lt(Mt(X));
  }
  lte(X) {
    return Mt(this).lte(Mt(X));
  }
  gt(X) {
    return Mt(this).gt(Mt(X));
  }
  gte(X) {
    return Mt(this).gte(Mt(X));
  }
  isNegative() {
    return this._hex[0] === "-";
  }
  isZero() {
    return Mt(this).isZero();
  }
  toNumber() {
    try {
      return Mt(this).toNumber();
    } catch {
      qn("overflow", "toNumber", this.toString());
    }
    return null;
  }
  toBigInt() {
    try {
      return BigInt(this.toString());
    } catch {
    }
    return ls.throwError("this platform does not support BigInt", ce.errors.UNSUPPORTED_OPERATION, {
      value: this.toString()
    });
  }
  toString() {
    return arguments.length > 0 && (arguments[0] === 10 ? Jb || (Jb = !0, ls.warn("BigNumber.toString does not accept any parameters; base-10 is assumed")) : arguments[0] === 16 ? ls.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()", ce.errors.UNEXPECTED_ARGUMENT, {}) : ls.throwError("BigNumber.toString does not accept parameters", ce.errors.UNEXPECTED_ARGUMENT, {})), Mt(this).toString(10);
  }
  toHexString() {
    return this._hex;
  }
  toJSON(X) {
    return { type: "BigNumber", hex: this.toHexString() };
  }
  static from(X) {
    if (X instanceof Be)
      return X;
    if (typeof X == "string")
      return X.match(/^-?0x[0-9a-f]+$/i) ? new Be(Y0, xu(X)) : X.match(/^-?[0-9]+$/) ? new Be(Y0, xu(new Bl(X))) : ls.throwArgumentError("invalid BigNumber string", "value", X);
    if (typeof X == "number")
      return X % 1 && qn("underflow", "BigNumber.from", X), (X >= Kb || X <= -Kb) && qn("overflow", "BigNumber.from", X), Be.from(String(X));
    const ee = X;
    if (typeof ee == "bigint")
      return Be.from(ee.toString());
    if (fc(ee))
      return Be.from(Oe(ee));
    if (ee)
      if (ee.toHexString) {
        const te = ee.toHexString();
        if (typeof te == "string")
          return Be.from(te);
      } else {
        let te = ee._hex;
        if (te == null && ee.type === "BigNumber" && (te = ee.hex), typeof te == "string" && (Bt(te) || te[0] === "-" && Bt(te.substring(1))))
          return Be.from(te);
      }
    return ls.throwArgumentError("invalid BigNumber value", "value", X);
  }
  static isBigNumber(X) {
    return !!(X && X._isBigNumber);
  }
}
function xu(Y) {
  if (typeof Y != "string")
    return xu(Y.toString(16));
  if (Y[0] === "-")
    return Y = Y.substring(1), Y[0] === "-" && ls.throwArgumentError("invalid hex", "value", Y), Y = xu(Y), Y === "0x00" ? Y : "-" + Y;
  if (Y.substring(0, 2) !== "0x" && (Y = "0x" + Y), Y === "0x")
    return "0x00";
  for (Y.length % 2 && (Y = "0x0" + Y.substring(2)); Y.length > 4 && Y.substring(0, 4) === "0x00"; )
    Y = "0x" + Y.substring(4);
  return Y;
}
function Sn(Y) {
  return Be.from(xu(Y));
}
function Mt(Y) {
  const X = Be.from(Y).toHexString();
  return X[0] === "-" ? new Bl("-" + X.substring(3), 16) : new Bl(X.substring(2), 16);
}
function qn(Y, X, ee) {
  const te = { fault: Y, operation: X };
  return ee != null && (te.value = ee), ls.throwError(Y, ce.errors.NUMERIC_FAULT, te);
}
function Q4(Y) {
  return new Bl(Y, 36).toString(16);
}
const yn = new ce(z2), ou = {}, q2 = Be.from(0), G2 = Be.from(-1);
function V2(Y, X, ee, te) {
  const ne = { fault: X, operation: ee };
  return te !== void 0 && (ne.value = te), yn.throwError(Y, ce.errors.NUMERIC_FAULT, ne);
}
let au = "0";
for (; au.length < 256; )
  au += au;
function am(Y) {
  if (typeof Y != "number")
    try {
      Y = Be.from(Y).toNumber();
    } catch {
    }
  return typeof Y == "number" && Y >= 0 && Y <= 256 && !(Y % 1) ? "1" + au.substring(0, Y) : yn.throwArgumentError("invalid decimal size", "decimals", Y);
}
function yl(Y, X) {
  X == null && (X = 0);
  const ee = am(X);
  Y = Be.from(Y);
  const te = Y.lt(q2);
  te && (Y = Y.mul(G2));
  let ne = Y.mod(ee).toString();
  for (; ne.length < ee.length - 1; )
    ne = "0" + ne;
  ne = ne.match(/^([0-9]*[1-9]|0)(0*)/)[1];
  const ie = Y.div(ee).toString();
  return ee.length === 1 ? Y = ie : Y = ie + "." + ne, te && (Y = "-" + Y), Y;
}
function Ri(Y, X) {
  X == null && (X = 0);
  const ee = am(X);
  (typeof Y != "string" || !Y.match(/^-?[0-9.]+$/)) && yn.throwArgumentError("invalid decimal value", "value", Y);
  const te = Y.substring(0, 1) === "-";
  te && (Y = Y.substring(1)), Y === "." && yn.throwArgumentError("missing value", "value", Y);
  const ne = Y.split(".");
  ne.length > 2 && yn.throwArgumentError("too many decimal points", "value", Y);
  let ie = ne[0], oe = ne[1];
  for (ie || (ie = "0"), oe || (oe = "0"); oe[oe.length - 1] === "0"; )
    oe = oe.substring(0, oe.length - 1);
  for (oe.length > ee.length - 1 && V2("fractional component exceeds decimals", "underflow", "parseFixed"), oe === "" && (oe = "0"); oe.length < ee.length - 1; )
    oe += "0";
  const se = Be.from(ie), ae = Be.from(oe);
  let ue = se.mul(ee).add(ae);
  return te && (ue = ue.mul(G2)), ue;
}
class Ra {
  constructor(X, ee, te, ne) {
    X !== ou && yn.throwError("cannot use FixedFormat constructor; use FixedFormat.from", ce.errors.UNSUPPORTED_OPERATION, {
      operation: "new FixedFormat"
    }), this.signed = ee, this.width = te, this.decimals = ne, this.name = (ee ? "" : "u") + "fixed" + String(te) + "x" + String(ne), this._multiplier = am(ne), Object.freeze(this);
  }
  static from(X) {
    if (X instanceof Ra)
      return X;
    typeof X == "number" && (X = `fixed128x${X}`);
    let ee = !0, te = 128, ne = 18;
    if (typeof X == "string") {
      if (X !== "fixed")
        if (X === "ufixed")
          ee = !1;
        else {
          const ie = X.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
          ie || yn.throwArgumentError("invalid fixed format", "format", X), ee = ie[1] !== "u", te = parseInt(ie[2]), ne = parseInt(ie[3]);
        }
    } else if (X) {
      const ie = (oe, se, ae) => X[oe] == null ? ae : (typeof X[oe] !== se && yn.throwArgumentError("invalid fixed format (" + oe + " not " + se + ")", "format." + oe, X[oe]), X[oe]);
      ee = ie("signed", "boolean", ee), te = ie("width", "number", te), ne = ie("decimals", "number", ne);
    }
    return te % 8 && yn.throwArgumentError("invalid fixed format width (not byte aligned)", "format.width", te), ne > 80 && yn.throwArgumentError("invalid fixed format (decimals too large)", "format.decimals", ne), new Ra(ou, ee, te, ne);
  }
}
class en {
  constructor(X, ee, te, ne) {
    X !== ou && yn.throwError("cannot use FixedNumber constructor; use FixedNumber.from", ce.errors.UNSUPPORTED_OPERATION, {
      operation: "new FixedFormat"
    }), this.format = ne, this._hex = ee, this._value = te, this._isFixedNumber = !0, Object.freeze(this);
  }
  _checkFormat(X) {
    this.format.name !== X.format.name && yn.throwArgumentError("incompatible format; use fixedNumber.toFormat", "other", X);
  }
  addUnsafe(X) {
    this._checkFormat(X);
    const ee = Ri(this._value, this.format.decimals), te = Ri(X._value, X.format.decimals);
    return en.fromValue(ee.add(te), this.format.decimals, this.format);
  }
  subUnsafe(X) {
    this._checkFormat(X);
    const ee = Ri(this._value, this.format.decimals), te = Ri(X._value, X.format.decimals);
    return en.fromValue(ee.sub(te), this.format.decimals, this.format);
  }
  mulUnsafe(X) {
    this._checkFormat(X);
    const ee = Ri(this._value, this.format.decimals), te = Ri(X._value, X.format.decimals);
    return en.fromValue(ee.mul(te).div(this.format._multiplier), this.format.decimals, this.format);
  }
  divUnsafe(X) {
    this._checkFormat(X);
    const ee = Ri(this._value, this.format.decimals), te = Ri(X._value, X.format.decimals);
    return en.fromValue(ee.mul(this.format._multiplier).div(te), this.format.decimals, this.format);
  }
  floor() {
    const X = this.toString().split(".");
    X.length === 1 && X.push("0");
    let ee = en.from(X[0], this.format);
    const te = !X[1].match(/^(0*)$/);
    return this.isNegative() && te && (ee = ee.subUnsafe(Yb.toFormat(ee.format))), ee;
  }
  ceiling() {
    const X = this.toString().split(".");
    X.length === 1 && X.push("0");
    let ee = en.from(X[0], this.format);
    const te = !X[1].match(/^(0*)$/);
    return !this.isNegative() && te && (ee = ee.addUnsafe(Yb.toFormat(ee.format))), ee;
  }
  // @TODO: Support other rounding algorithms
  round(X) {
    X == null && (X = 0);
    const ee = this.toString().split(".");
    if (ee.length === 1 && ee.push("0"), (X < 0 || X > 80 || X % 1) && yn.throwArgumentError("invalid decimal count", "decimals", X), ee[1].length <= X)
      return this;
    const te = en.from("1" + au.substring(0, X), this.format), ne = eT.toFormat(this.format);
    return this.mulUnsafe(te).addUnsafe(ne).floor().divUnsafe(te);
  }
  isZero() {
    return this._value === "0.0" || this._value === "0";
  }
  isNegative() {
    return this._value[0] === "-";
  }
  toString() {
    return this._value;
  }
  toHexString(X) {
    if (X == null)
      return this._hex;
    X % 8 && yn.throwArgumentError("invalid byte width", "width", X);
    const ee = Be.from(this._hex).fromTwos(this.format.width).toTwos(X).toHexString();
    return hr$1(ee, X / 8);
  }
  toUnsafeFloat() {
    return parseFloat(this.toString());
  }
  toFormat(X) {
    return en.fromString(this._value, X);
  }
  static fromValue(X, ee, te) {
    return te == null && ee != null && !Z4(ee) && (te = ee, ee = null), ee == null && (ee = 0), te == null && (te = "fixed"), en.fromString(yl(X, ee), Ra.from(te));
  }
  static fromString(X, ee) {
    ee == null && (ee = "fixed");
    const te = Ra.from(ee), ne = Ri(X, te.decimals);
    !te.signed && ne.lt(q2) && V2("unsigned value cannot be negative", "overflow", "value", X);
    let ie = null;
    te.signed ? ie = ne.toTwos(te.width).toHexString() : (ie = ne.toHexString(), ie = hr$1(ie, te.width / 8));
    const oe = yl(ne, te.decimals);
    return new en(ou, ie, oe, te);
  }
  static fromBytes(X, ee) {
    ee == null && (ee = "fixed");
    const te = Ra.from(ee);
    if (Ne(X).length > te.width / 8)
      throw new Error("overflow");
    let ne = Be.from(X);
    te.signed && (ne = ne.fromTwos(te.width));
    const ie = ne.toTwos((te.signed ? 0 : 1) + te.width).toHexString(), oe = yl(ne, te.decimals);
    return new en(ou, ie, oe, te);
  }
  static from(X, ee) {
    if (typeof X == "string")
      return en.fromString(X, ee);
    if (fc(X))
      return en.fromBytes(X, ee);
    try {
      return en.fromValue(X, 0, ee);
    } catch (te) {
      if (te.code !== ce.errors.INVALID_ARGUMENT)
        throw te;
    }
    return yn.throwArgumentError("invalid FixedNumber value", "value", X);
  }
  static isFixedNumber(X) {
    return !!(X && X._isFixedNumber);
  }
}
const Yb = en.from(1), eT = en.from("0.5"), tT = "properties/5.7.0";
var rT = function(Y, X, ee, te) {
  function ne(ie) {
    return ie instanceof ee ? ie : new ee(function(oe) {
      oe(ie);
    });
  }
  return new (ee || (ee = Promise))(function(ie, oe) {
    function se(le) {
      try {
        ue(te.next(le));
      } catch (he) {
        oe(he);
      }
    }
    function ae(le) {
      try {
        ue(te.throw(le));
      } catch (he) {
        oe(he);
      }
    }
    function ue(le) {
      le.done ? ie(le.value) : ne(le.value).then(se, ae);
    }
    ue((te = te.apply(Y, X || [])).next());
  });
};
const Nl = new ce(tT);
function ve(Y, X, ee) {
  Object.defineProperty(Y, X, {
    enumerable: !0,
    value: ee,
    writable: !1
  });
}
function ji(Y, X) {
  for (let ee = 0; ee < 32; ee++) {
    if (Y[X])
      return Y[X];
    if (!Y.prototype || typeof Y.prototype != "object")
      break;
    Y = Object.getPrototypeOf(Y.prototype).constructor;
  }
  return null;
}
function Cr(Y) {
  return rT(this, void 0, void 0, function* () {
    const X = Object.keys(Y).map((ee) => {
      const te = Y[ee];
      return Promise.resolve(te).then((ne) => ({ key: ee, value: ne }));
    });
    return (yield Promise.all(X)).reduce((ee, te) => (ee[te.key] = te.value, ee), {});
  });
}
function W2(Y, X) {
  (!Y || typeof Y != "object") && Nl.throwArgumentError("invalid object", "object", Y), Object.keys(Y).forEach((ee) => {
    X[ee] || Nl.throwArgumentError("invalid object key - " + ee, "transaction:" + ee, Y);
  });
}
function mr$1(Y) {
  const X = {};
  for (const ee in Y)
    X[ee] = Y[ee];
  return X;
}
const nT = { bigint: !0, boolean: !0, function: !0, number: !0, string: !0 };
function K2(Y) {
  if (Y == null || nT[typeof Y])
    return !0;
  if (Array.isArray(Y) || typeof Y == "object") {
    if (!Object.isFrozen(Y))
      return !1;
    const X = Object.keys(Y);
    for (let ee = 0; ee < X.length; ee++) {
      let te = null;
      try {
        te = Y[X[ee]];
      } catch {
        continue;
      }
      if (!K2(te))
        return !1;
    }
    return !0;
  }
  return Nl.throwArgumentError(`Cannot deepCopy ${typeof Y}`, "object", Y);
}
function iT(Y) {
  if (K2(Y))
    return Y;
  if (Array.isArray(Y))
    return Object.freeze(Y.map((X) => ti(X)));
  if (typeof Y == "object") {
    const X = {};
    for (const ee in Y) {
      const te = Y[ee];
      te !== void 0 && ve(X, ee, ti(te));
    }
    return X;
  }
  return Nl.throwArgumentError(`Cannot deepCopy ${typeof Y}`, "object", Y);
}
function ti(Y) {
  return iT(Y);
}
class Wo {
  constructor(X) {
    for (const ee in X)
      this[ee] = ti(X[ee]);
  }
}
const af = "abi/5.7.0", Ft = new ce(af), Bo = {};
let Xb = { calldata: !0, memory: !0, storage: !0 }, sT = { calldata: !0, memory: !0 };
function Ff(Y, X) {
  if (Y === "bytes" || Y === "string") {
    if (Xb[X])
      return !0;
  } else if (Y === "address") {
    if (X === "payable")
      return !0;
  } else if ((Y.indexOf("[") >= 0 || Y === "tuple") && sT[X])
    return !0;
  return (Xb[X] || X === "payable") && Ft.throwArgumentError("invalid modifier", "name", X), !1;
}
function oT(Y, X) {
  let ee = Y;
  function te(se) {
    Ft.throwArgumentError(`unexpected character at position ${se}`, "param", Y);
  }
  Y = Y.replace(/\s/g, " ");
  function ne(se) {
    let ae = { type: "", name: "", parent: se, state: { allowType: !0 } };
    return X && (ae.indexed = !1), ae;
  }
  let ie = { type: "", name: "", state: { allowType: !0 } }, oe = ie;
  for (let se = 0; se < Y.length; se++) {
    let ae = Y[se];
    switch (ae) {
      case "(":
        oe.state.allowType && oe.type === "" ? oe.type = "tuple" : oe.state.allowParams || te(se), oe.state.allowType = !1, oe.type = la(oe.type), oe.components = [ne(oe)], oe = oe.components[0];
        break;
      case ")":
        delete oe.state, oe.name === "indexed" && (X || te(se), oe.indexed = !0, oe.name = ""), Ff(oe.type, oe.name) && (oe.name = ""), oe.type = la(oe.type);
        let ue = oe;
        oe = oe.parent, oe || te(se), delete ue.parent, oe.state.allowParams = !1, oe.state.allowName = !0, oe.state.allowArray = !0;
        break;
      case ",":
        delete oe.state, oe.name === "indexed" && (X || te(se), oe.indexed = !0, oe.name = ""), Ff(oe.type, oe.name) && (oe.name = ""), oe.type = la(oe.type);
        let le = ne(oe.parent);
        oe.parent.components.push(le), delete oe.parent, oe = le;
        break;
      case " ":
        oe.state.allowType && oe.type !== "" && (oe.type = la(oe.type), delete oe.state.allowType, oe.state.allowName = !0, oe.state.allowParams = !0), oe.state.allowName && oe.name !== "" && (oe.name === "indexed" ? (X || te(se), oe.indexed && te(se), oe.indexed = !0, oe.name = "") : Ff(oe.type, oe.name) ? oe.name = "" : oe.state.allowName = !1);
        break;
      case "[":
        oe.state.allowArray || te(se), oe.type += ae, oe.state.allowArray = !1, oe.state.allowName = !1, oe.state.readArray = !0;
        break;
      case "]":
        oe.state.readArray || te(se), oe.type += ae, oe.state.readArray = !1, oe.state.allowArray = !0, oe.state.allowName = !0;
        break;
      default:
        oe.state.allowType ? (oe.type += ae, oe.state.allowParams = !0, oe.state.allowArray = !0) : oe.state.allowName ? (oe.name += ae, delete oe.state.allowArray) : oe.state.readArray ? oe.type += ae : te(se);
    }
  }
  return oe.parent && Ft.throwArgumentError("unexpected eof", "param", Y), delete ie.state, oe.name === "indexed" ? (X || te(ee.length - 7), oe.indexed && te(ee.length - 7), oe.indexed = !0, oe.name = "") : Ff(oe.type, oe.name) && (oe.name = ""), ie.type = la(ie.type), ie;
}
function bl(Y, X) {
  for (let ee in X)
    ve(Y, ee, X[ee]);
}
const Xt = Object.freeze({
  // Bare formatting, as is needed for computing a sighash of an event or function
  sighash: "sighash",
  // Human-Readable with Minimal spacing and without names (compact human-readable)
  minimal: "minimal",
  // Human-Readable with nice spacing, including all names
  full: "full",
  // JSON-format a la Solidity
  json: "json"
}), aT = new RegExp(/^(.*)\[([0-9]*)\]$/);
class Vr {
  constructor(X, ee) {
    X !== Bo && Ft.throwError("use fromString", ce.errors.UNSUPPORTED_OPERATION, {
      operation: "new ParamType()"
    }), bl(this, ee);
    let te = this.type.match(aT);
    te ? bl(this, {
      arrayLength: parseInt(te[2] || "-1"),
      arrayChildren: Vr.fromObject({
        type: te[1],
        components: this.components
      }),
      baseType: "array"
    }) : bl(this, {
      arrayLength: null,
      arrayChildren: null,
      baseType: this.components != null ? "tuple" : this.type
    }), this._isParamType = !0, Object.freeze(this);
  }
  // Format the parameter fragment
  //   - sighash: "(uint256,address)"
  //   - minimal: "tuple(uint256,address) indexed"
  //   - full:    "tuple(uint256 foo, address bar) indexed baz"
  format(X) {
    if (X || (X = Xt.sighash), Xt[X] || Ft.throwArgumentError("invalid format type", "format", X), X === Xt.json) {
      let te = {
        type: this.baseType === "tuple" ? "tuple" : this.type,
        name: this.name || void 0
      };
      return typeof this.indexed == "boolean" && (te.indexed = this.indexed), this.components && (te.components = this.components.map((ne) => JSON.parse(ne.format(X)))), JSON.stringify(te);
    }
    let ee = "";
    return this.baseType === "array" ? (ee += this.arrayChildren.format(X), ee += "[" + (this.arrayLength < 0 ? "" : String(this.arrayLength)) + "]") : this.baseType === "tuple" ? (X !== Xt.sighash && (ee += this.type), ee += "(" + this.components.map((te) => te.format(X)).join(X === Xt.full ? ", " : ",") + ")") : ee += this.type, X !== Xt.sighash && (this.indexed === !0 && (ee += " indexed"), X === Xt.full && this.name && (ee += " " + this.name)), ee;
  }
  static from(X, ee) {
    return typeof X == "string" ? Vr.fromString(X, ee) : Vr.fromObject(X);
  }
  static fromObject(X) {
    return Vr.isParamType(X) ? X : new Vr(Bo, {
      name: X.name || null,
      type: la(X.type),
      indexed: X.indexed == null ? null : !!X.indexed,
      components: X.components ? X.components.map(Vr.fromObject) : null
    });
  }
  static fromString(X, ee) {
    function te(ne) {
      return Vr.fromObject({
        name: ne.name,
        type: ne.type,
        indexed: ne.indexed,
        components: ne.components
      });
    }
    return te(oT(X, !!ee));
  }
  static isParamType(X) {
    return !!(X != null && X._isParamType);
  }
}
function wu(Y, X) {
  return uT(Y).map((ee) => Vr.fromString(ee, X));
}
class ws {
  constructor(X, ee) {
    X !== Bo && Ft.throwError("use a static from method", ce.errors.UNSUPPORTED_OPERATION, {
      operation: "new Fragment()"
    }), bl(this, ee), this._isFragment = !0, Object.freeze(this);
  }
  static from(X) {
    return ws.isFragment(X) ? X : typeof X == "string" ? ws.fromString(X) : ws.fromObject(X);
  }
  static fromObject(X) {
    if (ws.isFragment(X))
      return X;
    switch (X.type) {
      case "function":
        return Fi.fromObject(X);
      case "event":
        return bs.fromObject(X);
      case "constructor":
        return Li.fromObject(X);
      case "error":
        return Js.fromObject(X);
      case "fallback":
      case "receive":
        return null;
    }
    return Ft.throwArgumentError("invalid fragment object", "value", X);
  }
  static fromString(X) {
    return X = X.replace(/\s/g, " "), X = X.replace(/\(/g, " (").replace(/\)/g, ") ").replace(/\s+/g, " "), X = X.trim(), X.split(" ")[0] === "event" ? bs.fromString(X.substring(5).trim()) : X.split(" ")[0] === "function" ? Fi.fromString(X.substring(8).trim()) : X.split("(")[0].trim() === "constructor" ? Li.fromString(X.trim()) : X.split(" ")[0] === "error" ? Js.fromString(X.substring(5).trim()) : Ft.throwArgumentError("unsupported fragment", "value", X);
  }
  static isFragment(X) {
    return !!(X && X._isFragment);
  }
}
class bs extends ws {
  format(X) {
    if (X || (X = Xt.sighash), Xt[X] || Ft.throwArgumentError("invalid format type", "format", X), X === Xt.json)
      return JSON.stringify({
        type: "event",
        anonymous: this.anonymous,
        name: this.name,
        inputs: this.inputs.map((te) => JSON.parse(te.format(X)))
      });
    let ee = "";
    return X !== Xt.sighash && (ee += "event "), ee += this.name + "(" + this.inputs.map((te) => te.format(X)).join(X === Xt.full ? ", " : ",") + ") ", X !== Xt.sighash && this.anonymous && (ee += "anonymous "), ee.trim();
  }
  static from(X) {
    return typeof X == "string" ? bs.fromString(X) : bs.fromObject(X);
  }
  static fromObject(X) {
    if (bs.isEventFragment(X))
      return X;
    X.type !== "event" && Ft.throwArgumentError("invalid event object", "value", X);
    const ee = {
      name: vu(X.name),
      anonymous: X.anonymous,
      inputs: X.inputs ? X.inputs.map(Vr.fromObject) : [],
      type: "event"
    };
    return new bs(Bo, ee);
  }
  static fromString(X) {
    let ee = X.match(Eu);
    ee || Ft.throwArgumentError("invalid event string", "value", X);
    let te = !1;
    return ee[3].split(" ").forEach((ne) => {
      switch (ne.trim()) {
        case "anonymous":
          te = !0;
          break;
        case "":
          break;
        default:
          Ft.warn("unknown modifier: " + ne);
      }
    }), bs.fromObject({
      name: ee[1].trim(),
      anonymous: te,
      inputs: wu(ee[2], !0),
      type: "event"
    });
  }
  static isEventFragment(X) {
    return X && X._isFragment && X.type === "event";
  }
}
function J2(Y, X) {
  X.gas = null;
  let ee = Y.split("@");
  return ee.length !== 1 ? (ee.length > 2 && Ft.throwArgumentError("invalid human-readable ABI signature", "value", Y), ee[1].match(/^[0-9]+$/) || Ft.throwArgumentError("invalid human-readable ABI signature gas", "value", Y), X.gas = Be.from(ee[1]), ee[0]) : Y;
}
function Y2(Y, X) {
  X.constant = !1, X.payable = !1, X.stateMutability = "nonpayable", Y.split(" ").forEach((ee) => {
    switch (ee.trim()) {
      case "constant":
        X.constant = !0;
        break;
      case "payable":
        X.payable = !0, X.stateMutability = "payable";
        break;
      case "nonpayable":
        X.payable = !1, X.stateMutability = "nonpayable";
        break;
      case "pure":
        X.constant = !0, X.stateMutability = "pure";
        break;
      case "view":
        X.constant = !0, X.stateMutability = "view";
        break;
      case "external":
      case "public":
      case "":
        break;
      default:
        console.log("unknown modifier: " + ee);
    }
  });
}
function X2(Y) {
  let X = {
    constant: !1,
    payable: !0,
    stateMutability: "payable"
  };
  return Y.stateMutability != null ? (X.stateMutability = Y.stateMutability, X.constant = X.stateMutability === "view" || X.stateMutability === "pure", Y.constant != null && !!Y.constant !== X.constant && Ft.throwArgumentError("cannot have constant function with mutability " + X.stateMutability, "value", Y), X.payable = X.stateMutability === "payable", Y.payable != null && !!Y.payable !== X.payable && Ft.throwArgumentError("cannot have payable function with mutability " + X.stateMutability, "value", Y)) : Y.payable != null ? (X.payable = !!Y.payable, Y.constant == null && !X.payable && Y.type !== "constructor" && Ft.throwArgumentError("unable to determine stateMutability", "value", Y), X.constant = !!Y.constant, X.constant ? X.stateMutability = "view" : X.stateMutability = X.payable ? "payable" : "nonpayable", X.payable && X.constant && Ft.throwArgumentError("cannot have constant payable function", "value", Y)) : Y.constant != null ? (X.constant = !!Y.constant, X.payable = !X.constant, X.stateMutability = X.constant ? "view" : "payable") : Y.type !== "constructor" && Ft.throwArgumentError("unable to determine stateMutability", "value", Y), X;
}
class Li extends ws {
  format(X) {
    if (X || (X = Xt.sighash), Xt[X] || Ft.throwArgumentError("invalid format type", "format", X), X === Xt.json)
      return JSON.stringify({
        type: "constructor",
        stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
        payable: this.payable,
        gas: this.gas ? this.gas.toNumber() : void 0,
        inputs: this.inputs.map((te) => JSON.parse(te.format(X)))
      });
    X === Xt.sighash && Ft.throwError("cannot format a constructor for sighash", ce.errors.UNSUPPORTED_OPERATION, {
      operation: "format(sighash)"
    });
    let ee = "constructor(" + this.inputs.map((te) => te.format(X)).join(X === Xt.full ? ", " : ",") + ") ";
    return this.stateMutability && this.stateMutability !== "nonpayable" && (ee += this.stateMutability + " "), ee.trim();
  }
  static from(X) {
    return typeof X == "string" ? Li.fromString(X) : Li.fromObject(X);
  }
  static fromObject(X) {
    if (Li.isConstructorFragment(X))
      return X;
    X.type !== "constructor" && Ft.throwArgumentError("invalid constructor object", "value", X);
    let ee = X2(X);
    ee.constant && Ft.throwArgumentError("constructor cannot be constant", "value", X);
    const te = {
      name: null,
      type: X.type,
      inputs: X.inputs ? X.inputs.map(Vr.fromObject) : [],
      payable: ee.payable,
      stateMutability: ee.stateMutability,
      gas: X.gas ? Be.from(X.gas) : null
    };
    return new Li(Bo, te);
  }
  static fromString(X) {
    let ee = { type: "constructor" };
    X = J2(X, ee);
    let te = X.match(Eu);
    return (!te || te[1].trim() !== "constructor") && Ft.throwArgumentError("invalid constructor string", "value", X), ee.inputs = wu(te[2].trim(), !1), Y2(te[3].trim(), ee), Li.fromObject(ee);
  }
  static isConstructorFragment(X) {
    return X && X._isFragment && X.type === "constructor";
  }
}
class Fi extends Li {
  format(X) {
    if (X || (X = Xt.sighash), Xt[X] || Ft.throwArgumentError("invalid format type", "format", X), X === Xt.json)
      return JSON.stringify({
        type: "function",
        name: this.name,
        constant: this.constant,
        stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
        payable: this.payable,
        gas: this.gas ? this.gas.toNumber() : void 0,
        inputs: this.inputs.map((te) => JSON.parse(te.format(X))),
        outputs: this.outputs.map((te) => JSON.parse(te.format(X)))
      });
    let ee = "";
    return X !== Xt.sighash && (ee += "function "), ee += this.name + "(" + this.inputs.map((te) => te.format(X)).join(X === Xt.full ? ", " : ",") + ") ", X !== Xt.sighash && (this.stateMutability ? this.stateMutability !== "nonpayable" && (ee += this.stateMutability + " ") : this.constant && (ee += "view "), this.outputs && this.outputs.length && (ee += "returns (" + this.outputs.map((te) => te.format(X)).join(", ") + ") "), this.gas != null && (ee += "@" + this.gas.toString() + " ")), ee.trim();
  }
  static from(X) {
    return typeof X == "string" ? Fi.fromString(X) : Fi.fromObject(X);
  }
  static fromObject(X) {
    if (Fi.isFunctionFragment(X))
      return X;
    X.type !== "function" && Ft.throwArgumentError("invalid function object", "value", X);
    let ee = X2(X);
    const te = {
      type: X.type,
      name: vu(X.name),
      constant: ee.constant,
      inputs: X.inputs ? X.inputs.map(Vr.fromObject) : [],
      outputs: X.outputs ? X.outputs.map(Vr.fromObject) : [],
      payable: ee.payable,
      stateMutability: ee.stateMutability,
      gas: X.gas ? Be.from(X.gas) : null
    };
    return new Fi(Bo, te);
  }
  static fromString(X) {
    let ee = { type: "function" };
    X = J2(X, ee);
    let te = X.split(" returns ");
    te.length > 2 && Ft.throwArgumentError("invalid function string", "value", X);
    let ne = te[0].match(Eu);
    if (ne || Ft.throwArgumentError("invalid function signature", "value", X), ee.name = ne[1].trim(), ee.name && vu(ee.name), ee.inputs = wu(ne[2], !1), Y2(ne[3].trim(), ee), te.length > 1) {
      let ie = te[1].match(Eu);
      (ie[1].trim() != "" || ie[3].trim() != "") && Ft.throwArgumentError("unexpected tokens", "value", X), ee.outputs = wu(ie[2], !1);
    } else
      ee.outputs = [];
    return Fi.fromObject(ee);
  }
  static isFunctionFragment(X) {
    return X && X._isFragment && X.type === "function";
  }
}
function Zb(Y) {
  const X = Y.format();
  return (X === "Error(string)" || X === "Panic(uint256)") && Ft.throwArgumentError(`cannot specify user defined ${X} error`, "fragment", Y), Y;
}
class Js extends ws {
  format(X) {
    if (X || (X = Xt.sighash), Xt[X] || Ft.throwArgumentError("invalid format type", "format", X), X === Xt.json)
      return JSON.stringify({
        type: "error",
        name: this.name,
        inputs: this.inputs.map((te) => JSON.parse(te.format(X)))
      });
    let ee = "";
    return X !== Xt.sighash && (ee += "error "), ee += this.name + "(" + this.inputs.map((te) => te.format(X)).join(X === Xt.full ? ", " : ",") + ") ", ee.trim();
  }
  static from(X) {
    return typeof X == "string" ? Js.fromString(X) : Js.fromObject(X);
  }
  static fromObject(X) {
    if (Js.isErrorFragment(X))
      return X;
    X.type !== "error" && Ft.throwArgumentError("invalid error object", "value", X);
    const ee = {
      type: X.type,
      name: vu(X.name),
      inputs: X.inputs ? X.inputs.map(Vr.fromObject) : []
    };
    return Zb(new Js(Bo, ee));
  }
  static fromString(X) {
    let ee = { type: "error" }, te = X.match(Eu);
    return te || Ft.throwArgumentError("invalid error signature", "value", X), ee.name = te[1].trim(), ee.name && vu(ee.name), ee.inputs = wu(te[2], !1), Zb(Js.fromObject(ee));
  }
  static isErrorFragment(X) {
    return X && X._isFragment && X.type === "error";
  }
}
function la(Y) {
  return Y.match(/^uint($|[^1-9])/) ? Y = "uint256" + Y.substring(4) : Y.match(/^int($|[^1-9])/) && (Y = "int256" + Y.substring(3)), Y;
}
const cT = new RegExp("^[a-zA-Z$_][a-zA-Z0-9$_]*$");
function vu(Y) {
  return (!Y || !Y.match(cT)) && Ft.throwArgumentError(`invalid identifier "${Y}"`, "value", Y), Y;
}
const Eu = new RegExp("^([^)(]*)\\((.*)\\)([^)(]*)$");
function uT(Y) {
  Y = Y.trim();
  let X = [], ee = "", te = 0;
  for (let ne = 0; ne < Y.length; ne++) {
    let ie = Y[ne];
    ie === "," && te === 0 ? (X.push(ee), ee = "") : (ee += ie, ie === "(" ? te++ : ie === ")" && (te--, te === -1 && Ft.throwArgumentError("unbalanced parenthesis", "value", Y)));
  }
  return ee && X.push(ee), X;
}
const cm = new ce(af);
function fT(Y) {
  const X = [], ee = function(te, ne) {
    if (Array.isArray(ne))
      for (let ie in ne) {
        const oe = te.slice();
        oe.push(ie);
        try {
          ee(oe, ne[ie]);
        } catch (se) {
          X.push({ path: oe, error: se });
        }
      }
  };
  return ee([], Y), X;
}
class Ms {
  constructor(X, ee, te, ne) {
    this.name = X, this.type = ee, this.localName = te, this.dynamic = ne;
  }
  _throwError(X, ee) {
    cm.throwArgumentError(X, this.localName, ee);
  }
}
class Lp {
  constructor(X) {
    ve(this, "wordSize", X || 32), this._data = [], this._dataLength = 0, this._padding = new Uint8Array(X);
  }
  get data() {
    return Tn(this._data);
  }
  get length() {
    return this._dataLength;
  }
  _writeData(X) {
    return this._data.push(X), this._dataLength += X.length, X.length;
  }
  appendWriter(X) {
    return this._writeData(Br(X._data));
  }
  // Arrayish items; padded on the right to wordSize
  writeBytes(X) {
    let ee = Ne(X);
    const te = ee.length % this.wordSize;
    return te && (ee = Br([ee, this._padding.slice(te)])), this._writeData(ee);
  }
  _getValue(X) {
    let ee = Ne(Be.from(X));
    return ee.length > this.wordSize && cm.throwError("value out-of-bounds", ce.errors.BUFFER_OVERRUN, {
      length: this.wordSize,
      offset: ee.length
    }), ee.length % this.wordSize && (ee = Br([this._padding.slice(ee.length % this.wordSize), ee])), ee;
  }
  // BigNumberish items; padded on the left to wordSize
  writeValue(X) {
    return this._writeData(this._getValue(X));
  }
  writeUpdatableValue() {
    const X = this._data.length;
    return this._data.push(this._padding), this._dataLength += this.wordSize, (ee) => {
      this._data[X] = this._getValue(ee);
    };
  }
}
class kl {
  constructor(X, ee, te, ne) {
    ve(this, "_data", Ne(X)), ve(this, "wordSize", ee || 32), ve(this, "_coerceFunc", te), ve(this, "allowLoose", ne), this._offset = 0;
  }
  get data() {
    return Oe(this._data);
  }
  get consumed() {
    return this._offset;
  }
  // The default Coerce function
  static coerce(X, ee) {
    let te = X.match("^u?int([0-9]+)$");
    return te && parseInt(te[1]) <= 48 && (ee = ee.toNumber()), ee;
  }
  coerce(X, ee) {
    return this._coerceFunc ? this._coerceFunc(X, ee) : kl.coerce(X, ee);
  }
  _peekBytes(X, ee, te) {
    let ne = Math.ceil(ee / this.wordSize) * this.wordSize;
    return this._offset + ne > this._data.length && (this.allowLoose && te && this._offset + ee <= this._data.length ? ne = ee : cm.throwError("data out-of-bounds", ce.errors.BUFFER_OVERRUN, {
      length: this._data.length,
      offset: this._offset + ne
    })), this._data.slice(this._offset, this._offset + ne);
  }
  subReader(X) {
    return new kl(this._data.slice(this._offset + X), this.wordSize, this._coerceFunc, this.allowLoose);
  }
  readBytes(X, ee) {
    let te = this._peekBytes(0, X, !!ee);
    return this._offset += te.length, te.slice(0, X);
  }
  readValue() {
    return Be.from(this.readBytes(this.wordSize));
  }
}
var Z2 = { exports: {} };
/**
 * [js-sha3]{@link https://github.com/emn178/js-sha3}
 *
 * @version 0.8.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2015-2018
 * @license MIT
 */
(function(Y) {
  (function() {
    var X = "input is invalid type", ee = "finalize already called", te = typeof window == "object", ne = te ? window : {};
    ne.JS_SHA3_NO_WINDOW && (te = !1);
    var ie = !te && typeof self == "object", oe = !ne.JS_SHA3_NO_NODE_JS && typeof process == "object" && process.versions && process.versions.node;
    oe ? ne = St : ie && (ne = self);
    var se = !ne.JS_SHA3_NO_COMMON_JS && !0 && Y.exports, ae = !ne.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer < "u", ue = "0123456789abcdef".split(""), le = [31, 7936, 2031616, 520093696], he = [4, 1024, 262144, 67108864], me = [1, 256, 65536, 16777216], ye = [6, 1536, 393216, 100663296], we = [0, 8, 16, 24], Ee = [
      1,
      0,
      32898,
      0,
      32906,
      2147483648,
      2147516416,
      2147483648,
      32907,
      0,
      2147483649,
      0,
      2147516545,
      2147483648,
      32777,
      2147483648,
      138,
      0,
      136,
      0,
      2147516425,
      0,
      2147483658,
      0,
      2147516555,
      0,
      139,
      2147483648,
      32905,
      2147483648,
      32771,
      2147483648,
      32770,
      2147483648,
      128,
      2147483648,
      32778,
      0,
      2147483658,
      2147483648,
      2147516545,
      2147483648,
      32896,
      2147483648,
      2147483649,
      0,
      2147516424,
      2147483648
    ], Re = [224, 256, 384, 512], Ue = [128, 256], Me = ["hex", "buffer", "arrayBuffer", "array", "digest"], De = {
      128: 168,
      256: 136
    };
    (ne.JS_SHA3_NO_NODE_JS || !Array.isArray) && (Array.isArray = function($e) {
      return Object.prototype.toString.call($e) === "[object Array]";
    }), ae && (ne.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView) && (ArrayBuffer.isView = function($e) {
      return typeof $e == "object" && $e.buffer && $e.buffer.constructor === ArrayBuffer;
    });
    for (var Fe = function($e, Ze, ot) {
      return function(ct) {
        return new Ae($e, Ze, $e).update(ct)[ot]();
      };
    }, Ke = function($e, Ze, ot) {
      return function(ct, At) {
        return new Ae($e, Ze, At).update(ct)[ot]();
      };
    }, tt = function($e, Ze, ot) {
      return function(ct, At, Tt, dt) {
        return de["cshake" + $e].update(ct, At, Tt, dt)[ot]();
      };
    }, rt = function($e, Ze, ot) {
      return function(ct, At, Tt, dt) {
        return de["kmac" + $e].update(ct, At, Tt, dt)[ot]();
      };
    }, it = function($e, Ze, ot, ct) {
      for (var At = 0; At < Me.length; ++At) {
        var Tt = Me[At];
        $e[Tt] = Ze(ot, ct, Tt);
      }
      return $e;
    }, _t = function($e, Ze) {
      var ot = Fe($e, Ze, "hex");
      return ot.create = function() {
        return new Ae($e, Ze, $e);
      }, ot.update = function(ct) {
        return ot.create().update(ct);
      }, it(ot, Fe, $e, Ze);
    }, Dt = function($e, Ze) {
      var ot = Ke($e, Ze, "hex");
      return ot.create = function(ct) {
        return new Ae($e, Ze, ct);
      }, ot.update = function(ct, At) {
        return ot.create(At).update(ct);
      }, it(ot, Ke, $e, Ze);
    }, je = function($e, Ze) {
      var ot = De[$e], ct = tt($e, Ze, "hex");
      return ct.create = function(At, Tt, dt) {
        return !Tt && !dt ? de["shake" + $e].create(At) : new Ae($e, Ze, At).bytepad([Tt, dt], ot);
      }, ct.update = function(At, Tt, dt, vt) {
        return ct.create(Tt, dt, vt).update(At);
      }, it(ct, tt, $e, Ze);
    }, ze = function($e, Ze) {
      var ot = De[$e], ct = rt($e, Ze, "hex");
      return ct.create = function(At, Tt, dt) {
        return new Ge($e, Ze, Tt).bytepad(["KMAC", dt], ot).bytepad([At], ot);
      }, ct.update = function(At, Tt, dt, vt) {
        return ct.create(At, dt, vt).update(Tt);
      }, it(ct, rt, $e, Ze);
    }, fe = [
      { name: "keccak", padding: me, bits: Re, createMethod: _t },
      { name: "sha3", padding: ye, bits: Re, createMethod: _t },
      { name: "shake", padding: le, bits: Ue, createMethod: Dt },
      { name: "cshake", padding: he, bits: Ue, createMethod: je },
      { name: "kmac", padding: he, bits: Ue, createMethod: ze }
    ], de = {}, be = [], Te = 0; Te < fe.length; ++Te)
      for (var Ce = fe[Te], Pe = Ce.bits, Se = 0; Se < Pe.length; ++Se) {
        var ke = Ce.name + "_" + Pe[Se];
        if (be.push(ke), de[ke] = Ce.createMethod(Pe[Se], Ce.padding), Ce.name !== "sha3") {
          var ge = Ce.name + Pe[Se];
          be.push(ge), de[ge] = de[ke];
        }
      }
    function Ae($e, Ze, ot) {
      this.blocks = [], this.s = [], this.padding = Ze, this.outputBits = ot, this.reset = !0, this.finalized = !1, this.block = 0, this.start = 0, this.blockCount = 1600 - ($e << 1) >> 5, this.byteCount = this.blockCount << 2, this.outputBlocks = ot >> 5, this.extraBytes = (ot & 31) >> 3;
      for (var ct = 0; ct < 50; ++ct)
        this.s[ct] = 0;
    }
    Ae.prototype.update = function($e) {
      if (this.finalized)
        throw new Error(ee);
      var Ze, ot = typeof $e;
      if (ot !== "string") {
        if (ot === "object") {
          if ($e === null)
            throw new Error(X);
          if (ae && $e.constructor === ArrayBuffer)
            $e = new Uint8Array($e);
          else if (!Array.isArray($e) && (!ae || !ArrayBuffer.isView($e)))
            throw new Error(X);
        } else
          throw new Error(X);
        Ze = !0;
      }
      for (var ct = this.blocks, At = this.byteCount, Tt = $e.length, dt = this.blockCount, vt = 0, Ut = this.s, It, Er; vt < Tt; ) {
        if (this.reset)
          for (this.reset = !1, ct[0] = this.block, It = 1; It < dt + 1; ++It)
            ct[It] = 0;
        if (Ze)
          for (It = this.start; vt < Tt && It < At; ++vt)
            ct[It >> 2] |= $e[vt] << we[It++ & 3];
        else
          for (It = this.start; vt < Tt && It < At; ++vt)
            Er = $e.charCodeAt(vt), Er < 128 ? ct[It >> 2] |= Er << we[It++ & 3] : Er < 2048 ? (ct[It >> 2] |= (192 | Er >> 6) << we[It++ & 3], ct[It >> 2] |= (128 | Er & 63) << we[It++ & 3]) : Er < 55296 || Er >= 57344 ? (ct[It >> 2] |= (224 | Er >> 12) << we[It++ & 3], ct[It >> 2] |= (128 | Er >> 6 & 63) << we[It++ & 3], ct[It >> 2] |= (128 | Er & 63) << we[It++ & 3]) : (Er = 65536 + ((Er & 1023) << 10 | $e.charCodeAt(++vt) & 1023), ct[It >> 2] |= (240 | Er >> 18) << we[It++ & 3], ct[It >> 2] |= (128 | Er >> 12 & 63) << we[It++ & 3], ct[It >> 2] |= (128 | Er >> 6 & 63) << we[It++ & 3], ct[It >> 2] |= (128 | Er & 63) << we[It++ & 3]);
        if (this.lastByteIndex = It, It >= At) {
          for (this.start = It - At, this.block = ct[dt], It = 0; It < dt; ++It)
            Ut[It] ^= ct[It];
          Xe(Ut), this.reset = !0;
        } else
          this.start = It;
      }
      return this;
    }, Ae.prototype.encode = function($e, Ze) {
      var ot = $e & 255, ct = 1, At = [ot];
      for ($e = $e >> 8, ot = $e & 255; ot > 0; )
        At.unshift(ot), $e = $e >> 8, ot = $e & 255, ++ct;
      return Ze ? At.push(ct) : At.unshift(ct), this.update(At), At.length;
    }, Ae.prototype.encodeString = function($e) {
      var Ze, ot = typeof $e;
      if (ot !== "string") {
        if (ot === "object") {
          if ($e === null)
            throw new Error(X);
          if (ae && $e.constructor === ArrayBuffer)
            $e = new Uint8Array($e);
          else if (!Array.isArray($e) && (!ae || !ArrayBuffer.isView($e)))
            throw new Error(X);
        } else
          throw new Error(X);
        Ze = !0;
      }
      var ct = 0, At = $e.length;
      if (Ze)
        ct = At;
      else
        for (var Tt = 0; Tt < $e.length; ++Tt) {
          var dt = $e.charCodeAt(Tt);
          dt < 128 ? ct += 1 : dt < 2048 ? ct += 2 : dt < 55296 || dt >= 57344 ? ct += 3 : (dt = 65536 + ((dt & 1023) << 10 | $e.charCodeAt(++Tt) & 1023), ct += 4);
        }
      return ct += this.encode(ct * 8), this.update($e), ct;
    }, Ae.prototype.bytepad = function($e, Ze) {
      for (var ot = this.encode(Ze), ct = 0; ct < $e.length; ++ct)
        ot += this.encodeString($e[ct]);
      var At = Ze - ot % Ze, Tt = [];
      return Tt.length = At, this.update(Tt), this;
    }, Ae.prototype.finalize = function() {
      if (!this.finalized) {
        this.finalized = !0;
        var $e = this.blocks, Ze = this.lastByteIndex, ot = this.blockCount, ct = this.s;
        if ($e[Ze >> 2] |= this.padding[Ze & 3], this.lastByteIndex === this.byteCount)
          for ($e[0] = $e[ot], Ze = 1; Ze < ot + 1; ++Ze)
            $e[Ze] = 0;
        for ($e[ot - 1] |= 2147483648, Ze = 0; Ze < ot; ++Ze)
          ct[Ze] ^= $e[Ze];
        Xe(ct);
      }
    }, Ae.prototype.toString = Ae.prototype.hex = function() {
      this.finalize();
      for (var $e = this.blockCount, Ze = this.s, ot = this.outputBlocks, ct = this.extraBytes, At = 0, Tt = 0, dt = "", vt; Tt < ot; ) {
        for (At = 0; At < $e && Tt < ot; ++At, ++Tt)
          vt = Ze[At], dt += ue[vt >> 4 & 15] + ue[vt & 15] + ue[vt >> 12 & 15] + ue[vt >> 8 & 15] + ue[vt >> 20 & 15] + ue[vt >> 16 & 15] + ue[vt >> 28 & 15] + ue[vt >> 24 & 15];
        Tt % $e === 0 && (Xe(Ze), At = 0);
      }
      return ct && (vt = Ze[At], dt += ue[vt >> 4 & 15] + ue[vt & 15], ct > 1 && (dt += ue[vt >> 12 & 15] + ue[vt >> 8 & 15]), ct > 2 && (dt += ue[vt >> 20 & 15] + ue[vt >> 16 & 15])), dt;
    }, Ae.prototype.arrayBuffer = function() {
      this.finalize();
      var $e = this.blockCount, Ze = this.s, ot = this.outputBlocks, ct = this.extraBytes, At = 0, Tt = 0, dt = this.outputBits >> 3, vt;
      ct ? vt = new ArrayBuffer(ot + 1 << 2) : vt = new ArrayBuffer(dt);
      for (var Ut = new Uint32Array(vt); Tt < ot; ) {
        for (At = 0; At < $e && Tt < ot; ++At, ++Tt)
          Ut[Tt] = Ze[At];
        Tt % $e === 0 && Xe(Ze);
      }
      return ct && (Ut[At] = Ze[At], vt = vt.slice(0, dt)), vt;
    }, Ae.prototype.buffer = Ae.prototype.arrayBuffer, Ae.prototype.digest = Ae.prototype.array = function() {
      this.finalize();
      for (var $e = this.blockCount, Ze = this.s, ot = this.outputBlocks, ct = this.extraBytes, At = 0, Tt = 0, dt = [], vt, Ut; Tt < ot; ) {
        for (At = 0; At < $e && Tt < ot; ++At, ++Tt)
          vt = Tt << 2, Ut = Ze[At], dt[vt] = Ut & 255, dt[vt + 1] = Ut >> 8 & 255, dt[vt + 2] = Ut >> 16 & 255, dt[vt + 3] = Ut >> 24 & 255;
        Tt % $e === 0 && Xe(Ze);
      }
      return ct && (vt = Tt << 2, Ut = Ze[At], dt[vt] = Ut & 255, ct > 1 && (dt[vt + 1] = Ut >> 8 & 255), ct > 2 && (dt[vt + 2] = Ut >> 16 & 255)), dt;
    };
    function Ge($e, Ze, ot) {
      Ae.call(this, $e, Ze, ot);
    }
    Ge.prototype = new Ae(), Ge.prototype.finalize = function() {
      return this.encode(this.outputBits, !0), Ae.prototype.finalize.call(this);
    };
    var Xe = function($e) {
      var Ze, ot, ct, At, Tt, dt, vt, Ut, It, Er, Fr, an, wX, Ct, w_, hX, oX, Nn, SX, sX, nX, Ye, lt, pt, He, Je, st, gt, kt, Vt, Lr, Ci, Qr, xX, lX, rX, FX, BX, cX, MX, EX, yX, jX, AX, vX, PX, kX, qe, Qe, Ve, Ie, nt, Et, xt, Jt, Yt, _r, cn, _X, un, aX, uX, fX;
      for (ct = 0; ct < 48; ct += 2)
        At = $e[0] ^ $e[10] ^ $e[20] ^ $e[30] ^ $e[40], Tt = $e[1] ^ $e[11] ^ $e[21] ^ $e[31] ^ $e[41], dt = $e[2] ^ $e[12] ^ $e[22] ^ $e[32] ^ $e[42], vt = $e[3] ^ $e[13] ^ $e[23] ^ $e[33] ^ $e[43], Ut = $e[4] ^ $e[14] ^ $e[24] ^ $e[34] ^ $e[44], It = $e[5] ^ $e[15] ^ $e[25] ^ $e[35] ^ $e[45], Er = $e[6] ^ $e[16] ^ $e[26] ^ $e[36] ^ $e[46], Fr = $e[7] ^ $e[17] ^ $e[27] ^ $e[37] ^ $e[47], an = $e[8] ^ $e[18] ^ $e[28] ^ $e[38] ^ $e[48], wX = $e[9] ^ $e[19] ^ $e[29] ^ $e[39] ^ $e[49], Ze = an ^ (dt << 1 | vt >>> 31), ot = wX ^ (vt << 1 | dt >>> 31), $e[0] ^= Ze, $e[1] ^= ot, $e[10] ^= Ze, $e[11] ^= ot, $e[20] ^= Ze, $e[21] ^= ot, $e[30] ^= Ze, $e[31] ^= ot, $e[40] ^= Ze, $e[41] ^= ot, Ze = At ^ (Ut << 1 | It >>> 31), ot = Tt ^ (It << 1 | Ut >>> 31), $e[2] ^= Ze, $e[3] ^= ot, $e[12] ^= Ze, $e[13] ^= ot, $e[22] ^= Ze, $e[23] ^= ot, $e[32] ^= Ze, $e[33] ^= ot, $e[42] ^= Ze, $e[43] ^= ot, Ze = dt ^ (Er << 1 | Fr >>> 31), ot = vt ^ (Fr << 1 | Er >>> 31), $e[4] ^= Ze, $e[5] ^= ot, $e[14] ^= Ze, $e[15] ^= ot, $e[24] ^= Ze, $e[25] ^= ot, $e[34] ^= Ze, $e[35] ^= ot, $e[44] ^= Ze, $e[45] ^= ot, Ze = Ut ^ (an << 1 | wX >>> 31), ot = It ^ (wX << 1 | an >>> 31), $e[6] ^= Ze, $e[7] ^= ot, $e[16] ^= Ze, $e[17] ^= ot, $e[26] ^= Ze, $e[27] ^= ot, $e[36] ^= Ze, $e[37] ^= ot, $e[46] ^= Ze, $e[47] ^= ot, Ze = Er ^ (At << 1 | Tt >>> 31), ot = Fr ^ (Tt << 1 | At >>> 31), $e[8] ^= Ze, $e[9] ^= ot, $e[18] ^= Ze, $e[19] ^= ot, $e[28] ^= Ze, $e[29] ^= ot, $e[38] ^= Ze, $e[39] ^= ot, $e[48] ^= Ze, $e[49] ^= ot, Ct = $e[0], w_ = $e[1], PX = $e[11] << 4 | $e[10] >>> 28, kX = $e[10] << 4 | $e[11] >>> 28, gt = $e[20] << 3 | $e[21] >>> 29, kt = $e[21] << 3 | $e[20] >>> 29, un = $e[31] << 9 | $e[30] >>> 23, aX = $e[30] << 9 | $e[31] >>> 23, yX = $e[40] << 18 | $e[41] >>> 14, jX = $e[41] << 18 | $e[40] >>> 14, xX = $e[2] << 1 | $e[3] >>> 31, lX = $e[3] << 1 | $e[2] >>> 31, hX = $e[13] << 12 | $e[12] >>> 20, oX = $e[12] << 12 | $e[13] >>> 20, qe = $e[22] << 10 | $e[23] >>> 22, Qe = $e[23] << 10 | $e[22] >>> 22, Vt = $e[33] << 13 | $e[32] >>> 19, Lr = $e[32] << 13 | $e[33] >>> 19, uX = $e[42] << 2 | $e[43] >>> 30, fX = $e[43] << 2 | $e[42] >>> 30, xt = $e[5] << 30 | $e[4] >>> 2, Jt = $e[4] << 30 | $e[5] >>> 2, rX = $e[14] << 6 | $e[15] >>> 26, FX = $e[15] << 6 | $e[14] >>> 26, Nn = $e[25] << 11 | $e[24] >>> 21, SX = $e[24] << 11 | $e[25] >>> 21, Ve = $e[34] << 15 | $e[35] >>> 17, Ie = $e[35] << 15 | $e[34] >>> 17, Ci = $e[45] << 29 | $e[44] >>> 3, Qr = $e[44] << 29 | $e[45] >>> 3, pt = $e[6] << 28 | $e[7] >>> 4, He = $e[7] << 28 | $e[6] >>> 4, Yt = $e[17] << 23 | $e[16] >>> 9, _r = $e[16] << 23 | $e[17] >>> 9, BX = $e[26] << 25 | $e[27] >>> 7, cX = $e[27] << 25 | $e[26] >>> 7, sX = $e[36] << 21 | $e[37] >>> 11, nX = $e[37] << 21 | $e[36] >>> 11, nt = $e[47] << 24 | $e[46] >>> 8, Et = $e[46] << 24 | $e[47] >>> 8, AX = $e[8] << 27 | $e[9] >>> 5, vX = $e[9] << 27 | $e[8] >>> 5, Je = $e[18] << 20 | $e[19] >>> 12, st = $e[19] << 20 | $e[18] >>> 12, cn = $e[29] << 7 | $e[28] >>> 25, _X = $e[28] << 7 | $e[29] >>> 25, MX = $e[38] << 8 | $e[39] >>> 24, EX = $e[39] << 8 | $e[38] >>> 24, Ye = $e[48] << 14 | $e[49] >>> 18, lt = $e[49] << 14 | $e[48] >>> 18, $e[0] = Ct ^ ~hX & Nn, $e[1] = w_ ^ ~oX & SX, $e[10] = pt ^ ~Je & gt, $e[11] = He ^ ~st & kt, $e[20] = xX ^ ~rX & BX, $e[21] = lX ^ ~FX & cX, $e[30] = AX ^ ~PX & qe, $e[31] = vX ^ ~kX & Qe, $e[40] = xt ^ ~Yt & cn, $e[41] = Jt ^ ~_r & _X, $e[2] = hX ^ ~Nn & sX, $e[3] = oX ^ ~SX & nX, $e[12] = Je ^ ~gt & Vt, $e[13] = st ^ ~kt & Lr, $e[22] = rX ^ ~BX & MX, $e[23] = FX ^ ~cX & EX, $e[32] = PX ^ ~qe & Ve, $e[33] = kX ^ ~Qe & Ie, $e[42] = Yt ^ ~cn & un, $e[43] = _r ^ ~_X & aX, $e[4] = Nn ^ ~sX & Ye, $e[5] = SX ^ ~nX & lt, $e[14] = gt ^ ~Vt & Ci, $e[15] = kt ^ ~Lr & Qr, $e[24] = BX ^ ~MX & yX, $e[25] = cX ^ ~EX & jX, $e[34] = qe ^ ~Ve & nt, $e[35] = Qe ^ ~Ie & Et, $e[44] = cn ^ ~un & uX, $e[45] = _X ^ ~aX & fX, $e[6] = sX ^ ~Ye & Ct, $e[7] = nX ^ ~lt & w_, $e[16] = Vt ^ ~Ci & pt, $e[17] = Lr ^ ~Qr & He, $e[26] = MX ^ ~yX & xX, $e[27] = EX ^ ~jX & lX, $e[36] = Ve ^ ~nt & AX, $e[37] = Ie ^ ~Et & vX, $e[46] = un ^ ~uX & xt, $e[47] = aX ^ ~fX & Jt, $e[8] = Ye ^ ~Ct & hX, $e[9] = lt ^ ~w_ & oX, $e[18] = Ci ^ ~pt & Je, $e[19] = Qr ^ ~He & st, $e[28] = yX ^ ~xX & rX, $e[29] = jX ^ ~lX & FX, $e[38] = nt ^ ~AX & PX, $e[39] = Et ^ ~vX & kX, $e[48] = uX ^ ~xt & Yt, $e[49] = fX ^ ~Jt & _r, $e[0] ^= Ee[ct], $e[1] ^= Ee[ct + 1];
    };
    if (se)
      Y.exports = de;
    else
      for (Te = 0; Te < be.length; ++Te)
        ne[be[Te]] = de[be[Te]];
  })();
})(Z2);
var lT = Z2.exports;
const dT = /* @__PURE__ */ uc(lT);
function gr(Y) {
  return "0x" + dT.keccak_256(Ne(Y));
}
const hT = "rlp/5.7.0", Bi = new ce(hT);
function Qb(Y) {
  const X = [];
  for (; Y; )
    X.unshift(Y & 255), Y >>= 8;
  return X;
}
function ex(Y, X, ee) {
  let te = 0;
  for (let ne = 0; ne < ee; ne++)
    te = te * 256 + Y[X + ne];
  return te;
}
function Q2(Y) {
  if (Array.isArray(Y)) {
    let te = [];
    if (Y.forEach(function(ie) {
      te = te.concat(Q2(ie));
    }), te.length <= 55)
      return te.unshift(192 + te.length), te;
    const ne = Qb(te.length);
    return ne.unshift(247 + ne.length), ne.concat(te);
  }
  Ad(Y) || Bi.throwArgumentError("RLP object must be BytesLike", "object", Y);
  const X = Array.prototype.slice.call(Ne(Y));
  if (X.length === 1 && X[0] <= 127)
    return X;
  if (X.length <= 55)
    return X.unshift(128 + X.length), X;
  const ee = Qb(X.length);
  return ee.unshift(183 + ee.length), ee.concat(X);
}
function Ha(Y) {
  return Oe(Q2(Y));
}
function tx(Y, X, ee, te) {
  const ne = [];
  for (; ee < X + 1 + te; ) {
    const ie = eE(Y, ee);
    ne.push(ie.result), ee += ie.consumed, ee > X + 1 + te && Bi.throwError("child data too short", ce.errors.BUFFER_OVERRUN, {});
  }
  return { consumed: 1 + te, result: ne };
}
function eE(Y, X) {
  if (Y.length === 0 && Bi.throwError("data too short", ce.errors.BUFFER_OVERRUN, {}), Y[X] >= 248) {
    const ee = Y[X] - 247;
    X + 1 + ee > Y.length && Bi.throwError("data short segment too short", ce.errors.BUFFER_OVERRUN, {});
    const te = ex(Y, X + 1, ee);
    return X + 1 + ee + te > Y.length && Bi.throwError("data long segment too short", ce.errors.BUFFER_OVERRUN, {}), tx(Y, X, X + 1 + ee, ee + te);
  } else if (Y[X] >= 192) {
    const ee = Y[X] - 192;
    return X + 1 + ee > Y.length && Bi.throwError("data array too short", ce.errors.BUFFER_OVERRUN, {}), tx(Y, X, X + 1, ee);
  } else if (Y[X] >= 184) {
    const ee = Y[X] - 183;
    X + 1 + ee > Y.length && Bi.throwError("data array too short", ce.errors.BUFFER_OVERRUN, {});
    const te = ex(Y, X + 1, ee);
    X + 1 + ee + te > Y.length && Bi.throwError("data array too short", ce.errors.BUFFER_OVERRUN, {});
    const ne = Oe(Y.slice(X + 1 + ee, X + 1 + ee + te));
    return { consumed: 1 + ee + te, result: ne };
  } else if (Y[X] >= 128) {
    const ee = Y[X] - 128;
    X + 1 + ee > Y.length && Bi.throwError("data too short", ce.errors.BUFFER_OVERRUN, {});
    const te = Oe(Y.slice(X + 1, X + 1 + ee));
    return { consumed: 1 + ee, result: te };
  }
  return { consumed: 1, result: Oe(Y[X]) };
}
function um(Y) {
  const X = Ne(Y), ee = eE(X, 0);
  return ee.consumed !== X.length && Bi.throwArgumentError("invalid rlp data", "data", Y), ee.result;
}
const pT = "address/5.7.0", ga = new ce(pT);
function rx(Y) {
  Bt(Y, 20) || ga.throwArgumentError("invalid address", "address", Y), Y = Y.toLowerCase();
  const X = Y.substring(2).split(""), ee = new Uint8Array(40);
  for (let ne = 0; ne < 40; ne++)
    ee[ne] = X[ne].charCodeAt(0);
  const te = Ne(gr(ee));
  for (let ne = 0; ne < 40; ne += 2)
    te[ne >> 1] >> 4 >= 8 && (X[ne] = X[ne].toUpperCase()), (te[ne >> 1] & 15) >= 8 && (X[ne + 1] = X[ne + 1].toUpperCase());
  return "0x" + X.join("");
}
const gT = 9007199254740991;
function mT(Y) {
  return Math.log10 ? Math.log10(Y) : Math.log(Y) / Math.LN10;
}
const fm = {};
for (let Y = 0; Y < 10; Y++)
  fm[String(Y)] = String(Y);
for (let Y = 0; Y < 26; Y++)
  fm[String.fromCharCode(65 + Y)] = String(10 + Y);
const nx = Math.floor(mT(gT));
function yT(Y) {
  Y = Y.toUpperCase(), Y = Y.substring(4) + Y.substring(0, 2) + "00";
  let X = Y.split("").map((te) => fm[te]).join("");
  for (; X.length >= nx; ) {
    let te = X.substring(0, nx);
    X = parseInt(te, 10) % 97 + X.substring(te.length);
  }
  let ee = String(98 - parseInt(X, 10) % 97);
  for (; ee.length < 2; )
    ee = "0" + ee;
  return ee;
}
function pr(Y) {
  let X = null;
  if (typeof Y != "string" && ga.throwArgumentError("invalid address", "address", Y), Y.match(/^(0x)?[0-9a-fA-F]{40}$/))
    Y.substring(0, 2) !== "0x" && (Y = "0x" + Y), X = rx(Y), Y.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && X !== Y && ga.throwArgumentError("bad address checksum", "address", Y);
  else if (Y.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
    for (Y.substring(2, 4) !== yT(Y) && ga.throwArgumentError("bad icap checksum", "address", Y), X = Q4(Y.substring(4)); X.length < 40; )
      X = "0" + X;
    X = rx("0x" + X);
  } else
    ga.throwArgumentError("invalid address", "address", Y);
  return X;
}
function bT(Y) {
  try {
    return pr(Y), !0;
  } catch {
  }
  return !1;
}
function tE(Y) {
  let X = null;
  try {
    X = pr(Y.from);
  } catch {
    ga.throwArgumentError("missing from address", "transaction", Y);
  }
  const ee = _s(Ne(Be.from(Y.nonce).toHexString()));
  return pr(Dr(gr(Ha([X, ee])), 12));
}
class xT extends Ms {
  constructor(X) {
    super("address", "address", X, !1);
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000";
  }
  encode(X, ee) {
    try {
      ee = pr(ee);
    } catch (te) {
      this._throwError(te.message, ee);
    }
    return X.writeValue(ee);
  }
  decode(X) {
    return pr(hr$1(X.readValue().toHexString(), 20));
  }
}
class wT extends Ms {
  constructor(X) {
    super(X.name, X.type, void 0, X.dynamic), this.coder = X;
  }
  defaultValue() {
    return this.coder.defaultValue();
  }
  encode(X, ee) {
    return this.coder.encode(X, ee);
  }
  decode(X) {
    return this.coder.decode(X);
  }
}
const ma = new ce(af);
function rE(Y, X, ee) {
  let te = null;
  if (Array.isArray(ee))
    te = ee;
  else if (ee && typeof ee == "object") {
    let ae = {};
    te = X.map((ue) => {
      const le = ue.localName;
      return le || ma.throwError("cannot encode object for signature with missing names", ce.errors.INVALID_ARGUMENT, {
        argument: "values",
        coder: ue,
        value: ee
      }), ae[le] && ma.throwError("cannot encode object for signature with duplicate names", ce.errors.INVALID_ARGUMENT, {
        argument: "values",
        coder: ue,
        value: ee
      }), ae[le] = !0, ee[le];
    });
  } else
    ma.throwArgumentError("invalid tuple value", "tuple", ee);
  X.length !== te.length && ma.throwArgumentError("types/value length mismatch", "tuple", ee);
  let ne = new Lp(Y.wordSize), ie = new Lp(Y.wordSize), oe = [];
  X.forEach((ae, ue) => {
    let le = te[ue];
    if (ae.dynamic) {
      let he = ie.length;
      ae.encode(ie, le);
      let me = ne.writeUpdatableValue();
      oe.push((ye) => {
        me(ye + he);
      });
    } else
      ae.encode(ne, le);
  }), oe.forEach((ae) => {
    ae(ne.length);
  });
  let se = Y.appendWriter(ne);
  return se += Y.appendWriter(ie), se;
}
function nE(Y, X) {
  let ee = [], te = Y.subReader(0);
  X.forEach((ie) => {
    let oe = null;
    if (ie.dynamic) {
      let se = Y.readValue(), ae = te.subReader(se.toNumber());
      try {
        oe = ie.decode(ae);
      } catch (ue) {
        if (ue.code === ce.errors.BUFFER_OVERRUN)
          throw ue;
        oe = ue, oe.baseType = ie.name, oe.name = ie.localName, oe.type = ie.type;
      }
    } else
      try {
        oe = ie.decode(Y);
      } catch (se) {
        if (se.code === ce.errors.BUFFER_OVERRUN)
          throw se;
        oe = se, oe.baseType = ie.name, oe.name = ie.localName, oe.type = ie.type;
      }
    oe != null && ee.push(oe);
  });
  const ne = X.reduce((ie, oe) => {
    const se = oe.localName;
    return se && (ie[se] || (ie[se] = 0), ie[se]++), ie;
  }, {});
  X.forEach((ie, oe) => {
    let se = ie.localName;
    if (!se || ne[se] !== 1 || (se === "length" && (se = "_length"), ee[se] != null))
      return;
    const ae = ee[oe];
    ae instanceof Error ? Object.defineProperty(ee, se, {
      enumerable: !0,
      get: () => {
        throw ae;
      }
    }) : ee[se] = ae;
  });
  for (let ie = 0; ie < ee.length; ie++) {
    const oe = ee[ie];
    oe instanceof Error && Object.defineProperty(ee, ie, {
      enumerable: !0,
      get: () => {
        throw oe;
      }
    });
  }
  return Object.freeze(ee);
}
class vT extends Ms {
  constructor(X, ee, te) {
    const ne = X.type + "[" + (ee >= 0 ? ee : "") + "]", ie = ee === -1 || X.dynamic;
    super("array", ne, te, ie), this.coder = X, this.length = ee;
  }
  defaultValue() {
    const X = this.coder.defaultValue(), ee = [];
    for (let te = 0; te < this.length; te++)
      ee.push(X);
    return ee;
  }
  encode(X, ee) {
    Array.isArray(ee) || this._throwError("expected array value", ee);
    let te = this.length;
    te === -1 && (te = ee.length, X.writeValue(ee.length)), ma.checkArgumentCount(ee.length, te, "coder array" + (this.localName ? " " + this.localName : ""));
    let ne = [];
    for (let ie = 0; ie < ee.length; ie++)
      ne.push(this.coder);
    return rE(X, ne, ee);
  }
  decode(X) {
    let ee = this.length;
    ee === -1 && (ee = X.readValue().toNumber(), ee * 32 > X._data.length && ma.throwError("insufficient data length", ce.errors.BUFFER_OVERRUN, {
      length: X._data.length,
      count: ee
    }));
    let te = [];
    for (let ne = 0; ne < ee; ne++)
      te.push(new wT(this.coder));
    return X.coerce(this.name, nE(X, te));
  }
}
class ET extends Ms {
  constructor(X) {
    super("bool", "bool", X, !1);
  }
  defaultValue() {
    return !1;
  }
  encode(X, ee) {
    return X.writeValue(ee ? 1 : 0);
  }
  decode(X) {
    return X.coerce(this.type, !X.readValue().isZero());
  }
}
class iE extends Ms {
  constructor(X, ee) {
    super(X, X, ee, !0);
  }
  defaultValue() {
    return "0x";
  }
  encode(X, ee) {
    ee = Ne(ee);
    let te = X.writeValue(ee.length);
    return te += X.writeBytes(ee), te;
  }
  decode(X) {
    return X.readBytes(X.readValue().toNumber(), !0);
  }
}
class _T extends iE {
  constructor(X) {
    super("bytes", X);
  }
  decode(X) {
    return X.coerce(this.name, Oe(super.decode(X)));
  }
}
class AT extends Ms {
  constructor(X, ee) {
    let te = "bytes" + String(X);
    super(te, te, ee, !1), this.size = X;
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(0, 2 + this.size * 2);
  }
  encode(X, ee) {
    let te = Ne(ee);
    return te.length !== this.size && this._throwError("incorrect data length", ee), X.writeBytes(te);
  }
  decode(X) {
    return X.coerce(this.name, Oe(X.readBytes(this.size)));
  }
}
class ST extends Ms {
  constructor(X) {
    super("null", "", X, !1);
  }
  defaultValue() {
    return null;
  }
  encode(X, ee) {
    return ee != null && this._throwError("not null", ee), X.writeBytes([]);
  }
  decode(X) {
    return X.readBytes(0), X.coerce(this.name, null);
  }
}
const TT = "0x0000000000000000000000000000000000000000", IT = /* @__PURE__ */ Be.from(-1), sE = /* @__PURE__ */ Be.from(0), RT = /* @__PURE__ */ Be.from(1), CT = /* @__PURE__ */ Be.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"), PT = "0x0000000000000000000000000000000000000000000000000000000000000000";
class OT extends Ms {
  constructor(X, ee, te) {
    const ne = (ee ? "int" : "uint") + X * 8;
    super(ne, ne, te, !1), this.size = X, this.signed = ee;
  }
  defaultValue() {
    return 0;
  }
  encode(X, ee) {
    let te = Be.from(ee), ne = CT.mask(X.wordSize * 8);
    if (this.signed) {
      let ie = ne.mask(this.size * 8 - 1);
      (te.gt(ie) || te.lt(ie.add(RT).mul(IT))) && this._throwError("value out-of-bounds", ee);
    } else
      (te.lt(sE) || te.gt(ne.mask(this.size * 8))) && this._throwError("value out-of-bounds", ee);
    return te = te.toTwos(this.size * 8).mask(this.size * 8), this.signed && (te = te.fromTwos(this.size * 8).toTwos(8 * X.wordSize)), X.writeValue(te);
  }
  decode(X) {
    let ee = X.readValue().mask(this.size * 8);
    return this.signed && (ee = ee.fromTwos(this.size * 8)), X.coerce(this.name, ee);
  }
}
const BT = "strings/5.7.0", oE = new ce(BT);
var oo;
(function(Y) {
  Y.current = "", Y.NFC = "NFC", Y.NFD = "NFD", Y.NFKC = "NFKC", Y.NFKD = "NFKD";
})(oo || (oo = {}));
var Mn;
(function(Y) {
  Y.UNEXPECTED_CONTINUE = "unexpected continuation byte", Y.BAD_PREFIX = "bad codepoint prefix", Y.OVERRUN = "string overrun", Y.MISSING_CONTINUE = "missing continuation byte", Y.OUT_OF_RANGE = "out of UTF-8 range", Y.UTF16_SURROGATE = "UTF-16 surrogate", Y.OVERLONG = "overlong representation";
})(Mn || (Mn = {}));
function NT(Y, X, ee, te, ne) {
  return oE.throwArgumentError(`invalid codepoint at offset ${X}; ${Y}`, "bytes", ee);
}
function aE(Y, X, ee, te, ne) {
  if (Y === Mn.BAD_PREFIX || Y === Mn.UNEXPECTED_CONTINUE) {
    let ie = 0;
    for (let oe = X + 1; oe < ee.length && ee[oe] >> 6 === 2; oe++)
      ie++;
    return ie;
  }
  return Y === Mn.OVERRUN ? ee.length - X - 1 : 0;
}
function kT(Y, X, ee, te, ne) {
  return Y === Mn.OVERLONG ? (te.push(ne), 0) : (te.push(65533), aE(Y, X, ee));
}
const MT = Object.freeze({
  error: NT,
  ignore: aE,
  replace: kT
});
function cE(Y, X) {
  X == null && (X = MT.error), Y = Ne(Y);
  const ee = [];
  let te = 0;
  for (; te < Y.length; ) {
    const ne = Y[te++];
    if (!(ne >> 7)) {
      ee.push(ne);
      continue;
    }
    let ie = null, oe = null;
    if ((ne & 224) === 192)
      ie = 1, oe = 127;
    else if ((ne & 240) === 224)
      ie = 2, oe = 2047;
    else if ((ne & 248) === 240)
      ie = 3, oe = 65535;
    else {
      (ne & 192) === 128 ? te += X(Mn.UNEXPECTED_CONTINUE, te - 1, Y, ee) : te += X(Mn.BAD_PREFIX, te - 1, Y, ee);
      continue;
    }
    if (te - 1 + ie >= Y.length) {
      te += X(Mn.OVERRUN, te - 1, Y, ee);
      continue;
    }
    let se = ne & (1 << 8 - ie - 1) - 1;
    for (let ae = 0; ae < ie; ae++) {
      let ue = Y[te];
      if ((ue & 192) != 128) {
        te += X(Mn.MISSING_CONTINUE, te, Y, ee), se = null;
        break;
      }
      se = se << 6 | ue & 63, te++;
    }
    if (se !== null) {
      if (se > 1114111) {
        te += X(Mn.OUT_OF_RANGE, te - 1 - ie, Y, ee, se);
        continue;
      }
      if (se >= 55296 && se <= 57343) {
        te += X(Mn.UTF16_SURROGATE, te - 1 - ie, Y, ee, se);
        continue;
      }
      if (se <= oe) {
        te += X(Mn.OVERLONG, te - 1 - ie, Y, ee, se);
        continue;
      }
      ee.push(se);
    }
  }
  return ee;
}
function Xr(Y, X = oo.current) {
  X != oo.current && (oE.checkNormalize(), Y = Y.normalize(X));
  let ee = [];
  for (let te = 0; te < Y.length; te++) {
    const ne = Y.charCodeAt(te);
    if (ne < 128)
      ee.push(ne);
    else if (ne < 2048)
      ee.push(ne >> 6 | 192), ee.push(ne & 63 | 128);
    else if ((ne & 64512) == 55296) {
      te++;
      const ie = Y.charCodeAt(te);
      if (te >= Y.length || (ie & 64512) !== 56320)
        throw new Error("invalid utf-8 string");
      const oe = 65536 + ((ne & 1023) << 10) + (ie & 1023);
      ee.push(oe >> 18 | 240), ee.push(oe >> 12 & 63 | 128), ee.push(oe >> 6 & 63 | 128), ee.push(oe & 63 | 128);
    } else
      ee.push(ne >> 12 | 224), ee.push(ne >> 6 & 63 | 128), ee.push(ne & 63 | 128);
  }
  return Ne(ee);
}
function LT(Y) {
  return Y.map((X) => X <= 65535 ? String.fromCharCode(X) : (X -= 65536, String.fromCharCode((X >> 10 & 1023) + 55296, (X & 1023) + 56320))).join("");
}
function cf(Y, X) {
  return LT(cE(Y, X));
}
function FT(Y, X = oo.current) {
  return cE(Xr(Y, X));
}
class $T extends iE {
  constructor(X) {
    super("string", X);
  }
  defaultValue() {
    return "";
  }
  encode(X, ee) {
    return super.encode(X, Xr(ee));
  }
  decode(X) {
    return cf(super.decode(X));
  }
}
class $f extends Ms {
  constructor(X, ee) {
    let te = !1;
    const ne = [];
    X.forEach((oe) => {
      oe.dynamic && (te = !0), ne.push(oe.type);
    });
    const ie = "tuple(" + ne.join(",") + ")";
    super("tuple", ie, ee, te), this.coders = X;
  }
  defaultValue() {
    const X = [];
    this.coders.forEach((te) => {
      X.push(te.defaultValue());
    });
    const ee = this.coders.reduce((te, ne) => {
      const ie = ne.localName;
      return ie && (te[ie] || (te[ie] = 0), te[ie]++), te;
    }, {});
    return this.coders.forEach((te, ne) => {
      let ie = te.localName;
      !ie || ee[ie] !== 1 || (ie === "length" && (ie = "_length"), X[ie] == null && (X[ie] = X[ne]));
    }), Object.freeze(X);
  }
  encode(X, ee) {
    return rE(X, this.coders, ee);
  }
  decode(X) {
    return X.coerce(this.name, nE(X, this.coders));
  }
}
const Df = new ce(af), DT = new RegExp(/^bytes([0-9]*)$/), UT = new RegExp(/^(u?int)([0-9]*)$/);
class jT {
  constructor(X) {
    ve(this, "coerceFunc", X || null);
  }
  _getCoder(X) {
    switch (X.baseType) {
      case "address":
        return new xT(X.name);
      case "bool":
        return new ET(X.name);
      case "string":
        return new $T(X.name);
      case "bytes":
        return new _T(X.name);
      case "array":
        return new vT(this._getCoder(X.arrayChildren), X.arrayLength, X.name);
      case "tuple":
        return new $f((X.components || []).map((te) => this._getCoder(te)), X.name);
      case "":
        return new ST(X.name);
    }
    let ee = X.type.match(UT);
    if (ee) {
      let te = parseInt(ee[2] || "256");
      return (te === 0 || te > 256 || te % 8 !== 0) && Df.throwArgumentError("invalid " + ee[1] + " bit length", "param", X), new OT(te / 8, ee[1] === "int", X.name);
    }
    if (ee = X.type.match(DT), ee) {
      let te = parseInt(ee[1]);
      return (te === 0 || te > 32) && Df.throwArgumentError("invalid bytes length", "param", X), new AT(te, X.name);
    }
    return Df.throwArgumentError("invalid type", "type", X.type);
  }
  _getWordSize() {
    return 32;
  }
  _getReader(X, ee) {
    return new kl(X, this._getWordSize(), this.coerceFunc, ee);
  }
  _getWriter() {
    return new Lp(this._getWordSize());
  }
  getDefaultValue(X) {
    const ee = X.map((te) => this._getCoder(Vr.from(te)));
    return new $f(ee, "_").defaultValue();
  }
  encode(X, ee) {
    X.length !== ee.length && Df.throwError("types/values length mismatch", ce.errors.INVALID_ARGUMENT, {
      count: { types: X.length, values: ee.length },
      value: { types: X, values: ee }
    });
    const te = X.map((oe) => this._getCoder(Vr.from(oe))), ne = new $f(te, "_"), ie = this._getWriter();
    return ne.encode(ie, ee), ie.data;
  }
  decode(X, ee, te) {
    const ne = X.map((ie) => this._getCoder(Vr.from(ie)));
    return new $f(ne, "_").decode(this._getReader(Ne(ee), te));
  }
}
const HT = new jT();
function Ao(Y) {
  return gr(Xr(Y));
}
const uE = "hash/5.7.0";
function fE(Y) {
  Y = atob(Y);
  const X = [];
  for (let ee = 0; ee < Y.length; ee++)
    X.push(Y.charCodeAt(ee));
  return Ne(X);
}
function lE(Y) {
  Y = Ne(Y);
  let X = "";
  for (let ee = 0; ee < Y.length; ee++)
    X += String.fromCharCode(Y[ee]);
  return btoa(X);
}
function dE(Y, X) {
  X == null && (X = 1);
  const ee = [], te = ee.forEach, ne = function(ie, oe) {
    te.call(ie, function(se) {
      oe > 0 && Array.isArray(se) ? ne(se, oe - 1) : ee.push(se);
    });
  };
  return ne(Y, X), ee;
}
function zT(Y) {
  const X = {};
  for (let ee = 0; ee < Y.length; ee++) {
    const te = Y[ee];
    X[te[0]] = te[1];
  }
  return X;
}
function qT(Y) {
  let X = 0;
  function ee() {
    return Y[X++] << 8 | Y[X++];
  }
  let te = ee(), ne = 1, ie = [0, 1];
  for (let Ke = 1; Ke < te; Ke++)
    ie.push(ne += ee());
  let oe = ee(), se = X;
  X += oe;
  let ae = 0, ue = 0;
  function le() {
    return ae == 0 && (ue = ue << 8 | Y[X++], ae = 8), ue >> --ae & 1;
  }
  const he = 31, me = Math.pow(2, he), ye = me >>> 1, we = ye >> 1, Ee = me - 1;
  let Re = 0;
  for (let Ke = 0; Ke < he; Ke++)
    Re = Re << 1 | le();
  let Ue = [], Me = 0, De = me;
  for (; ; ) {
    let Ke = Math.floor(((Re - Me + 1) * ne - 1) / De), tt = 0, rt = te;
    for (; rt - tt > 1; ) {
      let Dt = tt + rt >>> 1;
      Ke < ie[Dt] ? rt = Dt : tt = Dt;
    }
    if (tt == 0)
      break;
    Ue.push(tt);
    let it = Me + Math.floor(De * ie[tt] / ne), _t = Me + Math.floor(De * ie[tt + 1] / ne) - 1;
    for (; !((it ^ _t) & ye); )
      Re = Re << 1 & Ee | le(), it = it << 1 & Ee, _t = _t << 1 & Ee | 1;
    for (; it & ~_t & we; )
      Re = Re & ye | Re << 1 & Ee >>> 1 | le(), it = it << 1 ^ ye, _t = (_t ^ ye) << 1 | ye | 1;
    Me = it, De = 1 + _t - it;
  }
  let Fe = te - 4;
  return Ue.map((Ke) => {
    switch (Ke - Fe) {
      case 3:
        return Fe + 65792 + (Y[se++] << 16 | Y[se++] << 8 | Y[se++]);
      case 2:
        return Fe + 256 + (Y[se++] << 8 | Y[se++]);
      case 1:
        return Fe + Y[se++];
      default:
        return Ke - 1;
    }
  });
}
function GT(Y) {
  let X = 0;
  return () => Y[X++];
}
function VT(Y) {
  return GT(qT(Y));
}
function WT$1(Y) {
  return Y & 1 ? ~Y >> 1 : Y >> 1;
}
function KT(Y, X) {
  let ee = Array(Y);
  for (let te = 0; te < Y; te++)
    ee[te] = 1 + X();
  return ee;
}
function ix(Y, X) {
  let ee = Array(Y);
  for (let te = 0, ne = -1; te < Y; te++)
    ee[te] = ne += 1 + X();
  return ee;
}
function JT(Y, X) {
  let ee = Array(Y);
  for (let te = 0, ne = 0; te < Y; te++)
    ee[te] = ne += WT$1(X());
  return ee;
}
function Ml(Y, X) {
  let ee = ix(Y(), Y), te = Y(), ne = ix(te, Y), ie = KT(te, Y);
  for (let oe = 0; oe < te; oe++)
    for (let se = 0; se < ie[oe]; se++)
      ee.push(ne[oe] + se);
  return X ? ee.map((oe) => X[oe]) : ee;
}
function YT(Y) {
  let X = [];
  for (; ; ) {
    let ee = Y();
    if (ee == 0)
      break;
    X.push(ZT(ee, Y));
  }
  for (; ; ) {
    let ee = Y() - 1;
    if (ee < 0)
      break;
    X.push(QT(ee, Y));
  }
  return zT(dE(X));
}
function XT(Y) {
  let X = [];
  for (; ; ) {
    let ee = Y();
    if (ee == 0)
      break;
    X.push(ee);
  }
  return X;
}
function hE(Y, X, ee) {
  let te = Array(Y).fill(void 0).map(() => []);
  for (let ne = 0; ne < X; ne++)
    JT(Y, ee).forEach((ie, oe) => te[oe].push(ie));
  return te;
}
function ZT(Y, X) {
  let ee = 1 + X(), te = X(), ne = XT(X), ie = hE(ne.length, 1 + Y, X);
  return dE(ie.map((oe, se) => {
    const ae = oe[0], ue = oe.slice(1);
    return Array(ne[se]).fill(void 0).map((le, he) => {
      let me = he * te;
      return [ae + he * ee, ue.map((ye) => ye + me)];
    });
  }));
}
function QT(Y, X) {
  let ee = 1 + X();
  return hE(ee, 1 + Y, X).map((te) => [te[0], te.slice(1)]);
}
function eI(Y) {
  let X = Ml(Y).sort((te, ne) => te - ne);
  return ee();
  function ee() {
    let te = [];
    for (; ; ) {
      let ue = Ml(Y, X);
      if (ue.length == 0)
        break;
      te.push({ set: new Set(ue), node: ee() });
    }
    te.sort((ue, le) => le.set.size - ue.set.size);
    let ne = Y(), ie = ne % 3;
    ne = ne / 3 | 0;
    let oe = !!(ne & 1);
    ne >>= 1;
    let se = ne == 1, ae = ne == 2;
    return { branches: te, valid: ie, fe0f: oe, save: se, check: ae };
  }
}
function tI() {
  return VT(fE("AEQF2AO2DEsA2wIrAGsBRABxAN8AZwCcAEwAqgA0AGwAUgByADcATAAVAFYAIQAyACEAKAAYAFgAGwAjABQAMAAmADIAFAAfABQAKwATACoADgAbAA8AHQAYABoAGQAxADgALAAoADwAEwA9ABMAGgARAA4ADwAWABMAFgAIAA8AHgQXBYMA5BHJAS8JtAYoAe4AExozi0UAH21tAaMnBT8CrnIyhrMDhRgDygIBUAEHcoFHUPe8AXBjAewCjgDQR8IICIcEcQLwATXCDgzvHwBmBoHNAqsBdBcUAykgDhAMShskMgo8AY8jqAQfAUAfHw8BDw87MioGlCIPBwZCa4ELatMAAMspJVgsDl8AIhckSg8XAHdvTwBcIQEiDT4OPhUqbyECAEoAS34Aej8Ybx83JgT/Xw8gHxZ/7w8RICxPHA9vBw+Pfw8PHwAPFv+fAsAvCc8vEr8ivwD/EQ8Bol8OEBa/A78hrwAPCU8vESNvvwWfHwNfAVoDHr+ZAAED34YaAdJPAK7PLwSEgDLHAGo1Pz8Pvx9fUwMrpb8O/58VTzAPIBoXIyQJNF8hpwIVAT8YGAUADDNBaX3RAMomJCg9EhUeA29MABsZBTMNJipjOhc19gcIDR8bBwQHEggCWi6DIgLuAQYA+BAFCha3A5XiAEsqM7UFFgFLhAMjFTMYE1Klnw74nRVBG/ASCm0BYRN/BrsU3VoWy+S0vV8LQx+vN8gF2AC2AK5EAWwApgYDKmAAroQ0NDQ0AT+OCg7wAAIHRAbpNgVcBV0APTA5BfbPFgMLzcYL/QqqA82eBALKCjQCjqYCht0/k2+OAsXQAoP3ASTKDgDw6ACKAUYCMpIKJpRaAE4A5womABzZvs0REEKiACIQAd5QdAECAj4Ywg/wGqY2AVgAYADYvAoCGAEubA0gvAY2ALAAbpbvqpyEAGAEpgQAJgAG7gAgAEACmghUFwCqAMpAINQIwC4DthRAAPcycKgApoIdABwBfCisABoATwBqASIAvhnSBP8aH/ECeAKXAq40NjgDBTwFYQU6AXs3oABgAD4XNgmcCY1eCl5tIFZeUqGgyoNHABgAEQAaABNwWQAmABMATPMa3T34ADldyprmM1M2XociUQgLzvwAXT3xABgAEQAaABNwIGFAnADD8AAgAD4BBJWzaCcIAIEBFMAWwKoAAdq9BWAF5wLQpALEtQAKUSGkahR4GnJM+gsAwCgeFAiUAECQ0BQuL8AAIAAAADKeIheclvFqQAAETr4iAMxIARMgAMIoHhQIAn0E0pDQFC4HhznoAAAAIAI2C0/4lvFqQAAETgBJJwYCAy4ABgYAFAA8MBKYEH4eRhTkAjYeFcgACAYAeABsOqyQ5gRwDayqugEgaIIAtgoACgDmEABmBAWGme5OBJJA2m4cDeoAmITWAXwrMgOgAGwBCh6CBXYF1Tzg1wKAAFdiuABRAFwAXQBsAG8AdgBrAHYAbwCEAHEwfxQBVE5TEQADVFhTBwBDANILAqcCzgLTApQCrQL6vAAMAL8APLhNBKkE6glGKTAU4Dr4N2EYEwBCkABKk8rHAbYBmwIoAiU4Ajf/Aq4CowCAANIChzgaNBsCsTgeODcFXrgClQKdAqQBiQGYAqsCsjTsNHsfNPA0ixsAWTWiOAMFPDQSNCk2BDZHNow2TTZUNhk28Jk9VzI3QkEoAoICoQKwAqcAQAAxBV4FXbS9BW47YkIXP1ciUqs05DS/FwABUwJW11e6nHuYZmSh/RAYA8oMKvZ8KASoUAJYWAJ6ILAsAZSoqjpgA0ocBIhmDgDWAAawRDQoAAcuAj5iAHABZiR2AIgiHgCaAU68ACxuHAG0ygM8MiZIAlgBdF4GagJqAPZOHAMuBgoATkYAsABiAHgAMLoGDPj0HpKEBAAOJgAuALggTAHWAeAMEDbd20Uege0ADwAWADkAQgA9OHd+2MUQZBBhBgNNDkxxPxUQArEPqwvqERoM1irQ090ANK4H8ANYB/ADWANYB/AH8ANYB/ADWANYA1gDWBwP8B/YxRBkD00EcgWTBZAE2wiIJk4RhgctCNdUEnQjHEwDSgEBIypJITuYMxAlR0wRTQgIATZHbKx9PQNMMbBU+pCnA9AyVDlxBgMedhKlAC8PeCE1uk6DekxxpQpQT7NX9wBFBgASqwAS5gBJDSgAUCwGPQBI4zTYABNGAE2bAE3KAExdGABKaAbgAFBXAFCOAFBJABI2SWdObALDOq0//QomCZhvwHdTBkIQHCemEPgMNAG2ATwN7kvZBPIGPATKH34ZGg/OlZ0Ipi3eDO4m5C6igFsj9iqEBe5L9TzeC05RaQ9aC2YJ5DpkgU8DIgEOIowK3g06CG4Q9ArKbA3mEUYHOgPWSZsApgcCCxIdNhW2JhFirQsKOXgG/Br3C5AmsBMqev0F1BoiBk4BKhsAANAu6IWxWjJcHU9gBgQLJiPIFKlQIQ0mQLh4SRocBxYlqgKSQ3FKiFE3HpQh9zw+DWcuFFF9B/Y8BhlQC4I8n0asRQ8R0z6OPUkiSkwtBDaALDAnjAnQD4YMunxzAVoJIgmyDHITMhEYN8YIOgcaLpclJxYIIkaWYJsE+KAD9BPSAwwFQAlCBxQDthwuEy8VKgUOgSXYAvQ21i60ApBWgQEYBcwPJh/gEFFH4Q7qCJwCZgOEJewALhUiABginAhEZABgj9lTBi7MCMhqbSN1A2gU6GIRdAeSDlgHqBw0FcAc4nDJXgyGCSiksAlcAXYJmgFgBOQICjVcjKEgQmdUi1kYnCBiQUBd/QIyDGYVoES+h3kCjA9sEhwBNgF0BzoNAgJ4Ee4RbBCWCOyGBTW2M/k6JgRQIYQgEgooA1BszwsoJvoM+WoBpBJjAw00PnfvZ6xgtyUX/gcaMsZBYSHyC5NPzgydGsIYQ1QvGeUHwAP0GvQn60FYBgADpAQUOk4z7wS+C2oIjAlAAEoOpBgH2BhrCnKM0QEyjAG4mgNYkoQCcJAGOAcMAGgMiAV65gAeAqgIpAAGANADWAA6Aq4HngAaAIZCAT4DKDABIuYCkAOUCDLMAZYwAfQqBBzEDBYA+DhuSwLDsgKAa2ajBd5ZAo8CSjYBTiYEBk9IUgOwcuIA3ABMBhTgSAEWrEvMG+REAeBwLADIAPwABjYHBkIBzgH0bgC4AWALMgmjtLYBTuoqAIQAFmwB2AKKAN4ANgCA8gFUAE4FWvoF1AJQSgESMhksWGIBvAMgATQBDgB6BsyOpsoIIARuB9QCEBwV4gLvLwe2AgMi4BPOQsYCvd9WADIXUu5eZwqoCqdeaAC0YTQHMnM9UQAPH6k+yAdy/BZIiQImSwBQ5gBQQzSaNTFWSTYBpwGqKQK38AFtqwBI/wK37gK3rQK3sAK6280C0gK33AK3zxAAUEIAUD9SklKDArekArw5AEQAzAHCO147WTteO1k7XjtZO147WTteO1kDmChYI03AVU0oJqkKbV9GYewMpw3VRMk6ShPcYFJgMxPJLbgUwhXPJVcZPhq9JwYl5VUKDwUt1GYxCC00dhe9AEApaYNCY4ceMQpMHOhTklT5LRwAskujM7ANrRsWREEFSHXuYisWDwojAmSCAmJDXE6wXDchAqH4AmiZAmYKAp+FOBwMAmY8AmYnBG8EgAN/FAN+kzkHOXgYOYM6JCQCbB4CMjc4CwJtyAJtr/CLADRoRiwBaADfAOIASwYHmQyOAP8MwwAOtgJ3MAJ2o0ACeUxEAni7Hl3cRa9G9AJ8QAJ6yQJ9CgJ88UgBSH5kJQAsFklZSlwWGErNAtECAtDNSygDiFADh+dExpEzAvKiXQQDA69Lz0wuJgTQTU1NsAKLQAKK2cIcCB5EaAa4Ao44Ao5dQZiCAo7aAo5deVG1UzYLUtVUhgKT/AKTDQDqAB1VH1WwVdEHLBwplocy4nhnRTw6ApegAu+zWCKpAFomApaQApZ9nQCqWa1aCoJOADwClrYClk9cRVzSApnMApllXMtdCBoCnJw5wzqeApwXAp+cAp65iwAeEDIrEAKd8gKekwC2PmE1YfACntQCoG8BqgKeoCACnk+mY8lkKCYsAiewAiZ/AqD8AqBN2AKmMAKlzwKoAAB+AqfzaH1osgAESmodatICrOQCrK8CrWgCrQMCVx4CVd0CseLYAx9PbJgCsr4OArLpGGzhbWRtSWADJc4Ctl08QG6RAylGArhfArlIFgK5K3hwN3DiAr0aAy2zAzISAr6JcgMDM3ICvhtzI3NQAsPMAsMFc4N0TDZGdOEDPKgDPJsDPcACxX0CxkgCxhGKAshqUgLIRQLJUALJLwJkngLd03h6YniveSZL0QMYpGcDAmH1GfSVJXsMXpNevBICz2wCz20wTFTT9BSgAMeuAs90ASrrA04TfkwGAtwoAtuLAtJQA1JdA1NgAQIDVY2AikABzBfuYUZ2AILPg44C2sgC2d+EEYRKpz0DhqYAMANkD4ZyWvoAVgLfZgLeuXR4AuIw7RUB8zEoAfScAfLTiALr9ALpcXoAAur6AurlAPpIAboC7ooC652Wq5cEAu5AA4XhmHpw4XGiAvMEAGoDjheZlAL3FAORbwOSiAL3mQL52gL4Z5odmqy8OJsfA52EAv77ARwAOp8dn7QDBY4DpmsDptoA0sYDBmuhiaIGCgMMSgFgASACtgNGAJwEgLpoBgC8BGzAEowcggCEDC6kdjoAJAM0C5IKRoABZCgiAIzw3AYBLACkfng9ogigkgNmWAN6AEQCvrkEVqTGAwCsBRbAA+4iQkMCHR072jI2PTbUNsk2RjY5NvA23TZKNiU3EDcZN5I+RTxDRTBCJkK5VBYKFhZfwQCWygU3AJBRHpu+OytgNxa61A40GMsYjsn7BVwFXQVcBV0FaAVdBVwFXQVcBV0FXAVdBVwFXUsaCNyKAK4AAQUHBwKU7oICoW1e7jAEzgPxA+YDwgCkBFDAwADABKzAAOxFLhitA1UFTDeyPkM+bj51QkRCuwTQWWQ8X+0AWBYzsACNA8xwzAGm7EZ/QisoCTAbLDs6fnLfb8H2GccsbgFw13M1HAVkBW/Jxsm9CNRO8E8FDD0FBQw9FkcClOYCoMFegpDfADgcMiA2AJQACB8AsigKAIzIEAJKeBIApY5yPZQIAKQiHb4fvj5BKSRPQrZCOz0oXyxgOywfKAnGbgMClQaCAkILXgdeCD9IIGUgQj5fPoY+dT52Ao5CM0dAX9BTVG9SDzFwWTQAbxBzJF/lOEIQQglCCkKJIAls5AcClQICoKPMODEFxhi6KSAbiyfIRrMjtCgdWCAkPlFBIitCsEJRzAbMAV/OEyQzDg0OAQQEJ36i328/Mk9AybDJsQlq3tDRApUKAkFzXf1d/j9uALYP6hCoFgCTGD8kPsFKQiobrm0+zj0KSD8kPnVCRBwMDyJRTHFgMTJa5rwXQiQ2YfI/JD7BMEJEHGINTw4TOFlIRzwJO0icMQpyPyQ+wzJCRBv6DVgnKB01NgUKj2bwYzMqCoBkznBgEF+zYDIocwRIX+NgHj4HICNfh2C4CwdwFWpTG/lgUhYGAwRfv2Ts8mAaXzVgml/XYIJfuWC4HI1gUF9pYJZgMR6ilQHMAOwLAlDRefC0in4AXAEJA6PjCwc0IamOANMMCAECRQDFNRTZBgd+CwQlRA+r6+gLBDEFBnwUBXgKATIArwAGRAAHA3cDdAN2A3kDdwN9A3oDdQN7A30DfAN4A3oDfQAYEAAlAtYASwMAUAFsAHcKAHcAmgB3AHUAdQB2AHVu8UgAygDAAHcAdQB1AHYAdQALCgB3AAsAmgB3AAsCOwB3AAtu8UgAygDAAHgKAJoAdwB3AHUAdQB2AHUAeAB1AHUAdgB1bvFIAMoAwAALCgCaAHcACwB3AAsCOwB3AAtu8UgAygDAAH4ACwGgALcBpwC6AahdAu0COwLtbvFIAMoAwAALCgCaAu0ACwLtAAsCOwLtAAtu8UgAygDAA24ACwNvAAu0VsQAAzsAABCkjUIpAAsAUIusOggWcgMeBxVsGwL67U/2HlzmWOEeOgALASvuAAseAfpKUpnpGgYJDCIZM6YyARUE9ThqAD5iXQgnAJYJPnOzw0ZAEZxEKsIAkA4DhAHnTAIDxxUDK0lxCQlPYgIvIQVYJQBVqE1GakUAKGYiDToSBA1EtAYAXQJYAIF8GgMHRyAAIAjOe9YncekRAA0KACUrjwE7Ayc6AAYWAqaiKG4McEcqANoN3+Mg9TwCBhIkuCny+JwUQ29L008JluRxu3K+oAdqiHOqFH0AG5SUIfUJ5SxCGfxdipRzqTmT4V5Zb+r1Uo4Vm+NqSSEl2mNvR2JhIa8SpYO6ntdwFXHCWTCK8f2+Hxo7uiG3drDycAuKIMP5bhi06ACnqArH1rz4Rqg//lm6SgJGEVbF9xJHISaR6HxqxSnkw6shDnelHKNEfGUXSJRJ1GcsmtJw25xrZMDK9gXSm1/YMkdX4/6NKYOdtk/NQ3/NnDASjTc3fPjIjW/5sVfVObX2oTDWkr1dF9f3kxBsD3/3aQO8hPfRz+e0uEiJqt1161griu7gz8hDDwtpy+F+BWtefnKHZPAxcZoWbnznhJpy0e842j36bcNzGnIEusgGX0a8ZxsnjcSsPDZ09yZ36fCQbriHeQ72JRMILNl6ePPf2HWoVwgWAm1fb3V2sAY0+B6rAXqSwPBgseVmoqsBTSrm91+XasMYYySI8eeRxH3ZvHkMz3BQ5aJ3iUVbYPNM3/7emRtjlsMgv/9VyTsyt/mK+8fgWeT6SoFaclXqn42dAIsvAarF5vNNWHzKSkKQ/8Hfk5ZWK7r9yliOsooyBjRhfkHP4Q2DkWXQi6FG/9r/IwbmkV5T7JSopHKn1pJwm9tb5Ot0oyN1Z2mPpKXHTxx2nlK08fKk1hEYA8WgVVWL5lgx0iTv+KdojJeU23ZDjmiubXOxVXJKKi2Wjuh2HLZOFLiSC7Tls5SMh4f+Pj6xUSrNjFqLGehRNB8lC0QSLNmkJJx/wSG3MnjE9T1CkPwJI0wH2lfzwETIiVqUxg0dfu5q39Gt+hwdcxkhhNvQ4TyrBceof3Mhs/IxFci1HmHr4FMZgXEEczPiGCx0HRwzAqDq2j9AVm1kwN0mRVLWLylgtoPNapF5cY4Y1wJh/e0BBwZj44YgZrDNqvD/9Hv7GFYdUQeDJuQ3EWI4HaKqavU1XjC/n41kT4L79kqGq0kLhdTZvgP3TA3fS0ozVz+5piZsoOtIvBUFoMKbNcmBL6YxxaUAusHB38XrS8dQMnQwJfUUkpRoGr5AUeWicvBTzyK9g77+yCkf5PAysL7r/JjcZgrbvRpMW9iyaxZvKO6ceZN2EwIxKwVFPuvFuiEPGCoagbMo+SpydLrXqBzNCDGFCrO/rkcwa2xhokQZ5CdZ0AsU3JfSqJ6n5I14YA+P/uAgfhPU84Tlw7cEFfp7AEE8ey4sP12PTt4Cods1GRgDOB5xvyiR5m+Bx8O5nBCNctU8BevfV5A08x6RHd5jcwPTMDSZJOedIZ1cGQ704lxbAzqZOP05ZxaOghzSdvFBHYqomATARyAADK4elP8Ly3IrUZKfWh23Xy20uBUmLS4Pfagu9+oyVa2iPgqRP3F2CTUsvJ7+RYnN8fFZbU/HVvxvcFFDKkiTqV5UBZ3Gz54JAKByi9hkKMZJvuGgcSYXFmw08UyoQyVdfTD1/dMkCHXcTGAKeROgArsvmRrQTLUOXioOHGK2QkjHuoYFgXciZoTJd6Fs5q1QX1G+p/e26hYsEf7QZD1nnIyl/SFkNtYYmmBhpBrxl9WbY0YpHWRuw2Ll/tj9mD8P4snVzJl4F9J+1arVeTb9E5r2ILH04qStjxQNwn3m4YNqxmaNbLAqW2TN6LidwuJRqS+NXbtqxoeDXpxeGWmxzSkWxjkyCkX4NQRme6q5SAcC+M7+9ETfA/EwrzQajKakCwYyeunP6ZFlxU2oMEn1Pz31zeStW74G406ZJFCl1wAXIoUKkWotYEpOuXB1uVNxJ63dpJEqfxBeptwIHNrPz8BllZoIcBoXwgfJ+8VAUnVPvRvexnw0Ma/WiGYuJO5y8QTvEYBigFmhUxY5RqzE8OcywN/8m4UYrlaniJO75XQ6KSo9+tWHlu+hMi0UVdiKQp7NelnoZUzNaIyBPVeOwK6GNp+FfHuPOoyhaWuNvTYFkvxscMQWDh+zeFCFkgwbXftiV23ywJ4+uwRqmg9k3KzwIQpzppt8DBBOMbrqwQM5Gb05sEwdKzMiAqOloaA/lr0KA+1pr0/+HiWoiIjHA/wir2nIuS3PeU/ji3O6ZwoxcR1SZ9FhtLC5S0FIzFhbBWcGVP/KpxOPSiUoAdWUpqKH++6Scz507iCcxYI6rdMBICPJZea7OcmeFw5mObJSiqpjg2UoWNIs+cFhyDSt6geV5qgi3FunmwwDoGSMgerFOZGX1m0dMCYo5XOruxO063dwENK9DbnVM9wYFREzh4vyU1WYYJ/LRRp6oxgjqP/X5a8/4Af6p6NWkQferzBmXme0zY/4nwMJm/wd1tIqSwGz+E3xPEAOoZlJit3XddD7/BT1pllzOx+8bmQtANQ/S6fZexc6qi3W+Q2xcmXTUhuS5mpHQRvcxZUN0S5+PL9lXWUAaRZhEH8hTdAcuNMMCuVNKTEGtSUKNi3O6KhSaTzck8csZ2vWRZ+d7mW8c4IKwXIYd25S/zIftPkwPzufjEvOHWVD1m+FjpDVUTV0DGDuHj6QnaEwLu/dEgdLQOg9E1Sro9XHJ8ykLAwtPu+pxqKDuFexqON1sKQm7rwbE1E68UCfA/erovrTCG+DBSNg0l4goDQvZN6uNlbyLpcZAwj2UclycvLpIZMgv4yRlpb3YuMftozorbcGVHt/VeDV3+Fdf1TP0iuaCsPi2G4XeGhsyF1ubVDxkoJhmniQ0/jSg/eYML9KLfnCFgISWkp91eauR3IQvED0nAPXK+6hPCYs+n3+hCZbiskmVMG2da+0EsZPonUeIY8EbfusQXjsK/eFDaosbPjEfQS0RKG7yj5GG69M7MeO1HmiUYocgygJHL6M1qzUDDwUSmr99V7Sdr2F3JjQAJY+F0yH33Iv3+C9M38eML7gTgmNu/r2bUMiPvpYbZ6v1/IaESirBHNa7mPKn4dEmYg7v/+HQgPN1G79jBQ1+soydfDC2r+h2Bl/KIc5KjMK7OH6nb1jLsNf0EHVe2KBiE51ox636uyG6Lho0t3J34L5QY/ilE3mikaF4HKXG1mG1rCevT1Vv6GavltxoQe/bMrpZvRggnBxSEPEeEzkEdOxTnPXHVjUYdw8JYvjB/o7Eegc3Ma+NUxLLnsK0kJlinPmUHzHGtrk5+CAbVzFOBqpyy3QVUnzTDfC/0XD94/okH+OB+i7g9lolhWIjSnfIb+Eq43ZXOWmwvjyV/qqD+t0e+7mTEM74qP/Ozt8nmC7mRpyu63OB4KnUzFc074SqoyPUAgM+/TJGFo6T44EHnQU4X4z6qannVqgw/U7zCpwcmXV1AubIrvOmkKHazJAR55ePjp5tLBsN8vAqs3NAHdcEHOR2xQ0lsNAFzSUuxFQCFYvXLZJdOj9p4fNq6p0HBGUik2YzaI4xySy91KzhQ0+q1hjxvImRwPRf76tChlRkhRCi74NXZ9qUNeIwP+s5p+3m5nwPdNOHgSLD79n7O9m1n1uDHiMntq4nkYwV5OZ1ENbXxFd4PgrlvavZsyUO4MqYlqqn1O8W/I1dEZq5dXhrbETLaZIbC2Kj/Aa/QM+fqUOHdf0tXAQ1huZ3cmWECWSXy/43j35+Mvq9xws7JKseriZ1pEWKc8qlzNrGPUGcVgOa9cPJYIJsGnJTAUsEcDOEVULO5x0rXBijc1lgXEzQQKhROf8zIV82w8eswc78YX11KYLWQRcgHNJElBxfXr72lS2RBSl07qTKorO2uUDZr3sFhYsvnhLZn0A94KRzJ/7DEGIAhW5ZWFpL8gEwu1aLA9MuWZzNwl8Oze9Y+bX+v9gywRVnoB5I/8kXTXU3141yRLYrIOOz6SOnyHNy4SieqzkBXharjfjqq1q6tklaEbA8Qfm2DaIPs7OTq/nvJBjKfO2H9bH2cCMh1+5gspfycu8f/cuuRmtDjyqZ7uCIMyjdV3a+p3fqmXsRx4C8lujezIFHnQiVTXLXuI1XrwN3+siYYj2HHTvESUx8DlOTXpak9qFRK+L3mgJ1WsD7F4cu1aJoFoYQnu+wGDMOjJM3kiBQWHCcvhJ/HRdxodOQp45YZaOTA22Nb4XKCVxqkbwMYFhzYQYIAnCW8FW14uf98jhUG2zrKhQQ0q0CEq0t5nXyvUyvR8DvD69LU+g3i+HFWQMQ8PqZuHD+sNKAV0+M6EJC0szq7rEr7B5bQ8BcNHzvDMc9eqB5ZCQdTf80Obn4uzjwpYU7SISdtV0QGa9D3Wrh2BDQtpBKxaNFV+/Cy2P/Sv+8s7Ud0Fd74X4+o/TNztWgETUapy+majNQ68Lq3ee0ZO48VEbTZYiH1Co4OlfWef82RWeyUXo7woM03PyapGfikTnQinoNq5z5veLpeMV3HCAMTaZmA1oGLAn7XS3XYsz+XK7VMQsc4XKrmDXOLU/pSXVNUq8dIqTba///3x6LiLS6xs1xuCAYSfcQ3+rQgmu7uvf3THKt5Ooo97TqcbRqxx7EASizaQCBQllG/rYxVapMLgtLbZS64w1MDBMXX+PQpBKNwqUKOf2DDRDUXQf9EhOS0Qj4nTmlA8dzSLz/G1d+Ud8MTy/6ghhdiLpeerGY/UlDOfiuqFsMUU5/UYlP+BAmgRLuNpvrUaLlVkrqDievNVEAwF+4CoM1MZTmjxjJMsKJq+u8Zd7tNCUFy6LiyYXRJQ4VyvEQFFaCGKsxIwQkk7EzZ6LTJq2hUuPhvAW+gQnSG6J+MszC+7QCRHcnqDdyNRJ6T9xyS87A6MDutbzKGvGktpbXqtzWtXb9HsfK2cBMomjN9a4y+TaJLnXxAeX/HWzmf4cR4vALt/P4w4qgKY04ml4ZdLOinFYS6cup3G/1ie4+t1eOnpBNlqGqs75ilzkT4+DsZQxNvaSKJ//6zIbbk/M7LOhFmRc/1R+kBtz7JFGdZm/COotIdvQoXpTqP/1uqEUmCb/QWoGLMwO5ANcHzxdY48IGP5+J+zKOTBFZ4Pid+GTM+Wq12MV/H86xEJptBa6T+p3kgpwLedManBHC2GgNrFpoN2xnrMz9WFWX/8/ygSBkavq2Uv7FdCsLEYLu9LLIvAU0bNRDtzYl+/vXmjpIvuJFYjmI0im6QEYqnIeMsNjXG4vIutIGHijeAG/9EDBozKV5cldkHbLxHh25vT+ZEzbhXlqvpzKJwcEgfNwLAKFeo0/pvEE10XDB+EXRTXtSzJozQKFFAJhMxYkVaCW+E9AL7tMeU8acxidHqzb6lX4691UsDpy/LLRmT+epgW56+5Cw8tB4kMUv6s9lh3eRKbyGs+H/4mQMaYzPTf2OOdokEn+zzgvoD3FqNKk8QqGAXVsqcGdXrT62fSPkR2vROFi68A6se86UxRUk4cajfPyCC4G5wDhD+zNq4jodQ4u4n/m37Lr36n4LIAAsVr02dFi9AiwA81MYs2rm4eDlDNmdMRvEKRHfBwW5DdMNp0jPFZMeARqF/wL4XBfd+EMLBfMzpH5GH6NaW+1vrvMdg+VxDzatk3MXgO3ro3P/DpcC6+Mo4MySJhKJhSR01SGGGp5hPWmrrUgrv3lDnP+HhcI3nt3YqBoVAVTBAQT5iuhTg8nvPtd8ZeYj6w1x6RqGUBrSku7+N1+BaasZvjTk64RoIDlL8brpEcJx3OmY7jLoZsswdtmhfC/G21llXhITOwmvRDDeTTPbyASOa16cF5/A1fZAidJpqju3wYAy9avPR1ya6eNp9K8XYrrtuxlqi+bDKwlfrYdR0RRiKRVTLOH85+ZY7XSmzRpfZBJjaTa81VDcJHpZnZnSQLASGYW9l51ZV/h7eVzTi3Hv6hUsgc/51AqJRTkpbFVLXXszoBL8nBX0u/0jBLT8nH+fJePbrwURT58OY+UieRjd1vs04w0VG5VN2U6MoGZkQzKN/ptz0Q366dxoTGmj7i1NQGHi9GgnquXFYdrCfZBmeb7s0T6yrdlZH5cZuwHFyIJ/kAtGsTg0xH5taAAq44BAk1CPk9KVVbqQzrCUiFdF/6gtlPQ8bHHc1G1W92MXGZ5HEHftyLYs8mbD/9xYRUWkHmlM0zC2ilJlnNgV4bfALpQghxOUoZL7VTqtCHIaQSXm+YUMnpkXybnV+A6xlm2CVy8fn0Xlm2XRa0+zzOa21JWWmixfiPMSCZ7qA4rS93VN3pkpF1s5TonQjisHf7iU9ZGvUPOAKZcR1pbeVf/Ul7OhepGCaId9wOtqo7pJ7yLcBZ0pFkOF28y4zEI/kcUNmutBHaQpBdNM8vjCS6HZRokkeo88TBAjGyG7SR+6vUgTcyK9Imalj0kuxz0wmK+byQU11AiJFk/ya5dNduRClcnU64yGu/ieWSeOos1t3ep+RPIWQ2pyTYVbZltTbsb7NiwSi3AV+8KLWk7LxCnfZUetEM8ThnsSoGH38/nyAwFguJp8FjvlHtcWZuU4hPva0rHfr0UhOOJ/F6vS62FW7KzkmRll2HEc7oUq4fyi5T70Vl7YVIfsPHUCdHesf9Lk7WNVWO75JDkYbMI8TOW8JKVtLY9d6UJRITO8oKo0xS+o99Yy04iniGHAaGj88kEWgwv0OrHdY/nr76DOGNS59hXCGXzTKUvDl9iKpLSWYN1lxIeyywdNpTkhay74w2jFT6NS8qkjo5CxA1yfSYwp6AJIZNKIeEK5PJAW7ORgWgwp0VgzYpqovMrWxbu+DGZ6Lhie1RAqpzm8VUzKJOH3mCzWuTOLsN3VT/dv2eeYe9UjbR8YTBsLz7q60VN1sU51k+um1f8JxD5pPhbhSC8rRaB454tmh6YUWrJI3+GWY0qeWioj/tbkYITOkJaeuGt4JrJvHA+l0Gu7kY7XOaa05alMnRWVCXqFgLIwSY4uF59Ue5SU4QKuc/HamDxbr0x6csCetXGoP7Qn1Bk/J9DsynO/UD6iZ1Hyrz+jit0hDCwi/E9OjgKTbB3ZQKQ/0ZOvevfNHG0NK4Aj3Cp7NpRk07RT1i/S0EL93Ag8GRgKI9CfpajKyK6+Jj/PI1KO5/85VAwz2AwzP8FTBb075IxCXv6T9RVvWT2tUaqxDS92zrGUbWzUYk9mSs82pECH+fkqsDt93VW++4YsR/dHCYcQSYTO/KaBMDj9LSD/J/+z20Kq8XvZUAIHtm9hRPP3ItbuAu2Hm5lkPs92pd7kCxgRs0xOVBnZ13ccdA0aunrwv9SdqElJRC3g+oCu+nXyCgmXUs9yMjTMAIHfxZV+aPKcZeUBWt057Xo85Ks1Ir5gzEHCWqZEhrLZMuF11ziGtFQUds/EESajhagzcKsxamcSZxGth4UII+adPhQkUnx2WyN+4YWR+r3f8MnkyGFuR4zjzxJS8WsQYR5PTyRaD9ixa6Mh741nBHbzfjXHskGDq179xaRNrCIB1z1xRfWfjqw2pHc1zk9xlPpL8sQWAIuETZZhbnmL54rceXVNRvUiKrrqIkeogsl0XXb17ylNb0f4GA9Wd44vffEG8FSZGHEL2fbaTGRcSiCeA8PmA/f6Hz8HCS76fXUHwgwkzSwlI71ekZ7Fapmlk/KC+Hs8hUcw3N2LN5LhkVYyizYFl/uPeVP5lsoJHhhfWvvSWruCUW1ZcJOeuTbrDgywJ/qG07gZJplnTvLcYdNaH0KMYOYMGX+rB4NGPFmQsNaIwlWrfCezxre8zXBrsMT+edVLbLqN1BqB76JH4BvZTqUIMfGwPGEn+EnmTV86fPBaYbFL3DFEhjB45CewkXEAtJxk4/Ms2pPXnaRqdky0HOYdcUcE2zcXq4vaIvW2/v0nHFJH2XXe22ueDmq/18XGtELSq85j9X8q0tcNSSKJIX8FTuJF/Pf8j5PhqG2u+osvsLxYrvvfeVJL+4tkcXcr9JV7v0ERmj/X6fM3NC4j6dS1+9Umr2oPavqiAydTZPLMNRGY23LO9zAVDly7jD+70G5TPPLdhRIl4WxcYjLnM+SNcJ26FOrkrISUtPObIz5Zb3AG612krnpy15RMW+1cQjlnWFI6538qky9axd2oJmHIHP08KyP0ubGO+TQNOYuv2uh17yCIvR8VcStw7o1g0NM60sk+8Tq7YfIBJrtp53GkvzXH7OA0p8/n/u1satf/VJhtR1l8Wa6Gmaug7haSpaCaYQax6ta0mkutlb+eAOSG1aobM81D9A4iS1RRlzBBoVX6tU1S6WE2N9ORY6DfeLRC4l9Rvr5h95XDWB2mR1d4WFudpsgVYwiTwT31ljskD8ZyDOlm5DkGh9N/UB/0AI5Xvb8ZBmai2hQ4BWMqFwYnzxwB26YHSOv9WgY3JXnvoN+2R4rqGVh/LLDMtpFP+SpMGJNWvbIl5SOodbCczW2RKleksPoUeGEzrjtKHVdtZA+kfqO+rVx/iclCqwoopepvJpSTDjT+b9GWylGRF8EDbGlw6eUzmJM95Ovoz+kwLX3c2fTjFeYEsE7vUZm3mqdGJuKh2w9/QGSaqRHs99aScGOdDqkFcACoqdbBoQqqjamhH6Q9ng39JCg3lrGJwd50Qk9ovnqBTr8MME7Ps2wiVfygUmPoUBJJfJWX5Nda0nuncbFkA=="));
}
const Sd = tI(), rI = new Set(Ml(Sd)), nI = new Set(Ml(Sd)), iI = YT(Sd), sI = eI(Sd), sx = 45, ox = 95;
function pE(Y) {
  return FT(Y);
}
function oI(Y) {
  return Y.filter((X) => X != 65039);
}
function gE(Y) {
  for (let X of Y.split(".")) {
    let ee = pE(X);
    try {
      for (let te = ee.lastIndexOf(ox) - 1; te >= 0; te--)
        if (ee[te] !== ox)
          throw new Error("underscore only allowed at start");
      if (ee.length >= 4 && ee.every((te) => te < 128) && ee[2] === sx && ee[3] === sx)
        throw new Error("invalid label extension");
    } catch (te) {
      throw new Error(`Invalid label "${X}": ${te.message}`);
    }
  }
  return Y;
}
function aI(Y) {
  return gE(cI(Y, oI));
}
function cI(Y, X) {
  let ee = pE(Y).reverse(), te = [];
  for (; ee.length; ) {
    let ne = fI(ee);
    if (ne) {
      te.push(...X(ne));
      continue;
    }
    let ie = ee.pop();
    if (rI.has(ie)) {
      te.push(ie);
      continue;
    }
    if (nI.has(ie))
      continue;
    let oe = iI[ie];
    if (oe) {
      te.push(...oe);
      continue;
    }
    throw new Error(`Disallowed codepoint: 0x${ie.toString(16).toUpperCase()}`);
  }
  return gE(uI(String.fromCodePoint(...te)));
}
function uI(Y) {
  return Y.normalize("NFC");
}
function fI(Y, X) {
  var ee;
  let te = sI, ne, ie, oe = [], se = Y.length;
  for (X && (X.length = 0); se; ) {
    let ae = Y[--se];
    if (te = (ee = te.branches.find((ue) => ue.set.has(ae))) === null || ee === void 0 ? void 0 : ee.node, !te)
      break;
    if (te.save)
      ie = ae;
    else if (te.check && ae === ie)
      break;
    oe.push(ae), te.fe0f && (oe.push(65039), se > 0 && Y[se - 1] == 65039 && se--), te.valid && (ne = oe.slice(), te.valid == 2 && ne.splice(1, 1), X && X.push(...Y.slice(se).reverse()), Y.length = se);
  }
  return ne;
}
const lI = new ce(uE), mE = new Uint8Array(32);
mE.fill(0);
function ax(Y) {
  if (Y.length === 0)
    throw new Error("invalid ENS name; empty component");
  return Y;
}
function yE(Y) {
  const X = Xr(aI(Y)), ee = [];
  if (Y.length === 0)
    return ee;
  let te = 0;
  for (let ne = 0; ne < X.length; ne++)
    X[ne] === 46 && (ee.push(ax(X.slice(te, ne))), te = ne + 1);
  if (te >= X.length)
    throw new Error("invalid ENS name; empty component");
  return ee.push(ax(X.slice(te))), ee;
}
function xl(Y) {
  typeof Y != "string" && lI.throwArgumentError("invalid ENS name; not a string", "name", Y);
  let X = mE;
  const ee = yE(Y);
  for (; ee.length; )
    X = gr(Br([X, gr(ee.pop())]));
  return Oe(X);
}
function dI(Y) {
  return Oe(Br(yE(Y).map((X) => {
    if (X.length > 63)
      throw new Error("invalid DNS encoded entry; length exceeds 63 bytes");
    const ee = new Uint8Array(X.length + 1);
    return ee.set(X, 1), ee[0] = ee.length - 1, ee;
  }))) + "00";
}
const hI = `Ethereum Signed Message:
`;
function pI(Y) {
  return typeof Y == "string" && (Y = Xr(Y)), gr(Br([
    Xr(hI),
    Xr(String(Y.length)),
    Y
  ]));
}
var gI = function(Y, X, ee, te) {
  function ne(ie) {
    return ie instanceof ee ? ie : new ee(function(oe) {
      oe(ie);
    });
  }
  return new (ee || (ee = Promise))(function(ie, oe) {
    function se(le) {
      try {
        ue(te.next(le));
      } catch (he) {
        oe(he);
      }
    }
    function ae(le) {
      try {
        ue(te.throw(le));
      } catch (he) {
        oe(he);
      }
    }
    function ue(le) {
      le.done ? ie(le.value) : ne(le.value).then(se, ae);
    }
    ue((te = te.apply(Y, X || [])).next());
  });
};
const br = new ce(uE), bE = new Uint8Array(32);
bE.fill(0);
const mI = Be.from(-1), xE = Be.from(0), wE = Be.from(1), yI = Be.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
function bI(Y) {
  const X = Ne(Y), ee = X.length % 32;
  return ee ? Tn([X, bE.slice(ee)]) : Oe(X);
}
const xI = hr$1(wE.toHexString(), 32), wI = hr$1(xE.toHexString(), 32), cx = {
  name: "string",
  version: "string",
  chainId: "uint256",
  verifyingContract: "address",
  salt: "bytes32"
}, X0 = [
  "name",
  "version",
  "chainId",
  "verifyingContract",
  "salt"
];
function ux(Y) {
  return function(X) {
    return typeof X != "string" && br.throwArgumentError(`invalid domain value for ${JSON.stringify(Y)}`, `domain.${Y}`, X), X;
  };
}
const vI = {
  name: ux("name"),
  version: ux("version"),
  chainId: function(Y) {
    try {
      return Be.from(Y).toString();
    } catch {
    }
    return br.throwArgumentError('invalid domain value for "chainId"', "domain.chainId", Y);
  },
  verifyingContract: function(Y) {
    try {
      return pr(Y).toLowerCase();
    } catch {
    }
    return br.throwArgumentError('invalid domain value "verifyingContract"', "domain.verifyingContract", Y);
  },
  salt: function(Y) {
    try {
      const X = Ne(Y);
      if (X.length !== 32)
        throw new Error("bad length");
      return Oe(X);
    } catch {
    }
    return br.throwArgumentError('invalid domain value "salt"', "domain.salt", Y);
  }
};
function Z0(Y) {
  {
    const X = Y.match(/^(u?)int(\d*)$/);
    if (X) {
      const ee = X[1] === "", te = parseInt(X[2] || "256");
      (te % 8 !== 0 || te > 256 || X[2] && X[2] !== String(te)) && br.throwArgumentError("invalid numeric width", "type", Y);
      const ne = yI.mask(ee ? te - 1 : te), ie = ee ? ne.add(wE).mul(mI) : xE;
      return function(oe) {
        const se = Be.from(oe);
        return (se.lt(ie) || se.gt(ne)) && br.throwArgumentError(`value out-of-bounds for ${Y}`, "value", oe), hr$1(se.toTwos(256).toHexString(), 32);
      };
    }
  }
  {
    const X = Y.match(/^bytes(\d+)$/);
    if (X) {
      const ee = parseInt(X[1]);
      return (ee === 0 || ee > 32 || X[1] !== String(ee)) && br.throwArgumentError("invalid bytes width", "type", Y), function(te) {
        return Ne(te).length !== ee && br.throwArgumentError(`invalid length for ${Y}`, "value", te), bI(te);
      };
    }
  }
  switch (Y) {
    case "address":
      return function(X) {
        return hr$1(pr(X), 32);
      };
    case "bool":
      return function(X) {
        return X ? xI : wI;
      };
    case "bytes":
      return function(X) {
        return gr(X);
      };
    case "string":
      return function(X) {
        return Ao(X);
      };
  }
  return null;
}
function fx(Y, X) {
  return `${Y}(${X.map(({ name: ee, type: te }) => te + " " + ee).join(",")})`;
}
class gn {
  constructor(X) {
    ve(this, "types", Object.freeze(ti(X))), ve(this, "_encoderCache", {}), ve(this, "_types", {});
    const ee = {}, te = {}, ne = {};
    Object.keys(X).forEach((se) => {
      ee[se] = {}, te[se] = [], ne[se] = {};
    });
    for (const se in X) {
      const ae = {};
      X[se].forEach((ue) => {
        ae[ue.name] && br.throwArgumentError(`duplicate variable name ${JSON.stringify(ue.name)} in ${JSON.stringify(se)}`, "types", X), ae[ue.name] = !0;
        const le = ue.type.match(/^([^\x5b]*)(\x5b|$)/)[1];
        le === se && br.throwArgumentError(`circular type reference to ${JSON.stringify(le)}`, "types", X), !Z0(le) && (te[le] || br.throwArgumentError(`unknown type ${JSON.stringify(le)}`, "types", X), te[le].push(se), ee[se][le] = !0);
      });
    }
    const ie = Object.keys(te).filter((se) => te[se].length === 0);
    ie.length === 0 ? br.throwArgumentError("missing primary type", "types", X) : ie.length > 1 && br.throwArgumentError(`ambiguous primary types or unused types: ${ie.map((se) => JSON.stringify(se)).join(", ")}`, "types", X), ve(this, "primaryType", ie[0]);
    function oe(se, ae) {
      ae[se] && br.throwArgumentError(`circular type reference to ${JSON.stringify(se)}`, "types", X), ae[se] = !0, Object.keys(ee[se]).forEach((ue) => {
        te[ue] && (oe(ue, ae), Object.keys(ae).forEach((le) => {
          ne[le][ue] = !0;
        }));
      }), delete ae[se];
    }
    oe(this.primaryType, {});
    for (const se in ne) {
      const ae = Object.keys(ne[se]);
      ae.sort(), this._types[se] = fx(se, X[se]) + ae.map((ue) => fx(ue, X[ue])).join("");
    }
  }
  getEncoder(X) {
    let ee = this._encoderCache[X];
    return ee || (ee = this._encoderCache[X] = this._getEncoder(X)), ee;
  }
  _getEncoder(X) {
    {
      const ne = Z0(X);
      if (ne)
        return ne;
    }
    const ee = X.match(/^(.*)(\x5b(\d*)\x5d)$/);
    if (ee) {
      const ne = ee[1], ie = this.getEncoder(ne), oe = parseInt(ee[3]);
      return (se) => {
        oe >= 0 && se.length !== oe && br.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", se);
        let ae = se.map(ie);
        return this._types[ne] && (ae = ae.map(gr)), gr(Tn(ae));
      };
    }
    const te = this.types[X];
    if (te) {
      const ne = Ao(this._types[X]);
      return (ie) => {
        const oe = te.map(({ name: se, type: ae }) => {
          const ue = this.getEncoder(ae)(ie[se]);
          return this._types[ae] ? gr(ue) : ue;
        });
        return oe.unshift(ne), Tn(oe);
      };
    }
    return br.throwArgumentError(`unknown type: ${X}`, "type", X);
  }
  encodeType(X) {
    const ee = this._types[X];
    return ee || br.throwArgumentError(`unknown type: ${JSON.stringify(X)}`, "name", X), ee;
  }
  encodeData(X, ee) {
    return this.getEncoder(X)(ee);
  }
  hashStruct(X, ee) {
    return gr(this.encodeData(X, ee));
  }
  encode(X) {
    return this.encodeData(this.primaryType, X);
  }
  hash(X) {
    return this.hashStruct(this.primaryType, X);
  }
  _visit(X, ee, te) {
    if (Z0(X))
      return te(X, ee);
    const ne = X.match(/^(.*)(\x5b(\d*)\x5d)$/);
    if (ne) {
      const oe = ne[1], se = parseInt(ne[3]);
      return se >= 0 && ee.length !== se && br.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", ee), ee.map((ae) => this._visit(oe, ae, te));
    }
    const ie = this.types[X];
    return ie ? ie.reduce((oe, { name: se, type: ae }) => (oe[se] = this._visit(ae, ee[se], te), oe), {}) : br.throwArgumentError(`unknown type: ${X}`, "type", X);
  }
  visit(X, ee) {
    return this._visit(this.primaryType, X, ee);
  }
  static from(X) {
    return new gn(X);
  }
  static getPrimaryType(X) {
    return gn.from(X).primaryType;
  }
  static hashStruct(X, ee, te) {
    return gn.from(ee).hashStruct(X, te);
  }
  static hashDomain(X) {
    const ee = [];
    for (const te in X) {
      const ne = cx[te];
      ne || br.throwArgumentError(`invalid typed-data domain key: ${JSON.stringify(te)}`, "domain", X), ee.push({ name: te, type: ne });
    }
    return ee.sort((te, ne) => X0.indexOf(te.name) - X0.indexOf(ne.name)), gn.hashStruct("EIP712Domain", { EIP712Domain: ee }, X);
  }
  static encode(X, ee, te) {
    return Tn([
      "0x1901",
      gn.hashDomain(X),
      gn.from(ee).hash(te)
    ]);
  }
  static hash(X, ee, te) {
    return gr(gn.encode(X, ee, te));
  }
  // Replaces all address types with ENS names with their looked up address
  static resolveNames(X, ee, te, ne) {
    return gI(this, void 0, void 0, function* () {
      X = mr$1(X);
      const ie = {};
      X.verifyingContract && !Bt(X.verifyingContract, 20) && (ie[X.verifyingContract] = "0x");
      const oe = gn.from(ee);
      oe.visit(te, (se, ae) => (se === "address" && !Bt(ae, 20) && (ie[ae] = "0x"), ae));
      for (const se in ie)
        ie[se] = yield ne(se);
      return X.verifyingContract && ie[X.verifyingContract] && (X.verifyingContract = ie[X.verifyingContract]), te = oe.visit(te, (se, ae) => se === "address" && ie[ae] ? ie[ae] : ae), { domain: X, value: te };
    });
  }
  static getPayload(X, ee, te) {
    gn.hashDomain(X);
    const ne = {}, ie = [];
    X0.forEach((ae) => {
      const ue = X[ae];
      ue != null && (ne[ae] = vI[ae](ue), ie.push({ name: ae, type: cx[ae] }));
    });
    const oe = gn.from(ee), se = mr$1(ee);
    return se.EIP712Domain ? br.throwArgumentError("types must not contain EIP712Domain type", "types.EIP712Domain", ee) : se.EIP712Domain = ie, oe.encode(te), {
      types: se,
      domain: ne,
      primaryType: oe.primaryType,
      message: oe.visit(te, (ae, ue) => {
        if (ae.match(/^bytes(\d*)/))
          return Oe(Ne(ue));
        if (ae.match(/^u?int/))
          return Be.from(ue).toString();
        switch (ae) {
          case "address":
            return ue.toLowerCase();
          case "bool":
            return !!ue;
          case "string":
            return typeof ue != "string" && br.throwArgumentError("invalid string", "value", ue), ue;
        }
        return br.throwArgumentError("unsupported type", "type", ae);
      })
    };
  }
}
const yr = new ce(af);
class EI extends Wo {
}
class _I extends Wo {
}
class AI extends Wo {
}
let Fp$2 = class extends Wo {
  static isIndexed(Y) {
    return !!(Y && Y._isIndexed);
  }
};
const SI = {
  "0x08c379a0": { signature: "Error(string)", name: "Error", inputs: ["string"], reason: !0 },
  "0x4e487b71": { signature: "Panic(uint256)", name: "Panic", inputs: ["uint256"] }
};
function lx(Y, X) {
  const ee = new Error(`deferred error during ABI decoding triggered accessing ${Y}`);
  return ee.error = X, ee;
}
class dx {
  constructor(X) {
    let ee = [];
    typeof X == "string" ? ee = JSON.parse(X) : ee = X, ve(this, "fragments", ee.map((te) => ws.from(te)).filter((te) => te != null)), ve(this, "_abiCoder", ji(new.target, "getAbiCoder")()), ve(this, "functions", {}), ve(this, "errors", {}), ve(this, "events", {}), ve(this, "structs", {}), this.fragments.forEach((te) => {
      let ne = null;
      switch (te.type) {
        case "constructor":
          if (this.deploy) {
            yr.warn("duplicate definition - constructor");
            return;
          }
          ve(this, "deploy", te);
          return;
        case "function":
          ne = this.functions;
          break;
        case "event":
          ne = this.events;
          break;
        case "error":
          ne = this.errors;
          break;
        default:
          return;
      }
      let ie = te.format();
      if (ne[ie]) {
        yr.warn("duplicate definition - " + ie);
        return;
      }
      ne[ie] = te;
    }), this.deploy || ve(this, "deploy", Li.from({
      payable: !1,
      type: "constructor"
    })), ve(this, "_isInterface", !0);
  }
  format(X) {
    X || (X = Xt.full), X === Xt.sighash && yr.throwArgumentError("interface does not support formatting sighash", "format", X);
    const ee = this.fragments.map((te) => te.format(X));
    return X === Xt.json ? JSON.stringify(ee.map((te) => JSON.parse(te))) : ee;
  }
  // Sub-classes can override these to handle other blockchains
  static getAbiCoder() {
    return HT;
  }
  static getAddress(X) {
    return pr(X);
  }
  static getSighash(X) {
    return Dr(Ao(X.format()), 0, 4);
  }
  static getEventTopic(X) {
    return Ao(X.format());
  }
  // Find a function definition by any means necessary (unless it is ambiguous)
  getFunction(X) {
    if (Bt(X)) {
      for (const te in this.functions)
        if (X === this.getSighash(te))
          return this.functions[te];
      yr.throwArgumentError("no matching function", "sighash", X);
    }
    if (X.indexOf("(") === -1) {
      const te = X.trim(), ne = Object.keys(this.functions).filter((ie) => ie.split(
        "("
        /* fix:) */
      )[0] === te);
      return ne.length === 0 ? yr.throwArgumentError("no matching function", "name", te) : ne.length > 1 && yr.throwArgumentError("multiple matching functions", "name", te), this.functions[ne[0]];
    }
    const ee = this.functions[Fi.fromString(X).format()];
    return ee || yr.throwArgumentError("no matching function", "signature", X), ee;
  }
  // Find an event definition by any means necessary (unless it is ambiguous)
  getEvent(X) {
    if (Bt(X)) {
      const te = X.toLowerCase();
      for (const ne in this.events)
        if (te === this.getEventTopic(ne))
          return this.events[ne];
      yr.throwArgumentError("no matching event", "topichash", te);
    }
    if (X.indexOf("(") === -1) {
      const te = X.trim(), ne = Object.keys(this.events).filter((ie) => ie.split(
        "("
        /* fix:) */
      )[0] === te);
      return ne.length === 0 ? yr.throwArgumentError("no matching event", "name", te) : ne.length > 1 && yr.throwArgumentError("multiple matching events", "name", te), this.events[ne[0]];
    }
    const ee = this.events[bs.fromString(X).format()];
    return ee || yr.throwArgumentError("no matching event", "signature", X), ee;
  }
  // Find a function definition by any means necessary (unless it is ambiguous)
  getError(X) {
    if (Bt(X)) {
      const te = ji(this.constructor, "getSighash");
      for (const ne in this.errors) {
        const ie = this.errors[ne];
        if (X === te(ie))
          return this.errors[ne];
      }
      yr.throwArgumentError("no matching error", "sighash", X);
    }
    if (X.indexOf("(") === -1) {
      const te = X.trim(), ne = Object.keys(this.errors).filter((ie) => ie.split(
        "("
        /* fix:) */
      )[0] === te);
      return ne.length === 0 ? yr.throwArgumentError("no matching error", "name", te) : ne.length > 1 && yr.throwArgumentError("multiple matching errors", "name", te), this.errors[ne[0]];
    }
    const ee = this.errors[Fi.fromString(X).format()];
    return ee || yr.throwArgumentError("no matching error", "signature", X), ee;
  }
  // Get the sighash (the bytes4 selector) used by Solidity to identify a function
  getSighash(X) {
    if (typeof X == "string")
      try {
        X = this.getFunction(X);
      } catch (ee) {
        try {
          X = this.getError(X);
        } catch {
          throw ee;
        }
      }
    return ji(this.constructor, "getSighash")(X);
  }
  // Get the topic (the bytes32 hash) used by Solidity to identify an event
  getEventTopic(X) {
    return typeof X == "string" && (X = this.getEvent(X)), ji(this.constructor, "getEventTopic")(X);
  }
  _decodeParams(X, ee) {
    return this._abiCoder.decode(X, ee);
  }
  _encodeParams(X, ee) {
    return this._abiCoder.encode(X, ee);
  }
  encodeDeploy(X) {
    return this._encodeParams(this.deploy.inputs, X || []);
  }
  decodeErrorResult(X, ee) {
    typeof X == "string" && (X = this.getError(X));
    const te = Ne(ee);
    return Oe(te.slice(0, 4)) !== this.getSighash(X) && yr.throwArgumentError(`data signature does not match error ${X.name}.`, "data", Oe(te)), this._decodeParams(X.inputs, te.slice(4));
  }
  encodeErrorResult(X, ee) {
    return typeof X == "string" && (X = this.getError(X)), Oe(Br([
      this.getSighash(X),
      this._encodeParams(X.inputs, ee || [])
    ]));
  }
  // Decode the data for a function call (e.g. tx.data)
  decodeFunctionData(X, ee) {
    typeof X == "string" && (X = this.getFunction(X));
    const te = Ne(ee);
    return Oe(te.slice(0, 4)) !== this.getSighash(X) && yr.throwArgumentError(`data signature does not match function ${X.name}.`, "data", Oe(te)), this._decodeParams(X.inputs, te.slice(4));
  }
  // Encode the data for a function call (e.g. tx.data)
  encodeFunctionData(X, ee) {
    return typeof X == "string" && (X = this.getFunction(X)), Oe(Br([
      this.getSighash(X),
      this._encodeParams(X.inputs, ee || [])
    ]));
  }
  // Decode the result from a function call (e.g. from eth_call)
  decodeFunctionResult(X, ee) {
    typeof X == "string" && (X = this.getFunction(X));
    let te = Ne(ee), ne = null, ie = "", oe = null, se = null, ae = null;
    switch (te.length % this._abiCoder._getWordSize()) {
      case 0:
        try {
          return this._abiCoder.decode(X.outputs, te);
        } catch {
        }
        break;
      case 4: {
        const ue = Oe(te.slice(0, 4)), le = SI[ue];
        if (le)
          oe = this._abiCoder.decode(le.inputs, te.slice(4)), se = le.name, ae = le.signature, le.reason && (ne = oe[0]), se === "Error" ? ie = `; VM Exception while processing transaction: reverted with reason string ${JSON.stringify(oe[0])}` : se === "Panic" && (ie = `; VM Exception while processing transaction: reverted with panic code ${oe[0]}`);
        else
          try {
            const he = this.getError(ue);
            oe = this._abiCoder.decode(he.inputs, te.slice(4)), se = he.name, ae = he.format();
          } catch {
          }
        break;
      }
    }
    return yr.throwError("call revert exception" + ie, ce.errors.CALL_EXCEPTION, {
      method: X.format(),
      data: Oe(ee),
      errorArgs: oe,
      errorName: se,
      errorSignature: ae,
      reason: ne
    });
  }
  // Encode the result for a function call (e.g. for eth_call)
  encodeFunctionResult(X, ee) {
    return typeof X == "string" && (X = this.getFunction(X)), Oe(this._abiCoder.encode(X.outputs, ee || []));
  }
  // Create the filter for the event with search criteria (e.g. for eth_filterLog)
  encodeFilterTopics(X, ee) {
    typeof X == "string" && (X = this.getEvent(X)), ee.length > X.inputs.length && yr.throwError("too many arguments for " + X.format(), ce.errors.UNEXPECTED_ARGUMENT, {
      argument: "values",
      value: ee
    });
    let te = [];
    X.anonymous || te.push(this.getEventTopic(X));
    const ne = (ie, oe) => ie.type === "string" ? Ao(oe) : ie.type === "bytes" ? gr(Oe(oe)) : (ie.type === "bool" && typeof oe == "boolean" && (oe = oe ? "0x01" : "0x00"), ie.type.match(/^u?int/) && (oe = Be.from(oe).toHexString()), ie.type === "address" && this._abiCoder.encode(["address"], [oe]), hr$1(Oe(oe), 32));
    for (ee.forEach((ie, oe) => {
      let se = X.inputs[oe];
      if (!se.indexed) {
        ie != null && yr.throwArgumentError("cannot filter non-indexed parameters; must be null", "contract." + se.name, ie);
        return;
      }
      ie == null ? te.push(null) : se.baseType === "array" || se.baseType === "tuple" ? yr.throwArgumentError("filtering with tuples or arrays not supported", "contract." + se.name, ie) : Array.isArray(ie) ? te.push(ie.map((ae) => ne(se, ae))) : te.push(ne(se, ie));
    }); te.length && te[te.length - 1] === null; )
      te.pop();
    return te;
  }
  encodeEventLog(X, ee) {
    typeof X == "string" && (X = this.getEvent(X));
    const te = [], ne = [], ie = [];
    return X.anonymous || te.push(this.getEventTopic(X)), ee.length !== X.inputs.length && yr.throwArgumentError("event arguments/values mismatch", "values", ee), X.inputs.forEach((oe, se) => {
      const ae = ee[se];
      if (oe.indexed)
        if (oe.type === "string")
          te.push(Ao(ae));
        else if (oe.type === "bytes")
          te.push(gr(ae));
        else {
          if (oe.baseType === "tuple" || oe.baseType === "array")
            throw new Error("not implemented");
          te.push(this._abiCoder.encode([oe.type], [ae]));
        }
      else
        ne.push(oe), ie.push(ae);
    }), {
      data: this._abiCoder.encode(ne, ie),
      topics: te
    };
  }
  // Decode a filter for the event and the search criteria
  decodeEventLog(X, ee, te) {
    if (typeof X == "string" && (X = this.getEvent(X)), te != null && !X.anonymous) {
      let me = this.getEventTopic(X);
      (!Bt(te[0], 32) || te[0].toLowerCase() !== me) && yr.throwError("fragment/topic mismatch", ce.errors.INVALID_ARGUMENT, { argument: "topics[0]", expected: me, value: te[0] }), te = te.slice(1);
    }
    let ne = [], ie = [], oe = [];
    X.inputs.forEach((me, ye) => {
      me.indexed ? me.type === "string" || me.type === "bytes" || me.baseType === "tuple" || me.baseType === "array" ? (ne.push(Vr.fromObject({ type: "bytes32", name: me.name })), oe.push(!0)) : (ne.push(me), oe.push(!1)) : (ie.push(me), oe.push(!1));
    });
    let se = te != null ? this._abiCoder.decode(ne, Br(te)) : null, ae = this._abiCoder.decode(ie, ee, !0), ue = [], le = 0, he = 0;
    X.inputs.forEach((me, ye) => {
      if (me.indexed)
        if (se == null)
          ue[ye] = new Fp$2({ _isIndexed: !0, hash: null });
        else if (oe[ye])
          ue[ye] = new Fp$2({ _isIndexed: !0, hash: se[he++] });
        else
          try {
            ue[ye] = se[he++];
          } catch (we) {
            ue[ye] = we;
          }
      else
        try {
          ue[ye] = ae[le++];
        } catch (we) {
          ue[ye] = we;
        }
      if (me.name && ue[me.name] == null) {
        const we = ue[ye];
        we instanceof Error ? Object.defineProperty(ue, me.name, {
          enumerable: !0,
          get: () => {
            throw lx(`property ${JSON.stringify(me.name)}`, we);
          }
        }) : ue[me.name] = we;
      }
    });
    for (let me = 0; me < ue.length; me++) {
      const ye = ue[me];
      ye instanceof Error && Object.defineProperty(ue, me, {
        enumerable: !0,
        get: () => {
          throw lx(`index ${me}`, ye);
        }
      });
    }
    return Object.freeze(ue);
  }
  // Given a transaction, find the matching function fragment (if any) and
  // determine all its properties and call parameters
  parseTransaction(X) {
    let ee = this.getFunction(X.data.substring(0, 10).toLowerCase());
    return ee ? new _I({
      args: this._abiCoder.decode(ee.inputs, "0x" + X.data.substring(10)),
      functionFragment: ee,
      name: ee.name,
      signature: ee.format(),
      sighash: this.getSighash(ee),
      value: Be.from(X.value || "0")
    }) : null;
  }
  // @TODO
  //parseCallResult(data: BytesLike): ??
  // Given an event log, find the matching event fragment (if any) and
  // determine all its properties and values
  parseLog(X) {
    let ee = this.getEvent(X.topics[0]);
    return !ee || ee.anonymous ? null : new EI({
      eventFragment: ee,
      name: ee.name,
      signature: ee.format(),
      topic: this.getEventTopic(ee),
      args: this.decodeEventLog(ee, X.data, X.topics)
    });
  }
  parseError(X) {
    const ee = Oe(X);
    let te = this.getError(ee.substring(0, 10).toLowerCase());
    return te ? new AI({
      args: this._abiCoder.decode(te.inputs, "0x" + ee.substring(10)),
      errorFragment: te,
      name: te.name,
      signature: te.format(),
      sighash: this.getSighash(te)
    }) : null;
  }
  /*
  static from(value: Array<Fragment | string | JsonAbi> | string | Interface) {
      if (Interface.isInterface(value)) {
          return value;
      }
      if (typeof(value) === "string") {
          return new Interface(JSON.parse(value));
      }
      return new Interface(value);
  }
  */
  static isInterface(X) {
    return !!(X && X._isInterface);
  }
}
const TI = "abstract-provider/5.7.0";
var II = function(Y, X, ee, te) {
  function ne(ie) {
    return ie instanceof ee ? ie : new ee(function(oe) {
      oe(ie);
    });
  }
  return new (ee || (ee = Promise))(function(ie, oe) {
    function se(le) {
      try {
        ue(te.next(le));
      } catch (he) {
        oe(he);
      }
    }
    function ae(le) {
      try {
        ue(te.throw(le));
      } catch (he) {
        oe(he);
      }
    }
    function ue(le) {
      le.done ? ie(le.value) : ne(le.value).then(se, ae);
    }
    ue((te = te.apply(Y, X || [])).next());
  });
};
const RI = new ce(TI);
class CI extends Wo {
  static isForkEvent(X) {
    return !!(X && X._isForkEvent);
  }
}
class dc {
  constructor() {
    RI.checkAbstract(new.target, dc), ve(this, "_isProvider", !0);
  }
  getFeeData() {
    return II(this, void 0, void 0, function* () {
      const { block: X, gasPrice: ee } = yield Cr({
        block: this.getBlock("latest"),
        gasPrice: this.getGasPrice().catch((oe) => null)
      });
      let te = null, ne = null, ie = null;
      return X && X.baseFeePerGas && (te = X.baseFeePerGas, ie = Be.from("1500000000"), ne = X.baseFeePerGas.mul(2).add(ie)), { lastBaseFeePerGas: te, maxFeePerGas: ne, maxPriorityFeePerGas: ie, gasPrice: ee };
    });
  }
  // Alias for "on"
  addListener(X, ee) {
    return this.on(X, ee);
  }
  // Alias for "off"
  removeListener(X, ee) {
    return this.off(X, ee);
  }
  static isProvider(X) {
    return !!(X && X._isProvider);
  }
}
const PI = "abstract-signer/5.7.0";
var ci = function(Y, X, ee, te) {
  function ne(ie) {
    return ie instanceof ee ? ie : new ee(function(oe) {
      oe(ie);
    });
  }
  return new (ee || (ee = Promise))(function(ie, oe) {
    function se(le) {
      try {
        ue(te.next(le));
      } catch (he) {
        oe(he);
      }
    }
    function ae(le) {
      try {
        ue(te.throw(le));
      } catch (he) {
        oe(he);
      }
    }
    function ue(le) {
      le.done ? ie(le.value) : ne(le.value).then(se, ae);
    }
    ue((te = te.apply(Y, X || [])).next());
  });
};
const Gn = new ce(PI), OI = [
  "accessList",
  "ccipReadEnabled",
  "chainId",
  "customData",
  "data",
  "from",
  "gasLimit",
  "gasPrice",
  "maxFeePerGas",
  "maxPriorityFeePerGas",
  "nonce",
  "to",
  "type",
  "value"
], BI = [
  ce.errors.INSUFFICIENT_FUNDS,
  ce.errors.NONCE_EXPIRED,
  ce.errors.REPLACEMENT_UNDERPRICED
];
class hc {
  ///////////////////
  // Sub-classes MUST call super
  constructor() {
    Gn.checkAbstract(new.target, hc), ve(this, "_isSigner", !0);
  }
  ///////////////////
  // Sub-classes MAY override these
  getBalance(X) {
    return ci(this, void 0, void 0, function* () {
      return this._checkProvider("getBalance"), yield this.provider.getBalance(this.getAddress(), X);
    });
  }
  getTransactionCount(X) {
    return ci(this, void 0, void 0, function* () {
      return this._checkProvider("getTransactionCount"), yield this.provider.getTransactionCount(this.getAddress(), X);
    });
  }
  // Populates "from" if unspecified, and estimates the gas for the transaction
  estimateGas(X) {
    return ci(this, void 0, void 0, function* () {
      this._checkProvider("estimateGas");
      const ee = yield Cr(this.checkTransaction(X));
      return yield this.provider.estimateGas(ee);
    });
  }
  // Populates "from" if unspecified, and calls with the transaction
  call(X, ee) {
    return ci(this, void 0, void 0, function* () {
      this._checkProvider("call");
      const te = yield Cr(this.checkTransaction(X));
      return yield this.provider.call(te, ee);
    });
  }
  // Populates all fields in a transaction, signs it and sends it to the network
  sendTransaction(X) {
    return ci(this, void 0, void 0, function* () {
      this._checkProvider("sendTransaction");
      const ee = yield this.populateTransaction(X), te = yield this.signTransaction(ee);
      return yield this.provider.sendTransaction(te);
    });
  }
  getChainId() {
    return ci(this, void 0, void 0, function* () {
      return this._checkProvider("getChainId"), (yield this.provider.getNetwork()).chainId;
    });
  }
  getGasPrice() {
    return ci(this, void 0, void 0, function* () {
      return this._checkProvider("getGasPrice"), yield this.provider.getGasPrice();
    });
  }
  getFeeData() {
    return ci(this, void 0, void 0, function* () {
      return this._checkProvider("getFeeData"), yield this.provider.getFeeData();
    });
  }
  resolveName(X) {
    return ci(this, void 0, void 0, function* () {
      return this._checkProvider("resolveName"), yield this.provider.resolveName(X);
    });
  }
  // Checks a transaction does not contain invalid keys and if
  // no "from" is provided, populates it.
  // - does NOT require a provider
  // - adds "from" is not present
  // - returns a COPY (safe to mutate the result)
  // By default called from: (overriding these prevents it)
  //   - call
  //   - estimateGas
  //   - populateTransaction (and therefor sendTransaction)
  checkTransaction(X) {
    for (const te in X)
      OI.indexOf(te) === -1 && Gn.throwArgumentError("invalid transaction key: " + te, "transaction", X);
    const ee = mr$1(X);
    return ee.from == null ? ee.from = this.getAddress() : ee.from = Promise.all([
      Promise.resolve(ee.from),
      this.getAddress()
    ]).then((te) => (te[0].toLowerCase() !== te[1].toLowerCase() && Gn.throwArgumentError("from address mismatch", "transaction", X), te[0])), ee;
  }
  // Populates ALL keys for a transaction and checks that "from" matches
  // this Signer. Should be used by sendTransaction but NOT by signTransaction.
  // By default called from: (overriding these prevents it)
  //   - sendTransaction
  //
  // Notes:
  //  - We allow gasPrice for EIP-1559 as long as it matches maxFeePerGas
  populateTransaction(X) {
    return ci(this, void 0, void 0, function* () {
      const ee = yield Cr(this.checkTransaction(X));
      ee.to != null && (ee.to = Promise.resolve(ee.to).then((ne) => ci(this, void 0, void 0, function* () {
        if (ne == null)
          return null;
        const ie = yield this.resolveName(ne);
        return ie == null && Gn.throwArgumentError("provided ENS name resolves to null", "tx.to", ne), ie;
      })), ee.to.catch((ne) => {
      }));
      const te = ee.maxFeePerGas != null || ee.maxPriorityFeePerGas != null;
      if (ee.gasPrice != null && (ee.type === 2 || te) ? Gn.throwArgumentError("eip-1559 transaction do not support gasPrice", "transaction", X) : (ee.type === 0 || ee.type === 1) && te && Gn.throwArgumentError("pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "transaction", X), (ee.type === 2 || ee.type == null) && ee.maxFeePerGas != null && ee.maxPriorityFeePerGas != null)
        ee.type = 2;
      else if (ee.type === 0 || ee.type === 1)
        ee.gasPrice == null && (ee.gasPrice = this.getGasPrice());
      else {
        const ne = yield this.getFeeData();
        if (ee.type == null)
          if (ne.maxFeePerGas != null && ne.maxPriorityFeePerGas != null)
            if (ee.type = 2, ee.gasPrice != null) {
              const ie = ee.gasPrice;
              delete ee.gasPrice, ee.maxFeePerGas = ie, ee.maxPriorityFeePerGas = ie;
            } else
              ee.maxFeePerGas == null && (ee.maxFeePerGas = ne.maxFeePerGas), ee.maxPriorityFeePerGas == null && (ee.maxPriorityFeePerGas = ne.maxPriorityFeePerGas);
          else
            ne.gasPrice != null ? (te && Gn.throwError("network does not support EIP-1559", ce.errors.UNSUPPORTED_OPERATION, {
              operation: "populateTransaction"
            }), ee.gasPrice == null && (ee.gasPrice = ne.gasPrice), ee.type = 0) : Gn.throwError("failed to get consistent fee data", ce.errors.UNSUPPORTED_OPERATION, {
              operation: "signer.getFeeData"
            });
        else
          ee.type === 2 && (ee.maxFeePerGas == null && (ee.maxFeePerGas = ne.maxFeePerGas), ee.maxPriorityFeePerGas == null && (ee.maxPriorityFeePerGas = ne.maxPriorityFeePerGas));
      }
      return ee.nonce == null && (ee.nonce = this.getTransactionCount("pending")), ee.gasLimit == null && (ee.gasLimit = this.estimateGas(ee).catch((ne) => {
        if (BI.indexOf(ne.code) >= 0)
          throw ne;
        return Gn.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", ce.errors.UNPREDICTABLE_GAS_LIMIT, {
          error: ne,
          tx: ee
        });
      })), ee.chainId == null ? ee.chainId = this.getChainId() : ee.chainId = Promise.all([
        Promise.resolve(ee.chainId),
        this.getChainId()
      ]).then((ne) => (ne[1] !== 0 && ne[0] !== ne[1] && Gn.throwArgumentError("chainId address mismatch", "transaction", X), ne[0])), yield Cr(ee);
    });
  }
  ///////////////////
  // Sub-classes SHOULD leave these alone
  _checkProvider(X) {
    this.provider || Gn.throwError("missing provider", ce.errors.UNSUPPORTED_OPERATION, {
      operation: X || "_checkProvider"
    });
  }
  static isSigner(X) {
    return !!(X && X._isSigner);
  }
}
class lm extends hc {
  constructor(X, ee) {
    super(), ve(this, "address", X), ve(this, "provider", ee || null);
  }
  getAddress() {
    return Promise.resolve(this.address);
  }
  _fail(X, ee) {
    return Promise.resolve().then(() => {
      Gn.throwError(X, ce.errors.UNSUPPORTED_OPERATION, { operation: ee });
    });
  }
  signMessage(X) {
    return this._fail("VoidSigner cannot sign messages", "signMessage");
  }
  signTransaction(X) {
    return this._fail("VoidSigner cannot sign transactions", "signTransaction");
  }
  _signTypedData(X, ee, te) {
    return this._fail("VoidSigner cannot sign typed data", "signTypedData");
  }
  connect(X) {
    return new lm(this.address, X);
  }
}
var vE = {}, Lt = {}, uf = EE$1;
function EE$1(Y, X) {
  if (!Y)
    throw new Error(X || "Assertion failed");
}
EE$1.equal = function(Y, X, ee) {
  if (Y != X)
    throw new Error(ee || "Assertion failed: " + Y + " != " + X);
};
var $p = { exports: {} };
typeof Object.create == "function" ? $p.exports = function(Y, X) {
  X && (Y.super_ = X, Y.prototype = Object.create(X.prototype, {
    constructor: {
      value: Y,
      enumerable: !1,
      writable: !0,
      configurable: !0
    }
  }));
} : $p.exports = function(Y, X) {
  if (X) {
    Y.super_ = X;
    var ee = function() {
    };
    ee.prototype = X.prototype, Y.prototype = new ee(), Y.prototype.constructor = Y;
  }
};
var _E = $p.exports, NI = uf, kI = _E;
Lt.inherits = kI;
function MI(Y, X) {
  return (Y.charCodeAt(X) & 64512) !== 55296 || X < 0 || X + 1 >= Y.length ? !1 : (Y.charCodeAt(X + 1) & 64512) === 56320;
}
function LI(Y, X) {
  if (Array.isArray(Y))
    return Y.slice();
  if (!Y)
    return [];
  var ee = [];
  if (typeof Y == "string")
    if (X) {
      if (X === "hex")
        for (Y = Y.replace(/[^a-z0-9]+/ig, ""), Y.length % 2 !== 0 && (Y = "0" + Y), ne = 0; ne < Y.length; ne += 2)
          ee.push(parseInt(Y[ne] + Y[ne + 1], 16));
    } else
      for (var te = 0, ne = 0; ne < Y.length; ne++) {
        var ie = Y.charCodeAt(ne);
        ie < 128 ? ee[te++] = ie : ie < 2048 ? (ee[te++] = ie >> 6 | 192, ee[te++] = ie & 63 | 128) : MI(Y, ne) ? (ie = 65536 + ((ie & 1023) << 10) + (Y.charCodeAt(++ne) & 1023), ee[te++] = ie >> 18 | 240, ee[te++] = ie >> 12 & 63 | 128, ee[te++] = ie >> 6 & 63 | 128, ee[te++] = ie & 63 | 128) : (ee[te++] = ie >> 12 | 224, ee[te++] = ie >> 6 & 63 | 128, ee[te++] = ie & 63 | 128);
      }
  else
    for (ne = 0; ne < Y.length; ne++)
      ee[ne] = Y[ne] | 0;
  return ee;
}
Lt.toArray = LI;
function FI(Y) {
  for (var X = "", ee = 0; ee < Y.length; ee++)
    X += SE(Y[ee].toString(16));
  return X;
}
Lt.toHex = FI;
function AE(Y) {
  var X = Y >>> 24 | Y >>> 8 & 65280 | Y << 8 & 16711680 | (Y & 255) << 24;
  return X >>> 0;
}
Lt.htonl = AE;
function $I(Y, X) {
  for (var ee = "", te = 0; te < Y.length; te++) {
    var ne = Y[te];
    X === "little" && (ne = AE(ne)), ee += TE(ne.toString(16));
  }
  return ee;
}
Lt.toHex32 = $I;
function SE(Y) {
  return Y.length === 1 ? "0" + Y : Y;
}
Lt.zero2 = SE;
function TE(Y) {
  return Y.length === 7 ? "0" + Y : Y.length === 6 ? "00" + Y : Y.length === 5 ? "000" + Y : Y.length === 4 ? "0000" + Y : Y.length === 3 ? "00000" + Y : Y.length === 2 ? "000000" + Y : Y.length === 1 ? "0000000" + Y : Y;
}
Lt.zero8 = TE;
function DI(Y, X, ee, te) {
  var ne = ee - X;
  NI(ne % 4 === 0);
  for (var ie = new Array(ne / 4), oe = 0, se = X; oe < ie.length; oe++, se += 4) {
    var ae;
    te === "big" ? ae = Y[se] << 24 | Y[se + 1] << 16 | Y[se + 2] << 8 | Y[se + 3] : ae = Y[se + 3] << 24 | Y[se + 2] << 16 | Y[se + 1] << 8 | Y[se], ie[oe] = ae >>> 0;
  }
  return ie;
}
Lt.join32 = DI;
function UI(Y, X) {
  for (var ee = new Array(Y.length * 4), te = 0, ne = 0; te < Y.length; te++, ne += 4) {
    var ie = Y[te];
    X === "big" ? (ee[ne] = ie >>> 24, ee[ne + 1] = ie >>> 16 & 255, ee[ne + 2] = ie >>> 8 & 255, ee[ne + 3] = ie & 255) : (ee[ne + 3] = ie >>> 24, ee[ne + 2] = ie >>> 16 & 255, ee[ne + 1] = ie >>> 8 & 255, ee[ne] = ie & 255);
  }
  return ee;
}
Lt.split32 = UI;
function jI(Y, X) {
  return Y >>> X | Y << 32 - X;
}
Lt.rotr32 = jI;
function HI(Y, X) {
  return Y << X | Y >>> 32 - X;
}
Lt.rotl32 = HI;
function zI(Y, X) {
  return Y + X >>> 0;
}
Lt.sum32 = zI;
function qI(Y, X, ee) {
  return Y + X + ee >>> 0;
}
Lt.sum32_3 = qI;
function GI(Y, X, ee, te) {
  return Y + X + ee + te >>> 0;
}
Lt.sum32_4 = GI;
function VI(Y, X, ee, te, ne) {
  return Y + X + ee + te + ne >>> 0;
}
Lt.sum32_5 = VI;
function WI(Y, X, ee, te) {
  var ne = Y[X], ie = Y[X + 1], oe = te + ie >>> 0, se = (oe < te ? 1 : 0) + ee + ne;
  Y[X] = se >>> 0, Y[X + 1] = oe;
}
Lt.sum64 = WI;
function KI(Y, X, ee, te) {
  var ne = X + te >>> 0, ie = (ne < X ? 1 : 0) + Y + ee;
  return ie >>> 0;
}
Lt.sum64_hi = KI;
function JI(Y, X, ee, te) {
  var ne = X + te;
  return ne >>> 0;
}
Lt.sum64_lo = JI;
function YI(Y, X, ee, te, ne, ie, oe, se) {
  var ae = 0, ue = X;
  ue = ue + te >>> 0, ae += ue < X ? 1 : 0, ue = ue + ie >>> 0, ae += ue < ie ? 1 : 0, ue = ue + se >>> 0, ae += ue < se ? 1 : 0;
  var le = Y + ee + ne + oe + ae;
  return le >>> 0;
}
Lt.sum64_4_hi = YI;
function XI(Y, X, ee, te, ne, ie, oe, se) {
  var ae = X + te + ie + se;
  return ae >>> 0;
}
Lt.sum64_4_lo = XI;
function ZI(Y, X, ee, te, ne, ie, oe, se, ae, ue) {
  var le = 0, he = X;
  he = he + te >>> 0, le += he < X ? 1 : 0, he = he + ie >>> 0, le += he < ie ? 1 : 0, he = he + se >>> 0, le += he < se ? 1 : 0, he = he + ue >>> 0, le += he < ue ? 1 : 0;
  var me = Y + ee + ne + oe + ae + le;
  return me >>> 0;
}
Lt.sum64_5_hi = ZI;
function QI(Y, X, ee, te, ne, ie, oe, se, ae, ue) {
  var le = X + te + ie + se + ue;
  return le >>> 0;
}
Lt.sum64_5_lo = QI;
function eR(Y, X, ee) {
  var te = X << 32 - ee | Y >>> ee;
  return te >>> 0;
}
Lt.rotr64_hi = eR;
function tR(Y, X, ee) {
  var te = Y << 32 - ee | X >>> ee;
  return te >>> 0;
}
Lt.rotr64_lo = tR;
function rR(Y, X, ee) {
  return Y >>> ee;
}
Lt.shr64_hi = rR;
function nR(Y, X, ee) {
  var te = Y << 32 - ee | X >>> ee;
  return te >>> 0;
}
Lt.shr64_lo = nR;
var pc = {}, hx = Lt, iR = uf;
function Td() {
  this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;
}
pc.BlockHash = Td;
Td.prototype.update = function(Y, X) {
  if (Y = hx.toArray(Y, X), this.pending ? this.pending = this.pending.concat(Y) : this.pending = Y, this.pendingTotal += Y.length, this.pending.length >= this._delta8) {
    Y = this.pending;
    var ee = Y.length % this._delta8;
    this.pending = Y.slice(Y.length - ee, Y.length), this.pending.length === 0 && (this.pending = null), Y = hx.join32(Y, 0, Y.length - ee, this.endian);
    for (var te = 0; te < Y.length; te += this._delta32)
      this._update(Y, te, te + this._delta32);
  }
  return this;
};
Td.prototype.digest = function(Y) {
  return this.update(this._pad()), iR(this.pending === null), this._digest(Y);
};
Td.prototype._pad = function() {
  var Y = this.pendingTotal, X = this._delta8, ee = X - (Y + this.padLength) % X, te = new Array(ee + this.padLength);
  te[0] = 128;
  for (var ne = 1; ne < ee; ne++)
    te[ne] = 0;
  if (Y <<= 3, this.endian === "big") {
    for (var ie = 8; ie < this.padLength; ie++)
      te[ne++] = 0;
    te[ne++] = 0, te[ne++] = 0, te[ne++] = 0, te[ne++] = 0, te[ne++] = Y >>> 24 & 255, te[ne++] = Y >>> 16 & 255, te[ne++] = Y >>> 8 & 255, te[ne++] = Y & 255;
  } else
    for (te[ne++] = Y & 255, te[ne++] = Y >>> 8 & 255, te[ne++] = Y >>> 16 & 255, te[ne++] = Y >>> 24 & 255, te[ne++] = 0, te[ne++] = 0, te[ne++] = 0, te[ne++] = 0, ie = 8; ie < this.padLength; ie++)
      te[ne++] = 0;
  return te;
};
var gc = {}, rs = {}, sR = Lt, Vi = sR.rotr32;
function oR(Y, X, ee, te) {
  if (Y === 0)
    return IE(X, ee, te);
  if (Y === 1 || Y === 3)
    return CE(X, ee, te);
  if (Y === 2)
    return RE(X, ee, te);
}
rs.ft_1 = oR;
function IE(Y, X, ee) {
  return Y & X ^ ~Y & ee;
}
rs.ch32 = IE;
function RE(Y, X, ee) {
  return Y & X ^ Y & ee ^ X & ee;
}
rs.maj32 = RE;
function CE(Y, X, ee) {
  return Y ^ X ^ ee;
}
rs.p32 = CE;
function aR(Y) {
  return Vi(Y, 2) ^ Vi(Y, 13) ^ Vi(Y, 22);
}
rs.s0_256 = aR;
function cR(Y) {
  return Vi(Y, 6) ^ Vi(Y, 11) ^ Vi(Y, 25);
}
rs.s1_256 = cR;
function uR(Y) {
  return Vi(Y, 7) ^ Vi(Y, 18) ^ Y >>> 3;
}
rs.g0_256 = uR;
function fR(Y) {
  return Vi(Y, 17) ^ Vi(Y, 19) ^ Y >>> 10;
}
rs.g1_256 = fR;
var za = Lt, lR = pc, dR = rs, Q0 = za.rotl32, Fc = za.sum32, hR = za.sum32_5, pR = dR.ft_1, PE = lR.BlockHash, gR = [
  1518500249,
  1859775393,
  2400959708,
  3395469782
];
function Xi() {
  if (!(this instanceof Xi))
    return new Xi();
  PE.call(this), this.h = [
    1732584193,
    4023233417,
    2562383102,
    271733878,
    3285377520
  ], this.W = new Array(80);
}
za.inherits(Xi, PE);
var mR = Xi;
Xi.blockSize = 512;
Xi.outSize = 160;
Xi.hmacStrength = 80;
Xi.padLength = 64;
Xi.prototype._update = function(Y, X) {
  for (var ee = this.W, te = 0; te < 16; te++)
    ee[te] = Y[X + te];
  for (; te < ee.length; te++)
    ee[te] = Q0(ee[te - 3] ^ ee[te - 8] ^ ee[te - 14] ^ ee[te - 16], 1);
  var ne = this.h[0], ie = this.h[1], oe = this.h[2], se = this.h[3], ae = this.h[4];
  for (te = 0; te < ee.length; te++) {
    var ue = ~~(te / 20), le = hR(Q0(ne, 5), pR(ue, ie, oe, se), ae, ee[te], gR[ue]);
    ae = se, se = oe, oe = Q0(ie, 30), ie = ne, ne = le;
  }
  this.h[0] = Fc(this.h[0], ne), this.h[1] = Fc(this.h[1], ie), this.h[2] = Fc(this.h[2], oe), this.h[3] = Fc(this.h[3], se), this.h[4] = Fc(this.h[4], ae);
};
Xi.prototype._digest = function(Y) {
  return Y === "hex" ? za.toHex32(this.h, "big") : za.split32(this.h, "big");
};
var qa = Lt, yR = pc, mc = rs, bR = uf, ui = qa.sum32, xR = qa.sum32_4, wR = qa.sum32_5, vR = mc.ch32, ER = mc.maj32, _R = mc.s0_256, AR = mc.s1_256, SR = mc.g0_256, TR = mc.g1_256, OE = yR.BlockHash, IR = [
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
];
function Zi() {
  if (!(this instanceof Zi))
    return new Zi();
  OE.call(this), this.h = [
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ], this.k = IR, this.W = new Array(64);
}
qa.inherits(Zi, OE);
var BE = Zi;
Zi.blockSize = 512;
Zi.outSize = 256;
Zi.hmacStrength = 192;
Zi.padLength = 64;
Zi.prototype._update = function(Y, X) {
  for (var ee = this.W, te = 0; te < 16; te++)
    ee[te] = Y[X + te];
  for (; te < ee.length; te++)
    ee[te] = xR(TR(ee[te - 2]), ee[te - 7], SR(ee[te - 15]), ee[te - 16]);
  var ne = this.h[0], ie = this.h[1], oe = this.h[2], se = this.h[3], ae = this.h[4], ue = this.h[5], le = this.h[6], he = this.h[7];
  for (bR(this.k.length === ee.length), te = 0; te < ee.length; te++) {
    var me = wR(he, AR(ae), vR(ae, ue, le), this.k[te], ee[te]), ye = ui(_R(ne), ER(ne, ie, oe));
    he = le, le = ue, ue = ae, ae = ui(se, me), se = oe, oe = ie, ie = ne, ne = ui(me, ye);
  }
  this.h[0] = ui(this.h[0], ne), this.h[1] = ui(this.h[1], ie), this.h[2] = ui(this.h[2], oe), this.h[3] = ui(this.h[3], se), this.h[4] = ui(this.h[4], ae), this.h[5] = ui(this.h[5], ue), this.h[6] = ui(this.h[6], le), this.h[7] = ui(this.h[7], he);
};
Zi.prototype._digest = function(Y) {
  return Y === "hex" ? qa.toHex32(this.h, "big") : qa.split32(this.h, "big");
};
var Dp = Lt, NE = BE;
function Is() {
  if (!(this instanceof Is))
    return new Is();
  NE.call(this), this.h = [
    3238371032,
    914150663,
    812702999,
    4144912697,
    4290775857,
    1750603025,
    1694076839,
    3204075428
  ];
}
Dp.inherits(Is, NE);
var RR = Is;
Is.blockSize = 512;
Is.outSize = 224;
Is.hmacStrength = 192;
Is.padLength = 64;
Is.prototype._digest = function(Y) {
  return Y === "hex" ? Dp.toHex32(this.h.slice(0, 7), "big") : Dp.split32(this.h.slice(0, 7), "big");
};
var Pn = Lt, CR = pc, PR = uf, Wi = Pn.rotr64_hi, Ki = Pn.rotr64_lo, kE = Pn.shr64_hi, ME = Pn.shr64_lo, Us = Pn.sum64, eh = Pn.sum64_hi, th = Pn.sum64_lo, OR = Pn.sum64_4_hi, BR = Pn.sum64_4_lo, NR = Pn.sum64_5_hi, kR = Pn.sum64_5_lo, LE = CR.BlockHash, MR = [
  1116352408,
  3609767458,
  1899447441,
  602891725,
  3049323471,
  3964484399,
  3921009573,
  2173295548,
  961987163,
  4081628472,
  1508970993,
  3053834265,
  2453635748,
  2937671579,
  2870763221,
  3664609560,
  3624381080,
  2734883394,
  310598401,
  1164996542,
  607225278,
  1323610764,
  1426881987,
  3590304994,
  1925078388,
  4068182383,
  2162078206,
  991336113,
  2614888103,
  633803317,
  3248222580,
  3479774868,
  3835390401,
  2666613458,
  4022224774,
  944711139,
  264347078,
  2341262773,
  604807628,
  2007800933,
  770255983,
  1495990901,
  1249150122,
  1856431235,
  1555081692,
  3175218132,
  1996064986,
  2198950837,
  2554220882,
  3999719339,
  2821834349,
  766784016,
  2952996808,
  2566594879,
  3210313671,
  3203337956,
  3336571891,
  1034457026,
  3584528711,
  2466948901,
  113926993,
  3758326383,
  338241895,
  168717936,
  666307205,
  1188179964,
  773529912,
  1546045734,
  1294757372,
  1522805485,
  1396182291,
  2643833823,
  1695183700,
  2343527390,
  1986661051,
  1014477480,
  2177026350,
  1206759142,
  2456956037,
  344077627,
  2730485921,
  1290863460,
  2820302411,
  3158454273,
  3259730800,
  3505952657,
  3345764771,
  106217008,
  3516065817,
  3606008344,
  3600352804,
  1432725776,
  4094571909,
  1467031594,
  275423344,
  851169720,
  430227734,
  3100823752,
  506948616,
  1363258195,
  659060556,
  3750685593,
  883997877,
  3785050280,
  958139571,
  3318307427,
  1322822218,
  3812723403,
  1537002063,
  2003034995,
  1747873779,
  3602036899,
  1955562222,
  1575990012,
  2024104815,
  1125592928,
  2227730452,
  2716904306,
  2361852424,
  442776044,
  2428436474,
  593698344,
  2756734187,
  3733110249,
  3204031479,
  2999351573,
  3329325298,
  3815920427,
  3391569614,
  3928383900,
  3515267271,
  566280711,
  3940187606,
  3454069534,
  4118630271,
  4000239992,
  116418474,
  1914138554,
  174292421,
  2731055270,
  289380356,
  3203993006,
  460393269,
  320620315,
  685471733,
  587496836,
  852142971,
  1086792851,
  1017036298,
  365543100,
  1126000580,
  2618297676,
  1288033470,
  3409855158,
  1501505948,
  4234509866,
  1607167915,
  987167468,
  1816402316,
  1246189591
];
function xi() {
  if (!(this instanceof xi))
    return new xi();
  LE.call(this), this.h = [
    1779033703,
    4089235720,
    3144134277,
    2227873595,
    1013904242,
    4271175723,
    2773480762,
    1595750129,
    1359893119,
    2917565137,
    2600822924,
    725511199,
    528734635,
    4215389547,
    1541459225,
    327033209
  ], this.k = MR, this.W = new Array(160);
}
Pn.inherits(xi, LE);
var FE = xi;
xi.blockSize = 1024;
xi.outSize = 512;
xi.hmacStrength = 192;
xi.padLength = 128;
xi.prototype._prepareBlock = function(Y, X) {
  for (var ee = this.W, te = 0; te < 32; te++)
    ee[te] = Y[X + te];
  for (; te < ee.length; te += 2) {
    var ne = VR(ee[te - 4], ee[te - 3]), ie = WR(ee[te - 4], ee[te - 3]), oe = ee[te - 14], se = ee[te - 13], ae = qR(ee[te - 30], ee[te - 29]), ue = GR(ee[te - 30], ee[te - 29]), le = ee[te - 32], he = ee[te - 31];
    ee[te] = OR(
      ne,
      ie,
      oe,
      se,
      ae,
      ue,
      le,
      he
    ), ee[te + 1] = BR(
      ne,
      ie,
      oe,
      se,
      ae,
      ue,
      le,
      he
    );
  }
};
xi.prototype._update = function(Y, X) {
  this._prepareBlock(Y, X);
  var ee = this.W, te = this.h[0], ne = this.h[1], ie = this.h[2], oe = this.h[3], se = this.h[4], ae = this.h[5], ue = this.h[6], le = this.h[7], he = this.h[8], me = this.h[9], ye = this.h[10], we = this.h[11], Ee = this.h[12], Re = this.h[13], Ue = this.h[14], Me = this.h[15];
  PR(this.k.length === ee.length);
  for (var De = 0; De < ee.length; De += 2) {
    var Fe = Ue, Ke = Me, tt = HR(he, me), rt = zR(he, me), it = LR(he, me, ye, we, Ee), _t = FR(he, me, ye, we, Ee, Re), Dt = this.k[De], je = this.k[De + 1], ze = ee[De], fe = ee[De + 1], de = NR(
      Fe,
      Ke,
      tt,
      rt,
      it,
      _t,
      Dt,
      je,
      ze,
      fe
    ), be = kR(
      Fe,
      Ke,
      tt,
      rt,
      it,
      _t,
      Dt,
      je,
      ze,
      fe
    );
    Fe = UR(te, ne), Ke = jR(te, ne), tt = $R(te, ne, ie, oe, se), rt = DR(te, ne, ie, oe, se, ae);
    var Te = eh(Fe, Ke, tt, rt), Ce = th(Fe, Ke, tt, rt);
    Ue = Ee, Me = Re, Ee = ye, Re = we, ye = he, we = me, he = eh(ue, le, de, be), me = th(le, le, de, be), ue = se, le = ae, se = ie, ae = oe, ie = te, oe = ne, te = eh(de, be, Te, Ce), ne = th(de, be, Te, Ce);
  }
  Us(this.h, 0, te, ne), Us(this.h, 2, ie, oe), Us(this.h, 4, se, ae), Us(this.h, 6, ue, le), Us(this.h, 8, he, me), Us(this.h, 10, ye, we), Us(this.h, 12, Ee, Re), Us(this.h, 14, Ue, Me);
};
xi.prototype._digest = function(Y) {
  return Y === "hex" ? Pn.toHex32(this.h, "big") : Pn.split32(this.h, "big");
};
function LR(Y, X, ee, te, ne) {
  var ie = Y & ee ^ ~Y & ne;
  return ie < 0 && (ie += 4294967296), ie;
}
function FR(Y, X, ee, te, ne, ie) {
  var oe = X & te ^ ~X & ie;
  return oe < 0 && (oe += 4294967296), oe;
}
function $R(Y, X, ee, te, ne) {
  var ie = Y & ee ^ Y & ne ^ ee & ne;
  return ie < 0 && (ie += 4294967296), ie;
}
function DR(Y, X, ee, te, ne, ie) {
  var oe = X & te ^ X & ie ^ te & ie;
  return oe < 0 && (oe += 4294967296), oe;
}
function UR(Y, X) {
  var ee = Wi(Y, X, 28), te = Wi(X, Y, 2), ne = Wi(X, Y, 7), ie = ee ^ te ^ ne;
  return ie < 0 && (ie += 4294967296), ie;
}
function jR(Y, X) {
  var ee = Ki(Y, X, 28), te = Ki(X, Y, 2), ne = Ki(X, Y, 7), ie = ee ^ te ^ ne;
  return ie < 0 && (ie += 4294967296), ie;
}
function HR(Y, X) {
  var ee = Wi(Y, X, 14), te = Wi(Y, X, 18), ne = Wi(X, Y, 9), ie = ee ^ te ^ ne;
  return ie < 0 && (ie += 4294967296), ie;
}
function zR(Y, X) {
  var ee = Ki(Y, X, 14), te = Ki(Y, X, 18), ne = Ki(X, Y, 9), ie = ee ^ te ^ ne;
  return ie < 0 && (ie += 4294967296), ie;
}
function qR(Y, X) {
  var ee = Wi(Y, X, 1), te = Wi(Y, X, 8), ne = kE(Y, X, 7), ie = ee ^ te ^ ne;
  return ie < 0 && (ie += 4294967296), ie;
}
function GR(Y, X) {
  var ee = Ki(Y, X, 1), te = Ki(Y, X, 8), ne = ME(Y, X, 7), ie = ee ^ te ^ ne;
  return ie < 0 && (ie += 4294967296), ie;
}
function VR(Y, X) {
  var ee = Wi(Y, X, 19), te = Wi(X, Y, 29), ne = kE(Y, X, 6), ie = ee ^ te ^ ne;
  return ie < 0 && (ie += 4294967296), ie;
}
function WR(Y, X) {
  var ee = Ki(Y, X, 19), te = Ki(X, Y, 29), ne = ME(Y, X, 6), ie = ee ^ te ^ ne;
  return ie < 0 && (ie += 4294967296), ie;
}
var Up = Lt, $E = FE;
function Rs() {
  if (!(this instanceof Rs))
    return new Rs();
  $E.call(this), this.h = [
    3418070365,
    3238371032,
    1654270250,
    914150663,
    2438529370,
    812702999,
    355462360,
    4144912697,
    1731405415,
    4290775857,
    2394180231,
    1750603025,
    3675008525,
    1694076839,
    1203062813,
    3204075428
  ];
}
Up.inherits(Rs, $E);
var KR = Rs;
Rs.blockSize = 1024;
Rs.outSize = 384;
Rs.hmacStrength = 192;
Rs.padLength = 128;
Rs.prototype._digest = function(Y) {
  return Y === "hex" ? Up.toHex32(this.h.slice(0, 12), "big") : Up.split32(this.h.slice(0, 12), "big");
};
gc.sha1 = mR;
gc.sha224 = RR;
gc.sha256 = BE;
gc.sha384 = KR;
gc.sha512 = FE;
var DE = {}, No = Lt, JR = pc, Uf = No.rotl32, px = No.sum32, $c = No.sum32_3, gx = No.sum32_4, UE = JR.BlockHash;
function Qi() {
  if (!(this instanceof Qi))
    return new Qi();
  UE.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little";
}
No.inherits(Qi, UE);
DE.ripemd160 = Qi;
Qi.blockSize = 512;
Qi.outSize = 160;
Qi.hmacStrength = 192;
Qi.padLength = 64;
Qi.prototype._update = function(Y, X) {
  for (var ee = this.h[0], te = this.h[1], ne = this.h[2], ie = this.h[3], oe = this.h[4], se = ee, ae = te, ue = ne, le = ie, he = oe, me = 0; me < 80; me++) {
    var ye = px(
      Uf(
        gx(ee, mx(me, te, ne, ie), Y[ZR[me] + X], YR(me)),
        eC[me]
      ),
      oe
    );
    ee = oe, oe = ie, ie = Uf(ne, 10), ne = te, te = ye, ye = px(
      Uf(
        gx(se, mx(79 - me, ae, ue, le), Y[QR[me] + X], XR(me)),
        tC[me]
      ),
      he
    ), se = he, he = le, le = Uf(ue, 10), ue = ae, ae = ye;
  }
  ye = $c(this.h[1], ne, le), this.h[1] = $c(this.h[2], ie, he), this.h[2] = $c(this.h[3], oe, se), this.h[3] = $c(this.h[4], ee, ae), this.h[4] = $c(this.h[0], te, ue), this.h[0] = ye;
};
Qi.prototype._digest = function(Y) {
  return Y === "hex" ? No.toHex32(this.h, "little") : No.split32(this.h, "little");
};
function mx(Y, X, ee, te) {
  return Y <= 15 ? X ^ ee ^ te : Y <= 31 ? X & ee | ~X & te : Y <= 47 ? (X | ~ee) ^ te : Y <= 63 ? X & te | ee & ~te : X ^ (ee | ~te);
}
function YR(Y) {
  return Y <= 15 ? 0 : Y <= 31 ? 1518500249 : Y <= 47 ? 1859775393 : Y <= 63 ? 2400959708 : 2840853838;
}
function XR(Y) {
  return Y <= 15 ? 1352829926 : Y <= 31 ? 1548603684 : Y <= 47 ? 1836072691 : Y <= 63 ? 2053994217 : 0;
}
var ZR = [
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  7,
  4,
  13,
  1,
  10,
  6,
  15,
  3,
  12,
  0,
  9,
  5,
  2,
  14,
  11,
  8,
  3,
  10,
  14,
  4,
  9,
  15,
  8,
  1,
  2,
  7,
  0,
  6,
  13,
  11,
  5,
  12,
  1,
  9,
  11,
  10,
  0,
  8,
  12,
  4,
  13,
  3,
  7,
  15,
  14,
  5,
  6,
  2,
  4,
  0,
  5,
  9,
  7,
  12,
  2,
  10,
  14,
  1,
  3,
  8,
  11,
  6,
  15,
  13
], QR = [
  5,
  14,
  7,
  0,
  9,
  2,
  11,
  4,
  13,
  6,
  15,
  8,
  1,
  10,
  3,
  12,
  6,
  11,
  3,
  7,
  0,
  13,
  5,
  10,
  14,
  15,
  8,
  12,
  4,
  9,
  1,
  2,
  15,
  5,
  1,
  3,
  7,
  14,
  6,
  9,
  11,
  8,
  12,
  2,
  10,
  0,
  4,
  13,
  8,
  6,
  4,
  1,
  3,
  11,
  15,
  0,
  5,
  12,
  2,
  13,
  9,
  7,
  10,
  14,
  12,
  15,
  10,
  4,
  1,
  5,
  8,
  7,
  6,
  2,
  13,
  14,
  0,
  3,
  9,
  11
], eC = [
  11,
  14,
  15,
  12,
  5,
  8,
  7,
  9,
  11,
  13,
  14,
  15,
  6,
  7,
  9,
  8,
  7,
  6,
  8,
  13,
  11,
  9,
  7,
  15,
  7,
  12,
  15,
  9,
  11,
  7,
  13,
  12,
  11,
  13,
  6,
  7,
  14,
  9,
  13,
  15,
  14,
  8,
  13,
  6,
  5,
  12,
  7,
  5,
  11,
  12,
  14,
  15,
  14,
  15,
  9,
  8,
  9,
  14,
  5,
  6,
  8,
  6,
  5,
  12,
  9,
  15,
  5,
  11,
  6,
  8,
  13,
  12,
  5,
  12,
  13,
  14,
  11,
  8,
  5,
  6
], tC = [
  8,
  9,
  9,
  11,
  13,
  15,
  15,
  5,
  7,
  7,
  8,
  11,
  14,
  14,
  12,
  6,
  9,
  13,
  15,
  7,
  12,
  8,
  9,
  11,
  7,
  7,
  12,
  7,
  6,
  15,
  13,
  11,
  9,
  7,
  15,
  11,
  8,
  6,
  6,
  14,
  12,
  13,
  5,
  14,
  13,
  13,
  7,
  5,
  15,
  5,
  8,
  11,
  14,
  14,
  6,
  14,
  6,
  9,
  12,
  9,
  12,
  5,
  15,
  8,
  8,
  5,
  12,
  9,
  12,
  5,
  14,
  6,
  8,
  13,
  6,
  5,
  15,
  13,
  11,
  11
], rC = Lt, nC = uf;
function Ga(Y, X, ee) {
  if (!(this instanceof Ga))
    return new Ga(Y, X, ee);
  this.Hash = Y, this.blockSize = Y.blockSize / 8, this.outSize = Y.outSize / 8, this.inner = null, this.outer = null, this._init(rC.toArray(X, ee));
}
var iC = Ga;
Ga.prototype._init = function(Y) {
  Y.length > this.blockSize && (Y = new this.Hash().update(Y).digest()), nC(Y.length <= this.blockSize);
  for (var X = Y.length; X < this.blockSize; X++)
    Y.push(0);
  for (X = 0; X < Y.length; X++)
    Y[X] ^= 54;
  for (this.inner = new this.Hash().update(Y), X = 0; X < Y.length; X++)
    Y[X] ^= 106;
  this.outer = new this.Hash().update(Y);
};
Ga.prototype.update = function(Y, X) {
  return this.inner.update(Y, X), this;
};
Ga.prototype.digest = function(Y) {
  return this.outer.update(this.inner.digest()), this.outer.digest(Y);
};
(function(Y) {
  var X = Y;
  X.utils = Lt, X.common = pc, X.sha = gc, X.ripemd = DE, X.hmac = iC, X.sha1 = X.sha.sha1, X.sha256 = X.sha.sha256, X.sha224 = X.sha.sha224, X.sha384 = X.sha.sha384, X.sha512 = X.sha.sha512, X.ripemd160 = X.ripemd.ripemd160;
})(vE);
const kn = /* @__PURE__ */ uc(vE);
function yc(Y, X, ee) {
  return ee = {
    path: X,
    exports: {},
    require: function(te, ne) {
      return sC(te, ne ?? ee.path);
    }
  }, Y(ee, ee.exports), ee.exports;
}
function sC() {
  throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
}
var dm = jE;
function jE(Y, X) {
  if (!Y)
    throw new Error(X || "Assertion failed");
}
jE.equal = function(Y, X, ee) {
  if (Y != X)
    throw new Error(ee || "Assertion failed: " + Y + " != " + X);
};
var yi = yc(function(Y, X) {
  var ee = X;
  function te(oe, se) {
    if (Array.isArray(oe))
      return oe.slice();
    if (!oe)
      return [];
    var ae = [];
    if (typeof oe != "string") {
      for (var ue = 0; ue < oe.length; ue++)
        ae[ue] = oe[ue] | 0;
      return ae;
    }
    if (se === "hex") {
      oe = oe.replace(/[^a-z0-9]+/ig, ""), oe.length % 2 !== 0 && (oe = "0" + oe);
      for (var ue = 0; ue < oe.length; ue += 2)
        ae.push(parseInt(oe[ue] + oe[ue + 1], 16));
    } else
      for (var ue = 0; ue < oe.length; ue++) {
        var le = oe.charCodeAt(ue), he = le >> 8, me = le & 255;
        he ? ae.push(he, me) : ae.push(me);
      }
    return ae;
  }
  ee.toArray = te;
  function ne(oe) {
    return oe.length === 1 ? "0" + oe : oe;
  }
  ee.zero2 = ne;
  function ie(oe) {
    for (var se = "", ae = 0; ae < oe.length; ae++)
      se += ne(oe[ae].toString(16));
    return se;
  }
  ee.toHex = ie, ee.encode = function(oe, se) {
    return se === "hex" ? ie(oe) : oe;
  };
}), jn = yc(function(Y, X) {
  var ee = X;
  ee.assert = dm, ee.toArray = yi.toArray, ee.zero2 = yi.zero2, ee.toHex = yi.toHex, ee.encode = yi.encode;
  function te(ae, ue, le) {
    var he = new Array(Math.max(ae.bitLength(), le) + 1);
    he.fill(0);
    for (var me = 1 << ue + 1, ye = ae.clone(), we = 0; we < he.length; we++) {
      var Ee, Re = ye.andln(me - 1);
      ye.isOdd() ? (Re > (me >> 1) - 1 ? Ee = (me >> 1) - Re : Ee = Re, ye.isubn(Ee)) : Ee = 0, he[we] = Ee, ye.iushrn(1);
    }
    return he;
  }
  ee.getNAF = te;
  function ne(ae, ue) {
    var le = [
      [],
      []
    ];
    ae = ae.clone(), ue = ue.clone();
    for (var he = 0, me = 0, ye; ae.cmpn(-he) > 0 || ue.cmpn(-me) > 0; ) {
      var we = ae.andln(3) + he & 3, Ee = ue.andln(3) + me & 3;
      we === 3 && (we = -1), Ee === 3 && (Ee = -1);
      var Re;
      we & 1 ? (ye = ae.andln(7) + he & 7, (ye === 3 || ye === 5) && Ee === 2 ? Re = -we : Re = we) : Re = 0, le[0].push(Re);
      var Ue;
      Ee & 1 ? (ye = ue.andln(7) + me & 7, (ye === 3 || ye === 5) && we === 2 ? Ue = -Ee : Ue = Ee) : Ue = 0, le[1].push(Ue), 2 * he === Re + 1 && (he = 1 - he), 2 * me === Ue + 1 && (me = 1 - me), ae.iushrn(1), ue.iushrn(1);
    }
    return le;
  }
  ee.getJSF = ne;
  function ie(ae, ue, le) {
    var he = "_" + ue;
    ae.prototype[ue] = function() {
      return this[he] !== void 0 ? this[he] : this[he] = le.call(this);
    };
  }
  ee.cachedProperty = ie;
  function oe(ae) {
    return typeof ae == "string" ? ee.toArray(ae, "hex") : ae;
  }
  ee.parseBytes = oe;
  function se(ae) {
    return new bt(ae, "hex", "le");
  }
  ee.intFromLE = se;
}), Ll = jn.getNAF, oC = jn.getJSF, Fl = jn.assert;
function po(Y, X) {
  this.type = Y, this.p = new bt(X.p, 16), this.red = X.prime ? bt.red(X.prime) : bt.mont(this.p), this.zero = new bt(0).toRed(this.red), this.one = new bt(1).toRed(this.red), this.two = new bt(2).toRed(this.red), this.n = X.n && new bt(X.n, 16), this.g = X.g && this.pointFromJSON(X.g, X.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
  var ee = this.n && this.p.div(this.n);
  !ee || ee.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = !0, this.redN = this.n.toRed(this.red));
}
var Ko = po;
po.prototype.point = function() {
  throw new Error("Not implemented");
};
po.prototype.validate = function() {
  throw new Error("Not implemented");
};
po.prototype._fixedNafMul = function(Y, X) {
  Fl(Y.precomputed);
  var ee = Y._getDoubles(), te = Ll(X, 1, this._bitLength), ne = (1 << ee.step + 1) - (ee.step % 2 === 0 ? 2 : 1);
  ne /= 3;
  var ie = [], oe, se;
  for (oe = 0; oe < te.length; oe += ee.step) {
    se = 0;
    for (var ae = oe + ee.step - 1; ae >= oe; ae--)
      se = (se << 1) + te[ae];
    ie.push(se);
  }
  for (var ue = this.jpoint(null, null, null), le = this.jpoint(null, null, null), he = ne; he > 0; he--) {
    for (oe = 0; oe < ie.length; oe++)
      se = ie[oe], se === he ? le = le.mixedAdd(ee.points[oe]) : se === -he && (le = le.mixedAdd(ee.points[oe].neg()));
    ue = ue.add(le);
  }
  return ue.toP();
};
po.prototype._wnafMul = function(Y, X) {
  var ee = 4, te = Y._getNAFPoints(ee);
  ee = te.wnd;
  for (var ne = te.points, ie = Ll(X, ee, this._bitLength), oe = this.jpoint(null, null, null), se = ie.length - 1; se >= 0; se--) {
    for (var ae = 0; se >= 0 && ie[se] === 0; se--)
      ae++;
    if (se >= 0 && ae++, oe = oe.dblp(ae), se < 0)
      break;
    var ue = ie[se];
    Fl(ue !== 0), Y.type === "affine" ? ue > 0 ? oe = oe.mixedAdd(ne[ue - 1 >> 1]) : oe = oe.mixedAdd(ne[-ue - 1 >> 1].neg()) : ue > 0 ? oe = oe.add(ne[ue - 1 >> 1]) : oe = oe.add(ne[-ue - 1 >> 1].neg());
  }
  return Y.type === "affine" ? oe.toP() : oe;
};
po.prototype._wnafMulAdd = function(Y, X, ee, te, ne) {
  var ie = this._wnafT1, oe = this._wnafT2, se = this._wnafT3, ae = 0, ue, le, he;
  for (ue = 0; ue < te; ue++) {
    he = X[ue];
    var me = he._getNAFPoints(Y);
    ie[ue] = me.wnd, oe[ue] = me.points;
  }
  for (ue = te - 1; ue >= 1; ue -= 2) {
    var ye = ue - 1, we = ue;
    if (ie[ye] !== 1 || ie[we] !== 1) {
      se[ye] = Ll(ee[ye], ie[ye], this._bitLength), se[we] = Ll(ee[we], ie[we], this._bitLength), ae = Math.max(se[ye].length, ae), ae = Math.max(se[we].length, ae);
      continue;
    }
    var Ee = [
      X[ye],
      /* 1 */
      null,
      /* 3 */
      null,
      /* 5 */
      X[we]
      /* 7 */
    ];
    X[ye].y.cmp(X[we].y) === 0 ? (Ee[1] = X[ye].add(X[we]), Ee[2] = X[ye].toJ().mixedAdd(X[we].neg())) : X[ye].y.cmp(X[we].y.redNeg()) === 0 ? (Ee[1] = X[ye].toJ().mixedAdd(X[we]), Ee[2] = X[ye].add(X[we].neg())) : (Ee[1] = X[ye].toJ().mixedAdd(X[we]), Ee[2] = X[ye].toJ().mixedAdd(X[we].neg()));
    var Re = [
      -3,
      /* -1 -1 */
      -1,
      /* -1 0 */
      -5,
      /* -1 1 */
      -7,
      /* 0 -1 */
      0,
      /* 0 0 */
      7,
      /* 0 1 */
      5,
      /* 1 -1 */
      1,
      /* 1 0 */
      3
      /* 1 1 */
    ], Ue = oC(ee[ye], ee[we]);
    for (ae = Math.max(Ue[0].length, ae), se[ye] = new Array(ae), se[we] = new Array(ae), le = 0; le < ae; le++) {
      var Me = Ue[0][le] | 0, De = Ue[1][le] | 0;
      se[ye][le] = Re[(Me + 1) * 3 + (De + 1)], se[we][le] = 0, oe[ye] = Ee;
    }
  }
  var Fe = this.jpoint(null, null, null), Ke = this._wnafT4;
  for (ue = ae; ue >= 0; ue--) {
    for (var tt = 0; ue >= 0; ) {
      var rt = !0;
      for (le = 0; le < te; le++)
        Ke[le] = se[le][ue] | 0, Ke[le] !== 0 && (rt = !1);
      if (!rt)
        break;
      tt++, ue--;
    }
    if (ue >= 0 && tt++, Fe = Fe.dblp(tt), ue < 0)
      break;
    for (le = 0; le < te; le++) {
      var it = Ke[le];
      it !== 0 && (it > 0 ? he = oe[le][it - 1 >> 1] : it < 0 && (he = oe[le][-it - 1 >> 1].neg()), he.type === "affine" ? Fe = Fe.mixedAdd(he) : Fe = Fe.add(he));
    }
  }
  for (ue = 0; ue < te; ue++)
    oe[ue] = null;
  return ne ? Fe : Fe.toP();
};
function ii(Y, X) {
  this.curve = Y, this.type = X, this.precomputed = null;
}
po.BasePoint = ii;
ii.prototype.eq = function() {
  throw new Error("Not implemented");
};
ii.prototype.validate = function() {
  return this.curve.validate(this);
};
po.prototype.decodePoint = function(Y, X) {
  Y = jn.toArray(Y, X);
  var ee = this.p.byteLength();
  if ((Y[0] === 4 || Y[0] === 6 || Y[0] === 7) && Y.length - 1 === 2 * ee) {
    Y[0] === 6 ? Fl(Y[Y.length - 1] % 2 === 0) : Y[0] === 7 && Fl(Y[Y.length - 1] % 2 === 1);
    var te = this.point(
      Y.slice(1, 1 + ee),
      Y.slice(1 + ee, 1 + 2 * ee)
    );
    return te;
  } else if ((Y[0] === 2 || Y[0] === 3) && Y.length - 1 === ee)
    return this.pointFromX(Y.slice(1, 1 + ee), Y[0] === 3);
  throw new Error("Unknown point format");
};
ii.prototype.encodeCompressed = function(Y) {
  return this.encode(Y, !0);
};
ii.prototype._encode = function(Y) {
  var X = this.curve.p.byteLength(), ee = this.getX().toArray("be", X);
  return Y ? [this.getY().isEven() ? 2 : 3].concat(ee) : [4].concat(ee, this.getY().toArray("be", X));
};
ii.prototype.encode = function(Y, X) {
  return jn.encode(this._encode(X), Y);
};
ii.prototype.precompute = function(Y) {
  if (this.precomputed)
    return this;
  var X = {
    doubles: null,
    naf: null,
    beta: null
  };
  return X.naf = this._getNAFPoints(8), X.doubles = this._getDoubles(4, Y), X.beta = this._getBeta(), this.precomputed = X, this;
};
ii.prototype._hasDoubles = function(Y) {
  if (!this.precomputed)
    return !1;
  var X = this.precomputed.doubles;
  return X ? X.points.length >= Math.ceil((Y.bitLength() + 1) / X.step) : !1;
};
ii.prototype._getDoubles = function(Y, X) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;
  for (var ee = [this], te = this, ne = 0; ne < X; ne += Y) {
    for (var ie = 0; ie < Y; ie++)
      te = te.dbl();
    ee.push(te);
  }
  return {
    step: Y,
    points: ee
  };
};
ii.prototype._getNAFPoints = function(Y) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;
  for (var X = [this], ee = (1 << Y) - 1, te = ee === 1 ? null : this.dbl(), ne = 1; ne < ee; ne++)
    X[ne] = X[ne - 1].add(te);
  return {
    wnd: Y,
    points: X
  };
};
ii.prototype._getBeta = function() {
  return null;
};
ii.prototype.dblp = function(Y) {
  for (var X = this, ee = 0; ee < Y; ee++)
    X = X.dbl();
  return X;
};
var hm = yc(function(Y) {
  typeof Object.create == "function" ? Y.exports = function(X, ee) {
    ee && (X.super_ = ee, X.prototype = Object.create(ee.prototype, {
      constructor: {
        value: X,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }));
  } : Y.exports = function(X, ee) {
    if (ee) {
      X.super_ = ee;
      var te = function() {
      };
      te.prototype = ee.prototype, X.prototype = new te(), X.prototype.constructor = X;
    }
  };
}), aC = jn.assert;
function si(Y) {
  Ko.call(this, "short", Y), this.a = new bt(Y.a, 16).toRed(this.red), this.b = new bt(Y.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(Y), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);
}
hm(si, Ko);
var cC = si;
si.prototype._getEndomorphism = function(Y) {
  if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
    var X, ee;
    if (Y.beta)
      X = new bt(Y.beta, 16).toRed(this.red);
    else {
      var te = this._getEndoRoots(this.p);
      X = te[0].cmp(te[1]) < 0 ? te[0] : te[1], X = X.toRed(this.red);
    }
    if (Y.lambda)
      ee = new bt(Y.lambda, 16);
    else {
      var ne = this._getEndoRoots(this.n);
      this.g.mul(ne[0]).x.cmp(this.g.x.redMul(X)) === 0 ? ee = ne[0] : (ee = ne[1], aC(this.g.mul(ee).x.cmp(this.g.x.redMul(X)) === 0));
    }
    var ie;
    return Y.basis ? ie = Y.basis.map(function(oe) {
      return {
        a: new bt(oe.a, 16),
        b: new bt(oe.b, 16)
      };
    }) : ie = this._getEndoBasis(ee), {
      beta: X,
      lambda: ee,
      basis: ie
    };
  }
};
si.prototype._getEndoRoots = function(Y) {
  var X = Y === this.p ? this.red : bt.mont(Y), ee = new bt(2).toRed(X).redInvm(), te = ee.redNeg(), ne = new bt(3).toRed(X).redNeg().redSqrt().redMul(ee), ie = te.redAdd(ne).fromRed(), oe = te.redSub(ne).fromRed();
  return [ie, oe];
};
si.prototype._getEndoBasis = function(Y) {
  for (var X = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), ee = Y, te = this.n.clone(), ne = new bt(1), ie = new bt(0), oe = new bt(0), se = new bt(1), ae, ue, le, he, me, ye, we, Ee = 0, Re, Ue; ee.cmpn(0) !== 0; ) {
    var Me = te.div(ee);
    Re = te.sub(Me.mul(ee)), Ue = oe.sub(Me.mul(ne));
    var De = se.sub(Me.mul(ie));
    if (!le && Re.cmp(X) < 0)
      ae = we.neg(), ue = ne, le = Re.neg(), he = Ue;
    else if (le && ++Ee === 2)
      break;
    we = Re, te = ee, ee = Re, oe = ne, ne = Ue, se = ie, ie = De;
  }
  me = Re.neg(), ye = Ue;
  var Fe = le.sqr().add(he.sqr()), Ke = me.sqr().add(ye.sqr());
  return Ke.cmp(Fe) >= 0 && (me = ae, ye = ue), le.negative && (le = le.neg(), he = he.neg()), me.negative && (me = me.neg(), ye = ye.neg()), [
    { a: le, b: he },
    { a: me, b: ye }
  ];
};
si.prototype._endoSplit = function(Y) {
  var X = this.endo.basis, ee = X[0], te = X[1], ne = te.b.mul(Y).divRound(this.n), ie = ee.b.neg().mul(Y).divRound(this.n), oe = ne.mul(ee.a), se = ie.mul(te.a), ae = ne.mul(ee.b), ue = ie.mul(te.b), le = Y.sub(oe).sub(se), he = ae.add(ue).neg();
  return { k1: le, k2: he };
};
si.prototype.pointFromX = function(Y, X) {
  Y = new bt(Y, 16), Y.red || (Y = Y.toRed(this.red));
  var ee = Y.redSqr().redMul(Y).redIAdd(Y.redMul(this.a)).redIAdd(this.b), te = ee.redSqrt();
  if (te.redSqr().redSub(ee).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var ne = te.fromRed().isOdd();
  return (X && !ne || !X && ne) && (te = te.redNeg()), this.point(Y, te);
};
si.prototype.validate = function(Y) {
  if (Y.inf)
    return !0;
  var X = Y.x, ee = Y.y, te = this.a.redMul(X), ne = X.redSqr().redMul(X).redIAdd(te).redIAdd(this.b);
  return ee.redSqr().redISub(ne).cmpn(0) === 0;
};
si.prototype._endoWnafMulAdd = function(Y, X, ee) {
  for (var te = this._endoWnafT1, ne = this._endoWnafT2, ie = 0; ie < Y.length; ie++) {
    var oe = this._endoSplit(X[ie]), se = Y[ie], ae = se._getBeta();
    oe.k1.negative && (oe.k1.ineg(), se = se.neg(!0)), oe.k2.negative && (oe.k2.ineg(), ae = ae.neg(!0)), te[ie * 2] = se, te[ie * 2 + 1] = ae, ne[ie * 2] = oe.k1, ne[ie * 2 + 1] = oe.k2;
  }
  for (var ue = this._wnafMulAdd(1, te, ne, ie * 2, ee), le = 0; le < ie * 2; le++)
    te[le] = null, ne[le] = null;
  return ue;
};
function Zr(Y, X, ee, te) {
  Ko.BasePoint.call(this, Y, "affine"), X === null && ee === null ? (this.x = null, this.y = null, this.inf = !0) : (this.x = new bt(X, 16), this.y = new bt(ee, 16), te && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1);
}
hm(Zr, Ko.BasePoint);
si.prototype.point = function(Y, X, ee) {
  return new Zr(this, Y, X, ee);
};
si.prototype.pointFromJSON = function(Y, X) {
  return Zr.fromJSON(this, Y, X);
};
Zr.prototype._getBeta = function() {
  if (this.curve.endo) {
    var Y = this.precomputed;
    if (Y && Y.beta)
      return Y.beta;
    var X = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
    if (Y) {
      var ee = this.curve, te = function(ne) {
        return ee.point(ne.x.redMul(ee.endo.beta), ne.y);
      };
      Y.beta = X, X.precomputed = {
        beta: null,
        naf: Y.naf && {
          wnd: Y.naf.wnd,
          points: Y.naf.points.map(te)
        },
        doubles: Y.doubles && {
          step: Y.doubles.step,
          points: Y.doubles.points.map(te)
        }
      };
    }
    return X;
  }
};
Zr.prototype.toJSON = function() {
  return this.precomputed ? [this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1)
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1)
    }
  }] : [this.x, this.y];
};
Zr.fromJSON = function(Y, X, ee) {
  typeof X == "string" && (X = JSON.parse(X));
  var te = Y.point(X[0], X[1], ee);
  if (!X[2])
    return te;
  function ne(oe) {
    return Y.point(oe[0], oe[1], ee);
  }
  var ie = X[2];
  return te.precomputed = {
    beta: null,
    doubles: ie.doubles && {
      step: ie.doubles.step,
      points: [te].concat(ie.doubles.points.map(ne))
    },
    naf: ie.naf && {
      wnd: ie.naf.wnd,
      points: [te].concat(ie.naf.points.map(ne))
    }
  }, te;
};
Zr.prototype.inspect = function() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
};
Zr.prototype.isInfinity = function() {
  return this.inf;
};
Zr.prototype.add = function(Y) {
  if (this.inf)
    return Y;
  if (Y.inf)
    return this;
  if (this.eq(Y))
    return this.dbl();
  if (this.neg().eq(Y))
    return this.curve.point(null, null);
  if (this.x.cmp(Y.x) === 0)
    return this.curve.point(null, null);
  var X = this.y.redSub(Y.y);
  X.cmpn(0) !== 0 && (X = X.redMul(this.x.redSub(Y.x).redInvm()));
  var ee = X.redSqr().redISub(this.x).redISub(Y.x), te = X.redMul(this.x.redSub(ee)).redISub(this.y);
  return this.curve.point(ee, te);
};
Zr.prototype.dbl = function() {
  if (this.inf)
    return this;
  var Y = this.y.redAdd(this.y);
  if (Y.cmpn(0) === 0)
    return this.curve.point(null, null);
  var X = this.curve.a, ee = this.x.redSqr(), te = Y.redInvm(), ne = ee.redAdd(ee).redIAdd(ee).redIAdd(X).redMul(te), ie = ne.redSqr().redISub(this.x.redAdd(this.x)), oe = ne.redMul(this.x.redSub(ie)).redISub(this.y);
  return this.curve.point(ie, oe);
};
Zr.prototype.getX = function() {
  return this.x.fromRed();
};
Zr.prototype.getY = function() {
  return this.y.fromRed();
};
Zr.prototype.mul = function(Y) {
  return Y = new bt(Y, 16), this.isInfinity() ? this : this._hasDoubles(Y) ? this.curve._fixedNafMul(this, Y) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [Y]) : this.curve._wnafMul(this, Y);
};
Zr.prototype.mulAdd = function(Y, X, ee) {
  var te = [this, X], ne = [Y, ee];
  return this.curve.endo ? this.curve._endoWnafMulAdd(te, ne) : this.curve._wnafMulAdd(1, te, ne, 2);
};
Zr.prototype.jmulAdd = function(Y, X, ee) {
  var te = [this, X], ne = [Y, ee];
  return this.curve.endo ? this.curve._endoWnafMulAdd(te, ne, !0) : this.curve._wnafMulAdd(1, te, ne, 2, !0);
};
Zr.prototype.eq = function(Y) {
  return this === Y || this.inf === Y.inf && (this.inf || this.x.cmp(Y.x) === 0 && this.y.cmp(Y.y) === 0);
};
Zr.prototype.neg = function(Y) {
  if (this.inf)
    return this;
  var X = this.curve.point(this.x, this.y.redNeg());
  if (Y && this.precomputed) {
    var ee = this.precomputed, te = function(ne) {
      return ne.neg();
    };
    X.precomputed = {
      naf: ee.naf && {
        wnd: ee.naf.wnd,
        points: ee.naf.points.map(te)
      },
      doubles: ee.doubles && {
        step: ee.doubles.step,
        points: ee.doubles.points.map(te)
      }
    };
  }
  return X;
};
Zr.prototype.toJ = function() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);
  var Y = this.curve.jpoint(this.x, this.y, this.curve.one);
  return Y;
};
function nn(Y, X, ee, te) {
  Ko.BasePoint.call(this, Y, "jacobian"), X === null && ee === null && te === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new bt(0)) : (this.x = new bt(X, 16), this.y = new bt(ee, 16), this.z = new bt(te, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;
}
hm(nn, Ko.BasePoint);
si.prototype.jpoint = function(Y, X, ee) {
  return new nn(this, Y, X, ee);
};
nn.prototype.toP = function() {
  if (this.isInfinity())
    return this.curve.point(null, null);
  var Y = this.z.redInvm(), X = Y.redSqr(), ee = this.x.redMul(X), te = this.y.redMul(X).redMul(Y);
  return this.curve.point(ee, te);
};
nn.prototype.neg = function() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};
nn.prototype.add = function(Y) {
  if (this.isInfinity())
    return Y;
  if (Y.isInfinity())
    return this;
  var X = Y.z.redSqr(), ee = this.z.redSqr(), te = this.x.redMul(X), ne = Y.x.redMul(ee), ie = this.y.redMul(X.redMul(Y.z)), oe = Y.y.redMul(ee.redMul(this.z)), se = te.redSub(ne), ae = ie.redSub(oe);
  if (se.cmpn(0) === 0)
    return ae.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var ue = se.redSqr(), le = ue.redMul(se), he = te.redMul(ue), me = ae.redSqr().redIAdd(le).redISub(he).redISub(he), ye = ae.redMul(he.redISub(me)).redISub(ie.redMul(le)), we = this.z.redMul(Y.z).redMul(se);
  return this.curve.jpoint(me, ye, we);
};
nn.prototype.mixedAdd = function(Y) {
  if (this.isInfinity())
    return Y.toJ();
  if (Y.isInfinity())
    return this;
  var X = this.z.redSqr(), ee = this.x, te = Y.x.redMul(X), ne = this.y, ie = Y.y.redMul(X).redMul(this.z), oe = ee.redSub(te), se = ne.redSub(ie);
  if (oe.cmpn(0) === 0)
    return se.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var ae = oe.redSqr(), ue = ae.redMul(oe), le = ee.redMul(ae), he = se.redSqr().redIAdd(ue).redISub(le).redISub(le), me = se.redMul(le.redISub(he)).redISub(ne.redMul(ue)), ye = this.z.redMul(oe);
  return this.curve.jpoint(he, me, ye);
};
nn.prototype.dblp = function(Y) {
  if (Y === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!Y)
    return this.dbl();
  var X;
  if (this.curve.zeroA || this.curve.threeA) {
    var ee = this;
    for (X = 0; X < Y; X++)
      ee = ee.dbl();
    return ee;
  }
  var te = this.curve.a, ne = this.curve.tinv, ie = this.x, oe = this.y, se = this.z, ae = se.redSqr().redSqr(), ue = oe.redAdd(oe);
  for (X = 0; X < Y; X++) {
    var le = ie.redSqr(), he = ue.redSqr(), me = he.redSqr(), ye = le.redAdd(le).redIAdd(le).redIAdd(te.redMul(ae)), we = ie.redMul(he), Ee = ye.redSqr().redISub(we.redAdd(we)), Re = we.redISub(Ee), Ue = ye.redMul(Re);
    Ue = Ue.redIAdd(Ue).redISub(me);
    var Me = ue.redMul(se);
    X + 1 < Y && (ae = ae.redMul(me)), ie = Ee, se = Me, ue = Ue;
  }
  return this.curve.jpoint(ie, ue.redMul(ne), se);
};
nn.prototype.dbl = function() {
  return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();
};
nn.prototype._zeroDbl = function() {
  var Y, X, ee;
  if (this.zOne) {
    var te = this.x.redSqr(), ne = this.y.redSqr(), ie = ne.redSqr(), oe = this.x.redAdd(ne).redSqr().redISub(te).redISub(ie);
    oe = oe.redIAdd(oe);
    var se = te.redAdd(te).redIAdd(te), ae = se.redSqr().redISub(oe).redISub(oe), ue = ie.redIAdd(ie);
    ue = ue.redIAdd(ue), ue = ue.redIAdd(ue), Y = ae, X = se.redMul(oe.redISub(ae)).redISub(ue), ee = this.y.redAdd(this.y);
  } else {
    var le = this.x.redSqr(), he = this.y.redSqr(), me = he.redSqr(), ye = this.x.redAdd(he).redSqr().redISub(le).redISub(me);
    ye = ye.redIAdd(ye);
    var we = le.redAdd(le).redIAdd(le), Ee = we.redSqr(), Re = me.redIAdd(me);
    Re = Re.redIAdd(Re), Re = Re.redIAdd(Re), Y = Ee.redISub(ye).redISub(ye), X = we.redMul(ye.redISub(Y)).redISub(Re), ee = this.y.redMul(this.z), ee = ee.redIAdd(ee);
  }
  return this.curve.jpoint(Y, X, ee);
};
nn.prototype._threeDbl = function() {
  var Y, X, ee;
  if (this.zOne) {
    var te = this.x.redSqr(), ne = this.y.redSqr(), ie = ne.redSqr(), oe = this.x.redAdd(ne).redSqr().redISub(te).redISub(ie);
    oe = oe.redIAdd(oe);
    var se = te.redAdd(te).redIAdd(te).redIAdd(this.curve.a), ae = se.redSqr().redISub(oe).redISub(oe);
    Y = ae;
    var ue = ie.redIAdd(ie);
    ue = ue.redIAdd(ue), ue = ue.redIAdd(ue), X = se.redMul(oe.redISub(ae)).redISub(ue), ee = this.y.redAdd(this.y);
  } else {
    var le = this.z.redSqr(), he = this.y.redSqr(), me = this.x.redMul(he), ye = this.x.redSub(le).redMul(this.x.redAdd(le));
    ye = ye.redAdd(ye).redIAdd(ye);
    var we = me.redIAdd(me);
    we = we.redIAdd(we);
    var Ee = we.redAdd(we);
    Y = ye.redSqr().redISub(Ee), ee = this.y.redAdd(this.z).redSqr().redISub(he).redISub(le);
    var Re = he.redSqr();
    Re = Re.redIAdd(Re), Re = Re.redIAdd(Re), Re = Re.redIAdd(Re), X = ye.redMul(we.redISub(Y)).redISub(Re);
  }
  return this.curve.jpoint(Y, X, ee);
};
nn.prototype._dbl = function() {
  var Y = this.curve.a, X = this.x, ee = this.y, te = this.z, ne = te.redSqr().redSqr(), ie = X.redSqr(), oe = ee.redSqr(), se = ie.redAdd(ie).redIAdd(ie).redIAdd(Y.redMul(ne)), ae = X.redAdd(X);
  ae = ae.redIAdd(ae);
  var ue = ae.redMul(oe), le = se.redSqr().redISub(ue.redAdd(ue)), he = ue.redISub(le), me = oe.redSqr();
  me = me.redIAdd(me), me = me.redIAdd(me), me = me.redIAdd(me);
  var ye = se.redMul(he).redISub(me), we = ee.redAdd(ee).redMul(te);
  return this.curve.jpoint(le, ye, we);
};
nn.prototype.trpl = function() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);
  var Y = this.x.redSqr(), X = this.y.redSqr(), ee = this.z.redSqr(), te = X.redSqr(), ne = Y.redAdd(Y).redIAdd(Y), ie = ne.redSqr(), oe = this.x.redAdd(X).redSqr().redISub(Y).redISub(te);
  oe = oe.redIAdd(oe), oe = oe.redAdd(oe).redIAdd(oe), oe = oe.redISub(ie);
  var se = oe.redSqr(), ae = te.redIAdd(te);
  ae = ae.redIAdd(ae), ae = ae.redIAdd(ae), ae = ae.redIAdd(ae);
  var ue = ne.redIAdd(oe).redSqr().redISub(ie).redISub(se).redISub(ae), le = X.redMul(ue);
  le = le.redIAdd(le), le = le.redIAdd(le);
  var he = this.x.redMul(se).redISub(le);
  he = he.redIAdd(he), he = he.redIAdd(he);
  var me = this.y.redMul(ue.redMul(ae.redISub(ue)).redISub(oe.redMul(se)));
  me = me.redIAdd(me), me = me.redIAdd(me), me = me.redIAdd(me);
  var ye = this.z.redAdd(oe).redSqr().redISub(ee).redISub(se);
  return this.curve.jpoint(he, me, ye);
};
nn.prototype.mul = function(Y, X) {
  return Y = new bt(Y, X), this.curve._wnafMul(this, Y);
};
nn.prototype.eq = function(Y) {
  if (Y.type === "affine")
    return this.eq(Y.toJ());
  if (this === Y)
    return !0;
  var X = this.z.redSqr(), ee = Y.z.redSqr();
  if (this.x.redMul(ee).redISub(Y.x.redMul(X)).cmpn(0) !== 0)
    return !1;
  var te = X.redMul(this.z), ne = ee.redMul(Y.z);
  return this.y.redMul(ne).redISub(Y.y.redMul(te)).cmpn(0) === 0;
};
nn.prototype.eqXToP = function(Y) {
  var X = this.z.redSqr(), ee = Y.toRed(this.curve.red).redMul(X);
  if (this.x.cmp(ee) === 0)
    return !0;
  for (var te = Y.clone(), ne = this.curve.redN.redMul(X); ; ) {
    if (te.iadd(this.curve.n), te.cmp(this.curve.p) >= 0)
      return !1;
    if (ee.redIAdd(ne), this.x.cmp(ee) === 0)
      return !0;
  }
};
nn.prototype.inspect = function() {
  return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
};
nn.prototype.isInfinity = function() {
  return this.z.cmpn(0) === 0;
};
var wl = yc(function(Y, X) {
  var ee = X;
  ee.base = Ko, ee.short = cC, ee.mont = /*RicMoo:ethers:require(./mont)*/
  null, ee.edwards = /*RicMoo:ethers:require(./edwards)*/
  null;
}), vl = yc(function(Y, X) {
  var ee = X, te = jn.assert;
  function ne(se) {
    se.type === "short" ? this.curve = new wl.short(se) : se.type === "edwards" ? this.curve = new wl.edwards(se) : this.curve = new wl.mont(se), this.g = this.curve.g, this.n = this.curve.n, this.hash = se.hash, te(this.g.validate(), "Invalid curve"), te(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
  }
  ee.PresetCurve = ne;
  function ie(se, ae) {
    Object.defineProperty(ee, se, {
      configurable: !0,
      enumerable: !0,
      get: function() {
        var ue = new ne(ae);
        return Object.defineProperty(ee, se, {
          configurable: !0,
          enumerable: !0,
          value: ue
        }), ue;
      }
    });
  }
  ie("p192", {
    type: "short",
    prime: "p192",
    p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
    b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
    n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
    hash: kn.sha256,
    gRed: !1,
    g: [
      "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
      "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
    ]
  }), ie("p224", {
    type: "short",
    prime: "p224",
    p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
    b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
    n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
    hash: kn.sha256,
    gRed: !1,
    g: [
      "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
      "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
    ]
  }), ie("p256", {
    type: "short",
    prime: null,
    p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
    a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
    b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
    n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
    hash: kn.sha256,
    gRed: !1,
    g: [
      "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
      "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
    ]
  }), ie("p384", {
    type: "short",
    prime: null,
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
    a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
    b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
    n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
    hash: kn.sha384,
    gRed: !1,
    g: [
      "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
      "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
    ]
  }), ie("p521", {
    type: "short",
    prime: null,
    p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
    a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
    b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
    n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
    hash: kn.sha512,
    gRed: !1,
    g: [
      "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
      "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
    ]
  }), ie("curve25519", {
    type: "mont",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "76d06",
    b: "1",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: kn.sha256,
    gRed: !1,
    g: [
      "9"
    ]
  }), ie("ed25519", {
    type: "edwards",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "-1",
    c: "1",
    // -121665 * (121666^(-1)) (mod P)
    d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: kn.sha256,
    gRed: !1,
    g: [
      "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
      // 4/5
      "6666666666666666666666666666666666666666666666666666666666666658"
    ]
  });
  var oe;
  try {
    oe = /*RicMoo:ethers:require(./precomputed/secp256k1)*/
    null.crash();
  } catch {
    oe = void 0;
  }
  ie("secp256k1", {
    type: "short",
    prime: "k256",
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
    a: "0",
    b: "7",
    n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
    h: "1",
    hash: kn.sha256,
    // Precomputed endomorphism
    beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
    lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
    basis: [
      {
        a: "3086d221a7d46bcde86c90e49284eb15",
        b: "-e4437ed6010e88286f547fa90abfe4c3"
      },
      {
        a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
        b: "3086d221a7d46bcde86c90e49284eb15"
      }
    ],
    gRed: !1,
    g: [
      "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
      "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
      oe
    ]
  });
});
function ao(Y) {
  if (!(this instanceof ao))
    return new ao(Y);
  this.hash = Y.hash, this.predResist = !!Y.predResist, this.outLen = this.hash.outSize, this.minEntropy = Y.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
  var X = yi.toArray(Y.entropy, Y.entropyEnc || "hex"), ee = yi.toArray(Y.nonce, Y.nonceEnc || "hex"), te = yi.toArray(Y.pers, Y.persEnc || "hex");
  dm(
    X.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  ), this._init(X, ee, te);
}
var HE = ao;
ao.prototype._init = function(Y, X, ee) {
  var te = Y.concat(X).concat(ee);
  this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
  for (var ne = 0; ne < this.V.length; ne++)
    this.K[ne] = 0, this.V[ne] = 1;
  this._update(te), this._reseed = 1, this.reseedInterval = 281474976710656;
};
ao.prototype._hmac = function() {
  return new kn.hmac(this.hash, this.K);
};
ao.prototype._update = function(Y) {
  var X = this._hmac().update(this.V).update([0]);
  Y && (X = X.update(Y)), this.K = X.digest(), this.V = this._hmac().update(this.V).digest(), Y && (this.K = this._hmac().update(this.V).update([1]).update(Y).digest(), this.V = this._hmac().update(this.V).digest());
};
ao.prototype.reseed = function(Y, X, ee, te) {
  typeof X != "string" && (te = ee, ee = X, X = null), Y = yi.toArray(Y, X), ee = yi.toArray(ee, te), dm(
    Y.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  ), this._update(Y.concat(ee || [])), this._reseed = 1;
};
ao.prototype.generate = function(Y, X, ee, te) {
  if (this._reseed > this.reseedInterval)
    throw new Error("Reseed is required");
  typeof X != "string" && (te = ee, ee = X, X = null), ee && (ee = yi.toArray(ee, te || "hex"), this._update(ee));
  for (var ne = []; ne.length < Y; )
    this.V = this._hmac().update(this.V).digest(), ne = ne.concat(this.V);
  var ie = ne.slice(0, Y);
  return this._update(ee), this._reseed++, yi.encode(ie, X);
};
var jp = jn.assert;
function hn(Y, X) {
  this.ec = Y, this.priv = null, this.pub = null, X.priv && this._importPrivate(X.priv, X.privEnc), X.pub && this._importPublic(X.pub, X.pubEnc);
}
var pm = hn;
hn.fromPublic = function(Y, X, ee) {
  return X instanceof hn ? X : new hn(Y, {
    pub: X,
    pubEnc: ee
  });
};
hn.fromPrivate = function(Y, X, ee) {
  return X instanceof hn ? X : new hn(Y, {
    priv: X,
    privEnc: ee
  });
};
hn.prototype.validate = function() {
  var Y = this.getPublic();
  return Y.isInfinity() ? { result: !1, reason: "Invalid public key" } : Y.validate() ? Y.mul(this.ec.curve.n).isInfinity() ? { result: !0, reason: null } : { result: !1, reason: "Public key * N != O" } : { result: !1, reason: "Public key is not a point" };
};
hn.prototype.getPublic = function(Y, X) {
  return typeof Y == "string" && (X = Y, Y = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), X ? this.pub.encode(X, Y) : this.pub;
};
hn.prototype.getPrivate = function(Y) {
  return Y === "hex" ? this.priv.toString(16, 2) : this.priv;
};
hn.prototype._importPrivate = function(Y, X) {
  this.priv = new bt(Y, X || 16), this.priv = this.priv.umod(this.ec.curve.n);
};
hn.prototype._importPublic = function(Y, X) {
  if (Y.x || Y.y) {
    this.ec.curve.type === "mont" ? jp(Y.x, "Need x coordinate") : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") && jp(Y.x && Y.y, "Need both x and y coordinate"), this.pub = this.ec.curve.point(Y.x, Y.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(Y, X);
};
hn.prototype.derive = function(Y) {
  return Y.validate() || jp(Y.validate(), "public point not validated"), Y.mul(this.priv).getX();
};
hn.prototype.sign = function(Y, X, ee) {
  return this.ec.sign(Y, this, X, ee);
};
hn.prototype.verify = function(Y, X) {
  return this.ec.verify(Y, X, this);
};
hn.prototype.inspect = function() {
  return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
};
var uC = jn.assert;
function Id(Y, X) {
  if (Y instanceof Id)
    return Y;
  this._importDER(Y, X) || (uC(Y.r && Y.s, "Signature without r or s"), this.r = new bt(Y.r, 16), this.s = new bt(Y.s, 16), Y.recoveryParam === void 0 ? this.recoveryParam = null : this.recoveryParam = Y.recoveryParam);
}
var Rd = Id;
function fC() {
  this.place = 0;
}
function rh$1(Y, X) {
  var ee = Y[X.place++];
  if (!(ee & 128))
    return ee;
  var te = ee & 15;
  if (te === 0 || te > 4)
    return !1;
  for (var ne = 0, ie = 0, oe = X.place; ie < te; ie++, oe++)
    ne <<= 8, ne |= Y[oe], ne >>>= 0;
  return ne <= 127 ? !1 : (X.place = oe, ne);
}
function yx(Y) {
  for (var X = 0, ee = Y.length - 1; !Y[X] && !(Y[X + 1] & 128) && X < ee; )
    X++;
  return X === 0 ? Y : Y.slice(X);
}
Id.prototype._importDER = function(Y, X) {
  Y = jn.toArray(Y, X);
  var ee = new fC();
  if (Y[ee.place++] !== 48)
    return !1;
  var te = rh$1(Y, ee);
  if (te === !1 || te + ee.place !== Y.length || Y[ee.place++] !== 2)
    return !1;
  var ne = rh$1(Y, ee);
  if (ne === !1)
    return !1;
  var ie = Y.slice(ee.place, ne + ee.place);
  if (ee.place += ne, Y[ee.place++] !== 2)
    return !1;
  var oe = rh$1(Y, ee);
  if (oe === !1 || Y.length !== oe + ee.place)
    return !1;
  var se = Y.slice(ee.place, oe + ee.place);
  if (ie[0] === 0)
    if (ie[1] & 128)
      ie = ie.slice(1);
    else
      return !1;
  if (se[0] === 0)
    if (se[1] & 128)
      se = se.slice(1);
    else
      return !1;
  return this.r = new bt(ie), this.s = new bt(se), this.recoveryParam = null, !0;
};
function nh(Y, X) {
  if (X < 128) {
    Y.push(X);
    return;
  }
  var ee = 1 + (Math.log(X) / Math.LN2 >>> 3);
  for (Y.push(ee | 128); --ee; )
    Y.push(X >>> (ee << 3) & 255);
  Y.push(X);
}
Id.prototype.toDER = function(Y) {
  var X = this.r.toArray(), ee = this.s.toArray();
  for (X[0] & 128 && (X = [0].concat(X)), ee[0] & 128 && (ee = [0].concat(ee)), X = yx(X), ee = yx(ee); !ee[0] && !(ee[1] & 128); )
    ee = ee.slice(1);
  var te = [2];
  nh(te, X.length), te = te.concat(X), te.push(2), nh(te, ee.length);
  var ne = te.concat(ee), ie = [48];
  return nh(ie, ne.length), ie = ie.concat(ne), jn.encode(ie, Y);
};
var lC = (
  /*RicMoo:ethers:require(brorand)*/
  function() {
    throw new Error("unsupported");
  }
), zE = jn.assert;
function ni(Y) {
  if (!(this instanceof ni))
    return new ni(Y);
  typeof Y == "string" && (zE(
    Object.prototype.hasOwnProperty.call(vl, Y),
    "Unknown curve " + Y
  ), Y = vl[Y]), Y instanceof vl.PresetCurve && (Y = { curve: Y }), this.curve = Y.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = Y.curve.g, this.g.precompute(Y.curve.n.bitLength() + 1), this.hash = Y.hash || Y.curve.hash;
}
var dC = ni;
ni.prototype.keyPair = function(Y) {
  return new pm(this, Y);
};
ni.prototype.keyFromPrivate = function(Y, X) {
  return pm.fromPrivate(this, Y, X);
};
ni.prototype.keyFromPublic = function(Y, X) {
  return pm.fromPublic(this, Y, X);
};
ni.prototype.genKeyPair = function(Y) {
  Y || (Y = {});
  for (var X = new HE({
    hash: this.hash,
    pers: Y.pers,
    persEnc: Y.persEnc || "utf8",
    entropy: Y.entropy || lC(this.hash.hmacStrength),
    entropyEnc: Y.entropy && Y.entropyEnc || "utf8",
    nonce: this.n.toArray()
  }), ee = this.n.byteLength(), te = this.n.sub(new bt(2)); ; ) {
    var ne = new bt(X.generate(ee));
    if (!(ne.cmp(te) > 0))
      return ne.iaddn(1), this.keyFromPrivate(ne);
  }
};
ni.prototype._truncateToN = function(Y, X) {
  var ee = Y.byteLength() * 8 - this.n.bitLength();
  return ee > 0 && (Y = Y.ushrn(ee)), !X && Y.cmp(this.n) >= 0 ? Y.sub(this.n) : Y;
};
ni.prototype.sign = function(Y, X, ee, te) {
  typeof ee == "object" && (te = ee, ee = null), te || (te = {}), X = this.keyFromPrivate(X, ee), Y = this._truncateToN(new bt(Y, 16));
  for (var ne = this.n.byteLength(), ie = X.getPrivate().toArray("be", ne), oe = Y.toArray("be", ne), se = new HE({
    hash: this.hash,
    entropy: ie,
    nonce: oe,
    pers: te.pers,
    persEnc: te.persEnc || "utf8"
  }), ae = this.n.sub(new bt(1)), ue = 0; ; ue++) {
    var le = te.k ? te.k(ue) : new bt(se.generate(this.n.byteLength()));
    if (le = this._truncateToN(le, !0), !(le.cmpn(1) <= 0 || le.cmp(ae) >= 0)) {
      var he = this.g.mul(le);
      if (!he.isInfinity()) {
        var me = he.getX(), ye = me.umod(this.n);
        if (ye.cmpn(0) !== 0) {
          var we = le.invm(this.n).mul(ye.mul(X.getPrivate()).iadd(Y));
          if (we = we.umod(this.n), we.cmpn(0) !== 0) {
            var Ee = (he.getY().isOdd() ? 1 : 0) | (me.cmp(ye) !== 0 ? 2 : 0);
            return te.canonical && we.cmp(this.nh) > 0 && (we = this.n.sub(we), Ee ^= 1), new Rd({ r: ye, s: we, recoveryParam: Ee });
          }
        }
      }
    }
  }
};
ni.prototype.verify = function(Y, X, ee, te) {
  Y = this._truncateToN(new bt(Y, 16)), ee = this.keyFromPublic(ee, te), X = new Rd(X, "hex");
  var ne = X.r, ie = X.s;
  if (ne.cmpn(1) < 0 || ne.cmp(this.n) >= 0 || ie.cmpn(1) < 0 || ie.cmp(this.n) >= 0)
    return !1;
  var oe = ie.invm(this.n), se = oe.mul(Y).umod(this.n), ae = oe.mul(ne).umod(this.n), ue;
  return this.curve._maxwellTrick ? (ue = this.g.jmulAdd(se, ee.getPublic(), ae), ue.isInfinity() ? !1 : ue.eqXToP(ne)) : (ue = this.g.mulAdd(se, ee.getPublic(), ae), ue.isInfinity() ? !1 : ue.getX().umod(this.n).cmp(ne) === 0);
};
ni.prototype.recoverPubKey = function(Y, X, ee, te) {
  zE((3 & ee) === ee, "The recovery param is more than two bits"), X = new Rd(X, te);
  var ne = this.n, ie = new bt(Y), oe = X.r, se = X.s, ae = ee & 1, ue = ee >> 1;
  if (oe.cmp(this.curve.p.umod(this.curve.n)) >= 0 && ue)
    throw new Error("Unable to find sencond key candinate");
  ue ? oe = this.curve.pointFromX(oe.add(this.curve.n), ae) : oe = this.curve.pointFromX(oe, ae);
  var le = X.r.invm(ne), he = ne.sub(ie).mul(le).umod(ne), me = se.mul(le).umod(ne);
  return this.g.mulAdd(he, oe, me);
};
ni.prototype.getKeyRecoveryParam = function(Y, X, ee, te) {
  if (X = new Rd(X, te), X.recoveryParam !== null)
    return X.recoveryParam;
  for (var ne = 0; ne < 4; ne++) {
    var ie;
    try {
      ie = this.recoverPubKey(Y, X, ne);
    } catch {
      continue;
    }
    if (ie.eq(ee))
      return ne;
  }
  throw new Error("Unable to find valid recovery factor");
};
var hC = yc(function(Y, X) {
  var ee = X;
  ee.version = "6.5.4", ee.utils = jn, ee.rand = /*RicMoo:ethers:require(brorand)*/
  function() {
    throw new Error("unsupported");
  }, ee.curve = wl, ee.curves = vl, ee.ec = dC, ee.eddsa = /*RicMoo:ethers:require(./elliptic/eddsa)*/
  null;
}), pC = hC.ec;
const gC = "signing-key/5.7.0", Hp = new ce(gC);
let ih = null;
function Ni() {
  return ih || (ih = new pC("secp256k1")), ih;
}
class Ca {
  constructor(X) {
    ve(this, "curve", "secp256k1"), ve(this, "privateKey", Oe(X)), Oo(this.privateKey) !== 32 && Hp.throwArgumentError("invalid private key", "privateKey", "[[ REDACTED ]]");
    const ee = Ni().keyFromPrivate(Ne(this.privateKey));
    ve(this, "publicKey", "0x" + ee.getPublic(!1, "hex")), ve(this, "compressedPublicKey", "0x" + ee.getPublic(!0, "hex")), ve(this, "_isSigningKey", !0);
  }
  _addPoint(X) {
    const ee = Ni().keyFromPublic(Ne(this.publicKey)), te = Ni().keyFromPublic(Ne(X));
    return "0x" + ee.pub.add(te.pub).encodeCompressed("hex");
  }
  signDigest(X) {
    const ee = Ni().keyFromPrivate(Ne(this.privateKey)), te = Ne(X);
    te.length !== 32 && Hp.throwArgumentError("bad digest length", "digest", X);
    const ne = ee.sign(te, { canonical: !0 });
    return lc({
      recoveryParam: ne.recoveryParam,
      r: hr$1("0x" + ne.r.toString(16), 32),
      s: hr$1("0x" + ne.s.toString(16), 32)
    });
  }
  computeSharedSecret(X) {
    const ee = Ni().keyFromPrivate(Ne(this.privateKey)), te = Ni().keyFromPublic(Ne(qE(X)));
    return hr$1("0x" + ee.derive(te.getPublic()).toString(16), 32);
  }
  static isSigningKey(X) {
    return !!(X && X._isSigningKey);
  }
}
function mC(Y, X) {
  const ee = lc(X), te = { r: Ne(ee.r), s: Ne(ee.s) };
  return "0x" + Ni().recoverPubKey(Ne(Y), te, ee.recoveryParam).encode("hex", !1);
}
function qE(Y, X) {
  const ee = Ne(Y);
  if (ee.length === 32) {
    const te = new Ca(ee);
    return X ? "0x" + Ni().keyFromPrivate(ee).getPublic(!0, "hex") : te.publicKey;
  } else {
    if (ee.length === 33)
      return X ? Oe(ee) : "0x" + Ni().keyFromPublic(ee).getPublic(!1, "hex");
    if (ee.length === 65)
      return X ? "0x" + Ni().keyFromPublic(ee).getPublic(!0, "hex") : Oe(ee);
  }
  return Hp.throwArgumentError("invalid public or private key", "key", "[REDACTED]");
}
const yC = "transactions/5.7.0", dn = new ce(yC);
var bx;
(function(Y) {
  Y[Y.legacy = 0] = "legacy", Y[Y.eip2930 = 1] = "eip2930", Y[Y.eip1559 = 2] = "eip1559";
})(bx || (bx = {}));
function gm(Y) {
  return Y === "0x" ? null : pr(Y);
}
function ln(Y) {
  return Y === "0x" ? sE : Be.from(Y);
}
const bC = [
  { name: "nonce", maxLength: 32, numeric: !0 },
  { name: "gasPrice", maxLength: 32, numeric: !0 },
  { name: "gasLimit", maxLength: 32, numeric: !0 },
  { name: "to", length: 20 },
  { name: "value", maxLength: 32, numeric: !0 },
  { name: "data" }
], xC = {
  chainId: !0,
  data: !0,
  gasLimit: !0,
  gasPrice: !0,
  nonce: !0,
  to: !0,
  type: !0,
  value: !0
};
function Ro(Y) {
  const X = qE(Y);
  return pr(Dr(gr(Dr(X, 1)), 12));
}
function GE(Y, X) {
  return Ro(mC(Ne(Y), X));
}
function Ln(Y, X) {
  const ee = _s(Be.from(Y).toHexString());
  return ee.length > 32 && dn.throwArgumentError("invalid length for " + X, "transaction:" + X, Y), ee;
}
function sh$1(Y, X) {
  return {
    address: pr(Y),
    storageKeys: (X || []).map((ee, te) => (Oo(ee) !== 32 && dn.throwArgumentError("invalid access list storageKey", `accessList[${Y}:${te}]`, ee), ee.toLowerCase()))
  };
}
function bc(Y) {
  if (Array.isArray(Y))
    return Y.map((ee, te) => Array.isArray(ee) ? (ee.length > 2 && dn.throwArgumentError("access list expected to be [ address, storageKeys[] ]", `value[${te}]`, ee), sh$1(ee[0], ee[1])) : sh$1(ee.address, ee.storageKeys));
  const X = Object.keys(Y).map((ee) => {
    const te = Y[ee].reduce((ne, ie) => (ne[ie] = !0, ne), {});
    return sh$1(ee, Object.keys(te).sort());
  });
  return X.sort((ee, te) => ee.address.localeCompare(te.address)), X;
}
function VE(Y) {
  return bc(Y).map((X) => [X.address, X.storageKeys]);
}
function WE(Y, X) {
  if (Y.gasPrice != null) {
    const te = Be.from(Y.gasPrice), ne = Be.from(Y.maxFeePerGas || 0);
    te.eq(ne) || dn.throwArgumentError("mismatch EIP-1559 gasPrice != maxFeePerGas", "tx", {
      gasPrice: te,
      maxFeePerGas: ne
    });
  }
  const ee = [
    Ln(Y.chainId || 0, "chainId"),
    Ln(Y.nonce || 0, "nonce"),
    Ln(Y.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
    Ln(Y.maxFeePerGas || 0, "maxFeePerGas"),
    Ln(Y.gasLimit || 0, "gasLimit"),
    Y.to != null ? pr(Y.to) : "0x",
    Ln(Y.value || 0, "value"),
    Y.data || "0x",
    VE(Y.accessList || [])
  ];
  if (X) {
    const te = lc(X);
    ee.push(Ln(te.recoveryParam, "recoveryParam")), ee.push(_s(te.r)), ee.push(_s(te.s));
  }
  return Tn(["0x02", Ha(ee)]);
}
function KE(Y, X) {
  const ee = [
    Ln(Y.chainId || 0, "chainId"),
    Ln(Y.nonce || 0, "nonce"),
    Ln(Y.gasPrice || 0, "gasPrice"),
    Ln(Y.gasLimit || 0, "gasLimit"),
    Y.to != null ? pr(Y.to) : "0x",
    Ln(Y.value || 0, "value"),
    Y.data || "0x",
    VE(Y.accessList || [])
  ];
  if (X) {
    const te = lc(X);
    ee.push(Ln(te.recoveryParam, "recoveryParam")), ee.push(_s(te.r)), ee.push(_s(te.s));
  }
  return Tn(["0x01", Ha(ee)]);
}
function wC(Y, X) {
  W2(Y, xC);
  const ee = [];
  bC.forEach(function(oe) {
    let se = Y[oe.name] || [];
    const ae = {};
    oe.numeric && (ae.hexPad = "left"), se = Ne(Oe(se, ae)), oe.length && se.length !== oe.length && se.length > 0 && dn.throwArgumentError("invalid length for " + oe.name, "transaction:" + oe.name, se), oe.maxLength && (se = _s(se), se.length > oe.maxLength && dn.throwArgumentError("invalid length for " + oe.name, "transaction:" + oe.name, se)), ee.push(Oe(se));
  });
  let te = 0;
  if (Y.chainId != null ? (te = Y.chainId, typeof te != "number" && dn.throwArgumentError("invalid transaction.chainId", "transaction", Y)) : X && !Ad(X) && X.v > 28 && (te = Math.floor((X.v - 35) / 2)), te !== 0 && (ee.push(Oe(te)), ee.push("0x"), ee.push("0x")), !X)
    return Ha(ee);
  const ne = lc(X);
  let ie = 27 + ne.recoveryParam;
  return te !== 0 ? (ee.pop(), ee.pop(), ee.pop(), ie += te * 2 + 8, ne.v > 28 && ne.v !== ie && dn.throwArgumentError("transaction.chainId/signature.v mismatch", "signature", X)) : ne.v !== ie && dn.throwArgumentError("transaction.chainId/signature.v mismatch", "signature", X), ee.push(Oe(ie)), ee.push(_s(Ne(ne.r))), ee.push(_s(Ne(ne.s))), Ha(ee);
}
function xx(Y, X) {
  if (Y.type == null || Y.type === 0)
    return Y.accessList != null && dn.throwArgumentError("untyped transactions do not support accessList; include type: 1", "transaction", Y), wC(Y, X);
  switch (Y.type) {
    case 1:
      return KE(Y, X);
    case 2:
      return WE(Y, X);
  }
  return dn.throwError(`unsupported transaction type: ${Y.type}`, ce.errors.UNSUPPORTED_OPERATION, {
    operation: "serializeTransaction",
    transactionType: Y.type
  });
}
function JE(Y, X, ee) {
  try {
    const te = ln(X[0]).toNumber();
    if (te !== 0 && te !== 1)
      throw new Error("bad recid");
    Y.v = te;
  } catch {
    dn.throwArgumentError("invalid v for transaction type: 1", "v", X[0]);
  }
  Y.r = hr$1(X[1], 32), Y.s = hr$1(X[2], 32);
  try {
    const te = gr(ee(Y));
    Y.from = GE(te, { r: Y.r, s: Y.s, recoveryParam: Y.v });
  } catch {
  }
}
function vC(Y) {
  const X = um(Y.slice(1));
  X.length !== 9 && X.length !== 12 && dn.throwArgumentError("invalid component count for transaction type: 2", "payload", Oe(Y));
  const ee = ln(X[2]), te = ln(X[3]), ne = {
    type: 2,
    chainId: ln(X[0]).toNumber(),
    nonce: ln(X[1]).toNumber(),
    maxPriorityFeePerGas: ee,
    maxFeePerGas: te,
    gasPrice: null,
    gasLimit: ln(X[4]),
    to: gm(X[5]),
    value: ln(X[6]),
    data: X[7],
    accessList: bc(X[8])
  };
  return X.length === 9 || (ne.hash = gr(Y), JE(ne, X.slice(9), WE)), ne;
}
function EC$2(Y) {
  const X = um(Y.slice(1));
  X.length !== 8 && X.length !== 11 && dn.throwArgumentError("invalid component count for transaction type: 1", "payload", Oe(Y));
  const ee = {
    type: 1,
    chainId: ln(X[0]).toNumber(),
    nonce: ln(X[1]).toNumber(),
    gasPrice: ln(X[2]),
    gasLimit: ln(X[3]),
    to: gm(X[4]),
    value: ln(X[5]),
    data: X[6],
    accessList: bc(X[7])
  };
  return X.length === 8 || (ee.hash = gr(Y), JE(ee, X.slice(8), KE)), ee;
}
function _C(Y) {
  const X = um(Y);
  X.length !== 9 && X.length !== 6 && dn.throwArgumentError("invalid raw transaction", "rawTransaction", Y);
  const ee = {
    nonce: ln(X[0]).toNumber(),
    gasPrice: ln(X[1]),
    gasLimit: ln(X[2]),
    to: gm(X[3]),
    value: ln(X[4]),
    data: X[5],
    chainId: 0
  };
  if (X.length === 6)
    return ee;
  try {
    ee.v = Be.from(X[6]).toNumber();
  } catch {
    return ee;
  }
  if (ee.r = hr$1(X[7], 32), ee.s = hr$1(X[8], 32), Be.from(ee.r).isZero() && Be.from(ee.s).isZero())
    ee.chainId = ee.v, ee.v = 0;
  else {
    ee.chainId = Math.floor((ee.v - 35) / 2), ee.chainId < 0 && (ee.chainId = 0);
    let te = ee.v - 27;
    const ne = X.slice(0, 6);
    ee.chainId !== 0 && (ne.push(Oe(ee.chainId)), ne.push("0x"), ne.push("0x"), te -= ee.chainId * 2 + 8);
    const ie = gr(Ha(ne));
    try {
      ee.from = GE(ie, { r: Oe(ee.r), s: Oe(ee.s), recoveryParam: te });
    } catch {
    }
    ee.hash = gr(Y);
  }
  return ee.type = null, ee;
}
function AC(Y) {
  const X = Ne(Y);
  if (X[0] > 127)
    return _C(X);
  switch (X[0]) {
    case 1:
      return EC$2(X);
    case 2:
      return vC(X);
  }
  return dn.throwError(`unsupported transaction type: ${X[0]}`, ce.errors.UNSUPPORTED_OPERATION, {
    operation: "parseTransaction",
    transactionType: X[0]
  });
}
const SC = "contracts/5.7.0";
var ko = function(Y, X, ee, te) {
  function ne(ie) {
    return ie instanceof ee ? ie : new ee(function(oe) {
      oe(ie);
    });
  }
  return new (ee || (ee = Promise))(function(ie, oe) {
    function se(le) {
      try {
        ue(te.next(le));
      } catch (he) {
        oe(he);
      }
    }
    function ae(le) {
      try {
        ue(te.throw(le));
      } catch (he) {
        oe(he);
      }
    }
    function ue(le) {
      le.done ? ie(le.value) : ne(le.value).then(se, ae);
    }
    ue((te = te.apply(Y, X || [])).next());
  });
};
const Pr = new ce(SC);
function $l(Y, X) {
  return ko(this, void 0, void 0, function* () {
    const ee = yield X;
    typeof ee != "string" && Pr.throwArgumentError("invalid address or ENS name", "name", ee);
    try {
      return pr(ee);
    } catch {
    }
    Y || Pr.throwError("a provider or signer is needed to resolve ENS names", ce.errors.UNSUPPORTED_OPERATION, {
      operation: "resolveName"
    });
    const te = yield Y.resolveName(ee);
    return te == null && Pr.throwArgumentError("resolver or addr is not configured for ENS name", "name", ee), te;
  });
}
function El(Y, X, ee) {
  return ko(this, void 0, void 0, function* () {
    return Array.isArray(ee) ? yield Promise.all(ee.map((te, ne) => El(Y, Array.isArray(X) ? X[ne] : X[te.name], te))) : ee.type === "address" ? yield $l(Y, X) : ee.type === "tuple" ? yield El(Y, X, ee.components) : ee.baseType === "array" ? Array.isArray(X) ? yield Promise.all(X.map((te) => El(Y, te, ee.arrayChildren))) : Promise.reject(Pr.makeError("invalid value for array", ce.errors.INVALID_ARGUMENT, {
      argument: "value",
      value: X
    })) : X;
  });
}
function Cd(Y, X, ee) {
  return ko(this, void 0, void 0, function* () {
    let te = {};
    ee.length === X.inputs.length + 1 && typeof ee[ee.length - 1] == "object" && (te = mr$1(ee.pop())), Pr.checkArgumentCount(ee.length, X.inputs.length, "passed to contract"), Y.signer ? te.from ? te.from = Cr({
      override: $l(Y.signer, te.from),
      signer: Y.signer.getAddress()
    }).then((ue) => ko(this, void 0, void 0, function* () {
      return pr(ue.signer) !== ue.override && Pr.throwError("Contract with a Signer cannot override from", ce.errors.UNSUPPORTED_OPERATION, {
        operation: "overrides.from"
      }), ue.override;
    })) : te.from = Y.signer.getAddress() : te.from && (te.from = $l(Y.provider, te.from));
    const ne = yield Cr({
      args: El(Y.signer || Y.provider, ee, X.inputs),
      address: Y.resolvedAddress,
      overrides: Cr(te) || {}
    }), ie = Y.interface.encodeFunctionData(X, ne.args), oe = {
      data: ie,
      to: ne.address
    }, se = ne.overrides;
    if (se.nonce != null && (oe.nonce = Be.from(se.nonce).toNumber()), se.gasLimit != null && (oe.gasLimit = Be.from(se.gasLimit)), se.gasPrice != null && (oe.gasPrice = Be.from(se.gasPrice)), se.maxFeePerGas != null && (oe.maxFeePerGas = Be.from(se.maxFeePerGas)), se.maxPriorityFeePerGas != null && (oe.maxPriorityFeePerGas = Be.from(se.maxPriorityFeePerGas)), se.from != null && (oe.from = se.from), se.type != null && (oe.type = se.type), se.accessList != null && (oe.accessList = bc(se.accessList)), oe.gasLimit == null && X.gas != null) {
      let ue = 21e3;
      const le = Ne(ie);
      for (let he = 0; he < le.length; he++)
        ue += 4, le[he] && (ue += 64);
      oe.gasLimit = Be.from(X.gas).add(ue);
    }
    if (se.value) {
      const ue = Be.from(se.value);
      !ue.isZero() && !X.payable && Pr.throwError("non-payable method cannot override value", ce.errors.UNSUPPORTED_OPERATION, {
        operation: "overrides.value",
        value: te.value
      }), oe.value = ue;
    }
    se.customData && (oe.customData = mr$1(se.customData)), se.ccipReadEnabled && (oe.ccipReadEnabled = !!se.ccipReadEnabled), delete te.nonce, delete te.gasLimit, delete te.gasPrice, delete te.from, delete te.value, delete te.type, delete te.accessList, delete te.maxFeePerGas, delete te.maxPriorityFeePerGas, delete te.customData, delete te.ccipReadEnabled;
    const ae = Object.keys(te).filter((ue) => te[ue] != null);
    return ae.length && Pr.throwError(`cannot override ${ae.map((ue) => JSON.stringify(ue)).join(",")}`, ce.errors.UNSUPPORTED_OPERATION, {
      operation: "overrides",
      overrides: ae
    }), oe;
  });
}
function TC(Y, X) {
  return function(...ee) {
    return Cd(Y, X, ee);
  };
}
function IC(Y, X) {
  const ee = Y.signer || Y.provider;
  return function(...te) {
    return ko(this, void 0, void 0, function* () {
      ee || Pr.throwError("estimate require a provider or signer", ce.errors.UNSUPPORTED_OPERATION, {
        operation: "estimateGas"
      });
      const ne = yield Cd(Y, X, te);
      return yield ee.estimateGas(ne);
    });
  };
}
function RC(Y, X) {
  const ee = X.wait.bind(X);
  X.wait = (te) => ee(te).then((ne) => (ne.events = ne.logs.map((ie) => {
    let oe = ti(ie), se = null;
    try {
      se = Y.interface.parseLog(ie);
    } catch {
    }
    return se && (oe.args = se.args, oe.decode = (ae, ue) => Y.interface.decodeEventLog(se.eventFragment, ae, ue), oe.event = se.name, oe.eventSignature = se.signature), oe.removeListener = () => Y.provider, oe.getBlock = () => Y.provider.getBlock(ne.blockHash), oe.getTransaction = () => Y.provider.getTransaction(ne.transactionHash), oe.getTransactionReceipt = () => Promise.resolve(ne), oe;
  }), ne));
}
function YE(Y, X, ee) {
  const te = Y.signer || Y.provider;
  return function(...ne) {
    return ko(this, void 0, void 0, function* () {
      let ie;
      if (ne.length === X.inputs.length + 1 && typeof ne[ne.length - 1] == "object") {
        const ae = mr$1(ne.pop());
        ae.blockTag != null && (ie = yield ae.blockTag), delete ae.blockTag, ne.push(ae);
      }
      Y.deployTransaction != null && (yield Y._deployed(ie));
      const oe = yield Cd(Y, X, ne), se = yield te.call(oe, ie);
      try {
        let ae = Y.interface.decodeFunctionResult(X, se);
        return ee && X.outputs.length === 1 && (ae = ae[0]), ae;
      } catch (ae) {
        throw ae.code === ce.errors.CALL_EXCEPTION && (ae.address = Y.address, ae.args = ne, ae.transaction = oe), ae;
      }
    });
  };
}
function CC(Y, X) {
  return function(...ee) {
    return ko(this, void 0, void 0, function* () {
      Y.signer || Pr.throwError("sending a transaction requires a signer", ce.errors.UNSUPPORTED_OPERATION, {
        operation: "sendTransaction"
      }), Y.deployTransaction != null && (yield Y._deployed());
      const te = yield Cd(Y, X, ee), ne = yield Y.signer.sendTransaction(te);
      return RC(Y, ne), ne;
    });
  };
}
function wx(Y, X, ee) {
  return X.constant ? YE(Y, X, ee) : CC(Y, X);
}
function XE(Y) {
  return Y.address && (Y.topics == null || Y.topics.length === 0) ? "*" : (Y.address || "*") + "@" + (Y.topics ? Y.topics.map((X) => Array.isArray(X) ? X.join("|") : X).join(":") : "");
}
class _u {
  constructor(X, ee) {
    ve(this, "tag", X), ve(this, "filter", ee), this._listeners = [];
  }
  addListener(X, ee) {
    this._listeners.push({ listener: X, once: ee });
  }
  removeListener(X) {
    let ee = !1;
    this._listeners = this._listeners.filter((te) => ee || te.listener !== X ? !0 : (ee = !0, !1));
  }
  removeAllListeners() {
    this._listeners = [];
  }
  listeners() {
    return this._listeners.map((X) => X.listener);
  }
  listenerCount() {
    return this._listeners.length;
  }
  run(X) {
    const ee = this.listenerCount();
    return this._listeners = this._listeners.filter((te) => {
      const ne = X.slice();
      return setTimeout(() => {
        te.listener.apply(this, ne);
      }, 0), !te.once;
    }), ee;
  }
  prepareEvent(X) {
  }
  // Returns the array that will be applied to an emit
  getEmit(X) {
    return [X];
  }
}
class PC extends _u {
  constructor() {
    super("error", null);
  }
}
class vx extends _u {
  constructor(X, ee, te, ne) {
    const ie = {
      address: X
    };
    let oe = ee.getEventTopic(te);
    ne ? (oe !== ne[0] && Pr.throwArgumentError("topic mismatch", "topics", ne), ie.topics = ne.slice()) : ie.topics = [oe], super(XE(ie), ie), ve(this, "address", X), ve(this, "interface", ee), ve(this, "fragment", te);
  }
  prepareEvent(X) {
    super.prepareEvent(X), X.event = this.fragment.name, X.eventSignature = this.fragment.format(), X.decode = (ee, te) => this.interface.decodeEventLog(this.fragment, ee, te);
    try {
      X.args = this.interface.decodeEventLog(this.fragment, X.data, X.topics);
    } catch (ee) {
      X.args = null, X.decodeError = ee;
    }
  }
  getEmit(X) {
    const ee = fT(X.args);
    if (ee.length)
      throw ee[0].error;
    const te = (X.args || []).slice();
    return te.push(X), te;
  }
}
class Ex extends _u {
  constructor(X, ee) {
    super("*", { address: X }), ve(this, "address", X), ve(this, "interface", ee);
  }
  prepareEvent(X) {
    super.prepareEvent(X);
    try {
      const ee = this.interface.parseLog(X);
      X.event = ee.name, X.eventSignature = ee.signature, X.decode = (te, ne) => this.interface.decodeEventLog(ee.eventFragment, te, ne), X.args = ee.args;
    } catch {
    }
  }
}
class OC {
  constructor(X, ee, te) {
    ve(this, "interface", ji(new.target, "getInterface")(ee)), te == null ? (ve(this, "provider", null), ve(this, "signer", null)) : hc.isSigner(te) ? (ve(this, "provider", te.provider || null), ve(this, "signer", te)) : dc.isProvider(te) ? (ve(this, "provider", te), ve(this, "signer", null)) : Pr.throwArgumentError("invalid signer or provider", "signerOrProvider", te), ve(this, "callStatic", {}), ve(this, "estimateGas", {}), ve(this, "functions", {}), ve(this, "populateTransaction", {}), ve(this, "filters", {});
    {
      const oe = {};
      Object.keys(this.interface.events).forEach((se) => {
        const ae = this.interface.events[se];
        ve(this.filters, se, (...ue) => ({
          address: this.address,
          topics: this.interface.encodeFilterTopics(ae, ue)
        })), oe[ae.name] || (oe[ae.name] = []), oe[ae.name].push(se);
      }), Object.keys(oe).forEach((se) => {
        const ae = oe[se];
        ae.length === 1 ? ve(this.filters, se, this.filters[ae[0]]) : Pr.warn(`Duplicate definition of ${se} (${ae.join(", ")})`);
      });
    }
    if (ve(this, "_runningEvents", {}), ve(this, "_wrappedEmits", {}), X == null && Pr.throwArgumentError("invalid contract address or ENS name", "addressOrName", X), ve(this, "address", X), this.provider)
      ve(this, "resolvedAddress", $l(this.provider, X));
    else
      try {
        ve(this, "resolvedAddress", Promise.resolve(pr(X)));
      } catch {
        Pr.throwError("provider is required to use ENS name as contract address", ce.errors.UNSUPPORTED_OPERATION, {
          operation: "new Contract"
        });
      }
    this.resolvedAddress.catch((oe) => {
    });
    const ne = {}, ie = {};
    Object.keys(this.interface.functions).forEach((oe) => {
      const se = this.interface.functions[oe];
      if (ie[oe]) {
        Pr.warn(`Duplicate ABI entry for ${JSON.stringify(oe)}`);
        return;
      }
      ie[oe] = !0;
      {
        const ae = se.name;
        ne[`%${ae}`] || (ne[`%${ae}`] = []), ne[`%${ae}`].push(oe);
      }
      this[oe] == null && ve(this, oe, wx(this, se, !0)), this.functions[oe] == null && ve(this.functions, oe, wx(this, se, !1)), this.callStatic[oe] == null && ve(this.callStatic, oe, YE(this, se, !0)), this.populateTransaction[oe] == null && ve(this.populateTransaction, oe, TC(this, se)), this.estimateGas[oe] == null && ve(this.estimateGas, oe, IC(this, se));
    }), Object.keys(ne).forEach((oe) => {
      const se = ne[oe];
      if (se.length > 1)
        return;
      oe = oe.substring(1);
      const ae = se[0];
      try {
        this[oe] == null && ve(this, oe, this[ae]);
      } catch {
      }
      this.functions[oe] == null && ve(this.functions, oe, this.functions[ae]), this.callStatic[oe] == null && ve(this.callStatic, oe, this.callStatic[ae]), this.populateTransaction[oe] == null && ve(this.populateTransaction, oe, this.populateTransaction[ae]), this.estimateGas[oe] == null && ve(this.estimateGas, oe, this.estimateGas[ae]);
    });
  }
  static getContractAddress(X) {
    return tE(X);
  }
  static getInterface(X) {
    return dx.isInterface(X) ? X : new dx(X);
  }
  // @TODO: Allow timeout?
  deployed() {
    return this._deployed();
  }
  _deployed(X) {
    return this._deployedPromise || (this.deployTransaction ? this._deployedPromise = this.deployTransaction.wait().then(() => this) : this._deployedPromise = this.provider.getCode(this.address, X).then((ee) => (ee === "0x" && Pr.throwError("contract not deployed", ce.errors.UNSUPPORTED_OPERATION, {
      contractAddress: this.address,
      operation: "getDeployed"
    }), this))), this._deployedPromise;
  }
  // @TODO:
  // estimateFallback(overrides?: TransactionRequest): Promise<BigNumber>
  // @TODO:
  // estimateDeploy(bytecode: string, ...args): Promise<BigNumber>
  fallback(X) {
    this.signer || Pr.throwError("sending a transactions require a signer", ce.errors.UNSUPPORTED_OPERATION, { operation: "sendTransaction(fallback)" });
    const ee = mr$1(X || {});
    return ["from", "to"].forEach(function(te) {
      ee[te] != null && Pr.throwError("cannot override " + te, ce.errors.UNSUPPORTED_OPERATION, { operation: te });
    }), ee.to = this.resolvedAddress, this.deployed().then(() => this.signer.sendTransaction(ee));
  }
  // Reconnect to a different signer or provider
  connect(X) {
    typeof X == "string" && (X = new lm(X, this.provider));
    const ee = new this.constructor(this.address, this.interface, X);
    return this.deployTransaction && ve(ee, "deployTransaction", this.deployTransaction), ee;
  }
  // Re-attach to a different on-chain instance of this contract
  attach(X) {
    return new this.constructor(X, this.interface, this.signer || this.provider);
  }
  static isIndexed(X) {
    return Fp$2.isIndexed(X);
  }
  _normalizeRunningEvent(X) {
    return this._runningEvents[X.tag] ? this._runningEvents[X.tag] : X;
  }
  _getRunningEvent(X) {
    if (typeof X == "string") {
      if (X === "error")
        return this._normalizeRunningEvent(new PC());
      if (X === "event")
        return this._normalizeRunningEvent(new _u("event", null));
      if (X === "*")
        return this._normalizeRunningEvent(new Ex(this.address, this.interface));
      const ee = this.interface.getEvent(X);
      return this._normalizeRunningEvent(new vx(this.address, this.interface, ee));
    }
    if (X.topics && X.topics.length > 0) {
      try {
        const te = X.topics[0];
        if (typeof te != "string")
          throw new Error("invalid topic");
        const ne = this.interface.getEvent(te);
        return this._normalizeRunningEvent(new vx(this.address, this.interface, ne, X.topics));
      } catch {
      }
      const ee = {
        address: this.address,
        topics: X.topics
      };
      return this._normalizeRunningEvent(new _u(XE(ee), ee));
    }
    return this._normalizeRunningEvent(new Ex(this.address, this.interface));
  }
  _checkRunningEvents(X) {
    if (X.listenerCount() === 0) {
      delete this._runningEvents[X.tag];
      const ee = this._wrappedEmits[X.tag];
      ee && X.filter && (this.provider.off(X.filter, ee), delete this._wrappedEmits[X.tag]);
    }
  }
  // Subclasses can override this to gracefully recover
  // from parse errors if they wish
  _wrapEvent(X, ee, te) {
    const ne = ti(ee);
    return ne.removeListener = () => {
      te && (X.removeListener(te), this._checkRunningEvents(X));
    }, ne.getBlock = () => this.provider.getBlock(ee.blockHash), ne.getTransaction = () => this.provider.getTransaction(ee.transactionHash), ne.getTransactionReceipt = () => this.provider.getTransactionReceipt(ee.transactionHash), X.prepareEvent(ne), ne;
  }
  _addEventListener(X, ee, te) {
    if (this.provider || Pr.throwError("events require a provider or a signer with a provider", ce.errors.UNSUPPORTED_OPERATION, { operation: "once" }), X.addListener(ee, te), this._runningEvents[X.tag] = X, !this._wrappedEmits[X.tag]) {
      const ne = (ie) => {
        let oe = this._wrapEvent(X, ie, ee);
        if (oe.decodeError == null)
          try {
            const se = X.getEmit(oe);
            this.emit(X.filter, ...se);
          } catch (se) {
            oe.decodeError = se.error;
          }
        X.filter != null && this.emit("event", oe), oe.decodeError != null && this.emit("error", oe.decodeError, oe);
      };
      this._wrappedEmits[X.tag] = ne, X.filter != null && this.provider.on(X.filter, ne);
    }
  }
  queryFilter(X, ee, te) {
    const ne = this._getRunningEvent(X), ie = mr$1(ne.filter);
    return typeof ee == "string" && Bt(ee, 32) ? (te != null && Pr.throwArgumentError("cannot specify toBlock with blockhash", "toBlock", te), ie.blockHash = ee) : (ie.fromBlock = ee ?? 0, ie.toBlock = te ?? "latest"), this.provider.getLogs(ie).then((oe) => oe.map((se) => this._wrapEvent(ne, se, null)));
  }
  on(X, ee) {
    return this._addEventListener(this._getRunningEvent(X), ee, !1), this;
  }
  once(X, ee) {
    return this._addEventListener(this._getRunningEvent(X), ee, !0), this;
  }
  emit(X, ...ee) {
    if (!this.provider)
      return !1;
    const te = this._getRunningEvent(X), ne = te.run(ee) > 0;
    return this._checkRunningEvents(te), ne;
  }
  listenerCount(X) {
    return this.provider ? X == null ? Object.keys(this._runningEvents).reduce((ee, te) => ee + this._runningEvents[te].listenerCount(), 0) : this._getRunningEvent(X).listenerCount() : 0;
  }
  listeners(X) {
    if (!this.provider)
      return [];
    if (X == null) {
      const ee = [];
      for (let te in this._runningEvents)
        this._runningEvents[te].listeners().forEach((ne) => {
          ee.push(ne);
        });
      return ee;
    }
    return this._getRunningEvent(X).listeners();
  }
  removeAllListeners(X) {
    if (!this.provider)
      return this;
    if (X == null) {
      for (const te in this._runningEvents) {
        const ne = this._runningEvents[te];
        ne.removeAllListeners(), this._checkRunningEvents(ne);
      }
      return this;
    }
    const ee = this._getRunningEvent(X);
    return ee.removeAllListeners(), this._checkRunningEvents(ee), this;
  }
  off(X, ee) {
    if (!this.provider)
      return this;
    const te = this._getRunningEvent(X);
    return te.removeListener(ee), this._checkRunningEvents(te), this;
  }
  removeListener(X, ee) {
    return this.off(X, ee);
  }
}
class BC extends OC {
}
class ZE {
  constructor(X) {
    ve(this, "alphabet", X), ve(this, "base", X.length), ve(this, "_alphabetMap", {}), ve(this, "_leader", X.charAt(0));
    for (let ee = 0; ee < X.length; ee++)
      this._alphabetMap[X.charAt(ee)] = ee;
  }
  encode(X) {
    let ee = Ne(X);
    if (ee.length === 0)
      return "";
    let te = [0];
    for (let ie = 0; ie < ee.length; ++ie) {
      let oe = ee[ie];
      for (let se = 0; se < te.length; ++se)
        oe += te[se] << 8, te[se] = oe % this.base, oe = oe / this.base | 0;
      for (; oe > 0; )
        te.push(oe % this.base), oe = oe / this.base | 0;
    }
    let ne = "";
    for (let ie = 0; ee[ie] === 0 && ie < ee.length - 1; ++ie)
      ne += this._leader;
    for (let ie = te.length - 1; ie >= 0; --ie)
      ne += this.alphabet[te[ie]];
    return ne;
  }
  decode(X) {
    if (typeof X != "string")
      throw new TypeError("Expected String");
    let ee = [];
    if (X.length === 0)
      return new Uint8Array(ee);
    ee.push(0);
    for (let te = 0; te < X.length; te++) {
      let ne = this._alphabetMap[X[te]];
      if (ne === void 0)
        throw new Error("Non-base" + this.base + " character");
      let ie = ne;
      for (let oe = 0; oe < ee.length; ++oe)
        ie += ee[oe] * this.base, ee[oe] = ie & 255, ie >>= 8;
      for (; ie > 0; )
        ee.push(ie & 255), ie >>= 8;
    }
    for (let te = 0; X[te] === this._leader && te < X.length - 1; ++te)
      ee.push(0);
    return Ne(new Uint8Array(ee.reverse()));
  }
}
new ZE("abcdefghijklmnopqrstuvwxyz234567");
const Au = new ZE("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
var Su;
(function(Y) {
  Y.sha256 = "sha256", Y.sha512 = "sha512";
})(Su || (Su = {}));
const NC = "sha2/5.7.0", kC = new ce(NC);
function MC(Y) {
  return "0x" + kn.ripemd160().update(Ne(Y)).digest("hex");
}
function Mo(Y) {
  return "0x" + kn.sha256().update(Ne(Y)).digest("hex");
}
function Dl(Y, X, ee) {
  return Su[Y] || kC.throwError("unsupported algorithm " + Y, ce.errors.UNSUPPORTED_OPERATION, {
    operation: "hmac",
    algorithm: Y
  }), "0x" + kn.hmac(kn[Y], Ne(X)).update(Ne(ee)).digest("hex");
}
function mm(Y, X, ee, te, ne) {
  Y = Ne(Y), X = Ne(X);
  let ie, oe = 1;
  const se = new Uint8Array(te), ae = new Uint8Array(X.length + 4);
  ae.set(X);
  let ue, le;
  for (let he = 1; he <= oe; he++) {
    ae[X.length] = he >> 24 & 255, ae[X.length + 1] = he >> 16 & 255, ae[X.length + 2] = he >> 8 & 255, ae[X.length + 3] = he & 255;
    let me = Ne(Dl(ne, Y, ae));
    ie || (ie = me.length, le = new Uint8Array(ie), oe = Math.ceil(te / ie), ue = te - (oe - 1) * ie), le.set(me);
    for (let Ee = 1; Ee < ee; Ee++) {
      me = Ne(Dl(ne, Y, me));
      for (let Re = 0; Re < ie; Re++)
        le[Re] ^= me[Re];
    }
    const ye = (he - 1) * ie, we = he === oe ? ue : ie;
    se.set(Ne(le).slice(0, we), ye);
  }
  return Oe(se);
}
const LC = "wordlists/5.7.0", FC = new ce(LC);
class ff {
  constructor(X) {
    FC.checkAbstract(new.target, ff), ve(this, "locale", X);
  }
  // Subclasses may override this
  split(X) {
    return X.toLowerCase().split(/ +/g);
  }
  // Subclasses may override this
  join(X) {
    return X.join(" ");
  }
  static check(X) {
    const ee = [];
    for (let te = 0; te < 2048; te++) {
      const ne = X.getWord(te);
      if (te !== X.getWordIndex(ne))
        return "0x";
      ee.push(ne);
    }
    return Ao(ee.join(`
`) + `
`);
  }
  static register(X, ee) {
    ee || (ee = X.locale);
  }
}
const $C = "AbandonAbilityAbleAboutAboveAbsentAbsorbAbstractAbsurdAbuseAccessAccidentAccountAccuseAchieveAcidAcousticAcquireAcrossActActionActorActressActualAdaptAddAddictAddressAdjustAdmitAdultAdvanceAdviceAerobicAffairAffordAfraidAgainAgeAgentAgreeAheadAimAirAirportAisleAlarmAlbumAlcoholAlertAlienAllAlleyAllowAlmostAloneAlphaAlreadyAlsoAlterAlwaysAmateurAmazingAmongAmountAmusedAnalystAnchorAncientAngerAngleAngryAnimalAnkleAnnounceAnnualAnotherAnswerAntennaAntiqueAnxietyAnyApartApologyAppearAppleApproveAprilArchArcticAreaArenaArgueArmArmedArmorArmyAroundArrangeArrestArriveArrowArtArtefactArtistArtworkAskAspectAssaultAssetAssistAssumeAsthmaAthleteAtomAttackAttendAttitudeAttractAuctionAuditAugustAuntAuthorAutoAutumnAverageAvocadoAvoidAwakeAwareAwayAwesomeAwfulAwkwardAxisBabyBachelorBaconBadgeBagBalanceBalconyBallBambooBananaBannerBarBarelyBargainBarrelBaseBasicBasketBattleBeachBeanBeautyBecauseBecomeBeefBeforeBeginBehaveBehindBelieveBelowBeltBenchBenefitBestBetrayBetterBetweenBeyondBicycleBidBikeBindBiologyBirdBirthBitterBlackBladeBlameBlanketBlastBleakBlessBlindBloodBlossomBlouseBlueBlurBlushBoardBoatBodyBoilBombBoneBonusBookBoostBorderBoringBorrowBossBottomBounceBoxBoyBracketBrainBrandBrassBraveBreadBreezeBrickBridgeBriefBrightBringBriskBroccoliBrokenBronzeBroomBrotherBrownBrushBubbleBuddyBudgetBuffaloBuildBulbBulkBulletBundleBunkerBurdenBurgerBurstBusBusinessBusyButterBuyerBuzzCabbageCabinCableCactusCageCakeCallCalmCameraCampCanCanalCancelCandyCannonCanoeCanvasCanyonCapableCapitalCaptainCarCarbonCardCargoCarpetCarryCartCaseCashCasinoCastleCasualCatCatalogCatchCategoryCattleCaughtCauseCautionCaveCeilingCeleryCementCensusCenturyCerealCertainChairChalkChampionChangeChaosChapterChargeChaseChatCheapCheckCheeseChefCherryChestChickenChiefChildChimneyChoiceChooseChronicChuckleChunkChurnCigarCinnamonCircleCitizenCityCivilClaimClapClarifyClawClayCleanClerkCleverClickClientCliffClimbClinicClipClockClogCloseClothCloudClownClubClumpClusterClutchCoachCoastCoconutCodeCoffeeCoilCoinCollectColorColumnCombineComeComfortComicCommonCompanyConcertConductConfirmCongressConnectConsiderControlConvinceCookCoolCopperCopyCoralCoreCornCorrectCostCottonCouchCountryCoupleCourseCousinCoverCoyoteCrackCradleCraftCramCraneCrashCraterCrawlCrazyCreamCreditCreekCrewCricketCrimeCrispCriticCropCrossCrouchCrowdCrucialCruelCruiseCrumbleCrunchCrushCryCrystalCubeCultureCupCupboardCuriousCurrentCurtainCurveCushionCustomCuteCycleDadDamageDampDanceDangerDaringDashDaughterDawnDayDealDebateDebrisDecadeDecemberDecideDeclineDecorateDecreaseDeerDefenseDefineDefyDegreeDelayDeliverDemandDemiseDenialDentistDenyDepartDependDepositDepthDeputyDeriveDescribeDesertDesignDeskDespairDestroyDetailDetectDevelopDeviceDevoteDiagramDialDiamondDiaryDiceDieselDietDifferDigitalDignityDilemmaDinnerDinosaurDirectDirtDisagreeDiscoverDiseaseDishDismissDisorderDisplayDistanceDivertDivideDivorceDizzyDoctorDocumentDogDollDolphinDomainDonateDonkeyDonorDoorDoseDoubleDoveDraftDragonDramaDrasticDrawDreamDressDriftDrillDrinkDripDriveDropDrumDryDuckDumbDuneDuringDustDutchDutyDwarfDynamicEagerEagleEarlyEarnEarthEasilyEastEasyEchoEcologyEconomyEdgeEditEducateEffortEggEightEitherElbowElderElectricElegantElementElephantElevatorEliteElseEmbarkEmbodyEmbraceEmergeEmotionEmployEmpowerEmptyEnableEnactEndEndlessEndorseEnemyEnergyEnforceEngageEngineEnhanceEnjoyEnlistEnoughEnrichEnrollEnsureEnterEntireEntryEnvelopeEpisodeEqualEquipEraEraseErodeErosionErrorEruptEscapeEssayEssenceEstateEternalEthicsEvidenceEvilEvokeEvolveExactExampleExcessExchangeExciteExcludeExcuseExecuteExerciseExhaustExhibitExileExistExitExoticExpandExpectExpireExplainExposeExpressExtendExtraEyeEyebrowFabricFaceFacultyFadeFaintFaithFallFalseFameFamilyFamousFanFancyFantasyFarmFashionFatFatalFatherFatigueFaultFavoriteFeatureFebruaryFederalFeeFeedFeelFemaleFenceFestivalFetchFeverFewFiberFictionFieldFigureFileFilmFilterFinalFindFineFingerFinishFireFirmFirstFiscalFishFitFitnessFixFlagFlameFlashFlatFlavorFleeFlightFlipFloatFlockFloorFlowerFluidFlushFlyFoamFocusFogFoilFoldFollowFoodFootForceForestForgetForkFortuneForumForwardFossilFosterFoundFoxFragileFrameFrequentFreshFriendFringeFrogFrontFrostFrownFrozenFruitFuelFunFunnyFurnaceFuryFutureGadgetGainGalaxyGalleryGameGapGarageGarbageGardenGarlicGarmentGasGaspGateGatherGaugeGazeGeneralGeniusGenreGentleGenuineGestureGhostGiantGiftGiggleGingerGiraffeGirlGiveGladGlanceGlareGlassGlideGlimpseGlobeGloomGloryGloveGlowGlueGoatGoddessGoldGoodGooseGorillaGospelGossipGovernGownGrabGraceGrainGrantGrapeGrassGravityGreatGreenGridGriefGritGroceryGroupGrowGruntGuardGuessGuideGuiltGuitarGunGymHabitHairHalfHammerHamsterHandHappyHarborHardHarshHarvestHatHaveHawkHazardHeadHealthHeartHeavyHedgehogHeightHelloHelmetHelpHenHeroHiddenHighHillHintHipHireHistoryHobbyHockeyHoldHoleHolidayHollowHomeHoneyHoodHopeHornHorrorHorseHospitalHostHotelHourHoverHubHugeHumanHumbleHumorHundredHungryHuntHurdleHurryHurtHusbandHybridIceIconIdeaIdentifyIdleIgnoreIllIllegalIllnessImageImitateImmenseImmuneImpactImposeImproveImpulseInchIncludeIncomeIncreaseIndexIndicateIndoorIndustryInfantInflictInformInhaleInheritInitialInjectInjuryInmateInnerInnocentInputInquiryInsaneInsectInsideInspireInstallIntactInterestIntoInvestInviteInvolveIronIslandIsolateIssueItemIvoryJacketJaguarJarJazzJealousJeansJellyJewelJobJoinJokeJourneyJoyJudgeJuiceJumpJungleJuniorJunkJustKangarooKeenKeepKetchupKeyKickKidKidneyKindKingdomKissKitKitchenKiteKittenKiwiKneeKnifeKnockKnowLabLabelLaborLadderLadyLakeLampLanguageLaptopLargeLaterLatinLaughLaundryLavaLawLawnLawsuitLayerLazyLeaderLeafLearnLeaveLectureLeftLegLegalLegendLeisureLemonLendLengthLensLeopardLessonLetterLevelLiarLibertyLibraryLicenseLifeLiftLightLikeLimbLimitLinkLionLiquidListLittleLiveLizardLoadLoanLobsterLocalLockLogicLonelyLongLoopLotteryLoudLoungeLoveLoyalLuckyLuggageLumberLunarLunchLuxuryLyricsMachineMadMagicMagnetMaidMailMainMajorMakeMammalManManageMandateMangoMansionManualMapleMarbleMarchMarginMarineMarketMarriageMaskMassMasterMatchMaterialMathMatrixMatterMaximumMazeMeadowMeanMeasureMeatMechanicMedalMediaMelodyMeltMemberMemoryMentionMenuMercyMergeMeritMerryMeshMessageMetalMethodMiddleMidnightMilkMillionMimicMindMinimumMinorMinuteMiracleMirrorMiseryMissMistakeMixMixedMixtureMobileModelModifyMomMomentMonitorMonkeyMonsterMonthMoonMoralMoreMorningMosquitoMotherMotionMotorMountainMouseMoveMovieMuchMuffinMuleMultiplyMuscleMuseumMushroomMusicMustMutualMyselfMysteryMythNaiveNameNapkinNarrowNastyNationNatureNearNeckNeedNegativeNeglectNeitherNephewNerveNestNetNetworkNeutralNeverNewsNextNiceNightNobleNoiseNomineeNoodleNormalNorthNoseNotableNoteNothingNoticeNovelNowNuclearNumberNurseNutOakObeyObjectObligeObscureObserveObtainObviousOccurOceanOctoberOdorOffOfferOfficeOftenOilOkayOldOliveOlympicOmitOnceOneOnionOnlineOnlyOpenOperaOpinionOpposeOptionOrangeOrbitOrchardOrderOrdinaryOrganOrientOriginalOrphanOstrichOtherOutdoorOuterOutputOutsideOvalOvenOverOwnOwnerOxygenOysterOzonePactPaddlePagePairPalacePalmPandaPanelPanicPantherPaperParadeParentParkParrotPartyPassPatchPathPatientPatrolPatternPausePavePaymentPeacePeanutPearPeasantPelicanPenPenaltyPencilPeoplePepperPerfectPermitPersonPetPhonePhotoPhrasePhysicalPianoPicnicPicturePiecePigPigeonPillPilotPinkPioneerPipePistolPitchPizzaPlacePlanetPlasticPlatePlayPleasePledgePluckPlugPlungePoemPoetPointPolarPolePolicePondPonyPoolPopularPortionPositionPossiblePostPotatoPotteryPovertyPowderPowerPracticePraisePredictPreferPreparePresentPrettyPreventPricePridePrimaryPrintPriorityPrisonPrivatePrizeProblemProcessProduceProfitProgramProjectPromoteProofPropertyProsperProtectProudProvidePublicPuddingPullPulpPulsePumpkinPunchPupilPuppyPurchasePurityPurposePursePushPutPuzzlePyramidQualityQuantumQuarterQuestionQuickQuitQuizQuoteRabbitRaccoonRaceRackRadarRadioRailRainRaiseRallyRampRanchRandomRangeRapidRareRateRatherRavenRawRazorReadyRealReasonRebelRebuildRecallReceiveRecipeRecordRecycleReduceReflectReformRefuseRegionRegretRegularRejectRelaxReleaseReliefRelyRemainRememberRemindRemoveRenderRenewRentReopenRepairRepeatReplaceReportRequireRescueResembleResistResourceResponseResultRetireRetreatReturnReunionRevealReviewRewardRhythmRibRibbonRiceRichRideRidgeRifleRightRigidRingRiotRippleRiskRitualRivalRiverRoadRoastRobotRobustRocketRomanceRoofRookieRoomRoseRotateRoughRoundRouteRoyalRubberRudeRugRuleRunRunwayRuralSadSaddleSadnessSafeSailSaladSalmonSalonSaltSaluteSameSampleSandSatisfySatoshiSauceSausageSaveSayScaleScanScareScatterSceneSchemeSchoolScienceScissorsScorpionScoutScrapScreenScriptScrubSeaSearchSeasonSeatSecondSecretSectionSecuritySeedSeekSegmentSelectSellSeminarSeniorSenseSentenceSeriesServiceSessionSettleSetupSevenShadowShaftShallowShareShedShellSheriffShieldShiftShineShipShiverShockShoeShootShopShortShoulderShoveShrimpShrugShuffleShySiblingSickSideSiegeSightSignSilentSilkSillySilverSimilarSimpleSinceSingSirenSisterSituateSixSizeSkateSketchSkiSkillSkinSkirtSkullSlabSlamSleepSlenderSliceSlideSlightSlimSloganSlotSlowSlushSmallSmartSmileSmokeSmoothSnackSnakeSnapSniffSnowSoapSoccerSocialSockSodaSoftSolarSoldierSolidSolutionSolveSomeoneSongSoonSorrySortSoulSoundSoupSourceSouthSpaceSpareSpatialSpawnSpeakSpecialSpeedSpellSpendSphereSpiceSpiderSpikeSpinSpiritSplitSpoilSponsorSpoonSportSpotSpraySpreadSpringSpySquareSqueezeSquirrelStableStadiumStaffStageStairsStampStandStartStateStaySteakSteelStemStepStereoStickStillStingStockStomachStoneStoolStoryStoveStrategyStreetStrikeStrongStruggleStudentStuffStumbleStyleSubjectSubmitSubwaySuccessSuchSuddenSufferSugarSuggestSuitSummerSunSunnySunsetSuperSupplySupremeSureSurfaceSurgeSurpriseSurroundSurveySuspectSustainSwallowSwampSwapSwarmSwearSweetSwiftSwimSwingSwitchSwordSymbolSymptomSyrupSystemTableTackleTagTailTalentTalkTankTapeTargetTaskTasteTattooTaxiTeachTeamTellTenTenantTennisTentTermTestTextThankThatThemeThenTheoryThereTheyThingThisThoughtThreeThriveThrowThumbThunderTicketTideTigerTiltTimberTimeTinyTipTiredTissueTitleToastTobaccoTodayToddlerToeTogetherToiletTokenTomatoTomorrowToneTongueTonightToolToothTopTopicToppleTorchTornadoTortoiseTossTotalTouristTowardTowerTownToyTrackTradeTrafficTragicTrainTransferTrapTrashTravelTrayTreatTreeTrendTrialTribeTrickTriggerTrimTripTrophyTroubleTruckTrueTrulyTrumpetTrustTruthTryTubeTuitionTumbleTunaTunnelTurkeyTurnTurtleTwelveTwentyTwiceTwinTwistTwoTypeTypicalUglyUmbrellaUnableUnawareUncleUncoverUnderUndoUnfairUnfoldUnhappyUniformUniqueUnitUniverseUnknownUnlockUntilUnusualUnveilUpdateUpgradeUpholdUponUpperUpsetUrbanUrgeUsageUseUsedUsefulUselessUsualUtilityVacantVacuumVagueValidValleyValveVanVanishVaporVariousVastVaultVehicleVelvetVendorVentureVenueVerbVerifyVersionVeryVesselVeteranViableVibrantViciousVictoryVideoViewVillageVintageViolinVirtualVirusVisaVisitVisualVitalVividVocalVoiceVoidVolcanoVolumeVoteVoyageWageWagonWaitWalkWallWalnutWantWarfareWarmWarriorWashWaspWasteWaterWaveWayWealthWeaponWearWeaselWeatherWebWeddingWeekendWeirdWelcomeWestWetWhaleWhatWheatWheelWhenWhereWhipWhisperWideWidthWifeWildWillWinWindowWineWingWinkWinnerWinterWireWisdomWiseWishWitnessWolfWomanWonderWoodWoolWordWorkWorldWorryWorthWrapWreckWrestleWristWriteWrongYardYearYellowYouYoungYouthZebraZeroZoneZoo";
let cu = null;
function _x(Y) {
  if (cu == null && (cu = $C.replace(/([A-Z])/g, " $1").toLowerCase().substring(1).split(" "), ff.check(Y) !== "0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60"))
    throw cu = null, new Error("BIP39 Wordlist for en (English) FAILED");
}
class DC extends ff {
  constructor() {
    super("en");
  }
  getWord(X) {
    return _x(this), cu[X];
  }
  getWordIndex(X) {
    return _x(this), cu.indexOf(X);
  }
}
const QE = new DC();
ff.register(QE);
const Ax = {
  en: QE
}, UC = "hdnode/5.7.0", Ul = new ce(UC), jC = Be.from("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"), HC = Xr("Bitcoin seed"), Dc = 2147483648;
function e6(Y) {
  return (1 << Y) - 1 << 8 - Y;
}
function zC(Y) {
  return (1 << Y) - 1;
}
function jf(Y) {
  return hr$1(Oe(Y), 32);
}
function Sx(Y) {
  return Au.encode(Br([Y, Dr(Mo(Mo(Y)), 0, 4)]));
}
function ym(Y) {
  if (Y == null)
    return Ax.en;
  if (typeof Y == "string") {
    const X = Ax[Y];
    return X == null && Ul.throwArgumentError("unknown locale", "wordlist", Y), X;
  }
  return Y;
}
const ta = {}, Tu = "m/44'/60'/0'/0/0";
class Jn {
  /**
   *  This constructor should not be called directly.
   *
   *  Please use:
   *   - fromMnemonic
   *   - fromSeed
   */
  constructor(X, ee, te, ne, ie, oe, se, ae) {
    if (X !== ta)
      throw new Error("HDNode constructor cannot be called directly");
    if (ee) {
      const ue = new Ca(ee);
      ve(this, "privateKey", ue.privateKey), ve(this, "publicKey", ue.compressedPublicKey);
    } else
      ve(this, "privateKey", null), ve(this, "publicKey", Oe(te));
    ve(this, "parentFingerprint", ne), ve(this, "fingerprint", Dr(MC(Mo(this.publicKey)), 0, 4)), ve(this, "address", Ro(this.publicKey)), ve(this, "chainCode", ie), ve(this, "index", oe), ve(this, "depth", se), ae == null ? (ve(this, "mnemonic", null), ve(this, "path", null)) : typeof ae == "string" ? (ve(this, "mnemonic", null), ve(this, "path", ae)) : (ve(this, "mnemonic", ae), ve(this, "path", ae.path));
  }
  get extendedKey() {
    if (this.depth >= 256)
      throw new Error("Depth too large!");
    return Sx(Br([
      this.privateKey != null ? "0x0488ADE4" : "0x0488B21E",
      Oe(this.depth),
      this.parentFingerprint,
      hr$1(Oe(this.index), 4),
      this.chainCode,
      this.privateKey != null ? Br(["0x00", this.privateKey]) : this.publicKey
    ]));
  }
  neuter() {
    return new Jn(ta, null, this.publicKey, this.parentFingerprint, this.chainCode, this.index, this.depth, this.path);
  }
  _derive(X) {
    if (X > 4294967295)
      throw new Error("invalid index - " + String(X));
    let ee = this.path;
    ee && (ee += "/" + (X & ~Dc));
    const te = new Uint8Array(37);
    if (X & Dc) {
      if (!this.privateKey)
        throw new Error("cannot derive child of neutered node");
      te.set(Ne(this.privateKey), 1), ee && (ee += "'");
    } else
      te.set(Ne(this.publicKey));
    for (let he = 24; he >= 0; he -= 8)
      te[33 + (he >> 3)] = X >> 24 - he & 255;
    const ne = Ne(Dl(Su.sha512, this.chainCode, te)), ie = ne.slice(0, 32), oe = ne.slice(32);
    let se = null, ae = null;
    this.privateKey ? se = jf(Be.from(ie).add(this.privateKey).mod(jC)) : ae = new Ca(Oe(ie))._addPoint(this.publicKey);
    let ue = ee;
    const le = this.mnemonic;
    return le && (ue = Object.freeze({
      phrase: le.phrase,
      path: ee,
      locale: le.locale || "en"
    })), new Jn(ta, se, ae, this.fingerprint, jf(oe), X, this.depth + 1, ue);
  }
  derivePath(X) {
    const ee = X.split("/");
    if (ee.length === 0 || ee[0] === "m" && this.depth !== 0)
      throw new Error("invalid path - " + X);
    ee[0] === "m" && ee.shift();
    let te = this;
    for (let ne = 0; ne < ee.length; ne++) {
      const ie = ee[ne];
      if (ie.match(/^[0-9]+'$/)) {
        const oe = parseInt(ie.substring(0, ie.length - 1));
        if (oe >= Dc)
          throw new Error("invalid path index - " + ie);
        te = te._derive(Dc + oe);
      } else if (ie.match(/^[0-9]+$/)) {
        const oe = parseInt(ie);
        if (oe >= Dc)
          throw new Error("invalid path index - " + ie);
        te = te._derive(oe);
      } else
        throw new Error("invalid path component - " + ie);
    }
    return te;
  }
  static _fromSeed(X, ee) {
    const te = Ne(X);
    if (te.length < 16 || te.length > 64)
      throw new Error("invalid seed");
    const ne = Ne(Dl(Su.sha512, HC, te));
    return new Jn(ta, jf(ne.slice(0, 32)), null, "0x00000000", jf(ne.slice(32)), 0, 0, ee);
  }
  static fromMnemonic(X, ee, te) {
    return te = ym(te), X = bm(t6(X, te), te), Jn._fromSeed(qC(X, ee), {
      phrase: X,
      path: "m",
      locale: te.locale
    });
  }
  static fromSeed(X) {
    return Jn._fromSeed(X, null);
  }
  static fromExtendedKey(X) {
    const ee = Au.decode(X);
    (ee.length !== 82 || Sx(ee.slice(0, 78)) !== X) && Ul.throwArgumentError("invalid extended key", "extendedKey", "[REDACTED]");
    const te = ee[4], ne = Oe(ee.slice(5, 9)), ie = parseInt(Oe(ee.slice(9, 13)).substring(2), 16), oe = Oe(ee.slice(13, 45)), se = ee.slice(45, 78);
    switch (Oe(ee.slice(0, 4))) {
      case "0x0488b21e":
      case "0x043587cf":
        return new Jn(ta, null, Oe(se), ne, oe, ie, te, null);
      case "0x0488ade4":
      case "0x04358394 ":
        if (se[0] !== 0)
          break;
        return new Jn(ta, Oe(se.slice(1)), null, ne, oe, ie, te, null);
    }
    return Ul.throwArgumentError("invalid extended key", "extendedKey", "[REDACTED]");
  }
}
function qC(Y, X) {
  X || (X = "");
  const ee = Xr("mnemonic" + X, oo.NFKD);
  return mm(Xr(Y, oo.NFKD), ee, 2048, 64, "sha512");
}
function t6(Y, X) {
  X = ym(X), Ul.checkNormalize();
  const ee = X.split(Y);
  if (ee.length % 3 !== 0)
    throw new Error("invalid mnemonic");
  const te = Ne(new Uint8Array(Math.ceil(11 * ee.length / 8)));
  let ne = 0;
  for (let ae = 0; ae < ee.length; ae++) {
    let ue = X.getWordIndex(ee[ae].normalize("NFKD"));
    if (ue === -1)
      throw new Error("invalid mnemonic");
    for (let le = 0; le < 11; le++)
      ue & 1 << 10 - le && (te[ne >> 3] |= 1 << 7 - ne % 8), ne++;
  }
  const ie = 32 * ee.length / 3, oe = ee.length / 3, se = e6(oe);
  if ((Ne(Mo(te.slice(0, ie / 8)))[0] & se) !== (te[te.length - 1] & se))
    throw new Error("invalid checksum");
  return Oe(te.slice(0, ie / 8));
}
function bm(Y, X) {
  if (X = ym(X), Y = Ne(Y), Y.length % 4 !== 0 || Y.length < 16 || Y.length > 32)
    throw new Error("invalid entropy");
  const ee = [0];
  let te = 11;
  for (let oe = 0; oe < Y.length; oe++)
    te > 8 ? (ee[ee.length - 1] <<= 8, ee[ee.length - 1] |= Y[oe], te -= 8) : (ee[ee.length - 1] <<= te, ee[ee.length - 1] |= Y[oe] >> 8 - te, ee.push(Y[oe] & zC(8 - te)), te += 3);
  const ne = Y.length / 4, ie = Ne(Mo(Y))[0] & e6(ne);
  return ee[ee.length - 1] <<= ne, ee[ee.length - 1] |= ie >> 8 - ne, X.join(ee.map((oe) => X.getWord(oe)));
}
const GC = "random/5.7.0", zp = new ce(GC);
function VC() {
  if (typeof self < "u")
    return self;
  if (typeof window < "u" || typeof window < "u")
    return window;
  throw new Error("unable to locate global object");
}
const Tx = VC();
let _l = Tx.crypto || Tx.msCrypto;
(!_l || !_l.getRandomValues) && (zp.warn("WARNING: Missing strong random number source"), _l = {
  getRandomValues: function(Y) {
    return zp.throwError("no secure random source avaialble", ce.errors.UNSUPPORTED_OPERATION, {
      operation: "crypto.getRandomValues"
    });
  }
});
function nu(Y) {
  (Y <= 0 || Y > 1024 || Y % 1 || Y != Y) && zp.throwArgumentError("invalid length", "length", Y);
  const X = new Uint8Array(Y);
  return _l.getRandomValues(X), Ne(X);
}
function WC(Y) {
  Y = Y.slice();
  for (let X = Y.length - 1; X > 0; X--) {
    const ee = Math.floor(Math.random() * (X + 1)), te = Y[X];
    Y[X] = Y[ee], Y[ee] = te;
  }
  return Y;
}
var r6 = { exports: {} };
(function(Y, X) {
  (function(ee) {
    function te(ge) {
      return parseInt(ge) === ge;
    }
    function ne(ge) {
      if (!te(ge.length))
        return !1;
      for (var Ae = 0; Ae < ge.length; Ae++)
        if (!te(ge[Ae]) || ge[Ae] < 0 || ge[Ae] > 255)
          return !1;
      return !0;
    }
    function ie(ge, Ae) {
      if (ge.buffer && ArrayBuffer.isView(ge) && ge.name === "Uint8Array")
        return Ae && (ge.slice ? ge = ge.slice() : ge = Array.prototype.slice.call(ge)), ge;
      if (Array.isArray(ge)) {
        if (!ne(ge))
          throw new Error("Array contains invalid value: " + ge);
        return new Uint8Array(ge);
      }
      if (te(ge.length) && ne(ge))
        return new Uint8Array(ge);
      throw new Error("unsupported array-like object");
    }
    function oe(ge) {
      return new Uint8Array(ge);
    }
    function se(ge, Ae, Ge, Xe, $e) {
      (Xe != null || $e != null) && (ge.slice ? ge = ge.slice(Xe, $e) : ge = Array.prototype.slice.call(ge, Xe, $e)), Ae.set(ge, Ge);
    }
    var ae = /* @__PURE__ */ function() {
      function ge(Ge) {
        var Xe = [], $e = 0;
        for (Ge = encodeURI(Ge); $e < Ge.length; ) {
          var Ze = Ge.charCodeAt($e++);
          Ze === 37 ? (Xe.push(parseInt(Ge.substr($e, 2), 16)), $e += 2) : Xe.push(Ze);
        }
        return ie(Xe);
      }
      function Ae(Ge) {
        for (var Xe = [], $e = 0; $e < Ge.length; ) {
          var Ze = Ge[$e];
          Ze < 128 ? (Xe.push(String.fromCharCode(Ze)), $e++) : Ze > 191 && Ze < 224 ? (Xe.push(String.fromCharCode((Ze & 31) << 6 | Ge[$e + 1] & 63)), $e += 2) : (Xe.push(String.fromCharCode((Ze & 15) << 12 | (Ge[$e + 1] & 63) << 6 | Ge[$e + 2] & 63)), $e += 3);
        }
        return Xe.join("");
      }
      return {
        toBytes: ge,
        fromBytes: Ae
      };
    }(), ue = /* @__PURE__ */ function() {
      function ge(Xe) {
        for (var $e = [], Ze = 0; Ze < Xe.length; Ze += 2)
          $e.push(parseInt(Xe.substr(Ze, 2), 16));
        return $e;
      }
      var Ae = "0123456789abcdef";
      function Ge(Xe) {
        for (var $e = [], Ze = 0; Ze < Xe.length; Ze++) {
          var ot = Xe[Ze];
          $e.push(Ae[(ot & 240) >> 4] + Ae[ot & 15]);
        }
        return $e.join("");
      }
      return {
        toBytes: ge,
        fromBytes: Ge
      };
    }(), le = { 16: 10, 24: 12, 32: 14 }, he = [1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145], me = [99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171, 118, 202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175, 156, 164, 114, 192, 183, 253, 147, 38, 54, 63, 247, 204, 52, 165, 229, 241, 113, 216, 49, 21, 4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226, 235, 39, 178, 117, 9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 41, 227, 47, 132, 83, 209, 0, 237, 32, 252, 177, 91, 106, 203, 190, 57, 74, 76, 88, 207, 208, 239, 170, 251, 67, 77, 51, 133, 69, 249, 2, 127, 80, 60, 159, 168, 81, 163, 64, 143, 146, 157, 56, 245, 188, 182, 218, 33, 16, 255, 243, 210, 205, 12, 19, 236, 95, 151, 68, 23, 196, 167, 126, 61, 100, 93, 25, 115, 96, 129, 79, 220, 34, 42, 144, 136, 70, 238, 184, 20, 222, 94, 11, 219, 224, 50, 58, 10, 73, 6, 36, 92, 194, 211, 172, 98, 145, 149, 228, 121, 231, 200, 55, 109, 141, 213, 78, 169, 108, 86, 244, 234, 101, 122, 174, 8, 186, 120, 37, 46, 28, 166, 180, 198, 232, 221, 116, 31, 75, 189, 139, 138, 112, 62, 181, 102, 72, 3, 246, 14, 97, 53, 87, 185, 134, 193, 29, 158, 225, 248, 152, 17, 105, 217, 142, 148, 155, 30, 135, 233, 206, 85, 40, 223, 140, 161, 137, 13, 191, 230, 66, 104, 65, 153, 45, 15, 176, 84, 187, 22], ye = [82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 129, 243, 215, 251, 124, 227, 57, 130, 155, 47, 255, 135, 52, 142, 67, 68, 196, 222, 233, 203, 84, 123, 148, 50, 166, 194, 35, 61, 238, 76, 149, 11, 66, 250, 195, 78, 8, 46, 161, 102, 40, 217, 36, 178, 118, 91, 162, 73, 109, 139, 209, 37, 114, 248, 246, 100, 134, 104, 152, 22, 212, 164, 92, 204, 93, 101, 182, 146, 108, 112, 72, 80, 253, 237, 185, 218, 94, 21, 70, 87, 167, 141, 157, 132, 144, 216, 171, 0, 140, 188, 211, 10, 247, 228, 88, 5, 184, 179, 69, 6, 208, 44, 30, 143, 202, 63, 15, 2, 193, 175, 189, 3, 1, 19, 138, 107, 58, 145, 17, 65, 79, 103, 220, 234, 151, 242, 207, 206, 240, 180, 230, 115, 150, 172, 116, 34, 231, 173, 53, 133, 226, 249, 55, 232, 28, 117, 223, 110, 71, 241, 26, 113, 29, 41, 197, 137, 111, 183, 98, 14, 170, 24, 190, 27, 252, 86, 62, 75, 198, 210, 121, 32, 154, 219, 192, 254, 120, 205, 90, 244, 31, 221, 168, 51, 136, 7, 199, 49, 177, 18, 16, 89, 39, 128, 236, 95, 96, 81, 127, 169, 25, 181, 74, 13, 45, 229, 122, 159, 147, 201, 156, 239, 160, 224, 59, 77, 174, 42, 245, 176, 200, 235, 187, 60, 131, 83, 153, 97, 23, 43, 4, 126, 186, 119, 214, 38, 225, 105, 20, 99, 85, 33, 12, 125], we = [3328402341, 4168907908, 4000806809, 4135287693, 4294111757, 3597364157, 3731845041, 2445657428, 1613770832, 33620227, 3462883241, 1445669757, 3892248089, 3050821474, 1303096294, 3967186586, 2412431941, 528646813, 2311702848, 4202528135, 4026202645, 2992200171, 2387036105, 4226871307, 1101901292, 3017069671, 1604494077, 1169141738, 597466303, 1403299063, 3832705686, 2613100635, 1974974402, 3791519004, 1033081774, 1277568618, 1815492186, 2118074177, 4126668546, 2211236943, 1748251740, 1369810420, 3521504564, 4193382664, 3799085459, 2883115123, 1647391059, 706024767, 134480908, 2512897874, 1176707941, 2646852446, 806885416, 932615841, 168101135, 798661301, 235341577, 605164086, 461406363, 3756188221, 3454790438, 1311188841, 2142417613, 3933566367, 302582043, 495158174, 1479289972, 874125870, 907746093, 3698224818, 3025820398, 1537253627, 2756858614, 1983593293, 3084310113, 2108928974, 1378429307, 3722699582, 1580150641, 327451799, 2790478837, 3117535592, 0, 3253595436, 1075847264, 3825007647, 2041688520, 3059440621, 3563743934, 2378943302, 1740553945, 1916352843, 2487896798, 2555137236, 2958579944, 2244988746, 3151024235, 3320835882, 1336584933, 3992714006, 2252555205, 2588757463, 1714631509, 293963156, 2319795663, 3925473552, 67240454, 4269768577, 2689618160, 2017213508, 631218106, 1269344483, 2723238387, 1571005438, 2151694528, 93294474, 1066570413, 563977660, 1882732616, 4059428100, 1673313503, 2008463041, 2950355573, 1109467491, 537923632, 3858759450, 4260623118, 3218264685, 2177748300, 403442708, 638784309, 3287084079, 3193921505, 899127202, 2286175436, 773265209, 2479146071, 1437050866, 4236148354, 2050833735, 3362022572, 3126681063, 840505643, 3866325909, 3227541664, 427917720, 2655997905, 2749160575, 1143087718, 1412049534, 999329963, 193497219, 2353415882, 3354324521, 1807268051, 672404540, 2816401017, 3160301282, 369822493, 2916866934, 3688947771, 1681011286, 1949973070, 336202270, 2454276571, 201721354, 1210328172, 3093060836, 2680341085, 3184776046, 1135389935, 3294782118, 965841320, 831886756, 3554993207, 4068047243, 3588745010, 2345191491, 1849112409, 3664604599, 26054028, 2983581028, 2622377682, 1235855840, 3630984372, 2891339514, 4092916743, 3488279077, 3395642799, 4101667470, 1202630377, 268961816, 1874508501, 4034427016, 1243948399, 1546530418, 941366308, 1470539505, 1941222599, 2546386513, 3421038627, 2715671932, 3899946140, 1042226977, 2521517021, 1639824860, 227249030, 260737669, 3765465232, 2084453954, 1907733956, 3429263018, 2420656344, 100860677, 4160157185, 470683154, 3261161891, 1781871967, 2924959737, 1773779408, 394692241, 2579611992, 974986535, 664706745, 3655459128, 3958962195, 731420851, 571543859, 3530123707, 2849626480, 126783113, 865375399, 765172662, 1008606754, 361203602, 3387549984, 2278477385, 2857719295, 1344809080, 2782912378, 59542671, 1503764984, 160008576, 437062935, 1707065306, 3622233649, 2218934982, 3496503480, 2185314755, 697932208, 1512910199, 504303377, 2075177163, 2824099068, 1841019862, 739644986], Ee = [2781242211, 2230877308, 2582542199, 2381740923, 234877682, 3184946027, 2984144751, 1418839493, 1348481072, 50462977, 2848876391, 2102799147, 434634494, 1656084439, 3863849899, 2599188086, 1167051466, 2636087938, 1082771913, 2281340285, 368048890, 3954334041, 3381544775, 201060592, 3963727277, 1739838676, 4250903202, 3930435503, 3206782108, 4149453988, 2531553906, 1536934080, 3262494647, 484572669, 2923271059, 1783375398, 1517041206, 1098792767, 49674231, 1334037708, 1550332980, 4098991525, 886171109, 150598129, 2481090929, 1940642008, 1398944049, 1059722517, 201851908, 1385547719, 1699095331, 1587397571, 674240536, 2704774806, 252314885, 3039795866, 151914247, 908333586, 2602270848, 1038082786, 651029483, 1766729511, 3447698098, 2682942837, 454166793, 2652734339, 1951935532, 775166490, 758520603, 3000790638, 4004797018, 4217086112, 4137964114, 1299594043, 1639438038, 3464344499, 2068982057, 1054729187, 1901997871, 2534638724, 4121318227, 1757008337, 0, 750906861, 1614815264, 535035132, 3363418545, 3988151131, 3201591914, 1183697867, 3647454910, 1265776953, 3734260298, 3566750796, 3903871064, 1250283471, 1807470800, 717615087, 3847203498, 384695291, 3313910595, 3617213773, 1432761139, 2484176261, 3481945413, 283769337, 100925954, 2180939647, 4037038160, 1148730428, 3123027871, 3813386408, 4087501137, 4267549603, 3229630528, 2315620239, 2906624658, 3156319645, 1215313976, 82966005, 3747855548, 3245848246, 1974459098, 1665278241, 807407632, 451280895, 251524083, 1841287890, 1283575245, 337120268, 891687699, 801369324, 3787349855, 2721421207, 3431482436, 959321879, 1469301956, 4065699751, 2197585534, 1199193405, 2898814052, 3887750493, 724703513, 2514908019, 2696962144, 2551808385, 3516813135, 2141445340, 1715741218, 2119445034, 2872807568, 2198571144, 3398190662, 700968686, 3547052216, 1009259540, 2041044702, 3803995742, 487983883, 1991105499, 1004265696, 1449407026, 1316239930, 504629770, 3683797321, 168560134, 1816667172, 3837287516, 1570751170, 1857934291, 4014189740, 2797888098, 2822345105, 2754712981, 936633572, 2347923833, 852879335, 1133234376, 1500395319, 3084545389, 2348912013, 1689376213, 3533459022, 3762923945, 3034082412, 4205598294, 133428468, 634383082, 2949277029, 2398386810, 3913789102, 403703816, 3580869306, 2297460856, 1867130149, 1918643758, 607656988, 4049053350, 3346248884, 1368901318, 600565992, 2090982877, 2632479860, 557719327, 3717614411, 3697393085, 2249034635, 2232388234, 2430627952, 1115438654, 3295786421, 2865522278, 3633334344, 84280067, 33027830, 303828494, 2747425121, 1600795957, 4188952407, 3496589753, 2434238086, 1486471617, 658119965, 3106381470, 953803233, 334231800, 3005978776, 857870609, 3151128937, 1890179545, 2298973838, 2805175444, 3056442267, 574365214, 2450884487, 550103529, 1233637070, 4289353045, 2018519080, 2057691103, 2399374476, 4166623649, 2148108681, 387583245, 3664101311, 836232934, 3330556482, 3100665960, 3280093505, 2955516313, 2002398509, 287182607, 3413881008, 4238890068, 3597515707, 975967766], Re = [1671808611, 2089089148, 2006576759, 2072901243, 4061003762, 1807603307, 1873927791, 3310653893, 810573872, 16974337, 1739181671, 729634347, 4263110654, 3613570519, 2883997099, 1989864566, 3393556426, 2191335298, 3376449993, 2106063485, 4195741690, 1508618841, 1204391495, 4027317232, 2917941677, 3563566036, 2734514082, 2951366063, 2629772188, 2767672228, 1922491506, 3227229120, 3082974647, 4246528509, 2477669779, 644500518, 911895606, 1061256767, 4144166391, 3427763148, 878471220, 2784252325, 3845444069, 4043897329, 1905517169, 3631459288, 827548209, 356461077, 67897348, 3344078279, 593839651, 3277757891, 405286936, 2527147926, 84871685, 2595565466, 118033927, 305538066, 2157648768, 3795705826, 3945188843, 661212711, 2999812018, 1973414517, 152769033, 2208177539, 745822252, 439235610, 455947803, 1857215598, 1525593178, 2700827552, 1391895634, 994932283, 3596728278, 3016654259, 695947817, 3812548067, 795958831, 2224493444, 1408607827, 3513301457, 0, 3979133421, 543178784, 4229948412, 2982705585, 1542305371, 1790891114, 3410398667, 3201918910, 961245753, 1256100938, 1289001036, 1491644504, 3477767631, 3496721360, 4012557807, 2867154858, 4212583931, 1137018435, 1305975373, 861234739, 2241073541, 1171229253, 4178635257, 33948674, 2139225727, 1357946960, 1011120188, 2679776671, 2833468328, 1374921297, 2751356323, 1086357568, 2408187279, 2460827538, 2646352285, 944271416, 4110742005, 3168756668, 3066132406, 3665145818, 560153121, 271589392, 4279952895, 4077846003, 3530407890, 3444343245, 202643468, 322250259, 3962553324, 1608629855, 2543990167, 1154254916, 389623319, 3294073796, 2817676711, 2122513534, 1028094525, 1689045092, 1575467613, 422261273, 1939203699, 1621147744, 2174228865, 1339137615, 3699352540, 577127458, 712922154, 2427141008, 2290289544, 1187679302, 3995715566, 3100863416, 339486740, 3732514782, 1591917662, 186455563, 3681988059, 3762019296, 844522546, 978220090, 169743370, 1239126601, 101321734, 611076132, 1558493276, 3260915650, 3547250131, 2901361580, 1655096418, 2443721105, 2510565781, 3828863972, 2039214713, 3878868455, 3359869896, 928607799, 1840765549, 2374762893, 3580146133, 1322425422, 2850048425, 1823791212, 1459268694, 4094161908, 3928346602, 1706019429, 2056189050, 2934523822, 135794696, 3134549946, 2022240376, 628050469, 779246638, 472135708, 2800834470, 3032970164, 3327236038, 3894660072, 3715932637, 1956440180, 522272287, 1272813131, 3185336765, 2340818315, 2323976074, 1888542832, 1044544574, 3049550261, 1722469478, 1222152264, 50660867, 4127324150, 236067854, 1638122081, 895445557, 1475980887, 3117443513, 2257655686, 3243809217, 489110045, 2662934430, 3778599393, 4162055160, 2561878936, 288563729, 1773916777, 3648039385, 2391345038, 2493985684, 2612407707, 505560094, 2274497927, 3911240169, 3460925390, 1442818645, 678973480, 3749357023, 2358182796, 2717407649, 2306869641, 219617805, 3218761151, 3862026214, 1120306242, 1756942440, 1103331905, 2578459033, 762796589, 252780047, 2966125488, 1425844308, 3151392187, 372911126], Ue = [1667474886, 2088535288, 2004326894, 2071694838, 4075949567, 1802223062, 1869591006, 3318043793, 808472672, 16843522, 1734846926, 724270422, 4278065639, 3621216949, 2880169549, 1987484396, 3402253711, 2189597983, 3385409673, 2105378810, 4210693615, 1499065266, 1195886990, 4042263547, 2913856577, 3570689971, 2728590687, 2947541573, 2627518243, 2762274643, 1920112356, 3233831835, 3082273397, 4261223649, 2475929149, 640051788, 909531756, 1061110142, 4160160501, 3435941763, 875846760, 2779116625, 3857003729, 4059105529, 1903268834, 3638064043, 825316194, 353713962, 67374088, 3351728789, 589522246, 3284360861, 404236336, 2526454071, 84217610, 2593830191, 117901582, 303183396, 2155911963, 3806477791, 3958056653, 656894286, 2998062463, 1970642922, 151591698, 2206440989, 741110872, 437923380, 454765878, 1852748508, 1515908788, 2694904667, 1381168804, 993742198, 3604373943, 3014905469, 690584402, 3823320797, 791638366, 2223281939, 1398011302, 3520161977, 0, 3991743681, 538992704, 4244381667, 2981218425, 1532751286, 1785380564, 3419096717, 3200178535, 960056178, 1246420628, 1280103576, 1482221744, 3486468741, 3503319995, 4025428677, 2863326543, 4227536621, 1128514950, 1296947098, 859002214, 2240123921, 1162203018, 4193849577, 33687044, 2139062782, 1347481760, 1010582648, 2678045221, 2829640523, 1364325282, 2745433693, 1077985408, 2408548869, 2459086143, 2644360225, 943212656, 4126475505, 3166494563, 3065430391, 3671750063, 555836226, 269496352, 4294908645, 4092792573, 3537006015, 3452783745, 202118168, 320025894, 3974901699, 1600119230, 2543297077, 1145359496, 387397934, 3301201811, 2812801621, 2122220284, 1027426170, 1684319432, 1566435258, 421079858, 1936954854, 1616945344, 2172753945, 1330631070, 3705438115, 572679748, 707427924, 2425400123, 2290647819, 1179044492, 4008585671, 3099120491, 336870440, 3739122087, 1583276732, 185277718, 3688593069, 3772791771, 842159716, 976899700, 168435220, 1229577106, 101059084, 606366792, 1549591736, 3267517855, 3553849021, 2897014595, 1650632388, 2442242105, 2509612081, 3840161747, 2038008818, 3890688725, 3368567691, 926374254, 1835907034, 2374863873, 3587531953, 1313788572, 2846482505, 1819063512, 1448540844, 4109633523, 3941213647, 1701162954, 2054852340, 2930698567, 134748176, 3132806511, 2021165296, 623210314, 774795868, 471606328, 2795958615, 3031746419, 3334885783, 3907527627, 3722280097, 1953799400, 522133822, 1263263126, 3183336545, 2341176845, 2324333839, 1886425312, 1044267644, 3048588401, 1718004428, 1212733584, 50529542, 4143317495, 235803164, 1633788866, 892690282, 1465383342, 3115962473, 2256965911, 3250673817, 488449850, 2661202215, 3789633753, 4177007595, 2560144171, 286339874, 1768537042, 3654906025, 2391705863, 2492770099, 2610673197, 505291324, 2273808917, 3924369609, 3469625735, 1431699370, 673740880, 3755965093, 2358021891, 2711746649, 2307489801, 218961690, 3217021541, 3873845719, 1111672452, 1751693520, 1094828930, 2576986153, 757954394, 252645662, 2964376443, 1414855848, 3149649517, 370555436], Me = [1374988112, 2118214995, 437757123, 975658646, 1001089995, 530400753, 2902087851, 1273168787, 540080725, 2910219766, 2295101073, 4110568485, 1340463100, 3307916247, 641025152, 3043140495, 3736164937, 632953703, 1172967064, 1576976609, 3274667266, 2169303058, 2370213795, 1809054150, 59727847, 361929877, 3211623147, 2505202138, 3569255213, 1484005843, 1239443753, 2395588676, 1975683434, 4102977912, 2572697195, 666464733, 3202437046, 4035489047, 3374361702, 2110667444, 1675577880, 3843699074, 2538681184, 1649639237, 2976151520, 3144396420, 4269907996, 4178062228, 1883793496, 2403728665, 2497604743, 1383856311, 2876494627, 1917518562, 3810496343, 1716890410, 3001755655, 800440835, 2261089178, 3543599269, 807962610, 599762354, 33778362, 3977675356, 2328828971, 2809771154, 4077384432, 1315562145, 1708848333, 101039829, 3509871135, 3299278474, 875451293, 2733856160, 92987698, 2767645557, 193195065, 1080094634, 1584504582, 3178106961, 1042385657, 2531067453, 3711829422, 1306967366, 2438237621, 1908694277, 67556463, 1615861247, 429456164, 3602770327, 2302690252, 1742315127, 2968011453, 126454664, 3877198648, 2043211483, 2709260871, 2084704233, 4169408201, 0, 159417987, 841739592, 504459436, 1817866830, 4245618683, 260388950, 1034867998, 908933415, 168810852, 1750902305, 2606453969, 607530554, 202008497, 2472011535, 3035535058, 463180190, 2160117071, 1641816226, 1517767529, 470948374, 3801332234, 3231722213, 1008918595, 303765277, 235474187, 4069246893, 766945465, 337553864, 1475418501, 2943682380, 4003061179, 2743034109, 4144047775, 1551037884, 1147550661, 1543208500, 2336434550, 3408119516, 3069049960, 3102011747, 3610369226, 1113818384, 328671808, 2227573024, 2236228733, 3535486456, 2935566865, 3341394285, 496906059, 3702665459, 226906860, 2009195472, 733156972, 2842737049, 294930682, 1206477858, 2835123396, 2700099354, 1451044056, 573804783, 2269728455, 3644379585, 2362090238, 2564033334, 2801107407, 2776292904, 3669462566, 1068351396, 742039012, 1350078989, 1784663195, 1417561698, 4136440770, 2430122216, 775550814, 2193862645, 2673705150, 1775276924, 1876241833, 3475313331, 3366754619, 270040487, 3902563182, 3678124923, 3441850377, 1851332852, 3969562369, 2203032232, 3868552805, 2868897406, 566021896, 4011190502, 3135740889, 1248802510, 3936291284, 699432150, 832877231, 708780849, 3332740144, 899835584, 1951317047, 4236429990, 3767586992, 866637845, 4043610186, 1106041591, 2144161806, 395441711, 1984812685, 1139781709, 3433712980, 3835036895, 2664543715, 1282050075, 3240894392, 1181045119, 2640243204, 25965917, 4203181171, 4211818798, 3009879386, 2463879762, 3910161971, 1842759443, 2597806476, 933301370, 1509430414, 3943906441, 3467192302, 3076639029, 3776767469, 2051518780, 2631065433, 1441952575, 404016761, 1942435775, 1408749034, 1610459739, 3745345300, 2017778566, 3400528769, 3110650942, 941896748, 3265478751, 371049330, 3168937228, 675039627, 4279080257, 967311729, 135050206, 3635733660, 1683407248, 2076935265, 3576870512, 1215061108, 3501741890], De = [1347548327, 1400783205, 3273267108, 2520393566, 3409685355, 4045380933, 2880240216, 2471224067, 1428173050, 4138563181, 2441661558, 636813900, 4233094615, 3620022987, 2149987652, 2411029155, 1239331162, 1730525723, 2554718734, 3781033664, 46346101, 310463728, 2743944855, 3328955385, 3875770207, 2501218972, 3955191162, 3667219033, 768917123, 3545789473, 692707433, 1150208456, 1786102409, 2029293177, 1805211710, 3710368113, 3065962831, 401639597, 1724457132, 3028143674, 409198410, 2196052529, 1620529459, 1164071807, 3769721975, 2226875310, 486441376, 2499348523, 1483753576, 428819965, 2274680428, 3075636216, 598438867, 3799141122, 1474502543, 711349675, 129166120, 53458370, 2592523643, 2782082824, 4063242375, 2988687269, 3120694122, 1559041666, 730517276, 2460449204, 4042459122, 2706270690, 3446004468, 3573941694, 533804130, 2328143614, 2637442643, 2695033685, 839224033, 1973745387, 957055980, 2856345839, 106852767, 1371368976, 4181598602, 1033297158, 2933734917, 1179510461, 3046200461, 91341917, 1862534868, 4284502037, 605657339, 2547432937, 3431546947, 2003294622, 3182487618, 2282195339, 954669403, 3682191598, 1201765386, 3917234703, 3388507166, 0, 2198438022, 1211247597, 2887651696, 1315723890, 4227665663, 1443857720, 507358933, 657861945, 1678381017, 560487590, 3516619604, 975451694, 2970356327, 261314535, 3535072918, 2652609425, 1333838021, 2724322336, 1767536459, 370938394, 182621114, 3854606378, 1128014560, 487725847, 185469197, 2918353863, 3106780840, 3356761769, 2237133081, 1286567175, 3152976349, 4255350624, 2683765030, 3160175349, 3309594171, 878443390, 1988838185, 3704300486, 1756818940, 1673061617, 3403100636, 272786309, 1075025698, 545572369, 2105887268, 4174560061, 296679730, 1841768865, 1260232239, 4091327024, 3960309330, 3497509347, 1814803222, 2578018489, 4195456072, 575138148, 3299409036, 446754879, 3629546796, 4011996048, 3347532110, 3252238545, 4270639778, 915985419, 3483825537, 681933534, 651868046, 2755636671, 3828103837, 223377554, 2607439820, 1649704518, 3270937875, 3901806776, 1580087799, 4118987695, 3198115200, 2087309459, 2842678573, 3016697106, 1003007129, 2802849917, 1860738147, 2077965243, 164439672, 4100872472, 32283319, 2827177882, 1709610350, 2125135846, 136428751, 3874428392, 3652904859, 3460984630, 3572145929, 3593056380, 2939266226, 824852259, 818324884, 3224740454, 930369212, 2801566410, 2967507152, 355706840, 1257309336, 4148292826, 243256656, 790073846, 2373340630, 1296297904, 1422699085, 3756299780, 3818836405, 457992840, 3099667487, 2135319889, 77422314, 1560382517, 1945798516, 788204353, 1521706781, 1385356242, 870912086, 325965383, 2358957921, 2050466060, 2388260884, 2313884476, 4006521127, 901210569, 3990953189, 1014646705, 1503449823, 1062597235, 2031621326, 3212035895, 3931371469, 1533017514, 350174575, 2256028891, 2177544179, 1052338372, 741876788, 1606591296, 1914052035, 213705253, 2334669897, 1107234197, 1899603969, 3725069491, 2631447780, 2422494913, 1635502980, 1893020342, 1950903388, 1120974935], Fe = [2807058932, 1699970625, 2764249623, 1586903591, 1808481195, 1173430173, 1487645946, 59984867, 4199882800, 1844882806, 1989249228, 1277555970, 3623636965, 3419915562, 1149249077, 2744104290, 1514790577, 459744698, 244860394, 3235995134, 1963115311, 4027744588, 2544078150, 4190530515, 1608975247, 2627016082, 2062270317, 1507497298, 2200818878, 567498868, 1764313568, 3359936201, 2305455554, 2037970062, 1047239e3, 1910319033, 1337376481, 2904027272, 2892417312, 984907214, 1243112415, 830661914, 861968209, 2135253587, 2011214180, 2927934315, 2686254721, 731183368, 1750626376, 4246310725, 1820824798, 4172763771, 3542330227, 48394827, 2404901663, 2871682645, 671593195, 3254988725, 2073724613, 145085239, 2280796200, 2779915199, 1790575107, 2187128086, 472615631, 3029510009, 4075877127, 3802222185, 4107101658, 3201631749, 1646252340, 4270507174, 1402811438, 1436590835, 3778151818, 3950355702, 3963161475, 4020912224, 2667994737, 273792366, 2331590177, 104699613, 95345982, 3175501286, 2377486676, 1560637892, 3564045318, 369057872, 4213447064, 3919042237, 1137477952, 2658625497, 1119727848, 2340947849, 1530455833, 4007360968, 172466556, 266959938, 516552836, 0, 2256734592, 3980931627, 1890328081, 1917742170, 4294704398, 945164165, 3575528878, 958871085, 3647212047, 2787207260, 1423022939, 775562294, 1739656202, 3876557655, 2530391278, 2443058075, 3310321856, 547512796, 1265195639, 437656594, 3121275539, 719700128, 3762502690, 387781147, 218828297, 3350065803, 2830708150, 2848461854, 428169201, 122466165, 3720081049, 1627235199, 648017665, 4122762354, 1002783846, 2117360635, 695634755, 3336358691, 4234721005, 4049844452, 3704280881, 2232435299, 574624663, 287343814, 612205898, 1039717051, 840019705, 2708326185, 793451934, 821288114, 1391201670, 3822090177, 376187827, 3113855344, 1224348052, 1679968233, 2361698556, 1058709744, 752375421, 2431590963, 1321699145, 3519142200, 2734591178, 188127444, 2177869557, 3727205754, 2384911031, 3215212461, 2648976442, 2450346104, 3432737375, 1180849278, 331544205, 3102249176, 4150144569, 2952102595, 2159976285, 2474404304, 766078933, 313773861, 2570832044, 2108100632, 1668212892, 3145456443, 2013908262, 418672217, 3070356634, 2594734927, 1852171925, 3867060991, 3473416636, 3907448597, 2614737639, 919489135, 164948639, 2094410160, 2997825956, 590424639, 2486224549, 1723872674, 3157750862, 3399941250, 3501252752, 3625268135, 2555048196, 3673637356, 1343127501, 4130281361, 3599595085, 2957853679, 1297403050, 81781910, 3051593425, 2283490410, 532201772, 1367295589, 3926170974, 895287692, 1953757831, 1093597963, 492483431, 3528626907, 1446242576, 1192455638, 1636604631, 209336225, 344873464, 1015671571, 669961897, 3375740769, 3857572124, 2973530695, 3747192018, 1933530610, 3464042516, 935293895, 3454686199, 2858115069, 1863638845, 3683022916, 4085369519, 3292445032, 875313188, 1080017571, 3279033885, 621591778, 1233856572, 2504130317, 24197544, 3017672716, 3835484340, 3247465558, 2220981195, 3060847922, 1551124588, 1463996600], Ke = [4104605777, 1097159550, 396673818, 660510266, 2875968315, 2638606623, 4200115116, 3808662347, 821712160, 1986918061, 3430322568, 38544885, 3856137295, 718002117, 893681702, 1654886325, 2975484382, 3122358053, 3926825029, 4274053469, 796197571, 1290801793, 1184342925, 3556361835, 2405426947, 2459735317, 1836772287, 1381620373, 3196267988, 1948373848, 3764988233, 3385345166, 3263785589, 2390325492, 1480485785, 3111247143, 3780097726, 2293045232, 548169417, 3459953789, 3746175075, 439452389, 1362321559, 1400849762, 1685577905, 1806599355, 2174754046, 137073913, 1214797936, 1174215055, 3731654548, 2079897426, 1943217067, 1258480242, 529487843, 1437280870, 3945269170, 3049390895, 3313212038, 923313619, 679998e3, 3215307299, 57326082, 377642221, 3474729866, 2041877159, 133361907, 1776460110, 3673476453, 96392454, 878845905, 2801699524, 777231668, 4082475170, 2330014213, 4142626212, 2213296395, 1626319424, 1906247262, 1846563261, 562755902, 3708173718, 1040559837, 3871163981, 1418573201, 3294430577, 114585348, 1343618912, 2566595609, 3186202582, 1078185097, 3651041127, 3896688048, 2307622919, 425408743, 3371096953, 2081048481, 1108339068, 2216610296, 0, 2156299017, 736970802, 292596766, 1517440620, 251657213, 2235061775, 2933202493, 758720310, 265905162, 1554391400, 1532285339, 908999204, 174567692, 1474760595, 4002861748, 2610011675, 3234156416, 3693126241, 2001430874, 303699484, 2478443234, 2687165888, 585122620, 454499602, 151849742, 2345119218, 3064510765, 514443284, 4044981591, 1963412655, 2581445614, 2137062819, 19308535, 1928707164, 1715193156, 4219352155, 1126790795, 600235211, 3992742070, 3841024952, 836553431, 1669664834, 2535604243, 3323011204, 1243905413, 3141400786, 4180808110, 698445255, 2653899549, 2989552604, 2253581325, 3252932727, 3004591147, 1891211689, 2487810577, 3915653703, 4237083816, 4030667424, 2100090966, 865136418, 1229899655, 953270745, 3399679628, 3557504664, 4118925222, 2061379749, 3079546586, 2915017791, 983426092, 2022837584, 1607244650, 2118541908, 2366882550, 3635996816, 972512814, 3283088770, 1568718495, 3499326569, 3576539503, 621982671, 2895723464, 410887952, 2623762152, 1002142683, 645401037, 1494807662, 2595684844, 1335535747, 2507040230, 4293295786, 3167684641, 367585007, 3885750714, 1865862730, 2668221674, 2960971305, 2763173681, 1059270954, 2777952454, 2724642869, 1320957812, 2194319100, 2429595872, 2815956275, 77089521, 3973773121, 3444575871, 2448830231, 1305906550, 4021308739, 2857194700, 2516901860, 3518358430, 1787304780, 740276417, 1699839814, 1592394909, 2352307457, 2272556026, 188821243, 1729977011, 3687994002, 274084841, 3594982253, 3613494426, 2701949495, 4162096729, 322734571, 2837966542, 1640576439, 484830689, 1202797690, 3537852828, 4067639125, 349075736, 3342319475, 4157467219, 4255800159, 1030690015, 1155237496, 2951971274, 1757691577, 607398968, 2738905026, 499347990, 3794078908, 1011452712, 227885567, 2818666809, 213114376, 3034881240, 1455525988, 3414450555, 850817237, 1817998408, 3092726480], tt = [0, 235474187, 470948374, 303765277, 941896748, 908933415, 607530554, 708780849, 1883793496, 2118214995, 1817866830, 1649639237, 1215061108, 1181045119, 1417561698, 1517767529, 3767586992, 4003061179, 4236429990, 4069246893, 3635733660, 3602770327, 3299278474, 3400528769, 2430122216, 2664543715, 2362090238, 2193862645, 2835123396, 2801107407, 3035535058, 3135740889, 3678124923, 3576870512, 3341394285, 3374361702, 3810496343, 3977675356, 4279080257, 4043610186, 2876494627, 2776292904, 3076639029, 3110650942, 2472011535, 2640243204, 2403728665, 2169303058, 1001089995, 899835584, 666464733, 699432150, 59727847, 226906860, 530400753, 294930682, 1273168787, 1172967064, 1475418501, 1509430414, 1942435775, 2110667444, 1876241833, 1641816226, 2910219766, 2743034109, 2976151520, 3211623147, 2505202138, 2606453969, 2302690252, 2269728455, 3711829422, 3543599269, 3240894392, 3475313331, 3843699074, 3943906441, 4178062228, 4144047775, 1306967366, 1139781709, 1374988112, 1610459739, 1975683434, 2076935265, 1775276924, 1742315127, 1034867998, 866637845, 566021896, 800440835, 92987698, 193195065, 429456164, 395441711, 1984812685, 2017778566, 1784663195, 1683407248, 1315562145, 1080094634, 1383856311, 1551037884, 101039829, 135050206, 437757123, 337553864, 1042385657, 807962610, 573804783, 742039012, 2531067453, 2564033334, 2328828971, 2227573024, 2935566865, 2700099354, 3001755655, 3168937228, 3868552805, 3902563182, 4203181171, 4102977912, 3736164937, 3501741890, 3265478751, 3433712980, 1106041591, 1340463100, 1576976609, 1408749034, 2043211483, 2009195472, 1708848333, 1809054150, 832877231, 1068351396, 766945465, 599762354, 159417987, 126454664, 361929877, 463180190, 2709260871, 2943682380, 3178106961, 3009879386, 2572697195, 2538681184, 2236228733, 2336434550, 3509871135, 3745345300, 3441850377, 3274667266, 3910161971, 3877198648, 4110568485, 4211818798, 2597806476, 2497604743, 2261089178, 2295101073, 2733856160, 2902087851, 3202437046, 2968011453, 3936291284, 3835036895, 4136440770, 4169408201, 3535486456, 3702665459, 3467192302, 3231722213, 2051518780, 1951317047, 1716890410, 1750902305, 1113818384, 1282050075, 1584504582, 1350078989, 168810852, 67556463, 371049330, 404016761, 841739592, 1008918595, 775550814, 540080725, 3969562369, 3801332234, 4035489047, 4269907996, 3569255213, 3669462566, 3366754619, 3332740144, 2631065433, 2463879762, 2160117071, 2395588676, 2767645557, 2868897406, 3102011747, 3069049960, 202008497, 33778362, 270040487, 504459436, 875451293, 975658646, 675039627, 641025152, 2084704233, 1917518562, 1615861247, 1851332852, 1147550661, 1248802510, 1484005843, 1451044056, 933301370, 967311729, 733156972, 632953703, 260388950, 25965917, 328671808, 496906059, 1206477858, 1239443753, 1543208500, 1441952575, 2144161806, 1908694277, 1675577880, 1842759443, 3610369226, 3644379585, 3408119516, 3307916247, 4011190502, 3776767469, 4077384432, 4245618683, 2809771154, 2842737049, 3144396420, 3043140495, 2673705150, 2438237621, 2203032232, 2370213795], rt = [0, 185469197, 370938394, 487725847, 741876788, 657861945, 975451694, 824852259, 1483753576, 1400783205, 1315723890, 1164071807, 1950903388, 2135319889, 1649704518, 1767536459, 2967507152, 3152976349, 2801566410, 2918353863, 2631447780, 2547432937, 2328143614, 2177544179, 3901806776, 3818836405, 4270639778, 4118987695, 3299409036, 3483825537, 3535072918, 3652904859, 2077965243, 1893020342, 1841768865, 1724457132, 1474502543, 1559041666, 1107234197, 1257309336, 598438867, 681933534, 901210569, 1052338372, 261314535, 77422314, 428819965, 310463728, 3409685355, 3224740454, 3710368113, 3593056380, 3875770207, 3960309330, 4045380933, 4195456072, 2471224067, 2554718734, 2237133081, 2388260884, 3212035895, 3028143674, 2842678573, 2724322336, 4138563181, 4255350624, 3769721975, 3955191162, 3667219033, 3516619604, 3431546947, 3347532110, 2933734917, 2782082824, 3099667487, 3016697106, 2196052529, 2313884476, 2499348523, 2683765030, 1179510461, 1296297904, 1347548327, 1533017514, 1786102409, 1635502980, 2087309459, 2003294622, 507358933, 355706840, 136428751, 53458370, 839224033, 957055980, 605657339, 790073846, 2373340630, 2256028891, 2607439820, 2422494913, 2706270690, 2856345839, 3075636216, 3160175349, 3573941694, 3725069491, 3273267108, 3356761769, 4181598602, 4063242375, 4011996048, 3828103837, 1033297158, 915985419, 730517276, 545572369, 296679730, 446754879, 129166120, 213705253, 1709610350, 1860738147, 1945798516, 2029293177, 1239331162, 1120974935, 1606591296, 1422699085, 4148292826, 4233094615, 3781033664, 3931371469, 3682191598, 3497509347, 3446004468, 3328955385, 2939266226, 2755636671, 3106780840, 2988687269, 2198438022, 2282195339, 2501218972, 2652609425, 1201765386, 1286567175, 1371368976, 1521706781, 1805211710, 1620529459, 2105887268, 1988838185, 533804130, 350174575, 164439672, 46346101, 870912086, 954669403, 636813900, 788204353, 2358957921, 2274680428, 2592523643, 2441661558, 2695033685, 2880240216, 3065962831, 3182487618, 3572145929, 3756299780, 3270937875, 3388507166, 4174560061, 4091327024, 4006521127, 3854606378, 1014646705, 930369212, 711349675, 560487590, 272786309, 457992840, 106852767, 223377554, 1678381017, 1862534868, 1914052035, 2031621326, 1211247597, 1128014560, 1580087799, 1428173050, 32283319, 182621114, 401639597, 486441376, 768917123, 651868046, 1003007129, 818324884, 1503449823, 1385356242, 1333838021, 1150208456, 1973745387, 2125135846, 1673061617, 1756818940, 2970356327, 3120694122, 2802849917, 2887651696, 2637442643, 2520393566, 2334669897, 2149987652, 3917234703, 3799141122, 4284502037, 4100872472, 3309594171, 3460984630, 3545789473, 3629546796, 2050466060, 1899603969, 1814803222, 1730525723, 1443857720, 1560382517, 1075025698, 1260232239, 575138148, 692707433, 878443390, 1062597235, 243256656, 91341917, 409198410, 325965383, 3403100636, 3252238545, 3704300486, 3620022987, 3874428392, 3990953189, 4042459122, 4227665663, 2460449204, 2578018489, 2226875310, 2411029155, 3198115200, 3046200461, 2827177882, 2743944855], it = [0, 218828297, 437656594, 387781147, 875313188, 958871085, 775562294, 590424639, 1750626376, 1699970625, 1917742170, 2135253587, 1551124588, 1367295589, 1180849278, 1265195639, 3501252752, 3720081049, 3399941250, 3350065803, 3835484340, 3919042237, 4270507174, 4085369519, 3102249176, 3051593425, 2734591178, 2952102595, 2361698556, 2177869557, 2530391278, 2614737639, 3145456443, 3060847922, 2708326185, 2892417312, 2404901663, 2187128086, 2504130317, 2555048196, 3542330227, 3727205754, 3375740769, 3292445032, 3876557655, 3926170974, 4246310725, 4027744588, 1808481195, 1723872674, 1910319033, 2094410160, 1608975247, 1391201670, 1173430173, 1224348052, 59984867, 244860394, 428169201, 344873464, 935293895, 984907214, 766078933, 547512796, 1844882806, 1627235199, 2011214180, 2062270317, 1507497298, 1423022939, 1137477952, 1321699145, 95345982, 145085239, 532201772, 313773861, 830661914, 1015671571, 731183368, 648017665, 3175501286, 2957853679, 2807058932, 2858115069, 2305455554, 2220981195, 2474404304, 2658625497, 3575528878, 3625268135, 3473416636, 3254988725, 3778151818, 3963161475, 4213447064, 4130281361, 3599595085, 3683022916, 3432737375, 3247465558, 3802222185, 4020912224, 4172763771, 4122762354, 3201631749, 3017672716, 2764249623, 2848461854, 2331590177, 2280796200, 2431590963, 2648976442, 104699613, 188127444, 472615631, 287343814, 840019705, 1058709744, 671593195, 621591778, 1852171925, 1668212892, 1953757831, 2037970062, 1514790577, 1463996600, 1080017571, 1297403050, 3673637356, 3623636965, 3235995134, 3454686199, 4007360968, 3822090177, 4107101658, 4190530515, 2997825956, 3215212461, 2830708150, 2779915199, 2256734592, 2340947849, 2627016082, 2443058075, 172466556, 122466165, 273792366, 492483431, 1047239e3, 861968209, 612205898, 695634755, 1646252340, 1863638845, 2013908262, 1963115311, 1446242576, 1530455833, 1277555970, 1093597963, 1636604631, 1820824798, 2073724613, 1989249228, 1436590835, 1487645946, 1337376481, 1119727848, 164948639, 81781910, 331544205, 516552836, 1039717051, 821288114, 669961897, 719700128, 2973530695, 3157750862, 2871682645, 2787207260, 2232435299, 2283490410, 2667994737, 2450346104, 3647212047, 3564045318, 3279033885, 3464042516, 3980931627, 3762502690, 4150144569, 4199882800, 3070356634, 3121275539, 2904027272, 2686254721, 2200818878, 2384911031, 2570832044, 2486224549, 3747192018, 3528626907, 3310321856, 3359936201, 3950355702, 3867060991, 4049844452, 4234721005, 1739656202, 1790575107, 2108100632, 1890328081, 1402811438, 1586903591, 1233856572, 1149249077, 266959938, 48394827, 369057872, 418672217, 1002783846, 919489135, 567498868, 752375421, 209336225, 24197544, 376187827, 459744698, 945164165, 895287692, 574624663, 793451934, 1679968233, 1764313568, 2117360635, 1933530610, 1343127501, 1560637892, 1243112415, 1192455638, 3704280881, 3519142200, 3336358691, 3419915562, 3907448597, 3857572124, 4075877127, 4294704398, 3029510009, 3113855344, 2927934315, 2744104290, 2159976285, 2377486676, 2594734927, 2544078150], _t = [0, 151849742, 303699484, 454499602, 607398968, 758720310, 908999204, 1059270954, 1214797936, 1097159550, 1517440620, 1400849762, 1817998408, 1699839814, 2118541908, 2001430874, 2429595872, 2581445614, 2194319100, 2345119218, 3034881240, 3186202582, 2801699524, 2951971274, 3635996816, 3518358430, 3399679628, 3283088770, 4237083816, 4118925222, 4002861748, 3885750714, 1002142683, 850817237, 698445255, 548169417, 529487843, 377642221, 227885567, 77089521, 1943217067, 2061379749, 1640576439, 1757691577, 1474760595, 1592394909, 1174215055, 1290801793, 2875968315, 2724642869, 3111247143, 2960971305, 2405426947, 2253581325, 2638606623, 2487810577, 3808662347, 3926825029, 4044981591, 4162096729, 3342319475, 3459953789, 3576539503, 3693126241, 1986918061, 2137062819, 1685577905, 1836772287, 1381620373, 1532285339, 1078185097, 1229899655, 1040559837, 923313619, 740276417, 621982671, 439452389, 322734571, 137073913, 19308535, 3871163981, 4021308739, 4104605777, 4255800159, 3263785589, 3414450555, 3499326569, 3651041127, 2933202493, 2815956275, 3167684641, 3049390895, 2330014213, 2213296395, 2566595609, 2448830231, 1305906550, 1155237496, 1607244650, 1455525988, 1776460110, 1626319424, 2079897426, 1928707164, 96392454, 213114376, 396673818, 514443284, 562755902, 679998e3, 865136418, 983426092, 3708173718, 3557504664, 3474729866, 3323011204, 4180808110, 4030667424, 3945269170, 3794078908, 2507040230, 2623762152, 2272556026, 2390325492, 2975484382, 3092726480, 2738905026, 2857194700, 3973773121, 3856137295, 4274053469, 4157467219, 3371096953, 3252932727, 3673476453, 3556361835, 2763173681, 2915017791, 3064510765, 3215307299, 2156299017, 2307622919, 2459735317, 2610011675, 2081048481, 1963412655, 1846563261, 1729977011, 1480485785, 1362321559, 1243905413, 1126790795, 878845905, 1030690015, 645401037, 796197571, 274084841, 425408743, 38544885, 188821243, 3613494426, 3731654548, 3313212038, 3430322568, 4082475170, 4200115116, 3780097726, 3896688048, 2668221674, 2516901860, 2366882550, 2216610296, 3141400786, 2989552604, 2837966542, 2687165888, 1202797690, 1320957812, 1437280870, 1554391400, 1669664834, 1787304780, 1906247262, 2022837584, 265905162, 114585348, 499347990, 349075736, 736970802, 585122620, 972512814, 821712160, 2595684844, 2478443234, 2293045232, 2174754046, 3196267988, 3079546586, 2895723464, 2777952454, 3537852828, 3687994002, 3234156416, 3385345166, 4142626212, 4293295786, 3841024952, 3992742070, 174567692, 57326082, 410887952, 292596766, 777231668, 660510266, 1011452712, 893681702, 1108339068, 1258480242, 1343618912, 1494807662, 1715193156, 1865862730, 1948373848, 2100090966, 2701949495, 2818666809, 3004591147, 3122358053, 2235061775, 2352307457, 2535604243, 2653899549, 3915653703, 3764988233, 4219352155, 4067639125, 3444575871, 3294430577, 3746175075, 3594982253, 836553431, 953270745, 600235211, 718002117, 367585007, 484830689, 133361907, 251657213, 2041877159, 1891211689, 1806599355, 1654886325, 1568718495, 1418573201, 1335535747, 1184342925];
    function Dt(ge) {
      for (var Ae = [], Ge = 0; Ge < ge.length; Ge += 4)
        Ae.push(
          ge[Ge] << 24 | ge[Ge + 1] << 16 | ge[Ge + 2] << 8 | ge[Ge + 3]
        );
      return Ae;
    }
    var je = function(ge) {
      if (!(this instanceof je))
        throw Error("AES must be instanitated with `new`");
      Object.defineProperty(this, "key", {
        value: ie(ge, !0)
      }), this._prepare();
    };
    je.prototype._prepare = function() {
      var ge = le[this.key.length];
      if (ge == null)
        throw new Error("invalid key size (must be 16, 24 or 32 bytes)");
      this._Ke = [], this._Kd = [];
      for (var Ae = 0; Ae <= ge; Ae++)
        this._Ke.push([0, 0, 0, 0]), this._Kd.push([0, 0, 0, 0]);
      for (var Ge = (ge + 1) * 4, Xe = this.key.length / 4, $e = Dt(this.key), Ze, Ae = 0; Ae < Xe; Ae++)
        Ze = Ae >> 2, this._Ke[Ze][Ae % 4] = $e[Ae], this._Kd[ge - Ze][Ae % 4] = $e[Ae];
      for (var ot = 0, ct = Xe, At; ct < Ge; ) {
        if (At = $e[Xe - 1], $e[0] ^= me[At >> 16 & 255] << 24 ^ me[At >> 8 & 255] << 16 ^ me[At & 255] << 8 ^ me[At >> 24 & 255] ^ he[ot] << 24, ot += 1, Xe != 8)
          for (var Ae = 1; Ae < Xe; Ae++)
            $e[Ae] ^= $e[Ae - 1];
        else {
          for (var Ae = 1; Ae < Xe / 2; Ae++)
            $e[Ae] ^= $e[Ae - 1];
          At = $e[Xe / 2 - 1], $e[Xe / 2] ^= me[At & 255] ^ me[At >> 8 & 255] << 8 ^ me[At >> 16 & 255] << 16 ^ me[At >> 24 & 255] << 24;
          for (var Ae = Xe / 2 + 1; Ae < Xe; Ae++)
            $e[Ae] ^= $e[Ae - 1];
        }
        for (var Ae = 0, Tt, dt; Ae < Xe && ct < Ge; )
          Tt = ct >> 2, dt = ct % 4, this._Ke[Tt][dt] = $e[Ae], this._Kd[ge - Tt][dt] = $e[Ae++], ct++;
      }
      for (var Tt = 1; Tt < ge; Tt++)
        for (var dt = 0; dt < 4; dt++)
          At = this._Kd[Tt][dt], this._Kd[Tt][dt] = tt[At >> 24 & 255] ^ rt[At >> 16 & 255] ^ it[At >> 8 & 255] ^ _t[At & 255];
    }, je.prototype.encrypt = function(ge) {
      if (ge.length != 16)
        throw new Error("invalid plaintext size (must be 16 bytes)");
      for (var Ae = this._Ke.length - 1, Ge = [0, 0, 0, 0], Xe = Dt(ge), $e = 0; $e < 4; $e++)
        Xe[$e] ^= this._Ke[0][$e];
      for (var Ze = 1; Ze < Ae; Ze++) {
        for (var $e = 0; $e < 4; $e++)
          Ge[$e] = we[Xe[$e] >> 24 & 255] ^ Ee[Xe[($e + 1) % 4] >> 16 & 255] ^ Re[Xe[($e + 2) % 4] >> 8 & 255] ^ Ue[Xe[($e + 3) % 4] & 255] ^ this._Ke[Ze][$e];
        Xe = Ge.slice();
      }
      for (var ot = oe(16), ct, $e = 0; $e < 4; $e++)
        ct = this._Ke[Ae][$e], ot[4 * $e] = (me[Xe[$e] >> 24 & 255] ^ ct >> 24) & 255, ot[4 * $e + 1] = (me[Xe[($e + 1) % 4] >> 16 & 255] ^ ct >> 16) & 255, ot[4 * $e + 2] = (me[Xe[($e + 2) % 4] >> 8 & 255] ^ ct >> 8) & 255, ot[4 * $e + 3] = (me[Xe[($e + 3) % 4] & 255] ^ ct) & 255;
      return ot;
    }, je.prototype.decrypt = function(ge) {
      if (ge.length != 16)
        throw new Error("invalid ciphertext size (must be 16 bytes)");
      for (var Ae = this._Kd.length - 1, Ge = [0, 0, 0, 0], Xe = Dt(ge), $e = 0; $e < 4; $e++)
        Xe[$e] ^= this._Kd[0][$e];
      for (var Ze = 1; Ze < Ae; Ze++) {
        for (var $e = 0; $e < 4; $e++)
          Ge[$e] = Me[Xe[$e] >> 24 & 255] ^ De[Xe[($e + 3) % 4] >> 16 & 255] ^ Fe[Xe[($e + 2) % 4] >> 8 & 255] ^ Ke[Xe[($e + 1) % 4] & 255] ^ this._Kd[Ze][$e];
        Xe = Ge.slice();
      }
      for (var ot = oe(16), ct, $e = 0; $e < 4; $e++)
        ct = this._Kd[Ae][$e], ot[4 * $e] = (ye[Xe[$e] >> 24 & 255] ^ ct >> 24) & 255, ot[4 * $e + 1] = (ye[Xe[($e + 3) % 4] >> 16 & 255] ^ ct >> 16) & 255, ot[4 * $e + 2] = (ye[Xe[($e + 2) % 4] >> 8 & 255] ^ ct >> 8) & 255, ot[4 * $e + 3] = (ye[Xe[($e + 1) % 4] & 255] ^ ct) & 255;
      return ot;
    };
    var ze = function(ge) {
      if (!(this instanceof ze))
        throw Error("AES must be instanitated with `new`");
      this.description = "Electronic Code Block", this.name = "ecb", this._aes = new je(ge);
    };
    ze.prototype.encrypt = function(ge) {
      if (ge = ie(ge), ge.length % 16 !== 0)
        throw new Error("invalid plaintext size (must be multiple of 16 bytes)");
      for (var Ae = oe(ge.length), Ge = oe(16), Xe = 0; Xe < ge.length; Xe += 16)
        se(ge, Ge, 0, Xe, Xe + 16), Ge = this._aes.encrypt(Ge), se(Ge, Ae, Xe);
      return Ae;
    }, ze.prototype.decrypt = function(ge) {
      if (ge = ie(ge), ge.length % 16 !== 0)
        throw new Error("invalid ciphertext size (must be multiple of 16 bytes)");
      for (var Ae = oe(ge.length), Ge = oe(16), Xe = 0; Xe < ge.length; Xe += 16)
        se(ge, Ge, 0, Xe, Xe + 16), Ge = this._aes.decrypt(Ge), se(Ge, Ae, Xe);
      return Ae;
    };
    var fe = function(ge, Ae) {
      if (!(this instanceof fe))
        throw Error("AES must be instanitated with `new`");
      if (this.description = "Cipher Block Chaining", this.name = "cbc", !Ae)
        Ae = oe(16);
      else if (Ae.length != 16)
        throw new Error("invalid initialation vector size (must be 16 bytes)");
      this._lastCipherblock = ie(Ae, !0), this._aes = new je(ge);
    };
    fe.prototype.encrypt = function(ge) {
      if (ge = ie(ge), ge.length % 16 !== 0)
        throw new Error("invalid plaintext size (must be multiple of 16 bytes)");
      for (var Ae = oe(ge.length), Ge = oe(16), Xe = 0; Xe < ge.length; Xe += 16) {
        se(ge, Ge, 0, Xe, Xe + 16);
        for (var $e = 0; $e < 16; $e++)
          Ge[$e] ^= this._lastCipherblock[$e];
        this._lastCipherblock = this._aes.encrypt(Ge), se(this._lastCipherblock, Ae, Xe);
      }
      return Ae;
    }, fe.prototype.decrypt = function(ge) {
      if (ge = ie(ge), ge.length % 16 !== 0)
        throw new Error("invalid ciphertext size (must be multiple of 16 bytes)");
      for (var Ae = oe(ge.length), Ge = oe(16), Xe = 0; Xe < ge.length; Xe += 16) {
        se(ge, Ge, 0, Xe, Xe + 16), Ge = this._aes.decrypt(Ge);
        for (var $e = 0; $e < 16; $e++)
          Ae[Xe + $e] = Ge[$e] ^ this._lastCipherblock[$e];
        se(ge, this._lastCipherblock, 0, Xe, Xe + 16);
      }
      return Ae;
    };
    var de = function(ge, Ae, Ge) {
      if (!(this instanceof de))
        throw Error("AES must be instanitated with `new`");
      if (this.description = "Cipher Feedback", this.name = "cfb", !Ae)
        Ae = oe(16);
      else if (Ae.length != 16)
        throw new Error("invalid initialation vector size (must be 16 size)");
      Ge || (Ge = 1), this.segmentSize = Ge, this._shiftRegister = ie(Ae, !0), this._aes = new je(ge);
    };
    de.prototype.encrypt = function(ge) {
      if (ge.length % this.segmentSize != 0)
        throw new Error("invalid plaintext size (must be segmentSize bytes)");
      for (var Ae = ie(ge, !0), Ge, Xe = 0; Xe < Ae.length; Xe += this.segmentSize) {
        Ge = this._aes.encrypt(this._shiftRegister);
        for (var $e = 0; $e < this.segmentSize; $e++)
          Ae[Xe + $e] ^= Ge[$e];
        se(this._shiftRegister, this._shiftRegister, 0, this.segmentSize), se(Ae, this._shiftRegister, 16 - this.segmentSize, Xe, Xe + this.segmentSize);
      }
      return Ae;
    }, de.prototype.decrypt = function(ge) {
      if (ge.length % this.segmentSize != 0)
        throw new Error("invalid ciphertext size (must be segmentSize bytes)");
      for (var Ae = ie(ge, !0), Ge, Xe = 0; Xe < Ae.length; Xe += this.segmentSize) {
        Ge = this._aes.encrypt(this._shiftRegister);
        for (var $e = 0; $e < this.segmentSize; $e++)
          Ae[Xe + $e] ^= Ge[$e];
        se(this._shiftRegister, this._shiftRegister, 0, this.segmentSize), se(ge, this._shiftRegister, 16 - this.segmentSize, Xe, Xe + this.segmentSize);
      }
      return Ae;
    };
    var be = function(ge, Ae) {
      if (!(this instanceof be))
        throw Error("AES must be instanitated with `new`");
      if (this.description = "Output Feedback", this.name = "ofb", !Ae)
        Ae = oe(16);
      else if (Ae.length != 16)
        throw new Error("invalid initialation vector size (must be 16 bytes)");
      this._lastPrecipher = ie(Ae, !0), this._lastPrecipherIndex = 16, this._aes = new je(ge);
    };
    be.prototype.encrypt = function(ge) {
      for (var Ae = ie(ge, !0), Ge = 0; Ge < Ae.length; Ge++)
        this._lastPrecipherIndex === 16 && (this._lastPrecipher = this._aes.encrypt(this._lastPrecipher), this._lastPrecipherIndex = 0), Ae[Ge] ^= this._lastPrecipher[this._lastPrecipherIndex++];
      return Ae;
    }, be.prototype.decrypt = be.prototype.encrypt;
    var Te = function(ge) {
      if (!(this instanceof Te))
        throw Error("Counter must be instanitated with `new`");
      ge !== 0 && !ge && (ge = 1), typeof ge == "number" ? (this._counter = oe(16), this.setValue(ge)) : this.setBytes(ge);
    };
    Te.prototype.setValue = function(ge) {
      if (typeof ge != "number" || parseInt(ge) != ge)
        throw new Error("invalid counter value (must be an integer)");
      for (var Ae = 15; Ae >= 0; --Ae)
        this._counter[Ae] = ge % 256, ge = ge >> 8;
    }, Te.prototype.setBytes = function(ge) {
      if (ge = ie(ge, !0), ge.length != 16)
        throw new Error("invalid counter bytes size (must be 16 bytes)");
      this._counter = ge;
    }, Te.prototype.increment = function() {
      for (var ge = 15; ge >= 0; ge--)
        if (this._counter[ge] === 255)
          this._counter[ge] = 0;
        else {
          this._counter[ge]++;
          break;
        }
    };
    var Ce = function(ge, Ae) {
      if (!(this instanceof Ce))
        throw Error("AES must be instanitated with `new`");
      this.description = "Counter", this.name = "ctr", Ae instanceof Te || (Ae = new Te(Ae)), this._counter = Ae, this._remainingCounter = null, this._remainingCounterIndex = 16, this._aes = new je(ge);
    };
    Ce.prototype.encrypt = function(ge) {
      for (var Ae = ie(ge, !0), Ge = 0; Ge < Ae.length; Ge++)
        this._remainingCounterIndex === 16 && (this._remainingCounter = this._aes.encrypt(this._counter._counter), this._remainingCounterIndex = 0, this._counter.increment()), Ae[Ge] ^= this._remainingCounter[this._remainingCounterIndex++];
      return Ae;
    }, Ce.prototype.decrypt = Ce.prototype.encrypt;
    function Pe(ge) {
      ge = ie(ge, !0);
      var Ae = 16 - ge.length % 16, Ge = oe(ge.length + Ae);
      se(ge, Ge);
      for (var Xe = ge.length; Xe < Ge.length; Xe++)
        Ge[Xe] = Ae;
      return Ge;
    }
    function Se(ge) {
      if (ge = ie(ge, !0), ge.length < 16)
        throw new Error("PKCS#7 invalid length");
      var Ae = ge[ge.length - 1];
      if (Ae > 16)
        throw new Error("PKCS#7 padding byte out of range");
      for (var Ge = ge.length - Ae, Xe = 0; Xe < Ae; Xe++)
        if (ge[Ge + Xe] !== Ae)
          throw new Error("PKCS#7 invalid padding byte");
      var $e = oe(Ge);
      return se(ge, $e, 0, 0, Ge), $e;
    }
    var ke = {
      AES: je,
      Counter: Te,
      ModeOfOperation: {
        ecb: ze,
        cbc: fe,
        cfb: de,
        ofb: be,
        ctr: Ce
      },
      utils: {
        hex: ue,
        utf8: ae
      },
      padding: {
        pkcs7: {
          pad: Pe,
          strip: Se
        }
      },
      _arrayTest: {
        coerceArray: ie,
        createArray: oe,
        copyArray: se
      }
    };
    Y.exports = ke;
  })();
})(r6);
var KC = r6.exports;
const Hi = /* @__PURE__ */ uc(KC), n6 = "json-wallets/5.7.0";
function Co(Y) {
  return typeof Y == "string" && Y.substring(0, 2) !== "0x" && (Y = "0x" + Y), Ne(Y);
}
function Uc(Y, X) {
  for (Y = String(Y); Y.length < X; )
    Y = "0" + Y;
  return Y;
}
function xm(Y) {
  return typeof Y == "string" ? Xr(Y, oo.NFKC) : Ne(Y);
}
function Or(Y, X) {
  let ee = Y;
  const te = X.toLowerCase().split("/");
  for (let ne = 0; ne < te.length; ne++) {
    let ie = null;
    for (const oe in ee)
      if (oe.toLowerCase() === te[ne]) {
        ie = ee[oe];
        break;
      }
    if (ie === null)
      return null;
    ee = ie;
  }
  return ee;
}
function JC(Y) {
  const X = Ne(Y);
  X[6] = X[6] & 15 | 64, X[8] = X[8] & 63 | 128;
  const ee = Oe(X);
  return [
    ee.substring(2, 10),
    ee.substring(10, 14),
    ee.substring(14, 18),
    ee.substring(18, 22),
    ee.substring(22, 34)
  ].join("-");
}
const YC = new ce(n6);
class XC extends Wo {
  isCrowdsaleAccount(X) {
    return !!(X && X._isCrowdsaleAccount);
  }
}
function i6(Y, X) {
  const ee = JSON.parse(Y);
  X = xm(X);
  const te = pr(Or(ee, "ethaddr")), ne = Co(Or(ee, "encseed"));
  (!ne || ne.length % 16 !== 0) && YC.throwArgumentError("invalid encseed", "json", Y);
  const ie = Ne(mm(X, X, 2e3, 32, "sha256")).slice(0, 16), oe = ne.slice(0, 16), se = ne.slice(16), ae = new Hi.ModeOfOperation.cbc(ie, oe), ue = Hi.padding.pkcs7.strip(Ne(ae.decrypt(se)));
  let le = "";
  for (let ye = 0; ye < ue.length; ye++)
    le += String.fromCharCode(ue[ye]);
  const he = Xr(le), me = gr(he);
  return new XC({
    _isCrowdsaleAccount: !0,
    address: te,
    privateKey: me
  });
}
function s6(Y) {
  let X = null;
  try {
    X = JSON.parse(Y);
  } catch {
    return !1;
  }
  return X.encseed && X.ethaddr;
}
function o6(Y) {
  let X = null;
  try {
    X = JSON.parse(Y);
  } catch {
    return !1;
  }
  return !(!X.version || parseInt(X.version) !== X.version || parseInt(X.version) !== 3);
}
var a6 = { exports: {} };
(function(Y, X) {
  (function(ee) {
    function te(we) {
      const Ee = new Uint32Array([
        1116352408,
        1899447441,
        3049323471,
        3921009573,
        961987163,
        1508970993,
        2453635748,
        2870763221,
        3624381080,
        310598401,
        607225278,
        1426881987,
        1925078388,
        2162078206,
        2614888103,
        3248222580,
        3835390401,
        4022224774,
        264347078,
        604807628,
        770255983,
        1249150122,
        1555081692,
        1996064986,
        2554220882,
        2821834349,
        2952996808,
        3210313671,
        3336571891,
        3584528711,
        113926993,
        338241895,
        666307205,
        773529912,
        1294757372,
        1396182291,
        1695183700,
        1986661051,
        2177026350,
        2456956037,
        2730485921,
        2820302411,
        3259730800,
        3345764771,
        3516065817,
        3600352804,
        4094571909,
        275423344,
        430227734,
        506948616,
        659060556,
        883997877,
        958139571,
        1322822218,
        1537002063,
        1747873779,
        1955562222,
        2024104815,
        2227730452,
        2361852424,
        2428436474,
        2756734187,
        3204031479,
        3329325298
      ]);
      let Re = 1779033703, Ue = 3144134277, Me = 1013904242, De = 2773480762, Fe = 1359893119, Ke = 2600822924, tt = 528734635, rt = 1541459225;
      const it = new Uint32Array(64);
      function _t(Te) {
        let Ce = 0, Pe = Te.length;
        for (; Pe >= 64; ) {
          let Se = Re, ke = Ue, ge = Me, Ae = De, Ge = Fe, Xe = Ke, $e = tt, Ze = rt, ot, ct, At, Tt, dt;
          for (ct = 0; ct < 16; ct++)
            At = Ce + ct * 4, it[ct] = (Te[At] & 255) << 24 | (Te[At + 1] & 255) << 16 | (Te[At + 2] & 255) << 8 | Te[At + 3] & 255;
          for (ct = 16; ct < 64; ct++)
            ot = it[ct - 2], Tt = (ot >>> 17 | ot << 15) ^ (ot >>> 19 | ot << 13) ^ ot >>> 10, ot = it[ct - 15], dt = (ot >>> 7 | ot << 25) ^ (ot >>> 18 | ot << 14) ^ ot >>> 3, it[ct] = (Tt + it[ct - 7] | 0) + (dt + it[ct - 16] | 0) | 0;
          for (ct = 0; ct < 64; ct++)
            Tt = (((Ge >>> 6 | Ge << 26) ^ (Ge >>> 11 | Ge << 21) ^ (Ge >>> 25 | Ge << 7)) + (Ge & Xe ^ ~Ge & $e) | 0) + (Ze + (Ee[ct] + it[ct] | 0) | 0) | 0, dt = ((Se >>> 2 | Se << 30) ^ (Se >>> 13 | Se << 19) ^ (Se >>> 22 | Se << 10)) + (Se & ke ^ Se & ge ^ ke & ge) | 0, Ze = $e, $e = Xe, Xe = Ge, Ge = Ae + Tt | 0, Ae = ge, ge = ke, ke = Se, Se = Tt + dt | 0;
          Re = Re + Se | 0, Ue = Ue + ke | 0, Me = Me + ge | 0, De = De + Ae | 0, Fe = Fe + Ge | 0, Ke = Ke + Xe | 0, tt = tt + $e | 0, rt = rt + Ze | 0, Ce += 64, Pe -= 64;
        }
      }
      _t(we);
      let Dt, je = we.length % 64, ze = we.length / 536870912 | 0, fe = we.length << 3, de = je < 56 ? 56 : 120, be = we.slice(we.length - je, we.length);
      for (be.push(128), Dt = je + 1; Dt < de; Dt++)
        be.push(0);
      return be.push(ze >>> 24 & 255), be.push(ze >>> 16 & 255), be.push(ze >>> 8 & 255), be.push(ze >>> 0 & 255), be.push(fe >>> 24 & 255), be.push(fe >>> 16 & 255), be.push(fe >>> 8 & 255), be.push(fe >>> 0 & 255), _t(be), [
        Re >>> 24 & 255,
        Re >>> 16 & 255,
        Re >>> 8 & 255,
        Re >>> 0 & 255,
        Ue >>> 24 & 255,
        Ue >>> 16 & 255,
        Ue >>> 8 & 255,
        Ue >>> 0 & 255,
        Me >>> 24 & 255,
        Me >>> 16 & 255,
        Me >>> 8 & 255,
        Me >>> 0 & 255,
        De >>> 24 & 255,
        De >>> 16 & 255,
        De >>> 8 & 255,
        De >>> 0 & 255,
        Fe >>> 24 & 255,
        Fe >>> 16 & 255,
        Fe >>> 8 & 255,
        Fe >>> 0 & 255,
        Ke >>> 24 & 255,
        Ke >>> 16 & 255,
        Ke >>> 8 & 255,
        Ke >>> 0 & 255,
        tt >>> 24 & 255,
        tt >>> 16 & 255,
        tt >>> 8 & 255,
        tt >>> 0 & 255,
        rt >>> 24 & 255,
        rt >>> 16 & 255,
        rt >>> 8 & 255,
        rt >>> 0 & 255
      ];
    }
    function ne(we, Ee, Re) {
      we = we.length <= 64 ? we : te(we);
      const Ue = 64 + Ee.length + 4, Me = new Array(Ue), De = new Array(64);
      let Fe, Ke = [];
      for (Fe = 0; Fe < 64; Fe++)
        Me[Fe] = 54;
      for (Fe = 0; Fe < we.length; Fe++)
        Me[Fe] ^= we[Fe];
      for (Fe = 0; Fe < Ee.length; Fe++)
        Me[64 + Fe] = Ee[Fe];
      for (Fe = Ue - 4; Fe < Ue; Fe++)
        Me[Fe] = 0;
      for (Fe = 0; Fe < 64; Fe++)
        De[Fe] = 92;
      for (Fe = 0; Fe < we.length; Fe++)
        De[Fe] ^= we[Fe];
      function tt() {
        for (let rt = Ue - 1; rt >= Ue - 4; rt--) {
          if (Me[rt]++, Me[rt] <= 255)
            return;
          Me[rt] = 0;
        }
      }
      for (; Re >= 32; )
        tt(), Ke = Ke.concat(te(De.concat(te(Me)))), Re -= 32;
      return Re > 0 && (tt(), Ke = Ke.concat(te(De.concat(te(Me))).slice(0, Re))), Ke;
    }
    function ie(we, Ee, Re, Ue, Me) {
      let De;
      for (ue(we, (2 * Re - 1) * 16, Me, 0, 16), De = 0; De < 2 * Re; De++)
        ae(we, De * 16, Me, 16), se(Me, Ue), ue(Me, 0, we, Ee + De * 16, 16);
      for (De = 0; De < Re; De++)
        ue(we, Ee + De * 2 * 16, we, De * 16, 16);
      for (De = 0; De < Re; De++)
        ue(we, Ee + (De * 2 + 1) * 16, we, (De + Re) * 16, 16);
    }
    function oe(we, Ee) {
      return we << Ee | we >>> 32 - Ee;
    }
    function se(we, Ee) {
      ue(we, 0, Ee, 0, 16);
      for (let Re = 8; Re > 0; Re -= 2)
        Ee[4] ^= oe(Ee[0] + Ee[12], 7), Ee[8] ^= oe(Ee[4] + Ee[0], 9), Ee[12] ^= oe(Ee[8] + Ee[4], 13), Ee[0] ^= oe(Ee[12] + Ee[8], 18), Ee[9] ^= oe(Ee[5] + Ee[1], 7), Ee[13] ^= oe(Ee[9] + Ee[5], 9), Ee[1] ^= oe(Ee[13] + Ee[9], 13), Ee[5] ^= oe(Ee[1] + Ee[13], 18), Ee[14] ^= oe(Ee[10] + Ee[6], 7), Ee[2] ^= oe(Ee[14] + Ee[10], 9), Ee[6] ^= oe(Ee[2] + Ee[14], 13), Ee[10] ^= oe(Ee[6] + Ee[2], 18), Ee[3] ^= oe(Ee[15] + Ee[11], 7), Ee[7] ^= oe(Ee[3] + Ee[15], 9), Ee[11] ^= oe(Ee[7] + Ee[3], 13), Ee[15] ^= oe(Ee[11] + Ee[7], 18), Ee[1] ^= oe(Ee[0] + Ee[3], 7), Ee[2] ^= oe(Ee[1] + Ee[0], 9), Ee[3] ^= oe(Ee[2] + Ee[1], 13), Ee[0] ^= oe(Ee[3] + Ee[2], 18), Ee[6] ^= oe(Ee[5] + Ee[4], 7), Ee[7] ^= oe(Ee[6] + Ee[5], 9), Ee[4] ^= oe(Ee[7] + Ee[6], 13), Ee[5] ^= oe(Ee[4] + Ee[7], 18), Ee[11] ^= oe(Ee[10] + Ee[9], 7), Ee[8] ^= oe(Ee[11] + Ee[10], 9), Ee[9] ^= oe(Ee[8] + Ee[11], 13), Ee[10] ^= oe(Ee[9] + Ee[8], 18), Ee[12] ^= oe(Ee[15] + Ee[14], 7), Ee[13] ^= oe(Ee[12] + Ee[15], 9), Ee[14] ^= oe(Ee[13] + Ee[12], 13), Ee[15] ^= oe(Ee[14] + Ee[13], 18);
      for (let Re = 0; Re < 16; ++Re)
        we[Re] += Ee[Re];
    }
    function ae(we, Ee, Re, Ue) {
      for (let Me = 0; Me < Ue; Me++)
        Re[Me] ^= we[Ee + Me];
    }
    function ue(we, Ee, Re, Ue, Me) {
      for (; Me--; )
        Re[Ue++] = we[Ee++];
    }
    function le(we) {
      if (!we || typeof we.length != "number")
        return !1;
      for (let Ee = 0; Ee < we.length; Ee++) {
        const Re = we[Ee];
        if (typeof Re != "number" || Re % 1 || Re < 0 || Re >= 256)
          return !1;
      }
      return !0;
    }
    function he(we, Ee) {
      if (typeof we != "number" || we % 1)
        throw new Error("invalid " + Ee);
      return we;
    }
    function me(we, Ee, Re, Ue, Me, De, Fe) {
      if (Re = he(Re, "N"), Ue = he(Ue, "r"), Me = he(Me, "p"), De = he(De, "dkLen"), Re === 0 || Re & Re - 1)
        throw new Error("N must be power of 2");
      if (Re > 2147483647 / 128 / Ue)
        throw new Error("N too large");
      if (Ue > 2147483647 / 128 / Me)
        throw new Error("r too large");
      if (!le(we))
        throw new Error("password must be an array or buffer");
      if (we = Array.prototype.slice.call(we), !le(Ee))
        throw new Error("salt must be an array or buffer");
      Ee = Array.prototype.slice.call(Ee);
      let Ke = ne(we, Ee, Me * 128 * Ue);
      const tt = new Uint32Array(Me * 32 * Ue);
      for (let Ge = 0; Ge < tt.length; Ge++) {
        const Xe = Ge * 4;
        tt[Ge] = (Ke[Xe + 3] & 255) << 24 | (Ke[Xe + 2] & 255) << 16 | (Ke[Xe + 1] & 255) << 8 | (Ke[Xe + 0] & 255) << 0;
      }
      const rt = new Uint32Array(64 * Ue), it = new Uint32Array(32 * Ue * Re), _t = 32 * Ue, Dt = new Uint32Array(16), je = new Uint32Array(16), ze = Me * Re * 2;
      let fe = 0, de = null, be = !1, Te = 0, Ce = 0, Pe, Se;
      const ke = Fe ? parseInt(1e3 / Ue) : 4294967295, ge = typeof setImmediate < "u" ? setImmediate : setTimeout, Ae = function() {
        if (be)
          return Fe(new Error("cancelled"), fe / ze);
        let Ge;
        switch (Te) {
          case 0:
            Se = Ce * 32 * Ue, ue(tt, Se, rt, 0, _t), Te = 1, Pe = 0;
          case 1:
            Ge = Re - Pe, Ge > ke && (Ge = ke);
            for (let $e = 0; $e < Ge; $e++)
              ue(rt, 0, it, (Pe + $e) * _t, _t), ie(rt, _t, Ue, Dt, je);
            if (Pe += Ge, fe += Ge, Fe) {
              const $e = parseInt(1e3 * fe / ze);
              if ($e !== de) {
                if (be = Fe(null, fe / ze), be)
                  break;
                de = $e;
              }
            }
            if (Pe < Re)
              break;
            Pe = 0, Te = 2;
          case 2:
            Ge = Re - Pe, Ge > ke && (Ge = ke);
            for (let $e = 0; $e < Ge; $e++) {
              const Ze = (2 * Ue - 1) * 16, ot = rt[Ze] & Re - 1;
              ae(it, ot * _t, rt, _t), ie(rt, _t, Ue, Dt, je);
            }
            if (Pe += Ge, fe += Ge, Fe) {
              const $e = parseInt(1e3 * fe / ze);
              if ($e !== de) {
                if (be = Fe(null, fe / ze), be)
                  break;
                de = $e;
              }
            }
            if (Pe < Re)
              break;
            if (ue(rt, 0, tt, Se, _t), Ce++, Ce < Me) {
              Te = 0;
              break;
            }
            Ke = [];
            for (let $e = 0; $e < tt.length; $e++)
              Ke.push(tt[$e] >> 0 & 255), Ke.push(tt[$e] >> 8 & 255), Ke.push(tt[$e] >> 16 & 255), Ke.push(tt[$e] >> 24 & 255);
            const Xe = ne(we, Ke, De);
            return Fe && Fe(null, 1, Xe), Xe;
        }
        Fe && ge(Ae);
      };
      if (!Fe)
        for (; ; ) {
          const Ge = Ae();
          if (Ge != null)
            return Ge;
        }
      Ae();
    }
    const ye = {
      scrypt: function(we, Ee, Re, Ue, Me, De, Fe) {
        return new Promise(function(Ke, tt) {
          let rt = 0;
          Fe && Fe(0), me(we, Ee, Re, Ue, Me, De, function(it, _t, Dt) {
            if (it)
              tt(it);
            else if (Dt)
              Fe && rt !== 1 && Fe(1), Ke(new Uint8Array(Dt));
            else if (Fe && _t !== rt)
              return rt = _t, Fe(_t);
          });
        });
      },
      syncScrypt: function(we, Ee, Re, Ue, Me, De) {
        return new Uint8Array(me(we, Ee, Re, Ue, Me, De));
      }
    };
    Y.exports = ye;
  })();
})(a6);
var ZC = a6.exports;
const wm = /* @__PURE__ */ uc(ZC);
var QC = function(Y, X, ee, te) {
  function ne(ie) {
    return ie instanceof ee ? ie : new ee(function(oe) {
      oe(ie);
    });
  }
  return new (ee || (ee = Promise))(function(ie, oe) {
    function se(le) {
      try {
        ue(te.next(le));
      } catch (he) {
        oe(he);
      }
    }
    function ae(le) {
      try {
        ue(te.throw(le));
      } catch (he) {
        oe(he);
      }
    }
    function ue(le) {
      le.done ? ie(le.value) : ne(le.value).then(se, ae);
    }
    ue((te = te.apply(Y, X || [])).next());
  });
};
const qp = new ce(n6);
function Ix(Y) {
  return Y != null && Y.mnemonic && Y.mnemonic.phrase;
}
class e9 extends Wo {
  isKeystoreAccount(X) {
    return !!(X && X._isKeystoreAccount);
  }
}
function t9(Y, X, ee) {
  if (Or(Y, "crypto/cipher") === "aes-128-ctr") {
    const te = Co(Or(Y, "crypto/cipherparams/iv")), ne = new Hi.Counter(te), ie = new Hi.ModeOfOperation.ctr(X, ne);
    return Ne(ie.decrypt(ee));
  }
  return null;
}
function c6(Y, X) {
  const ee = Co(Or(Y, "crypto/ciphertext"));
  if (Oe(gr(Br([X.slice(16, 32), ee]))).substring(2) !== Or(Y, "crypto/mac").toLowerCase())
    throw new Error("invalid password");
  const te = t9(Y, X.slice(0, 16), ee);
  te || qp.throwError("unsupported cipher", ce.errors.UNSUPPORTED_OPERATION, {
    operation: "decrypt"
  });
  const ne = X.slice(32, 64), ie = Ro(te);
  if (Y.address) {
    let se = Y.address.toLowerCase();
    if (se.substring(0, 2) !== "0x" && (se = "0x" + se), pr(se) !== ie)
      throw new Error("address mismatch");
  }
  const oe = {
    _isKeystoreAccount: !0,
    address: ie,
    privateKey: Oe(te)
  };
  if (Or(Y, "x-ethers/version") === "0.1") {
    const se = Co(Or(Y, "x-ethers/mnemonicCiphertext")), ae = Co(Or(Y, "x-ethers/mnemonicCounter")), ue = new Hi.Counter(ae), le = new Hi.ModeOfOperation.ctr(ne, ue), he = Or(Y, "x-ethers/path") || Tu, me = Or(Y, "x-ethers/locale") || "en", ye = Ne(le.decrypt(se));
    try {
      const we = bm(ye, me), Ee = Jn.fromMnemonic(we, null, me).derivePath(he);
      if (Ee.privateKey != oe.privateKey)
        throw new Error("mnemonic mismatch");
      oe.mnemonic = Ee.mnemonic;
    } catch (we) {
      if (we.code !== ce.errors.INVALID_ARGUMENT || we.argument !== "wordlist")
        throw we;
    }
  }
  return new e9(oe);
}
function u6(Y, X, ee, te, ne) {
  return Ne(mm(Y, X, ee, te, ne));
}
function r9(Y, X, ee, te, ne) {
  return Promise.resolve(u6(Y, X, ee, te, ne));
}
function f6(Y, X, ee, te, ne) {
  const ie = xm(X), oe = Or(Y, "crypto/kdf");
  if (oe && typeof oe == "string") {
    const se = function(ae, ue) {
      return qp.throwArgumentError("invalid key-derivation function parameters", ae, ue);
    };
    if (oe.toLowerCase() === "scrypt") {
      const ae = Co(Or(Y, "crypto/kdfparams/salt")), ue = parseInt(Or(Y, "crypto/kdfparams/n")), le = parseInt(Or(Y, "crypto/kdfparams/r")), he = parseInt(Or(Y, "crypto/kdfparams/p"));
      (!ue || !le || !he) && se("kdf", oe), ue & ue - 1 && se("N", ue);
      const me = parseInt(Or(Y, "crypto/kdfparams/dklen"));
      return me !== 32 && se("dklen", me), te(ie, ae, ue, le, he, 64, ne);
    } else if (oe.toLowerCase() === "pbkdf2") {
      const ae = Co(Or(Y, "crypto/kdfparams/salt"));
      let ue = null;
      const le = Or(Y, "crypto/kdfparams/prf");
      le === "hmac-sha256" ? ue = "sha256" : le === "hmac-sha512" ? ue = "sha512" : se("prf", le);
      const he = parseInt(Or(Y, "crypto/kdfparams/c")), me = parseInt(Or(Y, "crypto/kdfparams/dklen"));
      return me !== 32 && se("dklen", me), ee(ie, ae, he, me, ue);
    }
  }
  return qp.throwArgumentError("unsupported key-derivation function", "kdf", oe);
}
function n9(Y, X) {
  const ee = JSON.parse(Y), te = f6(ee, X, u6, wm.syncScrypt);
  return c6(ee, te);
}
function i9(Y, X, ee) {
  return QC(this, void 0, void 0, function* () {
    const te = JSON.parse(Y), ne = yield f6(te, X, r9, wm.scrypt, ee);
    return c6(te, ne);
  });
}
function s9(Y, X, ee, te) {
  try {
    if (pr(Y.address) !== Ro(Y.privateKey))
      throw new Error("address/privateKey mismatch");
    if (Ix(Y)) {
      const Re = Y.mnemonic;
      if (Jn.fromMnemonic(Re.phrase, null, Re.locale).derivePath(Re.path || Tu).privateKey != Y.privateKey)
        throw new Error("mnemonic mismatch");
    }
  } catch (Re) {
    return Promise.reject(Re);
  }
  typeof ee == "function" && !te && (te = ee, ee = {}), ee || (ee = {});
  const ne = Ne(Y.privateKey), ie = xm(X);
  let oe = null, se = null, ae = null;
  if (Ix(Y)) {
    const Re = Y.mnemonic;
    oe = Ne(t6(Re.phrase, Re.locale || "en")), se = Re.path || Tu, ae = Re.locale || "en";
  }
  let ue = ee.client;
  ue || (ue = "ethers.js");
  let le = null;
  ee.salt ? le = Ne(ee.salt) : le = nu(32);
  let he = null;
  if (ee.iv) {
    if (he = Ne(ee.iv), he.length !== 16)
      throw new Error("invalid iv");
  } else
    he = nu(16);
  let me = null;
  if (ee.uuid) {
    if (me = Ne(ee.uuid), me.length !== 16)
      throw new Error("invalid uuid");
  } else
    me = nu(16);
  let ye = 1 << 17, we = 8, Ee = 1;
  return ee.scrypt && (ee.scrypt.N && (ye = ee.scrypt.N), ee.scrypt.r && (we = ee.scrypt.r), ee.scrypt.p && (Ee = ee.scrypt.p)), wm.scrypt(ie, le, ye, we, Ee, 64, te).then((Re) => {
    Re = Ne(Re);
    const Ue = Re.slice(0, 16), Me = Re.slice(16, 32), De = Re.slice(32, 64), Fe = new Hi.Counter(he), Ke = new Hi.ModeOfOperation.ctr(Ue, Fe), tt = Ne(Ke.encrypt(ne)), rt = gr(Br([Me, tt])), it = {
      address: Y.address.substring(2).toLowerCase(),
      id: JC(me),
      version: 3,
      crypto: {
        cipher: "aes-128-ctr",
        cipherparams: {
          iv: Oe(he).substring(2)
        },
        ciphertext: Oe(tt).substring(2),
        kdf: "scrypt",
        kdfparams: {
          salt: Oe(le).substring(2),
          n: ye,
          dklen: 32,
          p: Ee,
          r: we
        },
        mac: rt.substring(2)
      }
    };
    if (oe) {
      const _t = nu(16), Dt = new Hi.Counter(_t), je = new Hi.ModeOfOperation.ctr(De, Dt), ze = Ne(je.encrypt(oe)), fe = /* @__PURE__ */ new Date(), de = fe.getUTCFullYear() + "-" + Uc(fe.getUTCMonth() + 1, 2) + "-" + Uc(fe.getUTCDate(), 2) + "T" + Uc(fe.getUTCHours(), 2) + "-" + Uc(fe.getUTCMinutes(), 2) + "-" + Uc(fe.getUTCSeconds(), 2) + ".0Z";
      it["x-ethers"] = {
        client: ue,
        gethFilename: "UTC--" + de + "--" + it.address,
        mnemonicCounter: Oe(_t).substring(2),
        mnemonicCiphertext: Oe(ze).substring(2),
        path: se,
        locale: ae,
        version: "0.1"
      };
    }
    return JSON.stringify(it);
  });
}
function o9(Y, X, ee) {
  if (s6(Y)) {
    ee && ee(0);
    const te = i6(Y, X);
    return ee && ee(1), Promise.resolve(te);
  }
  return o6(Y) ? i9(Y, X, ee) : Promise.reject(new Error("invalid JSON wallet"));
}
function a9(Y, X) {
  if (s6(Y))
    return i6(Y, X);
  if (o6(Y))
    return n9(Y, X);
  throw new Error("invalid JSON wallet");
}
const c9 = "wallet/5.7.0";
var Rx = function(Y, X, ee, te) {
  function ne(ie) {
    return ie instanceof ee ? ie : new ee(function(oe) {
      oe(ie);
    });
  }
  return new (ee || (ee = Promise))(function(ie, oe) {
    function se(le) {
      try {
        ue(te.next(le));
      } catch (he) {
        oe(he);
      }
    }
    function ae(le) {
      try {
        ue(te.throw(le));
      } catch (he) {
        oe(he);
      }
    }
    function ue(le) {
      le.done ? ie(le.value) : ne(le.value).then(se, ae);
    }
    ue((te = te.apply(Y, X || [])).next());
  });
};
const ra = new ce(c9);
function u9(Y) {
  return Y != null && Bt(Y.privateKey, 32) && Y.address != null;
}
function f9(Y) {
  const X = Y.mnemonic;
  return X && X.phrase;
}
class Ys extends hc {
  constructor(X, ee) {
    if (super(), u9(X)) {
      const te = new Ca(X.privateKey);
      if (ve(this, "_signingKey", () => te), ve(this, "address", Ro(this.publicKey)), this.address !== pr(X.address) && ra.throwArgumentError("privateKey/address mismatch", "privateKey", "[REDACTED]"), f9(X)) {
        const ne = X.mnemonic;
        ve(this, "_mnemonic", () => ({
          phrase: ne.phrase,
          path: ne.path || Tu,
          locale: ne.locale || "en"
        }));
        const ie = this.mnemonic, oe = Jn.fromMnemonic(ie.phrase, null, ie.locale).derivePath(ie.path);
        Ro(oe.privateKey) !== this.address && ra.throwArgumentError("mnemonic/address mismatch", "privateKey", "[REDACTED]");
      } else
        ve(this, "_mnemonic", () => null);
    } else {
      if (Ca.isSigningKey(X))
        X.curve !== "secp256k1" && ra.throwArgumentError("unsupported curve; must be secp256k1", "privateKey", "[REDACTED]"), ve(this, "_signingKey", () => X);
      else {
        typeof X == "string" && X.match(/^[0-9a-f]*$/i) && X.length === 64 && (X = "0x" + X);
        const te = new Ca(X);
        ve(this, "_signingKey", () => te);
      }
      ve(this, "_mnemonic", () => null), ve(this, "address", Ro(this.publicKey));
    }
    ee && !dc.isProvider(ee) && ra.throwArgumentError("invalid provider", "provider", ee), ve(this, "provider", ee || null);
  }
  get mnemonic() {
    return this._mnemonic();
  }
  get privateKey() {
    return this._signingKey().privateKey;
  }
  get publicKey() {
    return this._signingKey().publicKey;
  }
  getAddress() {
    return Promise.resolve(this.address);
  }
  connect(X) {
    return new Ys(this, X);
  }
  signTransaction(X) {
    return Cr(X).then((ee) => {
      ee.from != null && (pr(ee.from) !== this.address && ra.throwArgumentError("transaction from address mismatch", "transaction.from", X.from), delete ee.from);
      const te = this._signingKey().signDigest(gr(xx(ee)));
      return xx(ee, te);
    });
  }
  signMessage(X) {
    return Rx(this, void 0, void 0, function* () {
      return Wb(this._signingKey().signDigest(pI(X)));
    });
  }
  _signTypedData(X, ee, te) {
    return Rx(this, void 0, void 0, function* () {
      const ne = yield gn.resolveNames(X, ee, te, (ie) => (this.provider == null && ra.throwError("cannot resolve ENS names without a provider", ce.errors.UNSUPPORTED_OPERATION, {
        operation: "resolveName",
        value: ie
      }), this.provider.resolveName(ie)));
      return Wb(this._signingKey().signDigest(gn.hash(ne.domain, ee, ne.value)));
    });
  }
  encrypt(X, ee, te) {
    if (typeof ee == "function" && !te && (te = ee, ee = {}), te && typeof te != "function")
      throw new Error("invalid callback");
    return ee || (ee = {}), s9(this, X, ee, te);
  }
  /**
   *  Static methods to create Wallet instances.
   */
  static createRandom(X) {
    let ee = nu(16);
    X || (X = {}), X.extraEntropy && (ee = Ne(Dr(gr(Br([ee, X.extraEntropy])), 0, 16)));
    const te = bm(ee, X.locale);
    return Ys.fromMnemonic(te, X.path, X.locale);
  }
  static fromEncryptedJson(X, ee, te) {
    return o9(X, ee, te).then((ne) => new Ys(ne));
  }
  static fromEncryptedJsonSync(X, ee) {
    return new Ys(a9(X, ee));
  }
  static fromMnemonic(X, ee, te) {
    return ee || (ee = Tu), new Ys(Jn.fromMnemonic(X, null, te).derivePath(ee));
  }
}
const l9 = "networks/5.7.1", Cx = new ce(l9);
function d9(Y) {
  return Y && typeof Y.renetwork == "function";
}
function ms(Y) {
  const X = function(ee, te) {
    te == null && (te = {});
    const ne = [];
    if (ee.InfuraProvider && te.infura !== "-")
      try {
        ne.push(new ee.InfuraProvider(Y, te.infura));
      } catch {
      }
    if (ee.EtherscanProvider && te.etherscan !== "-")
      try {
        ne.push(new ee.EtherscanProvider(Y, te.etherscan));
      } catch {
      }
    if (ee.AlchemyProvider && te.alchemy !== "-")
      try {
        ne.push(new ee.AlchemyProvider(Y, te.alchemy));
      } catch {
      }
    if (ee.PocketProvider && te.pocket !== "-") {
      const ie = ["goerli", "ropsten", "rinkeby", "sepolia"];
      try {
        const oe = new ee.PocketProvider(Y, te.pocket);
        oe.network && ie.indexOf(oe.network.name) === -1 && ne.push(oe);
      } catch {
      }
    }
    if (ee.CloudflareProvider && te.cloudflare !== "-")
      try {
        ne.push(new ee.CloudflareProvider(Y));
      } catch {
      }
    if (ee.AnkrProvider && te.ankr !== "-")
      try {
        const ie = ["ropsten"], oe = new ee.AnkrProvider(Y, te.ankr);
        oe.network && ie.indexOf(oe.network.name) === -1 && ne.push(oe);
      } catch {
      }
    if (ne.length === 0)
      return null;
    if (ee.FallbackProvider) {
      let ie = 1;
      return te.quorum != null ? ie = te.quorum : Y === "homestead" && (ie = 2), new ee.FallbackProvider(ne, ie);
    }
    return ne[0];
  };
  return X.renetwork = function(ee) {
    return ms(ee);
  }, X;
}
function jl(Y, X) {
  const ee = function(te, ne) {
    return te.JsonRpcProvider ? new te.JsonRpcProvider(Y, X) : null;
  };
  return ee.renetwork = function(te) {
    return jl(Y, te);
  }, ee;
}
const Px = {
  chainId: 1,
  ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
  name: "homestead",
  _defaultProvider: ms("homestead")
}, Ox = {
  chainId: 3,
  ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
  name: "ropsten",
  _defaultProvider: ms("ropsten")
}, Bx = {
  chainId: 63,
  name: "classicMordor",
  _defaultProvider: jl("https://www.ethercluster.com/mordor", "classicMordor")
}, Hf = {
  unspecified: { chainId: 0, name: "unspecified" },
  homestead: Px,
  mainnet: Px,
  morden: { chainId: 2, name: "morden" },
  ropsten: Ox,
  testnet: Ox,
  rinkeby: {
    chainId: 4,
    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
    name: "rinkeby",
    _defaultProvider: ms("rinkeby")
  },
  kovan: {
    chainId: 42,
    name: "kovan",
    _defaultProvider: ms("kovan")
  },
  goerli: {
    chainId: 5,
    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
    name: "goerli",
    _defaultProvider: ms("goerli")
  },
  kintsugi: { chainId: 1337702, name: "kintsugi" },
  sepolia: {
    chainId: 11155111,
    name: "sepolia",
    _defaultProvider: ms("sepolia")
  },
  // ETC (See: #351)
  classic: {
    chainId: 61,
    name: "classic",
    _defaultProvider: jl("https://www.ethercluster.com/etc", "classic")
  },
  classicMorden: { chainId: 62, name: "classicMorden" },
  classicMordor: Bx,
  classicTestnet: Bx,
  classicKotti: {
    chainId: 6,
    name: "classicKotti",
    _defaultProvider: jl("https://www.ethercluster.com/kotti", "classicKotti")
  },
  xdai: { chainId: 100, name: "xdai" },
  matic: {
    chainId: 137,
    name: "matic",
    _defaultProvider: ms("matic")
  },
  maticmum: { chainId: 80001, name: "maticmum" },
  optimism: {
    chainId: 10,
    name: "optimism",
    _defaultProvider: ms("optimism")
  },
  "optimism-kovan": { chainId: 69, name: "optimism-kovan" },
  "optimism-goerli": { chainId: 420, name: "optimism-goerli" },
  arbitrum: { chainId: 42161, name: "arbitrum" },
  "arbitrum-rinkeby": { chainId: 421611, name: "arbitrum-rinkeby" },
  "arbitrum-goerli": { chainId: 421613, name: "arbitrum-goerli" },
  bnb: { chainId: 56, name: "bnb" },
  bnbt: { chainId: 97, name: "bnbt" }
};
function h9(Y) {
  if (Y == null)
    return null;
  if (typeof Y == "number") {
    for (const te in Hf) {
      const ne = Hf[te];
      if (ne.chainId === Y)
        return {
          name: ne.name,
          chainId: ne.chainId,
          ensAddress: ne.ensAddress || null,
          _defaultProvider: ne._defaultProvider || null
        };
    }
    return {
      chainId: Y,
      name: "unknown"
    };
  }
  if (typeof Y == "string") {
    const te = Hf[Y];
    return te == null ? null : {
      name: te.name,
      chainId: te.chainId,
      ensAddress: te.ensAddress,
      _defaultProvider: te._defaultProvider || null
    };
  }
  const X = Hf[Y.name];
  if (!X)
    return typeof Y.chainId != "number" && Cx.throwArgumentError("invalid network chainId", "network", Y), Y;
  Y.chainId !== 0 && Y.chainId !== X.chainId && Cx.throwArgumentError("network chainId mismatch", "network", Y);
  let ee = Y._defaultProvider || null;
  return ee == null && X._defaultProvider && (d9(X._defaultProvider) ? ee = X._defaultProvider.renetwork(Y) : ee = X._defaultProvider), {
    name: Y.name,
    chainId: X.chainId,
    ensAddress: Y.ensAddress || X.ensAddress || null,
    _defaultProvider: ee
  };
}
const p9 = "web/5.7.1";
var g9 = function(Y, X, ee, te) {
  function ne(ie) {
    return ie instanceof ee ? ie : new ee(function(oe) {
      oe(ie);
    });
  }
  return new (ee || (ee = Promise))(function(ie, oe) {
    function se(le) {
      try {
        ue(te.next(le));
      } catch (he) {
        oe(he);
      }
    }
    function ae(le) {
      try {
        ue(te.throw(le));
      } catch (he) {
        oe(he);
      }
    }
    function ue(le) {
      le.done ? ie(le.value) : ne(le.value).then(se, ae);
    }
    ue((te = te.apply(Y, X || [])).next());
  });
};
function m9(Y, X) {
  return g9(this, void 0, void 0, function* () {
    X == null && (X = {});
    const ee = {
      method: X.method || "GET",
      headers: X.headers || {},
      body: X.body || void 0
    };
    if (X.skipFetchSetup !== !0 && (ee.mode = "cors", ee.cache = "no-cache", ee.credentials = "same-origin", ee.redirect = "follow", ee.referrer = "client"), X.fetchOptions != null) {
      const oe = X.fetchOptions;
      oe.mode && (ee.mode = oe.mode), oe.cache && (ee.cache = oe.cache), oe.credentials && (ee.credentials = oe.credentials), oe.redirect && (ee.redirect = oe.redirect), oe.referrer && (ee.referrer = oe.referrer);
    }
    const te = yield fetch(Y, ee), ne = yield te.arrayBuffer(), ie = {};
    return te.headers.forEach ? te.headers.forEach((oe, se) => {
      ie[se.toLowerCase()] = oe;
    }) : te.headers.keys().forEach((oe) => {
      ie[oe.toLowerCase()] = te.headers.get(oe);
    }), {
      headers: ie,
      statusCode: te.status,
      statusMessage: te.statusText,
      body: Ne(new Uint8Array(ne))
    };
  });
}
var y9 = function(Y, X, ee, te) {
  function ne(ie) {
    return ie instanceof ee ? ie : new ee(function(oe) {
      oe(ie);
    });
  }
  return new (ee || (ee = Promise))(function(ie, oe) {
    function se(le) {
      try {
        ue(te.next(le));
      } catch (he) {
        oe(he);
      }
    }
    function ae(le) {
      try {
        ue(te.throw(le));
      } catch (he) {
        oe(he);
      }
    }
    function ue(le) {
      le.done ? ie(le.value) : ne(le.value).then(se, ae);
    }
    ue((te = te.apply(Y, X || [])).next());
  });
};
const fi = new ce(p9);
function Nx(Y) {
  return new Promise((X) => {
    setTimeout(X, Y);
  });
}
function js(Y, X) {
  if (Y == null)
    return null;
  if (typeof Y == "string")
    return Y;
  if (Ad(Y)) {
    if (X && (X.split("/")[0] === "text" || X.split(";")[0].trim() === "application/json"))
      try {
        return cf(Y);
      } catch {
      }
    return Oe(Y);
  }
  return Y;
}
function b9(Y) {
  return Xr(Y.replace(/%([0-9a-f][0-9a-f])/gi, (X, ee) => String.fromCharCode(parseInt(ee, 16))));
}
function x9(Y, X, ee) {
  const te = typeof Y == "object" && Y.throttleLimit != null ? Y.throttleLimit : 12;
  fi.assertArgument(te > 0 && te % 1 === 0, "invalid connection throttle limit", "connection.throttleLimit", te);
  const ne = typeof Y == "object" ? Y.throttleCallback : null, ie = typeof Y == "object" && typeof Y.throttleSlotInterval == "number" ? Y.throttleSlotInterval : 100;
  fi.assertArgument(ie > 0 && ie % 1 === 0, "invalid connection throttle slot interval", "connection.throttleSlotInterval", ie);
  const oe = typeof Y == "object" ? !!Y.errorPassThrough : !1, se = {};
  let ae = null;
  const ue = {
    method: "GET"
  };
  let le = !1, he = 2 * 60 * 1e3;
  if (typeof Y == "string")
    ae = Y;
  else if (typeof Y == "object") {
    if ((Y == null || Y.url == null) && fi.throwArgumentError("missing URL", "connection.url", Y), ae = Y.url, typeof Y.timeout == "number" && Y.timeout > 0 && (he = Y.timeout), Y.headers)
      for (const Ue in Y.headers)
        se[Ue.toLowerCase()] = { key: Ue, value: String(Y.headers[Ue]) }, ["if-none-match", "if-modified-since"].indexOf(Ue.toLowerCase()) >= 0 && (le = !0);
    if (ue.allowGzip = !!Y.allowGzip, Y.user != null && Y.password != null) {
      ae.substring(0, 6) !== "https:" && Y.allowInsecureAuthentication !== !0 && fi.throwError("basic authentication requires a secure https url", ce.errors.INVALID_ARGUMENT, { argument: "url", url: ae, user: Y.user, password: "[REDACTED]" });
      const Ue = Y.user + ":" + Y.password;
      se.authorization = {
        key: "Authorization",
        value: "Basic " + lE(Xr(Ue))
      };
    }
    Y.skipFetchSetup != null && (ue.skipFetchSetup = !!Y.skipFetchSetup), Y.fetchOptions != null && (ue.fetchOptions = mr$1(Y.fetchOptions));
  }
  const me = new RegExp("^data:([^;:]*)?(;base64)?,(.*)$", "i"), ye = ae ? ae.match(me) : null;
  if (ye)
    try {
      const Ue = {
        statusCode: 200,
        statusMessage: "OK",
        headers: { "content-type": ye[1] || "text/plain" },
        body: ye[2] ? fE(ye[3]) : b9(ye[3])
      };
      let Me = Ue.body;
      return ee && (Me = ee(Ue.body, Ue)), Promise.resolve(Me);
    } catch (Ue) {
      fi.throwError("processing response error", ce.errors.SERVER_ERROR, {
        body: js(ye[1], ye[2]),
        error: Ue,
        requestBody: null,
        requestMethod: "GET",
        url: ae
      });
    }
  X && (ue.method = "POST", ue.body = X, se["content-type"] == null && (se["content-type"] = { key: "Content-Type", value: "application/octet-stream" }), se["content-length"] == null && (se["content-length"] = { key: "Content-Length", value: String(X.length) }));
  const we = {};
  Object.keys(se).forEach((Ue) => {
    const Me = se[Ue];
    we[Me.key] = Me.value;
  }), ue.headers = we;
  const Ee = function() {
    let Ue = null;
    return { promise: new Promise(function(Me, De) {
      he && (Ue = setTimeout(() => {
        Ue != null && (Ue = null, De(fi.makeError("timeout", ce.errors.TIMEOUT, {
          requestBody: js(ue.body, we["content-type"]),
          requestMethod: ue.method,
          timeout: he,
          url: ae
        })));
      }, he));
    }), cancel: function() {
      Ue != null && (clearTimeout(Ue), Ue = null);
    } };
  }(), Re = function() {
    return y9(this, void 0, void 0, function* () {
      for (let Ue = 0; Ue < te; Ue++) {
        let Me = null;
        try {
          if (Me = yield m9(ae, ue), Ue < te) {
            if (Me.statusCode === 301 || Me.statusCode === 302) {
              const Fe = Me.headers.location || "";
              if (ue.method === "GET" && Fe.match(/^https:/)) {
                ae = Me.headers.location;
                continue;
              }
            } else if (Me.statusCode === 429) {
              let Fe = !0;
              if (ne && (Fe = yield ne(Ue, ae)), Fe) {
                let Ke = 0;
                const tt = Me.headers["retry-after"];
                typeof tt == "string" && tt.match(/^[1-9][0-9]*$/) ? Ke = parseInt(tt) * 1e3 : Ke = ie * parseInt(String(Math.random() * Math.pow(2, Ue))), yield Nx(Ke);
                continue;
              }
            }
          }
        } catch (Fe) {
          Me = Fe.response, Me == null && (Ee.cancel(), fi.throwError("missing response", ce.errors.SERVER_ERROR, {
            requestBody: js(ue.body, we["content-type"]),
            requestMethod: ue.method,
            serverError: Fe,
            url: ae
          }));
        }
        let De = Me.body;
        if (le && Me.statusCode === 304 ? De = null : !oe && (Me.statusCode < 200 || Me.statusCode >= 300) && (Ee.cancel(), fi.throwError("bad response", ce.errors.SERVER_ERROR, {
          status: Me.statusCode,
          headers: Me.headers,
          body: js(De, Me.headers ? Me.headers["content-type"] : null),
          requestBody: js(ue.body, we["content-type"]),
          requestMethod: ue.method,
          url: ae
        })), ee)
          try {
            const Fe = yield ee(De, Me);
            return Ee.cancel(), Fe;
          } catch (Fe) {
            if (Fe.throttleRetry && Ue < te) {
              let Ke = !0;
              if (ne && (Ke = yield ne(Ue, ae)), Ke) {
                const tt = ie * parseInt(String(Math.random() * Math.pow(2, Ue)));
                yield Nx(tt);
                continue;
              }
            }
            Ee.cancel(), fi.throwError("processing response error", ce.errors.SERVER_ERROR, {
              body: js(De, Me.headers ? Me.headers["content-type"] : null),
              error: Fe,
              requestBody: js(ue.body, we["content-type"]),
              requestMethod: ue.method,
              url: ae
            });
          }
        return Ee.cancel(), De;
      }
      return fi.throwError("failed response", ce.errors.SERVER_ERROR, {
        requestBody: js(ue.body, we["content-type"]),
        requestMethod: ue.method,
        url: ae
      });
    });
  }();
  return Promise.race([Ee.promise, Re]);
}
function vm(Y, X, ee) {
  let te = (ie, oe) => {
    let se = null;
    if (ie != null)
      try {
        se = JSON.parse(cf(ie));
      } catch (ae) {
        fi.throwError("invalid JSON", ce.errors.SERVER_ERROR, {
          body: ie,
          error: ae
        });
      }
    return ee && (se = ee(se, oe)), se;
  }, ne = null;
  if (X != null) {
    ne = Xr(X);
    const ie = typeof Y == "string" ? { url: Y } : mr$1(Y);
    ie.headers ? Object.keys(ie.headers).filter((oe) => oe.toLowerCase() === "content-type").length !== 0 || (ie.headers = mr$1(ie.headers), ie.headers["content-type"] = "application/json") : ie.headers = { "content-type": "application/json" }, Y = ie;
  }
  return x9(Y, ne, te);
}
function ya(Y, X) {
  return X || (X = {}), X = mr$1(X), X.floor == null && (X.floor = 0), X.ceiling == null && (X.ceiling = 1e4), X.interval == null && (X.interval = 250), new Promise(function(ee, te) {
    let ne = null, ie = !1;
    const oe = () => ie ? !1 : (ie = !0, ne && clearTimeout(ne), !0);
    X.timeout && (ne = setTimeout(() => {
      oe() && te(new Error("timeout"));
    }, X.timeout));
    const se = X.retryLimit;
    let ae = 0;
    function ue() {
      return Y().then(function(le) {
        if (le !== void 0)
          oe() && ee(le);
        else if (X.oncePoll)
          X.oncePoll.once("poll", ue);
        else if (X.onceBlock)
          X.onceBlock.once("block", ue);
        else if (!ie) {
          if (ae++, ae > se) {
            oe() && te(new Error("retry limit reached"));
            return;
          }
          let he = X.interval * parseInt(String(Math.random() * Math.pow(2, ae)));
          he < X.floor && (he = X.floor), he > X.ceiling && (he = X.ceiling), setTimeout(ue, he);
        }
        return null;
      }, function(le) {
        oe() && te(le);
      });
    }
    ue();
  });
}
var Hl = "qpzry9x8gf2tvdw0s3jn54khce6mua7l", Gp = {};
for (var zf = 0; zf < Hl.length; zf++) {
  var oh = Hl.charAt(zf);
  if (Gp[oh] !== void 0)
    throw new TypeError(oh + " is ambiguous");
  Gp[oh] = zf;
}
function Pa(Y) {
  var X = Y >> 25;
  return (Y & 33554431) << 5 ^ -(X >> 0 & 1) & 996825010 ^ -(X >> 1 & 1) & 642813549 ^ -(X >> 2 & 1) & 513874426 ^ -(X >> 3 & 1) & 1027748829 ^ -(X >> 4 & 1) & 705979059;
}
function l6(Y) {
  for (var X = 1, ee = 0; ee < Y.length; ++ee) {
    var te = Y.charCodeAt(ee);
    if (te < 33 || te > 126)
      return "Invalid prefix (" + Y + ")";
    X = Pa(X) ^ te >> 5;
  }
  for (X = Pa(X), ee = 0; ee < Y.length; ++ee) {
    var ne = Y.charCodeAt(ee);
    X = Pa(X) ^ ne & 31;
  }
  return X;
}
function w9(Y, X, ee) {
  if (ee = ee || 90, Y.length + 7 + X.length > ee)
    throw new TypeError("Exceeds length limit");
  Y = Y.toLowerCase();
  var te = l6(Y);
  if (typeof te == "string")
    throw new Error(te);
  for (var ne = Y + "1", ie = 0; ie < X.length; ++ie) {
    var oe = X[ie];
    if (oe >> 5)
      throw new Error("Non 5-bit word");
    te = Pa(te) ^ oe, ne += Hl.charAt(oe);
  }
  for (ie = 0; ie < 6; ++ie)
    te = Pa(te);
  for (te ^= 1, ie = 0; ie < 6; ++ie) {
    var se = te >> (5 - ie) * 5 & 31;
    ne += Hl.charAt(se);
  }
  return ne;
}
function d6(Y, X) {
  if (X = X || 90, Y.length < 8)
    return Y + " too short";
  if (Y.length > X)
    return "Exceeds length limit";
  var ee = Y.toLowerCase(), te = Y.toUpperCase();
  if (Y !== ee && Y !== te)
    return "Mixed-case string " + Y;
  Y = ee;
  var ne = Y.lastIndexOf("1");
  if (ne === -1)
    return "No separator character for " + Y;
  if (ne === 0)
    return "Missing prefix for " + Y;
  var ie = Y.slice(0, ne), oe = Y.slice(ne + 1);
  if (oe.length < 6)
    return "Data too short";
  var se = l6(ie);
  if (typeof se == "string")
    return se;
  for (var ae = [], ue = 0; ue < oe.length; ++ue) {
    var le = oe.charAt(ue), he = Gp[le];
    if (he === void 0)
      return "Unknown character " + le;
    se = Pa(se) ^ he, !(ue + 6 >= oe.length) && ae.push(he);
  }
  return se !== 1 ? "Invalid checksum for " + Y : { prefix: ie, words: ae };
}
function v9() {
  var Y = d6.apply(null, arguments);
  if (typeof Y == "object")
    return Y;
}
function E9(Y) {
  var X = d6.apply(null, arguments);
  if (typeof X == "object")
    return X;
  throw new Error(X);
}
function Pd(Y, X, ee, te) {
  for (var ne = 0, ie = 0, oe = (1 << ee) - 1, se = [], ae = 0; ae < Y.length; ++ae)
    for (ne = ne << X | Y[ae], ie += X; ie >= ee; )
      ie -= ee, se.push(ne >> ie & oe);
  if (te)
    ie > 0 && se.push(ne << ee - ie & oe);
  else {
    if (ie >= X)
      return "Excess padding";
    if (ne << ee - ie & oe)
      return "Non-zero padding";
  }
  return se;
}
function _9(Y) {
  var X = Pd(Y, 8, 5, !0);
  if (Array.isArray(X))
    return X;
}
function A9(Y) {
  var X = Pd(Y, 8, 5, !0);
  if (Array.isArray(X))
    return X;
  throw new Error(X);
}
function S9(Y) {
  var X = Pd(Y, 5, 8, !1);
  if (Array.isArray(X))
    return X;
}
function T9(Y) {
  var X = Pd(Y, 5, 8, !1);
  if (Array.isArray(X))
    return X;
  throw new Error(X);
}
var I9 = {
  decodeUnsafe: v9,
  decode: E9,
  encode: w9,
  toWordsUnsafe: _9,
  toWords: A9,
  fromWordsUnsafe: S9,
  fromWords: T9
};
const kx = /* @__PURE__ */ uc(I9), lf = "providers/5.7.2", jc = new ce(lf);
class We {
  constructor() {
    this.formats = this.getDefaultFormats();
  }
  getDefaultFormats() {
    const X = {}, ee = this.address.bind(this), te = this.bigNumber.bind(this), ne = this.blockTag.bind(this), ie = this.data.bind(this), oe = this.hash.bind(this), se = this.hex.bind(this), ae = this.number.bind(this), ue = this.type.bind(this), le = (he) => this.data(he, !0);
    return X.transaction = {
      hash: oe,
      type: ue,
      accessList: We.allowNull(this.accessList.bind(this), null),
      blockHash: We.allowNull(oe, null),
      blockNumber: We.allowNull(ae, null),
      transactionIndex: We.allowNull(ae, null),
      confirmations: We.allowNull(ae, null),
      from: ee,
      // either (gasPrice) or (maxPriorityFeePerGas + maxFeePerGas)
      // must be set
      gasPrice: We.allowNull(te),
      maxPriorityFeePerGas: We.allowNull(te),
      maxFeePerGas: We.allowNull(te),
      gasLimit: te,
      to: We.allowNull(ee, null),
      value: te,
      nonce: ae,
      data: ie,
      r: We.allowNull(this.uint256),
      s: We.allowNull(this.uint256),
      v: We.allowNull(ae),
      creates: We.allowNull(ee, null),
      raw: We.allowNull(ie)
    }, X.transactionRequest = {
      from: We.allowNull(ee),
      nonce: We.allowNull(ae),
      gasLimit: We.allowNull(te),
      gasPrice: We.allowNull(te),
      maxPriorityFeePerGas: We.allowNull(te),
      maxFeePerGas: We.allowNull(te),
      to: We.allowNull(ee),
      value: We.allowNull(te),
      data: We.allowNull(le),
      type: We.allowNull(ae),
      accessList: We.allowNull(this.accessList.bind(this), null)
    }, X.receiptLog = {
      transactionIndex: ae,
      blockNumber: ae,
      transactionHash: oe,
      address: ee,
      topics: We.arrayOf(oe),
      data: ie,
      logIndex: ae,
      blockHash: oe
    }, X.receipt = {
      to: We.allowNull(this.address, null),
      from: We.allowNull(this.address, null),
      contractAddress: We.allowNull(ee, null),
      transactionIndex: ae,
      // should be allowNull(hash), but broken-EIP-658 support is handled in receipt
      root: We.allowNull(se),
      gasUsed: te,
      logsBloom: We.allowNull(ie),
      blockHash: oe,
      transactionHash: oe,
      logs: We.arrayOf(this.receiptLog.bind(this)),
      blockNumber: ae,
      confirmations: We.allowNull(ae, null),
      cumulativeGasUsed: te,
      effectiveGasPrice: We.allowNull(te),
      status: We.allowNull(ae),
      type: ue
    }, X.block = {
      hash: We.allowNull(oe),
      parentHash: oe,
      number: ae,
      timestamp: ae,
      nonce: We.allowNull(se),
      difficulty: this.difficulty.bind(this),
      gasLimit: te,
      gasUsed: te,
      miner: We.allowNull(ee),
      extraData: ie,
      transactions: We.allowNull(We.arrayOf(oe)),
      baseFeePerGas: We.allowNull(te)
    }, X.blockWithTransactions = mr$1(X.block), X.blockWithTransactions.transactions = We.allowNull(We.arrayOf(this.transactionResponse.bind(this))), X.filter = {
      fromBlock: We.allowNull(ne, void 0),
      toBlock: We.allowNull(ne, void 0),
      blockHash: We.allowNull(oe, void 0),
      address: We.allowNull(ee, void 0),
      topics: We.allowNull(this.topics.bind(this), void 0)
    }, X.filterLog = {
      blockNumber: We.allowNull(ae),
      blockHash: We.allowNull(oe),
      transactionIndex: ae,
      removed: We.allowNull(this.boolean.bind(this)),
      address: ee,
      data: We.allowFalsish(ie, "0x"),
      topics: We.arrayOf(oe),
      transactionHash: oe,
      logIndex: ae
    }, X;
  }
  accessList(X) {
    return bc(X || []);
  }
  // Requires a BigNumberish that is within the IEEE754 safe integer range; returns a number
  // Strict! Used on input.
  number(X) {
    return X === "0x" ? 0 : Be.from(X).toNumber();
  }
  type(X) {
    return X === "0x" || X == null ? 0 : Be.from(X).toNumber();
  }
  // Strict! Used on input.
  bigNumber(X) {
    return Be.from(X);
  }
  // Requires a boolean, "true" or  "false"; returns a boolean
  boolean(X) {
    if (typeof X == "boolean")
      return X;
    if (typeof X == "string") {
      if (X = X.toLowerCase(), X === "true")
        return !0;
      if (X === "false")
        return !1;
    }
    throw new Error("invalid boolean - " + X);
  }
  hex(X, ee) {
    return typeof X == "string" && (!ee && X.substring(0, 2) !== "0x" && (X = "0x" + X), Bt(X)) ? X.toLowerCase() : jc.throwArgumentError("invalid hash", "value", X);
  }
  data(X, ee) {
    const te = this.hex(X, ee);
    if (te.length % 2 !== 0)
      throw new Error("invalid data; odd-length - " + X);
    return te;
  }
  // Requires an address
  // Strict! Used on input.
  address(X) {
    return pr(X);
  }
  callAddress(X) {
    if (!Bt(X, 32))
      return null;
    const ee = pr(Dr(X, 12));
    return ee === TT ? null : ee;
  }
  contractAddress(X) {
    return tE(X);
  }
  // Strict! Used on input.
  blockTag(X) {
    if (X == null)
      return "latest";
    if (X === "earliest")
      return "0x0";
    switch (X) {
      case "earliest":
        return "0x0";
      case "latest":
      case "pending":
      case "safe":
      case "finalized":
        return X;
    }
    if (typeof X == "number" || Bt(X))
      return om(X);
    throw new Error("invalid blockTag");
  }
  // Requires a hash, optionally requires 0x prefix; returns prefixed lowercase hash.
  hash(X, ee) {
    const te = this.hex(X, ee);
    return Oo(te) !== 32 ? jc.throwArgumentError("invalid hash", "value", X) : te;
  }
  // Returns the difficulty as a number, or if too large (i.e. PoA network) null
  difficulty(X) {
    if (X == null)
      return null;
    const ee = Be.from(X);
    try {
      return ee.toNumber();
    } catch {
    }
    return null;
  }
  uint256(X) {
    if (!Bt(X))
      throw new Error("invalid uint256");
    return hr$1(X, 32);
  }
  _block(X, ee) {
    X.author != null && X.miner == null && (X.miner = X.author);
    const te = X._difficulty != null ? X._difficulty : X.difficulty, ne = We.check(ee, X);
    return ne._difficulty = te == null ? null : Be.from(te), ne;
  }
  block(X) {
    return this._block(X, this.formats.block);
  }
  blockWithTransactions(X) {
    return this._block(X, this.formats.blockWithTransactions);
  }
  // Strict! Used on input.
  transactionRequest(X) {
    return We.check(this.formats.transactionRequest, X);
  }
  transactionResponse(X) {
    X.gas != null && X.gasLimit == null && (X.gasLimit = X.gas), X.to && Be.from(X.to).isZero() && (X.to = "0x0000000000000000000000000000000000000000"), X.input != null && X.data == null && (X.data = X.input), X.to == null && X.creates == null && (X.creates = this.contractAddress(X)), (X.type === 1 || X.type === 2) && X.accessList == null && (X.accessList = []);
    const ee = We.check(this.formats.transaction, X);
    if (X.chainId != null) {
      let te = X.chainId;
      Bt(te) && (te = Be.from(te).toNumber()), ee.chainId = te;
    } else {
      let te = X.networkId;
      te == null && ee.v == null && (te = X.chainId), Bt(te) && (te = Be.from(te).toNumber()), typeof te != "number" && ee.v != null && (te = (ee.v - 35) / 2, te < 0 && (te = 0), te = parseInt(te)), typeof te != "number" && (te = 0), ee.chainId = te;
    }
    return ee.blockHash && ee.blockHash.replace(/0/g, "") === "x" && (ee.blockHash = null), ee;
  }
  transaction(X) {
    return AC(X);
  }
  receiptLog(X) {
    return We.check(this.formats.receiptLog, X);
  }
  receipt(X) {
    const ee = We.check(this.formats.receipt, X);
    if (ee.root != null)
      if (ee.root.length <= 4) {
        const te = Be.from(ee.root).toNumber();
        te === 0 || te === 1 ? (ee.status != null && ee.status !== te && jc.throwArgumentError("alt-root-status/status mismatch", "value", { root: ee.root, status: ee.status }), ee.status = te, delete ee.root) : jc.throwArgumentError("invalid alt-root-status", "value.root", ee.root);
      } else
        ee.root.length !== 66 && jc.throwArgumentError("invalid root hash", "value.root", ee.root);
    return ee.status != null && (ee.byzantium = !0), ee;
  }
  topics(X) {
    return Array.isArray(X) ? X.map((ee) => this.topics(ee)) : X != null ? this.hash(X, !0) : null;
  }
  filter(X) {
    return We.check(this.formats.filter, X);
  }
  filterLog(X) {
    return We.check(this.formats.filterLog, X);
  }
  static check(X, ee) {
    const te = {};
    for (const ne in X)
      try {
        const ie = X[ne](ee[ne]);
        ie !== void 0 && (te[ne] = ie);
      } catch (ie) {
        throw ie.checkKey = ne, ie.checkValue = ee[ne], ie;
      }
    return te;
  }
  // if value is null-ish, nullValue is returned
  static allowNull(X, ee) {
    return function(te) {
      return te == null ? ee : X(te);
    };
  }
  // If value is false-ish, replaceValue is returned
  static allowFalsish(X, ee) {
    return function(te) {
      return te ? X(te) : ee;
    };
  }
  // Requires an Array satisfying check
  static arrayOf(X) {
    return function(ee) {
      if (!Array.isArray(ee))
        throw new Error("not an array");
      const te = [];
      return ee.forEach(function(ne) {
        te.push(X(ne));
      }), te;
    };
  }
}
function R9(Y) {
  return Y && typeof Y.isCommunityResource == "function";
}
function Mx(Y) {
  return R9(Y) && Y.isCommunityResource();
}
var mt = function(Y, X, ee, te) {
  function ne(ie) {
    return ie instanceof ee ? ie : new ee(function(oe) {
      oe(ie);
    });
  }
  return new (ee || (ee = Promise))(function(ie, oe) {
    function se(le) {
      try {
        ue(te.next(le));
      } catch (he) {
        oe(he);
      }
    }
    function ae(le) {
      try {
        ue(te.throw(le));
      } catch (he) {
        oe(he);
      }
    }
    function ue(le) {
      le.done ? ie(le.value) : ne(le.value).then(se, ae);
    }
    ue((te = te.apply(Y, X || [])).next());
  });
};
const Nt = new ce(lf), C9 = 10;
function Lx(Y) {
  return Y == null ? "null" : (Oo(Y) !== 32 && Nt.throwArgumentError("invalid topic", "topic", Y), Y.toLowerCase());
}
function Fx(Y) {
  for (Y = Y.slice(); Y.length > 0 && Y[Y.length - 1] == null; )
    Y.pop();
  return Y.map((X) => {
    if (Array.isArray(X)) {
      const ee = {};
      X.forEach((ne) => {
        ee[Lx(ne)] = !0;
      });
      const te = Object.keys(ee);
      return te.sort(), te.join("|");
    } else
      return Lx(X);
  }).join("&");
}
function P9(Y) {
  return Y === "" ? [] : Y.split(/&/g).map((X) => {
    if (X === "")
      return [];
    const ee = X.split("|").map((te) => te === "null" ? null : te);
    return ee.length === 1 ? ee[0] : ee;
  });
}
function na(Y) {
  if (typeof Y == "string") {
    if (Y = Y.toLowerCase(), Oo(Y) === 32)
      return "tx:" + Y;
    if (Y.indexOf(":") === -1)
      return Y;
  } else {
    if (Array.isArray(Y))
      return "filter:*:" + Fx(Y);
    if (CI.isForkEvent(Y))
      throw Nt.warn("not implemented"), new Error("not implemented");
    if (Y && typeof Y == "object")
      return "filter:" + (Y.address || "*") + ":" + Fx(Y.topics || []);
  }
  throw new Error("invalid event - " + Y);
}
function Hc() {
  return (/* @__PURE__ */ new Date()).getTime();
}
function $x(Y) {
  return new Promise((X) => {
    setTimeout(X, Y);
  });
}
const O9 = ["block", "network", "pending", "poll"];
let B9 = class {
  constructor(Y, X, ee) {
    ve(this, "tag", Y), ve(this, "listener", X), ve(this, "once", ee), this._lastBlockNumber = -2, this._inflight = !1;
  }
  get event() {
    switch (this.type) {
      case "tx":
        return this.hash;
      case "filter":
        return this.filter;
    }
    return this.tag;
  }
  get type() {
    return this.tag.split(":")[0];
  }
  get hash() {
    const Y = this.tag.split(":");
    return Y[0] !== "tx" ? null : Y[1];
  }
  get filter() {
    const Y = this.tag.split(":");
    if (Y[0] !== "filter")
      return null;
    const X = Y[1], ee = P9(Y[2]), te = {};
    return ee.length > 0 && (te.topics = ee), X && X !== "*" && (te.address = X), te;
  }
  pollable() {
    return this.tag.indexOf(":") >= 0 || O9.indexOf(this.tag) >= 0;
  }
};
const N9 = {
  0: { symbol: "btc", p2pkh: 0, p2sh: 5, prefix: "bc" },
  2: { symbol: "ltc", p2pkh: 48, p2sh: 50, prefix: "ltc" },
  3: { symbol: "doge", p2pkh: 30, p2sh: 22 },
  60: { symbol: "eth", ilk: "eth" },
  61: { symbol: "etc", ilk: "eth" },
  700: { symbol: "xdai", ilk: "eth" }
};
function ah(Y) {
  return hr$1(Be.from(Y).toHexString(), 32);
}
function Dx(Y) {
  return Au.encode(Br([Y, Dr(Mo(Mo(Y)), 0, 4)]));
}
const h6 = new RegExp("^(ipfs)://(.*)$", "i"), Ux = [
  new RegExp("^(https)://(.*)$", "i"),
  new RegExp("^(data):(.*)$", "i"),
  h6,
  new RegExp("^eip155:[0-9]+/(erc[0-9]+):(.*)$", "i")
];
function Al(Y, X) {
  try {
    return cf(Iu(Y, X));
  } catch {
  }
  return null;
}
function Iu(Y, X) {
  if (Y === "0x")
    return null;
  const ee = Be.from(Dr(Y, X, X + 32)).toNumber(), te = Be.from(Dr(Y, ee, ee + 32)).toNumber();
  return Dr(Y, ee + 32, ee + 32 + te);
}
function ch$1(Y) {
  return Y.match(/^ipfs:\/\/ipfs\//i) ? Y = Y.substring(12) : Y.match(/^ipfs:\/\//i) ? Y = Y.substring(7) : Nt.throwArgumentError("unsupported IPFS format", "link", Y), `https://gateway.ipfs.io/ipfs/${Y}`;
}
function jx(Y) {
  const X = Ne(Y);
  if (X.length > 32)
    throw new Error("internal; should not happen");
  const ee = new Uint8Array(32);
  return ee.set(X, 32 - X.length), ee;
}
function k9(Y) {
  if (Y.length % 32 === 0)
    return Y;
  const X = new Uint8Array(Math.ceil(Y.length / 32) * 32);
  return X.set(Y), X;
}
function p6(Y) {
  const X = [];
  let ee = 0;
  for (let te = 0; te < Y.length; te++)
    X.push(null), ee += 32;
  for (let te = 0; te < Y.length; te++) {
    const ne = Ne(Y[te]);
    X[te] = jx(ee), X.push(jx(ne.length)), X.push(k9(ne)), ee += 32 + Math.ceil(ne.length / 32) * 32;
  }
  return Tn(X);
}
class Hx {
  // The resolvedAddress is only for creating a ReverseLookup resolver
  constructor(X, ee, te, ne) {
    ve(this, "provider", X), ve(this, "name", te), ve(this, "address", X.formatter.address(ee)), ve(this, "_resolvedAddress", ne);
  }
  supportsWildcard() {
    return this._supportsEip2544 || (this._supportsEip2544 = this.provider.call({
      to: this.address,
      data: "0x01ffc9a79061b92300000000000000000000000000000000000000000000000000000000"
    }).then((X) => Be.from(X).eq(1)).catch((X) => {
      if (X.code === ce.errors.CALL_EXCEPTION)
        return !1;
      throw this._supportsEip2544 = null, X;
    })), this._supportsEip2544;
  }
  _fetch(X, ee) {
    return mt(this, void 0, void 0, function* () {
      const te = {
        to: this.address,
        ccipReadEnabled: !0,
        data: Tn([X, xl(this.name), ee || "0x"])
      };
      let ne = !1;
      (yield this.supportsWildcard()) && (ne = !0, te.data = Tn(["0x9061b923", p6([dI(this.name), te.data])]));
      try {
        let ie = yield this.provider.call(te);
        return Ne(ie).length % 32 === 4 && Nt.throwError("resolver threw error", ce.errors.CALL_EXCEPTION, {
          transaction: te,
          data: ie
        }), ne && (ie = Iu(ie, 0)), ie;
      } catch (ie) {
        if (ie.code === ce.errors.CALL_EXCEPTION)
          return null;
        throw ie;
      }
    });
  }
  _fetchBytes(X, ee) {
    return mt(this, void 0, void 0, function* () {
      const te = yield this._fetch(X, ee);
      return te != null ? Iu(te, 0) : null;
    });
  }
  _getAddress(X, ee) {
    const te = N9[String(X)];
    if (te == null && Nt.throwError(`unsupported coin type: ${X}`, ce.errors.UNSUPPORTED_OPERATION, {
      operation: `getAddress(${X})`
    }), te.ilk === "eth")
      return this.provider.formatter.address(ee);
    const ne = Ne(ee);
    if (te.p2pkh != null) {
      const ie = ee.match(/^0x76a9([0-9a-f][0-9a-f])([0-9a-f]*)88ac$/);
      if (ie) {
        const oe = parseInt(ie[1], 16);
        if (ie[2].length === oe * 2 && oe >= 1 && oe <= 75)
          return Dx(Br([[te.p2pkh], "0x" + ie[2]]));
      }
    }
    if (te.p2sh != null) {
      const ie = ee.match(/^0xa9([0-9a-f][0-9a-f])([0-9a-f]*)87$/);
      if (ie) {
        const oe = parseInt(ie[1], 16);
        if (ie[2].length === oe * 2 && oe >= 1 && oe <= 75)
          return Dx(Br([[te.p2sh], "0x" + ie[2]]));
      }
    }
    if (te.prefix != null) {
      const ie = ne[1];
      let oe = ne[0];
      if (oe === 0 ? ie !== 20 && ie !== 32 && (oe = -1) : oe = -1, oe >= 0 && ne.length === 2 + ie && ie >= 1 && ie <= 75) {
        const se = kx.toWords(ne.slice(2));
        return se.unshift(oe), kx.encode(te.prefix, se);
      }
    }
    return null;
  }
  getAddress(X) {
    return mt(this, void 0, void 0, function* () {
      if (X == null && (X = 60), X === 60)
        try {
          const ne = yield this._fetch("0x3b3b57de");
          return ne === "0x" || ne === PT ? null : this.provider.formatter.callAddress(ne);
        } catch (ne) {
          if (ne.code === ce.errors.CALL_EXCEPTION)
            return null;
          throw ne;
        }
      const ee = yield this._fetchBytes("0xf1cb7e06", ah(X));
      if (ee == null || ee === "0x")
        return null;
      const te = this._getAddress(X, ee);
      return te == null && Nt.throwError("invalid or unsupported coin data", ce.errors.UNSUPPORTED_OPERATION, {
        operation: `getAddress(${X})`,
        coinType: X,
        data: ee
      }), te;
    });
  }
  getAvatar() {
    return mt(this, void 0, void 0, function* () {
      const X = [{ type: "name", content: this.name }];
      try {
        const ee = yield this.getText("avatar");
        if (ee == null)
          return null;
        for (let te = 0; te < Ux.length; te++) {
          const ne = ee.match(Ux[te]);
          if (ne == null)
            continue;
          const ie = ne[1].toLowerCase();
          switch (ie) {
            case "https":
              return X.push({ type: "url", content: ee }), { linkage: X, url: ee };
            case "data":
              return X.push({ type: "data", content: ee }), { linkage: X, url: ee };
            case "ipfs":
              return X.push({ type: "ipfs", content: ee }), { linkage: X, url: ch$1(ee) };
            case "erc721":
            case "erc1155": {
              const oe = ie === "erc721" ? "0xc87b56dd" : "0x0e89341c";
              X.push({ type: ie, content: ee });
              const se = this._resolvedAddress || (yield this.getAddress()), ae = (ne[2] || "").split("/");
              if (ae.length !== 2)
                return null;
              const ue = yield this.provider.formatter.address(ae[0]), le = hr$1(Be.from(ae[1]).toHexString(), 32);
              if (ie === "erc721") {
                const Ee = this.provider.formatter.callAddress(yield this.provider.call({
                  to: ue,
                  data: Tn(["0x6352211e", le])
                }));
                if (se !== Ee)
                  return null;
                X.push({ type: "owner", content: Ee });
              } else if (ie === "erc1155") {
                const Ee = Be.from(yield this.provider.call({
                  to: ue,
                  data: Tn(["0x00fdd58e", hr$1(se, 32), le])
                }));
                if (Ee.isZero())
                  return null;
                X.push({ type: "balance", content: Ee.toString() });
              }
              const he = {
                to: this.provider.formatter.address(ae[0]),
                data: Tn([oe, le])
              };
              let me = Al(yield this.provider.call(he), 0);
              if (me == null)
                return null;
              X.push({ type: "metadata-url-base", content: me }), ie === "erc1155" && (me = me.replace("{id}", le.substring(2)), X.push({ type: "metadata-url-expanded", content: me })), me.match(/^ipfs:/i) && (me = ch$1(me)), X.push({ type: "metadata-url", content: me });
              const ye = yield vm(me);
              if (!ye)
                return null;
              X.push({ type: "metadata", content: JSON.stringify(ye) });
              let we = ye.image;
              if (typeof we != "string")
                return null;
              if (!we.match(/^(https:\/\/|data:)/i)) {
                if (we.match(h6) == null)
                  return null;
                X.push({ type: "url-ipfs", content: we }), we = ch$1(we);
              }
              return X.push({ type: "url", content: we }), { linkage: X, url: we };
            }
          }
        }
      } catch {
      }
      return null;
    });
  }
  getContentHash() {
    return mt(this, void 0, void 0, function* () {
      const X = yield this._fetchBytes("0xbc1c58d1");
      if (X == null || X === "0x")
        return null;
      const ee = X.match(/^0xe3010170(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
      if (ee) {
        const oe = parseInt(ee[3], 16);
        if (ee[4].length === oe * 2)
          return "ipfs://" + Au.encode("0x" + ee[1]);
      }
      const te = X.match(/^0xe5010172(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
      if (te) {
        const oe = parseInt(te[3], 16);
        if (te[4].length === oe * 2)
          return "ipns://" + Au.encode("0x" + te[1]);
      }
      const ne = X.match(/^0xe40101fa011b20([0-9a-f]*)$/);
      if (ne && ne[1].length === 32 * 2)
        return "bzz://" + ne[1];
      const ie = X.match(/^0x90b2c605([0-9a-f]*)$/);
      if (ie && ie[1].length === 34 * 2) {
        const oe = { "=": "", "+": "-", "/": "_" };
        return "sia://" + lE("0x" + ie[1]).replace(/[=+\/]/g, (se) => oe[se]);
      }
      return Nt.throwError("invalid or unsupported content hash data", ce.errors.UNSUPPORTED_OPERATION, {
        operation: "getContentHash()",
        data: X
      });
    });
  }
  getText(X) {
    return mt(this, void 0, void 0, function* () {
      let ee = Xr(X);
      ee = Br([ah(64), ah(ee.length), ee]), ee.length % 32 !== 0 && (ee = Br([ee, hr$1("0x", 32 - X.length % 32)]));
      const te = yield this._fetchBytes("0x59d1d43c", Oe(ee));
      return te == null || te === "0x" ? null : cf(te);
    });
  }
}
let uh = null, M9 = 1;
class g6 extends dc {
  /**
   *  ready
   *
   *  A Promise<Network> that resolves only once the provider is ready.
   *
   *  Sub-classes that call the super with a network without a chainId
   *  MUST set this. Standard named networks have a known chainId.
   *
   */
  constructor(X) {
    if (super(), this._events = [], this._emitted = { block: -2 }, this.disableCcipRead = !1, this.formatter = new.target.getFormatter(), ve(this, "anyNetwork", X === "any"), this.anyNetwork && (X = this.detectNetwork()), X instanceof Promise)
      this._networkPromise = X, X.catch((ee) => {
      }), this._ready().catch((ee) => {
      });
    else {
      const ee = ji(new.target, "getNetwork")(X);
      ee ? (ve(this, "_network", ee), this.emit("network", ee, null)) : Nt.throwArgumentError("invalid network", "network", X);
    }
    this._maxInternalBlockNumber = -1024, this._lastBlockNumber = -2, this._maxFilterBlockRange = 10, this._pollingInterval = 4e3, this._fastQueryDate = 0;
  }
  _ready() {
    return mt(this, void 0, void 0, function* () {
      if (this._network == null) {
        let X = null;
        if (this._networkPromise)
          try {
            X = yield this._networkPromise;
          } catch {
          }
        X == null && (X = yield this.detectNetwork()), X || Nt.throwError("no network detected", ce.errors.UNKNOWN_ERROR, {}), this._network == null && (this.anyNetwork ? this._network = X : ve(this, "_network", X), this.emit("network", X, null));
      }
      return this._network;
    });
  }
  // This will always return the most recently established network.
  // For "any", this can change (a "network" event is emitted before
  // any change is reflected); otherwise this cannot change
  get ready() {
    return ya(() => this._ready().then((X) => X, (X) => {
      if (!(X.code === ce.errors.NETWORK_ERROR && X.event === "noNetwork"))
        throw X;
    }));
  }
  // @TODO: Remove this and just create a singleton formatter
  static getFormatter() {
    return uh == null && (uh = new We()), uh;
  }
  // @TODO: Remove this and just use getNetwork
  static getNetwork(X) {
    return h9(X ?? "homestead");
  }
  ccipReadFetch(X, ee, te) {
    return mt(this, void 0, void 0, function* () {
      if (this.disableCcipRead || te.length === 0)
        return null;
      const ne = X.to.toLowerCase(), ie = ee.toLowerCase(), oe = [];
      for (let se = 0; se < te.length; se++) {
        const ae = te[se], ue = ae.replace("{sender}", ne).replace("{data}", ie), le = ae.indexOf("{data}") >= 0 ? null : JSON.stringify({ data: ie, sender: ne }), he = yield vm({ url: ue, errorPassThrough: !0 }, le, (ye, we) => (ye.status = we.statusCode, ye));
        if (he.data)
          return he.data;
        const me = he.message || "unknown error";
        if (he.status >= 400 && he.status < 500)
          return Nt.throwError(`response not found during CCIP fetch: ${me}`, ce.errors.SERVER_ERROR, { url: ae, errorMessage: me });
        oe.push(me);
      }
      return Nt.throwError(`error encountered during CCIP fetch: ${oe.map((se) => JSON.stringify(se)).join(", ")}`, ce.errors.SERVER_ERROR, {
        urls: te,
        errorMessages: oe
      });
    });
  }
  // Fetches the blockNumber, but will reuse any result that is less
  // than maxAge old or has been requested since the last request
  _getInternalBlockNumber(X) {
    return mt(this, void 0, void 0, function* () {
      if (yield this._ready(), X > 0)
        for (; this._internalBlockNumber; ) {
          const ne = this._internalBlockNumber;
          try {
            const ie = yield ne;
            if (Hc() - ie.respTime <= X)
              return ie.blockNumber;
            break;
          } catch {
            if (this._internalBlockNumber === ne)
              break;
          }
        }
      const ee = Hc(), te = Cr({
        blockNumber: this.perform("getBlockNumber", {}),
        networkError: this.getNetwork().then((ne) => null, (ne) => ne)
      }).then(({ blockNumber: ne, networkError: ie }) => {
        if (ie)
          throw this._internalBlockNumber === te && (this._internalBlockNumber = null), ie;
        const oe = Hc();
        return ne = Be.from(ne).toNumber(), ne < this._maxInternalBlockNumber && (ne = this._maxInternalBlockNumber), this._maxInternalBlockNumber = ne, this._setFastBlockNumber(ne), { blockNumber: ne, reqTime: ee, respTime: oe };
      });
      return this._internalBlockNumber = te, te.catch((ne) => {
        this._internalBlockNumber === te && (this._internalBlockNumber = null);
      }), (yield te).blockNumber;
    });
  }
  poll() {
    return mt(this, void 0, void 0, function* () {
      const X = M9++, ee = [];
      let te = null;
      try {
        te = yield this._getInternalBlockNumber(100 + this.pollingInterval / 2);
      } catch (ne) {
        this.emit("error", ne);
        return;
      }
      if (this._setFastBlockNumber(te), this.emit("poll", X, te), te === this._lastBlockNumber) {
        this.emit("didPoll", X);
        return;
      }
      if (this._emitted.block === -2 && (this._emitted.block = te - 1), Math.abs(this._emitted.block - te) > 1e3)
        Nt.warn(`network block skew detected; skipping block events (emitted=${this._emitted.block} blockNumber${te})`), this.emit("error", Nt.makeError("network block skew detected", ce.errors.NETWORK_ERROR, {
          blockNumber: te,
          event: "blockSkew",
          previousBlockNumber: this._emitted.block
        })), this.emit("block", te);
      else
        for (let ne = this._emitted.block + 1; ne <= te; ne++)
          this.emit("block", ne);
      this._emitted.block !== te && (this._emitted.block = te, Object.keys(this._emitted).forEach((ne) => {
        if (ne === "block")
          return;
        const ie = this._emitted[ne];
        ie !== "pending" && te - ie > 12 && delete this._emitted[ne];
      })), this._lastBlockNumber === -2 && (this._lastBlockNumber = te - 1), this._events.forEach((ne) => {
        switch (ne.type) {
          case "tx": {
            const ie = ne.hash;
            let oe = this.getTransactionReceipt(ie).then((se) => (!se || se.blockNumber == null || (this._emitted["t:" + ie] = se.blockNumber, this.emit(ie, se)), null)).catch((se) => {
              this.emit("error", se);
            });
            ee.push(oe);
            break;
          }
          case "filter": {
            if (!ne._inflight) {
              ne._inflight = !0, ne._lastBlockNumber === -2 && (ne._lastBlockNumber = te - 1);
              const ie = ne.filter;
              ie.fromBlock = ne._lastBlockNumber + 1, ie.toBlock = te;
              const oe = ie.toBlock - this._maxFilterBlockRange;
              oe > ie.fromBlock && (ie.fromBlock = oe), ie.fromBlock < 0 && (ie.fromBlock = 0);
              const se = this.getLogs(ie).then((ae) => {
                ne._inflight = !1, ae.length !== 0 && ae.forEach((ue) => {
                  ue.blockNumber > ne._lastBlockNumber && (ne._lastBlockNumber = ue.blockNumber), this._emitted["b:" + ue.blockHash] = ue.blockNumber, this._emitted["t:" + ue.transactionHash] = ue.blockNumber, this.emit(ie, ue);
                });
              }).catch((ae) => {
                this.emit("error", ae), ne._inflight = !1;
              });
              ee.push(se);
            }
            break;
          }
        }
      }), this._lastBlockNumber = te, Promise.all(ee).then(() => {
        this.emit("didPoll", X);
      }).catch((ne) => {
        this.emit("error", ne);
      });
    });
  }
  // Deprecated; do not use this
  resetEventsBlock(X) {
    this._lastBlockNumber = X - 1, this.polling && this.poll();
  }
  get network() {
    return this._network;
  }
  // This method should query the network if the underlying network
  // can change, such as when connected to a JSON-RPC backend
  detectNetwork() {
    return mt(this, void 0, void 0, function* () {
      return Nt.throwError("provider does not support network detection", ce.errors.UNSUPPORTED_OPERATION, {
        operation: "provider.detectNetwork"
      });
    });
  }
  getNetwork() {
    return mt(this, void 0, void 0, function* () {
      const X = yield this._ready(), ee = yield this.detectNetwork();
      if (X.chainId !== ee.chainId) {
        if (this.anyNetwork)
          return this._network = ee, this._lastBlockNumber = -2, this._fastBlockNumber = null, this._fastBlockNumberPromise = null, this._fastQueryDate = 0, this._emitted.block = -2, this._maxInternalBlockNumber = -1024, this._internalBlockNumber = null, this.emit("network", ee, X), yield $x(0), this._network;
        const te = Nt.makeError("underlying network changed", ce.errors.NETWORK_ERROR, {
          event: "changed",
          network: X,
          detectedNetwork: ee
        });
        throw this.emit("error", te), te;
      }
      return X;
    });
  }
  get blockNumber() {
    return this._getInternalBlockNumber(100 + this.pollingInterval / 2).then((X) => {
      this._setFastBlockNumber(X);
    }, (X) => {
    }), this._fastBlockNumber != null ? this._fastBlockNumber : -1;
  }
  get polling() {
    return this._poller != null;
  }
  set polling(X) {
    X && !this._poller ? (this._poller = setInterval(() => {
      this.poll();
    }, this.pollingInterval), this._bootstrapPoll || (this._bootstrapPoll = setTimeout(() => {
      this.poll(), this._bootstrapPoll = setTimeout(() => {
        this._poller || this.poll(), this._bootstrapPoll = null;
      }, this.pollingInterval);
    }, 0))) : !X && this._poller && (clearInterval(this._poller), this._poller = null);
  }
  get pollingInterval() {
    return this._pollingInterval;
  }
  set pollingInterval(X) {
    if (typeof X != "number" || X <= 0 || parseInt(String(X)) != X)
      throw new Error("invalid polling interval");
    this._pollingInterval = X, this._poller && (clearInterval(this._poller), this._poller = setInterval(() => {
      this.poll();
    }, this._pollingInterval));
  }
  _getFastBlockNumber() {
    const X = Hc();
    return X - this._fastQueryDate > 2 * this._pollingInterval && (this._fastQueryDate = X, this._fastBlockNumberPromise = this.getBlockNumber().then((ee) => ((this._fastBlockNumber == null || ee > this._fastBlockNumber) && (this._fastBlockNumber = ee), this._fastBlockNumber))), this._fastBlockNumberPromise;
  }
  _setFastBlockNumber(X) {
    this._fastBlockNumber != null && X < this._fastBlockNumber || (this._fastQueryDate = Hc(), (this._fastBlockNumber == null || X > this._fastBlockNumber) && (this._fastBlockNumber = X, this._fastBlockNumberPromise = Promise.resolve(X)));
  }
  waitForTransaction(X, ee, te) {
    return mt(this, void 0, void 0, function* () {
      return this._waitForTransaction(X, ee ?? 1, te || 0, null);
    });
  }
  _waitForTransaction(X, ee, te, ne) {
    return mt(this, void 0, void 0, function* () {
      const ie = yield this.getTransactionReceipt(X);
      return (ie ? ie.confirmations : 0) >= ee ? ie : new Promise((oe, se) => {
        const ae = [];
        let ue = !1;
        const le = function() {
          return ue ? !0 : (ue = !0, ae.forEach((me) => {
            me();
          }), !1);
        }, he = (me) => {
          me.confirmations < ee || le() || oe(me);
        };
        if (this.on(X, he), ae.push(() => {
          this.removeListener(X, he);
        }), ne) {
          let me = ne.startBlock, ye = null;
          const we = (Ee) => mt(this, void 0, void 0, function* () {
            ue || (yield $x(1e3), this.getTransactionCount(ne.from).then((Re) => mt(this, void 0, void 0, function* () {
              if (!ue) {
                if (Re <= ne.nonce)
                  me = Ee;
                else {
                  {
                    const Ue = yield this.getTransaction(X);
                    if (Ue && Ue.blockNumber != null)
                      return;
                  }
                  for (ye == null && (ye = me - 3, ye < ne.startBlock && (ye = ne.startBlock)); ye <= Ee; ) {
                    if (ue)
                      return;
                    const Ue = yield this.getBlockWithTransactions(ye);
                    for (let Me = 0; Me < Ue.transactions.length; Me++) {
                      const De = Ue.transactions[Me];
                      if (De.hash === X)
                        return;
                      if (De.from === ne.from && De.nonce === ne.nonce) {
                        if (ue)
                          return;
                        const Fe = yield this.waitForTransaction(De.hash, ee);
                        if (le())
                          return;
                        let Ke = "replaced";
                        De.data === ne.data && De.to === ne.to && De.value.eq(ne.value) ? Ke = "repriced" : De.data === "0x" && De.from === De.to && De.value.isZero() && (Ke = "cancelled"), se(Nt.makeError("transaction was replaced", ce.errors.TRANSACTION_REPLACED, {
                          cancelled: Ke === "replaced" || Ke === "cancelled",
                          reason: Ke,
                          replacement: this._wrapTransaction(De),
                          hash: X,
                          receipt: Fe
                        }));
                        return;
                      }
                    }
                    ye++;
                  }
                }
                ue || this.once("block", we);
              }
            }), (Re) => {
              ue || this.once("block", we);
            }));
          });
          if (ue)
            return;
          this.once("block", we), ae.push(() => {
            this.removeListener("block", we);
          });
        }
        if (typeof te == "number" && te > 0) {
          const me = setTimeout(() => {
            le() || se(Nt.makeError("timeout exceeded", ce.errors.TIMEOUT, { timeout: te }));
          }, te);
          me.unref && me.unref(), ae.push(() => {
            clearTimeout(me);
          });
        }
      });
    });
  }
  getBlockNumber() {
    return mt(this, void 0, void 0, function* () {
      return this._getInternalBlockNumber(0);
    });
  }
  getGasPrice() {
    return mt(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const X = yield this.perform("getGasPrice", {});
      try {
        return Be.from(X);
      } catch (ee) {
        return Nt.throwError("bad result from backend", ce.errors.SERVER_ERROR, {
          method: "getGasPrice",
          result: X,
          error: ee
        });
      }
    });
  }
  getBalance(X, ee) {
    return mt(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const te = yield Cr({
        address: this._getAddress(X),
        blockTag: this._getBlockTag(ee)
      }), ne = yield this.perform("getBalance", te);
      try {
        return Be.from(ne);
      } catch (ie) {
        return Nt.throwError("bad result from backend", ce.errors.SERVER_ERROR, {
          method: "getBalance",
          params: te,
          result: ne,
          error: ie
        });
      }
    });
  }
  getTransactionCount(X, ee) {
    return mt(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const te = yield Cr({
        address: this._getAddress(X),
        blockTag: this._getBlockTag(ee)
      }), ne = yield this.perform("getTransactionCount", te);
      try {
        return Be.from(ne).toNumber();
      } catch (ie) {
        return Nt.throwError("bad result from backend", ce.errors.SERVER_ERROR, {
          method: "getTransactionCount",
          params: te,
          result: ne,
          error: ie
        });
      }
    });
  }
  getCode(X, ee) {
    return mt(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const te = yield Cr({
        address: this._getAddress(X),
        blockTag: this._getBlockTag(ee)
      }), ne = yield this.perform("getCode", te);
      try {
        return Oe(ne);
      } catch (ie) {
        return Nt.throwError("bad result from backend", ce.errors.SERVER_ERROR, {
          method: "getCode",
          params: te,
          result: ne,
          error: ie
        });
      }
    });
  }
  getStorageAt(X, ee, te) {
    return mt(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const ne = yield Cr({
        address: this._getAddress(X),
        blockTag: this._getBlockTag(te),
        position: Promise.resolve(ee).then((oe) => om(oe))
      }), ie = yield this.perform("getStorageAt", ne);
      try {
        return Oe(ie);
      } catch (oe) {
        return Nt.throwError("bad result from backend", ce.errors.SERVER_ERROR, {
          method: "getStorageAt",
          params: ne,
          result: ie,
          error: oe
        });
      }
    });
  }
  // This should be called by any subclass wrapping a TransactionResponse
  _wrapTransaction(X, ee, te) {
    if (ee != null && Oo(ee) !== 32)
      throw new Error("invalid response - sendTransaction");
    const ne = X;
    return ee != null && X.hash !== ee && Nt.throwError("Transaction hash mismatch from Provider.sendTransaction.", ce.errors.UNKNOWN_ERROR, { expectedHash: X.hash, returnedHash: ee }), ne.wait = (ie, oe) => mt(this, void 0, void 0, function* () {
      ie == null && (ie = 1), oe == null && (oe = 0);
      let se;
      ie !== 0 && te != null && (se = {
        data: X.data,
        from: X.from,
        nonce: X.nonce,
        to: X.to,
        value: X.value,
        startBlock: te
      });
      const ae = yield this._waitForTransaction(X.hash, ie, oe, se);
      return ae == null && ie === 0 ? null : (this._emitted["t:" + X.hash] = ae.blockNumber, ae.status === 0 && Nt.throwError("transaction failed", ce.errors.CALL_EXCEPTION, {
        transactionHash: X.hash,
        transaction: X,
        receipt: ae
      }), ae);
    }), ne;
  }
  sendTransaction(X) {
    return mt(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const ee = yield Promise.resolve(X).then((ie) => Oe(ie)), te = this.formatter.transaction(X);
      te.confirmations == null && (te.confirmations = 0);
      const ne = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
      try {
        const ie = yield this.perform("sendTransaction", { signedTransaction: ee });
        return this._wrapTransaction(te, ie, ne);
      } catch (ie) {
        throw ie.transaction = te, ie.transactionHash = te.hash, ie;
      }
    });
  }
  _getTransactionRequest(X) {
    return mt(this, void 0, void 0, function* () {
      const ee = yield X, te = {};
      return ["from", "to"].forEach((ne) => {
        ee[ne] != null && (te[ne] = Promise.resolve(ee[ne]).then((ie) => ie ? this._getAddress(ie) : null));
      }), ["gasLimit", "gasPrice", "maxFeePerGas", "maxPriorityFeePerGas", "value"].forEach((ne) => {
        ee[ne] != null && (te[ne] = Promise.resolve(ee[ne]).then((ie) => ie ? Be.from(ie) : null));
      }), ["type"].forEach((ne) => {
        ee[ne] != null && (te[ne] = Promise.resolve(ee[ne]).then((ie) => ie ?? null));
      }), ee.accessList && (te.accessList = this.formatter.accessList(ee.accessList)), ["data"].forEach((ne) => {
        ee[ne] != null && (te[ne] = Promise.resolve(ee[ne]).then((ie) => ie ? Oe(ie) : null));
      }), this.formatter.transactionRequest(yield Cr(te));
    });
  }
  _getFilter(X) {
    return mt(this, void 0, void 0, function* () {
      X = yield X;
      const ee = {};
      return X.address != null && (ee.address = this._getAddress(X.address)), ["blockHash", "topics"].forEach((te) => {
        X[te] != null && (ee[te] = X[te]);
      }), ["fromBlock", "toBlock"].forEach((te) => {
        X[te] != null && (ee[te] = this._getBlockTag(X[te]));
      }), this.formatter.filter(yield Cr(ee));
    });
  }
  _call(X, ee, te) {
    return mt(this, void 0, void 0, function* () {
      te >= C9 && Nt.throwError("CCIP read exceeded maximum redirections", ce.errors.SERVER_ERROR, {
        redirects: te,
        transaction: X
      });
      const ne = X.to, ie = yield this.perform("call", { transaction: X, blockTag: ee });
      if (te >= 0 && ee === "latest" && ne != null && ie.substring(0, 10) === "0x556f1830" && Oo(ie) % 32 === 4)
        try {
          const oe = Dr(ie, 4), se = Dr(oe, 0, 32);
          Be.from(se).eq(ne) || Nt.throwError("CCIP Read sender did not match", ce.errors.CALL_EXCEPTION, {
            name: "OffchainLookup",
            signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
            transaction: X,
            data: ie
          });
          const ae = [], ue = Be.from(Dr(oe, 32, 64)).toNumber(), le = Be.from(Dr(oe, ue, ue + 32)).toNumber(), he = Dr(oe, ue + 32);
          for (let Ue = 0; Ue < le; Ue++) {
            const Me = Al(he, Ue * 32);
            Me == null && Nt.throwError("CCIP Read contained corrupt URL string", ce.errors.CALL_EXCEPTION, {
              name: "OffchainLookup",
              signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
              transaction: X,
              data: ie
            }), ae.push(Me);
          }
          const me = Iu(oe, 64);
          Be.from(Dr(oe, 100, 128)).isZero() || Nt.throwError("CCIP Read callback selector included junk", ce.errors.CALL_EXCEPTION, {
            name: "OffchainLookup",
            signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
            transaction: X,
            data: ie
          });
          const ye = Dr(oe, 96, 100), we = Iu(oe, 128), Ee = yield this.ccipReadFetch(X, me, ae);
          Ee == null && Nt.throwError("CCIP Read disabled or provided no URLs", ce.errors.CALL_EXCEPTION, {
            name: "OffchainLookup",
            signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
            transaction: X,
            data: ie
          });
          const Re = {
            to: ne,
            data: Tn([ye, p6([Ee, we])])
          };
          return this._call(Re, ee, te + 1);
        } catch (oe) {
          if (oe.code === ce.errors.SERVER_ERROR)
            throw oe;
        }
      try {
        return Oe(ie);
      } catch (oe) {
        return Nt.throwError("bad result from backend", ce.errors.SERVER_ERROR, {
          method: "call",
          params: { transaction: X, blockTag: ee },
          result: ie,
          error: oe
        });
      }
    });
  }
  call(X, ee) {
    return mt(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const te = yield Cr({
        transaction: this._getTransactionRequest(X),
        blockTag: this._getBlockTag(ee),
        ccipReadEnabled: Promise.resolve(X.ccipReadEnabled)
      });
      return this._call(te.transaction, te.blockTag, te.ccipReadEnabled ? 0 : -1);
    });
  }
  estimateGas(X) {
    return mt(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const ee = yield Cr({
        transaction: this._getTransactionRequest(X)
      }), te = yield this.perform("estimateGas", ee);
      try {
        return Be.from(te);
      } catch (ne) {
        return Nt.throwError("bad result from backend", ce.errors.SERVER_ERROR, {
          method: "estimateGas",
          params: ee,
          result: te,
          error: ne
        });
      }
    });
  }
  _getAddress(X) {
    return mt(this, void 0, void 0, function* () {
      X = yield X, typeof X != "string" && Nt.throwArgumentError("invalid address or ENS name", "name", X);
      const ee = yield this.resolveName(X);
      return ee == null && Nt.throwError("ENS name not configured", ce.errors.UNSUPPORTED_OPERATION, {
        operation: `resolveName(${JSON.stringify(X)})`
      }), ee;
    });
  }
  _getBlock(X, ee) {
    return mt(this, void 0, void 0, function* () {
      yield this.getNetwork(), X = yield X;
      let te = -128;
      const ne = {
        includeTransactions: !!ee
      };
      if (Bt(X, 32))
        ne.blockHash = X;
      else
        try {
          ne.blockTag = yield this._getBlockTag(X), Bt(ne.blockTag) && (te = parseInt(ne.blockTag.substring(2), 16));
        } catch {
          Nt.throwArgumentError("invalid block hash or block tag", "blockHashOrBlockTag", X);
        }
      return ya(() => mt(this, void 0, void 0, function* () {
        const ie = yield this.perform("getBlock", ne);
        if (ie == null)
          return ne.blockHash != null && this._emitted["b:" + ne.blockHash] == null || ne.blockTag != null && te > this._emitted.block ? null : void 0;
        if (ee) {
          let oe = null;
          for (let ae = 0; ae < ie.transactions.length; ae++) {
            const ue = ie.transactions[ae];
            if (ue.blockNumber == null)
              ue.confirmations = 0;
            else if (ue.confirmations == null) {
              oe == null && (oe = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval));
              let le = oe - ue.blockNumber + 1;
              le <= 0 && (le = 1), ue.confirmations = le;
            }
          }
          const se = this.formatter.blockWithTransactions(ie);
          return se.transactions = se.transactions.map((ae) => this._wrapTransaction(ae)), se;
        }
        return this.formatter.block(ie);
      }), { oncePoll: this });
    });
  }
  getBlock(X) {
    return this._getBlock(X, !1);
  }
  getBlockWithTransactions(X) {
    return this._getBlock(X, !0);
  }
  getTransaction(X) {
    return mt(this, void 0, void 0, function* () {
      yield this.getNetwork(), X = yield X;
      const ee = { transactionHash: this.formatter.hash(X, !0) };
      return ya(() => mt(this, void 0, void 0, function* () {
        const te = yield this.perform("getTransaction", ee);
        if (te == null)
          return this._emitted["t:" + X] == null ? null : void 0;
        const ne = this.formatter.transactionResponse(te);
        if (ne.blockNumber == null)
          ne.confirmations = 0;
        else if (ne.confirmations == null) {
          let ie = (yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval)) - ne.blockNumber + 1;
          ie <= 0 && (ie = 1), ne.confirmations = ie;
        }
        return this._wrapTransaction(ne);
      }), { oncePoll: this });
    });
  }
  getTransactionReceipt(X) {
    return mt(this, void 0, void 0, function* () {
      yield this.getNetwork(), X = yield X;
      const ee = { transactionHash: this.formatter.hash(X, !0) };
      return ya(() => mt(this, void 0, void 0, function* () {
        const te = yield this.perform("getTransactionReceipt", ee);
        if (te == null)
          return this._emitted["t:" + X] == null ? null : void 0;
        if (te.blockHash == null)
          return;
        const ne = this.formatter.receipt(te);
        if (ne.blockNumber == null)
          ne.confirmations = 0;
        else if (ne.confirmations == null) {
          let ie = (yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval)) - ne.blockNumber + 1;
          ie <= 0 && (ie = 1), ne.confirmations = ie;
        }
        return ne;
      }), { oncePoll: this });
    });
  }
  getLogs(X) {
    return mt(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const ee = yield Cr({ filter: this._getFilter(X) }), te = yield this.perform("getLogs", ee);
      return te.forEach((ne) => {
        ne.removed == null && (ne.removed = !1);
      }), We.arrayOf(this.formatter.filterLog.bind(this.formatter))(te);
    });
  }
  getEtherPrice() {
    return mt(this, void 0, void 0, function* () {
      return yield this.getNetwork(), this.perform("getEtherPrice", {});
    });
  }
  _getBlockTag(X) {
    return mt(this, void 0, void 0, function* () {
      if (X = yield X, typeof X == "number" && X < 0) {
        X % 1 && Nt.throwArgumentError("invalid BlockTag", "blockTag", X);
        let ee = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
        return ee += X, ee < 0 && (ee = 0), this.formatter.blockTag(ee);
      }
      return this.formatter.blockTag(X);
    });
  }
  getResolver(X) {
    return mt(this, void 0, void 0, function* () {
      let ee = X;
      for (; ; ) {
        if (ee === "" || ee === "." || X !== "eth" && ee === "eth")
          return null;
        const te = yield this._getResolver(ee, "getResolver");
        if (te != null) {
          const ne = new Hx(this, te, X);
          return ee !== X && !(yield ne.supportsWildcard()) ? null : ne;
        }
        ee = ee.split(".").slice(1).join(".");
      }
    });
  }
  _getResolver(X, ee) {
    return mt(this, void 0, void 0, function* () {
      ee == null && (ee = "ENS");
      const te = yield this.getNetwork();
      te.ensAddress || Nt.throwError("network does not support ENS", ce.errors.UNSUPPORTED_OPERATION, { operation: ee, network: te.name });
      try {
        const ne = yield this.call({
          to: te.ensAddress,
          data: "0x0178b8bf" + xl(X).substring(2)
        });
        return this.formatter.callAddress(ne);
      } catch {
      }
      return null;
    });
  }
  resolveName(X) {
    return mt(this, void 0, void 0, function* () {
      X = yield X;
      try {
        return Promise.resolve(this.formatter.address(X));
      } catch (te) {
        if (Bt(X))
          throw te;
      }
      typeof X != "string" && Nt.throwArgumentError("invalid ENS name", "name", X);
      const ee = yield this.getResolver(X);
      return ee ? yield ee.getAddress() : null;
    });
  }
  lookupAddress(X) {
    return mt(this, void 0, void 0, function* () {
      X = yield X, X = this.formatter.address(X);
      const ee = X.substring(2).toLowerCase() + ".addr.reverse", te = yield this._getResolver(ee, "lookupAddress");
      if (te == null)
        return null;
      const ne = Al(yield this.call({
        to: te,
        data: "0x691f3431" + xl(ee).substring(2)
      }), 0);
      return (yield this.resolveName(ne)) != X ? null : ne;
    });
  }
  getAvatar(X) {
    return mt(this, void 0, void 0, function* () {
      let ee = null;
      if (Bt(X)) {
        const ne = this.formatter.address(X).substring(2).toLowerCase() + ".addr.reverse", ie = yield this._getResolver(ne, "getAvatar");
        if (!ie)
          return null;
        ee = new Hx(this, ie, ne);
        try {
          const oe = yield ee.getAvatar();
          if (oe)
            return oe.url;
        } catch (oe) {
          if (oe.code !== ce.errors.CALL_EXCEPTION)
            throw oe;
        }
        try {
          const oe = Al(yield this.call({
            to: ie,
            data: "0x691f3431" + xl(ne).substring(2)
          }), 0);
          ee = yield this.getResolver(oe);
        } catch (oe) {
          if (oe.code !== ce.errors.CALL_EXCEPTION)
            throw oe;
          return null;
        }
      } else if (ee = yield this.getResolver(X), !ee)
        return null;
      const te = yield ee.getAvatar();
      return te == null ? null : te.url;
    });
  }
  perform(X, ee) {
    return Nt.throwError(X + " not implemented", ce.errors.NOT_IMPLEMENTED, { operation: X });
  }
  _startEvent(X) {
    this.polling = this._events.filter((ee) => ee.pollable()).length > 0;
  }
  _stopEvent(X) {
    this.polling = this._events.filter((ee) => ee.pollable()).length > 0;
  }
  _addEventListener(X, ee, te) {
    const ne = new B9(na(X), ee, te);
    return this._events.push(ne), this._startEvent(ne), this;
  }
  on(X, ee) {
    return this._addEventListener(X, ee, !1);
  }
  once(X, ee) {
    return this._addEventListener(X, ee, !0);
  }
  emit(X, ...ee) {
    let te = !1, ne = [], ie = na(X);
    return this._events = this._events.filter((oe) => oe.tag !== ie ? !0 : (setTimeout(() => {
      oe.listener.apply(this, ee);
    }, 0), te = !0, oe.once ? (ne.push(oe), !1) : !0)), ne.forEach((oe) => {
      this._stopEvent(oe);
    }), te;
  }
  listenerCount(X) {
    if (!X)
      return this._events.length;
    let ee = na(X);
    return this._events.filter((te) => te.tag === ee).length;
  }
  listeners(X) {
    if (X == null)
      return this._events.map((te) => te.listener);
    let ee = na(X);
    return this._events.filter((te) => te.tag === ee).map((te) => te.listener);
  }
  off(X, ee) {
    if (ee == null)
      return this.removeAllListeners(X);
    const te = [];
    let ne = !1, ie = na(X);
    return this._events = this._events.filter((oe) => oe.tag !== ie || oe.listener != ee || ne ? !0 : (ne = !0, te.push(oe), !1)), te.forEach((oe) => {
      this._stopEvent(oe);
    }), this;
  }
  removeAllListeners(X) {
    let ee = [];
    if (X == null)
      ee = this._events, this._events = [];
    else {
      const te = na(X);
      this._events = this._events.filter((ne) => ne.tag !== te ? !0 : (ee.push(ne), !1));
    }
    return ee.forEach((te) => {
      this._stopEvent(te);
    }), this;
  }
}
var ds = function(Y, X, ee, te) {
  function ne(ie) {
    return ie instanceof ee ? ie : new ee(function(oe) {
      oe(ie);
    });
  }
  return new (ee || (ee = Promise))(function(ie, oe) {
    function se(le) {
      try {
        ue(te.next(le));
      } catch (he) {
        oe(he);
      }
    }
    function ae(le) {
      try {
        ue(te.throw(le));
      } catch (he) {
        oe(he);
      }
    }
    function ue(le) {
      le.done ? ie(le.value) : ne(le.value).then(se, ae);
    }
    ue((te = te.apply(Y, X || [])).next());
  });
};
const Mr = new ce(lf), L9 = ["call", "estimateGas"];
function uu(Y, X) {
  if (Y == null)
    return null;
  if (typeof Y.message == "string" && Y.message.match("reverted")) {
    const ee = Bt(Y.data) ? Y.data : null;
    if (!X || ee)
      return { message: Y.message, data: ee };
  }
  if (typeof Y == "object") {
    for (const ee in Y) {
      const te = uu(Y[ee], X);
      if (te)
        return te;
    }
    return null;
  }
  if (typeof Y == "string")
    try {
      return uu(JSON.parse(Y), X);
    } catch {
    }
  return null;
}
function m6(Y, X, ee) {
  const te = ee.transaction || ee.signedTransaction;
  if (Y === "call") {
    const ie = uu(X, !0);
    if (ie)
      return ie.data;
    Mr.throwError("missing revert data in call exception; Transaction reverted without a reason string", ce.errors.CALL_EXCEPTION, {
      data: "0x",
      transaction: te,
      error: X
    });
  }
  if (Y === "estimateGas") {
    let ie = uu(X.body, !1);
    ie == null && (ie = uu(X, !1)), ie && Mr.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", ce.errors.UNPREDICTABLE_GAS_LIMIT, {
      reason: ie.message,
      method: Y,
      transaction: te,
      error: X
    });
  }
  let ne = X.message;
  throw X.code === ce.errors.SERVER_ERROR && X.error && typeof X.error.message == "string" ? ne = X.error.message : typeof X.body == "string" ? ne = X.body : typeof X.responseText == "string" && (ne = X.responseText), ne = (ne || "").toLowerCase(), ne.match(/insufficient funds|base fee exceeds gas limit|InsufficientFunds/i) && Mr.throwError("insufficient funds for intrinsic transaction cost", ce.errors.INSUFFICIENT_FUNDS, {
    error: X,
    method: Y,
    transaction: te
  }), ne.match(/nonce (is )?too low/i) && Mr.throwError("nonce has already been used", ce.errors.NONCE_EXPIRED, {
    error: X,
    method: Y,
    transaction: te
  }), ne.match(/replacement transaction underpriced|transaction gas price.*too low/i) && Mr.throwError("replacement fee too low", ce.errors.REPLACEMENT_UNDERPRICED, {
    error: X,
    method: Y,
    transaction: te
  }), ne.match(/only replay-protected/i) && Mr.throwError("legacy pre-eip-155 transactions not supported", ce.errors.UNSUPPORTED_OPERATION, {
    error: X,
    method: Y,
    transaction: te
  }), L9.indexOf(Y) >= 0 && ne.match(/gas required exceeds allowance|always failing transaction|execution reverted|revert/) && Mr.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", ce.errors.UNPREDICTABLE_GAS_LIMIT, {
    error: X,
    method: Y,
    transaction: te
  }), X;
}
function zx(Y) {
  return new Promise(function(X) {
    setTimeout(X, Y);
  });
}
function F9(Y) {
  if (Y.error) {
    const X = new Error(Y.error.message);
    throw X.code = Y.error.code, X.data = Y.error.data, X;
  }
  return Y.result;
}
function zc(Y) {
  return Y && Y.toLowerCase();
}
const Vp = {};
class y6 extends hc {
  constructor(X, ee, te) {
    if (super(), X !== Vp)
      throw new Error("do not call the JsonRpcSigner constructor directly; use provider.getSigner");
    ve(this, "provider", ee), te == null && (te = 0), typeof te == "string" ? (ve(this, "_address", this.provider.formatter.address(te)), ve(this, "_index", null)) : typeof te == "number" ? (ve(this, "_index", te), ve(this, "_address", null)) : Mr.throwArgumentError("invalid address or index", "addressOrIndex", te);
  }
  connect(X) {
    return Mr.throwError("cannot alter JSON-RPC Signer connection", ce.errors.UNSUPPORTED_OPERATION, {
      operation: "connect"
    });
  }
  connectUnchecked() {
    return new $9(Vp, this.provider, this._address || this._index);
  }
  getAddress() {
    return this._address ? Promise.resolve(this._address) : this.provider.send("eth_accounts", []).then((X) => (X.length <= this._index && Mr.throwError("unknown account #" + this._index, ce.errors.UNSUPPORTED_OPERATION, {
      operation: "getAddress"
    }), this.provider.formatter.address(X[this._index])));
  }
  sendUncheckedTransaction(X) {
    X = mr$1(X);
    const ee = this.getAddress().then((te) => (te && (te = te.toLowerCase()), te));
    if (X.gasLimit == null) {
      const te = mr$1(X);
      te.from = ee, X.gasLimit = this.provider.estimateGas(te);
    }
    return X.to != null && (X.to = Promise.resolve(X.to).then((te) => ds(this, void 0, void 0, function* () {
      if (te == null)
        return null;
      const ne = yield this.provider.resolveName(te);
      return ne == null && Mr.throwArgumentError("provided ENS name resolves to null", "tx.to", te), ne;
    }))), Cr({
      tx: Cr(X),
      sender: ee
    }).then(({ tx: te, sender: ne }) => {
      te.from != null ? te.from.toLowerCase() !== ne && Mr.throwArgumentError("from address mismatch", "transaction", X) : te.from = ne;
      const ie = this.provider.constructor.hexlifyTransaction(te, { from: !0 });
      return this.provider.send("eth_sendTransaction", [ie]).then((oe) => oe, (oe) => (typeof oe.message == "string" && oe.message.match(/user denied/i) && Mr.throwError("user rejected transaction", ce.errors.ACTION_REJECTED, {
        action: "sendTransaction",
        transaction: te
      }), m6("sendTransaction", oe, ie)));
    });
  }
  signTransaction(X) {
    return Mr.throwError("signing transactions is unsupported", ce.errors.UNSUPPORTED_OPERATION, {
      operation: "signTransaction"
    });
  }
  sendTransaction(X) {
    return ds(this, void 0, void 0, function* () {
      const ee = yield this.provider._getInternalBlockNumber(100 + 2 * this.provider.pollingInterval), te = yield this.sendUncheckedTransaction(X);
      try {
        return yield ya(() => ds(this, void 0, void 0, function* () {
          const ne = yield this.provider.getTransaction(te);
          if (ne !== null)
            return this.provider._wrapTransaction(ne, te, ee);
        }), { oncePoll: this.provider });
      } catch (ne) {
        throw ne.transactionHash = te, ne;
      }
    });
  }
  signMessage(X) {
    return ds(this, void 0, void 0, function* () {
      const ee = typeof X == "string" ? Xr(X) : X, te = yield this.getAddress();
      try {
        return yield this.provider.send("personal_sign", [Oe(ee), te.toLowerCase()]);
      } catch (ne) {
        throw typeof ne.message == "string" && ne.message.match(/user denied/i) && Mr.throwError("user rejected signing", ce.errors.ACTION_REJECTED, {
          action: "signMessage",
          from: te,
          messageData: X
        }), ne;
      }
    });
  }
  _legacySignMessage(X) {
    return ds(this, void 0, void 0, function* () {
      const ee = typeof X == "string" ? Xr(X) : X, te = yield this.getAddress();
      try {
        return yield this.provider.send("eth_sign", [te.toLowerCase(), Oe(ee)]);
      } catch (ne) {
        throw typeof ne.message == "string" && ne.message.match(/user denied/i) && Mr.throwError("user rejected signing", ce.errors.ACTION_REJECTED, {
          action: "_legacySignMessage",
          from: te,
          messageData: X
        }), ne;
      }
    });
  }
  _signTypedData(X, ee, te) {
    return ds(this, void 0, void 0, function* () {
      const ne = yield gn.resolveNames(X, ee, te, (oe) => this.provider.resolveName(oe)), ie = yield this.getAddress();
      try {
        return yield this.provider.send("eth_signTypedData_v4", [
          ie.toLowerCase(),
          JSON.stringify(gn.getPayload(ne.domain, ee, ne.value))
        ]);
      } catch (oe) {
        throw typeof oe.message == "string" && oe.message.match(/user denied/i) && Mr.throwError("user rejected signing", ce.errors.ACTION_REJECTED, {
          action: "_signTypedData",
          from: ie,
          messageData: { domain: ne.domain, types: ee, value: ne.value }
        }), oe;
      }
    });
  }
  unlock(X) {
    return ds(this, void 0, void 0, function* () {
      const ee = this.provider, te = yield this.getAddress();
      return ee.send("personal_unlockAccount", [te.toLowerCase(), X, null]);
    });
  }
}
class $9 extends y6 {
  sendTransaction(X) {
    return this.sendUncheckedTransaction(X).then((ee) => ({
      hash: ee,
      nonce: null,
      gasLimit: null,
      gasPrice: null,
      data: null,
      value: null,
      chainId: null,
      confirmations: 0,
      from: null,
      wait: (te) => this.provider.waitForTransaction(ee, te)
    }));
  }
}
const D9 = {
  chainId: !0,
  data: !0,
  gasLimit: !0,
  gasPrice: !0,
  nonce: !0,
  to: !0,
  value: !0,
  type: !0,
  accessList: !0,
  maxFeePerGas: !0,
  maxPriorityFeePerGas: !0
};
let zl$1 = class extends g6 {
  constructor(Y, X) {
    let ee = X;
    ee == null && (ee = new Promise((te, ne) => {
      setTimeout(() => {
        this.detectNetwork().then((ie) => {
          te(ie);
        }, (ie) => {
          ne(ie);
        });
      }, 0);
    })), super(ee), Y || (Y = ji(this.constructor, "defaultUrl")()), typeof Y == "string" ? ve(this, "connection", Object.freeze({
      url: Y
    })) : ve(this, "connection", Object.freeze(mr$1(Y))), this._nextId = 42;
  }
  get _cache() {
    return this._eventLoopCache == null && (this._eventLoopCache = {}), this._eventLoopCache;
  }
  static defaultUrl() {
    return "http://localhost:8545";
  }
  detectNetwork() {
    return this._cache.detectNetwork || (this._cache.detectNetwork = this._uncachedDetectNetwork(), setTimeout(() => {
      this._cache.detectNetwork = null;
    }, 0)), this._cache.detectNetwork;
  }
  _uncachedDetectNetwork() {
    return ds(this, void 0, void 0, function* () {
      yield zx(0);
      let Y = null;
      try {
        Y = yield this.send("eth_chainId", []);
      } catch {
        try {
          Y = yield this.send("net_version", []);
        } catch {
        }
      }
      if (Y != null) {
        const X = ji(this.constructor, "getNetwork");
        try {
          return X(Be.from(Y).toNumber());
        } catch (ee) {
          return Mr.throwError("could not detect network", ce.errors.NETWORK_ERROR, {
            chainId: Y,
            event: "invalidNetwork",
            serverError: ee
          });
        }
      }
      return Mr.throwError("could not detect network", ce.errors.NETWORK_ERROR, {
        event: "noNetwork"
      });
    });
  }
  getSigner(Y) {
    return new y6(Vp, this, Y);
  }
  getUncheckedSigner(Y) {
    return this.getSigner(Y).connectUnchecked();
  }
  listAccounts() {
    return this.send("eth_accounts", []).then((Y) => Y.map((X) => this.formatter.address(X)));
  }
  send(Y, X) {
    const ee = {
      method: Y,
      params: X,
      id: this._nextId++,
      jsonrpc: "2.0"
    };
    this.emit("debug", {
      action: "request",
      request: ti(ee),
      provider: this
    });
    const te = ["eth_chainId", "eth_blockNumber"].indexOf(Y) >= 0;
    if (te && this._cache[Y])
      return this._cache[Y];
    const ne = vm(this.connection, JSON.stringify(ee), F9).then((ie) => (this.emit("debug", {
      action: "response",
      request: ee,
      response: ie,
      provider: this
    }), ie), (ie) => {
      throw this.emit("debug", {
        action: "response",
        error: ie,
        request: ee,
        provider: this
      }), ie;
    });
    return te && (this._cache[Y] = ne, setTimeout(() => {
      this._cache[Y] = null;
    }, 0)), ne;
  }
  prepareRequest(Y, X) {
    switch (Y) {
      case "getBlockNumber":
        return ["eth_blockNumber", []];
      case "getGasPrice":
        return ["eth_gasPrice", []];
      case "getBalance":
        return ["eth_getBalance", [zc(X.address), X.blockTag]];
      case "getTransactionCount":
        return ["eth_getTransactionCount", [zc(X.address), X.blockTag]];
      case "getCode":
        return ["eth_getCode", [zc(X.address), X.blockTag]];
      case "getStorageAt":
        return ["eth_getStorageAt", [zc(X.address), hr$1(X.position, 32), X.blockTag]];
      case "sendTransaction":
        return ["eth_sendRawTransaction", [X.signedTransaction]];
      case "getBlock":
        return X.blockTag ? ["eth_getBlockByNumber", [X.blockTag, !!X.includeTransactions]] : X.blockHash ? ["eth_getBlockByHash", [X.blockHash, !!X.includeTransactions]] : null;
      case "getTransaction":
        return ["eth_getTransactionByHash", [X.transactionHash]];
      case "getTransactionReceipt":
        return ["eth_getTransactionReceipt", [X.transactionHash]];
      case "call":
        return ["eth_call", [ji(this.constructor, "hexlifyTransaction")(X.transaction, { from: !0 }), X.blockTag]];
      case "estimateGas":
        return ["eth_estimateGas", [ji(this.constructor, "hexlifyTransaction")(X.transaction, { from: !0 })]];
      case "getLogs":
        return X.filter && X.filter.address != null && (X.filter.address = zc(X.filter.address)), ["eth_getLogs", [X.filter]];
    }
    return null;
  }
  perform(Y, X) {
    return ds(this, void 0, void 0, function* () {
      if (Y === "call" || Y === "estimateGas") {
        const te = X.transaction;
        if (te && te.type != null && Be.from(te.type).isZero() && te.maxFeePerGas == null && te.maxPriorityFeePerGas == null) {
          const ne = yield this.getFeeData();
          ne.maxFeePerGas == null && ne.maxPriorityFeePerGas == null && (X = mr$1(X), X.transaction = mr$1(te), delete X.transaction.type);
        }
      }
      const ee = this.prepareRequest(Y, X);
      ee == null && Mr.throwError(Y + " not implemented", ce.errors.NOT_IMPLEMENTED, { operation: Y });
      try {
        return yield this.send(ee[0], ee[1]);
      } catch (te) {
        return m6(Y, te, X);
      }
    });
  }
  _startEvent(Y) {
    Y.tag === "pending" && this._startPending(), super._startEvent(Y);
  }
  _startPending() {
    if (this._pendingFilter != null)
      return;
    const Y = this, X = this.send("eth_newPendingTransactionFilter", []);
    this._pendingFilter = X, X.then(function(ee) {
      function te() {
        Y.send("eth_getFilterChanges", [ee]).then(function(ne) {
          if (Y._pendingFilter != X)
            return null;
          let ie = Promise.resolve();
          return ne.forEach(function(oe) {
            Y._emitted["t:" + oe.toLowerCase()] = "pending", ie = ie.then(function() {
              return Y.getTransaction(oe).then(function(se) {
                return Y.emit("pending", se), null;
              });
            });
          }), ie.then(function() {
            return zx(1e3);
          });
        }).then(function() {
          if (Y._pendingFilter != X) {
            Y.send("eth_uninstallFilter", [ee]);
            return;
          }
          return setTimeout(function() {
            te();
          }, 0), null;
        }).catch((ne) => {
        });
      }
      return te(), ee;
    }).catch((ee) => {
    });
  }
  _stopEvent(Y) {
    Y.tag === "pending" && this.listenerCount("pending") === 0 && (this._pendingFilter = null), super._stopEvent(Y);
  }
  // Convert an ethers.js transaction into a JSON-RPC transaction
  //  - gasLimit => gas
  //  - All values hexlified
  //  - All numeric values zero-striped
  //  - All addresses are lowercased
  // NOTE: This allows a TransactionRequest, but all values should be resolved
  //       before this is called
  // @TODO: This will likely be removed in future versions and prepareRequest
  //        will be the preferred method for this.
  static hexlifyTransaction(Y, X) {
    const ee = mr$1(D9);
    if (X)
      for (const ne in X)
        X[ne] && (ee[ne] = !0);
    W2(Y, ee);
    const te = {};
    return ["chainId", "gasLimit", "gasPrice", "type", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "value"].forEach(function(ne) {
      if (Y[ne] == null)
        return;
      const ie = om(Be.from(Y[ne]));
      ne === "gasLimit" && (ne = "gas"), te[ne] = ie;
    }), ["from", "to", "data"].forEach(function(ne) {
      Y[ne] != null && (te[ne] = Oe(Y[ne]));
    }), Y.accessList && (te.accessList = bc(Y.accessList)), te;
  }
};
var ql = function(Y, X, ee, te) {
  function ne(ie) {
    return ie instanceof ee ? ie : new ee(function(oe) {
      oe(ie);
    });
  }
  return new (ee || (ee = Promise))(function(ie, oe) {
    function se(le) {
      try {
        ue(te.next(le));
      } catch (he) {
        oe(he);
      }
    }
    function ae(le) {
      try {
        ue(te.throw(le));
      } catch (he) {
        oe(he);
      }
    }
    function ue(le) {
      le.done ? ie(le.value) : ne(le.value).then(se, ae);
    }
    ue((te = te.apply(Y, X || [])).next());
  });
};
const Eo = new ce(lf);
function qf() {
  return (/* @__PURE__ */ new Date()).getTime();
}
function qx(Y) {
  let X = null;
  for (let ee = 0; ee < Y.length; ee++) {
    const te = Y[ee];
    if (te == null)
      return null;
    X ? X.name === te.name && X.chainId === te.chainId && (X.ensAddress === te.ensAddress || X.ensAddress == null && te.ensAddress == null) || Eo.throwArgumentError("provider mismatch", "networks", Y) : X = te;
  }
  return X;
}
function Gx(Y, X) {
  Y = Y.slice().sort();
  const ee = Math.floor(Y.length / 2);
  if (Y.length % 2)
    return Y[ee];
  const te = Y[ee - 1], ne = Y[ee];
  return X != null && Math.abs(te - ne) > X ? null : (te + ne) / 2;
}
function ba(Y) {
  if (Y === null)
    return "null";
  if (typeof Y == "number" || typeof Y == "boolean")
    return JSON.stringify(Y);
  if (typeof Y == "string")
    return Y;
  if (Be.isBigNumber(Y))
    return Y.toString();
  if (Array.isArray(Y))
    return JSON.stringify(Y.map((X) => ba(X)));
  if (typeof Y == "object") {
    const X = Object.keys(Y);
    return X.sort(), "{" + X.map((ee) => {
      let te = Y[ee];
      return typeof te == "function" ? te = "[function]" : te = ba(te), JSON.stringify(ee) + ":" + te;
    }).join(",") + "}";
  }
  throw new Error("unknown value type: " + typeof Y);
}
let U9 = 1;
function Vx(Y) {
  let X = null, ee = null, te = new Promise((oe) => {
    X = function() {
      ee && (clearTimeout(ee), ee = null), oe();
    }, ee = setTimeout(X, Y);
  });
  const ne = (oe) => (te = te.then(oe), te);
  function ie() {
    return te;
  }
  return { cancel: X, getPromise: ie, wait: ne };
}
const j9 = [
  ce.errors.CALL_EXCEPTION,
  ce.errors.INSUFFICIENT_FUNDS,
  ce.errors.NONCE_EXPIRED,
  ce.errors.REPLACEMENT_UNDERPRICED,
  ce.errors.UNPREDICTABLE_GAS_LIMIT
], H9 = [
  "address",
  "args",
  "errorArgs",
  "errorSignature",
  "method",
  "transaction"
];
function Gf(Y, X) {
  const ee = {
    weight: Y.weight
  };
  return Object.defineProperty(ee, "provider", { get: () => Y.provider }), Y.start && (ee.start = Y.start), X && (ee.duration = X - Y.start), Y.done && (Y.error ? ee.error = Y.error : ee.result = Y.result || null), ee;
}
function z9(Y, X) {
  return function(ee) {
    const te = {};
    ee.forEach((ie) => {
      const oe = Y(ie.result);
      te[oe] || (te[oe] = { count: 0, result: ie.result }), te[oe].count++;
    });
    const ne = Object.keys(te);
    for (let ie = 0; ie < ne.length; ie++) {
      const oe = te[ne[ie]];
      if (oe.count >= X)
        return oe.result;
    }
  };
}
function q9(Y, X, ee) {
  let te = ba;
  switch (X) {
    case "getBlockNumber":
      return function(ne) {
        const ie = ne.map((se) => se.result);
        let oe = Gx(ne.map((se) => se.result), 2);
        if (oe != null)
          return oe = Math.ceil(oe), ie.indexOf(oe + 1) >= 0 && oe++, oe >= Y._highestBlockNumber && (Y._highestBlockNumber = oe), Y._highestBlockNumber;
      };
    case "getGasPrice":
      return function(ne) {
        const ie = ne.map((oe) => oe.result);
        return ie.sort(), ie[Math.floor(ie.length / 2)];
      };
    case "getEtherPrice":
      return function(ne) {
        return Gx(ne.map((ie) => ie.result));
      };
    case "getBalance":
    case "getTransactionCount":
    case "getCode":
    case "getStorageAt":
    case "call":
    case "estimateGas":
    case "getLogs":
      break;
    case "getTransaction":
    case "getTransactionReceipt":
      te = function(ne) {
        return ne == null ? null : (ne = mr$1(ne), ne.confirmations = -1, ba(ne));
      };
      break;
    case "getBlock":
      ee.includeTransactions ? te = function(ne) {
        return ne == null ? null : (ne = mr$1(ne), ne.transactions = ne.transactions.map((ie) => (ie = mr$1(ie), ie.confirmations = -1, ie)), ba(ne));
      } : te = function(ne) {
        return ne == null ? null : ba(ne);
      };
      break;
    default:
      throw new Error("unknown method: " + X);
  }
  return z9(te, Y.quorum);
}
function qc(Y, X) {
  return ql(this, void 0, void 0, function* () {
    const ee = Y.provider;
    return ee.blockNumber != null && ee.blockNumber >= X || X === -1 ? ee : ya(() => new Promise((te, ne) => {
      setTimeout(function() {
        return ee.blockNumber >= X ? te(ee) : Y.cancelled ? te(null) : te(void 0);
      }, 0);
    }), { oncePoll: ee });
  });
}
function G9(Y, X, ee, te) {
  return ql(this, void 0, void 0, function* () {
    let ne = Y.provider;
    switch (ee) {
      case "getBlockNumber":
      case "getGasPrice":
        return ne[ee]();
      case "getEtherPrice":
        if (ne.getEtherPrice)
          return ne.getEtherPrice();
        break;
      case "getBalance":
      case "getTransactionCount":
      case "getCode":
        return te.blockTag && Bt(te.blockTag) && (ne = yield qc(Y, X)), ne[ee](te.address, te.blockTag || "latest");
      case "getStorageAt":
        return te.blockTag && Bt(te.blockTag) && (ne = yield qc(Y, X)), ne.getStorageAt(te.address, te.position, te.blockTag || "latest");
      case "getBlock":
        return te.blockTag && Bt(te.blockTag) && (ne = yield qc(Y, X)), ne[te.includeTransactions ? "getBlockWithTransactions" : "getBlock"](te.blockTag || te.blockHash);
      case "call":
      case "estimateGas":
        return te.blockTag && Bt(te.blockTag) && (ne = yield qc(Y, X)), ee === "call" && te.blockTag ? ne[ee](te.transaction, te.blockTag) : ne[ee](te.transaction);
      case "getTransaction":
      case "getTransactionReceipt":
        return ne[ee](te.transactionHash);
      case "getLogs": {
        let ie = te.filter;
        return (ie.fromBlock && Bt(ie.fromBlock) || ie.toBlock && Bt(ie.toBlock)) && (ne = yield qc(Y, X)), ne.getLogs(ie);
      }
    }
    return Eo.throwError("unknown method error", ce.errors.UNKNOWN_ERROR, {
      method: ee,
      params: te
    });
  });
}
class V9 extends g6 {
  constructor(X, ee) {
    X.length === 0 && Eo.throwArgumentError("missing providers", "providers", X);
    const te = X.map((oe, se) => {
      if (dc.isProvider(oe)) {
        const le = Mx(oe) ? 2e3 : 750;
        return Object.freeze({ provider: oe, weight: 1, stallTimeout: le, priority: 1 });
      }
      const ae = mr$1(oe);
      ae.priority == null && (ae.priority = 1), ae.stallTimeout == null && (ae.stallTimeout = Mx(oe) ? 2e3 : 750), ae.weight == null && (ae.weight = 1);
      const ue = ae.weight;
      return (ue % 1 || ue > 512 || ue < 1) && Eo.throwArgumentError("invalid weight; must be integer in [1, 512]", `providers[${se}].weight`, ue), Object.freeze(ae);
    }), ne = te.reduce((oe, se) => oe + se.weight, 0);
    ee == null ? ee = ne / 2 : ee > ne && Eo.throwArgumentError("quorum will always fail; larger than total weight", "quorum", ee);
    let ie = qx(te.map((oe) => oe.provider.network));
    ie == null && (ie = new Promise((oe, se) => {
      setTimeout(() => {
        this.detectNetwork().then(oe, se);
      }, 0);
    })), super(ie), ve(this, "providerConfigs", Object.freeze(te)), ve(this, "quorum", ee), this._highestBlockNumber = -1;
  }
  detectNetwork() {
    return ql(this, void 0, void 0, function* () {
      const X = yield Promise.all(this.providerConfigs.map((ee) => ee.provider.getNetwork()));
      return qx(X);
    });
  }
  perform(X, ee) {
    return ql(this, void 0, void 0, function* () {
      if (X === "sendTransaction") {
        const ae = yield Promise.all(this.providerConfigs.map((ue) => ue.provider.sendTransaction(ee.signedTransaction).then((le) => le.hash, (le) => le)));
        for (let ue = 0; ue < ae.length; ue++) {
          const le = ae[ue];
          if (typeof le == "string")
            return le;
        }
        throw ae[0];
      }
      this._highestBlockNumber === -1 && X !== "getBlockNumber" && (yield this.getBlockNumber());
      const te = q9(this, X, ee), ne = WC(this.providerConfigs.map(mr$1));
      ne.sort((ae, ue) => ae.priority - ue.priority);
      const ie = this._highestBlockNumber;
      let oe = 0, se = !0;
      for (; ; ) {
        const ae = qf();
        let ue = ne.filter((ye) => ye.runner && ae - ye.start < ye.stallTimeout).reduce((ye, we) => ye + we.weight, 0);
        for (; ue < this.quorum && oe < ne.length; ) {
          const ye = ne[oe++], we = U9++;
          ye.start = qf(), ye.staller = Vx(ye.stallTimeout), ye.staller.wait(() => {
            ye.staller = null;
          }), ye.runner = G9(ye, ie, X, ee).then((Ee) => {
            ye.done = !0, ye.result = Ee, this.listenerCount("debug") && this.emit("debug", {
              action: "request",
              rid: we,
              backend: Gf(ye, qf()),
              request: { method: X, params: ti(ee) },
              provider: this
            });
          }, (Ee) => {
            ye.done = !0, ye.error = Ee, this.listenerCount("debug") && this.emit("debug", {
              action: "request",
              rid: we,
              backend: Gf(ye, qf()),
              request: { method: X, params: ti(ee) },
              provider: this
            });
          }), this.listenerCount("debug") && this.emit("debug", {
            action: "request",
            rid: we,
            backend: Gf(ye, null),
            request: { method: X, params: ti(ee) },
            provider: this
          }), ue += ye.weight;
        }
        const le = [];
        ne.forEach((ye) => {
          ye.done || !ye.runner || (le.push(ye.runner), ye.staller && le.push(ye.staller.getPromise()));
        }), le.length && (yield Promise.race(le));
        const he = ne.filter((ye) => ye.done && ye.error == null);
        if (he.length >= this.quorum) {
          const ye = te(he);
          if (ye !== void 0)
            return ne.forEach((we) => {
              we.staller && we.staller.cancel(), we.cancelled = !0;
            }), ye;
          se || (yield Vx(100).getPromise()), se = !1;
        }
        const me = ne.reduce((ye, we) => {
          if (!we.done || we.error == null)
            return ye;
          const Ee = we.error.code;
          return j9.indexOf(Ee) >= 0 && (ye[Ee] || (ye[Ee] = { error: we.error, weight: 0 }), ye[Ee].weight += we.weight), ye;
        }, {});
        if (Object.keys(me).forEach((ye) => {
          const we = me[ye];
          if (we.weight < this.quorum)
            return;
          ne.forEach((Ue) => {
            Ue.staller && Ue.staller.cancel(), Ue.cancelled = !0;
          });
          const Ee = we.error, Re = {};
          H9.forEach((Ue) => {
            Ee[Ue] != null && (Re[Ue] = Ee[Ue]);
          }), Eo.throwError(Ee.reason || Ee.message, ye, Re);
        }), ne.filter((ye) => !ye.done).length === 0)
          break;
      }
      return ne.forEach((ae) => {
        ae.staller && ae.staller.cancel(), ae.cancelled = !0;
      }), Eo.throwError("failed to meet quorum", ce.errors.SERVER_ERROR, {
        method: X,
        params: ee,
        //results: configs.map((c) => c.result),
        //errors: configs.map((c) => c.error),
        results: ne.map((ae) => Gf(ae)),
        provider: this
      });
    });
  }
}
const Wx = new ce(lf);
let W9 = 1;
function Kx(Y, X) {
  const ee = "Web3LegacyFetcher";
  return function(te, ne) {
    const ie = {
      method: te,
      params: ne,
      id: W9++,
      jsonrpc: "2.0"
    };
    return new Promise((oe, se) => {
      this.emit("debug", {
        action: "request",
        fetcher: ee,
        request: ti(ie),
        provider: this
      }), X(ie, (ae, ue) => {
        if (ae)
          return this.emit("debug", {
            action: "response",
            fetcher: ee,
            error: ae,
            request: ie,
            provider: this
          }), se(ae);
        if (this.emit("debug", {
          action: "response",
          fetcher: ee,
          request: ie,
          response: ue,
          provider: this
        }), ue.error) {
          const le = new Error(ue.error.message);
          return le.code = ue.error.code, le.data = ue.error.data, se(le);
        }
        oe(ue.result);
      });
    });
  };
}
function K9(Y) {
  return function(X, ee) {
    ee == null && (ee = []);
    const te = { method: X, params: ee };
    return this.emit("debug", {
      action: "request",
      fetcher: "Eip1193Fetcher",
      request: ti(te),
      provider: this
    }), Y.request(te).then((ne) => (this.emit("debug", {
      action: "response",
      fetcher: "Eip1193Fetcher",
      request: te,
      response: ne,
      provider: this
    }), ne), (ne) => {
      throw this.emit("debug", {
        action: "response",
        fetcher: "Eip1193Fetcher",
        request: te,
        error: ne,
        provider: this
      }), ne;
    });
  };
}
class J9 extends zl$1 {
  constructor(X, ee) {
    X == null && Wx.throwArgumentError("missing provider", "provider", X);
    let te = null, ne = null, ie = null;
    typeof X == "function" ? (te = "unknown:", ne = X) : (te = X.host || X.path || "", !te && X.isMetaMask && (te = "metamask"), ie = X, X.request ? (te === "" && (te = "eip-1193:"), ne = K9(X)) : X.sendAsync ? ne = Kx(X, X.sendAsync.bind(X)) : X.send ? ne = Kx(X, X.send.bind(X)) : Wx.throwArgumentError("unsupported provider", "provider", X), te || (te = "unknown:")), super(te, ee), ve(this, "jsonRpcFetchFunc", ne), ve(this, "provider", ie);
  }
  send(X, ee) {
    return this.jsonRpcFetchFunc(X, ee);
  }
}
const Y9 = "units/5.7.0", X9 = new ce(Y9), b6 = [
  "wei",
  "kwei",
  "mwei",
  "gwei",
  "szabo",
  "finney",
  "ether"
];
function x6(Y, X) {
  if (typeof X == "string") {
    const ee = b6.indexOf(X);
    ee !== -1 && (X = 3 * ee);
  }
  return yl(Y, X ?? 18);
}
function da(Y, X) {
  if (typeof Y != "string" && X9.throwArgumentError("value must be a string", "value", Y), typeof X == "string") {
    const ee = b6.indexOf(X);
    ee !== -1 && (X = 3 * ee);
  }
  return Ri(Y, X ?? 18);
}
function Jx(Y) {
  return x6(Y, 18);
}
function Vf(Y) {
  return da(Y, 18);
}
var w6 = {}, to = {}, Od = {}, Bd = {}, v6 = {}, Nd = {};
Nd.byteLength = e7;
Nd.toByteArray = r7;
Nd.fromByteArray = s7;
var $i = [], Wn = [], Z9 = typeof Uint8Array < "u" ? Uint8Array : Array, fh = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var ia = 0, Q9 = fh.length; ia < Q9; ++ia)
  $i[ia] = fh[ia], Wn[fh.charCodeAt(ia)] = ia;
Wn[45] = 62;
Wn[95] = 63;
function E6(Y) {
  var X = Y.length;
  if (X % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var ee = Y.indexOf("=");
  ee === -1 && (ee = X);
  var te = ee === X ? 0 : 4 - ee % 4;
  return [ee, te];
}
function e7(Y) {
  var X = E6(Y), ee = X[0], te = X[1];
  return (ee + te) * 3 / 4 - te;
}
function t7(Y, X, ee) {
  return (X + ee) * 3 / 4 - ee;
}
function r7(Y) {
  var X, ee = E6(Y), te = ee[0], ne = ee[1], ie = new Z9(t7(Y, te, ne)), oe = 0, se = ne > 0 ? te - 4 : te, ae;
  for (ae = 0; ae < se; ae += 4)
    X = Wn[Y.charCodeAt(ae)] << 18 | Wn[Y.charCodeAt(ae + 1)] << 12 | Wn[Y.charCodeAt(ae + 2)] << 6 | Wn[Y.charCodeAt(ae + 3)], ie[oe++] = X >> 16 & 255, ie[oe++] = X >> 8 & 255, ie[oe++] = X & 255;
  return ne === 2 && (X = Wn[Y.charCodeAt(ae)] << 2 | Wn[Y.charCodeAt(ae + 1)] >> 4, ie[oe++] = X & 255), ne === 1 && (X = Wn[Y.charCodeAt(ae)] << 10 | Wn[Y.charCodeAt(ae + 1)] << 4 | Wn[Y.charCodeAt(ae + 2)] >> 2, ie[oe++] = X >> 8 & 255, ie[oe++] = X & 255), ie;
}
function n7(Y) {
  return $i[Y >> 18 & 63] + $i[Y >> 12 & 63] + $i[Y >> 6 & 63] + $i[Y & 63];
}
function i7(Y, X, ee) {
  for (var te, ne = [], ie = X; ie < ee; ie += 3)
    te = (Y[ie] << 16 & 16711680) + (Y[ie + 1] << 8 & 65280) + (Y[ie + 2] & 255), ne.push(n7(te));
  return ne.join("");
}
function s7(Y) {
  for (var X, ee = Y.length, te = ee % 3, ne = [], ie = 16383, oe = 0, se = ee - te; oe < se; oe += ie)
    ne.push(i7(Y, oe, oe + ie > se ? se : oe + ie));
  return te === 1 ? (X = Y[ee - 1], ne.push(
    $i[X >> 2] + $i[X << 4 & 63] + "=="
  )) : te === 2 && (X = (Y[ee - 2] << 8) + Y[ee - 1], ne.push(
    $i[X >> 10] + $i[X >> 4 & 63] + $i[X << 2 & 63] + "="
  )), ne.join("");
}
var Em = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
Em.read = function(Y, X, ee, te, ne) {
  var ie, oe, se = ne * 8 - te - 1, ae = (1 << se) - 1, ue = ae >> 1, le = -7, he = ee ? ne - 1 : 0, me = ee ? -1 : 1, ye = Y[X + he];
  for (he += me, ie = ye & (1 << -le) - 1, ye >>= -le, le += se; le > 0; ie = ie * 256 + Y[X + he], he += me, le -= 8)
    ;
  for (oe = ie & (1 << -le) - 1, ie >>= -le, le += te; le > 0; oe = oe * 256 + Y[X + he], he += me, le -= 8)
    ;
  if (ie === 0)
    ie = 1 - ue;
  else {
    if (ie === ae)
      return oe ? NaN : (ye ? -1 : 1) * (1 / 0);
    oe = oe + Math.pow(2, te), ie = ie - ue;
  }
  return (ye ? -1 : 1) * oe * Math.pow(2, ie - te);
};
Em.write = function(Y, X, ee, te, ne, ie) {
  var oe, se, ae, ue = ie * 8 - ne - 1, le = (1 << ue) - 1, he = le >> 1, me = ne === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, ye = te ? 0 : ie - 1, we = te ? 1 : -1, Ee = X < 0 || X === 0 && 1 / X < 0 ? 1 : 0;
  for (X = Math.abs(X), isNaN(X) || X === 1 / 0 ? (se = isNaN(X) ? 1 : 0, oe = le) : (oe = Math.floor(Math.log(X) / Math.LN2), X * (ae = Math.pow(2, -oe)) < 1 && (oe--, ae *= 2), oe + he >= 1 ? X += me / ae : X += me * Math.pow(2, 1 - he), X * ae >= 2 && (oe++, ae /= 2), oe + he >= le ? (se = 0, oe = le) : oe + he >= 1 ? (se = (X * ae - 1) * Math.pow(2, ne), oe = oe + he) : (se = X * Math.pow(2, he - 1) * Math.pow(2, ne), oe = 0)); ne >= 8; Y[ee + ye] = se & 255, ye += we, se /= 256, ne -= 8)
    ;
  for (oe = oe << ne | se, ue += ne; ue > 0; Y[ee + ye] = oe & 255, ye += we, oe /= 256, ue -= 8)
    ;
  Y[ee + ye - we] |= Ee * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(Y) {
  const X = Nd, ee = Em, te = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  Y.Buffer = se, Y.SlowBuffer = Me, Y.INSPECT_MAX_BYTES = 50;
  const ne = 2147483647;
  Y.kMaxLength = ne, se.TYPED_ARRAY_SUPPORT = ie(), !se.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
    "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
  );
  function ie() {
    try {
      const Ye = new Uint8Array(1), lt = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(lt, Uint8Array.prototype), Object.setPrototypeOf(Ye, lt), Ye.foo() === 42;
    } catch {
      return !1;
    }
  }
  Object.defineProperty(se.prototype, "parent", {
    enumerable: !0,
    get: function() {
      if (se.isBuffer(this))
        return this.buffer;
    }
  }), Object.defineProperty(se.prototype, "offset", {
    enumerable: !0,
    get: function() {
      if (se.isBuffer(this))
        return this.byteOffset;
    }
  });
  function oe(Ye) {
    if (Ye > ne)
      throw new RangeError('The value "' + Ye + '" is invalid for option "size"');
    const lt = new Uint8Array(Ye);
    return Object.setPrototypeOf(lt, se.prototype), lt;
  }
  function se(Ye, lt, pt) {
    if (typeof Ye == "number") {
      if (typeof lt == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return he(Ye);
    }
    return ae(Ye, lt, pt);
  }
  se.poolSize = 8192;
  function ae(Ye, lt, pt) {
    if (typeof Ye == "string")
      return me(Ye, lt);
    if (ArrayBuffer.isView(Ye))
      return we(Ye);
    if (Ye == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof Ye
      );
    if (oX(Ye, ArrayBuffer) || Ye && oX(Ye.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (oX(Ye, SharedArrayBuffer) || Ye && oX(Ye.buffer, SharedArrayBuffer)))
      return Ee(Ye, lt, pt);
    if (typeof Ye == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    const He = Ye.valueOf && Ye.valueOf();
    if (He != null && He !== Ye)
      return se.from(He, lt, pt);
    const Je = Re(Ye);
    if (Je)
      return Je;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof Ye[Symbol.toPrimitive] == "function")
      return se.from(Ye[Symbol.toPrimitive]("string"), lt, pt);
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof Ye
    );
  }
  se.from = function(Ye, lt, pt) {
    return ae(Ye, lt, pt);
  }, Object.setPrototypeOf(se.prototype, Uint8Array.prototype), Object.setPrototypeOf(se, Uint8Array);
  function ue(Ye) {
    if (typeof Ye != "number")
      throw new TypeError('"size" argument must be of type number');
    if (Ye < 0)
      throw new RangeError('The value "' + Ye + '" is invalid for option "size"');
  }
  function le(Ye, lt, pt) {
    return ue(Ye), Ye <= 0 ? oe(Ye) : lt !== void 0 ? typeof pt == "string" ? oe(Ye).fill(lt, pt) : oe(Ye).fill(lt) : oe(Ye);
  }
  se.alloc = function(Ye, lt, pt) {
    return le(Ye, lt, pt);
  };
  function he(Ye) {
    return ue(Ye), oe(Ye < 0 ? 0 : Ue(Ye) | 0);
  }
  se.allocUnsafe = function(Ye) {
    return he(Ye);
  }, se.allocUnsafeSlow = function(Ye) {
    return he(Ye);
  };
  function me(Ye, lt) {
    if ((typeof lt != "string" || lt === "") && (lt = "utf8"), !se.isEncoding(lt))
      throw new TypeError("Unknown encoding: " + lt);
    const pt = De(Ye, lt) | 0;
    let He = oe(pt);
    const Je = He.write(Ye, lt);
    return Je !== pt && (He = He.slice(0, Je)), He;
  }
  function ye(Ye) {
    const lt = Ye.length < 0 ? 0 : Ue(Ye.length) | 0, pt = oe(lt);
    for (let He = 0; He < lt; He += 1)
      pt[He] = Ye[He] & 255;
    return pt;
  }
  function we(Ye) {
    if (oX(Ye, Uint8Array)) {
      const lt = new Uint8Array(Ye);
      return Ee(lt.buffer, lt.byteOffset, lt.byteLength);
    }
    return ye(Ye);
  }
  function Ee(Ye, lt, pt) {
    if (lt < 0 || Ye.byteLength < lt)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (Ye.byteLength < lt + (pt || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let He;
    return lt === void 0 && pt === void 0 ? He = new Uint8Array(Ye) : pt === void 0 ? He = new Uint8Array(Ye, lt) : He = new Uint8Array(Ye, lt, pt), Object.setPrototypeOf(He, se.prototype), He;
  }
  function Re(Ye) {
    if (se.isBuffer(Ye)) {
      const lt = Ue(Ye.length) | 0, pt = oe(lt);
      return pt.length === 0 || Ye.copy(pt, 0, 0, lt), pt;
    }
    if (Ye.length !== void 0)
      return typeof Ye.length != "number" || Nn(Ye.length) ? oe(0) : ye(Ye);
    if (Ye.type === "Buffer" && Array.isArray(Ye.data))
      return ye(Ye.data);
  }
  function Ue(Ye) {
    if (Ye >= ne)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + ne.toString(16) + " bytes");
    return Ye | 0;
  }
  function Me(Ye) {
    return +Ye != Ye && (Ye = 0), se.alloc(+Ye);
  }
  se.isBuffer = function(Ye) {
    return Ye != null && Ye._isBuffer === !0 && Ye !== se.prototype;
  }, se.compare = function(Ye, lt) {
    if (oX(Ye, Uint8Array) && (Ye = se.from(Ye, Ye.offset, Ye.byteLength)), oX(lt, Uint8Array) && (lt = se.from(lt, lt.offset, lt.byteLength)), !se.isBuffer(Ye) || !se.isBuffer(lt))
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (Ye === lt)
      return 0;
    let pt = Ye.length, He = lt.length;
    for (let Je = 0, st = Math.min(pt, He); Je < st; ++Je)
      if (Ye[Je] !== lt[Je]) {
        pt = Ye[Je], He = lt[Je];
        break;
      }
    return pt < He ? -1 : He < pt ? 1 : 0;
  }, se.isEncoding = function(Ye) {
    switch (String(Ye).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  }, se.concat = function(Ye, lt) {
    if (!Array.isArray(Ye))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (Ye.length === 0)
      return se.alloc(0);
    let pt;
    if (lt === void 0)
      for (lt = 0, pt = 0; pt < Ye.length; ++pt)
        lt += Ye[pt].length;
    const He = se.allocUnsafe(lt);
    let Je = 0;
    for (pt = 0; pt < Ye.length; ++pt) {
      let st = Ye[pt];
      if (oX(st, Uint8Array))
        Je + st.length > He.length ? (se.isBuffer(st) || (st = se.from(st)), st.copy(He, Je)) : Uint8Array.prototype.set.call(
          He,
          st,
          Je
        );
      else if (se.isBuffer(st))
        st.copy(He, Je);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      Je += st.length;
    }
    return He;
  };
  function De(Ye, lt) {
    if (se.isBuffer(Ye))
      return Ye.length;
    if (ArrayBuffer.isView(Ye) || oX(Ye, ArrayBuffer))
      return Ye.byteLength;
    if (typeof Ye != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof Ye
      );
    const pt = Ye.length, He = arguments.length > 2 && arguments[2] === !0;
    if (!He && pt === 0)
      return 0;
    let Je = !1;
    for (; ; )
      switch (lt) {
        case "ascii":
        case "latin1":
        case "binary":
          return pt;
        case "utf8":
        case "utf-8":
          return an(Ye).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return pt * 2;
        case "hex":
          return pt >>> 1;
        case "base64":
          return w_(Ye).length;
        default:
          if (Je)
            return He ? -1 : an(Ye).length;
          lt = ("" + lt).toLowerCase(), Je = !0;
      }
  }
  se.byteLength = De;
  function Fe(Ye, lt, pt) {
    let He = !1;
    if ((lt === void 0 || lt < 0) && (lt = 0), lt > this.length || ((pt === void 0 || pt > this.length) && (pt = this.length), pt <= 0) || (pt >>>= 0, lt >>>= 0, pt <= lt))
      return "";
    for (Ye || (Ye = "utf8"); ; )
      switch (Ye) {
        case "hex":
          return Se(this, lt, pt);
        case "utf8":
        case "utf-8":
          return de(this, lt, pt);
        case "ascii":
          return Ce(this, lt, pt);
        case "latin1":
        case "binary":
          return Pe(this, lt, pt);
        case "base64":
          return fe(this, lt, pt);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ke(this, lt, pt);
        default:
          if (He)
            throw new TypeError("Unknown encoding: " + Ye);
          Ye = (Ye + "").toLowerCase(), He = !0;
      }
  }
  se.prototype._isBuffer = !0;
  function Ke(Ye, lt, pt) {
    const He = Ye[lt];
    Ye[lt] = Ye[pt], Ye[pt] = He;
  }
  se.prototype.swap16 = function() {
    const Ye = this.length;
    if (Ye % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let lt = 0; lt < Ye; lt += 2)
      Ke(this, lt, lt + 1);
    return this;
  }, se.prototype.swap32 = function() {
    const Ye = this.length;
    if (Ye % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let lt = 0; lt < Ye; lt += 4)
      Ke(this, lt, lt + 3), Ke(this, lt + 1, lt + 2);
    return this;
  }, se.prototype.swap64 = function() {
    const Ye = this.length;
    if (Ye % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let lt = 0; lt < Ye; lt += 8)
      Ke(this, lt, lt + 7), Ke(this, lt + 1, lt + 6), Ke(this, lt + 2, lt + 5), Ke(this, lt + 3, lt + 4);
    return this;
  }, se.prototype.toString = function() {
    const Ye = this.length;
    return Ye === 0 ? "" : arguments.length === 0 ? de(this, 0, Ye) : Fe.apply(this, arguments);
  }, se.prototype.toLocaleString = se.prototype.toString, se.prototype.equals = function(Ye) {
    if (!se.isBuffer(Ye))
      throw new TypeError("Argument must be a Buffer");
    return this === Ye ? !0 : se.compare(this, Ye) === 0;
  }, se.prototype.inspect = function() {
    let Ye = "";
    const lt = Y.INSPECT_MAX_BYTES;
    return Ye = this.toString("hex", 0, lt).replace(/(.{2})/g, "$1 ").trim(), this.length > lt && (Ye += " ... "), "<Buffer " + Ye + ">";
  }, te && (se.prototype[te] = se.prototype.inspect), se.prototype.compare = function(Ye, lt, pt, He, Je) {
    if (oX(Ye, Uint8Array) && (Ye = se.from(Ye, Ye.offset, Ye.byteLength)), !se.isBuffer(Ye))
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof Ye
      );
    if (lt === void 0 && (lt = 0), pt === void 0 && (pt = Ye ? Ye.length : 0), He === void 0 && (He = 0), Je === void 0 && (Je = this.length), lt < 0 || pt > Ye.length || He < 0 || Je > this.length)
      throw new RangeError("out of range index");
    if (He >= Je && lt >= pt)
      return 0;
    if (He >= Je)
      return -1;
    if (lt >= pt)
      return 1;
    if (lt >>>= 0, pt >>>= 0, He >>>= 0, Je >>>= 0, this === Ye)
      return 0;
    let st = Je - He, gt = pt - lt;
    const kt = Math.min(st, gt), Vt = this.slice(He, Je), Lr = Ye.slice(lt, pt);
    for (let Ci = 0; Ci < kt; ++Ci)
      if (Vt[Ci] !== Lr[Ci]) {
        st = Vt[Ci], gt = Lr[Ci];
        break;
      }
    return st < gt ? -1 : gt < st ? 1 : 0;
  };
  function tt(Ye, lt, pt, He, Je) {
    if (Ye.length === 0)
      return -1;
    if (typeof pt == "string" ? (He = pt, pt = 0) : pt > 2147483647 ? pt = 2147483647 : pt < -2147483648 && (pt = -2147483648), pt = +pt, Nn(pt) && (pt = Je ? 0 : Ye.length - 1), pt < 0 && (pt = Ye.length + pt), pt >= Ye.length) {
      if (Je)
        return -1;
      pt = Ye.length - 1;
    } else if (pt < 0)
      if (Je)
        pt = 0;
      else
        return -1;
    if (typeof lt == "string" && (lt = se.from(lt, He)), se.isBuffer(lt))
      return lt.length === 0 ? -1 : rt(Ye, lt, pt, He, Je);
    if (typeof lt == "number")
      return lt = lt & 255, typeof Uint8Array.prototype.indexOf == "function" ? Je ? Uint8Array.prototype.indexOf.call(Ye, lt, pt) : Uint8Array.prototype.lastIndexOf.call(Ye, lt, pt) : rt(Ye, [lt], pt, He, Je);
    throw new TypeError("val must be string, number or Buffer");
  }
  function rt(Ye, lt, pt, He, Je) {
    let st = 1, gt = Ye.length, kt = lt.length;
    if (He !== void 0 && (He = String(He).toLowerCase(), He === "ucs2" || He === "ucs-2" || He === "utf16le" || He === "utf-16le")) {
      if (Ye.length < 2 || lt.length < 2)
        return -1;
      st = 2, gt /= 2, kt /= 2, pt /= 2;
    }
    function Vt(Ci, Qr) {
      return st === 1 ? Ci[Qr] : Ci.readUInt16BE(Qr * st);
    }
    let Lr;
    if (Je) {
      let Ci = -1;
      for (Lr = pt; Lr < gt; Lr++)
        if (Vt(Ye, Lr) === Vt(lt, Ci === -1 ? 0 : Lr - Ci)) {
          if (Ci === -1 && (Ci = Lr), Lr - Ci + 1 === kt)
            return Ci * st;
        } else
          Ci !== -1 && (Lr -= Lr - Ci), Ci = -1;
    } else
      for (pt + kt > gt && (pt = gt - kt), Lr = pt; Lr >= 0; Lr--) {
        let Ci = !0;
        for (let Qr = 0; Qr < kt; Qr++)
          if (Vt(Ye, Lr + Qr) !== Vt(lt, Qr)) {
            Ci = !1;
            break;
          }
        if (Ci)
          return Lr;
      }
    return -1;
  }
  se.prototype.includes = function(Ye, lt, pt) {
    return this.indexOf(Ye, lt, pt) !== -1;
  }, se.prototype.indexOf = function(Ye, lt, pt) {
    return tt(this, Ye, lt, pt, !0);
  }, se.prototype.lastIndexOf = function(Ye, lt, pt) {
    return tt(this, Ye, lt, pt, !1);
  };
  function it(Ye, lt, pt, He) {
    pt = Number(pt) || 0;
    const Je = Ye.length - pt;
    He ? (He = Number(He), He > Je && (He = Je)) : He = Je;
    const st = lt.length;
    He > st / 2 && (He = st / 2);
    let gt;
    for (gt = 0; gt < He; ++gt) {
      const kt = parseInt(lt.substr(gt * 2, 2), 16);
      if (Nn(kt))
        return gt;
      Ye[pt + gt] = kt;
    }
    return gt;
  }
  function _t(Ye, lt, pt, He) {
    return hX(an(lt, Ye.length - pt), Ye, pt, He);
  }
  function Dt(Ye, lt, pt, He) {
    return hX(wX(lt), Ye, pt, He);
  }
  function je(Ye, lt, pt, He) {
    return hX(w_(lt), Ye, pt, He);
  }
  function ze(Ye, lt, pt, He) {
    return hX(Ct(lt, Ye.length - pt), Ye, pt, He);
  }
  se.prototype.write = function(Ye, lt, pt, He) {
    if (lt === void 0)
      He = "utf8", pt = this.length, lt = 0;
    else if (pt === void 0 && typeof lt == "string")
      He = lt, pt = this.length, lt = 0;
    else if (isFinite(lt))
      lt = lt >>> 0, isFinite(pt) ? (pt = pt >>> 0, He === void 0 && (He = "utf8")) : (He = pt, pt = void 0);
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    const Je = this.length - lt;
    if ((pt === void 0 || pt > Je) && (pt = Je), Ye.length > 0 && (pt < 0 || lt < 0) || lt > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    He || (He = "utf8");
    let st = !1;
    for (; ; )
      switch (He) {
        case "hex":
          return it(this, Ye, lt, pt);
        case "utf8":
        case "utf-8":
          return _t(this, Ye, lt, pt);
        case "ascii":
        case "latin1":
        case "binary":
          return Dt(this, Ye, lt, pt);
        case "base64":
          return je(this, Ye, lt, pt);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ze(this, Ye, lt, pt);
        default:
          if (st)
            throw new TypeError("Unknown encoding: " + He);
          He = ("" + He).toLowerCase(), st = !0;
      }
  }, se.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function fe(Ye, lt, pt) {
    return lt === 0 && pt === Ye.length ? X.fromByteArray(Ye) : X.fromByteArray(Ye.slice(lt, pt));
  }
  function de(Ye, lt, pt) {
    pt = Math.min(Ye.length, pt);
    const He = [];
    let Je = lt;
    for (; Je < pt; ) {
      const st = Ye[Je];
      let gt = null, kt = st > 239 ? 4 : st > 223 ? 3 : st > 191 ? 2 : 1;
      if (Je + kt <= pt) {
        let Vt, Lr, Ci, Qr;
        switch (kt) {
          case 1:
            st < 128 && (gt = st);
            break;
          case 2:
            Vt = Ye[Je + 1], (Vt & 192) === 128 && (Qr = (st & 31) << 6 | Vt & 63, Qr > 127 && (gt = Qr));
            break;
          case 3:
            Vt = Ye[Je + 1], Lr = Ye[Je + 2], (Vt & 192) === 128 && (Lr & 192) === 128 && (Qr = (st & 15) << 12 | (Vt & 63) << 6 | Lr & 63, Qr > 2047 && (Qr < 55296 || Qr > 57343) && (gt = Qr));
            break;
          case 4:
            Vt = Ye[Je + 1], Lr = Ye[Je + 2], Ci = Ye[Je + 3], (Vt & 192) === 128 && (Lr & 192) === 128 && (Ci & 192) === 128 && (Qr = (st & 15) << 18 | (Vt & 63) << 12 | (Lr & 63) << 6 | Ci & 63, Qr > 65535 && Qr < 1114112 && (gt = Qr));
        }
      }
      gt === null ? (gt = 65533, kt = 1) : gt > 65535 && (gt -= 65536, He.push(gt >>> 10 & 1023 | 55296), gt = 56320 | gt & 1023), He.push(gt), Je += kt;
    }
    return Te(He);
  }
  const be = 4096;
  function Te(Ye) {
    const lt = Ye.length;
    if (lt <= be)
      return String.fromCharCode.apply(String, Ye);
    let pt = "", He = 0;
    for (; He < lt; )
      pt += String.fromCharCode.apply(
        String,
        Ye.slice(He, He += be)
      );
    return pt;
  }
  function Ce(Ye, lt, pt) {
    let He = "";
    pt = Math.min(Ye.length, pt);
    for (let Je = lt; Je < pt; ++Je)
      He += String.fromCharCode(Ye[Je] & 127);
    return He;
  }
  function Pe(Ye, lt, pt) {
    let He = "";
    pt = Math.min(Ye.length, pt);
    for (let Je = lt; Je < pt; ++Je)
      He += String.fromCharCode(Ye[Je]);
    return He;
  }
  function Se(Ye, lt, pt) {
    const He = Ye.length;
    (!lt || lt < 0) && (lt = 0), (!pt || pt < 0 || pt > He) && (pt = He);
    let Je = "";
    for (let st = lt; st < pt; ++st)
      Je += SX[Ye[st]];
    return Je;
  }
  function ke(Ye, lt, pt) {
    const He = Ye.slice(lt, pt);
    let Je = "";
    for (let st = 0; st < He.length - 1; st += 2)
      Je += String.fromCharCode(He[st] + He[st + 1] * 256);
    return Je;
  }
  se.prototype.slice = function(Ye, lt) {
    const pt = this.length;
    Ye = ~~Ye, lt = lt === void 0 ? pt : ~~lt, Ye < 0 ? (Ye += pt, Ye < 0 && (Ye = 0)) : Ye > pt && (Ye = pt), lt < 0 ? (lt += pt, lt < 0 && (lt = 0)) : lt > pt && (lt = pt), lt < Ye && (lt = Ye);
    const He = this.subarray(Ye, lt);
    return Object.setPrototypeOf(He, se.prototype), He;
  };
  function ge(Ye, lt, pt) {
    if (Ye % 1 !== 0 || Ye < 0)
      throw new RangeError("offset is not uint");
    if (Ye + lt > pt)
      throw new RangeError("Trying to access beyond buffer length");
  }
  se.prototype.readUintLE = se.prototype.readUIntLE = function(Ye, lt, pt) {
    Ye = Ye >>> 0, lt = lt >>> 0, pt || ge(Ye, lt, this.length);
    let He = this[Ye], Je = 1, st = 0;
    for (; ++st < lt && (Je *= 256); )
      He += this[Ye + st] * Je;
    return He;
  }, se.prototype.readUintBE = se.prototype.readUIntBE = function(Ye, lt, pt) {
    Ye = Ye >>> 0, lt = lt >>> 0, pt || ge(Ye, lt, this.length);
    let He = this[Ye + --lt], Je = 1;
    for (; lt > 0 && (Je *= 256); )
      He += this[Ye + --lt] * Je;
    return He;
  }, se.prototype.readUint8 = se.prototype.readUInt8 = function(Ye, lt) {
    return Ye = Ye >>> 0, lt || ge(Ye, 1, this.length), this[Ye];
  }, se.prototype.readUint16LE = se.prototype.readUInt16LE = function(Ye, lt) {
    return Ye = Ye >>> 0, lt || ge(Ye, 2, this.length), this[Ye] | this[Ye + 1] << 8;
  }, se.prototype.readUint16BE = se.prototype.readUInt16BE = function(Ye, lt) {
    return Ye = Ye >>> 0, lt || ge(Ye, 2, this.length), this[Ye] << 8 | this[Ye + 1];
  }, se.prototype.readUint32LE = se.prototype.readUInt32LE = function(Ye, lt) {
    return Ye = Ye >>> 0, lt || ge(Ye, 4, this.length), (this[Ye] | this[Ye + 1] << 8 | this[Ye + 2] << 16) + this[Ye + 3] * 16777216;
  }, se.prototype.readUint32BE = se.prototype.readUInt32BE = function(Ye, lt) {
    return Ye = Ye >>> 0, lt || ge(Ye, 4, this.length), this[Ye] * 16777216 + (this[Ye + 1] << 16 | this[Ye + 2] << 8 | this[Ye + 3]);
  }, se.prototype.readBigUInt64LE = sX(function(Ye) {
    Ye = Ye >>> 0, Ut(Ye, "offset");
    const lt = this[Ye], pt = this[Ye + 7];
    (lt === void 0 || pt === void 0) && It(Ye, this.length - 8);
    const He = lt + this[++Ye] * 2 ** 8 + this[++Ye] * 2 ** 16 + this[++Ye] * 2 ** 24, Je = this[++Ye] + this[++Ye] * 2 ** 8 + this[++Ye] * 2 ** 16 + pt * 2 ** 24;
    return BigInt(He) + (BigInt(Je) << BigInt(32));
  }), se.prototype.readBigUInt64BE = sX(function(Ye) {
    Ye = Ye >>> 0, Ut(Ye, "offset");
    const lt = this[Ye], pt = this[Ye + 7];
    (lt === void 0 || pt === void 0) && It(Ye, this.length - 8);
    const He = lt * 2 ** 24 + this[++Ye] * 2 ** 16 + this[++Ye] * 2 ** 8 + this[++Ye], Je = this[++Ye] * 2 ** 24 + this[++Ye] * 2 ** 16 + this[++Ye] * 2 ** 8 + pt;
    return (BigInt(He) << BigInt(32)) + BigInt(Je);
  }), se.prototype.readIntLE = function(Ye, lt, pt) {
    Ye = Ye >>> 0, lt = lt >>> 0, pt || ge(Ye, lt, this.length);
    let He = this[Ye], Je = 1, st = 0;
    for (; ++st < lt && (Je *= 256); )
      He += this[Ye + st] * Je;
    return Je *= 128, He >= Je && (He -= Math.pow(2, 8 * lt)), He;
  }, se.prototype.readIntBE = function(Ye, lt, pt) {
    Ye = Ye >>> 0, lt = lt >>> 0, pt || ge(Ye, lt, this.length);
    let He = lt, Je = 1, st = this[Ye + --He];
    for (; He > 0 && (Je *= 256); )
      st += this[Ye + --He] * Je;
    return Je *= 128, st >= Je && (st -= Math.pow(2, 8 * lt)), st;
  }, se.prototype.readInt8 = function(Ye, lt) {
    return Ye = Ye >>> 0, lt || ge(Ye, 1, this.length), this[Ye] & 128 ? (255 - this[Ye] + 1) * -1 : this[Ye];
  }, se.prototype.readInt16LE = function(Ye, lt) {
    Ye = Ye >>> 0, lt || ge(Ye, 2, this.length);
    const pt = this[Ye] | this[Ye + 1] << 8;
    return pt & 32768 ? pt | 4294901760 : pt;
  }, se.prototype.readInt16BE = function(Ye, lt) {
    Ye = Ye >>> 0, lt || ge(Ye, 2, this.length);
    const pt = this[Ye + 1] | this[Ye] << 8;
    return pt & 32768 ? pt | 4294901760 : pt;
  }, se.prototype.readInt32LE = function(Ye, lt) {
    return Ye = Ye >>> 0, lt || ge(Ye, 4, this.length), this[Ye] | this[Ye + 1] << 8 | this[Ye + 2] << 16 | this[Ye + 3] << 24;
  }, se.prototype.readInt32BE = function(Ye, lt) {
    return Ye = Ye >>> 0, lt || ge(Ye, 4, this.length), this[Ye] << 24 | this[Ye + 1] << 16 | this[Ye + 2] << 8 | this[Ye + 3];
  }, se.prototype.readBigInt64LE = sX(function(Ye) {
    Ye = Ye >>> 0, Ut(Ye, "offset");
    const lt = this[Ye], pt = this[Ye + 7];
    (lt === void 0 || pt === void 0) && It(Ye, this.length - 8);
    const He = this[Ye + 4] + this[Ye + 5] * 2 ** 8 + this[Ye + 6] * 2 ** 16 + (pt << 24);
    return (BigInt(He) << BigInt(32)) + BigInt(lt + this[++Ye] * 2 ** 8 + this[++Ye] * 2 ** 16 + this[++Ye] * 2 ** 24);
  }), se.prototype.readBigInt64BE = sX(function(Ye) {
    Ye = Ye >>> 0, Ut(Ye, "offset");
    const lt = this[Ye], pt = this[Ye + 7];
    (lt === void 0 || pt === void 0) && It(Ye, this.length - 8);
    const He = (lt << 24) + // Overflow
    this[++Ye] * 2 ** 16 + this[++Ye] * 2 ** 8 + this[++Ye];
    return (BigInt(He) << BigInt(32)) + BigInt(this[++Ye] * 2 ** 24 + this[++Ye] * 2 ** 16 + this[++Ye] * 2 ** 8 + pt);
  }), se.prototype.readFloatLE = function(Ye, lt) {
    return Ye = Ye >>> 0, lt || ge(Ye, 4, this.length), ee.read(this, Ye, !0, 23, 4);
  }, se.prototype.readFloatBE = function(Ye, lt) {
    return Ye = Ye >>> 0, lt || ge(Ye, 4, this.length), ee.read(this, Ye, !1, 23, 4);
  }, se.prototype.readDoubleLE = function(Ye, lt) {
    return Ye = Ye >>> 0, lt || ge(Ye, 8, this.length), ee.read(this, Ye, !0, 52, 8);
  }, se.prototype.readDoubleBE = function(Ye, lt) {
    return Ye = Ye >>> 0, lt || ge(Ye, 8, this.length), ee.read(this, Ye, !1, 52, 8);
  };
  function Ae(Ye, lt, pt, He, Je, st) {
    if (!se.isBuffer(Ye))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (lt > Je || lt < st)
      throw new RangeError('"value" argument is out of bounds');
    if (pt + He > Ye.length)
      throw new RangeError("Index out of range");
  }
  se.prototype.writeUintLE = se.prototype.writeUIntLE = function(Ye, lt, pt, He) {
    if (Ye = +Ye, lt = lt >>> 0, pt = pt >>> 0, !He) {
      const gt = Math.pow(2, 8 * pt) - 1;
      Ae(this, Ye, lt, pt, gt, 0);
    }
    let Je = 1, st = 0;
    for (this[lt] = Ye & 255; ++st < pt && (Je *= 256); )
      this[lt + st] = Ye / Je & 255;
    return lt + pt;
  }, se.prototype.writeUintBE = se.prototype.writeUIntBE = function(Ye, lt, pt, He) {
    if (Ye = +Ye, lt = lt >>> 0, pt = pt >>> 0, !He) {
      const gt = Math.pow(2, 8 * pt) - 1;
      Ae(this, Ye, lt, pt, gt, 0);
    }
    let Je = pt - 1, st = 1;
    for (this[lt + Je] = Ye & 255; --Je >= 0 && (st *= 256); )
      this[lt + Je] = Ye / st & 255;
    return lt + pt;
  }, se.prototype.writeUint8 = se.prototype.writeUInt8 = function(Ye, lt, pt) {
    return Ye = +Ye, lt = lt >>> 0, pt || Ae(this, Ye, lt, 1, 255, 0), this[lt] = Ye & 255, lt + 1;
  }, se.prototype.writeUint16LE = se.prototype.writeUInt16LE = function(Ye, lt, pt) {
    return Ye = +Ye, lt = lt >>> 0, pt || Ae(this, Ye, lt, 2, 65535, 0), this[lt] = Ye & 255, this[lt + 1] = Ye >>> 8, lt + 2;
  }, se.prototype.writeUint16BE = se.prototype.writeUInt16BE = function(Ye, lt, pt) {
    return Ye = +Ye, lt = lt >>> 0, pt || Ae(this, Ye, lt, 2, 65535, 0), this[lt] = Ye >>> 8, this[lt + 1] = Ye & 255, lt + 2;
  }, se.prototype.writeUint32LE = se.prototype.writeUInt32LE = function(Ye, lt, pt) {
    return Ye = +Ye, lt = lt >>> 0, pt || Ae(this, Ye, lt, 4, 4294967295, 0), this[lt + 3] = Ye >>> 24, this[lt + 2] = Ye >>> 16, this[lt + 1] = Ye >>> 8, this[lt] = Ye & 255, lt + 4;
  }, se.prototype.writeUint32BE = se.prototype.writeUInt32BE = function(Ye, lt, pt) {
    return Ye = +Ye, lt = lt >>> 0, pt || Ae(this, Ye, lt, 4, 4294967295, 0), this[lt] = Ye >>> 24, this[lt + 1] = Ye >>> 16, this[lt + 2] = Ye >>> 8, this[lt + 3] = Ye & 255, lt + 4;
  };
  function Ge(Ye, lt, pt, He, Je) {
    vt(lt, He, Je, Ye, pt, 7);
    let st = Number(lt & BigInt(4294967295));
    Ye[pt++] = st, st = st >> 8, Ye[pt++] = st, st = st >> 8, Ye[pt++] = st, st = st >> 8, Ye[pt++] = st;
    let gt = Number(lt >> BigInt(32) & BigInt(4294967295));
    return Ye[pt++] = gt, gt = gt >> 8, Ye[pt++] = gt, gt = gt >> 8, Ye[pt++] = gt, gt = gt >> 8, Ye[pt++] = gt, pt;
  }
  function Xe(Ye, lt, pt, He, Je) {
    vt(lt, He, Je, Ye, pt, 7);
    let st = Number(lt & BigInt(4294967295));
    Ye[pt + 7] = st, st = st >> 8, Ye[pt + 6] = st, st = st >> 8, Ye[pt + 5] = st, st = st >> 8, Ye[pt + 4] = st;
    let gt = Number(lt >> BigInt(32) & BigInt(4294967295));
    return Ye[pt + 3] = gt, gt = gt >> 8, Ye[pt + 2] = gt, gt = gt >> 8, Ye[pt + 1] = gt, gt = gt >> 8, Ye[pt] = gt, pt + 8;
  }
  se.prototype.writeBigUInt64LE = sX(function(Ye, lt = 0) {
    return Ge(this, Ye, lt, BigInt(0), BigInt("0xffffffffffffffff"));
  }), se.prototype.writeBigUInt64BE = sX(function(Ye, lt = 0) {
    return Xe(this, Ye, lt, BigInt(0), BigInt("0xffffffffffffffff"));
  }), se.prototype.writeIntLE = function(Ye, lt, pt, He) {
    if (Ye = +Ye, lt = lt >>> 0, !He) {
      const kt = Math.pow(2, 8 * pt - 1);
      Ae(this, Ye, lt, pt, kt - 1, -kt);
    }
    let Je = 0, st = 1, gt = 0;
    for (this[lt] = Ye & 255; ++Je < pt && (st *= 256); )
      Ye < 0 && gt === 0 && this[lt + Je - 1] !== 0 && (gt = 1), this[lt + Je] = (Ye / st >> 0) - gt & 255;
    return lt + pt;
  }, se.prototype.writeIntBE = function(Ye, lt, pt, He) {
    if (Ye = +Ye, lt = lt >>> 0, !He) {
      const kt = Math.pow(2, 8 * pt - 1);
      Ae(this, Ye, lt, pt, kt - 1, -kt);
    }
    let Je = pt - 1, st = 1, gt = 0;
    for (this[lt + Je] = Ye & 255; --Je >= 0 && (st *= 256); )
      Ye < 0 && gt === 0 && this[lt + Je + 1] !== 0 && (gt = 1), this[lt + Je] = (Ye / st >> 0) - gt & 255;
    return lt + pt;
  }, se.prototype.writeInt8 = function(Ye, lt, pt) {
    return Ye = +Ye, lt = lt >>> 0, pt || Ae(this, Ye, lt, 1, 127, -128), Ye < 0 && (Ye = 255 + Ye + 1), this[lt] = Ye & 255, lt + 1;
  }, se.prototype.writeInt16LE = function(Ye, lt, pt) {
    return Ye = +Ye, lt = lt >>> 0, pt || Ae(this, Ye, lt, 2, 32767, -32768), this[lt] = Ye & 255, this[lt + 1] = Ye >>> 8, lt + 2;
  }, se.prototype.writeInt16BE = function(Ye, lt, pt) {
    return Ye = +Ye, lt = lt >>> 0, pt || Ae(this, Ye, lt, 2, 32767, -32768), this[lt] = Ye >>> 8, this[lt + 1] = Ye & 255, lt + 2;
  }, se.prototype.writeInt32LE = function(Ye, lt, pt) {
    return Ye = +Ye, lt = lt >>> 0, pt || Ae(this, Ye, lt, 4, 2147483647, -2147483648), this[lt] = Ye & 255, this[lt + 1] = Ye >>> 8, this[lt + 2] = Ye >>> 16, this[lt + 3] = Ye >>> 24, lt + 4;
  }, se.prototype.writeInt32BE = function(Ye, lt, pt) {
    return Ye = +Ye, lt = lt >>> 0, pt || Ae(this, Ye, lt, 4, 2147483647, -2147483648), Ye < 0 && (Ye = 4294967295 + Ye + 1), this[lt] = Ye >>> 24, this[lt + 1] = Ye >>> 16, this[lt + 2] = Ye >>> 8, this[lt + 3] = Ye & 255, lt + 4;
  }, se.prototype.writeBigInt64LE = sX(function(Ye, lt = 0) {
    return Ge(this, Ye, lt, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), se.prototype.writeBigInt64BE = sX(function(Ye, lt = 0) {
    return Xe(this, Ye, lt, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function $e(Ye, lt, pt, He, Je, st) {
    if (pt + He > Ye.length)
      throw new RangeError("Index out of range");
    if (pt < 0)
      throw new RangeError("Index out of range");
  }
  function Ze(Ye, lt, pt, He, Je) {
    return lt = +lt, pt = pt >>> 0, Je || $e(Ye, lt, pt, 4), ee.write(Ye, lt, pt, He, 23, 4), pt + 4;
  }
  se.prototype.writeFloatLE = function(Ye, lt, pt) {
    return Ze(this, Ye, lt, !0, pt);
  }, se.prototype.writeFloatBE = function(Ye, lt, pt) {
    return Ze(this, Ye, lt, !1, pt);
  };
  function ot(Ye, lt, pt, He, Je) {
    return lt = +lt, pt = pt >>> 0, Je || $e(Ye, lt, pt, 8), ee.write(Ye, lt, pt, He, 52, 8), pt + 8;
  }
  se.prototype.writeDoubleLE = function(Ye, lt, pt) {
    return ot(this, Ye, lt, !0, pt);
  }, se.prototype.writeDoubleBE = function(Ye, lt, pt) {
    return ot(this, Ye, lt, !1, pt);
  }, se.prototype.copy = function(Ye, lt, pt, He) {
    if (!se.isBuffer(Ye))
      throw new TypeError("argument should be a Buffer");
    if (pt || (pt = 0), !He && He !== 0 && (He = this.length), lt >= Ye.length && (lt = Ye.length), lt || (lt = 0), He > 0 && He < pt && (He = pt), He === pt || Ye.length === 0 || this.length === 0)
      return 0;
    if (lt < 0)
      throw new RangeError("targetStart out of bounds");
    if (pt < 0 || pt >= this.length)
      throw new RangeError("Index out of range");
    if (He < 0)
      throw new RangeError("sourceEnd out of bounds");
    He > this.length && (He = this.length), Ye.length - lt < He - pt && (He = Ye.length - lt + pt);
    const Je = He - pt;
    return this === Ye && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(lt, pt, He) : Uint8Array.prototype.set.call(
      Ye,
      this.subarray(pt, He),
      lt
    ), Je;
  }, se.prototype.fill = function(Ye, lt, pt, He) {
    if (typeof Ye == "string") {
      if (typeof lt == "string" ? (He = lt, lt = 0, pt = this.length) : typeof pt == "string" && (He = pt, pt = this.length), He !== void 0 && typeof He != "string")
        throw new TypeError("encoding must be a string");
      if (typeof He == "string" && !se.isEncoding(He))
        throw new TypeError("Unknown encoding: " + He);
      if (Ye.length === 1) {
        const st = Ye.charCodeAt(0);
        (He === "utf8" && st < 128 || He === "latin1") && (Ye = st);
      }
    } else
      typeof Ye == "number" ? Ye = Ye & 255 : typeof Ye == "boolean" && (Ye = Number(Ye));
    if (lt < 0 || this.length < lt || this.length < pt)
      throw new RangeError("Out of range index");
    if (pt <= lt)
      return this;
    lt = lt >>> 0, pt = pt === void 0 ? this.length : pt >>> 0, Ye || (Ye = 0);
    let Je;
    if (typeof Ye == "number")
      for (Je = lt; Je < pt; ++Je)
        this[Je] = Ye;
    else {
      const st = se.isBuffer(Ye) ? Ye : se.from(Ye, He), gt = st.length;
      if (gt === 0)
        throw new TypeError('The value "' + Ye + '" is invalid for argument "value"');
      for (Je = 0; Je < pt - lt; ++Je)
        this[Je + lt] = st[Je % gt];
    }
    return this;
  };
  const ct = {};
  function At(Ye, lt, pt) {
    ct[Ye] = class extends pt {
      constructor() {
        super(), Object.defineProperty(this, "message", {
          value: lt.apply(this, arguments),
          writable: !0,
          configurable: !0
        }), this.name = `${this.name} [${Ye}]`, this.stack, delete this.name;
      }
      get code() {
        return Ye;
      }
      set code(He) {
        Object.defineProperty(this, "code", {
          configurable: !0,
          enumerable: !0,
          value: He,
          writable: !0
        });
      }
      toString() {
        return `${this.name} [${Ye}]: ${this.message}`;
      }
    };
  }
  At(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(Ye) {
      return Ye ? `${Ye} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    },
    RangeError
  ), At(
    "ERR_INVALID_ARG_TYPE",
    function(Ye, lt) {
      return `The "${Ye}" argument must be of type number. Received type ${typeof lt}`;
    },
    TypeError
  ), At(
    "ERR_OUT_OF_RANGE",
    function(Ye, lt, pt) {
      let He = `The value of "${Ye}" is out of range.`, Je = pt;
      return Number.isInteger(pt) && Math.abs(pt) > 2 ** 32 ? Je = Tt(String(pt)) : typeof pt == "bigint" && (Je = String(pt), (pt > BigInt(2) ** BigInt(32) || pt < -(BigInt(2) ** BigInt(32))) && (Je = Tt(Je)), Je += "n"), He += ` It must be ${lt}. Received ${Je}`, He;
    },
    RangeError
  );
  function Tt(Ye) {
    let lt = "", pt = Ye.length;
    const He = Ye[0] === "-" ? 1 : 0;
    for (; pt >= He + 4; pt -= 3)
      lt = `_${Ye.slice(pt - 3, pt)}${lt}`;
    return `${Ye.slice(0, pt)}${lt}`;
  }
  function dt(Ye, lt, pt) {
    Ut(lt, "offset"), (Ye[lt] === void 0 || Ye[lt + pt] === void 0) && It(lt, Ye.length - (pt + 1));
  }
  function vt(Ye, lt, pt, He, Je, st) {
    if (Ye > pt || Ye < lt) {
      const gt = typeof lt == "bigint" ? "n" : "";
      let kt;
      throw st > 3 ? lt === 0 || lt === BigInt(0) ? kt = `>= 0${gt} and < 2${gt} ** ${(st + 1) * 8}${gt}` : kt = `>= -(2${gt} ** ${(st + 1) * 8 - 1}${gt}) and < 2 ** ${(st + 1) * 8 - 1}${gt}` : kt = `>= ${lt}${gt} and <= ${pt}${gt}`, new ct.ERR_OUT_OF_RANGE("value", kt, Ye);
    }
    dt(He, Je, st);
  }
  function Ut(Ye, lt) {
    if (typeof Ye != "number")
      throw new ct.ERR_INVALID_ARG_TYPE(lt, "number", Ye);
  }
  function It(Ye, lt, pt) {
    throw Math.floor(Ye) !== Ye ? (Ut(Ye, pt), new ct.ERR_OUT_OF_RANGE(pt || "offset", "an integer", Ye)) : lt < 0 ? new ct.ERR_BUFFER_OUT_OF_BOUNDS() : new ct.ERR_OUT_OF_RANGE(
      pt || "offset",
      `>= ${pt ? 1 : 0} and <= ${lt}`,
      Ye
    );
  }
  const Er = /[^+/0-9A-Za-z-_]/g;
  function Fr(Ye) {
    if (Ye = Ye.split("=")[0], Ye = Ye.trim().replace(Er, ""), Ye.length < 2)
      return "";
    for (; Ye.length % 4 !== 0; )
      Ye = Ye + "=";
    return Ye;
  }
  function an(Ye, lt) {
    lt = lt || 1 / 0;
    let pt;
    const He = Ye.length;
    let Je = null;
    const st = [];
    for (let gt = 0; gt < He; ++gt) {
      if (pt = Ye.charCodeAt(gt), pt > 55295 && pt < 57344) {
        if (!Je) {
          if (pt > 56319) {
            (lt -= 3) > -1 && st.push(239, 191, 189);
            continue;
          } else if (gt + 1 === He) {
            (lt -= 3) > -1 && st.push(239, 191, 189);
            continue;
          }
          Je = pt;
          continue;
        }
        if (pt < 56320) {
          (lt -= 3) > -1 && st.push(239, 191, 189), Je = pt;
          continue;
        }
        pt = (Je - 55296 << 10 | pt - 56320) + 65536;
      } else
        Je && (lt -= 3) > -1 && st.push(239, 191, 189);
      if (Je = null, pt < 128) {
        if ((lt -= 1) < 0)
          break;
        st.push(pt);
      } else if (pt < 2048) {
        if ((lt -= 2) < 0)
          break;
        st.push(
          pt >> 6 | 192,
          pt & 63 | 128
        );
      } else if (pt < 65536) {
        if ((lt -= 3) < 0)
          break;
        st.push(
          pt >> 12 | 224,
          pt >> 6 & 63 | 128,
          pt & 63 | 128
        );
      } else if (pt < 1114112) {
        if ((lt -= 4) < 0)
          break;
        st.push(
          pt >> 18 | 240,
          pt >> 12 & 63 | 128,
          pt >> 6 & 63 | 128,
          pt & 63 | 128
        );
      } else
        throw new Error("Invalid code point");
    }
    return st;
  }
  function wX(Ye) {
    const lt = [];
    for (let pt = 0; pt < Ye.length; ++pt)
      lt.push(Ye.charCodeAt(pt) & 255);
    return lt;
  }
  function Ct(Ye, lt) {
    let pt, He, Je;
    const st = [];
    for (let gt = 0; gt < Ye.length && !((lt -= 2) < 0); ++gt)
      pt = Ye.charCodeAt(gt), He = pt >> 8, Je = pt % 256, st.push(Je), st.push(He);
    return st;
  }
  function w_(Ye) {
    return X.toByteArray(Fr(Ye));
  }
  function hX(Ye, lt, pt, He) {
    let Je;
    for (Je = 0; Je < He && !(Je + pt >= lt.length || Je >= Ye.length); ++Je)
      lt[Je + pt] = Ye[Je];
    return Je;
  }
  function oX(Ye, lt) {
    return Ye instanceof lt || Ye != null && Ye.constructor != null && Ye.constructor.name != null && Ye.constructor.name === lt.name;
  }
  function Nn(Ye) {
    return Ye !== Ye;
  }
  const SX = function() {
    const Ye = "0123456789abcdef", lt = new Array(256);
    for (let pt = 0; pt < 16; ++pt) {
      const He = pt * 16;
      for (let Je = 0; Je < 16; ++Je)
        lt[He + Je] = Ye[pt] + Ye[Je];
    }
    return lt;
  }();
  function sX(Ye) {
    return typeof BigInt > "u" ? nX : Ye;
  }
  function nX() {
    throw new Error("BigInt not supported");
  }
})(v6);
var kd = {}, _6 = {}, Va = {}, Md = {}, Wr = {};
Object.defineProperty(Wr, "__esModule", { value: !0 });
Wr.output = Wr.exists = Wr.hash = Wr.bytes = Wr.bool = Wr.number = void 0;
function Gl(Y) {
  if (!Number.isSafeInteger(Y) || Y < 0)
    throw new Error(`Wrong positive integer: ${Y}`);
}
Wr.number = Gl;
function A6(Y) {
  if (typeof Y != "boolean")
    throw new Error(`Expected boolean, not ${Y}`);
}
Wr.bool = A6;
function o7(Y) {
  return Y instanceof Uint8Array || Y != null && typeof Y == "object" && Y.constructor.name === "Uint8Array";
}
function _m(Y, ...X) {
  if (!o7(Y))
    throw new Error("Expected Uint8Array");
  if (X.length > 0 && !X.includes(Y.length))
    throw new Error(`Expected Uint8Array of length ${X}, not of length=${Y.length}`);
}
Wr.bytes = _m;
function S6(Y) {
  if (typeof Y != "function" || typeof Y.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  Gl(Y.outputLen), Gl(Y.blockLen);
}
Wr.hash = S6;
function T6(Y, X = !0) {
  if (Y.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (X && Y.finished)
    throw new Error("Hash#digest() has already been called");
}
Wr.exists = T6;
function I6(Y, X) {
  _m(Y);
  const ee = X.outputLen;
  if (Y.length < ee)
    throw new Error(`digestInto() expects output buffer of length at least ${ee}`);
}
Wr.output = I6;
const a7 = { number: Gl, bool: A6, bytes: _m, hash: S6, exists: T6, output: I6 };
Wr.default = a7;
var Cs = {}, Ld = {};
Object.defineProperty(Ld, "__esModule", { value: !0 });
Ld.crypto = void 0;
Ld.crypto = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
(function(Y) {
  /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  Object.defineProperty(Y, "__esModule", { value: !0 }), Y.randomBytes = Y.wrapXOFConstructorWithOpts = Y.wrapConstructorWithOpts = Y.wrapConstructor = Y.checkOpts = Y.Hash = Y.concatBytes = Y.toBytes = Y.utf8ToBytes = Y.asyncLoop = Y.nextTick = Y.hexToBytes = Y.bytesToHex = Y.isLE = Y.rotr = Y.createView = Y.u32 = Y.u8 = void 0;
  const X = Ld, ee = (it) => new Uint8Array(it.buffer, it.byteOffset, it.byteLength);
  Y.u8 = ee;
  const te = (it) => new Uint32Array(it.buffer, it.byteOffset, Math.floor(it.byteLength / 4));
  Y.u32 = te;
  function ne(it) {
    return it instanceof Uint8Array || it != null && typeof it == "object" && it.constructor.name === "Uint8Array";
  }
  const ie = (it) => new DataView(it.buffer, it.byteOffset, it.byteLength);
  Y.createView = ie;
  const oe = (it, _t) => it << 32 - _t | it >>> _t;
  if (Y.rotr = oe, Y.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68, !Y.isLE)
    throw new Error("Non little-endian hardware is not supported");
  const se = /* @__PURE__ */ Array.from({ length: 256 }, (it, _t) => _t.toString(16).padStart(2, "0"));
  function ae(it) {
    if (!ne(it))
      throw new Error("Uint8Array expected");
    let _t = "";
    for (let Dt = 0; Dt < it.length; Dt++)
      _t += se[it[Dt]];
    return _t;
  }
  Y.bytesToHex = ae;
  const ue = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
  function le(it) {
    if (it >= ue._0 && it <= ue._9)
      return it - ue._0;
    if (it >= ue._A && it <= ue._F)
      return it - (ue._A - 10);
    if (it >= ue._a && it <= ue._f)
      return it - (ue._a - 10);
  }
  function he(it) {
    if (typeof it != "string")
      throw new Error("hex string expected, got " + typeof it);
    const _t = it.length, Dt = _t / 2;
    if (_t % 2)
      throw new Error("padded hex string expected, got unpadded hex of length " + _t);
    const je = new Uint8Array(Dt);
    for (let ze = 0, fe = 0; ze < Dt; ze++, fe += 2) {
      const de = le(it.charCodeAt(fe)), be = le(it.charCodeAt(fe + 1));
      if (de === void 0 || be === void 0) {
        const Te = it[fe] + it[fe + 1];
        throw new Error('hex string expected, got non-hex character "' + Te + '" at index ' + fe);
      }
      je[ze] = de * 16 + be;
    }
    return je;
  }
  Y.hexToBytes = he;
  const me = async () => {
  };
  Y.nextTick = me;
  async function ye(it, _t, Dt) {
    let je = Date.now();
    for (let ze = 0; ze < it; ze++) {
      Dt(ze);
      const fe = Date.now() - je;
      fe >= 0 && fe < _t || (await (0, Y.nextTick)(), je += fe);
    }
  }
  Y.asyncLoop = ye;
  function we(it) {
    if (typeof it != "string")
      throw new Error(`utf8ToBytes expected string, got ${typeof it}`);
    return new Uint8Array(new TextEncoder().encode(it));
  }
  Y.utf8ToBytes = we;
  function Ee(it) {
    if (typeof it == "string" && (it = we(it)), !ne(it))
      throw new Error(`expected Uint8Array, got ${typeof it}`);
    return it;
  }
  Y.toBytes = Ee;
  function Re(...it) {
    let _t = 0;
    for (let je = 0; je < it.length; je++) {
      const ze = it[je];
      if (!ne(ze))
        throw new Error("Uint8Array expected");
      _t += ze.length;
    }
    const Dt = new Uint8Array(_t);
    for (let je = 0, ze = 0; je < it.length; je++) {
      const fe = it[je];
      Dt.set(fe, ze), ze += fe.length;
    }
    return Dt;
  }
  Y.concatBytes = Re;
  class Ue {
    // Safe version that clones internal state
    clone() {
      return this._cloneInto();
    }
  }
  Y.Hash = Ue;
  const Me = {}.toString;
  function De(it, _t) {
    if (_t !== void 0 && Me.call(_t) !== "[object Object]")
      throw new Error("Options should be object or undefined");
    return Object.assign(it, _t);
  }
  Y.checkOpts = De;
  function Fe(it) {
    const _t = (je) => it().update(Ee(je)).digest(), Dt = it();
    return _t.outputLen = Dt.outputLen, _t.blockLen = Dt.blockLen, _t.create = () => it(), _t;
  }
  Y.wrapConstructor = Fe;
  function Ke(it) {
    const _t = (je, ze) => it(ze).update(Ee(je)).digest(), Dt = it({});
    return _t.outputLen = Dt.outputLen, _t.blockLen = Dt.blockLen, _t.create = (je) => it(je), _t;
  }
  Y.wrapConstructorWithOpts = Ke;
  function tt(it) {
    const _t = (je, ze) => it(ze).update(Ee(je)).digest(), Dt = it({});
    return _t.outputLen = Dt.outputLen, _t.blockLen = Dt.blockLen, _t.create = (je) => it(je), _t;
  }
  Y.wrapXOFConstructorWithOpts = tt;
  function rt(it = 32) {
    if (X.crypto && typeof X.crypto.getRandomValues == "function")
      return X.crypto.getRandomValues(new Uint8Array(it));
    throw new Error("crypto.getRandomValues must be defined");
  }
  Y.randomBytes = rt;
})(Cs);
Object.defineProperty(Md, "__esModule", { value: !0 });
Md.SHA2 = void 0;
const lh = Wr, Gc = Cs;
function c7(Y, X, ee, te) {
  if (typeof Y.setBigUint64 == "function")
    return Y.setBigUint64(X, ee, te);
  const ne = BigInt(32), ie = BigInt(4294967295), oe = Number(ee >> ne & ie), se = Number(ee & ie), ae = te ? 4 : 0, ue = te ? 0 : 4;
  Y.setUint32(X + ae, oe, te), Y.setUint32(X + ue, se, te);
}
class u7 extends Gc.Hash {
  constructor(X, ee, te, ne) {
    super(), this.blockLen = X, this.outputLen = ee, this.padOffset = te, this.isLE = ne, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(X), this.view = (0, Gc.createView)(this.buffer);
  }
  update(X) {
    (0, lh.exists)(this);
    const { view: ee, buffer: te, blockLen: ne } = this;
    X = (0, Gc.toBytes)(X);
    const ie = X.length;
    for (let oe = 0; oe < ie; ) {
      const se = Math.min(ne - this.pos, ie - oe);
      if (se === ne) {
        const ae = (0, Gc.createView)(X);
        for (; ne <= ie - oe; oe += ne)
          this.process(ae, oe);
        continue;
      }
      te.set(X.subarray(oe, oe + se), this.pos), this.pos += se, oe += se, this.pos === ne && (this.process(ee, 0), this.pos = 0);
    }
    return this.length += X.length, this.roundClean(), this;
  }
  digestInto(X) {
    (0, lh.exists)(this), (0, lh.output)(X, this), this.finished = !0;
    const { buffer: ee, view: te, blockLen: ne, isLE: ie } = this;
    let { pos: oe } = this;
    ee[oe++] = 128, this.buffer.subarray(oe).fill(0), this.padOffset > ne - oe && (this.process(te, 0), oe = 0);
    for (let he = oe; he < ne; he++)
      ee[he] = 0;
    c7(te, ne - 8, BigInt(this.length * 8), ie), this.process(te, 0);
    const se = (0, Gc.createView)(X), ae = this.outputLen;
    if (ae % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const ue = ae / 4, le = this.get();
    if (ue > le.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let he = 0; he < ue; he++)
      se.setUint32(4 * he, le[he], ie);
  }
  digest() {
    const { buffer: X, outputLen: ee } = this;
    this.digestInto(X);
    const te = X.slice(0, ee);
    return this.destroy(), te;
  }
  _cloneInto(X) {
    X || (X = new this.constructor()), X.set(...this.get());
    const { blockLen: ee, buffer: te, length: ne, finished: ie, destroyed: oe, pos: se } = this;
    return X.length = ne, X.pos = se, X.finished = ie, X.destroyed = oe, ne % ee && X.buffer.set(te), X;
  }
}
Md.SHA2 = u7;
Object.defineProperty(Va, "__esModule", { value: !0 });
Va.sha224 = Va.sha256 = void 0;
const f7 = Md, Vn = Cs, l7 = (Y, X, ee) => Y & X ^ ~Y & ee, d7 = (Y, X, ee) => Y & X ^ Y & ee ^ X & ee, h7 = /* @__PURE__ */ new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), Hs = /* @__PURE__ */ new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), zs = /* @__PURE__ */ new Uint32Array(64);
class R6 extends f7.SHA2 {
  constructor() {
    super(64, 32, 8, !1), this.A = Hs[0] | 0, this.B = Hs[1] | 0, this.C = Hs[2] | 0, this.D = Hs[3] | 0, this.E = Hs[4] | 0, this.F = Hs[5] | 0, this.G = Hs[6] | 0, this.H = Hs[7] | 0;
  }
  get() {
    const { A: X, B: ee, C: te, D: ne, E: ie, F: oe, G: se, H: ae } = this;
    return [X, ee, te, ne, ie, oe, se, ae];
  }
  // prettier-ignore
  set(X, ee, te, ne, ie, oe, se, ae) {
    this.A = X | 0, this.B = ee | 0, this.C = te | 0, this.D = ne | 0, this.E = ie | 0, this.F = oe | 0, this.G = se | 0, this.H = ae | 0;
  }
  process(X, ee) {
    for (let he = 0; he < 16; he++, ee += 4)
      zs[he] = X.getUint32(ee, !1);
    for (let he = 16; he < 64; he++) {
      const me = zs[he - 15], ye = zs[he - 2], we = (0, Vn.rotr)(me, 7) ^ (0, Vn.rotr)(me, 18) ^ me >>> 3, Ee = (0, Vn.rotr)(ye, 17) ^ (0, Vn.rotr)(ye, 19) ^ ye >>> 10;
      zs[he] = Ee + zs[he - 7] + we + zs[he - 16] | 0;
    }
    let { A: te, B: ne, C: ie, D: oe, E: se, F: ae, G: ue, H: le } = this;
    for (let he = 0; he < 64; he++) {
      const me = (0, Vn.rotr)(se, 6) ^ (0, Vn.rotr)(se, 11) ^ (0, Vn.rotr)(se, 25), ye = le + me + l7(se, ae, ue) + h7[he] + zs[he] | 0, we = ((0, Vn.rotr)(te, 2) ^ (0, Vn.rotr)(te, 13) ^ (0, Vn.rotr)(te, 22)) + d7(te, ne, ie) | 0;
      le = ue, ue = ae, ae = se, se = oe + ye | 0, oe = ie, ie = ne, ne = te, te = ye + we | 0;
    }
    te = te + this.A | 0, ne = ne + this.B | 0, ie = ie + this.C | 0, oe = oe + this.D | 0, se = se + this.E | 0, ae = ae + this.F | 0, ue = ue + this.G | 0, le = le + this.H | 0, this.set(te, ne, ie, oe, se, ae, ue, le);
  }
  roundClean() {
    zs.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
}
class p7 extends R6 {
  constructor() {
    super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28;
  }
}
Va.sha256 = (0, Vn.wrapConstructor)(() => new R6());
Va.sha224 = (0, Vn.wrapConstructor)(() => new p7());
var ht = {}, ft$2 = {};
Object.defineProperty(ft$2, "__esModule", { value: !0 });
ft$2.validateObject = ft$2.createHmacDrbg = ft$2.bitMask = ft$2.bitSet = ft$2.bitGet = ft$2.bitLen = ft$2.utf8ToBytes = ft$2.equalBytes = ft$2.concatBytes = ft$2.ensureBytes = ft$2.numberToVarBytesBE = ft$2.numberToBytesLE = ft$2.numberToBytesBE = ft$2.bytesToNumberLE = ft$2.bytesToNumberBE = ft$2.hexToBytes = ft$2.hexToNumber = ft$2.numberToHexUnpadded = ft$2.bytesToHex = ft$2.isBytes = void 0;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const C6 = BigInt(0), Fd = BigInt(1), g7 = BigInt(2);
function xc(Y) {
  return Y instanceof Uint8Array || Y != null && typeof Y == "object" && Y.constructor.name === "Uint8Array";
}
ft$2.isBytes = xc;
const m7 = /* @__PURE__ */ Array.from({ length: 256 }, (Y, X) => X.toString(16).padStart(2, "0"));
function Am(Y) {
  if (!xc(Y))
    throw new Error("Uint8Array expected");
  let X = "";
  for (let ee = 0; ee < Y.length; ee++)
    X += m7[Y[ee]];
  return X;
}
ft$2.bytesToHex = Am;
function P6(Y) {
  const X = Y.toString(16);
  return X.length & 1 ? `0${X}` : X;
}
ft$2.numberToHexUnpadded = P6;
function Sm(Y) {
  if (typeof Y != "string")
    throw new Error("hex string expected, got " + typeof Y);
  return BigInt(Y === "" ? "0" : `0x${Y}`);
}
ft$2.hexToNumber = Sm;
const os = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
function Yx(Y) {
  if (Y >= os._0 && Y <= os._9)
    return Y - os._0;
  if (Y >= os._A && Y <= os._F)
    return Y - (os._A - 10);
  if (Y >= os._a && Y <= os._f)
    return Y - (os._a - 10);
}
function $d(Y) {
  if (typeof Y != "string")
    throw new Error("hex string expected, got " + typeof Y);
  const X = Y.length, ee = X / 2;
  if (X % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + X);
  const te = new Uint8Array(ee);
  for (let ne = 0, ie = 0; ne < ee; ne++, ie += 2) {
    const oe = Yx(Y.charCodeAt(ie)), se = Yx(Y.charCodeAt(ie + 1));
    if (oe === void 0 || se === void 0) {
      const ae = Y[ie] + Y[ie + 1];
      throw new Error('hex string expected, got non-hex character "' + ae + '" at index ' + ie);
    }
    te[ne] = oe * 16 + se;
  }
  return te;
}
ft$2.hexToBytes = $d;
function y7(Y) {
  return Sm(Am(Y));
}
ft$2.bytesToNumberBE = y7;
function b7(Y) {
  if (!xc(Y))
    throw new Error("Uint8Array expected");
  return Sm(Am(Uint8Array.from(Y).reverse()));
}
ft$2.bytesToNumberLE = b7;
function O6(Y, X) {
  return $d(Y.toString(16).padStart(X * 2, "0"));
}
ft$2.numberToBytesBE = O6;
function x7(Y, X) {
  return O6(Y, X).reverse();
}
ft$2.numberToBytesLE = x7;
function w7(Y) {
  return $d(P6(Y));
}
ft$2.numberToVarBytesBE = w7;
function v7(Y, X, ee) {
  let te;
  if (typeof X == "string")
    try {
      te = $d(X);
    } catch (ie) {
      throw new Error(`${Y} must be valid hex string, got "${X}". Cause: ${ie}`);
    }
  else if (xc(X))
    te = Uint8Array.from(X);
  else
    throw new Error(`${Y} must be hex string or Uint8Array`);
  const ne = te.length;
  if (typeof ee == "number" && ne !== ee)
    throw new Error(`${Y} expected ${ee} bytes, got ${ne}`);
  return te;
}
ft$2.ensureBytes = v7;
function B6(...Y) {
  let X = 0;
  for (let ne = 0; ne < Y.length; ne++) {
    const ie = Y[ne];
    if (!xc(ie))
      throw new Error("Uint8Array expected");
    X += ie.length;
  }
  let ee = new Uint8Array(X), te = 0;
  for (let ne = 0; ne < Y.length; ne++) {
    const ie = Y[ne];
    ee.set(ie, te), te += ie.length;
  }
  return ee;
}
ft$2.concatBytes = B6;
function E7(Y, X) {
  if (Y.length !== X.length)
    return !1;
  let ee = 0;
  for (let te = 0; te < Y.length; te++)
    ee |= Y[te] ^ X[te];
  return ee === 0;
}
ft$2.equalBytes = E7;
function _7(Y) {
  if (typeof Y != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof Y}`);
  return new Uint8Array(new TextEncoder().encode(Y));
}
ft$2.utf8ToBytes = _7;
function A7(Y) {
  let X;
  for (X = 0; Y > C6; Y >>= Fd, X += 1)
    ;
  return X;
}
ft$2.bitLen = A7;
function S7(Y, X) {
  return Y >> BigInt(X) & Fd;
}
ft$2.bitGet = S7;
const T7 = (Y, X, ee) => Y | (ee ? Fd : C6) << BigInt(X);
ft$2.bitSet = T7;
const I7 = (Y) => (g7 << BigInt(Y - 1)) - Fd;
ft$2.bitMask = I7;
const dh$1 = (Y) => new Uint8Array(Y), Xx = (Y) => Uint8Array.from(Y);
function R7(Y, X, ee) {
  if (typeof Y != "number" || Y < 2)
    throw new Error("hashLen must be a number");
  if (typeof X != "number" || X < 2)
    throw new Error("qByteLen must be a number");
  if (typeof ee != "function")
    throw new Error("hmacFn must be a function");
  let te = dh$1(Y), ne = dh$1(Y), ie = 0;
  const oe = () => {
    te.fill(1), ne.fill(0), ie = 0;
  }, se = (...le) => ee(ne, te, ...le), ae = (le = dh$1()) => {
    ne = se(Xx([0]), le), te = se(), le.length !== 0 && (ne = se(Xx([1]), le), te = se());
  }, ue = () => {
    if (ie++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let le = 0;
    const he = [];
    for (; le < X; ) {
      te = se();
      const me = te.slice();
      he.push(me), le += te.length;
    }
    return B6(...he);
  };
  return (le, he) => {
    oe(), ae(le);
    let me;
    for (; !(me = he(ue())); )
      ae();
    return oe(), me;
  };
}
ft$2.createHmacDrbg = R7;
const C7 = {
  bigint: (Y) => typeof Y == "bigint",
  function: (Y) => typeof Y == "function",
  boolean: (Y) => typeof Y == "boolean",
  string: (Y) => typeof Y == "string",
  stringOrUint8Array: (Y) => typeof Y == "string" || xc(Y),
  isSafeInteger: (Y) => Number.isSafeInteger(Y),
  array: (Y) => Array.isArray(Y),
  field: (Y, X) => X.Fp.isValid(Y),
  hash: (Y) => typeof Y == "function" && Number.isSafeInteger(Y.outputLen)
};
function P7(Y, X, ee = {}) {
  const te = (ne, ie, oe) => {
    const se = C7[ie];
    if (typeof se != "function")
      throw new Error(`Invalid validator "${ie}", expected function`);
    const ae = Y[ne];
    if (!(oe && ae === void 0) && !se(ae, Y))
      throw new Error(`Invalid param ${String(ne)}=${ae} (${typeof ae}), expected ${ie}`);
  };
  for (const [ne, ie] of Object.entries(X))
    te(ne, ie, !1);
  for (const [ne, ie] of Object.entries(ee))
    te(ne, ie, !0);
  return Y;
}
ft$2.validateObject = P7;
Object.defineProperty(ht, "__esModule", { value: !0 });
ht.mapHashToField = ht.getMinHashLength = ht.getFieldBytesLength = ht.hashToPrivateScalar = ht.FpSqrtEven = ht.FpSqrtOdd = ht.Field = ht.nLength = ht.FpIsSquare = ht.FpDiv = ht.FpInvertBatch = ht.FpPow = ht.validateField = ht.isNegativeLE = ht.FpSqrt = ht.tonelliShanks = ht.invert = ht.pow2 = ht.pow = ht.mod = void 0;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const Un = ft$2, Kr = BigInt(0), dr = BigInt(1), Xs = BigInt(2), O7 = BigInt(3), Wp = BigInt(4), Zx = BigInt(5), Qx = BigInt(8);
BigInt(9);
BigInt(16);
function Fn(Y, X) {
  const ee = Y % X;
  return ee >= Kr ? ee : X + ee;
}
ht.mod = Fn;
function N6(Y, X, ee) {
  if (ee <= Kr || X < Kr)
    throw new Error("Expected power/modulo > 0");
  if (ee === dr)
    return Kr;
  let te = dr;
  for (; X > Kr; )
    X & dr && (te = te * Y % ee), Y = Y * Y % ee, X >>= dr;
  return te;
}
ht.pow = N6;
function B7(Y, X, ee) {
  let te = Y;
  for (; X-- > Kr; )
    te *= te, te %= ee;
  return te;
}
ht.pow2 = B7;
function Vl(Y, X) {
  if (Y === Kr || X <= Kr)
    throw new Error(`invert: expected positive integers, got n=${Y} mod=${X}`);
  let ee = Fn(Y, X), te = X, ne = Kr, ie = dr;
  for (; ee !== Kr; ) {
    const oe = te / ee, se = te % ee, ae = ne - ie * oe;
    te = ee, ee = se, ne = ie, ie = ae;
  }
  if (te !== dr)
    throw new Error("invert: does not exist");
  return Fn(ne, X);
}
ht.invert = Vl;
function k6(Y) {
  const X = (Y - dr) / Xs;
  let ee, te, ne;
  for (ee = Y - dr, te = 0; ee % Xs === Kr; ee /= Xs, te++)
    ;
  for (ne = Xs; ne < Y && N6(ne, X, Y) !== Y - dr; ne++)
    ;
  if (te === 1) {
    const oe = (Y + dr) / Wp;
    return function(se, ae) {
      const ue = se.pow(ae, oe);
      if (!se.eql(se.sqr(ue), ae))
        throw new Error("Cannot find square root");
      return ue;
    };
  }
  const ie = (ee + dr) / Xs;
  return function(oe, se) {
    if (oe.pow(se, X) === oe.neg(oe.ONE))
      throw new Error("Cannot find square root");
    let ae = te, ue = oe.pow(oe.mul(oe.ONE, ne), ee), le = oe.pow(se, ie), he = oe.pow(se, ee);
    for (; !oe.eql(he, oe.ONE); ) {
      if (oe.eql(he, oe.ZERO))
        return oe.ZERO;
      let me = 1;
      for (let we = oe.sqr(he); me < ae && !oe.eql(we, oe.ONE); me++)
        we = oe.sqr(we);
      const ye = oe.pow(ue, dr << BigInt(ae - me - 1));
      ue = oe.sqr(ye), le = oe.mul(le, ye), he = oe.mul(he, ue), ae = me;
    }
    return le;
  };
}
ht.tonelliShanks = k6;
function M6(Y) {
  if (Y % Wp === O7) {
    const X = (Y + dr) / Wp;
    return function(ee, te) {
      const ne = ee.pow(te, X);
      if (!ee.eql(ee.sqr(ne), te))
        throw new Error("Cannot find square root");
      return ne;
    };
  }
  if (Y % Qx === Zx) {
    const X = (Y - Zx) / Qx;
    return function(ee, te) {
      const ne = ee.mul(te, Xs), ie = ee.pow(ne, X), oe = ee.mul(te, ie), se = ee.mul(ee.mul(oe, Xs), ie), ae = ee.mul(oe, ee.sub(se, ee.ONE));
      if (!ee.eql(ee.sqr(ae), te))
        throw new Error("Cannot find square root");
      return ae;
    };
  }
  return k6(Y);
}
ht.FpSqrt = M6;
const N7 = (Y, X) => (Fn(Y, X) & dr) === dr;
ht.isNegativeLE = N7;
const k7 = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function M7(Y) {
  const X = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  }, ee = k7.reduce((te, ne) => (te[ne] = "function", te), X);
  return (0, Un.validateObject)(Y, ee);
}
ht.validateField = M7;
function L6(Y, X, ee) {
  if (ee < Kr)
    throw new Error("Expected power > 0");
  if (ee === Kr)
    return Y.ONE;
  if (ee === dr)
    return X;
  let te = Y.ONE, ne = X;
  for (; ee > Kr; )
    ee & dr && (te = Y.mul(te, ne)), ne = Y.sqr(ne), ee >>= dr;
  return te;
}
ht.FpPow = L6;
function F6(Y, X) {
  const ee = new Array(X.length), te = X.reduce((ie, oe, se) => Y.is0(oe) ? ie : (ee[se] = ie, Y.mul(ie, oe)), Y.ONE), ne = Y.inv(te);
  return X.reduceRight((ie, oe, se) => Y.is0(oe) ? ie : (ee[se] = Y.mul(ie, ee[se]), Y.mul(ie, oe)), ne), ee;
}
ht.FpInvertBatch = F6;
function L7(Y, X, ee) {
  return Y.mul(X, typeof ee == "bigint" ? Vl(ee, Y.ORDER) : Y.inv(ee));
}
ht.FpDiv = L7;
function F7(Y) {
  const X = (Y.ORDER - dr) / Xs;
  return (ee) => {
    const te = Y.pow(ee, X);
    return Y.eql(te, Y.ZERO) || Y.eql(te, Y.ONE);
  };
}
ht.FpIsSquare = F7;
function Tm(Y, X) {
  const ee = X !== void 0 ? X : Y.toString(2).length, te = Math.ceil(ee / 8);
  return { nBitLength: ee, nByteLength: te };
}
ht.nLength = Tm;
function $7(Y, X, ee = !1, te = {}) {
  if (Y <= Kr)
    throw new Error(`Expected Field ORDER > 0, got ${Y}`);
  const { nBitLength: ne, nByteLength: ie } = Tm(Y, X);
  if (ie > 2048)
    throw new Error("Field lengths over 2048 bytes are not supported");
  const oe = M6(Y), se = Object.freeze({
    ORDER: Y,
    BITS: ne,
    BYTES: ie,
    MASK: (0, Un.bitMask)(ne),
    ZERO: Kr,
    ONE: dr,
    create: (ae) => Fn(ae, Y),
    isValid: (ae) => {
      if (typeof ae != "bigint")
        throw new Error(`Invalid field element: expected bigint, got ${typeof ae}`);
      return Kr <= ae && ae < Y;
    },
    is0: (ae) => ae === Kr,
    isOdd: (ae) => (ae & dr) === dr,
    neg: (ae) => Fn(-ae, Y),
    eql: (ae, ue) => ae === ue,
    sqr: (ae) => Fn(ae * ae, Y),
    add: (ae, ue) => Fn(ae + ue, Y),
    sub: (ae, ue) => Fn(ae - ue, Y),
    mul: (ae, ue) => Fn(ae * ue, Y),
    pow: (ae, ue) => L6(se, ae, ue),
    div: (ae, ue) => Fn(ae * Vl(ue, Y), Y),
    // Same as above, but doesn't normalize
    sqrN: (ae) => ae * ae,
    addN: (ae, ue) => ae + ue,
    subN: (ae, ue) => ae - ue,
    mulN: (ae, ue) => ae * ue,
    inv: (ae) => Vl(ae, Y),
    sqrt: te.sqrt || ((ae) => oe(se, ae)),
    invertBatch: (ae) => F6(se, ae),
    // TODO: do we really need constant cmov?
    // We don't have const-time bigints anyway, so probably will be not very useful
    cmov: (ae, ue, le) => le ? ue : ae,
    toBytes: (ae) => ee ? (0, Un.numberToBytesLE)(ae, ie) : (0, Un.numberToBytesBE)(ae, ie),
    fromBytes: (ae) => {
      if (ae.length !== ie)
        throw new Error(`Fp.fromBytes: expected ${ie}, got ${ae.length}`);
      return ee ? (0, Un.bytesToNumberLE)(ae) : (0, Un.bytesToNumberBE)(ae);
    }
  });
  return Object.freeze(se);
}
ht.Field = $7;
function D7(Y, X) {
  if (!Y.isOdd)
    throw new Error("Field doesn't have isOdd");
  const ee = Y.sqrt(X);
  return Y.isOdd(ee) ? ee : Y.neg(ee);
}
ht.FpSqrtOdd = D7;
function U7(Y, X) {
  if (!Y.isOdd)
    throw new Error("Field doesn't have isOdd");
  const ee = Y.sqrt(X);
  return Y.isOdd(ee) ? Y.neg(ee) : ee;
}
ht.FpSqrtEven = U7;
function j7(Y, X, ee = !1) {
  Y = (0, Un.ensureBytes)("privateHash", Y);
  const te = Y.length, ne = Tm(X).nByteLength + 8;
  if (ne < 24 || te < ne || te > 1024)
    throw new Error(`hashToPrivateScalar: expected ${ne}-1024 bytes of input, got ${te}`);
  const ie = ee ? (0, Un.bytesToNumberLE)(Y) : (0, Un.bytesToNumberBE)(Y);
  return Fn(ie, X - dr) + dr;
}
ht.hashToPrivateScalar = j7;
function Im(Y) {
  if (typeof Y != "bigint")
    throw new Error("field order must be bigint");
  const X = Y.toString(2).length;
  return Math.ceil(X / 8);
}
ht.getFieldBytesLength = Im;
function $6(Y) {
  const X = Im(Y);
  return X + Math.ceil(X / 2);
}
ht.getMinHashLength = $6;
function H7(Y, X, ee = !1) {
  const te = Y.length, ne = Im(X), ie = $6(X);
  if (te < 16 || te < ie || te > 1024)
    throw new Error(`expected ${ie}-1024 bytes of input, got ${te}`);
  const oe = ee ? (0, Un.bytesToNumberBE)(Y) : (0, Un.bytesToNumberLE)(Y), se = Fn(oe, X - dr) + dr;
  return ee ? (0, Un.numberToBytesLE)(se, ne) : (0, Un.numberToBytesBE)(se, ne);
}
ht.mapHashToField = H7;
var Rm = {}, Wa = {};
Object.defineProperty(Wa, "__esModule", { value: !0 });
Wa.validateBasic = Wa.wNAF = void 0;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const e1 = ht, z7 = ft$2, q7 = BigInt(0), hh = BigInt(1);
function G7(Y, X) {
  const ee = (ne, ie) => {
    const oe = ie.negate();
    return ne ? oe : ie;
  }, te = (ne) => {
    const ie = Math.ceil(X / ne) + 1, oe = 2 ** (ne - 1);
    return { windows: ie, windowSize: oe };
  };
  return {
    constTimeNegate: ee,
    // non-const time multiplication ladder
    unsafeLadder(ne, ie) {
      let oe = Y.ZERO, se = ne;
      for (; ie > q7; )
        ie & hh && (oe = oe.add(se)), se = se.double(), ie >>= hh;
      return oe;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(1) * (Math.ceil( / ) + 1), where:
     * -  is the window size
     * -  is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(ne, ie) {
      const { windows: oe, windowSize: se } = te(ie), ae = [];
      let ue = ne, le = ue;
      for (let he = 0; he < oe; he++) {
        le = ue, ae.push(le);
        for (let me = 1; me < se; me++)
          le = le.add(ue), ae.push(le);
        ue = le.double();
      }
      return ae;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(ne, ie, oe) {
      const { windows: se, windowSize: ae } = te(ne);
      let ue = Y.ZERO, le = Y.BASE;
      const he = BigInt(2 ** ne - 1), me = 2 ** ne, ye = BigInt(ne);
      for (let we = 0; we < se; we++) {
        const Ee = we * ae;
        let Re = Number(oe & he);
        oe >>= ye, Re > ae && (Re -= me, oe += hh);
        const Ue = Ee, Me = Ee + Math.abs(Re) - 1, De = we % 2 !== 0, Fe = Re < 0;
        Re === 0 ? le = le.add(ee(De, ie[Ue])) : ue = ue.add(ee(Fe, ie[Me]));
      }
      return { p: ue, f: le };
    },
    wNAFCached(ne, ie, oe, se) {
      const ae = ne._WINDOW_SIZE || 1;
      let ue = ie.get(ne);
      return ue || (ue = this.precomputeWindow(ne, ae), ae !== 1 && ie.set(ne, se(ue))), this.wNAF(ae, ue, oe);
    }
  };
}
Wa.wNAF = G7;
function V7(Y) {
  return (0, e1.validateField)(Y.Fp), (0, z7.validateObject)(Y, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  }), Object.freeze({
    ...(0, e1.nLength)(Y.n, Y.nBitLength),
    ...Y,
    p: Y.Fp.ORDER
  });
}
Wa.validateBasic = V7;
(function(Y) {
  Object.defineProperty(Y, "__esModule", { value: !0 }), Y.mapToCurveSimpleSWU = Y.SWUFpSqrtRatio = Y.weierstrass = Y.weierstrassPoints = Y.DER = void 0;
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  const X = ht, ee = ft$2, te = ft$2, ne = Wa;
  function ie(Me) {
    const De = (0, ne.validateBasic)(Me);
    ee.validateObject(De, {
      a: "field",
      b: "field"
    }, {
      allowedPrivateKeyLengths: "array",
      wrapPrivateKey: "boolean",
      isTorsionFree: "function",
      clearCofactor: "function",
      allowInfinityPoint: "boolean",
      fromBytes: "function",
      toBytes: "function"
    });
    const { endo: Fe, Fp: Ke, a: tt } = De;
    if (Fe) {
      if (!Ke.eql(tt, Ke.ZERO))
        throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
      if (typeof Fe != "object" || typeof Fe.beta != "bigint" || typeof Fe.splitScalar != "function")
        throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
    }
    return Object.freeze({ ...De });
  }
  const { bytesToNumberBE: oe, hexToBytes: se } = ee;
  Y.DER = {
    // asn.1 DER encoding utils
    Err: class extends Error {
      constructor(Me = "") {
        super(Me);
      }
    },
    _parseInt(Me) {
      const { Err: De } = Y.DER;
      if (Me.length < 2 || Me[0] !== 2)
        throw new De("Invalid signature integer tag");
      const Fe = Me[1], Ke = Me.subarray(2, Fe + 2);
      if (!Fe || Ke.length !== Fe)
        throw new De("Invalid signature integer: wrong length");
      if (Ke[0] & 128)
        throw new De("Invalid signature integer: negative");
      if (Ke[0] === 0 && !(Ke[1] & 128))
        throw new De("Invalid signature integer: unnecessary leading zero");
      return { d: oe(Ke), l: Me.subarray(Fe + 2) };
    },
    toSig(Me) {
      const { Err: De } = Y.DER, Fe = typeof Me == "string" ? se(Me) : Me;
      if (!ee.isBytes(Fe))
        throw new Error("ui8a expected");
      let Ke = Fe.length;
      if (Ke < 2 || Fe[0] != 48)
        throw new De("Invalid signature tag");
      if (Fe[1] !== Ke - 2)
        throw new De("Invalid signature: incorrect length");
      const { d: tt, l: rt } = Y.DER._parseInt(Fe.subarray(2)), { d: it, l: _t } = Y.DER._parseInt(rt);
      if (_t.length)
        throw new De("Invalid signature: left bytes after parsing");
      return { r: tt, s: it };
    },
    hexFromSig(Me) {
      const De = (je) => Number.parseInt(je[0], 16) & 8 ? "00" + je : je, Fe = (je) => {
        const ze = je.toString(16);
        return ze.length & 1 ? `0${ze}` : ze;
      }, Ke = De(Fe(Me.s)), tt = De(Fe(Me.r)), rt = Ke.length / 2, it = tt.length / 2, _t = Fe(rt), Dt = Fe(it);
      return `30${Fe(it + rt + 4)}02${Dt}${tt}02${_t}${Ke}`;
    }
  };
  const ae = BigInt(0), ue = BigInt(1), le = BigInt(2), he = BigInt(3), me = BigInt(4);
  function ye(Me) {
    const De = ie(Me), { Fp: Fe } = De, Ke = De.toBytes || ((Te, Ce, Pe) => {
      const Se = Ce.toAffine();
      return ee.concatBytes(Uint8Array.from([4]), Fe.toBytes(Se.x), Fe.toBytes(Se.y));
    }), tt = De.fromBytes || ((Te) => {
      const Ce = Te.subarray(1), Pe = Fe.fromBytes(Ce.subarray(0, Fe.BYTES)), Se = Fe.fromBytes(Ce.subarray(Fe.BYTES, 2 * Fe.BYTES));
      return { x: Pe, y: Se };
    });
    function rt(Te) {
      const { a: Ce, b: Pe } = De, Se = Fe.sqr(Te), ke = Fe.mul(Se, Te);
      return Fe.add(Fe.add(ke, Fe.mul(Te, Ce)), Pe);
    }
    if (!Fe.eql(Fe.sqr(De.Gy), rt(De.Gx)))
      throw new Error("bad generator point: equation left != right");
    function it(Te) {
      return typeof Te == "bigint" && ae < Te && Te < De.n;
    }
    function _t(Te) {
      if (!it(Te))
        throw new Error("Expected valid bigint: 0 < bigint < curve.n");
    }
    function Dt(Te) {
      const { allowedPrivateKeyLengths: Ce, nByteLength: Pe, wrapPrivateKey: Se, n: ke } = De;
      if (Ce && typeof Te != "bigint") {
        if (ee.isBytes(Te) && (Te = ee.bytesToHex(Te)), typeof Te != "string" || !Ce.includes(Te.length))
          throw new Error("Invalid key");
        Te = Te.padStart(Pe * 2, "0");
      }
      let ge;
      try {
        ge = typeof Te == "bigint" ? Te : ee.bytesToNumberBE((0, te.ensureBytes)("private key", Te, Pe));
      } catch {
        throw new Error(`private key must be ${Pe} bytes, hex or bigint, not ${typeof Te}`);
      }
      return Se && (ge = X.mod(ge, ke)), _t(ge), ge;
    }
    const je = /* @__PURE__ */ new Map();
    function ze(Te) {
      if (!(Te instanceof fe))
        throw new Error("ProjectivePoint expected");
    }
    class fe {
      constructor(Ce, Pe, Se) {
        if (this.px = Ce, this.py = Pe, this.pz = Se, Ce == null || !Fe.isValid(Ce))
          throw new Error("x required");
        if (Pe == null || !Fe.isValid(Pe))
          throw new Error("y required");
        if (Se == null || !Fe.isValid(Se))
          throw new Error("z required");
      }
      // Does not validate if the point is on-curve.
      // Use fromHex instead, or call assertValidity() later.
      static fromAffine(Ce) {
        const { x: Pe, y: Se } = Ce || {};
        if (!Ce || !Fe.isValid(Pe) || !Fe.isValid(Se))
          throw new Error("invalid affine point");
        if (Ce instanceof fe)
          throw new Error("projective point not allowed");
        const ke = (ge) => Fe.eql(ge, Fe.ZERO);
        return ke(Pe) && ke(Se) ? fe.ZERO : new fe(Pe, Se, Fe.ONE);
      }
      get x() {
        return this.toAffine().x;
      }
      get y() {
        return this.toAffine().y;
      }
      /**
       * Takes a bunch of Projective Points but executes only one
       * inversion on all of them. Inversion is very slow operation,
       * so this improves performance massively.
       * Optimization: converts a list of projective points to a list of identical points with Z=1.
       */
      static normalizeZ(Ce) {
        const Pe = Fe.invertBatch(Ce.map((Se) => Se.pz));
        return Ce.map((Se, ke) => Se.toAffine(Pe[ke])).map(fe.fromAffine);
      }
      /**
       * Converts hash string or Uint8Array to Point.
       * @param hex short/long ECDSA hex
       */
      static fromHex(Ce) {
        const Pe = fe.fromAffine(tt((0, te.ensureBytes)("pointHex", Ce)));
        return Pe.assertValidity(), Pe;
      }
      // Multiplies generator point by privateKey.
      static fromPrivateKey(Ce) {
        return fe.BASE.multiply(Dt(Ce));
      }
      // "Private method", don't use it directly
      _setWindowSize(Ce) {
        this._WINDOW_SIZE = Ce, je.delete(this);
      }
      // A point on curve is valid if it conforms to equation.
      assertValidity() {
        if (this.is0()) {
          if (De.allowInfinityPoint && !Fe.is0(this.py))
            return;
          throw new Error("bad point: ZERO");
        }
        const { x: Ce, y: Pe } = this.toAffine();
        if (!Fe.isValid(Ce) || !Fe.isValid(Pe))
          throw new Error("bad point: x or y not FE");
        const Se = Fe.sqr(Pe), ke = rt(Ce);
        if (!Fe.eql(Se, ke))
          throw new Error("bad point: equation left != right");
        if (!this.isTorsionFree())
          throw new Error("bad point: not in prime-order subgroup");
      }
      hasEvenY() {
        const { y: Ce } = this.toAffine();
        if (Fe.isOdd)
          return !Fe.isOdd(Ce);
        throw new Error("Field doesn't support isOdd");
      }
      /**
       * Compare one point to another.
       */
      equals(Ce) {
        ze(Ce);
        const { px: Pe, py: Se, pz: ke } = this, { px: ge, py: Ae, pz: Ge } = Ce, Xe = Fe.eql(Fe.mul(Pe, Ge), Fe.mul(ge, ke)), $e = Fe.eql(Fe.mul(Se, Ge), Fe.mul(Ae, ke));
        return Xe && $e;
      }
      /**
       * Flips point to one corresponding to (x, -y) in Affine coordinates.
       */
      negate() {
        return new fe(this.px, Fe.neg(this.py), this.pz);
      }
      // Renes-Costello-Batina exception-free doubling formula.
      // There is 30% faster Jacobian formula, but it is not complete.
      // https://eprint.iacr.org/2015/1060, algorithm 3
      // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
      double() {
        const { a: Ce, b: Pe } = De, Se = Fe.mul(Pe, he), { px: ke, py: ge, pz: Ae } = this;
        let Ge = Fe.ZERO, Xe = Fe.ZERO, $e = Fe.ZERO, Ze = Fe.mul(ke, ke), ot = Fe.mul(ge, ge), ct = Fe.mul(Ae, Ae), At = Fe.mul(ke, ge);
        return At = Fe.add(At, At), $e = Fe.mul(ke, Ae), $e = Fe.add($e, $e), Ge = Fe.mul(Ce, $e), Xe = Fe.mul(Se, ct), Xe = Fe.add(Ge, Xe), Ge = Fe.sub(ot, Xe), Xe = Fe.add(ot, Xe), Xe = Fe.mul(Ge, Xe), Ge = Fe.mul(At, Ge), $e = Fe.mul(Se, $e), ct = Fe.mul(Ce, ct), At = Fe.sub(Ze, ct), At = Fe.mul(Ce, At), At = Fe.add(At, $e), $e = Fe.add(Ze, Ze), Ze = Fe.add($e, Ze), Ze = Fe.add(Ze, ct), Ze = Fe.mul(Ze, At), Xe = Fe.add(Xe, Ze), ct = Fe.mul(ge, Ae), ct = Fe.add(ct, ct), Ze = Fe.mul(ct, At), Ge = Fe.sub(Ge, Ze), $e = Fe.mul(ct, ot), $e = Fe.add($e, $e), $e = Fe.add($e, $e), new fe(Ge, Xe, $e);
      }
      // Renes-Costello-Batina exception-free addition formula.
      // There is 30% faster Jacobian formula, but it is not complete.
      // https://eprint.iacr.org/2015/1060, algorithm 1
      // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
      add(Ce) {
        ze(Ce);
        const { px: Pe, py: Se, pz: ke } = this, { px: ge, py: Ae, pz: Ge } = Ce;
        let Xe = Fe.ZERO, $e = Fe.ZERO, Ze = Fe.ZERO;
        const ot = De.a, ct = Fe.mul(De.b, he);
        let At = Fe.mul(Pe, ge), Tt = Fe.mul(Se, Ae), dt = Fe.mul(ke, Ge), vt = Fe.add(Pe, Se), Ut = Fe.add(ge, Ae);
        vt = Fe.mul(vt, Ut), Ut = Fe.add(At, Tt), vt = Fe.sub(vt, Ut), Ut = Fe.add(Pe, ke);
        let It = Fe.add(ge, Ge);
        return Ut = Fe.mul(Ut, It), It = Fe.add(At, dt), Ut = Fe.sub(Ut, It), It = Fe.add(Se, ke), Xe = Fe.add(Ae, Ge), It = Fe.mul(It, Xe), Xe = Fe.add(Tt, dt), It = Fe.sub(It, Xe), Ze = Fe.mul(ot, Ut), Xe = Fe.mul(ct, dt), Ze = Fe.add(Xe, Ze), Xe = Fe.sub(Tt, Ze), Ze = Fe.add(Tt, Ze), $e = Fe.mul(Xe, Ze), Tt = Fe.add(At, At), Tt = Fe.add(Tt, At), dt = Fe.mul(ot, dt), Ut = Fe.mul(ct, Ut), Tt = Fe.add(Tt, dt), dt = Fe.sub(At, dt), dt = Fe.mul(ot, dt), Ut = Fe.add(Ut, dt), At = Fe.mul(Tt, Ut), $e = Fe.add($e, At), At = Fe.mul(It, Ut), Xe = Fe.mul(vt, Xe), Xe = Fe.sub(Xe, At), At = Fe.mul(vt, Tt), Ze = Fe.mul(It, Ze), Ze = Fe.add(Ze, At), new fe(Xe, $e, Ze);
      }
      subtract(Ce) {
        return this.add(Ce.negate());
      }
      is0() {
        return this.equals(fe.ZERO);
      }
      wNAF(Ce) {
        return be.wNAFCached(this, je, Ce, (Pe) => {
          const Se = Fe.invertBatch(Pe.map((ke) => ke.pz));
          return Pe.map((ke, ge) => ke.toAffine(Se[ge])).map(fe.fromAffine);
        });
      }
      /**
       * Non-constant-time multiplication. Uses double-and-add algorithm.
       * It's faster, but should only be used when you don't care about
       * an exposed private key e.g. sig verification, which works over *public* keys.
       */
      multiplyUnsafe(Ce) {
        const Pe = fe.ZERO;
        if (Ce === ae)
          return Pe;
        if (_t(Ce), Ce === ue)
          return this;
        const { endo: Se } = De;
        if (!Se)
          return be.unsafeLadder(this, Ce);
        let { k1neg: ke, k1: ge, k2neg: Ae, k2: Ge } = Se.splitScalar(Ce), Xe = Pe, $e = Pe, Ze = this;
        for (; ge > ae || Ge > ae; )
          ge & ue && (Xe = Xe.add(Ze)), Ge & ue && ($e = $e.add(Ze)), Ze = Ze.double(), ge >>= ue, Ge >>= ue;
        return ke && (Xe = Xe.negate()), Ae && ($e = $e.negate()), $e = new fe(Fe.mul($e.px, Se.beta), $e.py, $e.pz), Xe.add($e);
      }
      /**
       * Constant time multiplication.
       * Uses wNAF method. Windowed method may be 10% faster,
       * but takes 2x longer to generate and consumes 2x memory.
       * Uses precomputes when available.
       * Uses endomorphism for Koblitz curves.
       * @param scalar by which the point would be multiplied
       * @returns New point
       */
      multiply(Ce) {
        _t(Ce);
        let Pe = Ce, Se, ke;
        const { endo: ge } = De;
        if (ge) {
          const { k1neg: Ae, k1: Ge, k2neg: Xe, k2: $e } = ge.splitScalar(Pe);
          let { p: Ze, f: ot } = this.wNAF(Ge), { p: ct, f: At } = this.wNAF($e);
          Ze = be.constTimeNegate(Ae, Ze), ct = be.constTimeNegate(Xe, ct), ct = new fe(Fe.mul(ct.px, ge.beta), ct.py, ct.pz), Se = Ze.add(ct), ke = ot.add(At);
        } else {
          const { p: Ae, f: Ge } = this.wNAF(Pe);
          Se = Ae, ke = Ge;
        }
        return fe.normalizeZ([Se, ke])[0];
      }
      /**
       * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
       * Not using Strauss-Shamir trick: precomputation tables are faster.
       * The trick could be useful if both P and Q are not G (not in our case).
       * @returns non-zero affine point
       */
      multiplyAndAddUnsafe(Ce, Pe, Se) {
        const ke = fe.BASE, ge = (Ge, Xe) => Xe === ae || Xe === ue || !Ge.equals(ke) ? Ge.multiplyUnsafe(Xe) : Ge.multiply(Xe), Ae = ge(this, Pe).add(ge(Ce, Se));
        return Ae.is0() ? void 0 : Ae;
      }
      // Converts Projective point to affine (x, y) coordinates.
      // Can accept precomputed Z^-1 - for example, from invertBatch.
      // (x, y, z)  (x=x/z, y=y/z)
      toAffine(Ce) {
        const { px: Pe, py: Se, pz: ke } = this, ge = this.is0();
        Ce == null && (Ce = ge ? Fe.ONE : Fe.inv(ke));
        const Ae = Fe.mul(Pe, Ce), Ge = Fe.mul(Se, Ce), Xe = Fe.mul(ke, Ce);
        if (ge)
          return { x: Fe.ZERO, y: Fe.ZERO };
        if (!Fe.eql(Xe, Fe.ONE))
          throw new Error("invZ was invalid");
        return { x: Ae, y: Ge };
      }
      isTorsionFree() {
        const { h: Ce, isTorsionFree: Pe } = De;
        if (Ce === ue)
          return !0;
        if (Pe)
          return Pe(fe, this);
        throw new Error("isTorsionFree() has not been declared for the elliptic curve");
      }
      clearCofactor() {
        const { h: Ce, clearCofactor: Pe } = De;
        return Ce === ue ? this : Pe ? Pe(fe, this) : this.multiplyUnsafe(De.h);
      }
      toRawBytes(Ce = !0) {
        return this.assertValidity(), Ke(fe, this, Ce);
      }
      toHex(Ce = !0) {
        return ee.bytesToHex(this.toRawBytes(Ce));
      }
    }
    fe.BASE = new fe(De.Gx, De.Gy, Fe.ONE), fe.ZERO = new fe(Fe.ZERO, Fe.ONE, Fe.ZERO);
    const de = De.nBitLength, be = (0, ne.wNAF)(fe, De.endo ? Math.ceil(de / 2) : de);
    return {
      CURVE: De,
      ProjectivePoint: fe,
      normPrivateKeyToScalar: Dt,
      weierstrassEquation: rt,
      isWithinCurveOrder: it
    };
  }
  Y.weierstrassPoints = ye;
  function we(Me) {
    const De = (0, ne.validateBasic)(Me);
    return ee.validateObject(De, {
      hash: "hash",
      hmac: "function",
      randomBytes: "function"
    }, {
      bits2int: "function",
      bits2int_modN: "function",
      lowS: "boolean"
    }), Object.freeze({ lowS: !0, ...De });
  }
  function Ee(Me) {
    const De = we(Me), { Fp: Fe, n: Ke } = De, tt = Fe.BYTES + 1, rt = 2 * Fe.BYTES + 1;
    function it(Ut) {
      return ae < Ut && Ut < Fe.ORDER;
    }
    function _t(Ut) {
      return X.mod(Ut, Ke);
    }
    function Dt(Ut) {
      return X.invert(Ut, Ke);
    }
    const { ProjectivePoint: je, normPrivateKeyToScalar: ze, weierstrassEquation: fe, isWithinCurveOrder: de } = ye({
      ...De,
      toBytes(Ut, It, Er) {
        const Fr = It.toAffine(), an = Fe.toBytes(Fr.x), wX = ee.concatBytes;
        return Er ? wX(Uint8Array.from([It.hasEvenY() ? 2 : 3]), an) : wX(Uint8Array.from([4]), an, Fe.toBytes(Fr.y));
      },
      fromBytes(Ut) {
        const It = Ut.length, Er = Ut[0], Fr = Ut.subarray(1);
        if (It === tt && (Er === 2 || Er === 3)) {
          const an = ee.bytesToNumberBE(Fr);
          if (!it(an))
            throw new Error("Point is not on curve");
          const wX = fe(an);
          let Ct = Fe.sqrt(wX);
          const w_ = (Ct & ue) === ue;
          return (Er & 1) === 1 !== w_ && (Ct = Fe.neg(Ct)), { x: an, y: Ct };
        } else if (It === rt && Er === 4) {
          const an = Fe.fromBytes(Fr.subarray(0, Fe.BYTES)), wX = Fe.fromBytes(Fr.subarray(Fe.BYTES, 2 * Fe.BYTES));
          return { x: an, y: wX };
        } else
          throw new Error(`Point of length ${It} was invalid. Expected ${tt} compressed bytes or ${rt} uncompressed bytes`);
      }
    }), be = (Ut) => ee.bytesToHex(ee.numberToBytesBE(Ut, De.nByteLength));
    function Te(Ut) {
      const It = Ke >> ue;
      return Ut > It;
    }
    function Ce(Ut) {
      return Te(Ut) ? _t(-Ut) : Ut;
    }
    const Pe = (Ut, It, Er) => ee.bytesToNumberBE(Ut.slice(It, Er));
    class Se {
      constructor(It, Er, Fr) {
        this.r = It, this.s = Er, this.recovery = Fr, this.assertValidity();
      }
      // pair (bytes of r, bytes of s)
      static fromCompact(It) {
        const Er = De.nByteLength;
        return It = (0, te.ensureBytes)("compactSignature", It, Er * 2), new Se(Pe(It, 0, Er), Pe(It, Er, 2 * Er));
      }
      // DER encoded ECDSA signature
      // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
      static fromDER(It) {
        const { r: Er, s: Fr } = Y.DER.toSig((0, te.ensureBytes)("DER", It));
        return new Se(Er, Fr);
      }
      assertValidity() {
        if (!de(this.r))
          throw new Error("r must be 0 < r < CURVE.n");
        if (!de(this.s))
          throw new Error("s must be 0 < s < CURVE.n");
      }
      addRecoveryBit(It) {
        return new Se(this.r, this.s, It);
      }
      recoverPublicKey(It) {
        const { r: Er, s: Fr, recovery: an } = this, wX = $e((0, te.ensureBytes)("msgHash", It));
        if (an == null || ![0, 1, 2, 3].includes(an))
          throw new Error("recovery id invalid");
        const Ct = an === 2 || an === 3 ? Er + De.n : Er;
        if (Ct >= Fe.ORDER)
          throw new Error("recovery id 2 or 3 invalid");
        const w_ = an & 1 ? "03" : "02", hX = je.fromHex(w_ + be(Ct)), oX = Dt(Ct), Nn = _t(-wX * oX), SX = _t(Fr * oX), sX = je.BASE.multiplyAndAddUnsafe(hX, Nn, SX);
        if (!sX)
          throw new Error("point at infinify");
        return sX.assertValidity(), sX;
      }
      // Signatures should be low-s, to prevent malleability.
      hasHighS() {
        return Te(this.s);
      }
      normalizeS() {
        return this.hasHighS() ? new Se(this.r, _t(-this.s), this.recovery) : this;
      }
      // DER-encoded
      toDERRawBytes() {
        return ee.hexToBytes(this.toDERHex());
      }
      toDERHex() {
        return Y.DER.hexFromSig({ r: this.r, s: this.s });
      }
      // padded bytes of r, then padded bytes of s
      toCompactRawBytes() {
        return ee.hexToBytes(this.toCompactHex());
      }
      toCompactHex() {
        return be(this.r) + be(this.s);
      }
    }
    const ke = {
      isValidPrivateKey(Ut) {
        try {
          return ze(Ut), !0;
        } catch {
          return !1;
        }
      },
      normPrivateKeyToScalar: ze,
      /**
       * Produces cryptographically secure private key from random of size
       * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
       */
      randomPrivateKey: () => {
        const Ut = X.getMinHashLength(De.n);
        return X.mapHashToField(De.randomBytes(Ut), De.n);
      },
      /**
       * Creates precompute table for an arbitrary EC point. Makes point "cached".
       * Allows to massively speed-up `point.multiply(scalar)`.
       * @returns cached point
       * @example
       * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
       * fast.multiply(privKey); // much faster ECDH now
       */
      precompute(Ut = 8, It = je.BASE) {
        return It._setWindowSize(Ut), It.multiply(BigInt(3)), It;
      }
    };
    function ge(Ut, It = !0) {
      return je.fromPrivateKey(Ut).toRawBytes(It);
    }
    function Ae(Ut) {
      const It = ee.isBytes(Ut), Er = typeof Ut == "string", Fr = (It || Er) && Ut.length;
      return It ? Fr === tt || Fr === rt : Er ? Fr === 2 * tt || Fr === 2 * rt : Ut instanceof je;
    }
    function Ge(Ut, It, Er = !0) {
      if (Ae(Ut))
        throw new Error("first arg must be private key");
      if (!Ae(It))
        throw new Error("second arg must be public key");
      return je.fromHex(It).multiply(ze(Ut)).toRawBytes(Er);
    }
    const Xe = De.bits2int || function(Ut) {
      const It = ee.bytesToNumberBE(Ut), Er = Ut.length * 8 - De.nBitLength;
      return Er > 0 ? It >> BigInt(Er) : It;
    }, $e = De.bits2int_modN || function(Ut) {
      return _t(Xe(Ut));
    }, Ze = ee.bitMask(De.nBitLength);
    function ot(Ut) {
      if (typeof Ut != "bigint")
        throw new Error("bigint expected");
      if (!(ae <= Ut && Ut < Ze))
        throw new Error(`bigint expected < 2^${De.nBitLength}`);
      return ee.numberToBytesBE(Ut, De.nByteLength);
    }
    function ct(Ut, It, Er = At) {
      if (["recovered", "canonical"].some((Ye) => Ye in Er))
        throw new Error("sign() legacy options not supported");
      const { hash: Fr, randomBytes: an } = De;
      let { lowS: wX, prehash: Ct, extraEntropy: w_ } = Er;
      wX == null && (wX = !0), Ut = (0, te.ensureBytes)("msgHash", Ut), Ct && (Ut = (0, te.ensureBytes)("prehashed msgHash", Fr(Ut)));
      const hX = $e(Ut), oX = ze(It), Nn = [ot(oX), ot(hX)];
      if (w_ != null) {
        const Ye = w_ === !0 ? an(Fe.BYTES) : w_;
        Nn.push((0, te.ensureBytes)("extraEntropy", Ye));
      }
      const SX = ee.concatBytes(...Nn), sX = hX;
      function nX(Ye) {
        const lt = Xe(Ye);
        if (!de(lt))
          return;
        const pt = Dt(lt), He = je.BASE.multiply(lt).toAffine(), Je = _t(He.x);
        if (Je === ae)
          return;
        const st = _t(pt * _t(sX + Je * oX));
        if (st === ae)
          return;
        let gt = (He.x === Je ? 0 : 2) | Number(He.y & ue), kt = st;
        return wX && Te(st) && (kt = Ce(st), gt ^= 1), new Se(Je, kt, gt);
      }
      return { seed: SX, k2sig: nX };
    }
    const At = { lowS: De.lowS, prehash: !1 }, Tt = { lowS: De.lowS, prehash: !1 };
    function dt(Ut, It, Er = At) {
      const { seed: Fr, k2sig: an } = ct(Ut, It, Er), wX = De;
      return ee.createHmacDrbg(wX.hash.outputLen, wX.nByteLength, wX.hmac)(Fr, an);
    }
    je.BASE._setWindowSize(8);
    function vt(Ut, It, Er, Fr = Tt) {
      var an;
      const wX = Ut;
      if (It = (0, te.ensureBytes)("msgHash", It), Er = (0, te.ensureBytes)("publicKey", Er), "strict" in Fr)
        throw new Error("options.strict was renamed to lowS");
      const { lowS: Ct, prehash: w_ } = Fr;
      let hX, oX;
      try {
        if (typeof wX == "string" || ee.isBytes(wX))
          try {
            hX = Se.fromDER(wX);
          } catch (He) {
            if (!(He instanceof Y.DER.Err))
              throw He;
            hX = Se.fromCompact(wX);
          }
        else if (typeof wX == "object" && typeof wX.r == "bigint" && typeof wX.s == "bigint") {
          const { r: He, s: Je } = wX;
          hX = new Se(He, Je);
        } else
          throw new Error("PARSE");
        oX = je.fromHex(Er);
      } catch (He) {
        if (He.message === "PARSE")
          throw new Error("signature must be Signature instance, Uint8Array or hex string");
        return !1;
      }
      if (Ct && hX.hasHighS())
        return !1;
      w_ && (It = De.hash(It));
      const { r: Nn, s: SX } = hX, sX = $e(It), nX = Dt(SX), Ye = _t(sX * nX), lt = _t(Nn * nX), pt = (an = je.BASE.multiplyAndAddUnsafe(oX, Ye, lt)) == null ? void 0 : an.toAffine();
      return pt ? _t(pt.x) === Nn : !1;
    }
    return {
      CURVE: De,
      getPublicKey: ge,
      getSharedSecret: Ge,
      sign: dt,
      verify: vt,
      ProjectivePoint: je,
      Signature: Se,
      utils: ke
    };
  }
  Y.weierstrass = Ee;
  function Re(Me, De) {
    const Fe = Me.ORDER;
    let Ke = ae;
    for (let Te = Fe - ue; Te % le === ae; Te /= le)
      Ke += ue;
    const tt = Ke, rt = le << tt - ue - ue, it = rt * le, _t = (Fe - ue) / it, Dt = (_t - ue) / le, je = it - ue, ze = rt, fe = Me.pow(De, _t), de = Me.pow(De, (_t + ue) / le);
    let be = (Te, Ce) => {
      let Pe = fe, Se = Me.pow(Ce, je), ke = Me.sqr(Se);
      ke = Me.mul(ke, Ce);
      let ge = Me.mul(Te, ke);
      ge = Me.pow(ge, Dt), ge = Me.mul(ge, Se), Se = Me.mul(ge, Ce), ke = Me.mul(ge, Te);
      let Ae = Me.mul(ke, Se);
      ge = Me.pow(Ae, ze);
      let Ge = Me.eql(ge, Me.ONE);
      Se = Me.mul(ke, de), ge = Me.mul(Ae, Pe), ke = Me.cmov(Se, ke, Ge), Ae = Me.cmov(ge, Ae, Ge);
      for (let Xe = tt; Xe > ue; Xe--) {
        let $e = Xe - le;
        $e = le << $e - ue;
        let Ze = Me.pow(Ae, $e);
        const ot = Me.eql(Ze, Me.ONE);
        Se = Me.mul(ke, Pe), Pe = Me.mul(Pe, Pe), Ze = Me.mul(Ae, Pe), ke = Me.cmov(Se, ke, ot), Ae = Me.cmov(Ze, Ae, ot);
      }
      return { isValid: Ge, value: ke };
    };
    if (Me.ORDER % me === he) {
      const Te = (Me.ORDER - he) / me, Ce = Me.sqrt(Me.neg(De));
      be = (Pe, Se) => {
        let ke = Me.sqr(Se);
        const ge = Me.mul(Pe, Se);
        ke = Me.mul(ke, ge);
        let Ae = Me.pow(ke, Te);
        Ae = Me.mul(Ae, ge);
        const Ge = Me.mul(Ae, Ce), Xe = Me.mul(Me.sqr(Ae), Se), $e = Me.eql(Xe, Pe);
        let Ze = Me.cmov(Ge, Ae, $e);
        return { isValid: $e, value: Ze };
      };
    }
    return be;
  }
  Y.SWUFpSqrtRatio = Re;
  function Ue(Me, De) {
    if (X.validateField(Me), !Me.isValid(De.A) || !Me.isValid(De.B) || !Me.isValid(De.Z))
      throw new Error("mapToCurveSimpleSWU: invalid opts");
    const Fe = Re(Me, De.Z);
    if (!Me.isOdd)
      throw new Error("Fp.isOdd is not implemented!");
    return (Ke) => {
      let tt, rt, it, _t, Dt, je, ze, fe;
      tt = Me.sqr(Ke), tt = Me.mul(tt, De.Z), rt = Me.sqr(tt), rt = Me.add(rt, tt), it = Me.add(rt, Me.ONE), it = Me.mul(it, De.B), _t = Me.cmov(De.Z, Me.neg(rt), !Me.eql(rt, Me.ZERO)), _t = Me.mul(_t, De.A), rt = Me.sqr(it), je = Me.sqr(_t), Dt = Me.mul(je, De.A), rt = Me.add(rt, Dt), rt = Me.mul(rt, it), je = Me.mul(je, _t), Dt = Me.mul(je, De.B), rt = Me.add(rt, Dt), ze = Me.mul(tt, it);
      const { isValid: de, value: be } = Fe(rt, je);
      fe = Me.mul(tt, Ke), fe = Me.mul(fe, be), ze = Me.cmov(ze, it, de), fe = Me.cmov(fe, be, de);
      const Te = Me.isOdd(Ke) === Me.isOdd(fe);
      return fe = Me.cmov(Me.neg(fe), fe, Te), ze = Me.div(ze, _t), { x: ze, y: fe };
    };
  }
  Y.mapToCurveSimpleSWU = Ue;
})(Rm);
var Yn = {};
Object.defineProperty(Yn, "__esModule", { value: !0 });
Yn.createHasher = Yn.isogenyMap = Yn.hash_to_field = Yn.expand_message_xof = Yn.expand_message_xmd = void 0;
const W7 = ht, $n = ft$2;
function K7(Y) {
  if ((0, $n.isBytes)(Y))
    return Y;
  if (typeof Y == "string")
    return (0, $n.utf8ToBytes)(Y);
  throw new Error("DST must be Uint8Array or string");
}
const J7 = $n.bytesToNumberBE;
function qs(Y, X) {
  if (Y < 0 || Y >= 1 << 8 * X)
    throw new Error(`bad I2OSP call: value=${Y} length=${X}`);
  const ee = Array.from({ length: X }).fill(0);
  for (let te = X - 1; te >= 0; te--)
    ee[te] = Y & 255, Y >>>= 8;
  return new Uint8Array(ee);
}
function Y7(Y, X) {
  const ee = new Uint8Array(Y.length);
  for (let te = 0; te < Y.length; te++)
    ee[te] = Y[te] ^ X[te];
  return ee;
}
function Ru(Y) {
  if (!(0, $n.isBytes)(Y))
    throw new Error("Uint8Array expected");
}
function Cm(Y) {
  if (!Number.isSafeInteger(Y))
    throw new Error("number expected");
}
function D6(Y, X, ee, te) {
  Ru(Y), Ru(X), Cm(ee), X.length > 255 && (X = te((0, $n.concatBytes)((0, $n.utf8ToBytes)("H2C-OVERSIZE-DST-"), X)));
  const { outputLen: ne, blockLen: ie } = te, oe = Math.ceil(ee / ne);
  if (oe > 255)
    throw new Error("Invalid xmd length");
  const se = (0, $n.concatBytes)(X, qs(X.length, 1)), ae = qs(0, ie), ue = qs(ee, 2), le = new Array(oe), he = te((0, $n.concatBytes)(ae, Y, ue, qs(0, 1), se));
  le[0] = te((0, $n.concatBytes)(he, qs(1, 1), se));
  for (let me = 1; me <= oe; me++) {
    const ye = [Y7(he, le[me - 1]), qs(me + 1, 1), se];
    le[me] = te((0, $n.concatBytes)(...ye));
  }
  return (0, $n.concatBytes)(...le).slice(0, ee);
}
Yn.expand_message_xmd = D6;
function U6(Y, X, ee, te, ne) {
  if (Ru(Y), Ru(X), Cm(ee), X.length > 255) {
    const ie = Math.ceil(2 * te / 8);
    X = ne.create({ dkLen: ie }).update((0, $n.utf8ToBytes)("H2C-OVERSIZE-DST-")).update(X).digest();
  }
  if (ee > 65535 || X.length > 255)
    throw new Error("expand_message_xof: invalid lenInBytes");
  return ne.create({ dkLen: ee }).update(Y).update(qs(ee, 2)).update(X).update(qs(X.length, 1)).digest();
}
Yn.expand_message_xof = U6;
function Kp(Y, X, ee) {
  (0, $n.validateObject)(ee, {
    DST: "stringOrUint8Array",
    p: "bigint",
    m: "isSafeInteger",
    k: "isSafeInteger",
    hash: "hash"
  });
  const { p: te, k: ne, m: ie, hash: oe, expand: se, DST: ae } = ee;
  Ru(Y), Cm(X);
  const ue = K7(ae), le = te.toString(2).length, he = Math.ceil((le + ne) / 8), me = X * ie * he;
  let ye;
  if (se === "xmd")
    ye = D6(Y, ue, me, oe);
  else if (se === "xof")
    ye = U6(Y, ue, me, ne, oe);
  else if (se === "_internal_pass")
    ye = Y;
  else
    throw new Error('expand must be "xmd" or "xof"');
  const we = new Array(X);
  for (let Ee = 0; Ee < X; Ee++) {
    const Re = new Array(ie);
    for (let Ue = 0; Ue < ie; Ue++) {
      const Me = he * (Ue + Ee * ie), De = ye.subarray(Me, Me + he);
      Re[Ue] = (0, W7.mod)(J7(De), te);
    }
    we[Ee] = Re;
  }
  return we;
}
Yn.hash_to_field = Kp;
function X7(Y, X) {
  const ee = X.map((te) => Array.from(te).reverse());
  return (te, ne) => {
    const [ie, oe, se, ae] = ee.map((ue) => ue.reduce((le, he) => Y.add(Y.mul(le, te), he)));
    return te = Y.div(ie, oe), ne = Y.mul(ne, Y.div(se, ae)), { x: te, y: ne };
  };
}
Yn.isogenyMap = X7;
function Z7(Y, X, ee) {
  if (typeof X != "function")
    throw new Error("mapToCurve() must be defined");
  return {
    // Encodes byte string to elliptic curve.
    // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
    hashToCurve(te, ne) {
      const ie = Kp(te, 2, { ...ee, DST: ee.DST, ...ne }), oe = Y.fromAffine(X(ie[0])), se = Y.fromAffine(X(ie[1])), ae = oe.add(se).clearCofactor();
      return ae.assertValidity(), ae;
    },
    // Encodes byte string to elliptic curve.
    // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
    encodeToCurve(te, ne) {
      const ie = Kp(te, 1, { ...ee, DST: ee.encodeDST, ...ne }), oe = Y.fromAffine(X(ie[0])).clearCofactor();
      return oe.assertValidity(), oe;
    }
  };
}
Yn.createHasher = Z7;
var Ka = {}, j6 = {};
(function(Y) {
  Object.defineProperty(Y, "__esModule", { value: !0 }), Y.hmac = Y.HMAC = void 0;
  const X = Wr, ee = Cs;
  class te extends ee.Hash {
    constructor(oe, se) {
      super(), this.finished = !1, this.destroyed = !1, (0, X.hash)(oe);
      const ae = (0, ee.toBytes)(se);
      if (this.iHash = oe.create(), typeof this.iHash.update != "function")
        throw new Error("Expected instance of class which extends utils.Hash");
      this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
      const ue = this.blockLen, le = new Uint8Array(ue);
      le.set(ae.length > ue ? oe.create().update(ae).digest() : ae);
      for (let he = 0; he < le.length; he++)
        le[he] ^= 54;
      this.iHash.update(le), this.oHash = oe.create();
      for (let he = 0; he < le.length; he++)
        le[he] ^= 106;
      this.oHash.update(le), le.fill(0);
    }
    update(oe) {
      return (0, X.exists)(this), this.iHash.update(oe), this;
    }
    digestInto(oe) {
      (0, X.exists)(this), (0, X.bytes)(oe, this.outputLen), this.finished = !0, this.iHash.digestInto(oe), this.oHash.update(oe), this.oHash.digestInto(oe), this.destroy();
    }
    digest() {
      const oe = new Uint8Array(this.oHash.outputLen);
      return this.digestInto(oe), oe;
    }
    _cloneInto(oe) {
      oe || (oe = Object.create(Object.getPrototypeOf(this), {}));
      const { oHash: se, iHash: ae, finished: ue, destroyed: le, blockLen: he, outputLen: me } = this;
      return oe = oe, oe.finished = ue, oe.destroyed = le, oe.blockLen = he, oe.outputLen = me, oe.oHash = se._cloneInto(oe.oHash), oe.iHash = ae._cloneInto(oe.iHash), oe;
    }
    destroy() {
      this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
    }
  }
  Y.HMAC = te;
  const ne = (ie, oe, se) => new te(ie, oe).update(se).digest();
  Y.hmac = ne, Y.hmac.create = (ie, oe) => new te(ie, oe);
})(j6);
Object.defineProperty(Ka, "__esModule", { value: !0 });
Ka.createCurve = Ka.getHash = void 0;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const Q7 = j6, t1 = Cs, eP = Rm;
function H6(Y) {
  return {
    hash: Y,
    hmac: (X, ...ee) => (0, Q7.hmac)(Y, X, (0, t1.concatBytes)(...ee)),
    randomBytes: t1.randomBytes
  };
}
Ka.getHash = H6;
function tP(Y, X) {
  const ee = (te) => (0, eP.weierstrass)({ ...Y, ...H6(te) });
  return Object.freeze({ ...ee(X), create: ee });
}
Ka.createCurve = tP;
(function(Y) {
  Object.defineProperty(Y, "__esModule", { value: !0 }), Y.encodeToCurve = Y.hashToCurve = Y.schnorr = Y.secp256k1 = void 0;
  /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  const X = Va, ee = Cs, te = ht, ne = Rm, ie = ft$2, oe = Yn, se = Ka, ae = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"), ue = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"), le = BigInt(1), he = BigInt(2), me = (Se, ke) => (Se + ke / he) / ke;
  function ye(Se) {
    const ke = ae, ge = BigInt(3), Ae = BigInt(6), Ge = BigInt(11), Xe = BigInt(22), $e = BigInt(23), Ze = BigInt(44), ot = BigInt(88), ct = Se * Se * Se % ke, At = ct * ct * Se % ke, Tt = (0, te.pow2)(At, ge, ke) * At % ke, dt = (0, te.pow2)(Tt, ge, ke) * At % ke, vt = (0, te.pow2)(dt, he, ke) * ct % ke, Ut = (0, te.pow2)(vt, Ge, ke) * vt % ke, It = (0, te.pow2)(Ut, Xe, ke) * Ut % ke, Er = (0, te.pow2)(It, Ze, ke) * It % ke, Fr = (0, te.pow2)(Er, ot, ke) * Er % ke, an = (0, te.pow2)(Fr, Ze, ke) * It % ke, wX = (0, te.pow2)(an, ge, ke) * At % ke, Ct = (0, te.pow2)(wX, $e, ke) * Ut % ke, w_ = (0, te.pow2)(Ct, Ae, ke) * ct % ke, hX = (0, te.pow2)(w_, he, ke);
    if (!we.eql(we.sqr(hX), Se))
      throw new Error("Cannot find square root");
    return hX;
  }
  const we = (0, te.Field)(ae, void 0, void 0, { sqrt: ye });
  Y.secp256k1 = (0, se.createCurve)({
    a: BigInt(0),
    // equation params: a, b
    b: BigInt(7),
    // Seem to be rigid: bitcointalk.org/index.php?topic=289795.msg3183975#msg3183975
    Fp: we,
    // Field's prime: 2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n
    n: ue,
    // Curve order, total count of valid points in the field
    // Base point (x, y) aka generator point
    Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
    Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
    h: BigInt(1),
    // Cofactor
    lowS: !0,
    // Allow only low-S signatures by default in sign() and verify()
    /**
     * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
     * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
     * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
     * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
     */
    endo: {
      beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
      splitScalar: (Se) => {
        const ke = ue, ge = BigInt("0x3086d221a7d46bcde86c90e49284eb15"), Ae = -le * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"), Ge = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), Xe = ge, $e = BigInt("0x100000000000000000000000000000000"), Ze = me(Xe * Se, ke), ot = me(-Ae * Se, ke);
        let ct = (0, te.mod)(Se - Ze * ge - ot * Ge, ke), At = (0, te.mod)(-Ze * Ae - ot * Xe, ke);
        const Tt = ct > $e, dt = At > $e;
        if (Tt && (ct = ke - ct), dt && (At = ke - At), ct > $e || At > $e)
          throw new Error("splitScalar: Endomorphism failed, k=" + Se);
        return { k1neg: Tt, k1: ct, k2neg: dt, k2: At };
      }
    }
  }, X.sha256);
  const Ee = BigInt(0), Re = (Se) => typeof Se == "bigint" && Ee < Se && Se < ae, Ue = (Se) => typeof Se == "bigint" && Ee < Se && Se < ue, Me = {};
  function De(Se, ...ke) {
    let ge = Me[Se];
    if (ge === void 0) {
      const Ae = (0, X.sha256)(Uint8Array.from(Se, (Ge) => Ge.charCodeAt(0)));
      ge = (0, ie.concatBytes)(Ae, Ae), Me[Se] = ge;
    }
    return (0, X.sha256)((0, ie.concatBytes)(ge, ...ke));
  }
  const Fe = (Se) => Se.toRawBytes(!0).slice(1), Ke = (Se) => (0, ie.numberToBytesBE)(Se, 32), tt = (Se) => (0, te.mod)(Se, ae), rt = (Se) => (0, te.mod)(Se, ue), it = Y.secp256k1.ProjectivePoint, _t = (Se, ke, ge) => it.BASE.multiplyAndAddUnsafe(Se, ke, ge);
  function Dt(Se) {
    let ke = Y.secp256k1.utils.normPrivateKeyToScalar(Se), ge = it.fromPrivateKey(ke);
    return { scalar: ge.hasEvenY() ? ke : rt(-ke), bytes: Fe(ge) };
  }
  function je(Se) {
    if (!Re(Se))
      throw new Error("bad x: need 0 < x < p");
    const ke = tt(Se * Se), ge = tt(ke * Se + BigInt(7));
    let Ae = ye(ge);
    Ae % he !== Ee && (Ae = tt(-Ae));
    const Ge = new it(Se, Ae, le);
    return Ge.assertValidity(), Ge;
  }
  function ze(...Se) {
    return rt((0, ie.bytesToNumberBE)(De("BIP0340/challenge", ...Se)));
  }
  function fe(Se) {
    return Dt(Se).bytes;
  }
  function de(Se, ke, ge = (0, ee.randomBytes)(32)) {
    const Ae = (0, ie.ensureBytes)("message", Se), { bytes: Ge, scalar: Xe } = Dt(ke), $e = (0, ie.ensureBytes)("auxRand", ge, 32), Ze = Ke(Xe ^ (0, ie.bytesToNumberBE)(De("BIP0340/aux", $e))), ot = De("BIP0340/nonce", Ze, Ge, Ae), ct = rt((0, ie.bytesToNumberBE)(ot));
    if (ct === Ee)
      throw new Error("sign failed: k is zero");
    const { bytes: At, scalar: Tt } = Dt(ct), dt = ze(At, Ge, Ae), vt = new Uint8Array(64);
    if (vt.set(At, 0), vt.set(Ke(rt(Tt + dt * Xe)), 32), !be(vt, Ae, Ge))
      throw new Error("sign: Invalid signature produced");
    return vt;
  }
  function be(Se, ke, ge) {
    const Ae = (0, ie.ensureBytes)("signature", Se, 64), Ge = (0, ie.ensureBytes)("message", ke), Xe = (0, ie.ensureBytes)("publicKey", ge, 32);
    try {
      const $e = je((0, ie.bytesToNumberBE)(Xe)), Ze = (0, ie.bytesToNumberBE)(Ae.subarray(0, 32));
      if (!Re(Ze))
        return !1;
      const ot = (0, ie.bytesToNumberBE)(Ae.subarray(32, 64));
      if (!Ue(ot))
        return !1;
      const ct = ze(Ke(Ze), Fe($e), Ge), At = _t($e, ot, rt(-ct));
      return !(!At || !At.hasEvenY() || At.toAffine().x !== Ze);
    } catch {
      return !1;
    }
  }
  Y.schnorr = {
    getPublicKey: fe,
    sign: de,
    verify: be,
    utils: {
      randomPrivateKey: Y.secp256k1.utils.randomPrivateKey,
      lift_x: je,
      pointToBytes: Fe,
      numberToBytesBE: ie.numberToBytesBE,
      bytesToNumberBE: ie.bytesToNumberBE,
      taggedHash: De,
      mod: te.mod
    }
  };
  const Te = (0, oe.isogenyMap)(we, [
    // xNum
    [
      "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7",
      "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581",
      "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262",
      "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"
    ],
    // xDen
    [
      "0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b",
      "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14",
      "0x0000000000000000000000000000000000000000000000000000000000000001"
      // LAST 1
    ],
    // yNum
    [
      "0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c",
      "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3",
      "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931",
      "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"
    ],
    // yDen
    [
      "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b",
      "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573",
      "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f",
      "0x0000000000000000000000000000000000000000000000000000000000000001"
      // LAST 1
    ]
  ].map((Se) => Se.map((ke) => BigInt(ke)))), Ce = (0, ne.mapToCurveSimpleSWU)(we, {
    A: BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),
    B: BigInt("1771"),
    Z: we.create(BigInt("-11"))
  }), Pe = (0, oe.createHasher)(Y.secp256k1.ProjectivePoint, (Se) => {
    const { x: ke, y: ge } = Ce(we.create(Se[0]));
    return Te(ke, ge);
  }, {
    DST: "secp256k1_XMD:SHA-256_SSWU_RO_",
    encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_",
    p: we.ORDER,
    m: 1,
    k: 128,
    expand: "xmd",
    hash: X.sha256
  });
  Y.hashToCurve = Pe.hashToCurve, Y.encodeToCurve = Pe.encodeToCurve;
})(_6);
(function(Y) {
  Object.defineProperty(Y, "__esModule", { value: !0 }), Y.secp256k1 = void 0;
  var X = _6;
  Object.defineProperty(Y, "secp256k1", { enumerable: !0, get: function() {
    return X.secp256k1;
  } });
})(kd);
(function(Y) {
  Object.defineProperty(Y, "__esModule", { value: !0 }), Y.MAX_WITHDRAWALS_PER_PAYLOAD = Y.RLP_EMPTY_STRING = Y.KECCAK256_RLP = Y.KECCAK256_RLP_S = Y.KECCAK256_RLP_ARRAY = Y.KECCAK256_RLP_ARRAY_S = Y.KECCAK256_NULL = Y.KECCAK256_NULL_S = Y.TWO_POW256 = Y.SECP256K1_ORDER_DIV_2 = Y.SECP256K1_ORDER = Y.MAX_INTEGER_BIGINT = Y.MAX_INTEGER = Y.MAX_UINT64 = void 0;
  const X = v6, ee = kd;
  Y.MAX_UINT64 = BigInt("0xffffffffffffffff"), Y.MAX_INTEGER = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"), Y.MAX_INTEGER_BIGINT = BigInt("115792089237316195423570985008687907853269984665640564039457584007913129639935"), Y.SECP256K1_ORDER = ee.secp256k1.CURVE.n, Y.SECP256K1_ORDER_DIV_2 = ee.secp256k1.CURVE.n / BigInt(2), Y.TWO_POW256 = BigInt("0x10000000000000000000000000000000000000000000000000000000000000000"), Y.KECCAK256_NULL_S = "c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470", Y.KECCAK256_NULL = X.Buffer.from(Y.KECCAK256_NULL_S, "hex"), Y.KECCAK256_RLP_ARRAY_S = "1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347", Y.KECCAK256_RLP_ARRAY = X.Buffer.from(Y.KECCAK256_RLP_ARRAY_S, "hex"), Y.KECCAK256_RLP_S = "56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421", Y.KECCAK256_RLP = X.Buffer.from(Y.KECCAK256_RLP_S, "hex"), Y.RLP_EMPTY_STRING = X.Buffer.from([128]), Y.MAX_WITHDRAWALS_PER_PAYLOAD = 16;
})(Bd);
var Dd = {};
Object.defineProperty(Dd, "__esModule", { value: !0 });
Dd.GWEI_TO_WEI = void 0;
Dd.GWEI_TO_WEI = BigInt(1e9);
var Pm = {}, zi = {};
Object.defineProperty(zi, "__esModule", { value: !0 });
zi.RLP = zi.utils = zi.decode = zi.encode = void 0;
function Om(Y) {
  if (Array.isArray(Y)) {
    const ee = [];
    let te = 0;
    for (let ne = 0; ne < Y.length; ne++) {
      const ie = Om(Y[ne]);
      ee.push(ie), te += ie.length;
    }
    return Yp(n1(te, 192), ...ee);
  }
  const X = K6(Y);
  return X.length === 1 && X[0] < 128 ? X : Yp(n1(X.length, 128), X);
}
zi.encode = Om;
function sa(Y, X, ee) {
  if (ee > Y.length)
    throw new Error("invalid RLP (safeSlice): end slice of Uint8Array out-of-bounds");
  return Y.slice(X, ee);
}
function r1(Y) {
  if (Y[0] === 0)
    throw new Error("invalid RLP: extra zeros");
  return G6(q6(Y));
}
function n1(Y, X) {
  if (Y < 56)
    return Uint8Array.from([Y + X]);
  const ee = Xp(Y), te = ee.length / 2, ne = Xp(X + 55 + te);
  return Uint8Array.from(Wl(ne + ee));
}
function z6(Y, X = !1) {
  if (typeof Y > "u" || Y === null || Y.length === 0)
    return Uint8Array.from([]);
  const ee = K6(Y), te = Jp(ee);
  if (X)
    return te;
  if (te.remainder.length !== 0)
    throw new Error("invalid RLP: remainder must be zero");
  return te.data;
}
zi.decode = z6;
function Jp(Y) {
  let X, ee, te, ne, ie;
  const oe = [], se = Y[0];
  if (se <= 127)
    return {
      data: Y.slice(0, 1),
      remainder: Y.slice(1)
    };
  if (se <= 183) {
    if (X = se - 127, se === 128 ? te = Uint8Array.from([]) : te = sa(Y, 1, X), X === 2 && te[0] < 128)
      throw new Error("invalid RLP encoding: invalid prefix, single byte < 0x80 are not prefixed");
    return {
      data: te,
      remainder: Y.slice(X)
    };
  } else if (se <= 191) {
    if (ee = se - 182, Y.length - 1 < ee)
      throw new Error("invalid RLP: not enough bytes for string length");
    if (X = r1(sa(Y, 1, ee)), X <= 55)
      throw new Error("invalid RLP: expected string length to be greater than 55");
    return te = sa(Y, ee, X + ee), {
      data: te,
      remainder: Y.slice(X + ee)
    };
  } else if (se <= 247) {
    for (X = se - 191, ne = sa(Y, 1, X); ne.length; )
      ie = Jp(ne), oe.push(ie.data), ne = ie.remainder;
    return {
      data: oe,
      remainder: Y.slice(X)
    };
  } else {
    if (ee = se - 246, X = r1(sa(Y, 1, ee)), X < 56)
      throw new Error("invalid RLP: encoded list too short");
    const ae = ee + X;
    if (ae > Y.length)
      throw new Error("invalid RLP: total length is larger than the data");
    for (ne = sa(Y, ee, ae); ne.length; )
      ie = Jp(ne), oe.push(ie.data), ne = ie.remainder;
    return {
      data: oe,
      remainder: Y.slice(ae)
    };
  }
}
const rP = Array.from({ length: 256 }, (Y, X) => X.toString(16).padStart(2, "0"));
function q6(Y) {
  let X = "";
  for (let ee = 0; ee < Y.length; ee++)
    X += rP[Y[ee]];
  return X;
}
function G6(Y) {
  const X = Number.parseInt(Y, 16);
  if (Number.isNaN(X))
    throw new Error("Invalid byte sequence");
  return X;
}
function Wl(Y) {
  if (typeof Y != "string")
    throw new TypeError("hexToBytes: expected string, got " + typeof Y);
  if (Y.length % 2)
    throw new Error("hexToBytes: received invalid unpadded hex");
  const X = new Uint8Array(Y.length / 2);
  for (let ee = 0; ee < X.length; ee++) {
    const te = ee * 2;
    X[ee] = G6(Y.slice(te, te + 2));
  }
  return X;
}
function Yp(...Y) {
  if (Y.length === 1)
    return Y[0];
  const X = Y.reduce((te, ne) => te + ne.length, 0), ee = new Uint8Array(X);
  for (let te = 0, ne = 0; te < Y.length; te++) {
    const ie = Y[te];
    ee.set(ie, ne), ne += ie.length;
  }
  return ee;
}
function V6(Y) {
  return new TextEncoder().encode(Y);
}
function Xp(Y) {
  if (Y < 0)
    throw new Error("Invalid integer as argument, must be unsigned!");
  const X = Y.toString(16);
  return X.length % 2 ? `0${X}` : X;
}
function nP(Y) {
  return Y.length % 2 ? `0${Y}` : Y;
}
function W6(Y) {
  return Y.length >= 2 && Y[0] === "0" && Y[1] === "x";
}
function iP(Y) {
  return typeof Y != "string" ? Y : W6(Y) ? Y.slice(2) : Y;
}
function K6(Y) {
  if (Y instanceof Uint8Array)
    return Y;
  if (typeof Y == "string")
    return W6(Y) ? Wl(nP(iP(Y))) : V6(Y);
  if (typeof Y == "number" || typeof Y == "bigint")
    return Y ? Wl(Xp(Y)) : Uint8Array.from([]);
  if (Y == null)
    return Uint8Array.from([]);
  throw new Error("toBytes: received unsupported type " + typeof Y);
}
zi.utils = {
  bytesToHex: q6,
  concatBytes: Yp,
  hexToBytes: Wl,
  utf8ToBytes: V6
};
zi.RLP = { encode: Om, decode: z6 };
var Zn = {}, sr$1 = {}, ut$1 = {};
Object.defineProperty(ut$1, "__esModule", { value: !0 });
ut$1.add5L = ut$1.add5H = ut$1.add4H = ut$1.add4L = ut$1.add3H = ut$1.add3L = ut$1.add = ut$1.rotlBL = ut$1.rotlBH = ut$1.rotlSL = ut$1.rotlSH = ut$1.rotr32L = ut$1.rotr32H = ut$1.rotrBL = ut$1.rotrBH = ut$1.rotrSL = ut$1.rotrSH = ut$1.shrSL = ut$1.shrSH = ut$1.toBig = ut$1.split = ut$1.fromBig = void 0;
const Wf = /* @__PURE__ */ BigInt(2 ** 32 - 1), Zp = /* @__PURE__ */ BigInt(32);
function Bm(Y, X = !1) {
  return X ? { h: Number(Y & Wf), l: Number(Y >> Zp & Wf) } : { h: Number(Y >> Zp & Wf) | 0, l: Number(Y & Wf) | 0 };
}
ut$1.fromBig = Bm;
function J6(Y, X = !1) {
  let ee = new Uint32Array(Y.length), te = new Uint32Array(Y.length);
  for (let ne = 0; ne < Y.length; ne++) {
    const { h: ie, l: oe } = Bm(Y[ne], X);
    [ee[ne], te[ne]] = [ie, oe];
  }
  return [ee, te];
}
ut$1.split = J6;
const Y6 = (Y, X) => BigInt(Y >>> 0) << Zp | BigInt(X >>> 0);
ut$1.toBig = Y6;
const X6 = (Y, X, ee) => Y >>> ee;
ut$1.shrSH = X6;
const Z6 = (Y, X, ee) => Y << 32 - ee | X >>> ee;
ut$1.shrSL = Z6;
const Q6 = (Y, X, ee) => Y >>> ee | X << 32 - ee;
ut$1.rotrSH = Q6;
const e_ = (Y, X, ee) => Y << 32 - ee | X >>> ee;
ut$1.rotrSL = e_;
const t_ = (Y, X, ee) => Y << 64 - ee | X >>> ee - 32;
ut$1.rotrBH = t_;
const r_ = (Y, X, ee) => Y >>> ee - 32 | X << 64 - ee;
ut$1.rotrBL = r_;
const n_ = (Y, X) => X;
ut$1.rotr32H = n_;
const i_ = (Y, X) => Y;
ut$1.rotr32L = i_;
const s_ = (Y, X, ee) => Y << ee | X >>> 32 - ee;
ut$1.rotlSH = s_;
const o_ = (Y, X, ee) => X << ee | Y >>> 32 - ee;
ut$1.rotlSL = o_;
const a_ = (Y, X, ee) => X << ee - 32 | Y >>> 64 - ee;
ut$1.rotlBH = a_;
const c_ = (Y, X, ee) => Y << ee - 32 | X >>> 64 - ee;
ut$1.rotlBL = c_;
function u_(Y, X, ee, te) {
  const ne = (X >>> 0) + (te >>> 0);
  return { h: Y + ee + (ne / 2 ** 32 | 0) | 0, l: ne | 0 };
}
ut$1.add = u_;
const f_ = (Y, X, ee) => (Y >>> 0) + (X >>> 0) + (ee >>> 0);
ut$1.add3L = f_;
const l_ = (Y, X, ee, te) => X + ee + te + (Y / 2 ** 32 | 0) | 0;
ut$1.add3H = l_;
const d_ = (Y, X, ee, te) => (Y >>> 0) + (X >>> 0) + (ee >>> 0) + (te >>> 0);
ut$1.add4L = d_;
const h_ = (Y, X, ee, te, ne) => X + ee + te + ne + (Y / 2 ** 32 | 0) | 0;
ut$1.add4H = h_;
const p_ = (Y, X, ee, te, ne) => (Y >>> 0) + (X >>> 0) + (ee >>> 0) + (te >>> 0) + (ne >>> 0);
ut$1.add5L = p_;
const g_ = (Y, X, ee, te, ne, ie) => X + ee + te + ne + ie + (Y / 2 ** 32 | 0) | 0;
ut$1.add5H = g_;
const sP = {
  fromBig: Bm,
  split: J6,
  toBig: Y6,
  shrSH: X6,
  shrSL: Z6,
  rotrSH: Q6,
  rotrSL: e_,
  rotrBH: t_,
  rotrBL: r_,
  rotr32H: n_,
  rotr32L: i_,
  rotlSH: s_,
  rotlSL: o_,
  rotlBH: a_,
  rotlBL: c_,
  add: u_,
  add3L: f_,
  add3H: l_,
  add4L: d_,
  add4H: h_,
  add5H: g_,
  add5L: p_
};
ut$1.default = sP;
Object.defineProperty(sr$1, "__esModule", { value: !0 });
sr$1.shake256 = sr$1.shake128 = sr$1.keccak_512 = sr$1.keccak_384 = sr$1.keccak_256 = sr$1.keccak_224 = sr$1.sha3_512 = sr$1.sha3_384 = sr$1.sha3_256 = sr$1.sha3_224 = sr$1.Keccak = sr$1.keccakP = void 0;
const oa = Wr, Cu = ut$1, fu = Cs, [m_, y_, b_] = [[], [], []], oP = /* @__PURE__ */ BigInt(0), Vc = /* @__PURE__ */ BigInt(1), aP = /* @__PURE__ */ BigInt(2), cP = /* @__PURE__ */ BigInt(7), uP = /* @__PURE__ */ BigInt(256), fP = /* @__PURE__ */ BigInt(113);
for (let Y = 0, X = Vc, ee = 1, te = 0; Y < 24; Y++) {
  [ee, te] = [te, (2 * ee + 3 * te) % 5], m_.push(2 * (5 * te + ee)), y_.push((Y + 1) * (Y + 2) / 2 % 64);
  let ne = oP;
  for (let ie = 0; ie < 7; ie++)
    X = (X << Vc ^ (X >> cP) * fP) % uP, X & aP && (ne ^= Vc << (Vc << /* @__PURE__ */ BigInt(ie)) - Vc);
  b_.push(ne);
}
const [lP, dP] = /* @__PURE__ */ (0, Cu.split)(b_, !0), i1 = (Y, X, ee) => ee > 32 ? (0, Cu.rotlBH)(Y, X, ee) : (0, Cu.rotlSH)(Y, X, ee), s1 = (Y, X, ee) => ee > 32 ? (0, Cu.rotlBL)(Y, X, ee) : (0, Cu.rotlSL)(Y, X, ee);
function x_(Y, X = 24) {
  const ee = new Uint32Array(10);
  for (let te = 24 - X; te < 24; te++) {
    for (let oe = 0; oe < 10; oe++)
      ee[oe] = Y[oe] ^ Y[oe + 10] ^ Y[oe + 20] ^ Y[oe + 30] ^ Y[oe + 40];
    for (let oe = 0; oe < 10; oe += 2) {
      const se = (oe + 8) % 10, ae = (oe + 2) % 10, ue = ee[ae], le = ee[ae + 1], he = i1(ue, le, 1) ^ ee[se], me = s1(ue, le, 1) ^ ee[se + 1];
      for (let ye = 0; ye < 50; ye += 10)
        Y[oe + ye] ^= he, Y[oe + ye + 1] ^= me;
    }
    let ne = Y[2], ie = Y[3];
    for (let oe = 0; oe < 24; oe++) {
      const se = y_[oe], ae = i1(ne, ie, se), ue = s1(ne, ie, se), le = m_[oe];
      ne = Y[le], ie = Y[le + 1], Y[le] = ae, Y[le + 1] = ue;
    }
    for (let oe = 0; oe < 50; oe += 10) {
      for (let se = 0; se < 10; se++)
        ee[se] = Y[oe + se];
      for (let se = 0; se < 10; se++)
        Y[oe + se] ^= ~ee[(se + 2) % 10] & ee[(se + 4) % 10];
    }
    Y[0] ^= lP[te], Y[1] ^= dP[te];
  }
  ee.fill(0);
}
sr$1.keccakP = x_;
let Nm = class wY extends fu.Hash {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(X, ee, te, ne = !1, ie = 24) {
    if (super(), this.blockLen = X, this.suffix = ee, this.outputLen = te, this.enableXOF = ne, this.rounds = ie, this.pos = 0, this.posOut = 0, this.finished = !1, this.destroyed = !1, (0, oa.number)(te), 0 >= this.blockLen || this.blockLen >= 200)
      throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200), this.state32 = (0, fu.u32)(this.state);
  }
  keccak() {
    x_(this.state32, this.rounds), this.posOut = 0, this.pos = 0;
  }
  update(X) {
    (0, oa.exists)(this);
    const { blockLen: ee, state: te } = this;
    X = (0, fu.toBytes)(X);
    const ne = X.length;
    for (let ie = 0; ie < ne; ) {
      const oe = Math.min(ee - this.pos, ne - ie);
      for (let se = 0; se < oe; se++)
        te[this.pos++] ^= X[ie++];
      this.pos === ee && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = !0;
    const { state: X, suffix: ee, pos: te, blockLen: ne } = this;
    X[te] ^= ee, ee & 128 && te === ne - 1 && this.keccak(), X[ne - 1] ^= 128, this.keccak();
  }
  writeInto(X) {
    (0, oa.exists)(this, !1), (0, oa.bytes)(X), this.finish();
    const ee = this.state, { blockLen: te } = this;
    for (let ne = 0, ie = X.length; ne < ie; ) {
      this.posOut >= te && this.keccak();
      const oe = Math.min(te - this.posOut, ie - ne);
      X.set(ee.subarray(this.posOut, this.posOut + oe), ne), this.posOut += oe, ne += oe;
    }
    return X;
  }
  xofInto(X) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(X);
  }
  xof(X) {
    return (0, oa.number)(X), this.xofInto(new Uint8Array(X));
  }
  digestInto(X) {
    if ((0, oa.output)(X, this), this.finished)
      throw new Error("digest() was already called");
    return this.writeInto(X), this.destroy(), X;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = !0, this.state.fill(0);
  }
  _cloneInto(X) {
    const { blockLen: ee, suffix: te, outputLen: ne, rounds: ie, enableXOF: oe } = this;
    return X || (X = new wY(ee, te, ne, oe, ie)), X.state32.set(this.state32), X.pos = this.pos, X.posOut = this.posOut, X.finished = this.finished, X.rounds = ie, X.suffix = te, X.outputLen = ne, X.enableXOF = oe, X.destroyed = this.destroyed, X;
  }
};
sr$1.Keccak = Nm;
const go = (Y, X, ee) => (0, fu.wrapConstructor)(() => new Nm(X, Y, ee));
sr$1.sha3_224 = go(6, 144, 224 / 8);
sr$1.sha3_256 = go(6, 136, 256 / 8);
sr$1.sha3_384 = go(6, 104, 384 / 8);
sr$1.sha3_512 = go(6, 72, 512 / 8);
sr$1.keccak_224 = go(1, 144, 224 / 8);
sr$1.keccak_256 = go(1, 136, 256 / 8);
sr$1.keccak_384 = go(1, 104, 384 / 8);
sr$1.keccak_512 = go(1, 72, 512 / 8);
const v_ = (Y, X, ee) => (0, fu.wrapXOFConstructorWithOpts)((te = {}) => new Nm(X, Y, te.dkLen === void 0 ? ee : te.dkLen, !0));
sr$1.shake128 = v_(31, 168, 128 / 8);
sr$1.shake256 = v_(31, 136, 256 / 8);
function Qp(Y) {
  throw new Error('Could not dynamically require "' + Y + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var Kl = { exports: {} };
Kl.exports;
(function(Y, X) {
  var ee = St && St.__importDefault || function(me) {
    return me && me.__esModule ? me : { default: me };
  };
  Object.defineProperty(X, "__esModule", { value: !0 }), X.crypto = X.wrapHash = X.equalsBytes = X.hexToBytes = X.bytesToUtf8 = X.utf8ToBytes = X.createView = X.concatBytes = X.toHex = X.bytesToHex = X.assertBytes = X.assertBool = void 0;
  const te = ee(Wr), ne = Cs, ie = te.default.bool;
  X.assertBool = ie;
  const oe = te.default.bytes;
  X.assertBytes = oe;
  var se = Cs;
  Object.defineProperty(X, "bytesToHex", { enumerable: !0, get: function() {
    return se.bytesToHex;
  } }), Object.defineProperty(X, "toHex", { enumerable: !0, get: function() {
    return se.bytesToHex;
  } }), Object.defineProperty(X, "concatBytes", { enumerable: !0, get: function() {
    return se.concatBytes;
  } }), Object.defineProperty(X, "createView", { enumerable: !0, get: function() {
    return se.createView;
  } }), Object.defineProperty(X, "utf8ToBytes", { enumerable: !0, get: function() {
    return se.utf8ToBytes;
  } });
  function ae(me) {
    if (!(me instanceof Uint8Array))
      throw new TypeError(`bytesToUtf8 expected Uint8Array, got ${typeof me}`);
    return new TextDecoder().decode(me);
  }
  X.bytesToUtf8 = ae;
  function ue(me) {
    const ye = me.startsWith("0x") ? me.substring(2) : me;
    return (0, ne.hexToBytes)(ye);
  }
  X.hexToBytes = ue;
  function le(me, ye) {
    if (me.length !== ye.length)
      return !1;
    for (let we = 0; we < me.length; we++)
      if (me[we] !== ye[we])
        return !1;
    return !0;
  }
  X.equalsBytes = le;
  function he(me) {
    return (ye) => (te.default.bytes(ye), me(ye));
  }
  X.wrapHash = he, X.crypto = (() => {
    const me = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0, ye = typeof Qp == "function" && Qp.bind(Y);
    return {
      node: ye && !me ? ye("crypto") : void 0,
      web: me
    };
  })();
})(Kl, Kl.exports);
var E_ = Kl.exports;
Object.defineProperty(Zn, "__esModule", { value: !0 });
Zn.keccak512 = Zn.keccak384 = Zn.keccak256 = Zn.keccak224 = void 0;
const Pu = sr$1, Ud = E_;
Zn.keccak224 = (0, Ud.wrapHash)(Pu.keccak_224);
Zn.keccak256 = (() => {
  const Y = (0, Ud.wrapHash)(Pu.keccak_256);
  return Y.create = Pu.keccak_256.create, Y;
})();
Zn.keccak384 = (0, Ud.wrapHash)(Pu.keccak_384);
Zn.keccak512 = (0, Ud.wrapHash)(Pu.keccak_512);
var Jo = {}, Qn = {}, lr = {};
Object.defineProperty(lr, "__esModule", { value: !0 });
lr.isHexString = lr.getKeys = lr.fromAscii = lr.fromUtf8 = lr.toAscii = lr.arrayContainsArray = lr.getBinarySize = lr.padToEven = lr.stripHexPrefix = lr.isHexPrefixed = void 0;
function __(Y) {
  if (typeof Y != "string")
    throw new Error(`[isHexPrefixed] input must be type 'string', received type ${typeof Y}`);
  return Y[0] === "0" && Y[1] === "x";
}
lr.isHexPrefixed = __;
const hP = (Y) => {
  if (typeof Y != "string")
    throw new Error(`[stripHexPrefix] input must be type 'string', received ${typeof Y}`);
  return __(Y) ? Y.slice(2) : Y;
};
lr.stripHexPrefix = hP;
function A_(Y) {
  let X = Y;
  if (typeof X != "string")
    throw new Error(`[padToEven] value must be type 'string', received ${typeof X}`);
  return X.length % 2 && (X = `0${X}`), X;
}
lr.padToEven = A_;
function pP(Y) {
  if (typeof Y != "string")
    throw new Error(`[getBinarySize] method requires input type 'string', received ${typeof Y}`);
  return Buffer.byteLength(Y, "utf8");
}
lr.getBinarySize = pP;
function gP(Y, X, ee) {
  if (Array.isArray(Y) !== !0)
    throw new Error(`[arrayContainsArray] method requires input 'superset' to be an array, got type '${typeof Y}'`);
  if (Array.isArray(X) !== !0)
    throw new Error(`[arrayContainsArray] method requires input 'subset' to be an array, got type '${typeof X}'`);
  return X[ee === !0 ? "some" : "every"]((te) => Y.indexOf(te) >= 0);
}
lr.arrayContainsArray = gP;
function mP(Y) {
  let X = "", ee = 0;
  const te = Y.length;
  for (Y.substring(0, 2) === "0x" && (ee = 2); ee < te; ee += 2) {
    const ne = parseInt(Y.substr(ee, 2), 16);
    X += String.fromCharCode(ne);
  }
  return X;
}
lr.toAscii = mP;
function yP(Y) {
  const X = Buffer.from(Y, "utf8");
  return `0x${A_(X.toString("hex")).replace(/^0+|0+$/g, "")}`;
}
lr.fromUtf8 = yP;
function bP(Y) {
  let X = "";
  for (let ee = 0; ee < Y.length; ee++) {
    const te = Y.charCodeAt(ee).toString(16);
    X += te.length < 2 ? `0${te}` : te;
  }
  return `0x${X}`;
}
lr.fromAscii = bP;
function xP(Y, X, ee) {
  if (!Array.isArray(Y))
    throw new Error(`[getKeys] method expects input 'params' to be an array, got ${typeof Y}`);
  if (typeof X != "string")
    throw new Error(`[getKeys] method expects input 'key' to be type 'string', got ${typeof Y}`);
  const te = [];
  for (let ne = 0; ne < Y.length; ne++) {
    let ie = Y[ne][X];
    if (ee === !0 && !ie)
      ie = "";
    else if (typeof ie != "string")
      throw new Error(`invalid abi - expected type 'string', received ${typeof ie}`);
    te.push(ie);
  }
  return te;
}
lr.getKeys = xP;
function wP(Y, X) {
  return !(typeof Y != "string" || !Y.match(/^0x[0-9A-Fa-f]*$/) || typeof X < "u" && X > 0 && Y.length !== 2 + 2 * X);
}
lr.isHexString = wP;
Object.defineProperty(Qn, "__esModule", { value: !0 });
Qn.assertIsString = Qn.assertIsArray = Qn.assertIsBuffer = Qn.assertIsHexString = void 0;
const vP = lr, EP = function(Y) {
  if (!(0, vP.isHexString)(Y)) {
    const X = `This method only supports 0x-prefixed hex strings but input was: ${Y}`;
    throw new Error(X);
  }
};
Qn.assertIsHexString = EP;
const _P = function(Y) {
  if (!Buffer.isBuffer(Y)) {
    const X = `This method only supports Buffer but input was: ${Y}`;
    throw new Error(X);
  }
};
Qn.assertIsBuffer = _P;
const AP = function(Y) {
  if (!Array.isArray(Y)) {
    const X = `This method only supports number arrays but input was: ${Y}`;
    throw new Error(X);
  }
};
Qn.assertIsArray = AP;
const SP = function(Y) {
  if (typeof Y != "string") {
    const X = `This method only supports strings but input was: ${Y}`;
    throw new Error(X);
  }
};
Qn.assertIsString = SP;
(function(Y) {
  Object.defineProperty(Y, "__esModule", { value: !0 }), Y.intToUnpaddedBuffer = Y.bigIntToUnpaddedBuffer = Y.bigIntToHex = Y.bufArrToArr = Y.arrToBufArr = Y.validateNoLeadingZeroes = Y.baToJSON = Y.toUtf8 = Y.short = Y.addHexPrefix = Y.toUnsigned = Y.fromSigned = Y.bufferToInt = Y.bigIntToBuffer = Y.bufferToBigInt = Y.bufferToHex = Y.toBuffer = Y.unpadHexString = Y.unpadArray = Y.unpadBuffer = Y.setLengthRight = Y.setLengthLeft = Y.zeros = Y.intToBuffer = Y.intToHex = void 0;
  const X = Qn, ee = lr, te = function(de) {
    if (!Number.isSafeInteger(de) || de < 0)
      throw new Error(`Received an invalid integer type: ${de}`);
    return `0x${de.toString(16)}`;
  };
  Y.intToHex = te;
  const ne = function(de) {
    const be = (0, Y.intToHex)(de);
    return Buffer.from((0, ee.padToEven)(be.slice(2)), "hex");
  };
  Y.intToBuffer = ne;
  const ie = function(de) {
    return Buffer.allocUnsafe(de).fill(0);
  };
  Y.zeros = ie;
  const oe = function(de, be, Te) {
    const Ce = (0, Y.zeros)(be);
    return Te ? de.length < be ? (de.copy(Ce), Ce) : de.slice(0, be) : de.length < be ? (de.copy(Ce, be - de.length), Ce) : de.slice(-be);
  }, se = function(de, be) {
    return (0, X.assertIsBuffer)(de), oe(de, be, !1);
  };
  Y.setLengthLeft = se;
  const ae = function(de, be) {
    return (0, X.assertIsBuffer)(de), oe(de, be, !0);
  };
  Y.setLengthRight = ae;
  const ue = function(de) {
    let be = de[0];
    for (; de.length > 0 && be.toString() === "0"; )
      de = de.slice(1), be = de[0];
    return de;
  }, le = function(de) {
    return (0, X.assertIsBuffer)(de), ue(de);
  };
  Y.unpadBuffer = le;
  const he = function(de) {
    return (0, X.assertIsArray)(de), ue(de);
  };
  Y.unpadArray = he;
  const me = function(de) {
    return (0, X.assertIsHexString)(de), de = (0, ee.stripHexPrefix)(de), "0x" + ue(de);
  };
  Y.unpadHexString = me;
  const ye = function(de) {
    if (de == null)
      return Buffer.allocUnsafe(0);
    if (Buffer.isBuffer(de) || Array.isArray(de) || de instanceof Uint8Array)
      return Buffer.from(de);
    if (typeof de == "string") {
      if (!(0, ee.isHexString)(de))
        throw new Error(`Cannot convert string to buffer. toBuffer only supports 0x-prefixed hex strings and this string was given: ${de}`);
      return Buffer.from((0, ee.padToEven)((0, ee.stripHexPrefix)(de)), "hex");
    }
    if (typeof de == "number")
      return (0, Y.intToBuffer)(de);
    if (typeof de == "bigint") {
      if (de < BigInt(0))
        throw new Error(`Cannot convert negative bigint to buffer. Given: ${de}`);
      let be = de.toString(16);
      return be.length % 2 && (be = "0" + be), Buffer.from(be, "hex");
    }
    if (de.toArray)
      return Buffer.from(de.toArray());
    if (de.toBuffer)
      return Buffer.from(de.toBuffer());
    throw new Error("invalid type");
  };
  Y.toBuffer = ye;
  const we = function(de) {
    return de = (0, Y.toBuffer)(de), "0x" + de.toString("hex");
  };
  Y.bufferToHex = we;
  function Ee(de) {
    const be = (0, Y.bufferToHex)(de);
    return BigInt(be === "0x" ? 0 : be);
  }
  Y.bufferToBigInt = Ee;
  function Re(de) {
    return (0, Y.toBuffer)("0x" + de.toString(16));
  }
  Y.bigIntToBuffer = Re;
  const Ue = function(de) {
    const be = Number(Ee(de));
    if (!Number.isSafeInteger(be))
      throw new Error("Number exceeds 53 bits");
    return be;
  };
  Y.bufferToInt = Ue;
  const Me = function(de) {
    return BigInt.asIntN(256, Ee(de));
  };
  Y.fromSigned = Me;
  const De = function(de) {
    return Re(BigInt.asUintN(256, de));
  };
  Y.toUnsigned = De;
  const Fe = function(de) {
    return typeof de != "string" || (0, ee.isHexPrefixed)(de) ? de : "0x" + de;
  };
  Y.addHexPrefix = Fe;
  function Ke(de, be = 50) {
    const Te = Buffer.isBuffer(de) ? de.toString("hex") : de;
    return Te.length <= be ? Te : Te.slice(0, be) + "";
  }
  Y.short = Ke;
  const tt = function(de) {
    const be = /^(00)+|(00)+$/g;
    if (de = (0, ee.stripHexPrefix)(de), de.length % 2 !== 0)
      throw new Error("Invalid non-even hex string input for toUtf8() provided");
    return Buffer.from(de.replace(be, ""), "hex").toString("utf8");
  };
  Y.toUtf8 = tt;
  const rt = function(de) {
    if (Buffer.isBuffer(de))
      return `0x${de.toString("hex")}`;
    if (de instanceof Array) {
      const be = [];
      for (let Te = 0; Te < de.length; Te++)
        be.push((0, Y.baToJSON)(de[Te]));
      return be;
    }
  };
  Y.baToJSON = rt;
  const it = function(de) {
    for (const [be, Te] of Object.entries(de))
      if (Te !== void 0 && Te.length > 0 && Te[0] === 0)
        throw new Error(`${be} cannot have leading zeroes, received: ${Te.toString("hex")}`);
  };
  Y.validateNoLeadingZeroes = it;
  function _t(de) {
    return Array.isArray(de) ? de.map((be) => _t(be)) : Buffer.from(de);
  }
  Y.arrToBufArr = _t;
  function Dt(de) {
    return Array.isArray(de) ? de.map((be) => Dt(be)) : Uint8Array.from(de ?? []);
  }
  Y.bufArrToArr = Dt;
  const je = (de) => "0x" + de.toString(16);
  Y.bigIntToHex = je;
  function ze(de) {
    return (0, Y.unpadBuffer)(Re(de));
  }
  Y.bigIntToUnpaddedBuffer = ze;
  function fe(de) {
    return (0, Y.unpadBuffer)((0, Y.intToBuffer)(de));
  }
  Y.intToUnpaddedBuffer = fe;
})(Jo);
(function(Y) {
  Object.defineProperty(Y, "__esModule", { value: !0 }), Y.accountBodyToRLP = Y.accountBodyToSlim = Y.accountBodyFromSlim = Y.isZeroAddress = Y.zeroAddress = Y.importPublic = Y.privateToAddress = Y.privateToPublic = Y.publicToAddress = Y.pubToAddress = Y.isValidPublic = Y.isValidPrivate = Y.generateAddress2 = Y.generateAddress = Y.isValidChecksumAddress = Y.toChecksumAddress = Y.isValidAddress = Y.Account = void 0;
  const X = zi, ee = Zn, te = kd, ne = E_, ie = Jo, oe = Bd, se = Qn, ae = lr, ue = BigInt(0);
  class le {
    /**
     * This constructor assigns and validates the values.
     * Use the static factory methods to assist in creating an Account from varying data types.
     */
    constructor(fe = ue, de = ue, be = oe.KECCAK256_RLP, Te = oe.KECCAK256_NULL) {
      this.nonce = fe, this.balance = de, this.storageRoot = be, this.codeHash = Te, this._validate();
    }
    static fromAccountData(fe) {
      const { nonce: de, balance: be, storageRoot: Te, codeHash: Ce } = fe;
      return new le(de !== void 0 ? (0, ie.bufferToBigInt)((0, ie.toBuffer)(de)) : void 0, be !== void 0 ? (0, ie.bufferToBigInt)((0, ie.toBuffer)(be)) : void 0, Te !== void 0 ? (0, ie.toBuffer)(Te) : void 0, Ce !== void 0 ? (0, ie.toBuffer)(Ce) : void 0);
    }
    static fromRlpSerializedAccount(fe) {
      const de = (0, ie.arrToBufArr)(X.RLP.decode(Uint8Array.from(fe)));
      if (!Array.isArray(de))
        throw new Error("Invalid serialized account input. Must be array");
      return this.fromValuesArray(de);
    }
    static fromValuesArray(fe) {
      const [de, be, Te, Ce] = fe;
      return new le((0, ie.bufferToBigInt)(de), (0, ie.bufferToBigInt)(be), Te, Ce);
    }
    _validate() {
      if (this.nonce < ue)
        throw new Error("nonce must be greater than zero");
      if (this.balance < ue)
        throw new Error("balance must be greater than zero");
      if (this.storageRoot.length !== 32)
        throw new Error("storageRoot must have a length of 32");
      if (this.codeHash.length !== 32)
        throw new Error("codeHash must have a length of 32");
    }
    /**
     * Returns a Buffer Array of the raw Buffers for the account, in order.
     */
    raw() {
      return [
        (0, ie.bigIntToUnpaddedBuffer)(this.nonce),
        (0, ie.bigIntToUnpaddedBuffer)(this.balance),
        this.storageRoot,
        this.codeHash
      ];
    }
    /**
     * Returns the RLP serialization of the account as a `Buffer`.
     */
    serialize() {
      return Buffer.from(X.RLP.encode((0, ie.bufArrToArr)(this.raw())));
    }
    /**
     * Returns a `Boolean` determining if the account is a contract.
     */
    isContract() {
      return !this.codeHash.equals(oe.KECCAK256_NULL);
    }
    /**
     * Returns a `Boolean` determining if the account is empty complying to the definition of
     * account emptiness in [EIP-161](https://eips.ethereum.org/EIPS/eip-161):
     * "An account is considered empty when it has no code and zero nonce and zero balance."
     */
    isEmpty() {
      return this.balance === ue && this.nonce === ue && this.codeHash.equals(oe.KECCAK256_NULL);
    }
  }
  Y.Account = le;
  const he = function(ze) {
    try {
      (0, se.assertIsString)(ze);
    } catch {
      return !1;
    }
    return /^0x[0-9a-fA-F]{40}$/.test(ze);
  };
  Y.isValidAddress = he;
  const me = function(ze, fe) {
    (0, se.assertIsHexString)(ze);
    const de = (0, ae.stripHexPrefix)(ze).toLowerCase();
    let be = "";
    fe !== void 0 && (be = (0, ie.bufferToBigInt)((0, ie.toBuffer)(fe)).toString() + "0x");
    const Te = Buffer.from(be + de, "utf8"), Ce = (0, ne.bytesToHex)((0, ee.keccak256)(Te));
    let Pe = "0x";
    for (let Se = 0; Se < de.length; Se++)
      parseInt(Ce[Se], 16) >= 8 ? Pe += de[Se].toUpperCase() : Pe += de[Se];
    return Pe;
  };
  Y.toChecksumAddress = me;
  const ye = function(ze, fe) {
    return (0, Y.isValidAddress)(ze) && (0, Y.toChecksumAddress)(ze, fe) === ze;
  };
  Y.isValidChecksumAddress = ye;
  const we = function(ze, fe) {
    return (0, se.assertIsBuffer)(ze), (0, se.assertIsBuffer)(fe), (0, ie.bufferToBigInt)(fe) === BigInt(0) ? Buffer.from((0, ee.keccak256)(X.RLP.encode((0, ie.bufArrToArr)([ze, null])))).slice(-20) : Buffer.from((0, ee.keccak256)(X.RLP.encode((0, ie.bufArrToArr)([ze, fe])))).slice(-20);
  };
  Y.generateAddress = we;
  const Ee = function(ze, fe, de) {
    if ((0, se.assertIsBuffer)(ze), (0, se.assertIsBuffer)(fe), (0, se.assertIsBuffer)(de), ze.length !== 20)
      throw new Error("Expected from to be of length 20");
    if (fe.length !== 32)
      throw new Error("Expected salt to be of length 32");
    const be = (0, ee.keccak256)(Buffer.concat([Buffer.from("ff", "hex"), ze, fe, (0, ee.keccak256)(de)]));
    return (0, ie.toBuffer)(be).slice(-20);
  };
  Y.generateAddress2 = Ee;
  const Re = function(ze) {
    return te.secp256k1.utils.isValidPrivateKey(ze);
  };
  Y.isValidPrivate = Re;
  const Ue = function(ze, fe = !1) {
    if ((0, se.assertIsBuffer)(ze), ze.length === 64)
      try {
        return te.secp256k1.ProjectivePoint.fromHex(Buffer.concat([Buffer.from([4]), ze])), !0;
      } catch {
        return !1;
      }
    if (!fe)
      return !1;
    try {
      return te.secp256k1.ProjectivePoint.fromHex(ze), !0;
    } catch {
      return !1;
    }
  };
  Y.isValidPublic = Ue;
  const Me = function(ze, fe = !1) {
    if ((0, se.assertIsBuffer)(ze), fe && ze.length !== 64 && (ze = Buffer.from(te.secp256k1.ProjectivePoint.fromHex(ze).toRawBytes(!1).slice(1))), ze.length !== 64)
      throw new Error("Expected pubKey to be of length 64");
    return Buffer.from((0, ee.keccak256)(ze)).slice(-20);
  };
  Y.pubToAddress = Me, Y.publicToAddress = Y.pubToAddress;
  const De = function(ze) {
    return (0, se.assertIsBuffer)(ze), Buffer.from(te.secp256k1.ProjectivePoint.fromPrivateKey(ze).toRawBytes(!1).slice(1));
  };
  Y.privateToPublic = De;
  const Fe = function(ze) {
    return (0, Y.publicToAddress)((0, Y.privateToPublic)(ze));
  };
  Y.privateToAddress = Fe;
  const Ke = function(ze) {
    return (0, se.assertIsBuffer)(ze), ze.length !== 64 && (ze = Buffer.from(te.secp256k1.ProjectivePoint.fromHex(ze).toRawBytes(!1).slice(1))), ze;
  };
  Y.importPublic = Ke;
  const tt = function() {
    const ze = (0, ie.zeros)(20);
    return (0, ie.bufferToHex)(ze);
  };
  Y.zeroAddress = tt;
  const rt = function(ze) {
    try {
      (0, se.assertIsString)(ze);
    } catch {
      return !1;
    }
    return (0, Y.zeroAddress)() === ze;
  };
  Y.isZeroAddress = rt;
  function it(ze) {
    const [fe, de, be, Te] = ze;
    return [
      fe,
      de,
      (0, ie.arrToBufArr)(be).length === 0 ? oe.KECCAK256_RLP : be,
      (0, ie.arrToBufArr)(Te).length === 0 ? oe.KECCAK256_NULL : Te
    ];
  }
  Y.accountBodyFromSlim = it;
  const _t = new Uint8Array(0);
  function Dt(ze) {
    const [fe, de, be, Te] = ze;
    return [
      fe,
      de,
      (0, ie.arrToBufArr)(be).equals(oe.KECCAK256_RLP) ? _t : be,
      (0, ie.arrToBufArr)(Te).equals(oe.KECCAK256_NULL) ? _t : Te
    ];
  }
  Y.accountBodyToSlim = Dt;
  function je(ze, fe = !0) {
    const de = fe ? it(ze) : ze;
    return (0, ie.arrToBufArr)(X.RLP.encode(de));
  }
  Y.accountBodyToRLP = je;
})(Pm);
var df = {};
Object.defineProperty(df, "__esModule", { value: !0 });
df.Address = void 0;
const Wc = Pm, Kf = Jo;
class hs {
  constructor(X) {
    if (X.length !== 20)
      throw new Error("Invalid address length");
    this.buf = X;
  }
  /**
   * Returns the zero address.
   */
  static zero() {
    return new hs((0, Kf.zeros)(20));
  }
  /**
   * Returns an Address object from a hex-encoded string.
   * @param str - Hex-encoded address
   */
  static fromString(X) {
    if (!(0, Wc.isValidAddress)(X))
      throw new Error("Invalid address");
    return new hs((0, Kf.toBuffer)(X));
  }
  /**
   * Returns an address for a given public key.
   * @param pubKey The two points of an uncompressed key
   */
  static fromPublicKey(X) {
    if (!Buffer.isBuffer(X))
      throw new Error("Public key should be Buffer");
    const ee = (0, Wc.pubToAddress)(X);
    return new hs(ee);
  }
  /**
   * Returns an address for a given private key.
   * @param privateKey A private key must be 256 bits wide
   */
  static fromPrivateKey(X) {
    if (!Buffer.isBuffer(X))
      throw new Error("Private key should be Buffer");
    const ee = (0, Wc.privateToAddress)(X);
    return new hs(ee);
  }
  /**
   * Generates an address for a newly created contract.
   * @param from The address which is creating this new address
   * @param nonce The nonce of the from account
   */
  static generate(X, ee) {
    if (typeof ee != "bigint")
      throw new Error("Expected nonce to be a bigint");
    return new hs((0, Wc.generateAddress)(X.buf, (0, Kf.bigIntToBuffer)(ee)));
  }
  /**
   * Generates an address for a contract created using CREATE2.
   * @param from The address which is creating this new address
   * @param salt A salt
   * @param initCode The init code of the contract being created
   */
  static generate2(X, ee, te) {
    if (!Buffer.isBuffer(ee))
      throw new Error("Expected salt to be a Buffer");
    if (!Buffer.isBuffer(te))
      throw new Error("Expected initCode to be a Buffer");
    return new hs((0, Wc.generateAddress2)(X.buf, ee, te));
  }
  /**
   * Is address equal to another.
   */
  equals(X) {
    return this.buf.equals(X.buf);
  }
  /**
   * Is address zero.
   */
  isZero() {
    return this.equals(hs.zero());
  }
  /**
   * True if address is in the address range defined
   * by EIP-1352
   */
  isPrecompileOrSystemAddress() {
    const X = (0, Kf.bufferToBigInt)(this.buf), ee = BigInt(0), te = BigInt("0xffff");
    return X >= ee && X <= te;
  }
  /**
   * Returns hex encoding of address.
   */
  toString() {
    return "0x" + this.buf.toString("hex");
  }
  /**
   * Returns Buffer representation of address.
   */
  toBuffer() {
    return Buffer.from(this.buf);
  }
}
df.Address = hs;
var jd = {}, km = {};
(function(Y) {
  Object.defineProperty(Y, "__esModule", { value: !0 }), Y.toType = Y.TypeOutput = void 0;
  const X = Jo, ee = lr;
  var te;
  (function(ie) {
    ie[ie.Number = 0] = "Number", ie[ie.BigInt = 1] = "BigInt", ie[ie.Buffer = 2] = "Buffer", ie[ie.PrefixedHexString = 3] = "PrefixedHexString";
  })(te = Y.TypeOutput || (Y.TypeOutput = {}));
  function ne(ie, oe) {
    if (ie === null)
      return null;
    if (ie === void 0)
      return;
    if (typeof ie == "string" && !(0, ee.isHexString)(ie))
      throw new Error(`A string must be provided with a 0x-prefix, given: ${ie}`);
    if (typeof ie == "number" && !Number.isSafeInteger(ie))
      throw new Error("The provided number is greater than MAX_SAFE_INTEGER (please use an alternative input type)");
    const se = (0, X.toBuffer)(ie);
    switch (oe) {
      case te.Buffer:
        return se;
      case te.BigInt:
        return (0, X.bufferToBigInt)(se);
      case te.Number: {
        const ae = (0, X.bufferToBigInt)(se);
        if (ae > BigInt(Number.MAX_SAFE_INTEGER))
          throw new Error("The provided number is greater than MAX_SAFE_INTEGER (please use an alternative output type)");
        return Number(ae);
      }
      case te.PrefixedHexString:
        return (0, X.bufferToHex)(se);
      default:
        throw new Error("unknown outputType");
    }
  }
  Y.toType = ne;
})(km);
Object.defineProperty(jd, "__esModule", { value: !0 });
jd.Withdrawal = void 0;
const o1 = df, ph = Jo, Ar = km;
class lu {
  /**
   * This constructor assigns and validates the values.
   * Use the static factory methods to assist in creating a Withdrawal object from varying data types.
   * Its amount is in Gwei to match CL representation and for eventual ssz withdrawalsRoot
   */
  constructor(X, ee, te, ne) {
    this.index = X, this.validatorIndex = ee, this.address = te, this.amount = ne;
  }
  static fromWithdrawalData(X) {
    const { index: ee, validatorIndex: te, address: ne, amount: ie } = X, oe = (0, Ar.toType)(ee, Ar.TypeOutput.BigInt), se = (0, Ar.toType)(te, Ar.TypeOutput.BigInt), ae = new o1.Address((0, Ar.toType)(ne, Ar.TypeOutput.Buffer)), ue = (0, Ar.toType)(ie, Ar.TypeOutput.BigInt);
    return new lu(oe, se, ae, ue);
  }
  static fromValuesArray(X) {
    if (X.length !== 4)
      throw Error(`Invalid withdrawalArray length expected=4 actual=${X.length}`);
    const [ee, te, ne, ie] = X;
    return lu.fromWithdrawalData({ index: ee, validatorIndex: te, address: ne, amount: ie });
  }
  /**
   * Convert a withdrawal to a buffer array
   * @param withdrawal the withdrawal to convert
   * @returns buffer array of the withdrawal
   */
  static toBufferArray(X) {
    const { index: ee, validatorIndex: te, address: ne, amount: ie } = X, oe = (0, Ar.toType)(ee, Ar.TypeOutput.BigInt) === BigInt(0) ? Buffer.alloc(0) : (0, Ar.toType)(ee, Ar.TypeOutput.Buffer), se = (0, Ar.toType)(te, Ar.TypeOutput.BigInt) === BigInt(0) ? Buffer.alloc(0) : (0, Ar.toType)(te, Ar.TypeOutput.Buffer);
    let ae;
    ne instanceof o1.Address ? ae = ne.buf : ae = (0, Ar.toType)(ne, Ar.TypeOutput.Buffer);
    const ue = (0, Ar.toType)(ie, Ar.TypeOutput.BigInt) === BigInt(0) ? Buffer.alloc(0) : (0, Ar.toType)(ie, Ar.TypeOutput.Buffer);
    return [oe, se, ae, ue];
  }
  raw() {
    return lu.toBufferArray(this);
  }
  toValue() {
    return {
      index: this.index,
      validatorIndex: this.validatorIndex,
      address: this.address.buf,
      amount: this.amount
    };
  }
  toJSON() {
    return {
      index: (0, ph.bigIntToHex)(this.index),
      validatorIndex: (0, ph.bigIntToHex)(this.validatorIndex),
      address: "0x" + this.address.buf.toString("hex"),
      amount: (0, ph.bigIntToHex)(this.amount)
    };
  }
}
jd.Withdrawal = lu;
var fn = {};
Object.defineProperty(fn, "__esModule", { value: !0 });
fn.hashPersonalMessage = fn.isValidSignature = fn.fromRpcSig = fn.toCompactSig = fn.toRpcSig = fn.ecrecover = fn.ecsign = void 0;
const TP = Zn, S_ = kd, In = Jo, gh = Bd, IP = Qn;
function RP(Y, X, ee) {
  const te = S_.secp256k1.sign(Y, X), ne = te.toCompactRawBytes(), ie = Buffer.from(ne.slice(0, 32)), oe = Buffer.from(ne.slice(32, 64)), se = ee === void 0 ? BigInt(te.recovery + 27) : BigInt(te.recovery + 35) + BigInt(ee) * BigInt(2);
  return { r: ie, s: oe, v: se };
}
fn.ecsign = RP;
function Hd(Y, X) {
  return Y === BigInt(0) || Y === BigInt(1) ? Y : X === void 0 ? Y - BigInt(27) : Y - (X * BigInt(2) + BigInt(35));
}
function zd(Y) {
  return Y === BigInt(0) || Y === BigInt(1);
}
const CP = function(Y, X, ee, te, ne) {
  const ie = Buffer.concat([(0, In.setLengthLeft)(ee, 32), (0, In.setLengthLeft)(te, 32)], 64), oe = Hd(X, ne);
  if (!zd(oe))
    throw new Error("Invalid signature v value");
  const se = S_.secp256k1.Signature.fromCompact(ie).addRecoveryBit(Number(oe)).recoverPublicKey(Y);
  return Buffer.from(se.toRawBytes(!1).slice(1));
};
fn.ecrecover = CP;
const PP = function(Y, X, ee, te) {
  const ne = Hd(Y, te);
  if (!zd(ne))
    throw new Error("Invalid signature v value");
  return (0, In.bufferToHex)(Buffer.concat([(0, In.setLengthLeft)(X, 32), (0, In.setLengthLeft)(ee, 32), (0, In.toBuffer)(Y)]));
};
fn.toRpcSig = PP;
const OP = function(Y, X, ee, te) {
  const ne = Hd(Y, te);
  if (!zd(ne))
    throw new Error("Invalid signature v value");
  let ie = ee;
  return (Y > BigInt(28) && Y % BigInt(2) === BigInt(1) || Y === BigInt(1) || Y === BigInt(28)) && (ie = Buffer.from(ee), ie[0] |= 128), (0, In.bufferToHex)(Buffer.concat([(0, In.setLengthLeft)(X, 32), (0, In.setLengthLeft)(ie, 32)]));
};
fn.toCompactSig = OP;
const BP = function(Y) {
  const X = (0, In.toBuffer)(Y);
  let ee, te, ne;
  if (X.length >= 65)
    ee = X.slice(0, 32), te = X.slice(32, 64), ne = (0, In.bufferToBigInt)(X.slice(64));
  else if (X.length === 64)
    ee = X.slice(0, 32), te = X.slice(32, 64), ne = BigInt((0, In.bufferToInt)(X.slice(32, 33)) >> 7), te[0] &= 127;
  else
    throw new Error("Invalid signature length");
  return ne < 27 && (ne = ne + BigInt(27)), {
    v: ne,
    r: ee,
    s: te
  };
};
fn.fromRpcSig = BP;
const NP = function(Y, X, ee, te = !0, ne) {
  if (X.length !== 32 || ee.length !== 32 || !zd(Hd(Y, ne)))
    return !1;
  const ie = (0, In.bufferToBigInt)(X), oe = (0, In.bufferToBigInt)(ee);
  return !(ie === BigInt(0) || ie >= gh.SECP256K1_ORDER || oe === BigInt(0) || oe >= gh.SECP256K1_ORDER || te && oe >= gh.SECP256K1_ORDER_DIV_2);
};
fn.isValidSignature = NP;
const kP = function(Y) {
  (0, IP.assertIsBuffer)(Y);
  const X = Buffer.from(`Ethereum Signed Message:
${Y.length}`, "utf-8");
  return Buffer.from((0, TP.keccak256)(Buffer.concat([X, Y])));
};
fn.hashPersonalMessage = kP;
var T_ = {};
(function(Y) {
  Object.defineProperty(Y, "__esModule", { value: !0 }), Y.compactBytesToNibbles = Y.bytesToNibbles = Y.nibblesToCompactBytes = Y.nibblesToBytes = Y.hasTerminator = void 0;
  const X = (oe) => oe.length > 0 && oe[oe.length - 1] === 16;
  Y.hasTerminator = X;
  const ee = (oe, se) => {
    for (let ae = 0, ue = 0; ue < oe.length; ae += 1, ue += 2)
      se[ae] = oe[ue] << 4 | oe[ue + 1];
  };
  Y.nibblesToBytes = ee;
  const te = (oe) => {
    let se = 0;
    (0, Y.hasTerminator)(oe) && (se = 1, oe = oe.subarray(0, oe.length - 1));
    const ae = new Uint8Array(oe.length / 2 + 1);
    return ae[0] = se << 5, (oe.length & 1) === 1 && (ae[0] |= 16, ae[0] |= oe[0], oe = oe.subarray(1)), (0, Y.nibblesToBytes)(oe, ae.subarray(1)), ae;
  };
  Y.nibblesToCompactBytes = te;
  const ne = (oe) => {
    const se = oe.length * 2 + 1, ae = new Uint8Array(se);
    for (let ue = 0; ue < oe.length; ue++) {
      const le = oe[ue];
      ae[ue * 2] = le / 16, ae[ue * 2 + 1] = le % 16;
    }
    return ae[se - 1] = 16, ae;
  };
  Y.bytesToNibbles = ne;
  const ie = (oe) => {
    if (oe.length === 0)
      return oe;
    let se = (0, Y.bytesToNibbles)(oe);
    se[0] < 2 && (se = se.subarray(0, se.length - 1));
    const ae = 2 - (se[0] & 1);
    return se.subarray(ae);
  };
  Y.compactBytesToNibbles = ie;
})(T_);
var qd = {}, Mm = { exports: {} }, Oa = typeof Reflect == "object" ? Reflect : null, a1 = Oa && typeof Oa.apply == "function" ? Oa.apply : function(Y, X, ee) {
  return Function.prototype.apply.call(Y, X, ee);
}, Sl;
Oa && typeof Oa.ownKeys == "function" ? Sl = Oa.ownKeys : Object.getOwnPropertySymbols ? Sl = function(Y) {
  return Object.getOwnPropertyNames(Y).concat(Object.getOwnPropertySymbols(Y));
} : Sl = function(Y) {
  return Object.getOwnPropertyNames(Y);
};
function MP(Y) {
  console && console.warn && console.warn(Y);
}
var I_ = Number.isNaN || function(Y) {
  return Y !== Y;
};
function ir() {
  ir.init.call(this);
}
Mm.exports = ir;
Mm.exports.once = DP;
ir.EventEmitter = ir;
ir.prototype._events = void 0;
ir.prototype._eventsCount = 0;
ir.prototype._maxListeners = void 0;
var c1 = 10;
function Gd(Y) {
  if (typeof Y != "function")
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof Y);
}
Object.defineProperty(ir, "defaultMaxListeners", {
  enumerable: !0,
  get: function() {
    return c1;
  },
  set: function(Y) {
    if (typeof Y != "number" || Y < 0 || I_(Y))
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + Y + ".");
    c1 = Y;
  }
});
ir.init = function() {
  (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
};
ir.prototype.setMaxListeners = function(Y) {
  if (typeof Y != "number" || Y < 0 || I_(Y))
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + Y + ".");
  return this._maxListeners = Y, this;
};
function R_(Y) {
  return Y._maxListeners === void 0 ? ir.defaultMaxListeners : Y._maxListeners;
}
ir.prototype.getMaxListeners = function() {
  return R_(this);
};
ir.prototype.emit = function(Y) {
  for (var X = [], ee = 1; ee < arguments.length; ee++)
    X.push(arguments[ee]);
  var te = Y === "error", ne = this._events;
  if (ne !== void 0)
    te = te && ne.error === void 0;
  else if (!te)
    return !1;
  if (te) {
    var ie;
    if (X.length > 0 && (ie = X[0]), ie instanceof Error)
      throw ie;
    var oe = new Error("Unhandled error." + (ie ? " (" + ie.message + ")" : ""));
    throw oe.context = ie, oe;
  }
  var se = ne[Y];
  if (se === void 0)
    return !1;
  if (typeof se == "function")
    a1(se, this, X);
  else
    for (var ae = se.length, ue = N_(se, ae), ee = 0; ee < ae; ++ee)
      a1(ue[ee], this, X);
  return !0;
};
function C_(Y, X, ee, te) {
  var ne, ie, oe;
  if (Gd(ee), ie = Y._events, ie === void 0 ? (ie = Y._events = /* @__PURE__ */ Object.create(null), Y._eventsCount = 0) : (ie.newListener !== void 0 && (Y.emit(
    "newListener",
    X,
    ee.listener ? ee.listener : ee
  ), ie = Y._events), oe = ie[X]), oe === void 0)
    oe = ie[X] = ee, ++Y._eventsCount;
  else if (typeof oe == "function" ? oe = ie[X] = te ? [ee, oe] : [oe, ee] : te ? oe.unshift(ee) : oe.push(ee), ne = R_(Y), ne > 0 && oe.length > ne && !oe.warned) {
    oe.warned = !0;
    var se = new Error("Possible EventEmitter memory leak detected. " + oe.length + " " + String(X) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    se.name = "MaxListenersExceededWarning", se.emitter = Y, se.type = X, se.count = oe.length, MP(se);
  }
  return Y;
}
ir.prototype.addListener = function(Y, X) {
  return C_(this, Y, X, !1);
};
ir.prototype.on = ir.prototype.addListener;
ir.prototype.prependListener = function(Y, X) {
  return C_(this, Y, X, !0);
};
function LP() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function P_(Y, X, ee) {
  var te = { fired: !1, wrapFn: void 0, target: Y, type: X, listener: ee }, ne = LP.bind(te);
  return ne.listener = ee, te.wrapFn = ne, ne;
}
ir.prototype.once = function(Y, X) {
  return Gd(X), this.on(Y, P_(this, Y, X)), this;
};
ir.prototype.prependOnceListener = function(Y, X) {
  return Gd(X), this.prependListener(Y, P_(this, Y, X)), this;
};
ir.prototype.removeListener = function(Y, X) {
  var ee, te, ne, ie, oe;
  if (Gd(X), te = this._events, te === void 0)
    return this;
  if (ee = te[Y], ee === void 0)
    return this;
  if (ee === X || ee.listener === X)
    --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete te[Y], te.removeListener && this.emit("removeListener", Y, ee.listener || X));
  else if (typeof ee != "function") {
    for (ne = -1, ie = ee.length - 1; ie >= 0; ie--)
      if (ee[ie] === X || ee[ie].listener === X) {
        oe = ee[ie].listener, ne = ie;
        break;
      }
    if (ne < 0)
      return this;
    ne === 0 ? ee.shift() : FP(ee, ne), ee.length === 1 && (te[Y] = ee[0]), te.removeListener !== void 0 && this.emit("removeListener", Y, oe || X);
  }
  return this;
};
ir.prototype.off = ir.prototype.removeListener;
ir.prototype.removeAllListeners = function(Y) {
  var X, ee, te;
  if (ee = this._events, ee === void 0)
    return this;
  if (ee.removeListener === void 0)
    return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : ee[Y] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete ee[Y]), this;
  if (arguments.length === 0) {
    var ne = Object.keys(ee), ie;
    for (te = 0; te < ne.length; ++te)
      ie = ne[te], ie !== "removeListener" && this.removeAllListeners(ie);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if (X = ee[Y], typeof X == "function")
    this.removeListener(Y, X);
  else if (X !== void 0)
    for (te = X.length - 1; te >= 0; te--)
      this.removeListener(Y, X[te]);
  return this;
};
function O_(Y, X, ee) {
  var te = Y._events;
  if (te === void 0)
    return [];
  var ne = te[X];
  return ne === void 0 ? [] : typeof ne == "function" ? ee ? [ne.listener || ne] : [ne] : ee ? $P(ne) : N_(ne, ne.length);
}
ir.prototype.listeners = function(Y) {
  return O_(this, Y, !0);
};
ir.prototype.rawListeners = function(Y) {
  return O_(this, Y, !1);
};
ir.listenerCount = function(Y, X) {
  return typeof Y.listenerCount == "function" ? Y.listenerCount(X) : B_.call(Y, X);
};
ir.prototype.listenerCount = B_;
function B_(Y) {
  var X = this._events;
  if (X !== void 0) {
    var ee = X[Y];
    if (typeof ee == "function")
      return 1;
    if (ee !== void 0)
      return ee.length;
  }
  return 0;
}
ir.prototype.eventNames = function() {
  return this._eventsCount > 0 ? Sl(this._events) : [];
};
function N_(Y, X) {
  for (var ee = new Array(X), te = 0; te < X; ++te)
    ee[te] = Y[te];
  return ee;
}
function FP(Y, X) {
  for (; X + 1 < Y.length; X++)
    Y[X] = Y[X + 1];
  Y.pop();
}
function $P(Y) {
  for (var X = new Array(Y.length), ee = 0; ee < X.length; ++ee)
    X[ee] = Y[ee].listener || Y[ee];
  return X;
}
function DP(Y, X) {
  return new Promise(function(ee, te) {
    function ne(oe) {
      Y.removeListener(X, ie), te(oe);
    }
    function ie() {
      typeof Y.removeListener == "function" && Y.removeListener("error", ne), ee([].slice.call(arguments));
    }
    k_(Y, X, ie, { once: !0 }), X !== "error" && UP(Y, ne, { once: !0 });
  });
}
function UP(Y, X, ee) {
  typeof Y.on == "function" && k_(Y, "error", X, ee);
}
function k_(Y, X, ee, te) {
  if (typeof Y.on == "function")
    te.once ? Y.once(X, ee) : Y.on(X, ee);
  else if (typeof Y.addEventListener == "function")
    Y.addEventListener(X, function ne(ie) {
      te.once && Y.removeEventListener(X, ne), ee(ie);
    });
  else
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof Y);
}
var jP = Mm.exports;
Object.defineProperty(qd, "__esModule", { value: !0 });
qd.AsyncEventEmitter = void 0;
const HP = jP;
async function zP(Y, X, ee) {
  let te;
  for await (const ne of X)
    try {
      ne.length < 2 ? ne.call(Y, ee) : await new Promise((ie, oe) => {
        ne.call(Y, ee, (se) => {
          se ? oe(se) : ie();
        });
      });
    } catch (ie) {
      te = ie;
    }
  if (te)
    throw te;
}
class qP extends HP.EventEmitter {
  emit(X, ...ee) {
    let [te, ne] = ee;
    const ie = this;
    let oe = ie._events[X] ?? [];
    return ne === void 0 && typeof te == "function" && (ne = te, te = void 0), (X === "newListener" || X === "removeListener") && (te = {
      event: te,
      fn: ne
    }, ne = void 0), oe = Array.isArray(oe) ? oe : [oe], zP(ie, oe.slice(), te).then(ne).catch(ne), ie.listenerCount(X) > 0;
  }
  once(X, ee) {
    const te = this;
    let ne;
    if (typeof ee != "function")
      throw new TypeError("listener must be a function");
    return ee.length >= 2 ? ne = function(ie, oe) {
      te.removeListener(X, ne), ee(ie, oe);
    } : ne = function(ie) {
      te.removeListener(X, ne), ee(ie, ne);
    }, te.on(X, ne), te;
  }
  first(X, ee) {
    let te = this._events[X] ?? [];
    if (typeof ee != "function")
      throw new TypeError("listener must be a function");
    return Array.isArray(te) || (this._events[X] = te = [te]), te.unshift(ee), this;
  }
  before(X, ee, te) {
    return this.beforeOrAfter(X, ee, te);
  }
  after(X, ee, te) {
    return this.beforeOrAfter(X, ee, te, "after");
  }
  beforeOrAfter(X, ee, te, ne) {
    let ie = this._events[X] ?? [], oe, se;
    const ae = ne === "after" ? 1 : 0;
    if (typeof te != "function")
      throw new TypeError("listener must be a function");
    if (typeof ee != "function")
      throw new TypeError("target must be a function");
    for (Array.isArray(ie) || (this._events[X] = ie = [ie]), se = ie.length, oe = ie.length; oe--; )
      if (ie[oe] === ee) {
        se = oe + ae;
        break;
      }
    return ie.splice(se, 0, te), this;
  }
  on(X, ee) {
    return super.on(X, ee);
  }
  addListener(X, ee) {
    return super.addListener(X, ee);
  }
  prependListener(X, ee) {
    return super.prependListener(X, ee);
  }
  prependOnceListener(X, ee) {
    return super.prependOnceListener(X, ee);
  }
  removeAllListeners(X) {
    return super.removeAllListeners(X);
  }
  removeListener(X, ee) {
    return super.removeListener(X, ee);
  }
  eventNames() {
    return super.eventNames();
  }
  listeners(X) {
    return super.listeners(X);
  }
  listenerCount(X) {
    return super.listenerCount(X);
  }
  getMaxListeners() {
    return super.getMaxListeners();
  }
  setMaxListeners(X) {
    return super.setMaxListeners(X);
  }
}
qd.AsyncEventEmitter = qP;
var Vd = {};
Object.defineProperty(Vd, "__esModule", { value: !0 });
Vd.Lock = void 0;
class GP {
  constructor() {
    this.permits = 1, this.promiseResolverQueue = [];
  }
  /**
   * Returns a promise used to wait for a permit to become available. This method should be awaited on.
   * @returns  A promise that gets resolved when execution is allowed to proceed.
   */
  async acquire() {
    return this.permits > 0 ? (this.permits -= 1, Promise.resolve(!0)) : new Promise((X) => this.promiseResolverQueue.push(X));
  }
  /**
   * Increases the number of permits by one. If there are other functions waiting, one of them will
   * continue to execute in a future iteration of the event loop.
   */
  release() {
    if (this.permits += 1, this.permits > 1 && this.promiseResolverQueue.length > 0)
      console.warn("Lock.permits should never be > 0 when there is someone waiting.");
    else if (this.permits === 1 && this.promiseResolverQueue.length > 0) {
      this.permits -= 1;
      const X = this.promiseResolverQueue.shift();
      X && X(!0);
    }
  }
}
Vd.Lock = GP;
var Ja = {}, Lo = {}, mh = {}, yh = {}, bh, u1;
function M_() {
  return u1 || (u1 = 1, bh = function() {
    if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
      return !1;
    if (typeof Symbol.iterator == "symbol")
      return !0;
    var Y = {}, X = Symbol("test"), ee = Object(X);
    if (typeof X == "string" || Object.prototype.toString.call(X) !== "[object Symbol]" || Object.prototype.toString.call(ee) !== "[object Symbol]")
      return !1;
    var te = 42;
    Y[X] = te;
    for (X in Y)
      return !1;
    if (typeof Object.keys == "function" && Object.keys(Y).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(Y).length !== 0)
      return !1;
    var ne = Object.getOwnPropertySymbols(Y);
    if (ne.length !== 1 || ne[0] !== X || !Object.prototype.propertyIsEnumerable.call(Y, X))
      return !1;
    if (typeof Object.getOwnPropertyDescriptor == "function") {
      var ie = Object.getOwnPropertyDescriptor(Y, X);
      if (ie.value !== te || ie.enumerable !== !0)
        return !1;
    }
    return !0;
  }), bh;
}
var xh, f1;
function Lm() {
  if (f1)
    return xh;
  f1 = 1;
  var Y = M_();
  return xh = function() {
    return Y() && !!Symbol.toStringTag;
  }, xh;
}
var wh, l1;
function VP() {
  return l1 || (l1 = 1, wh = Error), wh;
}
var vh, d1;
function WP() {
  return d1 || (d1 = 1, vh = EvalError), vh;
}
var Eh, h1;
function KP() {
  return h1 || (h1 = 1, Eh = RangeError), Eh;
}
var _h, p1;
function JP() {
  return p1 || (p1 = 1, _h = ReferenceError), _h;
}
var Ah, g1;
function L_() {
  return g1 || (g1 = 1, Ah = SyntaxError), Ah;
}
var Sh, m1;
function hf() {
  return m1 || (m1 = 1, Sh = TypeError), Sh;
}
var Th, y1;
function YP() {
  return y1 || (y1 = 1, Th = URIError), Th;
}
var Ih, b1;
function XP() {
  if (b1)
    return Ih;
  b1 = 1;
  var Y = typeof Symbol < "u" && Symbol, X = M_();
  return Ih = function() {
    return typeof Y != "function" || typeof Symbol != "function" || typeof Y("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : X();
  }, Ih;
}
var Rh, x1;
function ZP() {
  if (x1)
    return Rh;
  x1 = 1;
  var Y = {
    __proto__: null,
    foo: {}
  }, X = Object;
  return Rh = function() {
    return { __proto__: Y }.foo === Y.foo && !(Y instanceof X);
  }, Rh;
}
var Ch$1, w1;
function QP() {
  if (w1)
    return Ch$1;
  w1 = 1;
  var Y = "Function.prototype.bind called on incompatible ", X = Object.prototype.toString, ee = Math.max, te = "[object Function]", ne = function(se, ae) {
    for (var ue = [], le = 0; le < se.length; le += 1)
      ue[le] = se[le];
    for (var he = 0; he < ae.length; he += 1)
      ue[he + se.length] = ae[he];
    return ue;
  }, ie = function(se, ae) {
    for (var ue = [], le = ae || 0, he = 0; le < se.length; le += 1, he += 1)
      ue[he] = se[le];
    return ue;
  }, oe = function(se, ae) {
    for (var ue = "", le = 0; le < se.length; le += 1)
      ue += se[le], le + 1 < se.length && (ue += ae);
    return ue;
  };
  return Ch$1 = function(se) {
    var ae = this;
    if (typeof ae != "function" || X.apply(ae) !== te)
      throw new TypeError(Y + ae);
    for (var ue = ie(arguments, 1), le, he = function() {
      if (this instanceof le) {
        var Re = ae.apply(
          this,
          ne(ue, arguments)
        );
        return Object(Re) === Re ? Re : this;
      }
      return ae.apply(
        se,
        ne(ue, arguments)
      );
    }, me = ee(0, ae.length - ue.length), ye = [], we = 0; we < me; we++)
      ye[we] = "$" + we;
    if (le = Function("binder", "return function (" + oe(ye, ",") + "){ return binder.apply(this,arguments); }")(he), ae.prototype) {
      var Ee = function() {
      };
      Ee.prototype = ae.prototype, le.prototype = new Ee(), Ee.prototype = null;
    }
    return le;
  }, Ch$1;
}
var Ph, v1$1;
function Fm() {
  if (v1$1)
    return Ph;
  v1$1 = 1;
  var Y = QP();
  return Ph = Function.prototype.bind || Y, Ph;
}
var Oh, E1;
function eO() {
  if (E1)
    return Oh;
  E1 = 1;
  var Y = Function.prototype.call, X = Object.prototype.hasOwnProperty, ee = Fm();
  return Oh = ee.call(Y, X), Oh;
}
var Bh, _1$2;
function wc() {
  if (_1$2)
    return Bh;
  _1$2 = 1;
  var Y, X = VP(), ee = WP(), te = KP(), ne = JP(), ie = L_(), oe = hf(), se = YP(), ae = Function, ue = function(Ce) {
    try {
      return ae('"use strict"; return (' + Ce + ").constructor;")();
    } catch {
    }
  }, le = Object.getOwnPropertyDescriptor;
  if (le)
    try {
      le({}, "");
    } catch {
      le = null;
    }
  var he = function() {
    throw new oe();
  }, me = le ? function() {
    try {
      return arguments.callee, he;
    } catch {
      try {
        return le(arguments, "callee").get;
      } catch {
        return he;
      }
    }
  }() : he, ye = XP()(), we = ZP()(), Ee = Object.getPrototypeOf || (we ? function(Ce) {
    return Ce.__proto__;
  } : null), Re = {}, Ue = typeof Uint8Array > "u" || !Ee ? Y : Ee(Uint8Array), Me = {
    __proto__: null,
    "%AggregateError%": typeof AggregateError > "u" ? Y : AggregateError,
    "%Array%": Array,
    "%ArrayBuffer%": typeof ArrayBuffer > "u" ? Y : ArrayBuffer,
    "%ArrayIteratorPrototype%": ye && Ee ? Ee([][Symbol.iterator]()) : Y,
    "%AsyncFromSyncIteratorPrototype%": Y,
    "%AsyncFunction%": Re,
    "%AsyncGenerator%": Re,
    "%AsyncGeneratorFunction%": Re,
    "%AsyncIteratorPrototype%": Re,
    "%Atomics%": typeof Atomics > "u" ? Y : Atomics,
    "%BigInt%": typeof BigInt > "u" ? Y : BigInt,
    "%BigInt64Array%": typeof BigInt64Array > "u" ? Y : BigInt64Array,
    "%BigUint64Array%": typeof BigUint64Array > "u" ? Y : BigUint64Array,
    "%Boolean%": Boolean,
    "%DataView%": typeof DataView > "u" ? Y : DataView,
    "%Date%": Date,
    "%decodeURI%": decodeURI,
    "%decodeURIComponent%": decodeURIComponent,
    "%encodeURI%": encodeURI,
    "%encodeURIComponent%": encodeURIComponent,
    "%Error%": X,
    "%eval%": eval,
    // eslint-disable-line no-eval
    "%EvalError%": ee,
    "%Float32Array%": typeof Float32Array > "u" ? Y : Float32Array,
    "%Float64Array%": typeof Float64Array > "u" ? Y : Float64Array,
    "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? Y : FinalizationRegistry,
    "%Function%": ae,
    "%GeneratorFunction%": Re,
    "%Int8Array%": typeof Int8Array > "u" ? Y : Int8Array,
    "%Int16Array%": typeof Int16Array > "u" ? Y : Int16Array,
    "%Int32Array%": typeof Int32Array > "u" ? Y : Int32Array,
    "%isFinite%": isFinite,
    "%isNaN%": isNaN,
    "%IteratorPrototype%": ye && Ee ? Ee(Ee([][Symbol.iterator]())) : Y,
    "%JSON%": typeof JSON == "object" ? JSON : Y,
    "%Map%": typeof Map > "u" ? Y : Map,
    "%MapIteratorPrototype%": typeof Map > "u" || !ye || !Ee ? Y : Ee((/* @__PURE__ */ new Map())[Symbol.iterator]()),
    "%Math%": Math,
    "%Number%": Number,
    "%Object%": Object,
    "%parseFloat%": parseFloat,
    "%parseInt%": parseInt,
    "%Promise%": typeof Promise > "u" ? Y : Promise,
    "%Proxy%": typeof Proxy > "u" ? Y : Proxy,
    "%RangeError%": te,
    "%ReferenceError%": ne,
    "%Reflect%": typeof Reflect > "u" ? Y : Reflect,
    "%RegExp%": RegExp,
    "%Set%": typeof Set > "u" ? Y : Set,
    "%SetIteratorPrototype%": typeof Set > "u" || !ye || !Ee ? Y : Ee((/* @__PURE__ */ new Set())[Symbol.iterator]()),
    "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? Y : SharedArrayBuffer,
    "%String%": String,
    "%StringIteratorPrototype%": ye && Ee ? Ee(""[Symbol.iterator]()) : Y,
    "%Symbol%": ye ? Symbol : Y,
    "%SyntaxError%": ie,
    "%ThrowTypeError%": me,
    "%TypedArray%": Ue,
    "%TypeError%": oe,
    "%Uint8Array%": typeof Uint8Array > "u" ? Y : Uint8Array,
    "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? Y : Uint8ClampedArray,
    "%Uint16Array%": typeof Uint16Array > "u" ? Y : Uint16Array,
    "%Uint32Array%": typeof Uint32Array > "u" ? Y : Uint32Array,
    "%URIError%": se,
    "%WeakMap%": typeof WeakMap > "u" ? Y : WeakMap,
    "%WeakRef%": typeof WeakRef > "u" ? Y : WeakRef,
    "%WeakSet%": typeof WeakSet > "u" ? Y : WeakSet
  };
  if (Ee)
    try {
      null.error;
    } catch (Ce) {
      var De = Ee(Ee(Ce));
      Me["%Error.prototype%"] = De;
    }
  var Fe = function Ce(Pe) {
    var Se;
    if (Pe === "%AsyncFunction%")
      Se = ue("async function () {}");
    else if (Pe === "%GeneratorFunction%")
      Se = ue("function* () {}");
    else if (Pe === "%AsyncGeneratorFunction%")
      Se = ue("async function* () {}");
    else if (Pe === "%AsyncGenerator%") {
      var ke = Ce("%AsyncGeneratorFunction%");
      ke && (Se = ke.prototype);
    } else if (Pe === "%AsyncIteratorPrototype%") {
      var ge = Ce("%AsyncGenerator%");
      ge && Ee && (Se = Ee(ge.prototype));
    }
    return Me[Pe] = Se, Se;
  }, Ke = {
    __proto__: null,
    "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
    "%ArrayPrototype%": ["Array", "prototype"],
    "%ArrayProto_entries%": ["Array", "prototype", "entries"],
    "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
    "%ArrayProto_keys%": ["Array", "prototype", "keys"],
    "%ArrayProto_values%": ["Array", "prototype", "values"],
    "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
    "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
    "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
    "%BooleanPrototype%": ["Boolean", "prototype"],
    "%DataViewPrototype%": ["DataView", "prototype"],
    "%DatePrototype%": ["Date", "prototype"],
    "%ErrorPrototype%": ["Error", "prototype"],
    "%EvalErrorPrototype%": ["EvalError", "prototype"],
    "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
    "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
    "%FunctionPrototype%": ["Function", "prototype"],
    "%Generator%": ["GeneratorFunction", "prototype"],
    "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
    "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
    "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
    "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
    "%JSONParse%": ["JSON", "parse"],
    "%JSONStringify%": ["JSON", "stringify"],
    "%MapPrototype%": ["Map", "prototype"],
    "%NumberPrototype%": ["Number", "prototype"],
    "%ObjectPrototype%": ["Object", "prototype"],
    "%ObjProto_toString%": ["Object", "prototype", "toString"],
    "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
    "%PromisePrototype%": ["Promise", "prototype"],
    "%PromiseProto_then%": ["Promise", "prototype", "then"],
    "%Promise_all%": ["Promise", "all"],
    "%Promise_reject%": ["Promise", "reject"],
    "%Promise_resolve%": ["Promise", "resolve"],
    "%RangeErrorPrototype%": ["RangeError", "prototype"],
    "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
    "%RegExpPrototype%": ["RegExp", "prototype"],
    "%SetPrototype%": ["Set", "prototype"],
    "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
    "%StringPrototype%": ["String", "prototype"],
    "%SymbolPrototype%": ["Symbol", "prototype"],
    "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
    "%TypedArrayPrototype%": ["TypedArray", "prototype"],
    "%TypeErrorPrototype%": ["TypeError", "prototype"],
    "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
    "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
    "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
    "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
    "%URIErrorPrototype%": ["URIError", "prototype"],
    "%WeakMapPrototype%": ["WeakMap", "prototype"],
    "%WeakSetPrototype%": ["WeakSet", "prototype"]
  }, tt = Fm(), rt = eO(), it = tt.call(Function.call, Array.prototype.concat), _t = tt.call(Function.apply, Array.prototype.splice), Dt = tt.call(Function.call, String.prototype.replace), je = tt.call(Function.call, String.prototype.slice), ze = tt.call(Function.call, RegExp.prototype.exec), fe = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, de = /\\(\\)?/g, be = function(Ce) {
    var Pe = je(Ce, 0, 1), Se = je(Ce, -1);
    if (Pe === "%" && Se !== "%")
      throw new ie("invalid intrinsic syntax, expected closing `%`");
    if (Se === "%" && Pe !== "%")
      throw new ie("invalid intrinsic syntax, expected opening `%`");
    var ke = [];
    return Dt(Ce, fe, function(ge, Ae, Ge, Xe) {
      ke[ke.length] = Ge ? Dt(Xe, de, "$1") : Ae || ge;
    }), ke;
  }, Te = function(Ce, Pe) {
    var Se = Ce, ke;
    if (rt(Ke, Se) && (ke = Ke[Se], Se = "%" + ke[0] + "%"), rt(Me, Se)) {
      var ge = Me[Se];
      if (ge === Re && (ge = Fe(Se)), typeof ge > "u" && !Pe)
        throw new oe("intrinsic " + Ce + " exists, but is not available. Please file an issue!");
      return {
        alias: ke,
        name: Se,
        value: ge
      };
    }
    throw new ie("intrinsic " + Ce + " does not exist!");
  };
  return Bh = function(Ce, Pe) {
    if (typeof Ce != "string" || Ce.length === 0)
      throw new oe("intrinsic name must be a non-empty string");
    if (arguments.length > 1 && typeof Pe != "boolean")
      throw new oe('"allowMissing" argument must be a boolean');
    if (ze(/^%?[^%]*%?$/, Ce) === null)
      throw new ie("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
    var Se = be(Ce), ke = Se.length > 0 ? Se[0] : "", ge = Te("%" + ke + "%", Pe), Ae = ge.name, Ge = ge.value, Xe = !1, $e = ge.alias;
    $e && (ke = $e[0], _t(Se, it([0, 1], $e)));
    for (var Ze = 1, ot = !0; Ze < Se.length; Ze += 1) {
      var ct = Se[Ze], At = je(ct, 0, 1), Tt = je(ct, -1);
      if ((At === '"' || At === "'" || At === "`" || Tt === '"' || Tt === "'" || Tt === "`") && At !== Tt)
        throw new ie("property names with quotes must have matching quotes");
      if ((ct === "constructor" || !ot) && (Xe = !0), ke += "." + ct, Ae = "%" + ke + "%", rt(Me, Ae))
        Ge = Me[Ae];
      else if (Ge != null) {
        if (!(ct in Ge)) {
          if (!Pe)
            throw new oe("base intrinsic for " + Ce + " exists, but the property is not available.");
          return;
        }
        if (le && Ze + 1 >= Se.length) {
          var dt = le(Ge, ct);
          ot = !!dt, ot && "get" in dt && !("originalValue" in dt.get) ? Ge = dt.get : Ge = Ge[ct];
        } else
          ot = rt(Ge, ct), Ge = Ge[ct];
        ot && !Xe && (Me[Ae] = Ge);
      }
    }
    return Ge;
  }, Bh;
}
var Nh = { exports: {} }, kh, A1;
function $m() {
  if (A1)
    return kh;
  A1 = 1;
  var Y = wc(), X = Y("%Object.defineProperty%", !0) || !1;
  if (X)
    try {
      X({}, "a", { value: 1 });
    } catch {
      X = !1;
    }
  return kh = X, kh;
}
var Mh, S1;
function Dm() {
  if (S1)
    return Mh;
  S1 = 1;
  var Y = wc(), X = Y("%Object.getOwnPropertyDescriptor%", !0);
  if (X)
    try {
      X([], "length");
    } catch {
      X = null;
    }
  return Mh = X, Mh;
}
var Lh, T1;
function tO() {
  if (T1)
    return Lh;
  T1 = 1;
  var Y = $m(), X = L_(), ee = hf(), te = Dm();
  return Lh = function(ne, ie, oe) {
    if (!ne || typeof ne != "object" && typeof ne != "function")
      throw new ee("`obj` must be an object or a function`");
    if (typeof ie != "string" && typeof ie != "symbol")
      throw new ee("`property` must be a string or a symbol`");
    if (arguments.length > 3 && typeof arguments[3] != "boolean" && arguments[3] !== null)
      throw new ee("`nonEnumerable`, if provided, must be a boolean or null");
    if (arguments.length > 4 && typeof arguments[4] != "boolean" && arguments[4] !== null)
      throw new ee("`nonWritable`, if provided, must be a boolean or null");
    if (arguments.length > 5 && typeof arguments[5] != "boolean" && arguments[5] !== null)
      throw new ee("`nonConfigurable`, if provided, must be a boolean or null");
    if (arguments.length > 6 && typeof arguments[6] != "boolean")
      throw new ee("`loose`, if provided, must be a boolean");
    var se = arguments.length > 3 ? arguments[3] : null, ae = arguments.length > 4 ? arguments[4] : null, ue = arguments.length > 5 ? arguments[5] : null, le = arguments.length > 6 ? arguments[6] : !1, he = !!te && te(ne, ie);
    if (Y)
      Y(ne, ie, {
        configurable: ue === null && he ? he.configurable : !ue,
        enumerable: se === null && he ? he.enumerable : !se,
        value: oe,
        writable: ae === null && he ? he.writable : !ae
      });
    else if (le || !se && !ae && !ue)
      ne[ie] = oe;
    else
      throw new X("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
  }, Lh;
}
var Fh, I1;
function rO() {
  if (I1)
    return Fh;
  I1 = 1;
  var Y = $m(), X = function() {
    return !!Y;
  };
  return X.hasArrayLengthDefineBug = function() {
    if (!Y)
      return null;
    try {
      return Y([], "length", { value: 1 }).length !== 1;
    } catch {
      return !0;
    }
  }, Fh = X, Fh;
}
var $h, R1;
function nO() {
  if (R1)
    return $h;
  R1 = 1;
  var Y = wc(), X = tO(), ee = rO()(), te = Dm(), ne = hf(), ie = Y("%Math.floor%");
  return $h = function(oe, se) {
    if (typeof oe != "function")
      throw new ne("`fn` is not a function");
    if (typeof se != "number" || se < 0 || se > 4294967295 || ie(se) !== se)
      throw new ne("`length` must be a positive 32-bit integer");
    var ae = arguments.length > 2 && !!arguments[2], ue = !0, le = !0;
    if ("length" in oe && te) {
      var he = te(oe, "length");
      he && !he.configurable && (ue = !1), he && !he.writable && (le = !1);
    }
    return (ue || le || !ae) && (ee ? X(
      /** @type {Parameters<define>[0]} */
      oe,
      "length",
      se,
      !0,
      !0
    ) : X(
      /** @type {Parameters<define>[0]} */
      oe,
      "length",
      se
    )), oe;
  }, $h;
}
var C1;
function F_() {
  return C1 || (C1 = 1, function(Y) {
    var X = Fm(), ee = wc(), te = nO(), ne = hf(), ie = ee("%Function.prototype.apply%"), oe = ee("%Function.prototype.call%"), se = ee("%Reflect.apply%", !0) || X.call(oe, ie), ae = $m(), ue = ee("%Math.max%");
    Y.exports = function(he) {
      if (typeof he != "function")
        throw new ne("a function is required");
      var me = se(X, oe, arguments);
      return te(
        me,
        1 + ue(0, he.length - (arguments.length - 1)),
        !0
      );
    };
    var le = function() {
      return se(X, ie, arguments);
    };
    ae ? ae(Y.exports, "apply", { value: le }) : Y.exports.apply = le;
  }(Nh)), Nh.exports;
}
var Dh, P1;
function Um() {
  if (P1)
    return Dh;
  P1 = 1;
  var Y = wc(), X = F_(), ee = X(Y("String.prototype.indexOf"));
  return Dh = function(te, ne) {
    var ie = Y(te, !!ne);
    return typeof ie == "function" && ee(te, ".prototype.") > -1 ? X(ie) : ie;
  }, Dh;
}
var Uh, O1;
function iO() {
  if (O1)
    return Uh;
  O1 = 1;
  var Y = Lm()(), X = Um(), ee = X("Object.prototype.toString"), te = function(oe) {
    return Y && oe && typeof oe == "object" && Symbol.toStringTag in oe ? !1 : ee(oe) === "[object Arguments]";
  }, ne = function(oe) {
    return te(oe) ? !0 : oe !== null && typeof oe == "object" && typeof oe.length == "number" && oe.length >= 0 && ee(oe) !== "[object Array]" && ee(oe.callee) === "[object Function]";
  }, ie = function() {
    return te(arguments);
  }();
  return te.isLegacyArguments = ne, Uh = ie ? te : ne, Uh;
}
var jh, B1;
function sO() {
  if (B1)
    return jh;
  B1 = 1;
  var Y = Object.prototype.toString, X = Function.prototype.toString, ee = /^\s*(?:function)?\*/, te = Lm()(), ne = Object.getPrototypeOf, ie = function() {
    if (!te)
      return !1;
    try {
      return Function("return function*() {}")();
    } catch {
    }
  }, oe;
  return jh = function(se) {
    if (typeof se != "function")
      return !1;
    if (ee.test(X.call(se)))
      return !0;
    if (!te) {
      var ae = Y.call(se);
      return ae === "[object GeneratorFunction]";
    }
    if (!ne)
      return !1;
    if (typeof oe > "u") {
      var ue = ie();
      oe = ue ? ne(ue) : !1;
    }
    return ne(se) === oe;
  }, jh;
}
var Hh, N1;
function oO() {
  if (N1)
    return Hh;
  N1 = 1;
  var Y = Function.prototype.toString, X = typeof Reflect == "object" && Reflect !== null && Reflect.apply, ee, te;
  if (typeof X == "function" && typeof Object.defineProperty == "function")
    try {
      ee = Object.defineProperty({}, "length", {
        get: function() {
          throw te;
        }
      }), te = {}, X(function() {
        throw 42;
      }, null, ee);
    } catch (Me) {
      Me !== te && (X = null);
    }
  else
    X = null;
  var ne = /^\s*class\b/, ie = function(Me) {
    try {
      var De = Y.call(Me);
      return ne.test(De);
    } catch {
      return !1;
    }
  }, oe = function(Me) {
    try {
      return ie(Me) ? !1 : (Y.call(Me), !0);
    } catch {
      return !1;
    }
  }, se = Object.prototype.toString, ae = "[object Object]", ue = "[object Function]", le = "[object GeneratorFunction]", he = "[object HTMLAllCollection]", me = "[object HTML document.all class]", ye = "[object HTMLCollection]", we = typeof Symbol == "function" && !!Symbol.toStringTag, Ee = !(0 in [,]), Re = function() {
    return !1;
  };
  if (typeof document == "object") {
    var Ue = document.all;
    se.call(Ue) === se.call(document.all) && (Re = function(Me) {
      if ((Ee || !Me) && (typeof Me > "u" || typeof Me == "object"))
        try {
          var De = se.call(Me);
          return (De === he || De === me || De === ye || De === ae) && Me("") == null;
        } catch {
        }
      return !1;
    });
  }
  return Hh = X ? function(Me) {
    if (Re(Me))
      return !0;
    if (!Me || typeof Me != "function" && typeof Me != "object")
      return !1;
    try {
      X(Me, null, ee);
    } catch (De) {
      if (De !== te)
        return !1;
    }
    return !ie(Me) && oe(Me);
  } : function(Me) {
    if (Re(Me))
      return !0;
    if (!Me || typeof Me != "function" && typeof Me != "object")
      return !1;
    if (we)
      return oe(Me);
    if (ie(Me))
      return !1;
    var De = se.call(Me);
    return De !== ue && De !== le && !/^\[object HTML/.test(De) ? !1 : oe(Me);
  }, Hh;
}
var zh, k1;
function aO() {
  if (k1)
    return zh;
  k1 = 1;
  var Y = oO(), X = Object.prototype.toString, ee = Object.prototype.hasOwnProperty, te = function(se, ae, ue) {
    for (var le = 0, he = se.length; le < he; le++)
      ee.call(se, le) && (ue == null ? ae(se[le], le, se) : ae.call(ue, se[le], le, se));
  }, ne = function(se, ae, ue) {
    for (var le = 0, he = se.length; le < he; le++)
      ue == null ? ae(se.charAt(le), le, se) : ae.call(ue, se.charAt(le), le, se);
  }, ie = function(se, ae, ue) {
    for (var le in se)
      ee.call(se, le) && (ue == null ? ae(se[le], le, se) : ae.call(ue, se[le], le, se));
  }, oe = function(se, ae, ue) {
    if (!Y(ae))
      throw new TypeError("iterator must be a function");
    var le;
    arguments.length >= 3 && (le = ue), X.call(se) === "[object Array]" ? te(se, ae, le) : typeof se == "string" ? ne(se, ae, le) : ie(se, ae, le);
  };
  return zh = oe, zh;
}
var qh, M1;
function cO() {
  return M1 || (M1 = 1, qh = [
    "Float32Array",
    "Float64Array",
    "Int8Array",
    "Int16Array",
    "Int32Array",
    "Uint8Array",
    "Uint8ClampedArray",
    "Uint16Array",
    "Uint32Array",
    "BigInt64Array",
    "BigUint64Array"
  ]), qh;
}
var Gh, L1;
function uO() {
  if (L1)
    return Gh;
  L1 = 1;
  var Y = cO(), X = typeof globalThis > "u" ? St : globalThis;
  return Gh = function() {
    for (var ee = [], te = 0; te < Y.length; te++)
      typeof X[Y[te]] == "function" && (ee[ee.length] = Y[te]);
    return ee;
  }, Gh;
}
var Vh, F1;
function $_() {
  if (F1)
    return Vh;
  F1 = 1;
  var Y = aO(), X = uO(), ee = F_(), te = Um(), ne = Dm(), ie = te("Object.prototype.toString"), oe = Lm()(), se = typeof globalThis > "u" ? St : globalThis, ae = X(), ue = te("String.prototype.slice"), le = Object.getPrototypeOf, he = te("Array.prototype.indexOf", !0) || /** @type {(array: readonly unknown[], value: unknown) => keyof array} */
  function(Ee, Re) {
    for (var Ue = 0; Ue < Ee.length; Ue += 1)
      if (Ee[Ue] === Re)
        return Ue;
    return -1;
  }, me = { __proto__: null };
  oe && ne && le ? Y(ae, function(Ee) {
    var Re = new se[Ee]();
    if (Symbol.toStringTag in Re) {
      var Ue = le(Re), Me = ne(Ue, Symbol.toStringTag);
      if (!Me) {
        var De = le(Ue);
        Me = ne(De, Symbol.toStringTag);
      }
      me["$" + Ee] = ee(Me.get);
    }
  }) : Y(ae, function(Ee) {
    var Re = new se[Ee](), Ue = Re.slice || Re.set;
    Ue && (me["$" + Ee] = ee(Ue));
  });
  var ye = function(Ee) {
    var Re = !1;
    return Y(
      // eslint-disable-next-line no-extra-parens
      /** @type {Record<`\$${TypedArrayName}`, typeof cache>} */
      /** @type {any} */
      me,
      /** @type {(getter: typeof cache, name: `\$${TypedArrayName}`) => void} */
      function(Ue, Me) {
        if (!Re)
          try {
            "$" + Ue(Ee) === Me && (Re = ue(Me, 1));
          } catch {
          }
      }
    ), Re;
  }, we = function(Ee) {
    var Re = !1;
    return Y(
      // eslint-disable-next-line no-extra-parens
      /** @type {any} */
      me,
      /** @type {(getter: typeof cache, name: `\$${TypedArrayName}`) => void} */
      function(Ue, Me) {
        if (!Re)
          try {
            Ue(Ee), Re = ue(Me, 1);
          } catch {
          }
      }
    ), Re;
  };
  return Vh = function(Ee) {
    if (!Ee || typeof Ee != "object")
      return !1;
    if (!oe) {
      var Re = ue(ie(Ee), 8, -1);
      return he(ae, Re) > -1 ? Re : Re !== "Object" ? !1 : we(Ee);
    }
    return ne ? ye(Ee) : null;
  }, Vh;
}
var Wh, $1;
function fO() {
  if ($1)
    return Wh;
  $1 = 1;
  var Y = $_();
  return Wh = function(X) {
    return !!Y(X);
  }, Wh;
}
var D1;
function lO() {
  return D1 || (D1 = 1, function(Y) {
    var X = iO(), ee = sO(), te = $_(), ne = fO();
    function ie(Ct) {
      return Ct.call.bind(Ct);
    }
    var oe = typeof BigInt < "u", se = typeof Symbol < "u", ae = ie(Object.prototype.toString), ue = ie(Number.prototype.valueOf), le = ie(String.prototype.valueOf), he = ie(Boolean.prototype.valueOf);
    if (oe)
      var me = ie(BigInt.prototype.valueOf);
    if (se)
      var ye = ie(Symbol.prototype.valueOf);
    function we(Ct, w_) {
      if (typeof Ct != "object")
        return !1;
      try {
        return w_(Ct), !0;
      } catch {
        return !1;
      }
    }
    Y.isArgumentsObject = X, Y.isGeneratorFunction = ee, Y.isTypedArray = ne;
    function Ee(Ct) {
      return typeof Promise < "u" && Ct instanceof Promise || Ct !== null && typeof Ct == "object" && typeof Ct.then == "function" && typeof Ct.catch == "function";
    }
    Y.isPromise = Ee;
    function Re(Ct) {
      return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? ArrayBuffer.isView(Ct) : ne(Ct) || Ge(Ct);
    }
    Y.isArrayBufferView = Re;
    function Ue(Ct) {
      return te(Ct) === "Uint8Array";
    }
    Y.isUint8Array = Ue;
    function Me(Ct) {
      return te(Ct) === "Uint8ClampedArray";
    }
    Y.isUint8ClampedArray = Me;
    function De(Ct) {
      return te(Ct) === "Uint16Array";
    }
    Y.isUint16Array = De;
    function Fe(Ct) {
      return te(Ct) === "Uint32Array";
    }
    Y.isUint32Array = Fe;
    function Ke(Ct) {
      return te(Ct) === "Int8Array";
    }
    Y.isInt8Array = Ke;
    function tt(Ct) {
      return te(Ct) === "Int16Array";
    }
    Y.isInt16Array = tt;
    function rt(Ct) {
      return te(Ct) === "Int32Array";
    }
    Y.isInt32Array = rt;
    function it(Ct) {
      return te(Ct) === "Float32Array";
    }
    Y.isFloat32Array = it;
    function _t(Ct) {
      return te(Ct) === "Float64Array";
    }
    Y.isFloat64Array = _t;
    function Dt(Ct) {
      return te(Ct) === "BigInt64Array";
    }
    Y.isBigInt64Array = Dt;
    function je(Ct) {
      return te(Ct) === "BigUint64Array";
    }
    Y.isBigUint64Array = je;
    function ze(Ct) {
      return ae(Ct) === "[object Map]";
    }
    ze.working = typeof Map < "u" && ze(/* @__PURE__ */ new Map());
    function fe(Ct) {
      return typeof Map > "u" ? !1 : ze.working ? ze(Ct) : Ct instanceof Map;
    }
    Y.isMap = fe;
    function de(Ct) {
      return ae(Ct) === "[object Set]";
    }
    de.working = typeof Set < "u" && de(/* @__PURE__ */ new Set());
    function be(Ct) {
      return typeof Set > "u" ? !1 : de.working ? de(Ct) : Ct instanceof Set;
    }
    Y.isSet = be;
    function Te(Ct) {
      return ae(Ct) === "[object WeakMap]";
    }
    Te.working = typeof WeakMap < "u" && Te(/* @__PURE__ */ new WeakMap());
    function Ce(Ct) {
      return typeof WeakMap > "u" ? !1 : Te.working ? Te(Ct) : Ct instanceof WeakMap;
    }
    Y.isWeakMap = Ce;
    function Pe(Ct) {
      return ae(Ct) === "[object WeakSet]";
    }
    Pe.working = typeof WeakSet < "u" && Pe(/* @__PURE__ */ new WeakSet());
    function Se(Ct) {
      return Pe(Ct);
    }
    Y.isWeakSet = Se;
    function ke(Ct) {
      return ae(Ct) === "[object ArrayBuffer]";
    }
    ke.working = typeof ArrayBuffer < "u" && ke(new ArrayBuffer());
    function ge(Ct) {
      return typeof ArrayBuffer > "u" ? !1 : ke.working ? ke(Ct) : Ct instanceof ArrayBuffer;
    }
    Y.isArrayBuffer = ge;
    function Ae(Ct) {
      return ae(Ct) === "[object DataView]";
    }
    Ae.working = typeof ArrayBuffer < "u" && typeof DataView < "u" && Ae(new DataView(new ArrayBuffer(1), 0, 1));
    function Ge(Ct) {
      return typeof DataView > "u" ? !1 : Ae.working ? Ae(Ct) : Ct instanceof DataView;
    }
    Y.isDataView = Ge;
    var Xe = typeof SharedArrayBuffer < "u" ? SharedArrayBuffer : void 0;
    function $e(Ct) {
      return ae(Ct) === "[object SharedArrayBuffer]";
    }
    function Ze(Ct) {
      return typeof Xe > "u" ? !1 : (typeof $e.working > "u" && ($e.working = $e(new Xe())), $e.working ? $e(Ct) : Ct instanceof Xe);
    }
    Y.isSharedArrayBuffer = Ze;
    function ot(Ct) {
      return ae(Ct) === "[object AsyncFunction]";
    }
    Y.isAsyncFunction = ot;
    function ct(Ct) {
      return ae(Ct) === "[object Map Iterator]";
    }
    Y.isMapIterator = ct;
    function At(Ct) {
      return ae(Ct) === "[object Set Iterator]";
    }
    Y.isSetIterator = At;
    function Tt(Ct) {
      return ae(Ct) === "[object Generator]";
    }
    Y.isGeneratorObject = Tt;
    function dt(Ct) {
      return ae(Ct) === "[object WebAssembly.Module]";
    }
    Y.isWebAssemblyCompiledModule = dt;
    function vt(Ct) {
      return we(Ct, ue);
    }
    Y.isNumberObject = vt;
    function Ut(Ct) {
      return we(Ct, le);
    }
    Y.isStringObject = Ut;
    function It(Ct) {
      return we(Ct, he);
    }
    Y.isBooleanObject = It;
    function Er(Ct) {
      return oe && we(Ct, me);
    }
    Y.isBigIntObject = Er;
    function Fr(Ct) {
      return se && we(Ct, ye);
    }
    Y.isSymbolObject = Fr;
    function an(Ct) {
      return vt(Ct) || Ut(Ct) || It(Ct) || Er(Ct) || Fr(Ct);
    }
    Y.isBoxedPrimitive = an;
    function wX(Ct) {
      return typeof Uint8Array < "u" && (ge(Ct) || Ze(Ct));
    }
    Y.isAnyArrayBuffer = wX, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(Ct) {
      Object.defineProperty(Y, Ct, {
        enumerable: !1,
        value: function() {
          throw new Error(Ct + " is not supported in userland");
        }
      });
    });
  }(yh)), yh;
}
var Kh$1, U1;
function dO() {
  return U1 || (U1 = 1, Kh$1 = function(Y) {
    return Y && typeof Y == "object" && typeof Y.copy == "function" && typeof Y.fill == "function" && typeof Y.readUInt8 == "function";
  }), Kh$1;
}
var j1;
function hO() {
  return j1 || (j1 = 1, function(Y) {
    var X = Object.getOwnPropertyDescriptors || function(Ae) {
      for (var Ge = Object.keys(Ae), Xe = {}, $e = 0; $e < Ge.length; $e++)
        Xe[Ge[$e]] = Object.getOwnPropertyDescriptor(Ae, Ge[$e]);
      return Xe;
    }, ee = /%[sdj%]/g;
    Y.format = function(Ae) {
      if (!Ke(Ae)) {
        for (var Ge = [], Xe = 0; Xe < arguments.length; Xe++)
          Ge.push(oe(arguments[Xe]));
        return Ge.join(" ");
      }
      for (var Xe = 1, $e = arguments, Ze = $e.length, ot = String(Ae).replace(ee, function(Tt) {
        if (Tt === "%%")
          return "%";
        if (Xe >= Ze)
          return Tt;
        switch (Tt) {
          case "%s":
            return String($e[Xe++]);
          case "%d":
            return Number($e[Xe++]);
          case "%j":
            try {
              return JSON.stringify($e[Xe++]);
            } catch {
              return "[Circular]";
            }
          default:
            return Tt;
        }
      }), ct = $e[Xe]; Xe < Ze; ct = $e[++Xe])
        Me(ct) || !_t(ct) ? ot += " " + ct : ot += " " + oe(ct);
      return ot;
    }, Y.deprecate = function(Ae, Ge) {
      if (typeof process < "u" && process.noDeprecation === !0)
        return Ae;
      if (typeof process > "u")
        return function() {
          return Y.deprecate(Ae, Ge).apply(this, arguments);
        };
      var Xe = !1;
      function $e() {
        if (!Xe) {
          if (process.throwDeprecation)
            throw new Error(Ge);
          process.traceDeprecation ? console.trace(Ge) : console.error(Ge), Xe = !0;
        }
        return Ae.apply(this, arguments);
      }
      return $e;
    };
    var te = {}, ne = /^$/;
    if (process.env.NODE_DEBUG) {
      var ie = process.env.NODE_DEBUG;
      ie = ie.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), ne = new RegExp("^" + ie + "$", "i");
    }
    Y.debuglog = function(Ae) {
      if (Ae = Ae.toUpperCase(), !te[Ae])
        if (ne.test(Ae)) {
          var Ge = process.pid;
          te[Ae] = function() {
            var Xe = Y.format.apply(Y, arguments);
            console.error("%s %d: %s", Ae, Ge, Xe);
          };
        } else
          te[Ae] = function() {
          };
      return te[Ae];
    };
    function oe(Ae, Ge) {
      var Xe = {
        seen: [],
        stylize: ae
      };
      return arguments.length >= 3 && (Xe.depth = arguments[2]), arguments.length >= 4 && (Xe.colors = arguments[3]), Ue(Ge) ? Xe.showHidden = Ge : Ge && Y._extend(Xe, Ge), rt(Xe.showHidden) && (Xe.showHidden = !1), rt(Xe.depth) && (Xe.depth = 2), rt(Xe.colors) && (Xe.colors = !1), rt(Xe.customInspect) && (Xe.customInspect = !0), Xe.colors && (Xe.stylize = se), le(Xe, Ae, Xe.depth);
    }
    Y.inspect = oe, oe.colors = {
      bold: [1, 22],
      italic: [3, 23],
      underline: [4, 24],
      inverse: [7, 27],
      white: [37, 39],
      grey: [90, 39],
      black: [30, 39],
      blue: [34, 39],
      cyan: [36, 39],
      green: [32, 39],
      magenta: [35, 39],
      red: [31, 39],
      yellow: [33, 39]
    }, oe.styles = {
      special: "cyan",
      number: "yellow",
      boolean: "yellow",
      undefined: "grey",
      null: "bold",
      string: "green",
      date: "magenta",
      // "name": intentionally not styling
      regexp: "red"
    };
    function se(Ae, Ge) {
      var Xe = oe.styles[Ge];
      return Xe ? "\x1B[" + oe.colors[Xe][0] + "m" + Ae + "\x1B[" + oe.colors[Xe][1] + "m" : Ae;
    }
    function ae(Ae, Ge) {
      return Ae;
    }
    function ue(Ae) {
      var Ge = {};
      return Ae.forEach(function(Xe, $e) {
        Ge[Xe] = !0;
      }), Ge;
    }
    function le(Ae, Ge, Xe) {
      if (Ae.customInspect && Ge && ze(Ge.inspect) && // Filter out the util module, it's inspect function is special
      Ge.inspect !== Y.inspect && // Also filter out any prototype objects using the circular check.
      !(Ge.constructor && Ge.constructor.prototype === Ge)) {
        var $e = Ge.inspect(Xe, Ae);
        return Ke($e) || ($e = le(Ae, $e, Xe)), $e;
      }
      var Ze = he(Ae, Ge);
      if (Ze)
        return Ze;
      var ot = Object.keys(Ge), ct = ue(ot);
      if (Ae.showHidden && (ot = Object.getOwnPropertyNames(Ge)), je(Ge) && (ot.indexOf("message") >= 0 || ot.indexOf("description") >= 0))
        return me(Ge);
      if (ot.length === 0) {
        if (ze(Ge)) {
          var At = Ge.name ? ": " + Ge.name : "";
          return Ae.stylize("[Function" + At + "]", "special");
        }
        if (it(Ge))
          return Ae.stylize(RegExp.prototype.toString.call(Ge), "regexp");
        if (Dt(Ge))
          return Ae.stylize(Date.prototype.toString.call(Ge), "date");
        if (je(Ge))
          return me(Ge);
      }
      var Tt = "", dt = !1, vt = ["{", "}"];
      if (Re(Ge) && (dt = !0, vt = ["[", "]"]), ze(Ge)) {
        var Ut = Ge.name ? ": " + Ge.name : "";
        Tt = " [Function" + Ut + "]";
      }
      if (it(Ge) && (Tt = " " + RegExp.prototype.toString.call(Ge)), Dt(Ge) && (Tt = " " + Date.prototype.toUTCString.call(Ge)), je(Ge) && (Tt = " " + me(Ge)), ot.length === 0 && (!dt || Ge.length == 0))
        return vt[0] + Tt + vt[1];
      if (Xe < 0)
        return it(Ge) ? Ae.stylize(RegExp.prototype.toString.call(Ge), "regexp") : Ae.stylize("[Object]", "special");
      Ae.seen.push(Ge);
      var It;
      return dt ? It = ye(Ae, Ge, Xe, ct, ot) : It = ot.map(function(Er) {
        return we(Ae, Ge, Xe, ct, Er, dt);
      }), Ae.seen.pop(), Ee(It, Tt, vt);
    }
    function he(Ae, Ge) {
      if (rt(Ge))
        return Ae.stylize("undefined", "undefined");
      if (Ke(Ge)) {
        var Xe = "'" + JSON.stringify(Ge).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
        return Ae.stylize(Xe, "string");
      }
      if (Fe(Ge))
        return Ae.stylize("" + Ge, "number");
      if (Ue(Ge))
        return Ae.stylize("" + Ge, "boolean");
      if (Me(Ge))
        return Ae.stylize("null", "null");
    }
    function me(Ae) {
      return "[" + Error.prototype.toString.call(Ae) + "]";
    }
    function ye(Ae, Ge, Xe, $e, Ze) {
      for (var ot = [], ct = 0, At = Ge.length; ct < At; ++ct)
        Pe(Ge, String(ct)) ? ot.push(we(
          Ae,
          Ge,
          Xe,
          $e,
          String(ct),
          !0
        )) : ot.push("");
      return Ze.forEach(function(Tt) {
        Tt.match(/^\d+$/) || ot.push(we(
          Ae,
          Ge,
          Xe,
          $e,
          Tt,
          !0
        ));
      }), ot;
    }
    function we(Ae, Ge, Xe, $e, Ze, ot) {
      var ct, At, Tt;
      if (Tt = Object.getOwnPropertyDescriptor(Ge, Ze) || { value: Ge[Ze] }, Tt.get ? Tt.set ? At = Ae.stylize("[Getter/Setter]", "special") : At = Ae.stylize("[Getter]", "special") : Tt.set && (At = Ae.stylize("[Setter]", "special")), Pe($e, Ze) || (ct = "[" + Ze + "]"), At || (Ae.seen.indexOf(Tt.value) < 0 ? (Me(Xe) ? At = le(Ae, Tt.value, null) : At = le(Ae, Tt.value, Xe - 1), At.indexOf(`
`) > -1 && (ot ? At = At.split(`
`).map(function(dt) {
        return "  " + dt;
      }).join(`
`).slice(2) : At = `
` + At.split(`
`).map(function(dt) {
        return "   " + dt;
      }).join(`
`))) : At = Ae.stylize("[Circular]", "special")), rt(ct)) {
        if (ot && Ze.match(/^\d+$/))
          return At;
        ct = JSON.stringify("" + Ze), ct.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (ct = ct.slice(1, -1), ct = Ae.stylize(ct, "name")) : (ct = ct.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), ct = Ae.stylize(ct, "string"));
      }
      return ct + ": " + At;
    }
    function Ee(Ae, Ge, Xe) {
      var $e = Ae.reduce(function(Ze, ot) {
        return ot.indexOf(`
`) >= 0, Ze + ot.replace(/\u001b\[\d\d?m/g, "").length + 1;
      }, 0);
      return $e > 60 ? Xe[0] + (Ge === "" ? "" : Ge + `
 `) + " " + Ae.join(`,
  `) + " " + Xe[1] : Xe[0] + Ge + " " + Ae.join(", ") + " " + Xe[1];
    }
    Y.types = lO();
    function Re(Ae) {
      return Array.isArray(Ae);
    }
    Y.isArray = Re;
    function Ue(Ae) {
      return typeof Ae == "boolean";
    }
    Y.isBoolean = Ue;
    function Me(Ae) {
      return Ae === null;
    }
    Y.isNull = Me;
    function De(Ae) {
      return Ae == null;
    }
    Y.isNullOrUndefined = De;
    function Fe(Ae) {
      return typeof Ae == "number";
    }
    Y.isNumber = Fe;
    function Ke(Ae) {
      return typeof Ae == "string";
    }
    Y.isString = Ke;
    function tt(Ae) {
      return typeof Ae == "symbol";
    }
    Y.isSymbol = tt;
    function rt(Ae) {
      return Ae === void 0;
    }
    Y.isUndefined = rt;
    function it(Ae) {
      return _t(Ae) && de(Ae) === "[object RegExp]";
    }
    Y.isRegExp = it, Y.types.isRegExp = it;
    function _t(Ae) {
      return typeof Ae == "object" && Ae !== null;
    }
    Y.isObject = _t;
    function Dt(Ae) {
      return _t(Ae) && de(Ae) === "[object Date]";
    }
    Y.isDate = Dt, Y.types.isDate = Dt;
    function je(Ae) {
      return _t(Ae) && (de(Ae) === "[object Error]" || Ae instanceof Error);
    }
    Y.isError = je, Y.types.isNativeError = je;
    function ze(Ae) {
      return typeof Ae == "function";
    }
    Y.isFunction = ze;
    function fe(Ae) {
      return Ae === null || typeof Ae == "boolean" || typeof Ae == "number" || typeof Ae == "string" || typeof Ae == "symbol" || // ES6 symbol
      typeof Ae > "u";
    }
    Y.isPrimitive = fe, Y.isBuffer = dO();
    function de(Ae) {
      return Object.prototype.toString.call(Ae);
    }
    function be(Ae) {
      return Ae < 10 ? "0" + Ae.toString(10) : Ae.toString(10);
    }
    var Te = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ];
    function Ce() {
      var Ae = /* @__PURE__ */ new Date(), Ge = [
        be(Ae.getHours()),
        be(Ae.getMinutes()),
        be(Ae.getSeconds())
      ].join(":");
      return [Ae.getDate(), Te[Ae.getMonth()], Ge].join(" ");
    }
    Y.log = function() {
      console.log("%s - %s", Ce(), Y.format.apply(Y, arguments));
    }, Y.inherits = _E, Y._extend = function(Ae, Ge) {
      if (!Ge || !_t(Ge))
        return Ae;
      for (var Xe = Object.keys(Ge), $e = Xe.length; $e--; )
        Ae[Xe[$e]] = Ge[Xe[$e]];
      return Ae;
    };
    function Pe(Ae, Ge) {
      return Object.prototype.hasOwnProperty.call(Ae, Ge);
    }
    var Se = typeof Symbol < "u" ? Symbol("util.promisify.custom") : void 0;
    Y.promisify = function(Ae) {
      if (typeof Ae != "function")
        throw new TypeError('The "original" argument must be of type Function');
      if (Se && Ae[Se]) {
        var Ge = Ae[Se];
        if (typeof Ge != "function")
          throw new TypeError('The "util.promisify.custom" argument must be of type Function');
        return Object.defineProperty(Ge, Se, {
          value: Ge,
          enumerable: !1,
          writable: !1,
          configurable: !0
        }), Ge;
      }
      function Ge() {
        for (var Xe, $e, Ze = new Promise(function(At, Tt) {
          Xe = At, $e = Tt;
        }), ot = [], ct = 0; ct < arguments.length; ct++)
          ot.push(arguments[ct]);
        ot.push(function(At, Tt) {
          At ? $e(At) : Xe(Tt);
        });
        try {
          Ae.apply(this, ot);
        } catch (At) {
          $e(At);
        }
        return Ze;
      }
      return Object.setPrototypeOf(Ge, Object.getPrototypeOf(Ae)), Se && Object.defineProperty(Ge, Se, {
        value: Ge,
        enumerable: !1,
        writable: !1,
        configurable: !0
      }), Object.defineProperties(
        Ge,
        X(Ae)
      );
    }, Y.promisify.custom = Se;
    function ke(Ae, Ge) {
      if (!Ae) {
        var Xe = new Error("Promise was rejected with a falsy value");
        Xe.reason = Ae, Ae = Xe;
      }
      return Ge(Ae);
    }
    function ge(Ae) {
      if (typeof Ae != "function")
        throw new TypeError('The "original" argument must be of type Function');
      function Ge() {
        for (var Xe = [], $e = 0; $e < arguments.length; $e++)
          Xe.push(arguments[$e]);
        var Ze = Xe.pop();
        if (typeof Ze != "function")
          throw new TypeError("The last argument must be of type Function");
        var ot = this, ct = function() {
          return Ze.apply(ot, arguments);
        };
        Ae.apply(this, Xe).then(
          function(At) {
            process.nextTick(ct.bind(null, null, At));
          },
          function(At) {
            process.nextTick(ke.bind(null, At, ct));
          }
        );
      }
      return Object.setPrototypeOf(Ge, Object.getPrototypeOf(Ae)), Object.defineProperties(
        Ge,
        X(Ae)
      ), Ge;
    }
    Y.callbackify = ge;
  }(mh)), mh;
}
var vo = {}, iu = { exports: {} };
/*! https://mths.be/punycode v1.4.1 by @mathias */
iu.exports;
var H1;
function pO() {
  return H1 || (H1 = 1, function(Y, X) {
    (function(ee) {
      var te = X && !X.nodeType && X, ne = Y && !Y.nodeType && Y, ie = typeof St == "object" && St;
      (ie.global === ie || ie.window === ie || ie.self === ie) && (ee = ie);
      var oe, se = 2147483647, ae = 36, ue = 1, le = 26, he = 38, me = 700, ye = 72, we = 128, Ee = "-", Re = /^xn--/, Ue = /[^\x20-\x7E]/, Me = /[\x2E\u3002\uFF0E\uFF61]/g, De = {
        overflow: "Overflow: input needs wider integers to process",
        "not-basic": "Illegal input >= 0x80 (not a basic code point)",
        "invalid-input": "Invalid input"
      }, Fe = ae - ue, Ke = Math.floor, tt = String.fromCharCode, rt;
      function it(ke) {
        throw new RangeError(De[ke]);
      }
      function _t(ke, ge) {
        for (var Ae = ke.length, Ge = []; Ae--; )
          Ge[Ae] = ge(ke[Ae]);
        return Ge;
      }
      function Dt(ke, ge) {
        var Ae = ke.split("@"), Ge = "";
        Ae.length > 1 && (Ge = Ae[0] + "@", ke = Ae[1]), ke = ke.replace(Me, ".");
        var Xe = ke.split("."), $e = _t(Xe, ge).join(".");
        return Ge + $e;
      }
      function je(ke) {
        for (var ge = [], Ae = 0, Ge = ke.length, Xe, $e; Ae < Ge; )
          Xe = ke.charCodeAt(Ae++), Xe >= 55296 && Xe <= 56319 && Ae < Ge ? ($e = ke.charCodeAt(Ae++), ($e & 64512) == 56320 ? ge.push(((Xe & 1023) << 10) + ($e & 1023) + 65536) : (ge.push(Xe), Ae--)) : ge.push(Xe);
        return ge;
      }
      function ze(ke) {
        return _t(ke, function(ge) {
          var Ae = "";
          return ge > 65535 && (ge -= 65536, Ae += tt(ge >>> 10 & 1023 | 55296), ge = 56320 | ge & 1023), Ae += tt(ge), Ae;
        }).join("");
      }
      function fe(ke) {
        return ke - 48 < 10 ? ke - 22 : ke - 65 < 26 ? ke - 65 : ke - 97 < 26 ? ke - 97 : ae;
      }
      function de(ke, ge) {
        return ke + 22 + 75 * (ke < 26) - ((ge != 0) << 5);
      }
      function be(ke, ge, Ae) {
        var Ge = 0;
        for (ke = Ae ? Ke(ke / me) : ke >> 1, ke += Ke(ke / ge); ke > Fe * le >> 1; Ge += ae)
          ke = Ke(ke / Fe);
        return Ke(Ge + (Fe + 1) * ke / (ke + he));
      }
      function Te(ke) {
        var ge = [], Ae = ke.length, Ge, Xe = 0, $e = we, Ze = ye, ot, ct, At, Tt, dt, vt, Ut, It, Er;
        for (ot = ke.lastIndexOf(Ee), ot < 0 && (ot = 0), ct = 0; ct < ot; ++ct)
          ke.charCodeAt(ct) >= 128 && it("not-basic"), ge.push(ke.charCodeAt(ct));
        for (At = ot > 0 ? ot + 1 : 0; At < Ae; ) {
          for (Tt = Xe, dt = 1, vt = ae; At >= Ae && it("invalid-input"), Ut = fe(ke.charCodeAt(At++)), (Ut >= ae || Ut > Ke((se - Xe) / dt)) && it("overflow"), Xe += Ut * dt, It = vt <= Ze ? ue : vt >= Ze + le ? le : vt - Ze, !(Ut < It); vt += ae)
            Er = ae - It, dt > Ke(se / Er) && it("overflow"), dt *= Er;
          Ge = ge.length + 1, Ze = be(Xe - Tt, Ge, Tt == 0), Ke(Xe / Ge) > se - $e && it("overflow"), $e += Ke(Xe / Ge), Xe %= Ge, ge.splice(Xe++, 0, $e);
        }
        return ze(ge);
      }
      function Ce(ke) {
        var ge, Ae, Ge, Xe, $e, Ze, ot, ct, At, Tt, dt, vt = [], Ut, It, Er, Fr;
        for (ke = je(ke), Ut = ke.length, ge = we, Ae = 0, $e = ye, Ze = 0; Ze < Ut; ++Ze)
          dt = ke[Ze], dt < 128 && vt.push(tt(dt));
        for (Ge = Xe = vt.length, Xe && vt.push(Ee); Ge < Ut; ) {
          for (ot = se, Ze = 0; Ze < Ut; ++Ze)
            dt = ke[Ze], dt >= ge && dt < ot && (ot = dt);
          for (It = Ge + 1, ot - ge > Ke((se - Ae) / It) && it("overflow"), Ae += (ot - ge) * It, ge = ot, Ze = 0; Ze < Ut; ++Ze)
            if (dt = ke[Ze], dt < ge && ++Ae > se && it("overflow"), dt == ge) {
              for (ct = Ae, At = ae; Tt = At <= $e ? ue : At >= $e + le ? le : At - $e, !(ct < Tt); At += ae)
                Fr = ct - Tt, Er = ae - Tt, vt.push(
                  tt(de(Tt + Fr % Er, 0))
                ), ct = Ke(Fr / Er);
              vt.push(tt(de(ct, 0))), $e = be(Ae, It, Ge == Xe), Ae = 0, ++Ge;
            }
          ++Ae, ++ge;
        }
        return vt.join("");
      }
      function Pe(ke) {
        return Dt(ke, function(ge) {
          return Re.test(ge) ? Te(ge.slice(4).toLowerCase()) : ge;
        });
      }
      function Se(ke) {
        return Dt(ke, function(ge) {
          return Ue.test(ge) ? "xn--" + Ce(ge) : ge;
        });
      }
      if (oe = {
        /**
         * A string representing the current Punycode.js version number.
         * @memberOf punycode
         * @type String
         */
        version: "1.4.1",
        /**
         * An object of methods to convert from JavaScript's internal character
         * representation (UCS-2) to Unicode code points, and back.
         * @see <https://mathiasbynens.be/notes/javascript-encoding>
         * @memberOf punycode
         * @type Object
         */
        ucs2: {
          decode: je,
          encode: ze
        },
        decode: Te,
        encode: Ce,
        toASCII: Se,
        toUnicode: Pe
      }, te && ne)
        if (Y.exports == te)
          ne.exports = oe;
        else
          for (rt in oe)
            oe.hasOwnProperty(rt) && (te[rt] = oe[rt]);
      else
        ee.punycode = oe;
    })(St);
  }(iu, iu.exports)), iu.exports;
}
var Jh, z1;
function gO() {
  if (z1)
    return Jh;
  z1 = 1;
  var Y = typeof Map == "function" && Map.prototype, X = Object.getOwnPropertyDescriptor && Y ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null, ee = Y && X && typeof X.get == "function" ? X.get : null, te = Y && Map.prototype.forEach, ne = typeof Set == "function" && Set.prototype, ie = Object.getOwnPropertyDescriptor && ne ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null, oe = ne && ie && typeof ie.get == "function" ? ie.get : null, se = ne && Set.prototype.forEach, ae = typeof WeakMap == "function" && WeakMap.prototype, ue = ae ? WeakMap.prototype.has : null, le = typeof WeakSet == "function" && WeakSet.prototype, he = le ? WeakSet.prototype.has : null, me = typeof WeakRef == "function" && WeakRef.prototype, ye = me ? WeakRef.prototype.deref : null, we = Boolean.prototype.valueOf, Ee = Object.prototype.toString, Re = Function.prototype.toString, Ue = String.prototype.match, Me = String.prototype.slice, De = String.prototype.replace, Fe = String.prototype.toUpperCase, Ke = String.prototype.toLowerCase, tt = RegExp.prototype.test, rt = Array.prototype.concat, it = Array.prototype.join, _t = Array.prototype.slice, Dt = Math.floor, je = typeof BigInt == "function" ? BigInt.prototype.valueOf : null, ze = Object.getOwnPropertySymbols, fe = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Symbol.prototype.toString : null, de = typeof Symbol == "function" && typeof Symbol.iterator == "object", be = typeof Symbol == "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === de || !0) ? Symbol.toStringTag : null, Te = Object.prototype.propertyIsEnumerable, Ce = (typeof Reflect == "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(gt) {
    return gt.__proto__;
  } : null);
  function Pe(gt, kt) {
    if (gt === 1 / 0 || gt === -1 / 0 || gt !== gt || gt && gt > -1e3 && gt < 1e3 || tt.call(/e/, kt))
      return kt;
    var Vt = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
    if (typeof gt == "number") {
      var Lr = gt < 0 ? -Dt(-gt) : Dt(gt);
      if (Lr !== gt) {
        var Ci = String(Lr), Qr = Me.call(kt, Ci.length + 1);
        return De.call(Ci, Vt, "$&_") + "." + De.call(De.call(Qr, /([0-9]{3})/g, "$&_"), /_$/, "");
      }
    }
    return De.call(kt, Vt, "$&_");
  }
  var Se = Ta, ke = Se.custom, ge = dt(ke) ? ke : null;
  Jh = function gt(kt, Vt, Lr, Ci) {
    var Qr = Vt || {};
    if (It(Qr, "quoteStyle") && Qr.quoteStyle !== "single" && Qr.quoteStyle !== "double")
      throw new TypeError('option "quoteStyle" must be "single" or "double"');
    if (It(Qr, "maxStringLength") && (typeof Qr.maxStringLength == "number" ? Qr.maxStringLength < 0 && Qr.maxStringLength !== 1 / 0 : Qr.maxStringLength !== null))
      throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
    var xX = It(Qr, "customInspect") ? Qr.customInspect : !0;
    if (typeof xX != "boolean" && xX !== "symbol")
      throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
    if (It(Qr, "indent") && Qr.indent !== null && Qr.indent !== "	" && !(parseInt(Qr.indent, 10) === Qr.indent && Qr.indent > 0))
      throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
    if (It(Qr, "numericSeparator") && typeof Qr.numericSeparator != "boolean")
      throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
    var lX = Qr.numericSeparator;
    if (typeof kt > "u")
      return "undefined";
    if (kt === null)
      return "null";
    if (typeof kt == "boolean")
      return kt ? "true" : "false";
    if (typeof kt == "string")
      return SX(kt, Qr);
    if (typeof kt == "number") {
      if (kt === 0)
        return 1 / 0 / kt > 0 ? "0" : "-0";
      var rX = String(kt);
      return lX ? Pe(kt, rX) : rX;
    }
    if (typeof kt == "bigint") {
      var FX = String(kt) + "n";
      return lX ? Pe(kt, FX) : FX;
    }
    var BX = typeof Qr.depth > "u" ? 5 : Qr.depth;
    if (typeof Lr > "u" && (Lr = 0), Lr >= BX && BX > 0 && typeof kt == "object")
      return Xe(kt) ? "[Array]" : "[Object]";
    var cX = He(Qr, Lr);
    if (typeof Ci > "u")
      Ci = [];
    else if (an(Ci, kt) >= 0)
      return "[Circular]";
    function MX(_r, cn, _X) {
      if (cn && (Ci = _t.call(Ci), Ci.push(cn)), _X) {
        var un = {
          depth: Qr.depth
        };
        return It(Qr, "quoteStyle") && (un.quoteStyle = Qr.quoteStyle), gt(_r, un, Lr + 1, Ci);
      }
      return gt(_r, Qr, Lr + 1, Ci);
    }
    if (typeof kt == "function" && !Ze(kt)) {
      var EX = Fr(kt), yX = st(kt, MX);
      return "[Function" + (EX ? ": " + EX : " (anonymous)") + "]" + (yX.length > 0 ? " { " + it.call(yX, ", ") + " }" : "");
    }
    if (dt(kt)) {
      var jX = de ? De.call(String(kt), /^(Symbol\(.*\))_[^)]*$/, "$1") : fe.call(kt);
      return typeof kt == "object" && !de ? nX(jX) : jX;
    }
    if (Nn(kt)) {
      for (var AX = "<" + Ke.call(String(kt.nodeName)), vX = kt.attributes || [], PX = 0; PX < vX.length; PX++)
        AX += " " + vX[PX].name + "=" + Ae(Ge(vX[PX].value), "double", Qr);
      return AX += ">", kt.childNodes && kt.childNodes.length && (AX += "..."), AX += "</" + Ke.call(String(kt.nodeName)) + ">", AX;
    }
    if (Xe(kt)) {
      if (kt.length === 0)
        return "[]";
      var kX = st(kt, MX);
      return cX && !pt(kX) ? "[" + Je(kX, cX) + "]" : "[ " + it.call(kX, ", ") + " ]";
    }
    if (ot(kt)) {
      var qe = st(kt, MX);
      return !("cause" in Error.prototype) && "cause" in kt && !Te.call(kt, "cause") ? "{ [" + String(kt) + "] " + it.call(rt.call("[cause]: " + MX(kt.cause), qe), ", ") + " }" : qe.length === 0 ? "[" + String(kt) + "]" : "{ [" + String(kt) + "] " + it.call(qe, ", ") + " }";
    }
    if (typeof kt == "object" && xX) {
      if (ge && typeof kt[ge] == "function" && Se)
        return Se(kt, { depth: BX - Lr });
      if (xX !== "symbol" && typeof kt.inspect == "function")
        return kt.inspect();
    }
    if (wX(kt)) {
      var Qe = [];
      return te && te.call(kt, function(_r, cn) {
        Qe.push(MX(cn, kt, !0) + " => " + MX(_r, kt));
      }), lt("Map", ee.call(kt), Qe, cX);
    }
    if (hX(kt)) {
      var Ve = [];
      return se && se.call(kt, function(_r) {
        Ve.push(MX(_r, kt));
      }), lt("Set", oe.call(kt), Ve, cX);
    }
    if (Ct(kt))
      return Ye("WeakMap");
    if (oX(kt))
      return Ye("WeakSet");
    if (w_(kt))
      return Ye("WeakRef");
    if (At(kt))
      return nX(MX(Number(kt)));
    if (vt(kt))
      return nX(MX(je.call(kt)));
    if (Tt(kt))
      return nX(we.call(kt));
    if (ct(kt))
      return nX(MX(String(kt)));
    if (typeof window < "u" && kt === window)
      return "{ [object Window] }";
    if (kt === St)
      return "{ [object globalThis] }";
    if (!$e(kt) && !Ze(kt)) {
      var Ie = st(kt, MX), nt = Ce ? Ce(kt) === Object.prototype : kt instanceof Object || kt.constructor === Object, Et = kt instanceof Object ? "" : "null prototype", xt = !nt && be && Object(kt) === kt && be in kt ? Me.call(Er(kt), 8, -1) : Et ? "Object" : "", Jt = nt || typeof kt.constructor != "function" ? "" : kt.constructor.name ? kt.constructor.name + " " : "", Yt = Jt + (xt || Et ? "[" + it.call(rt.call([], xt || [], Et || []), ": ") + "] " : "");
      return Ie.length === 0 ? Yt + "{}" : cX ? Yt + "{" + Je(Ie, cX) + "}" : Yt + "{ " + it.call(Ie, ", ") + " }";
    }
    return String(kt);
  };
  function Ae(gt, kt, Vt) {
    var Lr = (Vt.quoteStyle || kt) === "double" ? '"' : "'";
    return Lr + gt + Lr;
  }
  function Ge(gt) {
    return De.call(String(gt), /"/g, "&quot;");
  }
  function Xe(gt) {
    return Er(gt) === "[object Array]" && (!be || !(typeof gt == "object" && be in gt));
  }
  function $e(gt) {
    return Er(gt) === "[object Date]" && (!be || !(typeof gt == "object" && be in gt));
  }
  function Ze(gt) {
    return Er(gt) === "[object RegExp]" && (!be || !(typeof gt == "object" && be in gt));
  }
  function ot(gt) {
    return Er(gt) === "[object Error]" && (!be || !(typeof gt == "object" && be in gt));
  }
  function ct(gt) {
    return Er(gt) === "[object String]" && (!be || !(typeof gt == "object" && be in gt));
  }
  function At(gt) {
    return Er(gt) === "[object Number]" && (!be || !(typeof gt == "object" && be in gt));
  }
  function Tt(gt) {
    return Er(gt) === "[object Boolean]" && (!be || !(typeof gt == "object" && be in gt));
  }
  function dt(gt) {
    if (de)
      return gt && typeof gt == "object" && gt instanceof Symbol;
    if (typeof gt == "symbol")
      return !0;
    if (!gt || typeof gt != "object" || !fe)
      return !1;
    try {
      return fe.call(gt), !0;
    } catch {
    }
    return !1;
  }
  function vt(gt) {
    if (!gt || typeof gt != "object" || !je)
      return !1;
    try {
      return je.call(gt), !0;
    } catch {
    }
    return !1;
  }
  var Ut = Object.prototype.hasOwnProperty || function(gt) {
    return gt in this;
  };
  function It(gt, kt) {
    return Ut.call(gt, kt);
  }
  function Er(gt) {
    return Ee.call(gt);
  }
  function Fr(gt) {
    if (gt.name)
      return gt.name;
    var kt = Ue.call(Re.call(gt), /^function\s*([\w$]+)/);
    return kt ? kt[1] : null;
  }
  function an(gt, kt) {
    if (gt.indexOf)
      return gt.indexOf(kt);
    for (var Vt = 0, Lr = gt.length; Vt < Lr; Vt++)
      if (gt[Vt] === kt)
        return Vt;
    return -1;
  }
  function wX(gt) {
    if (!ee || !gt || typeof gt != "object")
      return !1;
    try {
      ee.call(gt);
      try {
        oe.call(gt);
      } catch {
        return !0;
      }
      return gt instanceof Map;
    } catch {
    }
    return !1;
  }
  function Ct(gt) {
    if (!ue || !gt || typeof gt != "object")
      return !1;
    try {
      ue.call(gt, ue);
      try {
        he.call(gt, he);
      } catch {
        return !0;
      }
      return gt instanceof WeakMap;
    } catch {
    }
    return !1;
  }
  function w_(gt) {
    if (!ye || !gt || typeof gt != "object")
      return !1;
    try {
      return ye.call(gt), !0;
    } catch {
    }
    return !1;
  }
  function hX(gt) {
    if (!oe || !gt || typeof gt != "object")
      return !1;
    try {
      oe.call(gt);
      try {
        ee.call(gt);
      } catch {
        return !0;
      }
      return gt instanceof Set;
    } catch {
    }
    return !1;
  }
  function oX(gt) {
    if (!he || !gt || typeof gt != "object")
      return !1;
    try {
      he.call(gt, he);
      try {
        ue.call(gt, ue);
      } catch {
        return !0;
      }
      return gt instanceof WeakSet;
    } catch {
    }
    return !1;
  }
  function Nn(gt) {
    return !gt || typeof gt != "object" ? !1 : typeof HTMLElement < "u" && gt instanceof HTMLElement ? !0 : typeof gt.nodeName == "string" && typeof gt.getAttribute == "function";
  }
  function SX(gt, kt) {
    if (gt.length > kt.maxStringLength) {
      var Vt = gt.length - kt.maxStringLength, Lr = "... " + Vt + " more character" + (Vt > 1 ? "s" : "");
      return SX(Me.call(gt, 0, kt.maxStringLength), kt) + Lr;
    }
    var Ci = De.call(De.call(gt, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, sX);
    return Ae(Ci, "single", kt);
  }
  function sX(gt) {
    var kt = gt.charCodeAt(0), Vt = {
      8: "b",
      9: "t",
      10: "n",
      12: "f",
      13: "r"
    }[kt];
    return Vt ? "\\" + Vt : "\\x" + (kt < 16 ? "0" : "") + Fe.call(kt.toString(16));
  }
  function nX(gt) {
    return "Object(" + gt + ")";
  }
  function Ye(gt) {
    return gt + " { ? }";
  }
  function lt(gt, kt, Vt, Lr) {
    var Ci = Lr ? Je(Vt, Lr) : it.call(Vt, ", ");
    return gt + " (" + kt + ") {" + Ci + "}";
  }
  function pt(gt) {
    for (var kt = 0; kt < gt.length; kt++)
      if (an(gt[kt], `
`) >= 0)
        return !1;
    return !0;
  }
  function He(gt, kt) {
    var Vt;
    if (gt.indent === "	")
      Vt = "	";
    else if (typeof gt.indent == "number" && gt.indent > 0)
      Vt = it.call(Array(gt.indent + 1), " ");
    else
      return null;
    return {
      base: Vt,
      prev: it.call(Array(kt + 1), Vt)
    };
  }
  function Je(gt, kt) {
    if (gt.length === 0)
      return "";
    var Vt = `
` + kt.prev + kt.base;
    return Vt + it.call(gt, "," + Vt) + `
` + kt.prev;
  }
  function st(gt, kt) {
    var Vt = Xe(gt), Lr = [];
    if (Vt) {
      Lr.length = gt.length;
      for (var Ci = 0; Ci < gt.length; Ci++)
        Lr[Ci] = It(gt, Ci) ? kt(gt[Ci], gt) : "";
    }
    var Qr = typeof ze == "function" ? ze(gt) : [], xX;
    if (de) {
      xX = {};
      for (var lX = 0; lX < Qr.length; lX++)
        xX["$" + Qr[lX]] = Qr[lX];
    }
    for (var rX in gt)
      It(gt, rX) && (Vt && String(Number(rX)) === rX && rX < gt.length || de && xX["$" + rX] instanceof Symbol || (tt.call(/[^\w$]/, rX) ? Lr.push(kt(rX, gt) + ": " + kt(gt[rX], gt)) : Lr.push(rX + ": " + kt(gt[rX], gt))));
    if (typeof ze == "function")
      for (var FX = 0; FX < Qr.length; FX++)
        Te.call(gt, Qr[FX]) && Lr.push("[" + kt(Qr[FX]) + "]: " + kt(gt[Qr[FX]], gt));
    return Lr;
  }
  return Jh;
}
var Yh, q1;
function mO() {
  if (q1)
    return Yh;
  q1 = 1;
  var Y = wc(), X = Um(), ee = gO(), te = hf(), ne = Y("%WeakMap%", !0), ie = Y("%Map%", !0), oe = X("WeakMap.prototype.get", !0), se = X("WeakMap.prototype.set", !0), ae = X("WeakMap.prototype.has", !0), ue = X("Map.prototype.get", !0), le = X("Map.prototype.set", !0), he = X("Map.prototype.has", !0), me = function(Re, Ue) {
    for (var Me = Re, De; (De = Me.next) !== null; Me = De)
      if (De.key === Ue)
        return Me.next = De.next, De.next = /** @type {NonNullable<typeof list.next>} */
        Re.next, Re.next = De, De;
  }, ye = function(Re, Ue) {
    var Me = me(Re, Ue);
    return Me && Me.value;
  }, we = function(Re, Ue, Me) {
    var De = me(Re, Ue);
    De ? De.value = Me : Re.next = /** @type {import('.').ListNode<typeof value>} */
    {
      // eslint-disable-line no-param-reassign, no-extra-parens
      key: Ue,
      next: Re.next,
      value: Me
    };
  }, Ee = function(Re, Ue) {
    return !!me(Re, Ue);
  };
  return Yh = function() {
    var Re, Ue, Me, De = {
      assert: function(Fe) {
        if (!De.has(Fe))
          throw new te("Side channel does not contain " + ee(Fe));
      },
      get: function(Fe) {
        if (ne && Fe && (typeof Fe == "object" || typeof Fe == "function")) {
          if (Re)
            return oe(Re, Fe);
        } else if (ie) {
          if (Ue)
            return ue(Ue, Fe);
        } else if (Me)
          return ye(Me, Fe);
      },
      has: function(Fe) {
        if (ne && Fe && (typeof Fe == "object" || typeof Fe == "function")) {
          if (Re)
            return ae(Re, Fe);
        } else if (ie) {
          if (Ue)
            return he(Ue, Fe);
        } else if (Me)
          return Ee(Me, Fe);
        return !1;
      },
      set: function(Fe, Ke) {
        ne && Fe && (typeof Fe == "object" || typeof Fe == "function") ? (Re || (Re = new ne()), se(Re, Fe, Ke)) : ie ? (Ue || (Ue = new ie()), le(Ue, Fe, Ke)) : (Me || (Me = { key: {}, next: null }), we(Me, Fe, Ke));
      }
    };
    return De;
  }, Yh;
}
var Xh, G1;
function jm() {
  if (G1)
    return Xh;
  G1 = 1;
  var Y = String.prototype.replace, X = /%20/g, ee = {
    RFC1738: "RFC1738",
    RFC3986: "RFC3986"
  };
  return Xh = {
    default: ee.RFC3986,
    formatters: {
      RFC1738: function(te) {
        return Y.call(te, X, "+");
      },
      RFC3986: function(te) {
        return String(te);
      }
    },
    RFC1738: ee.RFC1738,
    RFC3986: ee.RFC3986
  }, Xh;
}
var Zh, V1;
function D_() {
  if (V1)
    return Zh;
  V1 = 1;
  var Y = jm(), X = Object.prototype.hasOwnProperty, ee = Array.isArray, te = function() {
    for (var Ee = [], Re = 0; Re < 256; ++Re)
      Ee.push("%" + ((Re < 16 ? "0" : "") + Re.toString(16)).toUpperCase());
    return Ee;
  }(), ne = function(Ee) {
    for (; Ee.length > 1; ) {
      var Re = Ee.pop(), Ue = Re.obj[Re.prop];
      if (ee(Ue)) {
        for (var Me = [], De = 0; De < Ue.length; ++De)
          typeof Ue[De] < "u" && Me.push(Ue[De]);
        Re.obj[Re.prop] = Me;
      }
    }
  }, ie = function(Ee, Re) {
    for (var Ue = Re && Re.plainObjects ? /* @__PURE__ */ Object.create(null) : {}, Me = 0; Me < Ee.length; ++Me)
      typeof Ee[Me] < "u" && (Ue[Me] = Ee[Me]);
    return Ue;
  }, oe = function Ee(Re, Ue, Me) {
    if (!Ue)
      return Re;
    if (typeof Ue != "object") {
      if (ee(Re))
        Re.push(Ue);
      else if (Re && typeof Re == "object")
        (Me && (Me.plainObjects || Me.allowPrototypes) || !X.call(Object.prototype, Ue)) && (Re[Ue] = !0);
      else
        return [Re, Ue];
      return Re;
    }
    if (!Re || typeof Re != "object")
      return [Re].concat(Ue);
    var De = Re;
    return ee(Re) && !ee(Ue) && (De = ie(Re, Me)), ee(Re) && ee(Ue) ? (Ue.forEach(function(Fe, Ke) {
      if (X.call(Re, Ke)) {
        var tt = Re[Ke];
        tt && typeof tt == "object" && Fe && typeof Fe == "object" ? Re[Ke] = Ee(tt, Fe, Me) : Re.push(Fe);
      } else
        Re[Ke] = Fe;
    }), Re) : Object.keys(Ue).reduce(function(Fe, Ke) {
      var tt = Ue[Ke];
      return X.call(Fe, Ke) ? Fe[Ke] = Ee(Fe[Ke], tt, Me) : Fe[Ke] = tt, Fe;
    }, De);
  }, se = function(Ee, Re) {
    return Object.keys(Re).reduce(function(Ue, Me) {
      return Ue[Me] = Re[Me], Ue;
    }, Ee);
  }, ae = function(Ee, Re, Ue) {
    var Me = Ee.replace(/\+/g, " ");
    if (Ue === "iso-8859-1")
      return Me.replace(/%[0-9a-f]{2}/gi, unescape);
    try {
      return decodeURIComponent(Me);
    } catch {
      return Me;
    }
  }, ue = function(Ee, Re, Ue, Me, De) {
    if (Ee.length === 0)
      return Ee;
    var Fe = Ee;
    if (typeof Ee == "symbol" ? Fe = Symbol.prototype.toString.call(Ee) : typeof Ee != "string" && (Fe = String(Ee)), Ue === "iso-8859-1")
      return escape(Fe).replace(/%u[0-9a-f]{4}/gi, function(it) {
        return "%26%23" + parseInt(it.slice(2), 16) + "%3B";
      });
    for (var Ke = "", tt = 0; tt < Fe.length; ++tt) {
      var rt = Fe.charCodeAt(tt);
      if (rt === 45 || rt === 46 || rt === 95 || rt === 126 || rt >= 48 && rt <= 57 || rt >= 65 && rt <= 90 || rt >= 97 && rt <= 122 || De === Y.RFC1738 && (rt === 40 || rt === 41)) {
        Ke += Fe.charAt(tt);
        continue;
      }
      if (rt < 128) {
        Ke = Ke + te[rt];
        continue;
      }
      if (rt < 2048) {
        Ke = Ke + (te[192 | rt >> 6] + te[128 | rt & 63]);
        continue;
      }
      if (rt < 55296 || rt >= 57344) {
        Ke = Ke + (te[224 | rt >> 12] + te[128 | rt >> 6 & 63] + te[128 | rt & 63]);
        continue;
      }
      tt += 1, rt = 65536 + ((rt & 1023) << 10 | Fe.charCodeAt(tt) & 1023), Ke += te[240 | rt >> 18] + te[128 | rt >> 12 & 63] + te[128 | rt >> 6 & 63] + te[128 | rt & 63];
    }
    return Ke;
  }, le = function(Ee) {
    for (var Re = [{ obj: { o: Ee }, prop: "o" }], Ue = [], Me = 0; Me < Re.length; ++Me)
      for (var De = Re[Me], Fe = De.obj[De.prop], Ke = Object.keys(Fe), tt = 0; tt < Ke.length; ++tt) {
        var rt = Ke[tt], it = Fe[rt];
        typeof it == "object" && it !== null && Ue.indexOf(it) === -1 && (Re.push({ obj: Fe, prop: rt }), Ue.push(it));
      }
    return ne(Re), Ee;
  }, he = function(Ee) {
    return Object.prototype.toString.call(Ee) === "[object RegExp]";
  }, me = function(Ee) {
    return !Ee || typeof Ee != "object" ? !1 : !!(Ee.constructor && Ee.constructor.isBuffer && Ee.constructor.isBuffer(Ee));
  }, ye = function(Ee, Re) {
    return [].concat(Ee, Re);
  }, we = function(Ee, Re) {
    if (ee(Ee)) {
      for (var Ue = [], Me = 0; Me < Ee.length; Me += 1)
        Ue.push(Re(Ee[Me]));
      return Ue;
    }
    return Re(Ee);
  };
  return Zh = {
    arrayToObject: ie,
    assign: se,
    combine: ye,
    compact: le,
    decode: ae,
    encode: ue,
    isBuffer: me,
    isRegExp: he,
    maybeMap: we,
    merge: oe
  }, Zh;
}
var Qh, W1;
function yO() {
  if (W1)
    return Qh;
  W1 = 1;
  var Y = mO(), X = D_(), ee = jm(), te = Object.prototype.hasOwnProperty, ne = {
    brackets: function(Ee) {
      return Ee + "[]";
    },
    comma: "comma",
    indices: function(Ee, Re) {
      return Ee + "[" + Re + "]";
    },
    repeat: function(Ee) {
      return Ee;
    }
  }, ie = Array.isArray, oe = Array.prototype.push, se = function(Ee, Re) {
    oe.apply(Ee, ie(Re) ? Re : [Re]);
  }, ae = Date.prototype.toISOString, ue = ee.default, le = {
    addQueryPrefix: !1,
    allowDots: !1,
    charset: "utf-8",
    charsetSentinel: !1,
    delimiter: "&",
    encode: !0,
    encoder: X.encode,
    encodeValuesOnly: !1,
    format: ue,
    formatter: ee.formatters[ue],
    // deprecated
    indices: !1,
    serializeDate: function(Ee) {
      return ae.call(Ee);
    },
    skipNulls: !1,
    strictNullHandling: !1
  }, he = function(Ee) {
    return typeof Ee == "string" || typeof Ee == "number" || typeof Ee == "boolean" || typeof Ee == "symbol" || typeof Ee == "bigint";
  }, me = {}, ye = function Ee(Re, Ue, Me, De, Fe, Ke, tt, rt, it, _t, Dt, je, ze, fe, de, be) {
    for (var Te = Re, Ce = be, Pe = 0, Se = !1; (Ce = Ce.get(me)) !== void 0 && !Se; ) {
      var ke = Ce.get(Re);
      if (Pe += 1, typeof ke < "u") {
        if (ke === Pe)
          throw new RangeError("Cyclic object value");
        Se = !0;
      }
      typeof Ce.get(me) > "u" && (Pe = 0);
    }
    if (typeof rt == "function" ? Te = rt(Ue, Te) : Te instanceof Date ? Te = Dt(Te) : Me === "comma" && ie(Te) && (Te = X.maybeMap(Te, function(dt) {
      return dt instanceof Date ? Dt(dt) : dt;
    })), Te === null) {
      if (Fe)
        return tt && !fe ? tt(Ue, le.encoder, de, "key", je) : Ue;
      Te = "";
    }
    if (he(Te) || X.isBuffer(Te)) {
      if (tt) {
        var ge = fe ? Ue : tt(Ue, le.encoder, de, "key", je);
        return [ze(ge) + "=" + ze(tt(Te, le.encoder, de, "value", je))];
      }
      return [ze(Ue) + "=" + ze(String(Te))];
    }
    var Ae = [];
    if (typeof Te > "u")
      return Ae;
    var Ge;
    if (Me === "comma" && ie(Te))
      fe && tt && (Te = X.maybeMap(Te, tt)), Ge = [{ value: Te.length > 0 ? Te.join(",") || null : void 0 }];
    else if (ie(rt))
      Ge = rt;
    else {
      var Xe = Object.keys(Te);
      Ge = it ? Xe.sort(it) : Xe;
    }
    for (var $e = De && ie(Te) && Te.length === 1 ? Ue + "[]" : Ue, Ze = 0; Ze < Ge.length; ++Ze) {
      var ot = Ge[Ze], ct = typeof ot == "object" && typeof ot.value < "u" ? ot.value : Te[ot];
      if (!(Ke && ct === null)) {
        var At = ie(Te) ? typeof Me == "function" ? Me($e, ot) : $e : $e + (_t ? "." + ot : "[" + ot + "]");
        be.set(Re, Pe);
        var Tt = Y();
        Tt.set(me, be), se(Ae, Ee(
          ct,
          At,
          Me,
          De,
          Fe,
          Ke,
          Me === "comma" && fe && ie(Te) ? null : tt,
          rt,
          it,
          _t,
          Dt,
          je,
          ze,
          fe,
          de,
          Tt
        ));
      }
    }
    return Ae;
  }, we = function(Ee) {
    if (!Ee)
      return le;
    if (Ee.encoder !== null && typeof Ee.encoder < "u" && typeof Ee.encoder != "function")
      throw new TypeError("Encoder has to be a function.");
    var Re = Ee.charset || le.charset;
    if (typeof Ee.charset < "u" && Ee.charset !== "utf-8" && Ee.charset !== "iso-8859-1")
      throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
    var Ue = ee.default;
    if (typeof Ee.format < "u") {
      if (!te.call(ee.formatters, Ee.format))
        throw new TypeError("Unknown format option provided.");
      Ue = Ee.format;
    }
    var Me = ee.formatters[Ue], De = le.filter;
    return (typeof Ee.filter == "function" || ie(Ee.filter)) && (De = Ee.filter), {
      addQueryPrefix: typeof Ee.addQueryPrefix == "boolean" ? Ee.addQueryPrefix : le.addQueryPrefix,
      allowDots: typeof Ee.allowDots > "u" ? le.allowDots : !!Ee.allowDots,
      charset: Re,
      charsetSentinel: typeof Ee.charsetSentinel == "boolean" ? Ee.charsetSentinel : le.charsetSentinel,
      delimiter: typeof Ee.delimiter > "u" ? le.delimiter : Ee.delimiter,
      encode: typeof Ee.encode == "boolean" ? Ee.encode : le.encode,
      encoder: typeof Ee.encoder == "function" ? Ee.encoder : le.encoder,
      encodeValuesOnly: typeof Ee.encodeValuesOnly == "boolean" ? Ee.encodeValuesOnly : le.encodeValuesOnly,
      filter: De,
      format: Ue,
      formatter: Me,
      serializeDate: typeof Ee.serializeDate == "function" ? Ee.serializeDate : le.serializeDate,
      skipNulls: typeof Ee.skipNulls == "boolean" ? Ee.skipNulls : le.skipNulls,
      sort: typeof Ee.sort == "function" ? Ee.sort : null,
      strictNullHandling: typeof Ee.strictNullHandling == "boolean" ? Ee.strictNullHandling : le.strictNullHandling
    };
  };
  return Qh = function(Ee, Re) {
    var Ue = Ee, Me = we(Re), De, Fe;
    typeof Me.filter == "function" ? (Fe = Me.filter, Ue = Fe("", Ue)) : ie(Me.filter) && (Fe = Me.filter, De = Fe);
    var Ke = [];
    if (typeof Ue != "object" || Ue === null)
      return "";
    var tt;
    Re && Re.arrayFormat in ne ? tt = Re.arrayFormat : Re && "indices" in Re ? tt = Re.indices ? "indices" : "repeat" : tt = "indices";
    var rt = ne[tt];
    if (Re && "commaRoundTrip" in Re && typeof Re.commaRoundTrip != "boolean")
      throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
    var it = rt === "comma" && Re && Re.commaRoundTrip;
    De || (De = Object.keys(Ue)), Me.sort && De.sort(Me.sort);
    for (var _t = Y(), Dt = 0; Dt < De.length; ++Dt) {
      var je = De[Dt];
      Me.skipNulls && Ue[je] === null || se(Ke, ye(
        Ue[je],
        je,
        rt,
        it,
        Me.strictNullHandling,
        Me.skipNulls,
        Me.encode ? Me.encoder : null,
        Me.filter,
        Me.sort,
        Me.allowDots,
        Me.serializeDate,
        Me.format,
        Me.formatter,
        Me.encodeValuesOnly,
        Me.charset,
        _t
      ));
    }
    var ze = Ke.join(Me.delimiter), fe = Me.addQueryPrefix === !0 ? "?" : "";
    return Me.charsetSentinel && (Me.charset === "iso-8859-1" ? fe += "utf8=%26%2310003%3B&" : fe += "utf8=%E2%9C%93&"), ze.length > 0 ? fe + ze : "";
  }, Qh;
}
var ep, K1;
function bO() {
  if (K1)
    return ep;
  K1 = 1;
  var Y = D_(), X = Object.prototype.hasOwnProperty, ee = Array.isArray, te = {
    allowDots: !1,
    allowPrototypes: !1,
    allowSparse: !1,
    arrayLimit: 20,
    charset: "utf-8",
    charsetSentinel: !1,
    comma: !1,
    decoder: Y.decode,
    delimiter: "&",
    depth: 5,
    ignoreQueryPrefix: !1,
    interpretNumericEntities: !1,
    parameterLimit: 1e3,
    parseArrays: !0,
    plainObjects: !1,
    strictNullHandling: !1
  }, ne = function(me) {
    return me.replace(/&#(\d+);/g, function(ye, we) {
      return String.fromCharCode(parseInt(we, 10));
    });
  }, ie = function(me, ye) {
    return me && typeof me == "string" && ye.comma && me.indexOf(",") > -1 ? me.split(",") : me;
  }, oe = "utf8=%26%2310003%3B", se = "utf8=%E2%9C%93", ae = function(me, ye) {
    var we = { __proto__: null }, Ee = ye.ignoreQueryPrefix ? me.replace(/^\?/, "") : me, Re = ye.parameterLimit === 1 / 0 ? void 0 : ye.parameterLimit, Ue = Ee.split(ye.delimiter, Re), Me = -1, De, Fe = ye.charset;
    if (ye.charsetSentinel)
      for (De = 0; De < Ue.length; ++De)
        Ue[De].indexOf("utf8=") === 0 && (Ue[De] === se ? Fe = "utf-8" : Ue[De] === oe && (Fe = "iso-8859-1"), Me = De, De = Ue.length);
    for (De = 0; De < Ue.length; ++De)
      if (De !== Me) {
        var Ke = Ue[De], tt = Ke.indexOf("]="), rt = tt === -1 ? Ke.indexOf("=") : tt + 1, it, _t;
        rt === -1 ? (it = ye.decoder(Ke, te.decoder, Fe, "key"), _t = ye.strictNullHandling ? null : "") : (it = ye.decoder(Ke.slice(0, rt), te.decoder, Fe, "key"), _t = Y.maybeMap(
          ie(Ke.slice(rt + 1), ye),
          function(Dt) {
            return ye.decoder(Dt, te.decoder, Fe, "value");
          }
        )), _t && ye.interpretNumericEntities && Fe === "iso-8859-1" && (_t = ne(_t)), Ke.indexOf("[]=") > -1 && (_t = ee(_t) ? [_t] : _t), X.call(we, it) ? we[it] = Y.combine(we[it], _t) : we[it] = _t;
      }
    return we;
  }, ue = function(me, ye, we, Ee) {
    for (var Re = Ee ? ye : ie(ye, we), Ue = me.length - 1; Ue >= 0; --Ue) {
      var Me, De = me[Ue];
      if (De === "[]" && we.parseArrays)
        Me = [].concat(Re);
      else {
        Me = we.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
        var Fe = De.charAt(0) === "[" && De.charAt(De.length - 1) === "]" ? De.slice(1, -1) : De, Ke = parseInt(Fe, 10);
        !we.parseArrays && Fe === "" ? Me = { 0: Re } : !isNaN(Ke) && De !== Fe && String(Ke) === Fe && Ke >= 0 && we.parseArrays && Ke <= we.arrayLimit ? (Me = [], Me[Ke] = Re) : Fe !== "__proto__" && (Me[Fe] = Re);
      }
      Re = Me;
    }
    return Re;
  }, le = function(me, ye, we, Ee) {
    if (me) {
      var Re = we.allowDots ? me.replace(/\.([^.[]+)/g, "[$1]") : me, Ue = /(\[[^[\]]*])/, Me = /(\[[^[\]]*])/g, De = we.depth > 0 && Ue.exec(Re), Fe = De ? Re.slice(0, De.index) : Re, Ke = [];
      if (Fe) {
        if (!we.plainObjects && X.call(Object.prototype, Fe) && !we.allowPrototypes)
          return;
        Ke.push(Fe);
      }
      for (var tt = 0; we.depth > 0 && (De = Me.exec(Re)) !== null && tt < we.depth; ) {
        if (tt += 1, !we.plainObjects && X.call(Object.prototype, De[1].slice(1, -1)) && !we.allowPrototypes)
          return;
        Ke.push(De[1]);
      }
      return De && Ke.push("[" + Re.slice(De.index) + "]"), ue(Ke, ye, we, Ee);
    }
  }, he = function(me) {
    if (!me)
      return te;
    if (me.decoder !== null && me.decoder !== void 0 && typeof me.decoder != "function")
      throw new TypeError("Decoder has to be a function.");
    if (typeof me.charset < "u" && me.charset !== "utf-8" && me.charset !== "iso-8859-1")
      throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
    var ye = typeof me.charset > "u" ? te.charset : me.charset;
    return {
      allowDots: typeof me.allowDots > "u" ? te.allowDots : !!me.allowDots,
      allowPrototypes: typeof me.allowPrototypes == "boolean" ? me.allowPrototypes : te.allowPrototypes,
      allowSparse: typeof me.allowSparse == "boolean" ? me.allowSparse : te.allowSparse,
      arrayLimit: typeof me.arrayLimit == "number" ? me.arrayLimit : te.arrayLimit,
      charset: ye,
      charsetSentinel: typeof me.charsetSentinel == "boolean" ? me.charsetSentinel : te.charsetSentinel,
      comma: typeof me.comma == "boolean" ? me.comma : te.comma,
      decoder: typeof me.decoder == "function" ? me.decoder : te.decoder,
      delimiter: typeof me.delimiter == "string" || Y.isRegExp(me.delimiter) ? me.delimiter : te.delimiter,
      // eslint-disable-next-line no-implicit-coercion, no-extra-parens
      depth: typeof me.depth == "number" || me.depth === !1 ? +me.depth : te.depth,
      ignoreQueryPrefix: me.ignoreQueryPrefix === !0,
      interpretNumericEntities: typeof me.interpretNumericEntities == "boolean" ? me.interpretNumericEntities : te.interpretNumericEntities,
      parameterLimit: typeof me.parameterLimit == "number" ? me.parameterLimit : te.parameterLimit,
      parseArrays: me.parseArrays !== !1,
      plainObjects: typeof me.plainObjects == "boolean" ? me.plainObjects : te.plainObjects,
      strictNullHandling: typeof me.strictNullHandling == "boolean" ? me.strictNullHandling : te.strictNullHandling
    };
  };
  return ep = function(me, ye) {
    var we = he(ye);
    if (me === "" || me === null || typeof me > "u")
      return we.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
    for (var Ee = typeof me == "string" ? ae(me, we) : me, Re = we.plainObjects ? /* @__PURE__ */ Object.create(null) : {}, Ue = Object.keys(Ee), Me = 0; Me < Ue.length; ++Me) {
      var De = Ue[Me], Fe = le(De, Ee[De], we, typeof me == "string");
      Re = Y.merge(Re, Fe, we);
    }
    return we.allowSparse === !0 ? Re : Y.compact(Re);
  }, ep;
}
var tp, J1;
function xO() {
  if (J1)
    return tp;
  J1 = 1;
  var Y = yO(), X = bO(), ee = jm();
  return tp = {
    formats: ee,
    parse: X,
    stringify: Y
  }, tp;
}
var Y1;
function wO() {
  if (Y1)
    return vo;
  Y1 = 1;
  var Y = pO();
  function X() {
    this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null;
  }
  var ee = /^([a-z0-9.+-]+:)/i, te = /:[0-9]*$/, ne = /^(\/\/?(?!\/)[^?\s]*)(\?[^\s]*)?$/, ie = [
    "<",
    ">",
    '"',
    "`",
    " ",
    "\r",
    `
`,
    "	"
  ], oe = [
    "{",
    "}",
    "|",
    "\\",
    "^",
    "`"
  ].concat(ie), se = ["'"].concat(oe), ae = [
    "%",
    "/",
    "?",
    ";",
    "#"
  ].concat(se), ue = [
    "/",
    "?",
    "#"
  ], le = 255, he = /^[+a-z0-9A-Z_-]{0,63}$/, me = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, ye = {
    javascript: !0,
    "javascript:": !0
  }, we = {
    javascript: !0,
    "javascript:": !0
  }, Ee = {
    http: !0,
    https: !0,
    ftp: !0,
    gopher: !0,
    file: !0,
    "http:": !0,
    "https:": !0,
    "ftp:": !0,
    "gopher:": !0,
    "file:": !0
  }, Re = xO();
  function Ue(Ke, tt, rt) {
    if (Ke && typeof Ke == "object" && Ke instanceof X)
      return Ke;
    var it = new X();
    return it.parse(Ke, tt, rt), it;
  }
  X.prototype.parse = function(Ke, tt, rt) {
    if (typeof Ke != "string")
      throw new TypeError("Parameter 'url' must be a string, not " + typeof Ke);
    var it = Ke.indexOf("?"), _t = it !== -1 && it < Ke.indexOf("#") ? "?" : "#", Dt = Ke.split(_t), je = /\\/g;
    Dt[0] = Dt[0].replace(je, "/"), Ke = Dt.join(_t);
    var ze = Ke;
    if (ze = ze.trim(), !rt && Ke.split("#").length === 1) {
      var fe = ne.exec(ze);
      if (fe)
        return this.path = ze, this.href = ze, this.pathname = fe[1], fe[2] ? (this.search = fe[2], tt ? this.query = Re.parse(this.search.substr(1)) : this.query = this.search.substr(1)) : tt && (this.search = "", this.query = {}), this;
    }
    var de = ee.exec(ze);
    if (de) {
      de = de[0];
      var be = de.toLowerCase();
      this.protocol = be, ze = ze.substr(de.length);
    }
    if (rt || de || ze.match(/^\/\/[^@/]+@[^@/]+/)) {
      var Te = ze.substr(0, 2) === "//";
      Te && !(de && we[de]) && (ze = ze.substr(2), this.slashes = !0);
    }
    if (!we[de] && (Te || de && !Ee[de])) {
      for (var Ce = -1, Pe = 0; Pe < ue.length; Pe++) {
        var Se = ze.indexOf(ue[Pe]);
        Se !== -1 && (Ce === -1 || Se < Ce) && (Ce = Se);
      }
      var ke, ge;
      Ce === -1 ? ge = ze.lastIndexOf("@") : ge = ze.lastIndexOf("@", Ce), ge !== -1 && (ke = ze.slice(0, ge), ze = ze.slice(ge + 1), this.auth = decodeURIComponent(ke)), Ce = -1;
      for (var Pe = 0; Pe < ae.length; Pe++) {
        var Se = ze.indexOf(ae[Pe]);
        Se !== -1 && (Ce === -1 || Se < Ce) && (Ce = Se);
      }
      Ce === -1 && (Ce = ze.length), this.host = ze.slice(0, Ce), ze = ze.slice(Ce), this.parseHost(), this.hostname = this.hostname || "";
      var Ae = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
      if (!Ae)
        for (var Ge = this.hostname.split(/\./), Pe = 0, Xe = Ge.length; Pe < Xe; Pe++) {
          var $e = Ge[Pe];
          if ($e && !$e.match(he)) {
            for (var Ze = "", ot = 0, ct = $e.length; ot < ct; ot++)
              $e.charCodeAt(ot) > 127 ? Ze += "x" : Ze += $e[ot];
            if (!Ze.match(he)) {
              var At = Ge.slice(0, Pe), Tt = Ge.slice(Pe + 1), dt = $e.match(me);
              dt && (At.push(dt[1]), Tt.unshift(dt[2])), Tt.length && (ze = "/" + Tt.join(".") + ze), this.hostname = At.join(".");
              break;
            }
          }
        }
      this.hostname.length > le ? this.hostname = "" : this.hostname = this.hostname.toLowerCase(), Ae || (this.hostname = Y.toASCII(this.hostname));
      var vt = this.port ? ":" + this.port : "", Ut = this.hostname || "";
      this.host = Ut + vt, this.href += this.host, Ae && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), ze[0] !== "/" && (ze = "/" + ze));
    }
    if (!ye[be])
      for (var Pe = 0, Xe = se.length; Pe < Xe; Pe++) {
        var It = se[Pe];
        if (ze.indexOf(It) !== -1) {
          var Er = encodeURIComponent(It);
          Er === It && (Er = escape(It)), ze = ze.split(It).join(Er);
        }
      }
    var Fr = ze.indexOf("#");
    Fr !== -1 && (this.hash = ze.substr(Fr), ze = ze.slice(0, Fr));
    var an = ze.indexOf("?");
    if (an !== -1 ? (this.search = ze.substr(an), this.query = ze.substr(an + 1), tt && (this.query = Re.parse(this.query)), ze = ze.slice(0, an)) : tt && (this.search = "", this.query = {}), ze && (this.pathname = ze), Ee[be] && this.hostname && !this.pathname && (this.pathname = "/"), this.pathname || this.search) {
      var vt = this.pathname || "", wX = this.search || "";
      this.path = vt + wX;
    }
    return this.href = this.format(), this;
  };
  function Me(Ke) {
    return typeof Ke == "string" && (Ke = Ue(Ke)), Ke instanceof X ? Ke.format() : X.prototype.format.call(Ke);
  }
  X.prototype.format = function() {
    var Ke = this.auth || "";
    Ke && (Ke = encodeURIComponent(Ke), Ke = Ke.replace(/%3A/i, ":"), Ke += "@");
    var tt = this.protocol || "", rt = this.pathname || "", it = this.hash || "", _t = !1, Dt = "";
    this.host ? _t = Ke + this.host : this.hostname && (_t = Ke + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]"), this.port && (_t += ":" + this.port)), this.query && typeof this.query == "object" && Object.keys(this.query).length && (Dt = Re.stringify(this.query, {
      arrayFormat: "repeat",
      addQueryPrefix: !1
    }));
    var je = this.search || Dt && "?" + Dt || "";
    return tt && tt.substr(-1) !== ":" && (tt += ":"), this.slashes || (!tt || Ee[tt]) && _t !== !1 ? (_t = "//" + (_t || ""), rt && rt.charAt(0) !== "/" && (rt = "/" + rt)) : _t || (_t = ""), it && it.charAt(0) !== "#" && (it = "#" + it), je && je.charAt(0) !== "?" && (je = "?" + je), rt = rt.replace(/[?#]/g, function(ze) {
      return encodeURIComponent(ze);
    }), je = je.replace("#", "%23"), tt + _t + rt + je + it;
  };
  function De(Ke, tt) {
    return Ue(Ke, !1, !0).resolve(tt);
  }
  X.prototype.resolve = function(Ke) {
    return this.resolveObject(Ue(Ke, !1, !0)).format();
  };
  function Fe(Ke, tt) {
    return Ke ? Ue(Ke, !1, !0).resolveObject(tt) : tt;
  }
  return X.prototype.resolveObject = function(Ke) {
    if (typeof Ke == "string") {
      var tt = new X();
      tt.parse(Ke, !1, !0), Ke = tt;
    }
    for (var rt = new X(), it = Object.keys(this), _t = 0; _t < it.length; _t++) {
      var Dt = it[_t];
      rt[Dt] = this[Dt];
    }
    if (rt.hash = Ke.hash, Ke.href === "")
      return rt.href = rt.format(), rt;
    if (Ke.slashes && !Ke.protocol) {
      for (var je = Object.keys(Ke), ze = 0; ze < je.length; ze++) {
        var fe = je[ze];
        fe !== "protocol" && (rt[fe] = Ke[fe]);
      }
      return Ee[rt.protocol] && rt.hostname && !rt.pathname && (rt.pathname = "/", rt.path = rt.pathname), rt.href = rt.format(), rt;
    }
    if (Ke.protocol && Ke.protocol !== rt.protocol) {
      if (!Ee[Ke.protocol]) {
        for (var de = Object.keys(Ke), be = 0; be < de.length; be++) {
          var Te = de[be];
          rt[Te] = Ke[Te];
        }
        return rt.href = rt.format(), rt;
      }
      if (rt.protocol = Ke.protocol, !Ke.host && !we[Ke.protocol]) {
        for (var Xe = (Ke.pathname || "").split("/"); Xe.length && !(Ke.host = Xe.shift()); )
          ;
        Ke.host || (Ke.host = ""), Ke.hostname || (Ke.hostname = ""), Xe[0] !== "" && Xe.unshift(""), Xe.length < 2 && Xe.unshift(""), rt.pathname = Xe.join("/");
      } else
        rt.pathname = Ke.pathname;
      if (rt.search = Ke.search, rt.query = Ke.query, rt.host = Ke.host || "", rt.auth = Ke.auth, rt.hostname = Ke.hostname || Ke.host, rt.port = Ke.port, rt.pathname || rt.search) {
        var Ce = rt.pathname || "", Pe = rt.search || "";
        rt.path = Ce + Pe;
      }
      return rt.slashes = rt.slashes || Ke.slashes, rt.href = rt.format(), rt;
    }
    var Se = rt.pathname && rt.pathname.charAt(0) === "/", ke = Ke.host || Ke.pathname && Ke.pathname.charAt(0) === "/", ge = ke || Se || rt.host && Ke.pathname, Ae = ge, Ge = rt.pathname && rt.pathname.split("/") || [], Xe = Ke.pathname && Ke.pathname.split("/") || [], $e = rt.protocol && !Ee[rt.protocol];
    if ($e && (rt.hostname = "", rt.port = null, rt.host && (Ge[0] === "" ? Ge[0] = rt.host : Ge.unshift(rt.host)), rt.host = "", Ke.protocol && (Ke.hostname = null, Ke.port = null, Ke.host && (Xe[0] === "" ? Xe[0] = Ke.host : Xe.unshift(Ke.host)), Ke.host = null), ge = ge && (Xe[0] === "" || Ge[0] === "")), ke)
      rt.host = Ke.host || Ke.host === "" ? Ke.host : rt.host, rt.hostname = Ke.hostname || Ke.hostname === "" ? Ke.hostname : rt.hostname, rt.search = Ke.search, rt.query = Ke.query, Ge = Xe;
    else if (Xe.length)
      Ge || (Ge = []), Ge.pop(), Ge = Ge.concat(Xe), rt.search = Ke.search, rt.query = Ke.query;
    else if (Ke.search != null) {
      if ($e) {
        rt.host = Ge.shift(), rt.hostname = rt.host;
        var Ze = rt.host && rt.host.indexOf("@") > 0 ? rt.host.split("@") : !1;
        Ze && (rt.auth = Ze.shift(), rt.hostname = Ze.shift(), rt.host = rt.hostname);
      }
      return rt.search = Ke.search, rt.query = Ke.query, (rt.pathname !== null || rt.search !== null) && (rt.path = (rt.pathname ? rt.pathname : "") + (rt.search ? rt.search : "")), rt.href = rt.format(), rt;
    }
    if (!Ge.length)
      return rt.pathname = null, rt.search ? rt.path = "/" + rt.search : rt.path = null, rt.href = rt.format(), rt;
    for (var ot = Ge.slice(-1)[0], ct = (rt.host || Ke.host || Ge.length > 1) && (ot === "." || ot === "..") || ot === "", At = 0, Tt = Ge.length; Tt >= 0; Tt--)
      ot = Ge[Tt], ot === "." ? Ge.splice(Tt, 1) : ot === ".." ? (Ge.splice(Tt, 1), At++) : At && (Ge.splice(Tt, 1), At--);
    if (!ge && !Ae)
      for (; At--; At)
        Ge.unshift("..");
    ge && Ge[0] !== "" && (!Ge[0] || Ge[0].charAt(0) !== "/") && Ge.unshift(""), ct && Ge.join("/").substr(-1) !== "/" && Ge.push("");
    var dt = Ge[0] === "" || Ge[0] && Ge[0].charAt(0) === "/";
    if ($e) {
      rt.hostname = dt ? "" : Ge.length ? Ge.shift() : "", rt.host = rt.hostname;
      var Ze = rt.host && rt.host.indexOf("@") > 0 ? rt.host.split("@") : !1;
      Ze && (rt.auth = Ze.shift(), rt.hostname = Ze.shift(), rt.host = rt.hostname);
    }
    return ge = ge || rt.host && Ge.length, ge && !dt && Ge.unshift(""), Ge.length > 0 ? rt.pathname = Ge.join("/") : (rt.pathname = null, rt.path = null), (rt.pathname !== null || rt.search !== null) && (rt.path = (rt.pathname ? rt.pathname : "") + (rt.search ? rt.search : "")), rt.auth = Ke.auth || rt.auth, rt.slashes = rt.slashes || Ke.slashes, rt.href = rt.format(), rt;
  }, X.prototype.parseHost = function() {
    var Ke = this.host, tt = te.exec(Ke);
    tt && (tt = tt[0], tt !== ":" && (this.port = tt.substr(1)), Ke = Ke.substr(0, Ke.length - tt.length)), Ke && (this.hostname = Ke);
  }, vo.parse = Ue, vo.resolve = De, vo.resolveObject = Fe, vo.format = Me, vo.Url = X, vo;
}
Object.defineProperty(Lo, "__esModule", { value: !0 });
Lo.InvalidStatusCodeError = Lo.InvalidCertError = void 0;
const U_ = Object.freeze({
  redirect: !0,
  expectStatusCode: 200,
  headers: {},
  full: !1,
  keepAlive: !0,
  cors: !1,
  referrer: !1,
  sslAllowSelfSigned: !1,
  _redirectCount: 0
});
class eg extends Error {
  constructor(X, ee) {
    super(X), this.fingerprint256 = ee;
  }
}
Lo.InvalidCertError = eg;
class Hm extends Error {
  constructor(X) {
    super(`Request Failed. Status Code: ${X}`), this.statusCode = X;
  }
}
Lo.InvalidStatusCodeError = Hm;
function j_(Y, X) {
  if (!X || X === "text" || X === "json")
    try {
      let ee = new TextDecoder("utf8", { fatal: !0 }).decode(Y);
      if (X === "text")
        return ee;
      try {
        return JSON.parse(ee);
      } catch (te) {
        if (X === "json")
          throw te;
        return ee;
      }
    } catch (ee) {
      if (X === "text" || X === "json")
        throw ee;
    }
  return Y;
}
let X1 = {};
function tg(Y, X) {
  var ee;
  let te = { ...U_, ...X };
  const ne = Ta, ie = Ta, oe = Ta, { promisify: se } = hO(), { resolve: ae } = wO(), ue = !!/^https/.test(Y);
  let le = {
    method: te.method || "GET",
    headers: { "Accept-Encoding": "gzip, deflate, br" }
  };
  const he = (ye) => ye.replace(/:| /g, "").toLowerCase();
  if (te.keepAlive) {
    const ye = {
      keepAlive: !0,
      keepAliveMsecs: 3e4,
      maxFreeSockets: 1024,
      maxCachedSessions: 1024
    }, we = [
      ue,
      ue && ((ee = te.sslPinnedCertificates) == null ? void 0 : ee.map((Ee) => he(Ee)).sort())
    ].join();
    le.agent = X1[we] || (X1[we] = new (ue ? ie : ne).Agent(ye));
  }
  te.type === "json" && (le.headers["Content-Type"] = "application/json"), te.data && (te.method || (le.method = "POST"), le.body = te.type === "json" ? JSON.stringify(te.data) : te.data), le.headers = { ...le.headers, ...te.headers }, te.sslAllowSelfSigned && (le.rejectUnauthorized = !1);
  const me = async (ye) => {
    const we = ye.statusCode;
    if (te.redirect && 300 <= we && we < 400 && ye.headers.location) {
      if (te._redirectCount == 10)
        throw new Error("Request failed. Too much redirects.");
      return te._redirectCount += 1, await tg(ae(Y, ye.headers.location), te);
    }
    if (te.expectStatusCode && we !== te.expectStatusCode)
      throw ye.resume(), new Hm(we);
    let Ee = [];
    for await (const De of ye)
      Ee.push(De);
    let Re = Buffer.concat(Ee);
    const Ue = ye.headers["content-encoding"];
    Ue === "br" && (Re = await se(oe.brotliDecompress)(Re)), (Ue === "gzip" || Ue === "deflate") && (Re = await se(oe.unzip)(Re));
    const Me = j_(Re, te.type);
    return te.full ? { headers: ye.headers, status: we, body: Me } : Me;
  };
  return new Promise((ye, we) => {
    var Ee;
    const Re = async (Fe) => {
      if (Fe && Fe.code === "DEPTH_ZERO_SELF_SIGNED_CERT")
        try {
          await tg(Y, { ...te, sslAllowSelfSigned: !0, sslPinnedCertificates: [] });
        } catch (Ke) {
          Ke && Ke.fingerprint256 && (Fe = new eg(`Self-signed SSL certificate: ${Ke.fingerprint256}`, Ke.fingerprint256));
        }
      we(Fe);
    }, Ue = (ue ? ie : ne).request(Y, le, (Fe) => {
      Fe.on("error", Re), (async () => {
        try {
          ye(await me(Fe));
        } catch (Ke) {
          we(Ke);
        }
      })();
    });
    Ue.on("error", Re);
    const Me = (Ee = te.sslPinnedCertificates) == null ? void 0 : Ee.map((Fe) => he(Fe)), De = (Fe) => {
      var Ke;
      const tt = he(((Ke = Fe.getPeerCertificate()) == null ? void 0 : Ke.fingerprint256) || "");
      if (!(!tt && Fe.isSessionReused()) && !Me.includes(tt))
        return Ue.emit("error", new eg(`Invalid SSL certificate: ${tt} Expected: ${Me}`, tt)), Ue.abort();
    };
    te.sslPinnedCertificates && Ue.on("socket", (Fe) => {
      Fe.listeners("secureConnect").map((Ke) => (Ke.name || "").replace("bound ", "")).includes("mfetchSecureConnect") || Fe.on("secureConnect", De.bind(null, Fe));
    }), te.keepAlive && Ue.setNoDelay(!0), le.body && Ue.write(le.body), Ue.end();
  });
}
const vO = new Set(["Accept", "Accept-Language", "Content-Language", "Content-Type"].map((Y) => Y.toLowerCase())), EO = new Set([
  "Accept-Charset",
  "Accept-Encoding",
  "Access-Control-Request-Headers",
  "Access-Control-Request-Method",
  "Connection",
  "Content-Length",
  "Cookie",
  "Cookie2",
  "Date",
  "DNT",
  "Expect",
  "Host",
  "Keep-Alive",
  "Origin",
  "Referer",
  "TE",
  "Trailer",
  "Transfer-Encoding",
  "Upgrade",
  "Via"
].map((Y) => Y.toLowerCase()));
async function _O(Y, X) {
  let ee = { ...U_, ...X };
  const te = new Headers();
  ee.type === "json" && te.set("Content-Type", "application/json");
  let ne = new URL(Y);
  if (ne.username) {
    const ae = btoa(`${ne.username}:${ne.password}`);
    te.set("Authorization", `Basic ${ae}`), ne.username = "", ne.password = "";
  }
  Y = "" + ne;
  for (let ae in ee.headers) {
    const ue = ae.toLowerCase();
    (vO.has(ue) || ee.cors && !EO.has(ue)) && te.set(ae, ee.headers[ae]);
  }
  let ie = { headers: te, redirect: ee.redirect ? "follow" : "manual" };
  ee.referrer || (ie.referrerPolicy = "no-referrer"), ee.cors && (ie.mode = "cors"), ee.data && (ee.method || (ie.method = "POST"), ie.body = ee.type === "json" ? JSON.stringify(ee.data) : ee.data);
  const oe = await fetch(Y, ie);
  if (ee.expectStatusCode && oe.status !== ee.expectStatusCode)
    throw new Hm(oe.status);
  const se = j_(new Uint8Array(await oe.arrayBuffer()), ee.type);
  return ee.full ? { headers: Object.fromEntries(oe.headers.entries()), status: oe.status, body: se } : se;
}
const AO = !!(typeof process == "object" && process.versions && process.versions.node && process.versions.v8);
function SO(Y, X) {
  return (AO ? tg : _O)(Y, X);
}
Lo.default = SO;
Object.defineProperty(Ja, "__esModule", { value: !0 });
Ja.getProvider = Ja.fetchFromProvider = void 0;
const TO = Lo, IO = async (Y, X) => (await (0, TO.default)(Y, {
  headers: {
    "content-type": "application/json"
  },
  type: "json",
  data: {
    method: X.method,
    params: X.params,
    jsonrpc: "2.0",
    id: 1
  }
})).result;
Ja.fetchFromProvider = IO;
const RO = (Y) => {
  var X;
  if (typeof Y == "string")
    return Y;
  if (((X = Y == null ? void 0 : Y.connection) == null ? void 0 : X.url) !== void 0)
    return Y.connection.url;
  throw new Error("Must provide valid provider URL or Web3Provider");
};
Ja.getProvider = RO;
(function(Y) {
  var X = St && St.__createBinding || (Object.create ? function(ne, ie, oe, se) {
    se === void 0 && (se = oe);
    var ae = Object.getOwnPropertyDescriptor(ie, oe);
    (!ae || ("get" in ae ? !ie.__esModule : ae.writable || ae.configurable)) && (ae = { enumerable: !0, get: function() {
      return ie[oe];
    } }), Object.defineProperty(ne, se, ae);
  } : function(ne, ie, oe, se) {
    se === void 0 && (se = oe), ne[se] = ie[oe];
  }), ee = St && St.__exportStar || function(ne, ie) {
    for (var oe in ne)
      oe !== "default" && !Object.prototype.hasOwnProperty.call(ie, oe) && X(ie, ne, oe);
  };
  Object.defineProperty(Y, "__esModule", { value: !0 }), Y.toAscii = Y.stripHexPrefix = Y.padToEven = Y.isHexString = Y.isHexPrefixed = Y.getKeys = Y.getBinarySize = Y.fromUtf8 = Y.fromAscii = Y.arrayContainsArray = void 0, ee(Bd, Y), ee(Dd, Y), ee(Pm, Y), ee(df, Y), ee(jd, Y), ee(fn, Y), ee(Jo, Y), ee(km, Y), ee(T_, Y), ee(qd, Y);
  var te = lr;
  Object.defineProperty(Y, "arrayContainsArray", { enumerable: !0, get: function() {
    return te.arrayContainsArray;
  } }), Object.defineProperty(Y, "fromAscii", { enumerable: !0, get: function() {
    return te.fromAscii;
  } }), Object.defineProperty(Y, "fromUtf8", { enumerable: !0, get: function() {
    return te.fromUtf8;
  } }), Object.defineProperty(Y, "getBinarySize", { enumerable: !0, get: function() {
    return te.getBinarySize;
  } }), Object.defineProperty(Y, "getKeys", { enumerable: !0, get: function() {
    return te.getKeys;
  } }), Object.defineProperty(Y, "isHexPrefixed", { enumerable: !0, get: function() {
    return te.isHexPrefixed;
  } }), Object.defineProperty(Y, "isHexString", { enumerable: !0, get: function() {
    return te.isHexString;
  } }), Object.defineProperty(Y, "padToEven", { enumerable: !0, get: function() {
    return te.padToEven;
  } }), Object.defineProperty(Y, "stripHexPrefix", { enumerable: !0, get: function() {
    return te.stripHexPrefix;
  } }), Object.defineProperty(Y, "toAscii", { enumerable: !0, get: function() {
    return te.toAscii;
  } }), ee(Vd, Y), ee(Ja, Y);
})(Od);
var tn = {}, pe = {}, vc = {}, qt = {}, oi = {}, mo = {}, En = {};
Object.defineProperty(En, "__esModule", { value: !0 });
function CO(Y, X) {
  return Y ?? X();
}
function PO(Y) {
  return Array.isArray(Y) && Y.length > 0;
}
function OO(Y) {
  return Y == null;
}
function BO(Y) {
  return !!Y && typeof Y == "object" && !Array.isArray(Y);
}
var NO = (Y, X) => Object.hasOwnProperty.call(Y, X);
function kO(Y) {
  return Object.getOwnPropertyNames(Y);
}
var H_ = /* @__PURE__ */ ((Y) => (Y[Y.Null = 4] = "Null", Y[Y.Comma = 1] = "Comma", Y[Y.Wrapper = 1] = "Wrapper", Y[Y.True = 4] = "True", Y[Y.False = 5] = "False", Y[Y.Quote = 1] = "Quote", Y[Y.Colon = 1] = "Colon", Y[Y.Date = 24] = "Date", Y))(H_ || {}), z_ = /"|\\|\n|\r|\t/gu;
function MO(Y) {
  if (typeof Y != "object" || Y === null)
    return !1;
  try {
    let X = Y;
    for (; Object.getPrototypeOf(X) !== null; )
      X = Object.getPrototypeOf(X);
    return Object.getPrototypeOf(Y) === X;
  } catch {
    return !1;
  }
}
function q_(Y) {
  return Y.charCodeAt(0) <= 127;
}
function LO(Y) {
  return Y.split("").reduce((X, ee) => q_(ee) ? X + 1 : X + 2, 0) + CO(Y.match(z_), () => []).length;
}
function FO(Y) {
  return Y.toString().length;
}
En.isNonEmptyArray = PO;
En.isNullOrUndefined = OO;
En.isObject = BO;
En.hasProperty = NO;
En.getKnownPropertyNames = kO;
En.JsonSize = H_;
En.ESCAPE_CHARACTERS_REGEXP = z_;
En.isPlainObject = MO;
En.isASCII = q_;
En.calculateStringSize = LO;
En.calculateNumberSize = FO;
let $O = class _Y extends Error {
  /**
   * @param {string} message
   * @param {{ cause?: T }} options
   */
  constructor(X, { cause: ee } = {}) {
    super(X), this.name = _Y.name, ee && (this.cause = ee), this.message = X;
  }
};
const DO = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ErrorWithCause: $O
}, Symbol.toStringTag, { value: "Module" })), UO = /* @__PURE__ */ _d(DO), jO = (Y, X) => {
  if (!Y || !X || !(Y instanceof Error) || !(X.prototype instanceof Error) && // @ts-ignore
  X !== Error)
    return;
  const ee = /* @__PURE__ */ new Set();
  let te = Y;
  for (; te && !ee.has(te); ) {
    if (ee.add(te), te instanceof X)
      return te;
    te = Wd(te);
  }
}, Wd = (Y) => {
  if (!(!Y || typeof Y != "object" || !("cause" in Y)))
    if (typeof Y.cause == "function") {
      const X = Y.cause();
      return X instanceof Error ? X : void 0;
    } else
      return Y.cause instanceof Error ? Y.cause : void 0;
}, V_ = (Y, X) => {
  if (!(Y instanceof Error))
    return "";
  const ee = Y.stack || "";
  if (X.has(Y))
    return ee + `
causes have become circular...`;
  const te = Wd(Y);
  return te ? (X.add(Y), ee + `
caused by: ` + V_(te, X)) : ee;
}, HO = (Y) => V_(Y, /* @__PURE__ */ new Set()), W_ = (Y, X, ee) => {
  if (!(Y instanceof Error))
    return "";
  const te = ee ? "" : Y.message || "";
  if (X.has(Y))
    return te + ": ...";
  const ne = Wd(Y);
  if (ne) {
    X.add(Y);
    const ie = "cause" in Y && typeof Y.cause == "function";
    return te + (ie ? "" : ": ") + W_(ne, X, ie);
  } else
    return te;
}, zO = (Y) => W_(Y, /* @__PURE__ */ new Set()), qO = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  findCauseByReference: jO,
  getErrorCause: Wd,
  messageWithCauses: zO,
  stackWithCauses: HO
}, Symbol.toStringTag, { value: "Module" })), GO = /* @__PURE__ */ _d(qO), { ErrorWithCause: VO } = UO, {
  // linemod-replace-with: export {
  findCauseByReference: WO,
  getErrorCause: KO,
  messageWithCauses: JO,
  stackWithCauses: YO
} = GO;
var XO = {
  // linemod-remove
  ErrorWithCause: VO,
  // linemod-remove
  findCauseByReference: WO,
  // linemod-remove
  getErrorCause: KO,
  // linemod-remove
  stackWithCauses: YO,
  // linemod-remove
  messageWithCauses: JO
  // linemod-remove
};
Object.defineProperty(mo, "__esModule", { value: !0 });
var K_ = En, ZO = XO;
function QO(Y) {
  return Y instanceof Error || K_.isObject.call(void 0, Y) && Y.constructor.name === "Error";
}
function J_(Y) {
  return typeof Y == "object" && Y !== null && "code" in Y;
}
function Y_(Y) {
  return typeof Y == "object" && Y !== null && "message" in Y;
}
function eB(Y) {
  return typeof Y == "object" && Y !== null && "stack" in Y;
}
function tB(Y) {
  return Y_(Y) && typeof Y.message == "string" ? Y.message : K_.isNullOrUndefined.call(void 0, Y) ? "" : String(Y);
}
function rB(Y, X) {
  if (QO(Y)) {
    let ee;
    return Error.length === 2 ? ee = new Error(X, { cause: Y }) : ee = new ZO.ErrorWithCause(X, { cause: Y }), J_(Y) && (ee.code = Y.code), ee;
  }
  return X.length > 0 ? new Error(`${String(Y)}: ${X}`) : new Error(String(Y));
}
mo.isErrorWithCode = J_;
mo.isErrorWithMessage = Y_;
mo.isErrorWithStack = eB;
mo.getErrorMessage = tB;
mo.wrapError = rB;
class X_ extends TypeError {
  constructor(X, ee) {
    let te;
    const { message: ne, explanation: ie, ...oe } = X, { path: se } = X, ae = se.length === 0 ? ne : `At path: ${se.join(".")} -- ${ne}`;
    super(ie ?? ae), ie != null && (this.cause = ae), Object.assign(this, oe), this.name = this.constructor.name, this.failures = () => te ?? (te = [X, ...ee()]);
  }
}
function nB(Y) {
  return ri(Y) && typeof Y[Symbol.iterator] == "function";
}
function ri(Y) {
  return typeof Y == "object" && Y != null;
}
function Z1(Y) {
  if (Object.prototype.toString.call(Y) !== "[object Object]")
    return !1;
  const X = Object.getPrototypeOf(Y);
  return X === null || X === Object.prototype;
}
function zr$1(Y) {
  return typeof Y == "symbol" ? Y.toString() : typeof Y == "string" ? JSON.stringify(Y) : `${Y}`;
}
function iB(Y) {
  const { done: X, value: ee } = Y.next();
  return X ? void 0 : ee;
}
function sB(Y, X, ee, te) {
  if (Y === !0)
    return;
  Y === !1 ? Y = {} : typeof Y == "string" && (Y = { message: Y });
  const { path: ne, branch: ie } = X, { type: oe } = ee, { refinement: se, message: ae = `Expected a value of type \`${oe}\`${se ? ` with refinement \`${se}\`` : ""}, but received: \`${zr$1(te)}\`` } = Y;
  return {
    value: te,
    type: oe,
    refinement: se,
    key: ne[ne.length - 1],
    path: ne,
    branch: ie,
    ...Y,
    message: ae
  };
}
function* rg(Y, X, ee, te) {
  nB(Y) || (Y = [Y]);
  for (const ne of Y) {
    const ie = sB(ne, X, ee, te);
    ie && (yield ie);
  }
}
function* zm(Y, X, ee = {}) {
  const { path: te = [], branch: ne = [Y], coerce: ie = !1, mask: oe = !1 } = ee, se = { path: te, branch: ne };
  if (ie && (Y = X.coercer(Y, se), oe && X.type !== "type" && ri(X.schema) && ri(Y) && !Array.isArray(Y)))
    for (const ue in Y)
      X.schema[ue] === void 0 && delete Y[ue];
  let ae = "valid";
  for (const ue of X.validator(Y, se))
    ue.explanation = ee.message, ae = "not_valid", yield [ue, void 0];
  for (let [ue, le, he] of X.entries(Y, se)) {
    const me = zm(le, he, {
      path: ue === void 0 ? te : [...te, ue],
      branch: ue === void 0 ? ne : [...ne, le],
      coerce: ie,
      mask: oe,
      message: ee.message
    });
    for (const ye of me)
      ye[0] ? (ae = ye[0].refinement != null ? "not_refined" : "not_valid", yield [ye[0], void 0]) : ie && (le = ye[1], ue === void 0 ? Y = le : Y instanceof Map ? Y.set(ue, le) : Y instanceof Set ? Y.add(le) : ri(Y) && (le !== void 0 || ue in Y) && (Y[ue] = le));
  }
  if (ae !== "not_valid")
    for (const ue of X.refiner(Y, se))
      ue.explanation = ee.message, ae = "not_refined", yield [ue, void 0];
  ae === "valid" && (yield [void 0, Y]);
}
class Nr {
  constructor(X) {
    const { type: ee, schema: te, validator: ne, refiner: ie, coercer: oe = (ae) => ae, entries: se = function* () {
    } } = X;
    this.type = ee, this.schema = te, this.entries = se, this.coercer = oe, ne ? this.validator = (ae, ue) => {
      const le = ne(ae, ue);
      return rg(le, ue, this, ae);
    } : this.validator = () => [], ie ? this.refiner = (ae, ue) => {
      const le = ie(ae, ue);
      return rg(le, ue, this, ae);
    } : this.refiner = () => [];
  }
  /**
   * Assert that a value passes the struct's validation, throwing if it doesn't.
   */
  assert(X, ee) {
    return Z_(X, this, ee);
  }
  /**
   * Create a value with the struct's coercion logic, then validate it.
   */
  create(X, ee) {
    return Q_(X, this, ee);
  }
  /**
   * Check if a value passes the struct's validation.
   */
  is(X) {
    return qm(X, this);
  }
  /**
   * Mask a value, coercing and validating it, but returning only the subset of
   * properties defined by the struct's schema.
   */
  mask(X, ee) {
    return e3(X, this, ee);
  }
  /**
   * Validate a value with the struct's validation logic, returning a tuple
   * representing the result.
   *
   * You may optionally pass `true` for the `withCoercion` argument to coerce
   * the value before attempting to validate it. If you do, the result will
   * contain the coerced result when successful.
   */
  validate(X, ee = {}) {
    return Ec(X, this, ee);
  }
}
function Z_(Y, X, ee) {
  const te = Ec(Y, X, { message: ee });
  if (te[0])
    throw te[0];
}
function Q_(Y, X, ee) {
  const te = Ec(Y, X, { coerce: !0, message: ee });
  if (te[0])
    throw te[0];
  return te[1];
}
function e3(Y, X, ee) {
  const te = Ec(Y, X, { coerce: !0, mask: !0, message: ee });
  if (te[0])
    throw te[0];
  return te[1];
}
function qm(Y, X) {
  return !Ec(Y, X)[0];
}
function Ec(Y, X, ee = {}) {
  const te = zm(Y, X, ee), ne = iB(te);
  return ne[0] ? [new X_(ne[0], function* () {
    for (const ie of te)
      ie[0] && (yield ie[0]);
  }), void 0] : [void 0, ne[1]];
}
function oB(...Y) {
  const X = Y[0].type === "type", ee = Y.map((ne) => ne.schema), te = Object.assign({}, ...ee);
  return X ? Vm(te) : pf(te);
}
function On(Y, X) {
  return new Nr({ type: Y, schema: null, validator: X });
}
function aB(Y, X) {
  return new Nr({
    ...Y,
    refiner: (ee, te) => ee === void 0 || Y.refiner(ee, te),
    validator(ee, te) {
      return ee === void 0 ? !0 : (X(ee, te), Y.validator(ee, te));
    }
  });
}
function cB(Y) {
  return new Nr({
    type: "dynamic",
    schema: null,
    *entries(X, ee) {
      yield* Y(X, ee).entries(X, ee);
    },
    validator(X, ee) {
      return Y(X, ee).validator(X, ee);
    },
    coercer(X, ee) {
      return Y(X, ee).coercer(X, ee);
    },
    refiner(X, ee) {
      return Y(X, ee).refiner(X, ee);
    }
  });
}
function uB(Y) {
  let X;
  return new Nr({
    type: "lazy",
    schema: null,
    *entries(ee, te) {
      X ?? (X = Y()), yield* X.entries(ee, te);
    },
    validator(ee, te) {
      return X ?? (X = Y()), X.validator(ee, te);
    },
    coercer(ee, te) {
      return X ?? (X = Y()), X.coercer(ee, te);
    },
    refiner(ee, te) {
      return X ?? (X = Y()), X.refiner(ee, te);
    }
  });
}
function fB(Y, X) {
  const { schema: ee } = Y, te = { ...ee };
  for (const ne of X)
    delete te[ne];
  switch (Y.type) {
    case "type":
      return Vm(te);
    default:
      return pf(te);
  }
}
function lB(Y) {
  const X = Y instanceof Nr ? { ...Y.schema } : { ...Y };
  for (const ee in X)
    X[ee] = t3(X[ee]);
  return pf(X);
}
function dB(Y, X) {
  const { schema: ee } = Y, te = {};
  for (const ne of X)
    te[ne] = ee[ne];
  return pf(te);
}
function hB(Y, X) {
  return console.warn("superstruct@0.11 - The `struct` helper has been renamed to `define`."), On(Y, X);
}
function pB() {
  return On("any", () => !0);
}
function gB(Y) {
  return new Nr({
    type: "array",
    schema: Y,
    *entries(X) {
      if (Y && Array.isArray(X))
        for (const [ee, te] of X.entries())
          yield [ee, te, Y];
    },
    coercer(X) {
      return Array.isArray(X) ? X.slice() : X;
    },
    validator(X) {
      return Array.isArray(X) || `Expected an array value, but received: ${zr$1(X)}`;
    }
  });
}
function mB() {
  return On("bigint", (Y) => typeof Y == "bigint");
}
function yB() {
  return On("boolean", (Y) => typeof Y == "boolean");
}
function bB() {
  return On("date", (Y) => Y instanceof Date && !isNaN(Y.getTime()) || `Expected a valid \`Date\` object, but received: ${zr$1(Y)}`);
}
function xB(Y) {
  const X = {}, ee = Y.map((te) => zr$1(te)).join();
  for (const te of Y)
    X[te] = te;
  return new Nr({
    type: "enums",
    schema: X,
    validator(te) {
      return Y.includes(te) || `Expected one of \`${ee}\`, but received: ${zr$1(te)}`;
    }
  });
}
function wB() {
  return On("func", (Y) => typeof Y == "function" || `Expected a function, but received: ${zr$1(Y)}`);
}
function vB(Y) {
  return On("instance", (X) => X instanceof Y || `Expected a \`${Y.name}\` instance, but received: ${zr$1(X)}`);
}
function EB() {
  return On("integer", (Y) => typeof Y == "number" && !isNaN(Y) && Number.isInteger(Y) || `Expected an integer, but received: ${zr$1(Y)}`);
}
function _B(Y) {
  return new Nr({
    type: "intersection",
    schema: null,
    *entries(X, ee) {
      for (const te of Y)
        yield* te.entries(X, ee);
    },
    *validator(X, ee) {
      for (const te of Y)
        yield* te.validator(X, ee);
    },
    *refiner(X, ee) {
      for (const te of Y)
        yield* te.refiner(X, ee);
    }
  });
}
function AB(Y) {
  const X = zr$1(Y), ee = typeof Y;
  return new Nr({
    type: "literal",
    schema: ee === "string" || ee === "number" || ee === "boolean" ? Y : null,
    validator(te) {
      return te === Y || `Expected the literal \`${X}\`, but received: ${zr$1(te)}`;
    }
  });
}
function SB(Y, X) {
  return new Nr({
    type: "map",
    schema: null,
    *entries(ee) {
      if (Y && X && ee instanceof Map)
        for (const [te, ne] of ee.entries())
          yield [te, te, Y], yield [te, ne, X];
    },
    coercer(ee) {
      return ee instanceof Map ? new Map(ee) : ee;
    },
    validator(ee) {
      return ee instanceof Map || `Expected a \`Map\` object, but received: ${zr$1(ee)}`;
    }
  });
}
function Gm() {
  return On("never", () => !1);
}
function TB(Y) {
  return new Nr({
    ...Y,
    validator: (X, ee) => X === null || Y.validator(X, ee),
    refiner: (X, ee) => X === null || Y.refiner(X, ee)
  });
}
function IB() {
  return On("number", (Y) => typeof Y == "number" && !isNaN(Y) || `Expected a number, but received: ${zr$1(Y)}`);
}
function pf(Y) {
  const X = Y ? Object.keys(Y) : [], ee = Gm();
  return new Nr({
    type: "object",
    schema: Y || null,
    *entries(te) {
      if (Y && ri(te)) {
        const ne = new Set(Object.keys(te));
        for (const ie of X)
          ne.delete(ie), yield [ie, te[ie], Y[ie]];
        for (const ie of ne)
          yield [ie, te[ie], ee];
      }
    },
    validator(te) {
      return ri(te) || `Expected an object, but received: ${zr$1(te)}`;
    },
    coercer(te) {
      return ri(te) ? { ...te } : te;
    }
  });
}
function t3(Y) {
  return new Nr({
    ...Y,
    validator: (X, ee) => X === void 0 || Y.validator(X, ee),
    refiner: (X, ee) => X === void 0 || Y.refiner(X, ee)
  });
}
function RB(Y, X) {
  return new Nr({
    type: "record",
    schema: null,
    *entries(ee) {
      if (ri(ee))
        for (const te in ee) {
          const ne = ee[te];
          yield [te, te, Y], yield [te, ne, X];
        }
    },
    validator(ee) {
      return ri(ee) || `Expected an object, but received: ${zr$1(ee)}`;
    }
  });
}
function CB() {
  return On("regexp", (Y) => Y instanceof RegExp);
}
function PB(Y) {
  return new Nr({
    type: "set",
    schema: null,
    *entries(X) {
      if (Y && X instanceof Set)
        for (const ee of X)
          yield [ee, ee, Y];
    },
    coercer(X) {
      return X instanceof Set ? new Set(X) : X;
    },
    validator(X) {
      return X instanceof Set || `Expected a \`Set\` object, but received: ${zr$1(X)}`;
    }
  });
}
function r3() {
  return On("string", (Y) => typeof Y == "string" || `Expected a string, but received: ${zr$1(Y)}`);
}
function OB(Y) {
  const X = Gm();
  return new Nr({
    type: "tuple",
    schema: null,
    *entries(ee) {
      if (Array.isArray(ee)) {
        const te = Math.max(Y.length, ee.length);
        for (let ne = 0; ne < te; ne++)
          yield [ne, ee[ne], Y[ne] || X];
      }
    },
    validator(ee) {
      return Array.isArray(ee) || `Expected an array, but received: ${zr$1(ee)}`;
    }
  });
}
function Vm(Y) {
  const X = Object.keys(Y);
  return new Nr({
    type: "type",
    schema: Y,
    *entries(ee) {
      if (ri(ee))
        for (const te of X)
          yield [te, ee[te], Y[te]];
    },
    validator(ee) {
      return ri(ee) || `Expected an object, but received: ${zr$1(ee)}`;
    },
    coercer(ee) {
      return ri(ee) ? { ...ee } : ee;
    }
  });
}
function BB(Y) {
  const X = Y.map((ee) => ee.type).join(" | ");
  return new Nr({
    type: "union",
    schema: null,
    coercer(ee) {
      for (const te of Y) {
        const [ne, ie] = te.validate(ee, { coerce: !0 });
        if (!ne)
          return ie;
      }
      return ee;
    },
    validator(ee, te) {
      const ne = [];
      for (const ie of Y) {
        const [...oe] = zm(ee, ie, te), [se] = oe;
        if (se[0])
          for (const [ae] of oe)
            ae && ne.push(ae);
        else
          return [];
      }
      return [
        `Expected the value to satisfy a union of \`${X}\`, but received: ${zr$1(ee)}`,
        ...ne
      ];
    }
  });
}
function n3() {
  return On("unknown", () => !0);
}
function Wm(Y, X, ee) {
  return new Nr({
    ...Y,
    coercer: (te, ne) => qm(te, X) ? Y.coercer(ee(te, ne), ne) : Y.coercer(te, ne)
  });
}
function NB(Y, X, ee = {}) {
  return Wm(Y, n3(), (te) => {
    const ne = typeof X == "function" ? X() : X;
    if (te === void 0)
      return ne;
    if (!ee.strict && Z1(te) && Z1(ne)) {
      const ie = { ...te };
      let oe = !1;
      for (const se in ne)
        ie[se] === void 0 && (ie[se] = ne[se], oe = !0);
      if (oe)
        return ie;
    }
    return te;
  });
}
function kB(Y) {
  return Wm(Y, r3(), (X) => X.trim());
}
function MB(Y) {
  return Yo(Y, "empty", (X) => {
    const ee = i3(X);
    return ee === 0 || `Expected an empty ${Y.type} but received one with a size of \`${ee}\``;
  });
}
function i3(Y) {
  return Y instanceof Map || Y instanceof Set ? Y.size : Y.length;
}
function LB(Y, X, ee = {}) {
  const { exclusive: te } = ee;
  return Yo(Y, "max", (ne) => te ? ne < X : ne <= X || `Expected a ${Y.type} less than ${te ? "" : "or equal to "}${X} but received \`${ne}\``);
}
function FB(Y, X, ee = {}) {
  const { exclusive: te } = ee;
  return Yo(Y, "min", (ne) => te ? ne > X : ne >= X || `Expected a ${Y.type} greater than ${te ? "" : "or equal to "}${X} but received \`${ne}\``);
}
function $B(Y) {
  return Yo(Y, "nonempty", (X) => i3(X) > 0 || `Expected a nonempty ${Y.type} but received an empty one`);
}
function DB(Y, X) {
  return Yo(Y, "pattern", (ee) => X.test(ee) || `Expected a ${Y.type} matching \`/${X.source}/\` but received "${ee}"`);
}
function UB(Y, X, ee = X) {
  const te = `Expected a ${Y.type}`, ne = X === ee ? `of \`${X}\`` : `between \`${X}\` and \`${ee}\``;
  return Yo(Y, "size", (ie) => {
    if (typeof ie == "number" || ie instanceof Date)
      return X <= ie && ie <= ee || `${te} ${ne} but received \`${ie}\``;
    if (ie instanceof Map || ie instanceof Set) {
      const { size: oe } = ie;
      return X <= oe && oe <= ee || `${te} with a size ${ne} but received one with a size of \`${oe}\``;
    } else {
      const { length: oe } = ie;
      return X <= oe && oe <= ee || `${te} with a length ${ne} but received one with a length of \`${oe}\``;
    }
  });
}
function Yo(Y, X, ee) {
  return new Nr({
    ...Y,
    *refiner(te, ne) {
      yield* Y.refiner(te, ne);
      const ie = ee(te, ne), oe = rg(ie, ne, Y, te);
      for (const se of oe)
        yield { ...se, refinement: X };
    }
  });
}
const jB = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Struct: Nr,
  StructError: X_,
  any: pB,
  array: gB,
  assert: Z_,
  assign: oB,
  bigint: mB,
  boolean: yB,
  coerce: Wm,
  create: Q_,
  date: bB,
  defaulted: NB,
  define: On,
  deprecated: aB,
  dynamic: cB,
  empty: MB,
  enums: xB,
  func: wB,
  instance: vB,
  integer: EB,
  intersection: _B,
  is: qm,
  lazy: uB,
  literal: AB,
  map: SB,
  mask: e3,
  max: LB,
  min: FB,
  never: Gm,
  nonempty: $B,
  nullable: TB,
  number: IB,
  object: pf,
  omit: fB,
  optional: t3,
  partial: lB,
  pattern: DB,
  pick: dB,
  record: RB,
  refine: Yo,
  regexp: CB,
  set: PB,
  size: UB,
  string: r3,
  struct: hB,
  trimmed: kB,
  tuple: OB,
  type: Vm,
  union: BB,
  unknown: n3,
  validate: Ec
}, Symbol.toStringTag, { value: "Module" })), ns = /* @__PURE__ */ _d(jB);
Object.defineProperty(oi, "__esModule", { value: !0 });
function HB(Y) {
  let X, ee = Y[0], te = 1;
  for (; te < Y.length; ) {
    const ne = Y[te], ie = Y[te + 1];
    if (te += 2, (ne === "optionalAccess" || ne === "optionalCall") && ee == null)
      return;
    ne === "access" || ne === "optionalAccess" ? (X = ee, ee = ie(ee)) : (ne === "call" || ne === "optionalCall") && (ee = ie((...oe) => ee.call(X, ...oe)), X = void 0);
  }
  return ee;
}
var zB = mo, qB = ns;
function GB(Y) {
  return typeof HB([Y, "optionalAccess", (X) => X.prototype, "optionalAccess", (X) => X.constructor, "optionalAccess", (X) => X.name]) == "string";
}
function VB(Y) {
  return zB.getErrorMessage.call(void 0, Y).replace(/\.$/u, "");
}
function s3(Y, X) {
  return GB(Y) ? new Y({
    message: X
  }) : Y({
    message: X
  });
}
var Km = class extends Error {
  constructor(Y) {
    super(Y.message), this.code = "ERR_ASSERTION";
  }
};
function WB(Y, X = "Assertion failed.", ee = Km) {
  if (!Y)
    throw X instanceof Error ? X : s3(ee, X);
}
function KB(Y, X, ee = "Assertion failed", te = Km) {
  try {
    qB.assert.call(void 0, Y, X);
  } catch (ne) {
    throw s3(
      te,
      `${ee}: ${VB(ne)}.`
    );
  }
}
function JB(Y) {
  throw new Error(
    "Invalid branch reached. Should be detected during compilation."
  );
}
oi.AssertionError = Km;
oi.assert = WB;
oi.assertStruct = KB;
oi.assertExhaustive = JB;
var o3 = {};
(function(Y) {
  /*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  Object.defineProperty(Y, "__esModule", { value: !0 }), Y.bytes = Y.stringToBytes = Y.str = Y.bytesToString = Y.hex = Y.utf8 = Y.bech32m = Y.bech32 = Y.base58check = Y.createBase58check = Y.base58xmr = Y.base58xrp = Y.base58flickr = Y.base58 = Y.base64urlnopad = Y.base64url = Y.base64 = Y.base32crockford = Y.base32hex = Y.base32 = Y.base16 = Y.utils = Y.assertNumber = void 0;
  // @__NO_SIDE_EFFECTS__
  function X(ze) {
    if (!Number.isSafeInteger(ze))
      throw new Error(`Wrong integer: ${ze}`);
  }
  Y.assertNumber = X;
  function ee(ze) {
    return ze instanceof Uint8Array || ze != null && typeof ze == "object" && ze.constructor.name === "Uint8Array";
  }
  // @__NO_SIDE_EFFECTS__
  function te(...ze) {
    const fe = (Ce) => Ce, de = (Ce, Pe) => (Se) => Ce(Pe(Se)), be = ze.map((Ce) => Ce.encode).reduceRight(de, fe), Te = ze.map((Ce) => Ce.decode).reduce(de, fe);
    return { encode: be, decode: Te };
  }
  // @__NO_SIDE_EFFECTS__
  function ne(ze) {
    return {
      encode: (fe) => {
        if (!Array.isArray(fe) || fe.length && typeof fe[0] != "number")
          throw new Error("alphabet.encode input should be an array of numbers");
        return fe.map((de) => {
          if (de < 0 || de >= ze.length)
            throw new Error(`Digit index outside alphabet: ${de} (alphabet: ${ze.length})`);
          return ze[de];
        });
      },
      decode: (fe) => {
        if (!Array.isArray(fe) || fe.length && typeof fe[0] != "string")
          throw new Error("alphabet.decode input should be array of strings");
        return fe.map((de) => {
          if (typeof de != "string")
            throw new Error(`alphabet.decode: not string element=${de}`);
          const be = ze.indexOf(de);
          if (be === -1)
            throw new Error(`Unknown letter: "${de}". Allowed: ${ze}`);
          return be;
        });
      }
    };
  }
  // @__NO_SIDE_EFFECTS__
  function ie(ze = "") {
    if (typeof ze != "string")
      throw new Error("join separator should be string");
    return {
      encode: (fe) => {
        if (!Array.isArray(fe) || fe.length && typeof fe[0] != "string")
          throw new Error("join.encode input should be array of strings");
        for (let de of fe)
          if (typeof de != "string")
            throw new Error(`join.encode: non-string input=${de}`);
        return fe.join(ze);
      },
      decode: (fe) => {
        if (typeof fe != "string")
          throw new Error("join.decode input should be string");
        return fe.split(ze);
      }
    };
  }
  // @__NO_SIDE_EFFECTS__
  function oe(ze, fe = "=") {
    if (typeof fe != "string")
      throw new Error("padding chr should be string");
    return {
      encode(de) {
        if (!Array.isArray(de) || de.length && typeof de[0] != "string")
          throw new Error("padding.encode input should be array of strings");
        for (let be of de)
          if (typeof be != "string")
            throw new Error(`padding.encode: non-string input=${be}`);
        for (; de.length * ze % 8; )
          de.push(fe);
        return de;
      },
      decode(de) {
        if (!Array.isArray(de) || de.length && typeof de[0] != "string")
          throw new Error("padding.encode input should be array of strings");
        for (let Te of de)
          if (typeof Te != "string")
            throw new Error(`padding.decode: non-string input=${Te}`);
        let be = de.length;
        if (be * ze % 8)
          throw new Error("Invalid padding: string should have whole number of bytes");
        for (; be > 0 && de[be - 1] === fe; be--)
          if (!((be - 1) * ze % 8))
            throw new Error("Invalid padding: string has too much padding");
        return de.slice(0, be);
      }
    };
  }
  // @__NO_SIDE_EFFECTS__
  function se(ze) {
    if (typeof ze != "function")
      throw new Error("normalize fn should be function");
    return { encode: (fe) => fe, decode: (fe) => ze(fe) };
  }
  // @__NO_SIDE_EFFECTS__
  function ae(ze, fe, de) {
    if (fe < 2)
      throw new Error(`convertRadix: wrong from=${fe}, base cannot be less than 2`);
    if (de < 2)
      throw new Error(`convertRadix: wrong to=${de}, base cannot be less than 2`);
    if (!Array.isArray(ze))
      throw new Error("convertRadix: data should be array");
    if (!ze.length)
      return [];
    let be = 0;
    const Te = [], Ce = Array.from(ze);
    for (Ce.forEach((Pe) => {
      if (Pe < 0 || Pe >= fe)
        throw new Error(`Wrong integer: ${Pe}`);
    }); ; ) {
      let Pe = 0, Se = !0;
      for (let ke = be; ke < Ce.length; ke++) {
        const ge = Ce[ke], Ae = fe * Pe + ge;
        if (!Number.isSafeInteger(Ae) || fe * Pe / fe !== Pe || Ae - ge !== fe * Pe)
          throw new Error("convertRadix: carry overflow");
        Pe = Ae % de;
        const Ge = Math.floor(Ae / de);
        if (Ce[ke] = Ge, !Number.isSafeInteger(Ge) || Ge * de + Pe !== Ae)
          throw new Error("convertRadix: carry overflow");
        if (Se)
          Ge ? Se = !1 : be = ke;
        else
          continue;
      }
      if (Te.push(Pe), Se)
        break;
    }
    for (let Pe = 0; Pe < ze.length - 1 && ze[Pe] === 0; Pe++)
      Te.push(0);
    return Te.reverse();
  }
  const ue = /* @__NO_SIDE_EFFECTS__ */ (ze, fe) => fe ? /* @__PURE__ */ ue(fe, ze % fe) : ze, le = /* @__NO_SIDE_EFFECTS__ */ (ze, fe) => ze + (fe - /* @__PURE__ */ ue(ze, fe));
  // @__NO_SIDE_EFFECTS__
  function he(ze, fe, de, be) {
    if (!Array.isArray(ze))
      throw new Error("convertRadix2: data should be array");
    if (fe <= 0 || fe > 32)
      throw new Error(`convertRadix2: wrong from=${fe}`);
    if (de <= 0 || de > 32)
      throw new Error(`convertRadix2: wrong to=${de}`);
    if (/* @__PURE__ */ le(fe, de) > 32)
      throw new Error(`convertRadix2: carry overflow from=${fe} to=${de} carryBits=${/* @__PURE__ */ le(fe, de)}`);
    let Te = 0, Ce = 0;
    const Pe = 2 ** de - 1, Se = [];
    for (const ke of ze) {
      if (ke >= 2 ** fe)
        throw new Error(`convertRadix2: invalid data word=${ke} from=${fe}`);
      if (Te = Te << fe | ke, Ce + fe > 32)
        throw new Error(`convertRadix2: carry overflow pos=${Ce} from=${fe}`);
      for (Ce += fe; Ce >= de; Ce -= de)
        Se.push((Te >> Ce - de & Pe) >>> 0);
      Te &= 2 ** Ce - 1;
    }
    if (Te = Te << de - Ce & Pe, !be && Ce >= fe)
      throw new Error("Excess padding");
    if (!be && Te)
      throw new Error(`Non-zero padding: ${Te}`);
    return be && Ce > 0 && Se.push(Te >>> 0), Se;
  }
  // @__NO_SIDE_EFFECTS__
  function me(ze) {
    return {
      encode: (fe) => {
        if (!ee(fe))
          throw new Error("radix.encode input should be Uint8Array");
        return /* @__PURE__ */ ae(Array.from(fe), 2 ** 8, ze);
      },
      decode: (fe) => {
        if (!Array.isArray(fe) || fe.length && typeof fe[0] != "number")
          throw new Error("radix.decode input should be array of numbers");
        return Uint8Array.from(/* @__PURE__ */ ae(fe, ze, 2 ** 8));
      }
    };
  }
  // @__NO_SIDE_EFFECTS__
  function ye(ze, fe = !1) {
    if (ze <= 0 || ze > 32)
      throw new Error("radix2: bits should be in (0..32]");
    if (/* @__PURE__ */ le(8, ze) > 32 || /* @__PURE__ */ le(ze, 8) > 32)
      throw new Error("radix2: carry overflow");
    return {
      encode: (de) => {
        if (!ee(de))
          throw new Error("radix2.encode input should be Uint8Array");
        return /* @__PURE__ */ he(Array.from(de), 8, ze, !fe);
      },
      decode: (de) => {
        if (!Array.isArray(de) || de.length && typeof de[0] != "number")
          throw new Error("radix2.decode input should be array of numbers");
        return Uint8Array.from(/* @__PURE__ */ he(de, ze, 8, fe));
      }
    };
  }
  // @__NO_SIDE_EFFECTS__
  function we(ze) {
    if (typeof ze != "function")
      throw new Error("unsafeWrapper fn should be function");
    return function(...fe) {
      try {
        return ze.apply(null, fe);
      } catch {
      }
    };
  }
  // @__NO_SIDE_EFFECTS__
  function Ee(ze, fe) {
    if (typeof fe != "function")
      throw new Error("checksum fn should be function");
    return {
      encode(de) {
        if (!ee(de))
          throw new Error("checksum.encode: input should be Uint8Array");
        const be = fe(de).slice(0, ze), Te = new Uint8Array(de.length + ze);
        return Te.set(de), Te.set(be, de.length), Te;
      },
      decode(de) {
        if (!ee(de))
          throw new Error("checksum.decode: input should be Uint8Array");
        const be = de.slice(0, -ze), Te = fe(be).slice(0, ze), Ce = de.slice(-ze);
        for (let Pe = 0; Pe < ze; Pe++)
          if (Te[Pe] !== Ce[Pe])
            throw new Error("Invalid checksum");
        return be;
      }
    };
  }
  Y.utils = {
    alphabet: ne,
    chain: te,
    checksum: Ee,
    convertRadix: ae,
    convertRadix2: he,
    radix: me,
    radix2: ye,
    join: ie,
    padding: oe
  }, Y.base16 = /* @__PURE__ */ te(/* @__PURE__ */ ye(4), /* @__PURE__ */ ne("0123456789ABCDEF"), /* @__PURE__ */ ie("")), Y.base32 = /* @__PURE__ */ te(/* @__PURE__ */ ye(5), /* @__PURE__ */ ne("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), /* @__PURE__ */ oe(5), /* @__PURE__ */ ie("")), Y.base32hex = /* @__PURE__ */ te(/* @__PURE__ */ ye(5), /* @__PURE__ */ ne("0123456789ABCDEFGHIJKLMNOPQRSTUV"), /* @__PURE__ */ oe(5), /* @__PURE__ */ ie("")), Y.base32crockford = /* @__PURE__ */ te(/* @__PURE__ */ ye(5), /* @__PURE__ */ ne("0123456789ABCDEFGHJKMNPQRSTVWXYZ"), /* @__PURE__ */ ie(""), /* @__PURE__ */ se((ze) => ze.toUpperCase().replace(/O/g, "0").replace(/[IL]/g, "1"))), Y.base64 = /* @__PURE__ */ te(/* @__PURE__ */ ye(6), /* @__PURE__ */ ne("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), /* @__PURE__ */ oe(6), /* @__PURE__ */ ie("")), Y.base64url = /* @__PURE__ */ te(/* @__PURE__ */ ye(6), /* @__PURE__ */ ne("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), /* @__PURE__ */ oe(6), /* @__PURE__ */ ie("")), Y.base64urlnopad = /* @__PURE__ */ te(/* @__PURE__ */ ye(6), /* @__PURE__ */ ne("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), /* @__PURE__ */ ie(""));
  const Re = (ze) => /* @__PURE__ */ te(/* @__PURE__ */ me(58), /* @__PURE__ */ ne(ze), /* @__PURE__ */ ie(""));
  Y.base58 = Re("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"), Y.base58flickr = Re("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"), Y.base58xrp = Re("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz");
  const Ue = [0, 2, 3, 5, 6, 7, 9, 10, 11];
  Y.base58xmr = {
    encode(ze) {
      let fe = "";
      for (let de = 0; de < ze.length; de += 8) {
        const be = ze.subarray(de, de + 8);
        fe += Y.base58.encode(be).padStart(Ue[be.length], "1");
      }
      return fe;
    },
    decode(ze) {
      let fe = [];
      for (let de = 0; de < ze.length; de += 11) {
        const be = ze.slice(de, de + 11), Te = Ue.indexOf(be.length), Ce = Y.base58.decode(be);
        for (let Pe = 0; Pe < Ce.length - Te; Pe++)
          if (Ce[Pe] !== 0)
            throw new Error("base58xmr: wrong padding");
        fe = fe.concat(Array.from(Ce.slice(Ce.length - Te)));
      }
      return Uint8Array.from(fe);
    }
  };
  const Me = (ze) => /* @__PURE__ */ te(/* @__PURE__ */ Ee(4, (fe) => ze(ze(fe))), Y.base58);
  Y.createBase58check = Me, Y.base58check = Y.createBase58check;
  const De = /* @__PURE__ */ te(/* @__PURE__ */ ne("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), /* @__PURE__ */ ie("")), Fe = [996825010, 642813549, 513874426, 1027748829, 705979059];
  // @__NO_SIDE_EFFECTS__
  function Ke(ze) {
    const fe = ze >> 25;
    let de = (ze & 33554431) << 5;
    for (let be = 0; be < Fe.length; be++)
      (fe >> be & 1) === 1 && (de ^= Fe[be]);
    return de;
  }
  // @__NO_SIDE_EFFECTS__
  function tt(ze, fe, de = 1) {
    const be = ze.length;
    let Te = 1;
    for (let Ce = 0; Ce < be; Ce++) {
      const Pe = ze.charCodeAt(Ce);
      if (Pe < 33 || Pe > 126)
        throw new Error(`Invalid prefix (${ze})`);
      Te = /* @__PURE__ */ Ke(Te) ^ Pe >> 5;
    }
    Te = /* @__PURE__ */ Ke(Te);
    for (let Ce = 0; Ce < be; Ce++)
      Te = /* @__PURE__ */ Ke(Te) ^ ze.charCodeAt(Ce) & 31;
    for (let Ce of fe)
      Te = /* @__PURE__ */ Ke(Te) ^ Ce;
    for (let Ce = 0; Ce < 6; Ce++)
      Te = /* @__PURE__ */ Ke(Te);
    return Te ^= de, De.encode(/* @__PURE__ */ he([Te % 2 ** 30], 30, 5, !1));
  }
  // @__NO_SIDE_EFFECTS__
  function rt(ze) {
    const fe = ze === "bech32" ? 1 : 734539939, de = /* @__PURE__ */ ye(5), be = de.decode, Te = de.encode, Ce = /* @__PURE__ */ we(be);
    function Pe(Ae, Ge, Xe = 90) {
      if (typeof Ae != "string")
        throw new Error(`bech32.encode prefix should be string, not ${typeof Ae}`);
      if (!Array.isArray(Ge) || Ge.length && typeof Ge[0] != "number")
        throw new Error(`bech32.encode words should be array of numbers, not ${typeof Ge}`);
      const $e = Ae.length + 7 + Ge.length;
      if (Xe !== !1 && $e > Xe)
        throw new TypeError(`Length ${$e} exceeds limit ${Xe}`);
      const Ze = Ae.toLowerCase(), ot = /* @__PURE__ */ tt(Ze, Ge, fe);
      return `${Ze}1${De.encode(Ge)}${ot}`;
    }
    function Se(Ae, Ge = 90) {
      if (typeof Ae != "string")
        throw new Error(`bech32.decode input should be string, not ${typeof Ae}`);
      if (Ae.length < 8 || Ge !== !1 && Ae.length > Ge)
        throw new TypeError(`Wrong string length: ${Ae.length} (${Ae}). Expected (8..${Ge})`);
      const Xe = Ae.toLowerCase();
      if (Ae !== Xe && Ae !== Ae.toUpperCase())
        throw new Error("String must be lowercase or uppercase");
      Ae = Xe;
      const $e = Ae.lastIndexOf("1");
      if ($e === 0 || $e === -1)
        throw new Error('Letter "1" must be present between prefix and data only');
      const Ze = Ae.slice(0, $e), ot = Ae.slice($e + 1);
      if (ot.length < 6)
        throw new Error("Data must be at least 6 characters long");
      const ct = De.decode(ot).slice(0, -6), At = /* @__PURE__ */ tt(Ze, ct, fe);
      if (!ot.endsWith(At))
        throw new Error(`Invalid checksum in ${Ae}: expected "${At}"`);
      return { prefix: Ze, words: ct };
    }
    const ke = /* @__PURE__ */ we(Se);
    function ge(Ae) {
      const { prefix: Ge, words: Xe } = Se(Ae, !1);
      return { prefix: Ge, words: Xe, bytes: be(Xe) };
    }
    return { encode: Pe, decode: Se, decodeToBytes: ge, decodeUnsafe: ke, fromWords: be, fromWordsUnsafe: Ce, toWords: Te };
  }
  Y.bech32 = /* @__PURE__ */ rt("bech32"), Y.bech32m = /* @__PURE__ */ rt("bech32m"), Y.utf8 = {
    encode: (ze) => new TextDecoder().decode(ze),
    decode: (ze) => new TextEncoder().encode(ze)
  }, Y.hex = /* @__PURE__ */ te(/* @__PURE__ */ ye(4), /* @__PURE__ */ ne("0123456789abcdef"), /* @__PURE__ */ ie(""), /* @__PURE__ */ se((ze) => {
    if (typeof ze != "string" || ze.length % 2)
      throw new TypeError(`hex.decode: expected string, got ${typeof ze} with length ${ze.length}`);
    return ze.toLowerCase();
  }));
  const it = {
    utf8: Y.utf8,
    hex: Y.hex,
    base16: Y.base16,
    base32: Y.base32,
    base64: Y.base64,
    base64url: Y.base64url,
    base58: Y.base58,
    base58xmr: Y.base58xmr
  }, _t = "Invalid encoding type. Available types: utf8, hex, base16, base32, base64, base64url, base58, base58xmr", Dt = (ze, fe) => {
    if (typeof ze != "string" || !it.hasOwnProperty(ze))
      throw new TypeError(_t);
    if (!ee(fe))
      throw new TypeError("bytesToString() expects Uint8Array");
    return it[ze].encode(fe);
  };
  Y.bytesToString = Dt, Y.str = Y.bytesToString;
  const je = (ze, fe) => {
    if (!it.hasOwnProperty(ze))
      throw new TypeError(_t);
    if (typeof fe != "string")
      throw new TypeError("stringToBytes() expects string");
    return it[ze].decode(fe);
  };
  Y.stringToBytes = je, Y.bytes = Y.stringToBytes;
})(o3);
Object.defineProperty(qt, "__esModule", { value: !0 });
function YB(Y) {
  let X, ee = Y[0], te = 1;
  for (; te < Y.length; ) {
    const ne = Y[te], ie = Y[te + 1];
    if (te += 2, (ne === "optionalAccess" || ne === "optionalCall") && ee == null)
      return;
    ne === "access" || ne === "optionalAccess" ? (X = ee, ee = ie(ee)) : (ne === "call" || ne === "optionalCall") && (ee = ie((...oe) => ee.call(X, ...oe)), X = void 0);
  }
  return ee;
}
var Jr = oi, XB = sr$1, wn = ns, a3 = o3, Q1 = 48, ew = 58, tw = 87;
function ZB() {
  const Y = [];
  return () => {
    if (Y.length === 0)
      for (let X = 0; X < 256; X++)
        Y.push(X.toString(16).padStart(2, "0"));
    return Y;
  };
}
var QB = ZB();
function Jm(Y) {
  return Y instanceof Uint8Array;
}
function Xo(Y) {
  Jr.assert.call(void 0, Jm(Y), "Value must be a Uint8Array.");
}
function Ym(Y) {
  if (Xo(Y), Y.length === 0)
    return "0x";
  const X = QB(), ee = new Array(Y.length);
  for (let te = 0; te < Y.length; te++)
    ee[te] = X[Y[te]];
  return v3$2(ee.join(""));
}
function c3(Y) {
  Xo(Y);
  const X = Ym(Y);
  return BigInt(X);
}
function eN(Y) {
  Xo(Y);
  let X = BigInt(0);
  for (const ee of Y)
    X = (X << BigInt(8)) + BigInt(ee);
  return BigInt.asIntN(Y.length * 8, X);
}
function tN(Y) {
  Xo(Y);
  const X = c3(Y);
  return Jr.assert.call(
    void 0,
    X <= BigInt(Number.MAX_SAFE_INTEGER),
    "Number is not a safe integer. Use `bytesToBigInt` instead."
  ), Number(X);
}
function rN(Y) {
  return Xo(Y), new TextDecoder().decode(Y);
}
function nN(Y) {
  return Xo(Y), a3.base64.encode(Y);
}
function Kd(Y) {
  if (YB([Y, "optionalAccess", (ne) => ne.toLowerCase, "optionalCall", (ne) => ne()]) === "0x")
    return new Uint8Array();
  b3(Y);
  const X = Jl(Y).toLowerCase(), ee = X.length % 2 === 0 ? X : `0${X}`, te = new Uint8Array(ee.length / 2);
  for (let ne = 0; ne < te.length; ne++) {
    const ie = ee.charCodeAt(ne * 2), oe = ee.charCodeAt(ne * 2 + 1), se = ie - (ie < ew ? Q1 : tw), ae = oe - (oe < ew ? Q1 : tw);
    te[ne] = se * 16 + ae;
  }
  return te;
}
function u3(Y) {
  Jr.assert.call(void 0, typeof Y == "bigint", "Value must be a bigint."), Jr.assert.call(void 0, Y >= BigInt(0), "Value must be a non-negative bigint.");
  const X = Y.toString(16);
  return Kd(X);
}
function iN(Y, X) {
  Jr.assert.call(void 0, X > 0);
  const ee = Y >> BigInt(31);
  return !((~Y & ee) + (Y & ~ee) >> BigInt(X * 8 + -1));
}
function sN(Y, X) {
  Jr.assert.call(void 0, typeof Y == "bigint", "Value must be a bigint."), Jr.assert.call(void 0, typeof X == "number", "Byte length must be a number."), Jr.assert.call(void 0, X > 0, "Byte length must be greater than 0."), Jr.assert.call(
    void 0,
    iN(Y, X),
    "Byte length is too small to represent the given value."
  );
  let ee = Y;
  const te = new Uint8Array(X);
  for (let ne = 0; ne < te.length; ne++)
    te[ne] = Number(BigInt.asUintN(8, ee)), ee >>= BigInt(8);
  return te.reverse();
}
function f3(Y) {
  Jr.assert.call(void 0, typeof Y == "number", "Value must be a number."), Jr.assert.call(void 0, Y >= 0, "Value must be a non-negative number."), Jr.assert.call(
    void 0,
    Number.isSafeInteger(Y),
    "Value is not a safe integer. Use `bigIntToBytes` instead."
  );
  const X = Y.toString(16);
  return Kd(X);
}
function l3(Y) {
  return Jr.assert.call(void 0, typeof Y == "string", "Value must be a string."), new TextEncoder().encode(Y);
}
function oN(Y) {
  return Jr.assert.call(void 0, typeof Y == "string", "Value must be a string."), a3.base64.decode(Y);
}
function d3(Y) {
  if (typeof Y == "bigint")
    return u3(Y);
  if (typeof Y == "number")
    return f3(Y);
  if (typeof Y == "string")
    return Y.startsWith("0x") ? Kd(Y) : l3(Y);
  if (Jm(Y))
    return Y;
  throw new TypeError(`Unsupported value type: "${typeof Y}".`);
}
function aN(Y) {
  const X = new Array(Y.length);
  let ee = 0;
  for (let ne = 0; ne < Y.length; ne++) {
    const ie = d3(Y[ne]);
    X[ne] = ie, ee += ie.length;
  }
  const te = new Uint8Array(ee);
  for (let ne = 0, ie = 0; ne < X.length; ne++)
    te.set(X[ne], ie), ie += X[ne].length;
  return te;
}
function cN(Y) {
  if (typeof Buffer < "u" && Y instanceof Buffer) {
    const X = Y.buffer.slice(
      Y.byteOffset,
      Y.byteOffset + Y.byteLength
    );
    return new DataView(X);
  }
  return new DataView(Y.buffer, Y.byteOffset, Y.byteLength);
}
var h3 = wn.pattern.call(void 0, wn.string.call(void 0), /^(?:0x)?[0-9a-f]+$/iu), p3 = wn.pattern.call(void 0, wn.string.call(void 0), /^0x[0-9a-f]+$/iu), g3 = wn.pattern.call(
  void 0,
  wn.string.call(void 0),
  /^0x[0-9a-f]{40}$/u
), Xm = wn.pattern.call(
  void 0,
  wn.string.call(void 0),
  /^0x[0-9a-fA-F]{40}$/u
);
function m3(Y) {
  return wn.is.call(void 0, Y, h3);
}
function y3(Y) {
  return wn.is.call(void 0, Y, p3);
}
function b3(Y) {
  Jr.assert.call(void 0, m3(Y), "Value must be a hexadecimal string.");
}
function uN(Y) {
  Jr.assert.call(
    void 0,
    y3(Y),
    'Value must be a hexadecimal string, starting with "0x".'
  );
}
function fN(Y) {
  return wn.is.call(void 0, Y, g3) || w3(Y);
}
function x3(Y) {
  Jr.assert.call(void 0, wn.is.call(void 0, Y, Xm), "Invalid hex address.");
  const X = Jl(Y.toLowerCase()), ee = Jl(Ym(XB.keccak_256.call(void 0, X)));
  return `0x${X.split("").map((te, ne) => {
    const ie = ee[ne];
    return Jr.assert.call(void 0, wn.is.call(void 0, ie, wn.string.call(void 0)), "Hash shorter than address."), parseInt(ie, 16) > 7 ? te.toUpperCase() : te;
  }).join("")}`;
}
function w3(Y) {
  return wn.is.call(void 0, Y, Xm) ? x3(Y) === Y : !1;
}
function v3$2(Y) {
  return Y.startsWith("0x") ? Y : Y.startsWith("0X") ? `0x${Y.substring(2)}` : `0x${Y}`;
}
function Jl(Y) {
  return Y.startsWith("0x") || Y.startsWith("0X") ? Y.substring(2) : Y;
}
qt.HexStruct = h3;
qt.StrictHexStruct = p3;
qt.HexAddressStruct = g3;
qt.HexChecksumAddressStruct = Xm;
qt.isHexString = m3;
qt.isStrictHexString = y3;
qt.assertIsHexString = b3;
qt.assertIsStrictHexString = uN;
qt.isValidHexAddress = fN;
qt.getChecksumAddress = x3;
qt.isValidChecksumAddress = w3;
qt.add0x = v3$2;
qt.remove0x = Jl;
qt.isBytes = Jm;
qt.assertIsBytes = Xo;
qt.bytesToHex = Ym;
qt.bytesToBigInt = c3;
qt.bytesToSignedBigInt = eN;
qt.bytesToNumber = tN;
qt.bytesToString = rN;
qt.bytesToBase64 = nN;
qt.hexToBytes = Kd;
qt.bigIntToBytes = u3;
qt.signedBigIntToBytes = sN;
qt.numberToBytes = f3;
qt.stringToBytes = l3;
qt.base64ToBytes = oN;
qt.valueToBytes = d3;
qt.concatBytes = aN;
qt.createDataView = cN;
Object.defineProperty(vc, "__esModule", { value: !0 });
var Ou = qt, Ba = oi, lN = (Y) => (Ba.assert.call(void 0, typeof Y == "number", "Value must be a number."), Ba.assert.call(void 0, Y >= 0, "Value must be a non-negative number."), Ba.assert.call(
  void 0,
  Number.isSafeInteger(Y),
  "Value is not a safe integer. Use `bigIntToHex` instead."
), Ou.add0x.call(void 0, Y.toString(16))), dN = (Y) => (Ba.assert.call(void 0, typeof Y == "bigint", "Value must be a bigint."), Ba.assert.call(void 0, Y >= 0, "Value must be a non-negative bigint."), Ou.add0x.call(void 0, Y.toString(16))), hN = (Y) => {
  Ou.assertIsHexString.call(void 0, Y);
  const X = parseInt(Y, 16);
  return Ba.assert.call(
    void 0,
    Number.isSafeInteger(X),
    "Value is not a safe integer. Use `hexToBigInt` instead."
  ), X;
}, pN = (Y) => (Ou.assertIsHexString.call(void 0, Y), BigInt(Ou.add0x.call(void 0, Y)));
vc.numberToHex = lN;
vc.bigIntToHex = dN;
vc.hexToNumber = hN;
vc.hexToBigInt = pN;
var Zm = {};
Object.defineProperty(Zm, "__esModule", { value: !0 });
function gN({
  suppressUnhandledRejection: Y = !1
} = {}) {
  let X, ee;
  const te = new Promise(
    (ne, ie) => {
      X = ne, ee = ie;
    }
  );
  return Y && te.catch((ne) => {
  }), { promise: te, resolve: X, reject: ee };
}
Zm.createDeferredPromise = gN;
var gf = {};
Object.defineProperty(gf, "__esModule", { value: !0 });
var E3 = /* @__PURE__ */ ((Y) => (Y[Y.Millisecond = 1] = "Millisecond", Y[Y.Second = 1e3] = "Second", Y[Y.Minute = 6e4] = "Minute", Y[Y.Hour = 36e5] = "Hour", Y[Y.Day = 864e5] = "Day", Y[Y.Week = 6048e5] = "Week", Y[Y.Year = 31536e6] = "Year", Y))(E3 || {}), mN = (Y) => Number.isInteger(Y) && Y >= 0, _3 = (Y, X) => {
  if (!mN(Y))
    throw new Error(
      `"${X}" must be a non-negative integer. Received: "${Y}".`
    );
};
function yN(Y, X) {
  return _3(Y, "count"), Y * X;
}
function bN(Y) {
  return _3(Y, "timestamp"), Date.now() - Y;
}
gf.Duration = E3;
gf.inMilliseconds = yN;
gf.timeSince = bN;
var Ei = {}, ng = { exports: {} };
const xN = "2.0.0", A3 = 256, wN = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
9007199254740991, vN = 16, EN = A3 - 6, _N = [
  "major",
  "premajor",
  "minor",
  "preminor",
  "patch",
  "prepatch",
  "prerelease"
];
var Jd = {
  MAX_LENGTH: A3,
  MAX_SAFE_COMPONENT_LENGTH: vN,
  MAX_SAFE_BUILD_LENGTH: EN,
  MAX_SAFE_INTEGER: wN,
  RELEASE_TYPES: _N,
  SEMVER_SPEC_VERSION: xN,
  FLAG_INCLUDE_PRERELEASE: 1,
  FLAG_LOOSE: 2
};
const AN = typeof process == "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...Y) => console.error("SEMVER", ...Y) : () => {
};
var Yd = AN;
(function(Y, X) {
  const {
    MAX_SAFE_COMPONENT_LENGTH: ee,
    MAX_SAFE_BUILD_LENGTH: te,
    MAX_LENGTH: ne
  } = Jd, ie = Yd;
  X = Y.exports = {};
  const oe = X.re = [], se = X.safeRe = [], ae = X.src = [], ue = X.t = {};
  let le = 0;
  const he = "[a-zA-Z0-9-]", me = [
    ["\\s", 1],
    ["\\d", ne],
    [he, te]
  ], ye = (Ee) => {
    for (const [Re, Ue] of me)
      Ee = Ee.split(`${Re}*`).join(`${Re}{0,${Ue}}`).split(`${Re}+`).join(`${Re}{1,${Ue}}`);
    return Ee;
  }, we = (Ee, Re, Ue) => {
    const Me = ye(Re), De = le++;
    ie(Ee, De, Re), ue[Ee] = De, ae[De] = Re, oe[De] = new RegExp(Re, Ue ? "g" : void 0), se[De] = new RegExp(Me, Ue ? "g" : void 0);
  };
  we("NUMERICIDENTIFIER", "0|[1-9]\\d*"), we("NUMERICIDENTIFIERLOOSE", "\\d+"), we("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${he}*`), we("MAINVERSION", `(${ae[ue.NUMERICIDENTIFIER]})\\.(${ae[ue.NUMERICIDENTIFIER]})\\.(${ae[ue.NUMERICIDENTIFIER]})`), we("MAINVERSIONLOOSE", `(${ae[ue.NUMERICIDENTIFIERLOOSE]})\\.(${ae[ue.NUMERICIDENTIFIERLOOSE]})\\.(${ae[ue.NUMERICIDENTIFIERLOOSE]})`), we("PRERELEASEIDENTIFIER", `(?:${ae[ue.NUMERICIDENTIFIER]}|${ae[ue.NONNUMERICIDENTIFIER]})`), we("PRERELEASEIDENTIFIERLOOSE", `(?:${ae[ue.NUMERICIDENTIFIERLOOSE]}|${ae[ue.NONNUMERICIDENTIFIER]})`), we("PRERELEASE", `(?:-(${ae[ue.PRERELEASEIDENTIFIER]}(?:\\.${ae[ue.PRERELEASEIDENTIFIER]})*))`), we("PRERELEASELOOSE", `(?:-?(${ae[ue.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${ae[ue.PRERELEASEIDENTIFIERLOOSE]})*))`), we("BUILDIDENTIFIER", `${he}+`), we("BUILD", `(?:\\+(${ae[ue.BUILDIDENTIFIER]}(?:\\.${ae[ue.BUILDIDENTIFIER]})*))`), we("FULLPLAIN", `v?${ae[ue.MAINVERSION]}${ae[ue.PRERELEASE]}?${ae[ue.BUILD]}?`), we("FULL", `^${ae[ue.FULLPLAIN]}$`), we("LOOSEPLAIN", `[v=\\s]*${ae[ue.MAINVERSIONLOOSE]}${ae[ue.PRERELEASELOOSE]}?${ae[ue.BUILD]}?`), we("LOOSE", `^${ae[ue.LOOSEPLAIN]}$`), we("GTLT", "((?:<|>)?=?)"), we("XRANGEIDENTIFIERLOOSE", `${ae[ue.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), we("XRANGEIDENTIFIER", `${ae[ue.NUMERICIDENTIFIER]}|x|X|\\*`), we("XRANGEPLAIN", `[v=\\s]*(${ae[ue.XRANGEIDENTIFIER]})(?:\\.(${ae[ue.XRANGEIDENTIFIER]})(?:\\.(${ae[ue.XRANGEIDENTIFIER]})(?:${ae[ue.PRERELEASE]})?${ae[ue.BUILD]}?)?)?`), we("XRANGEPLAINLOOSE", `[v=\\s]*(${ae[ue.XRANGEIDENTIFIERLOOSE]})(?:\\.(${ae[ue.XRANGEIDENTIFIERLOOSE]})(?:\\.(${ae[ue.XRANGEIDENTIFIERLOOSE]})(?:${ae[ue.PRERELEASELOOSE]})?${ae[ue.BUILD]}?)?)?`), we("XRANGE", `^${ae[ue.GTLT]}\\s*${ae[ue.XRANGEPLAIN]}$`), we("XRANGELOOSE", `^${ae[ue.GTLT]}\\s*${ae[ue.XRANGEPLAINLOOSE]}$`), we("COERCEPLAIN", `(^|[^\\d])(\\d{1,${ee}})(?:\\.(\\d{1,${ee}}))?(?:\\.(\\d{1,${ee}}))?`), we("COERCE", `${ae[ue.COERCEPLAIN]}(?:$|[^\\d])`), we("COERCEFULL", ae[ue.COERCEPLAIN] + `(?:${ae[ue.PRERELEASE]})?(?:${ae[ue.BUILD]})?(?:$|[^\\d])`), we("COERCERTL", ae[ue.COERCE], !0), we("COERCERTLFULL", ae[ue.COERCEFULL], !0), we("LONETILDE", "(?:~>?)"), we("TILDETRIM", `(\\s*)${ae[ue.LONETILDE]}\\s+`, !0), X.tildeTrimReplace = "$1~", we("TILDE", `^${ae[ue.LONETILDE]}${ae[ue.XRANGEPLAIN]}$`), we("TILDELOOSE", `^${ae[ue.LONETILDE]}${ae[ue.XRANGEPLAINLOOSE]}$`), we("LONECARET", "(?:\\^)"), we("CARETTRIM", `(\\s*)${ae[ue.LONECARET]}\\s+`, !0), X.caretTrimReplace = "$1^", we("CARET", `^${ae[ue.LONECARET]}${ae[ue.XRANGEPLAIN]}$`), we("CARETLOOSE", `^${ae[ue.LONECARET]}${ae[ue.XRANGEPLAINLOOSE]}$`), we("COMPARATORLOOSE", `^${ae[ue.GTLT]}\\s*(${ae[ue.LOOSEPLAIN]})$|^$`), we("COMPARATOR", `^${ae[ue.GTLT]}\\s*(${ae[ue.FULLPLAIN]})$|^$`), we("COMPARATORTRIM", `(\\s*)${ae[ue.GTLT]}\\s*(${ae[ue.LOOSEPLAIN]}|${ae[ue.XRANGEPLAIN]})`, !0), X.comparatorTrimReplace = "$1$2$3", we("HYPHENRANGE", `^\\s*(${ae[ue.XRANGEPLAIN]})\\s+-\\s+(${ae[ue.XRANGEPLAIN]})\\s*$`), we("HYPHENRANGELOOSE", `^\\s*(${ae[ue.XRANGEPLAINLOOSE]})\\s+-\\s+(${ae[ue.XRANGEPLAINLOOSE]})\\s*$`), we("STAR", "(<|>)?=?\\s*\\*"), we("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$"), we("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
})(ng, ng.exports);
var mf = ng.exports;
const SN = Object.freeze({ loose: !0 }), TN = Object.freeze({}), IN = (Y) => Y ? typeof Y != "object" ? SN : Y : TN;
var Qm = IN;
const rw = /^[0-9]+$/, S3 = (Y, X) => {
  const ee = rw.test(Y), te = rw.test(X);
  return ee && te && (Y = +Y, X = +X), Y === X ? 0 : ee && !te ? -1 : te && !ee ? 1 : Y < X ? -1 : 1;
}, RN = (Y, X) => S3(X, Y);
var T3 = {
  compareIdentifiers: S3,
  rcompareIdentifiers: RN
};
const Jf = Yd, { MAX_LENGTH: nw, MAX_SAFE_INTEGER: Yf } = Jd, { safeRe: iw, t: sw } = mf, CN = Qm, { compareIdentifiers: aa } = T3;
let PN = class XX {
  constructor(X, ee) {
    if (ee = CN(ee), X instanceof XX) {
      if (X.loose === !!ee.loose && X.includePrerelease === !!ee.includePrerelease)
        return X;
      X = X.version;
    } else if (typeof X != "string")
      throw new TypeError(`Invalid version. Must be a string. Got type "${typeof X}".`);
    if (X.length > nw)
      throw new TypeError(
        `version is longer than ${nw} characters`
      );
    Jf("SemVer", X, ee), this.options = ee, this.loose = !!ee.loose, this.includePrerelease = !!ee.includePrerelease;
    const te = X.trim().match(ee.loose ? iw[sw.LOOSE] : iw[sw.FULL]);
    if (!te)
      throw new TypeError(`Invalid Version: ${X}`);
    if (this.raw = X, this.major = +te[1], this.minor = +te[2], this.patch = +te[3], this.major > Yf || this.major < 0)
      throw new TypeError("Invalid major version");
    if (this.minor > Yf || this.minor < 0)
      throw new TypeError("Invalid minor version");
    if (this.patch > Yf || this.patch < 0)
      throw new TypeError("Invalid patch version");
    te[4] ? this.prerelease = te[4].split(".").map((ne) => {
      if (/^[0-9]+$/.test(ne)) {
        const ie = +ne;
        if (ie >= 0 && ie < Yf)
          return ie;
      }
      return ne;
    }) : this.prerelease = [], this.build = te[5] ? te[5].split(".") : [], this.format();
  }
  format() {
    return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version;
  }
  toString() {
    return this.version;
  }
  compare(X) {
    if (Jf("SemVer.compare", this.version, this.options, X), !(X instanceof XX)) {
      if (typeof X == "string" && X === this.version)
        return 0;
      X = new XX(X, this.options);
    }
    return X.version === this.version ? 0 : this.compareMain(X) || this.comparePre(X);
  }
  compareMain(X) {
    return X instanceof XX || (X = new XX(X, this.options)), aa(this.major, X.major) || aa(this.minor, X.minor) || aa(this.patch, X.patch);
  }
  comparePre(X) {
    if (X instanceof XX || (X = new XX(X, this.options)), this.prerelease.length && !X.prerelease.length)
      return -1;
    if (!this.prerelease.length && X.prerelease.length)
      return 1;
    if (!this.prerelease.length && !X.prerelease.length)
      return 0;
    let ee = 0;
    do {
      const te = this.prerelease[ee], ne = X.prerelease[ee];
      if (Jf("prerelease compare", ee, te, ne), te === void 0 && ne === void 0)
        return 0;
      if (ne === void 0)
        return 1;
      if (te === void 0)
        return -1;
      if (te !== ne)
        return aa(te, ne);
    } while (++ee);
  }
  compareBuild(X) {
    X instanceof XX || (X = new XX(X, this.options));
    let ee = 0;
    do {
      const te = this.build[ee], ne = X.build[ee];
      if (Jf("prerelease compare", ee, te, ne), te === void 0 && ne === void 0)
        return 0;
      if (ne === void 0)
        return 1;
      if (te === void 0)
        return -1;
      if (te !== ne)
        return aa(te, ne);
    } while (++ee);
  }
  // preminor will bump the version up to the next minor release, and immediately
  // down to pre-release. premajor and prepatch work the same way.
  inc(X, ee, te) {
    switch (X) {
      case "premajor":
        this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", ee, te);
        break;
      case "preminor":
        this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", ee, te);
        break;
      case "prepatch":
        this.prerelease.length = 0, this.inc("patch", ee, te), this.inc("pre", ee, te);
        break;
      case "prerelease":
        this.prerelease.length === 0 && this.inc("patch", ee, te), this.inc("pre", ee, te);
        break;
      case "major":
        (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) && this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
        break;
      case "minor":
        (this.patch !== 0 || this.prerelease.length === 0) && this.minor++, this.patch = 0, this.prerelease = [];
        break;
      case "patch":
        this.prerelease.length === 0 && this.patch++, this.prerelease = [];
        break;
      case "pre": {
        const ne = Number(te) ? 1 : 0;
        if (!ee && te === !1)
          throw new Error("invalid increment argument: identifier is empty");
        if (this.prerelease.length === 0)
          this.prerelease = [ne];
        else {
          let ie = this.prerelease.length;
          for (; --ie >= 0; )
            typeof this.prerelease[ie] == "number" && (this.prerelease[ie]++, ie = -2);
          if (ie === -1) {
            if (ee === this.prerelease.join(".") && te === !1)
              throw new Error("invalid increment argument: identifier already exists");
            this.prerelease.push(ne);
          }
        }
        if (ee) {
          let ie = [ee, ne];
          te === !1 && (ie = [ee]), aa(this.prerelease[0], ee) === 0 ? isNaN(this.prerelease[1]) && (this.prerelease = ie) : this.prerelease = ie;
        }
        break;
      }
      default:
        throw new Error(`invalid increment argument: ${X}`);
    }
    return this.raw = this.format(), this.build.length && (this.raw += `+${this.build.join(".")}`), this;
  }
};
var _n = PN;
const ow = _n, ON = (Y, X, ee = !1) => {
  if (Y instanceof ow)
    return Y;
  try {
    return new ow(Y, X);
  } catch (te) {
    if (!ee)
      return null;
    throw te;
  }
};
var _c = ON;
const BN$3 = _c, NN = (Y, X) => {
  const ee = BN$3(Y, X);
  return ee ? ee.version : null;
};
var kN = NN;
const MN = _c, LN = (Y, X) => {
  const ee = MN(Y.trim().replace(/^[=v]+/, ""), X);
  return ee ? ee.version : null;
};
var FN = LN;
const aw = _n, $N = (Y, X, ee, te, ne) => {
  typeof ee == "string" && (ne = te, te = ee, ee = void 0);
  try {
    return new aw(
      Y instanceof aw ? Y.version : Y,
      ee
    ).inc(X, te, ne).version;
  } catch {
    return null;
  }
};
var DN = $N;
const cw = _c, UN = (Y, X) => {
  const ee = cw(Y, null, !0), te = cw(X, null, !0), ne = ee.compare(te);
  if (ne === 0)
    return null;
  const ie = ne > 0, oe = ie ? ee : te, se = ie ? te : ee, ae = !!oe.prerelease.length;
  if (se.prerelease.length && !ae)
    return !se.patch && !se.minor ? "major" : oe.patch ? "patch" : oe.minor ? "minor" : "major";
  const ue = ae ? "pre" : "";
  return ee.major !== te.major ? ue + "major" : ee.minor !== te.minor ? ue + "minor" : ee.patch !== te.patch ? ue + "patch" : "prerelease";
};
var jN = UN;
const HN = _n, zN = (Y, X) => new HN(Y, X).major;
var qN = zN;
const GN = _n, VN = (Y, X) => new GN(Y, X).minor;
var WN = VN;
const KN = _n, JN = (Y, X) => new KN(Y, X).patch;
var YN = JN;
const XN = _c, ZN = (Y, X) => {
  const ee = XN(Y, X);
  return ee && ee.prerelease.length ? ee.prerelease : null;
};
var QN = ZN;
const uw = _n, ek = (Y, X, ee) => new uw(Y, ee).compare(new uw(X, ee));
var _i = ek;
const tk = _i, rk = (Y, X, ee) => tk(X, Y, ee);
var nk = rk;
const ik = _i, sk = (Y, X) => ik(Y, X, !0);
var ok = sk;
const fw = _n, ak = (Y, X, ee) => {
  const te = new fw(Y, ee), ne = new fw(X, ee);
  return te.compare(ne) || te.compareBuild(ne);
};
var ey = ak;
const ck = ey, uk = (Y, X) => Y.sort((ee, te) => ck(ee, te, X));
var fk = uk;
const lk = ey, dk = (Y, X) => Y.sort((ee, te) => lk(te, ee, X));
var hk = dk;
const pk = _i, gk = (Y, X, ee) => pk(Y, X, ee) > 0;
var Xd = gk;
const mk = _i, yk = (Y, X, ee) => mk(Y, X, ee) < 0;
var ty = yk;
const bk = _i, xk = (Y, X, ee) => bk(Y, X, ee) === 0;
var I3 = xk;
const wk = _i, vk = (Y, X, ee) => wk(Y, X, ee) !== 0;
var R3 = vk;
const Ek = _i, _k = (Y, X, ee) => Ek(Y, X, ee) >= 0;
var ry = _k;
const Ak = _i, Sk = (Y, X, ee) => Ak(Y, X, ee) <= 0;
var ny = Sk;
const Tk = I3, Ik = R3, Rk = Xd, Ck = ry, Pk = ty, Ok = ny, Bk = (Y, X, ee, te) => {
  switch (X) {
    case "===":
      return typeof Y == "object" && (Y = Y.version), typeof ee == "object" && (ee = ee.version), Y === ee;
    case "!==":
      return typeof Y == "object" && (Y = Y.version), typeof ee == "object" && (ee = ee.version), Y !== ee;
    case "":
    case "=":
    case "==":
      return Tk(Y, ee, te);
    case "!=":
      return Ik(Y, ee, te);
    case ">":
      return Rk(Y, ee, te);
    case ">=":
      return Ck(Y, ee, te);
    case "<":
      return Pk(Y, ee, te);
    case "<=":
      return Ok(Y, ee, te);
    default:
      throw new TypeError(`Invalid operator: ${X}`);
  }
};
var C3 = Bk;
const Nk = _n, kk = _c, { safeRe: Xf, t: Zf } = mf, Mk = (Y, X) => {
  if (Y instanceof Nk)
    return Y;
  if (typeof Y == "number" && (Y = String(Y)), typeof Y != "string")
    return null;
  X = X || {};
  let ee = null;
  if (!X.rtl)
    ee = Y.match(X.includePrerelease ? Xf[Zf.COERCEFULL] : Xf[Zf.COERCE]);
  else {
    const ae = X.includePrerelease ? Xf[Zf.COERCERTLFULL] : Xf[Zf.COERCERTL];
    let ue;
    for (; (ue = ae.exec(Y)) && (!ee || ee.index + ee[0].length !== Y.length); )
      (!ee || ue.index + ue[0].length !== ee.index + ee[0].length) && (ee = ue), ae.lastIndex = ue.index + ue[1].length + ue[2].length;
    ae.lastIndex = -1;
  }
  if (ee === null)
    return null;
  const te = ee[2], ne = ee[3] || "0", ie = ee[4] || "0", oe = X.includePrerelease && ee[5] ? `-${ee[5]}` : "", se = X.includePrerelease && ee[6] ? `+${ee[6]}` : "";
  return kk(`${te}.${ne}.${ie}${oe}${se}`, X);
};
var Lk = Mk, rp, lw;
function Fk() {
  return lw || (lw = 1, rp = function(Y) {
    Y.prototype[Symbol.iterator] = function* () {
      for (let X = this.head; X; X = X.next)
        yield X.value;
    };
  }), rp;
}
var $k = Zt;
Zt.Node = Fo;
Zt.create = Zt;
function Zt(Y) {
  var X = this;
  if (X instanceof Zt || (X = new Zt()), X.tail = null, X.head = null, X.length = 0, Y && typeof Y.forEach == "function")
    Y.forEach(function(ne) {
      X.push(ne);
    });
  else if (arguments.length > 0)
    for (var ee = 0, te = arguments.length; ee < te; ee++)
      X.push(arguments[ee]);
  return X;
}
Zt.prototype.removeNode = function(Y) {
  if (Y.list !== this)
    throw new Error("removing node which does not belong to this list");
  var X = Y.next, ee = Y.prev;
  return X && (X.prev = ee), ee && (ee.next = X), Y === this.head && (this.head = X), Y === this.tail && (this.tail = ee), Y.list.length--, Y.next = null, Y.prev = null, Y.list = null, X;
};
Zt.prototype.unshiftNode = function(Y) {
  if (Y !== this.head) {
    Y.list && Y.list.removeNode(Y);
    var X = this.head;
    Y.list = this, Y.next = X, X && (X.prev = Y), this.head = Y, this.tail || (this.tail = Y), this.length++;
  }
};
Zt.prototype.pushNode = function(Y) {
  if (Y !== this.tail) {
    Y.list && Y.list.removeNode(Y);
    var X = this.tail;
    Y.list = this, Y.prev = X, X && (X.next = Y), this.tail = Y, this.head || (this.head = Y), this.length++;
  }
};
Zt.prototype.push = function() {
  for (var Y = 0, X = arguments.length; Y < X; Y++)
    Uk(this, arguments[Y]);
  return this.length;
};
Zt.prototype.unshift = function() {
  for (var Y = 0, X = arguments.length; Y < X; Y++)
    jk(this, arguments[Y]);
  return this.length;
};
Zt.prototype.pop = function() {
  if (this.tail) {
    var Y = this.tail.value;
    return this.tail = this.tail.prev, this.tail ? this.tail.next = null : this.head = null, this.length--, Y;
  }
};
Zt.prototype.shift = function() {
  if (this.head) {
    var Y = this.head.value;
    return this.head = this.head.next, this.head ? this.head.prev = null : this.tail = null, this.length--, Y;
  }
};
Zt.prototype.forEach = function(Y, X) {
  X = X || this;
  for (var ee = this.head, te = 0; ee !== null; te++)
    Y.call(X, ee.value, te, this), ee = ee.next;
};
Zt.prototype.forEachReverse = function(Y, X) {
  X = X || this;
  for (var ee = this.tail, te = this.length - 1; ee !== null; te--)
    Y.call(X, ee.value, te, this), ee = ee.prev;
};
Zt.prototype.get = function(Y) {
  for (var X = 0, ee = this.head; ee !== null && X < Y; X++)
    ee = ee.next;
  if (X === Y && ee !== null)
    return ee.value;
};
Zt.prototype.getReverse = function(Y) {
  for (var X = 0, ee = this.tail; ee !== null && X < Y; X++)
    ee = ee.prev;
  if (X === Y && ee !== null)
    return ee.value;
};
Zt.prototype.map = function(Y, X) {
  X = X || this;
  for (var ee = new Zt(), te = this.head; te !== null; )
    ee.push(Y.call(X, te.value, this)), te = te.next;
  return ee;
};
Zt.prototype.mapReverse = function(Y, X) {
  X = X || this;
  for (var ee = new Zt(), te = this.tail; te !== null; )
    ee.push(Y.call(X, te.value, this)), te = te.prev;
  return ee;
};
Zt.prototype.reduce = function(Y, X) {
  var ee, te = this.head;
  if (arguments.length > 1)
    ee = X;
  else if (this.head)
    te = this.head.next, ee = this.head.value;
  else
    throw new TypeError("Reduce of empty list with no initial value");
  for (var ne = 0; te !== null; ne++)
    ee = Y(ee, te.value, ne), te = te.next;
  return ee;
};
Zt.prototype.reduceReverse = function(Y, X) {
  var ee, te = this.tail;
  if (arguments.length > 1)
    ee = X;
  else if (this.tail)
    te = this.tail.prev, ee = this.tail.value;
  else
    throw new TypeError("Reduce of empty list with no initial value");
  for (var ne = this.length - 1; te !== null; ne--)
    ee = Y(ee, te.value, ne), te = te.prev;
  return ee;
};
Zt.prototype.toArray = function() {
  for (var Y = new Array(this.length), X = 0, ee = this.head; ee !== null; X++)
    Y[X] = ee.value, ee = ee.next;
  return Y;
};
Zt.prototype.toArrayReverse = function() {
  for (var Y = new Array(this.length), X = 0, ee = this.tail; ee !== null; X++)
    Y[X] = ee.value, ee = ee.prev;
  return Y;
};
Zt.prototype.slice = function(Y, X) {
  X = X || this.length, X < 0 && (X += this.length), Y = Y || 0, Y < 0 && (Y += this.length);
  var ee = new Zt();
  if (X < Y || X < 0)
    return ee;
  Y < 0 && (Y = 0), X > this.length && (X = this.length);
  for (var te = 0, ne = this.head; ne !== null && te < Y; te++)
    ne = ne.next;
  for (; ne !== null && te < X; te++, ne = ne.next)
    ee.push(ne.value);
  return ee;
};
Zt.prototype.sliceReverse = function(Y, X) {
  X = X || this.length, X < 0 && (X += this.length), Y = Y || 0, Y < 0 && (Y += this.length);
  var ee = new Zt();
  if (X < Y || X < 0)
    return ee;
  Y < 0 && (Y = 0), X > this.length && (X = this.length);
  for (var te = this.length, ne = this.tail; ne !== null && te > X; te--)
    ne = ne.prev;
  for (; ne !== null && te > Y; te--, ne = ne.prev)
    ee.push(ne.value);
  return ee;
};
Zt.prototype.splice = function(Y, X, ...ee) {
  Y > this.length && (Y = this.length - 1), Y < 0 && (Y = this.length + Y);
  for (var te = 0, ne = this.head; ne !== null && te < Y; te++)
    ne = ne.next;
  for (var ie = [], te = 0; ne && te < X; te++)
    ie.push(ne.value), ne = this.removeNode(ne);
  ne === null && (ne = this.tail), ne !== this.head && ne !== this.tail && (ne = ne.prev);
  for (var te = 0; te < ee.length; te++)
    ne = Dk(this, ne, ee[te]);
  return ie;
};
Zt.prototype.reverse = function() {
  for (var Y = this.head, X = this.tail, ee = Y; ee !== null; ee = ee.prev) {
    var te = ee.prev;
    ee.prev = ee.next, ee.next = te;
  }
  return this.head = X, this.tail = Y, this;
};
function Dk(Y, X, ee) {
  var te = X === Y.head ? new Fo(ee, null, X, Y) : new Fo(ee, X, X.next, Y);
  return te.next === null && (Y.tail = te), te.prev === null && (Y.head = te), Y.length++, te;
}
function Uk(Y, X) {
  Y.tail = new Fo(X, Y.tail, null, Y), Y.head || (Y.head = Y.tail), Y.length++;
}
function jk(Y, X) {
  Y.head = new Fo(X, null, Y.head, Y), Y.tail || (Y.tail = Y.head), Y.length++;
}
function Fo(Y, X, ee, te) {
  if (!(this instanceof Fo))
    return new Fo(Y, X, ee, te);
  this.list = te, this.value = Y, X ? (X.next = this, this.prev = X) : this.prev = null, ee ? (ee.prev = this, this.next = ee) : this.next = null;
}
try {
  Fk()(Zt);
} catch {
}
const Hk = $k, _o = Symbol("max"), ys = Symbol("length"), ca = Symbol("lengthCalculator"), du = Symbol("allowStale"), So = Symbol("maxAge"), ps = Symbol("dispose"), dw = Symbol("noDisposeOnSet"), Gr = Symbol("lruList"), hi = Symbol("cache"), P3 = Symbol("updateAgeOnGet"), np = () => 1;
class zk {
  constructor(X) {
    if (typeof X == "number" && (X = { max: X }), X || (X = {}), X.max && (typeof X.max != "number" || X.max < 0))
      throw new TypeError("max must be a non-negative number");
    this[_o] = X.max || 1 / 0;
    const ee = X.length || np;
    if (this[ca] = typeof ee != "function" ? np : ee, this[du] = X.stale || !1, X.maxAge && typeof X.maxAge != "number")
      throw new TypeError("maxAge must be a number");
    this[So] = X.maxAge || 0, this[ps] = X.dispose, this[dw] = X.noDisposeOnSet || !1, this[P3] = X.updateAgeOnGet || !1, this.reset();
  }
  // resize the cache when the max changes.
  set max(X) {
    if (typeof X != "number" || X < 0)
      throw new TypeError("max must be a non-negative number");
    this[_o] = X || 1 / 0, Kc(this);
  }
  get max() {
    return this[_o];
  }
  set allowStale(X) {
    this[du] = !!X;
  }
  get allowStale() {
    return this[du];
  }
  set maxAge(X) {
    if (typeof X != "number")
      throw new TypeError("maxAge must be a non-negative number");
    this[So] = X, Kc(this);
  }
  get maxAge() {
    return this[So];
  }
  // resize the cache when the lengthCalculator changes.
  set lengthCalculator(X) {
    typeof X != "function" && (X = np), X !== this[ca] && (this[ca] = X, this[ys] = 0, this[Gr].forEach((ee) => {
      ee.length = this[ca](ee.value, ee.key), this[ys] += ee.length;
    })), Kc(this);
  }
  get lengthCalculator() {
    return this[ca];
  }
  get length() {
    return this[ys];
  }
  get itemCount() {
    return this[Gr].length;
  }
  rforEach(X, ee) {
    ee = ee || this;
    for (let te = this[Gr].tail; te !== null; ) {
      const ne = te.prev;
      hw(this, X, te, ee), te = ne;
    }
  }
  forEach(X, ee) {
    ee = ee || this;
    for (let te = this[Gr].head; te !== null; ) {
      const ne = te.next;
      hw(this, X, te, ee), te = ne;
    }
  }
  keys() {
    return this[Gr].toArray().map((X) => X.key);
  }
  values() {
    return this[Gr].toArray().map((X) => X.value);
  }
  reset() {
    this[ps] && this[Gr] && this[Gr].length && this[Gr].forEach((X) => this[ps](X.key, X.value)), this[hi] = /* @__PURE__ */ new Map(), this[Gr] = new Hk(), this[ys] = 0;
  }
  dump() {
    return this[Gr].map((X) => Yl(this, X) ? !1 : {
      k: X.key,
      v: X.value,
      e: X.now + (X.maxAge || 0)
    }).toArray().filter((X) => X);
  }
  dumpLru() {
    return this[Gr];
  }
  set(X, ee, te) {
    if (te = te || this[So], te && typeof te != "number")
      throw new TypeError("maxAge must be a number");
    const ne = te ? Date.now() : 0, ie = this[ca](ee, X);
    if (this[hi].has(X)) {
      if (ie > this[_o])
        return Na(this, this[hi].get(X)), !1;
      const se = this[hi].get(X).value;
      return this[ps] && (this[dw] || this[ps](X, se.value)), se.now = ne, se.maxAge = te, se.value = ee, this[ys] += ie - se.length, se.length = ie, this.get(X), Kc(this), !0;
    }
    const oe = new qk(X, ee, ie, ne, te);
    return oe.length > this[_o] ? (this[ps] && this[ps](X, ee), !1) : (this[ys] += oe.length, this[Gr].unshift(oe), this[hi].set(X, this[Gr].head), Kc(this), !0);
  }
  has(X) {
    if (!this[hi].has(X))
      return !1;
    const ee = this[hi].get(X).value;
    return !Yl(this, ee);
  }
  get(X) {
    return ip(this, X, !0);
  }
  peek(X) {
    return ip(this, X, !1);
  }
  pop() {
    const X = this[Gr].tail;
    return X ? (Na(this, X), X.value) : null;
  }
  del(X) {
    Na(this, this[hi].get(X));
  }
  load(X) {
    this.reset();
    const ee = Date.now();
    for (let te = X.length - 1; te >= 0; te--) {
      const ne = X[te], ie = ne.e || 0;
      if (ie === 0)
        this.set(ne.k, ne.v);
      else {
        const oe = ie - ee;
        oe > 0 && this.set(ne.k, ne.v, oe);
      }
    }
  }
  prune() {
    this[hi].forEach((X, ee) => ip(this, ee, !1));
  }
}
const ip = (Y, X, ee) => {
  const te = Y[hi].get(X);
  if (te) {
    const ne = te.value;
    if (Yl(Y, ne)) {
      if (Na(Y, te), !Y[du])
        return;
    } else
      ee && (Y[P3] && (te.value.now = Date.now()), Y[Gr].unshiftNode(te));
    return ne.value;
  }
}, Yl = (Y, X) => {
  if (!X || !X.maxAge && !Y[So])
    return !1;
  const ee = Date.now() - X.now;
  return X.maxAge ? ee > X.maxAge : Y[So] && ee > Y[So];
}, Kc = (Y) => {
  if (Y[ys] > Y[_o])
    for (let X = Y[Gr].tail; Y[ys] > Y[_o] && X !== null; ) {
      const ee = X.prev;
      Na(Y, X), X = ee;
    }
}, Na = (Y, X) => {
  if (X) {
    const ee = X.value;
    Y[ps] && Y[ps](ee.key, ee.value), Y[ys] -= ee.length, Y[hi].delete(ee.key), Y[Gr].removeNode(X);
  }
};
class qk {
  constructor(X, ee, te, ne, ie) {
    this.key = X, this.value = ee, this.length = te, this.now = ne, this.maxAge = ie || 0;
  }
}
const hw = (Y, X, ee, te) => {
  let ne = ee.value;
  Yl(Y, ne) && (Na(Y, ee), Y[du] || (ne = void 0)), ne && X.call(te, ne.value, ne.key, Y);
};
var Gk = zk, sp, pw;
function Ai() {
  if (pw)
    return sp;
  pw = 1;
  class Y {
    constructor(de, be) {
      if (be = te(be), de instanceof Y)
        return de.loose === !!be.loose && de.includePrerelease === !!be.includePrerelease ? de : new Y(de.raw, be);
      if (de instanceof ne)
        return this.raw = de.value, this.set = [[de]], this.format(), this;
      if (this.options = be, this.loose = !!be.loose, this.includePrerelease = !!be.includePrerelease, this.raw = de.trim().split(/\s+/).join(" "), this.set = this.raw.split("||").map((Te) => this.parseRange(Te.trim())).filter((Te) => Te.length), !this.set.length)
        throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
      if (this.set.length > 1) {
        const Te = this.set[0];
        if (this.set = this.set.filter((Ce) => !we(Ce[0])), this.set.length === 0)
          this.set = [Te];
        else if (this.set.length > 1) {
          for (const Ce of this.set)
            if (Ce.length === 1 && Ee(Ce[0])) {
              this.set = [Ce];
              break;
            }
        }
      }
      this.format();
    }
    format() {
      return this.range = this.set.map((de) => de.join(" ").trim()).join("||").trim(), this.range;
    }
    toString() {
      return this.range;
    }
    parseRange(de) {
      const be = ((this.options.includePrerelease && me) | (this.options.loose && ye)) + ":" + de, Te = ee.get(be);
      if (Te)
        return Te;
      const Ce = this.options.loose, Pe = Ce ? se[ae.HYPHENRANGELOOSE] : se[ae.HYPHENRANGE];
      de = de.replace(Pe, je(this.options.includePrerelease)), ie("hyphen replace", de), de = de.replace(se[ae.COMPARATORTRIM], ue), ie("comparator trim", de), de = de.replace(se[ae.TILDETRIM], le), ie("tilde trim", de), de = de.replace(se[ae.CARETTRIM], he), ie("caret trim", de);
      let Se = de.split(" ").map((Ge) => Ue(Ge, this.options)).join(" ").split(/\s+/).map((Ge) => Dt(Ge, this.options));
      Ce && (Se = Se.filter((Ge) => (ie("loose invalid filter", Ge, this.options), !!Ge.match(se[ae.COMPARATORLOOSE])))), ie("range list", Se);
      const ke = /* @__PURE__ */ new Map(), ge = Se.map((Ge) => new ne(Ge, this.options));
      for (const Ge of ge) {
        if (we(Ge))
          return [Ge];
        ke.set(Ge.value, Ge);
      }
      ke.size > 1 && ke.has("") && ke.delete("");
      const Ae = [...ke.values()];
      return ee.set(be, Ae), Ae;
    }
    intersects(de, be) {
      if (!(de instanceof Y))
        throw new TypeError("a Range is required");
      return this.set.some((Te) => Re(Te, be) && de.set.some((Ce) => Re(Ce, be) && Te.every((Pe) => Ce.every((Se) => Pe.intersects(Se, be)))));
    }
    // if ANY of the sets match ALL of its comparators, then pass
    test(de) {
      if (!de)
        return !1;
      if (typeof de == "string")
        try {
          de = new oe(de, this.options);
        } catch {
          return !1;
        }
      for (let be = 0; be < this.set.length; be++)
        if (ze(this.set[be], de, this.options))
          return !0;
      return !1;
    }
  }
  sp = Y;
  const X = Gk, ee = new X({ max: 1e3 }), te = Qm, ne = Zd(), ie = Yd, oe = _n, {
    safeRe: se,
    t: ae,
    comparatorTrimReplace: ue,
    tildeTrimReplace: le,
    caretTrimReplace: he
  } = mf, { FLAG_INCLUDE_PRERELEASE: me, FLAG_LOOSE: ye } = Jd, we = (fe) => fe.value === "<0.0.0-0", Ee = (fe) => fe.value === "", Re = (fe, de) => {
    let be = !0;
    const Te = fe.slice();
    let Ce = Te.pop();
    for (; be && Te.length; )
      be = Te.every((Pe) => Ce.intersects(Pe, de)), Ce = Te.pop();
    return be;
  }, Ue = (fe, de) => (ie("comp", fe, de), fe = Ke(fe, de), ie("caret", fe), fe = De(fe, de), ie("tildes", fe), fe = rt(fe, de), ie("xrange", fe), fe = _t(fe, de), ie("stars", fe), fe), Me = (fe) => !fe || fe.toLowerCase() === "x" || fe === "*", De = (fe, de) => fe.trim().split(/\s+/).map((be) => Fe(be, de)).join(" "), Fe = (fe, de) => {
    const be = de.loose ? se[ae.TILDELOOSE] : se[ae.TILDE];
    return fe.replace(be, (Te, Ce, Pe, Se, ke) => {
      ie("tilde", fe, Te, Ce, Pe, Se, ke);
      let ge;
      return Me(Ce) ? ge = "" : Me(Pe) ? ge = `>=${Ce}.0.0 <${+Ce + 1}.0.0-0` : Me(Se) ? ge = `>=${Ce}.${Pe}.0 <${Ce}.${+Pe + 1}.0-0` : ke ? (ie("replaceTilde pr", ke), ge = `>=${Ce}.${Pe}.${Se}-${ke} <${Ce}.${+Pe + 1}.0-0`) : ge = `>=${Ce}.${Pe}.${Se} <${Ce}.${+Pe + 1}.0-0`, ie("tilde return", ge), ge;
    });
  }, Ke = (fe, de) => fe.trim().split(/\s+/).map((be) => tt(be, de)).join(" "), tt = (fe, de) => {
    ie("caret", fe, de);
    const be = de.loose ? se[ae.CARETLOOSE] : se[ae.CARET], Te = de.includePrerelease ? "-0" : "";
    return fe.replace(be, (Ce, Pe, Se, ke, ge) => {
      ie("caret", fe, Ce, Pe, Se, ke, ge);
      let Ae;
      return Me(Pe) ? Ae = "" : Me(Se) ? Ae = `>=${Pe}.0.0${Te} <${+Pe + 1}.0.0-0` : Me(ke) ? Pe === "0" ? Ae = `>=${Pe}.${Se}.0${Te} <${Pe}.${+Se + 1}.0-0` : Ae = `>=${Pe}.${Se}.0${Te} <${+Pe + 1}.0.0-0` : ge ? (ie("replaceCaret pr", ge), Pe === "0" ? Se === "0" ? Ae = `>=${Pe}.${Se}.${ke}-${ge} <${Pe}.${Se}.${+ke + 1}-0` : Ae = `>=${Pe}.${Se}.${ke}-${ge} <${Pe}.${+Se + 1}.0-0` : Ae = `>=${Pe}.${Se}.${ke}-${ge} <${+Pe + 1}.0.0-0`) : (ie("no pr"), Pe === "0" ? Se === "0" ? Ae = `>=${Pe}.${Se}.${ke}${Te} <${Pe}.${Se}.${+ke + 1}-0` : Ae = `>=${Pe}.${Se}.${ke}${Te} <${Pe}.${+Se + 1}.0-0` : Ae = `>=${Pe}.${Se}.${ke} <${+Pe + 1}.0.0-0`), ie("caret return", Ae), Ae;
    });
  }, rt = (fe, de) => (ie("replaceXRanges", fe, de), fe.split(/\s+/).map((be) => it(be, de)).join(" ")), it = (fe, de) => {
    fe = fe.trim();
    const be = de.loose ? se[ae.XRANGELOOSE] : se[ae.XRANGE];
    return fe.replace(be, (Te, Ce, Pe, Se, ke, ge) => {
      ie("xRange", fe, Te, Ce, Pe, Se, ke, ge);
      const Ae = Me(Pe), Ge = Ae || Me(Se), Xe = Ge || Me(ke), $e = Xe;
      return Ce === "=" && $e && (Ce = ""), ge = de.includePrerelease ? "-0" : "", Ae ? Ce === ">" || Ce === "<" ? Te = "<0.0.0-0" : Te = "*" : Ce && $e ? (Ge && (Se = 0), ke = 0, Ce === ">" ? (Ce = ">=", Ge ? (Pe = +Pe + 1, Se = 0, ke = 0) : (Se = +Se + 1, ke = 0)) : Ce === "<=" && (Ce = "<", Ge ? Pe = +Pe + 1 : Se = +Se + 1), Ce === "<" && (ge = "-0"), Te = `${Ce + Pe}.${Se}.${ke}${ge}`) : Ge ? Te = `>=${Pe}.0.0${ge} <${+Pe + 1}.0.0-0` : Xe && (Te = `>=${Pe}.${Se}.0${ge} <${Pe}.${+Se + 1}.0-0`), ie("xRange return", Te), Te;
    });
  }, _t = (fe, de) => (ie("replaceStars", fe, de), fe.trim().replace(se[ae.STAR], "")), Dt = (fe, de) => (ie("replaceGTE0", fe, de), fe.trim().replace(se[de.includePrerelease ? ae.GTE0PRE : ae.GTE0], "")), je = (fe) => (de, be, Te, Ce, Pe, Se, ke, ge, Ae, Ge, Xe, $e, Ze) => (Me(Te) ? be = "" : Me(Ce) ? be = `>=${Te}.0.0${fe ? "-0" : ""}` : Me(Pe) ? be = `>=${Te}.${Ce}.0${fe ? "-0" : ""}` : Se ? be = `>=${be}` : be = `>=${be}${fe ? "-0" : ""}`, Me(Ae) ? ge = "" : Me(Ge) ? ge = `<${+Ae + 1}.0.0-0` : Me(Xe) ? ge = `<${Ae}.${+Ge + 1}.0-0` : $e ? ge = `<=${Ae}.${Ge}.${Xe}-${$e}` : fe ? ge = `<${Ae}.${Ge}.${+Xe + 1}-0` : ge = `<=${ge}`, `${be} ${ge}`.trim()), ze = (fe, de, be) => {
    for (let Te = 0; Te < fe.length; Te++)
      if (!fe[Te].test(de))
        return !1;
    if (de.prerelease.length && !be.includePrerelease) {
      for (let Te = 0; Te < fe.length; Te++)
        if (ie(fe[Te].semver), fe[Te].semver !== ne.ANY && fe[Te].semver.prerelease.length > 0) {
          const Ce = fe[Te].semver;
          if (Ce.major === de.major && Ce.minor === de.minor && Ce.patch === de.patch)
            return !0;
        }
      return !1;
    }
    return !0;
  };
  return sp;
}
var op, gw;
function Zd() {
  if (gw)
    return op;
  gw = 1;
  const Y = Symbol("SemVer ANY");
  class X {
    static get ANY() {
      return Y;
    }
    constructor(le, he) {
      if (he = ee(he), le instanceof X) {
        if (le.loose === !!he.loose)
          return le;
        le = le.value;
      }
      le = le.trim().split(/\s+/).join(" "), oe("comparator", le, he), this.options = he, this.loose = !!he.loose, this.parse(le), this.semver === Y ? this.value = "" : this.value = this.operator + this.semver.version, oe("comp", this);
    }
    parse(le) {
      const he = this.options.loose ? te[ne.COMPARATORLOOSE] : te[ne.COMPARATOR], me = le.match(he);
      if (!me)
        throw new TypeError(`Invalid comparator: ${le}`);
      this.operator = me[1] !== void 0 ? me[1] : "", this.operator === "=" && (this.operator = ""), me[2] ? this.semver = new se(me[2], this.options.loose) : this.semver = Y;
    }
    toString() {
      return this.value;
    }
    test(le) {
      if (oe("Comparator.test", le, this.options.loose), this.semver === Y || le === Y)
        return !0;
      if (typeof le == "string")
        try {
          le = new se(le, this.options);
        } catch {
          return !1;
        }
      return ie(le, this.operator, this.semver, this.options);
    }
    intersects(le, he) {
      if (!(le instanceof X))
        throw new TypeError("a Comparator is required");
      return this.operator === "" ? this.value === "" ? !0 : new ae(le.value, he).test(this.value) : le.operator === "" ? le.value === "" ? !0 : new ae(this.value, he).test(le.semver) : (he = ee(he), he.includePrerelease && (this.value === "<0.0.0-0" || le.value === "<0.0.0-0") || !he.includePrerelease && (this.value.startsWith("<0.0.0") || le.value.startsWith("<0.0.0")) ? !1 : !!(this.operator.startsWith(">") && le.operator.startsWith(">") || this.operator.startsWith("<") && le.operator.startsWith("<") || this.semver.version === le.semver.version && this.operator.includes("=") && le.operator.includes("=") || ie(this.semver, "<", le.semver, he) && this.operator.startsWith(">") && le.operator.startsWith("<") || ie(this.semver, ">", le.semver, he) && this.operator.startsWith("<") && le.operator.startsWith(">")));
    }
  }
  op = X;
  const ee = Qm, { safeRe: te, t: ne } = mf, ie = C3, oe = Yd, se = _n, ae = Ai();
  return op;
}
const Vk = Ai(), Wk = (Y, X, ee) => {
  try {
    X = new Vk(X, ee);
  } catch {
    return !1;
  }
  return X.test(Y);
};
var Qd = Wk;
const Kk = Ai(), Jk = (Y, X) => new Kk(Y, X).set.map((ee) => ee.map((te) => te.value).join(" ").trim().split(" "));
var Yk = Jk;
const Xk = _n, Zk = Ai(), Qk = (Y, X, ee) => {
  let te = null, ne = null, ie = null;
  try {
    ie = new Zk(X, ee);
  } catch {
    return null;
  }
  return Y.forEach((oe) => {
    ie.test(oe) && (!te || ne.compare(oe) === -1) && (te = oe, ne = new Xk(te, ee));
  }), te;
};
var eM = Qk;
const tM = _n, rM = Ai(), nM = (Y, X, ee) => {
  let te = null, ne = null, ie = null;
  try {
    ie = new rM(X, ee);
  } catch {
    return null;
  }
  return Y.forEach((oe) => {
    ie.test(oe) && (!te || ne.compare(oe) === 1) && (te = oe, ne = new tM(te, ee));
  }), te;
};
var iM = nM;
const ap = _n, sM = Ai(), mw = Xd, oM = (Y, X) => {
  Y = new sM(Y, X);
  let ee = new ap("0.0.0");
  if (Y.test(ee) || (ee = new ap("0.0.0-0"), Y.test(ee)))
    return ee;
  ee = null;
  for (let te = 0; te < Y.set.length; ++te) {
    const ne = Y.set[te];
    let ie = null;
    ne.forEach((oe) => {
      const se = new ap(oe.semver.version);
      switch (oe.operator) {
        case ">":
          se.prerelease.length === 0 ? se.patch++ : se.prerelease.push(0), se.raw = se.format();
        case "":
        case ">=":
          (!ie || mw(se, ie)) && (ie = se);
          break;
        case "<":
        case "<=":
          break;
        default:
          throw new Error(`Unexpected operation: ${oe.operator}`);
      }
    }), ie && (!ee || mw(ee, ie)) && (ee = ie);
  }
  return ee && Y.test(ee) ? ee : null;
};
var aM = oM;
const cM = Ai(), uM = (Y, X) => {
  try {
    return new cM(Y, X).range || "*";
  } catch {
    return null;
  }
};
var fM = uM;
const lM = _n, O3 = Zd(), { ANY: dM } = O3, hM = Ai(), pM = Qd, yw = Xd, bw = ty, gM = ny, mM = ry, yM = (Y, X, ee, te) => {
  Y = new lM(Y, te), X = new hM(X, te);
  let ne, ie, oe, se, ae;
  switch (ee) {
    case ">":
      ne = yw, ie = gM, oe = bw, se = ">", ae = ">=";
      break;
    case "<":
      ne = bw, ie = mM, oe = yw, se = "<", ae = "<=";
      break;
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"');
  }
  if (pM(Y, X, te))
    return !1;
  for (let ue = 0; ue < X.set.length; ++ue) {
    const le = X.set[ue];
    let he = null, me = null;
    if (le.forEach((ye) => {
      ye.semver === dM && (ye = new O3(">=0.0.0")), he = he || ye, me = me || ye, ne(ye.semver, he.semver, te) ? he = ye : oe(ye.semver, me.semver, te) && (me = ye);
    }), he.operator === se || he.operator === ae || (!me.operator || me.operator === se) && ie(Y, me.semver) || me.operator === ae && oe(Y, me.semver))
      return !1;
  }
  return !0;
};
var iy = yM;
const bM = iy, xM = (Y, X, ee) => bM(Y, X, ">", ee);
var wM = xM;
const vM = iy, EM = (Y, X, ee) => vM(Y, X, "<", ee);
var _M = EM;
const xw = Ai(), AM = (Y, X, ee) => (Y = new xw(Y, ee), X = new xw(X, ee), Y.intersects(X, ee));
var SM = AM;
const TM = Qd, IM = _i;
var RM = (Y, X, ee) => {
  const te = [];
  let ne = null, ie = null;
  const oe = Y.sort((le, he) => IM(le, he, ee));
  for (const le of oe)
    TM(le, X, ee) ? (ie = le, ne || (ne = le)) : (ie && te.push([ne, ie]), ie = null, ne = null);
  ne && te.push([ne, null]);
  const se = [];
  for (const [le, he] of te)
    le === he ? se.push(le) : !he && le === oe[0] ? se.push("*") : he ? le === oe[0] ? se.push(`<=${he}`) : se.push(`${le} - ${he}`) : se.push(`>=${le}`);
  const ae = se.join(" || "), ue = typeof X.raw == "string" ? X.raw : String(X);
  return ae.length < ue.length ? ae : X;
};
const ww = Ai(), sy = Zd(), { ANY: cp } = sy, Jc = Qd, oy = _i, CM = (Y, X, ee = {}) => {
  if (Y === X)
    return !0;
  Y = new ww(Y, ee), X = new ww(X, ee);
  let te = !1;
  e:
    for (const ne of Y.set) {
      for (const ie of X.set) {
        const oe = OM(ne, ie, ee);
        if (te = te || oe !== null, oe)
          continue e;
      }
      if (te)
        return !1;
    }
  return !0;
}, PM = [new sy(">=0.0.0-0")], vw = [new sy(">=0.0.0")], OM = (Y, X, ee) => {
  if (Y === X)
    return !0;
  if (Y.length === 1 && Y[0].semver === cp) {
    if (X.length === 1 && X[0].semver === cp)
      return !0;
    ee.includePrerelease ? Y = PM : Y = vw;
  }
  if (X.length === 1 && X[0].semver === cp) {
    if (ee.includePrerelease)
      return !0;
    X = vw;
  }
  const te = /* @__PURE__ */ new Set();
  let ne, ie;
  for (const ye of Y)
    ye.operator === ">" || ye.operator === ">=" ? ne = Ew(ne, ye, ee) : ye.operator === "<" || ye.operator === "<=" ? ie = _w(ie, ye, ee) : te.add(ye.semver);
  if (te.size > 1)
    return null;
  let oe;
  if (ne && ie && (oe = oy(ne.semver, ie.semver, ee), oe > 0 || oe === 0 && (ne.operator !== ">=" || ie.operator !== "<=")))
    return null;
  for (const ye of te) {
    if (ne && !Jc(ye, String(ne), ee) || ie && !Jc(ye, String(ie), ee))
      return null;
    for (const we of X)
      if (!Jc(ye, String(we), ee))
        return !1;
    return !0;
  }
  let se, ae, ue, le, he = ie && !ee.includePrerelease && ie.semver.prerelease.length ? ie.semver : !1, me = ne && !ee.includePrerelease && ne.semver.prerelease.length ? ne.semver : !1;
  he && he.prerelease.length === 1 && ie.operator === "<" && he.prerelease[0] === 0 && (he = !1);
  for (const ye of X) {
    if (le = le || ye.operator === ">" || ye.operator === ">=", ue = ue || ye.operator === "<" || ye.operator === "<=", ne) {
      if (me && ye.semver.prerelease && ye.semver.prerelease.length && ye.semver.major === me.major && ye.semver.minor === me.minor && ye.semver.patch === me.patch && (me = !1), ye.operator === ">" || ye.operator === ">=") {
        if (se = Ew(ne, ye, ee), se === ye && se !== ne)
          return !1;
      } else if (ne.operator === ">=" && !Jc(ne.semver, String(ye), ee))
        return !1;
    }
    if (ie) {
      if (he && ye.semver.prerelease && ye.semver.prerelease.length && ye.semver.major === he.major && ye.semver.minor === he.minor && ye.semver.patch === he.patch && (he = !1), ye.operator === "<" || ye.operator === "<=") {
        if (ae = _w(ie, ye, ee), ae === ye && ae !== ie)
          return !1;
      } else if (ie.operator === "<=" && !Jc(ie.semver, String(ye), ee))
        return !1;
    }
    if (!ye.operator && (ie || ne) && oe !== 0)
      return !1;
  }
  return !(ne && ue && !ie && oe !== 0 || ie && le && !ne && oe !== 0 || me || he);
}, Ew = (Y, X, ee) => {
  if (!Y)
    return X;
  const te = oy(Y.semver, X.semver, ee);
  return te > 0 ? Y : te < 0 || X.operator === ">" && Y.operator === ">=" ? X : Y;
}, _w = (Y, X, ee) => {
  if (!Y)
    return X;
  const te = oy(Y.semver, X.semver, ee);
  return te < 0 ? Y : te > 0 || X.operator === "<" && Y.operator === "<=" ? X : Y;
};
var BM = CM;
const up = mf, Aw = Jd, NM = _n, Sw = T3, kM = _c, MM = kN, LM = FN, FM = DN, $M = jN, DM = qN, UM = WN, jM = YN, HM = QN, zM = _i, qM = nk, GM = ok, VM = ey, WM = fk, KM = hk, JM = Xd, YM = ty, XM = I3, ZM = R3, QM = ry, eL = ny, tL = C3, rL = Lk, nL = Zd(), iL = Ai(), sL = Qd, oL = Yk, aL = eM, cL = iM, uL = aM, fL = fM, lL = iy, dL = wM, hL = _M, pL = SM, gL = RM, mL = BM;
var yL = {
  parse: kM,
  valid: MM,
  clean: LM,
  inc: FM,
  diff: $M,
  major: DM,
  minor: UM,
  patch: jM,
  prerelease: HM,
  compare: zM,
  rcompare: qM,
  compareLoose: GM,
  compareBuild: VM,
  sort: WM,
  rsort: KM,
  gt: JM,
  lt: YM,
  eq: XM,
  neq: ZM,
  gte: QM,
  lte: eL,
  cmp: tL,
  coerce: rL,
  Comparator: nL,
  Range: iL,
  satisfies: sL,
  toComparators: oL,
  maxSatisfying: aL,
  minSatisfying: cL,
  minVersion: uL,
  validRange: fL,
  outside: lL,
  gtr: dL,
  ltr: hL,
  intersects: pL,
  simplifyRange: gL,
  subset: mL,
  SemVer: NM,
  re: up.re,
  src: up.src,
  tokens: up.t,
  SEMVER_SPEC_VERSION: Aw.SEMVER_SPEC_VERSION,
  RELEASE_TYPES: Aw.RELEASE_TYPES,
  compareIdentifiers: Sw.compareIdentifiers,
  rcompareIdentifiers: Sw.rcompareIdentifiers
};
Object.defineProperty(Ei, "__esModule", { value: !0 });
var B3 = oi, yf = yL, Ya = ns, ay = Ya.refine.call(
  void 0,
  Ya.string.call(void 0),
  "Version",
  (Y) => yf.valid.call(void 0, Y) === null ? `Expected SemVer version, got "${Y}"` : !0
), cy = Ya.refine.call(
  void 0,
  Ya.string.call(void 0),
  "Version range",
  (Y) => yf.validRange.call(void 0, Y) === null ? `Expected SemVer range, got "${Y}"` : !0
);
function bL(Y) {
  return Ya.is.call(void 0, Y, ay);
}
function xL(Y) {
  return Ya.is.call(void 0, Y, cy);
}
function wL(Y) {
  B3.assertStruct.call(void 0, Y, ay);
}
function vL(Y) {
  B3.assertStruct.call(void 0, Y, cy);
}
function EL(Y, X) {
  return yf.gt.call(void 0, Y, X);
}
function _L(Y, X) {
  return yf.gtr.call(void 0, Y, X);
}
function AL(Y, X) {
  return yf.satisfies.call(void 0, Y, X, {
    includePrerelease: !0
  });
}
Ei.VersionStruct = ay;
Ei.VersionRangeStruct = cy;
Ei.isValidSemVerVersion = bL;
Ei.isValidSemVerRange = xL;
Ei.assertIsSemVerVersion = wL;
Ei.assertIsSemVerRange = vL;
Ei.gtVersion = EL;
Ei.gtRange = _L;
Ei.satisfiesVersionRange = AL;
var $t = {};
Object.defineProperty($t, "__esModule", { value: !0 });
var Ls = oi, SL = En, yt = ns, Ac = (Y) => (
  // The type is slightly different from a regular object struct, because we
  // want to make properties with `undefined` in their type optional, but not
  // `undefined` itself. This means that we need a type cast.
  yt.object.call(void 0, Y)
);
function Tw({ path: Y, branch: X }) {
  const ee = Y[Y.length - 1];
  return SL.hasProperty.call(void 0, X[X.length - 2], ee);
}
function Bu(Y) {
  return new yt.Struct({
    ...Y,
    type: `optional ${Y.type}`,
    validator: (X, ee) => !Tw(ee) || Y.validator(X, ee),
    refiner: (X, ee) => !Tw(ee) || Y.refiner(X, ee)
  });
}
var TL = () => yt.define.call(void 0, "finite number", (Y) => yt.is.call(void 0, Y, yt.number.call(void 0)) && Number.isFinite(Y)), Nu = yt.union.call(void 0, [
  yt.literal.call(void 0, null),
  yt.boolean.call(void 0),
  TL(),
  yt.string.call(void 0),
  yt.array.call(void 0, yt.lazy.call(void 0, () => Nu)),
  yt.record.call(
    void 0,
    yt.string.call(void 0),
    yt.lazy.call(void 0, () => Nu)
  )
]), $o = yt.coerce.call(void 0, Nu, yt.any.call(void 0), (Y) => (Ls.assertStruct.call(void 0, Y, Nu), JSON.parse(
  JSON.stringify(Y, (X, ee) => {
    if (!(X === "__proto__" || X === "constructor"))
      return ee;
  })
)));
function IL(Y) {
  try {
    return N3(Y), !0;
  } catch {
    return !1;
  }
}
function N3(Y) {
  return yt.create.call(void 0, Y, $o);
}
function RL(Y) {
  Ls.assertStruct.call(void 0, Y, $o, "Invalid JSON value");
  const X = JSON.stringify(Y);
  return new TextEncoder().encode(X).byteLength;
}
var k3 = "2.0", Sc = yt.literal.call(void 0, k3), bf = yt.nullable.call(void 0, yt.union.call(void 0, [yt.number.call(void 0), yt.string.call(void 0)])), xf = Ac({
  code: yt.integer.call(void 0),
  message: yt.string.call(void 0),
  data: Bu($o),
  stack: Bu(yt.string.call(void 0))
}), uy = yt.union.call(void 0, [yt.record.call(void 0, yt.string.call(void 0), $o), yt.array.call(void 0, $o)]), fy = Ac({
  id: bf,
  jsonrpc: Sc,
  method: yt.string.call(void 0),
  params: Bu(uy)
}), ly = Ac({
  jsonrpc: Sc,
  method: yt.string.call(void 0),
  params: Bu(uy)
});
function CL(Y) {
  return yt.is.call(void 0, Y, ly);
}
function PL(Y, X) {
  Ls.assertStruct.call(
    void 0,
    Y,
    ly,
    "Invalid JSON-RPC notification",
    X
  );
}
function OL(Y) {
  return yt.is.call(void 0, Y, fy);
}
function BL(Y, X) {
  Ls.assertStruct.call(
    void 0,
    Y,
    fy,
    "Invalid JSON-RPC request",
    X
  );
}
var dy = yt.object.call(void 0, {
  id: bf,
  jsonrpc: Sc,
  result: yt.optional.call(void 0, yt.unknown.call(void 0)),
  error: yt.optional.call(void 0, xf)
}), e0 = Ac({
  id: bf,
  jsonrpc: Sc,
  result: $o
}), t0 = Ac({
  id: bf,
  jsonrpc: Sc,
  error: xf
}), hy = yt.union.call(void 0, [
  e0,
  t0
]);
function NL(Y) {
  return yt.is.call(void 0, Y, dy);
}
function kL(Y, X) {
  Ls.assertStruct.call(
    void 0,
    Y,
    dy,
    "Invalid pending JSON-RPC response",
    X
  );
}
function ML(Y) {
  return yt.is.call(void 0, Y, hy);
}
function LL(Y, X) {
  Ls.assertStruct.call(
    void 0,
    Y,
    hy,
    "Invalid JSON-RPC response",
    X
  );
}
function FL(Y) {
  return yt.is.call(void 0, Y, e0);
}
function $L(Y, X) {
  Ls.assertStruct.call(
    void 0,
    Y,
    e0,
    "Invalid JSON-RPC success response",
    X
  );
}
function DL(Y) {
  return yt.is.call(void 0, Y, t0);
}
function UL(Y, X) {
  Ls.assertStruct.call(
    void 0,
    Y,
    t0,
    "Invalid JSON-RPC failure response",
    X
  );
}
function jL(Y) {
  return yt.is.call(void 0, Y, xf);
}
function HL(Y, X) {
  Ls.assertStruct.call(
    void 0,
    Y,
    xf,
    "Invalid JSON-RPC error",
    X
  );
}
function zL(Y) {
  const { permitEmptyString: X, permitFractions: ee, permitNull: te } = {
    permitEmptyString: !0,
    permitFractions: !1,
    permitNull: !0,
    ...Y
  };
  return (ne) => !!(typeof ne == "number" && (ee || Number.isInteger(ne)) || typeof ne == "string" && (X || ne.length > 0) || te && ne === null);
}
$t.object = Ac;
$t.exactOptional = Bu;
$t.UnsafeJsonStruct = Nu;
$t.JsonStruct = $o;
$t.isValidJson = IL;
$t.getSafeJson = N3;
$t.getJsonSize = RL;
$t.jsonrpc2 = k3;
$t.JsonRpcVersionStruct = Sc;
$t.JsonRpcIdStruct = bf;
$t.JsonRpcErrorStruct = xf;
$t.JsonRpcParamsStruct = uy;
$t.JsonRpcRequestStruct = fy;
$t.JsonRpcNotificationStruct = ly;
$t.isJsonRpcNotification = CL;
$t.assertIsJsonRpcNotification = PL;
$t.isJsonRpcRequest = OL;
$t.assertIsJsonRpcRequest = BL;
$t.PendingJsonRpcResponseStruct = dy;
$t.JsonRpcSuccessStruct = e0;
$t.JsonRpcFailureStruct = t0;
$t.JsonRpcResponseStruct = hy;
$t.isPendingJsonRpcResponse = NL;
$t.assertIsPendingJsonRpcResponse = kL;
$t.isJsonRpcResponse = ML;
$t.assertIsJsonRpcResponse = LL;
$t.isJsonRpcSuccess = FL;
$t.assertIsJsonRpcSuccess = $L;
$t.isJsonRpcFailure = DL;
$t.assertIsJsonRpcFailure = UL;
$t.isJsonRpcError = jL;
$t.assertIsJsonRpcError = HL;
$t.getJsonRpcIdValidator = zL;
var r0 = {}, ig = { exports: {} }, fp, Iw;
function qL() {
  if (Iw)
    return fp;
  Iw = 1;
  var Y = 1e3, X = Y * 60, ee = X * 60, te = ee * 24, ne = te * 7, ie = te * 365.25;
  fp = function(le, he) {
    he = he || {};
    var me = typeof le;
    if (me === "string" && le.length > 0)
      return oe(le);
    if (me === "number" && isFinite(le))
      return he.long ? ae(le) : se(le);
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(le)
    );
  };
  function oe(le) {
    if (le = String(le), !(le.length > 100)) {
      var he = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        le
      );
      if (he) {
        var me = parseFloat(he[1]), ye = (he[2] || "ms").toLowerCase();
        switch (ye) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return me * ie;
          case "weeks":
          case "week":
          case "w":
            return me * ne;
          case "days":
          case "day":
          case "d":
            return me * te;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return me * ee;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return me * X;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return me * Y;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return me;
          default:
            return;
        }
      }
    }
  }
  function se(le) {
    var he = Math.abs(le);
    return he >= te ? Math.round(le / te) + "d" : he >= ee ? Math.round(le / ee) + "h" : he >= X ? Math.round(le / X) + "m" : he >= Y ? Math.round(le / Y) + "s" : le + "ms";
  }
  function ae(le) {
    var he = Math.abs(le);
    return he >= te ? ue(le, he, te, "day") : he >= ee ? ue(le, he, ee, "hour") : he >= X ? ue(le, he, X, "minute") : he >= Y ? ue(le, he, Y, "second") : le + " ms";
  }
  function ue(le, he, me, ye) {
    var we = he >= me * 1.5;
    return Math.round(le / me) + " " + ye + (we ? "s" : "");
  }
  return fp;
}
function GL(Y) {
  ee.debug = ee, ee.default = ee, ee.coerce = ae, ee.disable = ie, ee.enable = ne, ee.enabled = oe, ee.humanize = qL(), ee.destroy = ue, Object.keys(Y).forEach((le) => {
    ee[le] = Y[le];
  }), ee.names = [], ee.skips = [], ee.formatters = {};
  function X(le) {
    let he = 0;
    for (let me = 0; me < le.length; me++)
      he = (he << 5) - he + le.charCodeAt(me), he |= 0;
    return ee.colors[Math.abs(he) % ee.colors.length];
  }
  ee.selectColor = X;
  function ee(le) {
    let he, me = null, ye, we;
    function Ee(...Re) {
      if (!Ee.enabled)
        return;
      const Ue = Ee, Me = Number(/* @__PURE__ */ new Date()), De = Me - (he || Me);
      Ue.diff = De, Ue.prev = he, Ue.curr = Me, he = Me, Re[0] = ee.coerce(Re[0]), typeof Re[0] != "string" && Re.unshift("%O");
      let Fe = 0;
      Re[0] = Re[0].replace(/%([a-zA-Z%])/g, (Ke, tt) => {
        if (Ke === "%%")
          return "%";
        Fe++;
        const rt = ee.formatters[tt];
        if (typeof rt == "function") {
          const it = Re[Fe];
          Ke = rt.call(Ue, it), Re.splice(Fe, 1), Fe--;
        }
        return Ke;
      }), ee.formatArgs.call(Ue, Re), (Ue.log || ee.log).apply(Ue, Re);
    }
    return Ee.namespace = le, Ee.useColors = ee.useColors(), Ee.color = ee.selectColor(le), Ee.extend = te, Ee.destroy = ee.destroy, Object.defineProperty(Ee, "enabled", {
      enumerable: !0,
      configurable: !1,
      get: () => me !== null ? me : (ye !== ee.namespaces && (ye = ee.namespaces, we = ee.enabled(le)), we),
      set: (Re) => {
        me = Re;
      }
    }), typeof ee.init == "function" && ee.init(Ee), Ee;
  }
  function te(le, he) {
    const me = ee(this.namespace + (typeof he > "u" ? ":" : he) + le);
    return me.log = this.log, me;
  }
  function ne(le) {
    ee.save(le), ee.namespaces = le, ee.names = [], ee.skips = [];
    let he;
    const me = (typeof le == "string" ? le : "").split(/[\s,]+/), ye = me.length;
    for (he = 0; he < ye; he++)
      me[he] && (le = me[he].replace(/\*/g, ".*?"), le[0] === "-" ? ee.skips.push(new RegExp("^" + le.slice(1) + "$")) : ee.names.push(new RegExp("^" + le + "$")));
  }
  function ie() {
    const le = [
      ...ee.names.map(se),
      ...ee.skips.map(se).map((he) => "-" + he)
    ].join(",");
    return ee.enable(""), le;
  }
  function oe(le) {
    if (le[le.length - 1] === "*")
      return !0;
    let he, me;
    for (he = 0, me = ee.skips.length; he < me; he++)
      if (ee.skips[he].test(le))
        return !1;
    for (he = 0, me = ee.names.length; he < me; he++)
      if (ee.names[he].test(le))
        return !0;
    return !1;
  }
  function se(le) {
    return le.toString().substring(2, le.toString().length - 2).replace(/\.\*\?$/, "*");
  }
  function ae(le) {
    return le instanceof Error ? le.stack || le.message : le;
  }
  function ue() {
    console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  }
  return ee.enable(ee.load()), ee;
}
var VL = GL;
(function(Y, X) {
  X.formatArgs = te, X.save = ne, X.load = ie, X.useColors = ee, X.storage = oe(), X.destroy = /* @__PURE__ */ (() => {
    let ae = !1;
    return () => {
      ae || (ae = !0, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
    };
  })(), X.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function ee() {
    return typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs) ? !0 : typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/) ? !1 : typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
    typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
    typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function te(ae) {
    if (ae[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + ae[0] + (this.useColors ? "%c " : " ") + "+" + Y.exports.humanize(this.diff), !this.useColors)
      return;
    const ue = "color: " + this.color;
    ae.splice(1, 0, ue, "color: inherit");
    let le = 0, he = 0;
    ae[0].replace(/%[a-zA-Z%]/g, (me) => {
      me !== "%%" && (le++, me === "%c" && (he = le));
    }), ae.splice(he, 0, ue);
  }
  X.log = console.debug || console.log || (() => {
  });
  function ne(ae) {
    try {
      ae ? X.storage.setItem("debug", ae) : X.storage.removeItem("debug");
    } catch {
    }
  }
  function ie() {
    let ae;
    try {
      ae = X.storage.getItem("debug");
    } catch {
    }
    return !ae && typeof process < "u" && "env" in process && (ae = process.env.DEBUG), ae;
  }
  function oe() {
    try {
      return localStorage;
    } catch {
    }
  }
  Y.exports = VL(X);
  const { formatters: se } = Y.exports;
  se.j = function(ae) {
    try {
      return JSON.stringify(ae);
    } catch (ue) {
      return "[UnexpectedJSONParseError]: " + ue.message;
    }
  };
})(ig, ig.exports);
var WL = ig.exports;
Object.defineProperty(r0, "__esModule", { value: !0 });
function KL(Y) {
  return Y && Y.__esModule ? Y : { default: Y };
}
var JL = WL, YL = KL(JL), XL = YL.default.call(void 0, "metamask");
function ZL(Y) {
  return XL.extend(Y);
}
function QL(Y, X) {
  return Y.extend(X);
}
r0.createProjectLogger = ZL;
r0.createModuleLogger = QL;
var qr = {};
Object.defineProperty(qr, "__esModule", { value: !0 });
function M3(Y) {
  let X, ee = Y[0], te = 1;
  for (; te < Y.length; ) {
    const ne = Y[te], ie = Y[te + 1];
    if (te += 2, (ne === "optionalAccess" || ne === "optionalCall") && ee == null)
      return;
    ne === "access" || ne === "optionalAccess" ? (X = ee, ee = ie(ee)) : (ne === "call" || ne === "optionalCall") && (ee = ie((...oe) => ee.call(X, ...oe)), X = void 0);
  }
  return ee;
}
var vn = ns, py = /^(?<namespace>[-a-z0-9]{3,8}):(?<reference>[-_a-zA-Z0-9]{1,32})$/u, L3 = /^[-a-z0-9]{3,8}$/u, F3 = /^[-_a-zA-Z0-9]{1,32}$/u, gy = /^(?<chainId>(?<namespace>[-a-z0-9]{3,8}):(?<reference>[-_a-zA-Z0-9]{1,32})):(?<accountAddress>[-.%a-zA-Z0-9]{1,128})$/u, $3 = /^[-.%a-zA-Z0-9]{1,128}$/u, D3 = vn.pattern.call(void 0, vn.string.call(void 0), py), U3 = vn.pattern.call(void 0, vn.string.call(void 0), L3), j3 = vn.pattern.call(void 0, vn.string.call(void 0), F3), H3 = vn.pattern.call(void 0, vn.string.call(void 0), gy), z3 = vn.pattern.call(
  void 0,
  vn.string.call(void 0),
  $3
);
function eF(Y) {
  return vn.is.call(void 0, Y, D3);
}
function tF(Y) {
  return vn.is.call(void 0, Y, U3);
}
function rF(Y) {
  return vn.is.call(void 0, Y, j3);
}
function nF(Y) {
  return vn.is.call(void 0, Y, H3);
}
function iF(Y) {
  return vn.is.call(void 0, Y, z3);
}
function sF(Y) {
  const X = py.exec(Y);
  if (!M3([X, "optionalAccess", (ee) => ee.groups]))
    throw new Error("Invalid CAIP chain ID.");
  return {
    namespace: X.groups.namespace,
    reference: X.groups.reference
  };
}
function oF(Y) {
  const X = gy.exec(Y);
  if (!M3([X, "optionalAccess", (ee) => ee.groups]))
    throw new Error("Invalid CAIP account ID.");
  return {
    address: X.groups.accountAddress,
    chainId: X.groups.chainId,
    chain: {
      namespace: X.groups.namespace,
      reference: X.groups.reference
    }
  };
}
qr.CAIP_CHAIN_ID_REGEX = py;
qr.CAIP_NAMESPACE_REGEX = L3;
qr.CAIP_REFERENCE_REGEX = F3;
qr.CAIP_ACCOUNT_ID_REGEX = gy;
qr.CAIP_ACCOUNT_ADDRESS_REGEX = $3;
qr.CaipChainIdStruct = D3;
qr.CaipNamespaceStruct = U3;
qr.CaipReferenceStruct = j3;
qr.CaipAccountIdStruct = H3;
qr.CaipAccountAddressStruct = z3;
qr.isCaipChainId = eF;
qr.isCaipNamespace = tF;
qr.isCaipReference = rF;
qr.isCaipAccountId = nF;
qr.isCaipAccountAddress = iF;
qr.parseCaipChainId = sF;
qr.parseCaipAccountId = oF;
var my = {}, n0 = {};
Object.defineProperty(n0, "__esModule", { value: !0 });
function Rw(Y, X) {
  return Y ?? X();
}
var aF = oi, cF = ns, uF = (Y, X = {}) => {
  const ee = Rw(X.paddingRequired, () => !1), te = Rw(X.characterSet, () => "base64");
  let ne;
  te === "base64" ? ne = String.raw`[A-Za-z0-9+\/]` : (aF.assert.call(void 0, te === "base64url"), ne = String.raw`[-_A-Za-z0-9]`);
  let ie;
  return ee ? ie = new RegExp(
    `^(?:${ne}{4})*(?:${ne}{3}=|${ne}{2}==)?$`,
    "u"
  ) : ie = new RegExp(
    `^(?:${ne}{4})*(?:${ne}{2,3}|${ne}{3}=|${ne}{2}==)?$`,
    "u"
  ), cF.pattern.call(void 0, Y, ie);
};
n0.base64 = uF;
Object.defineProperty(my, "__esModule", { value: !0 });
var fF = n0, Cw = ns, lF = Cw.size.call(
  void 0,
  fF.base64.call(void 0, Cw.string.call(void 0), { paddingRequired: !0 }),
  44,
  44
);
my.ChecksumStruct = lF;
var Tc = {};
Object.defineProperty(Tc, "__esModule", { value: !0 });
var Xa = qt, dF = oi, wr = ns, q3 = wr.union.call(void 0, [wr.number.call(void 0), wr.bigint.call(void 0), wr.string.call(void 0), Xa.StrictHexStruct]), hF = wr.coerce.call(void 0, wr.number.call(void 0), q3, Number), pF = wr.coerce.call(void 0, wr.bigint.call(void 0), q3, BigInt);
wr.union.call(void 0, [Xa.StrictHexStruct, wr.instance.call(void 0, Uint8Array)]);
var gF = wr.coerce.call(
  void 0,
  wr.instance.call(void 0, Uint8Array),
  wr.union.call(void 0, [Xa.StrictHexStruct]),
  Xa.hexToBytes
), mF = wr.coerce.call(void 0, Xa.StrictHexStruct, wr.instance.call(void 0, Uint8Array), Xa.bytesToHex);
function yF(Y) {
  try {
    const X = wr.create.call(void 0, Y, hF);
    return dF.assert.call(
      void 0,
      Number.isFinite(X),
      `Expected a number-like value, got "${Y}".`
    ), X;
  } catch (X) {
    throw X instanceof wr.StructError ? new Error(`Expected a number-like value, got "${Y}".`) : X;
  }
}
function bF(Y) {
  try {
    return wr.create.call(void 0, Y, pF);
  } catch (X) {
    throw X instanceof wr.StructError ? new Error(
      `Expected a number-like value, got "${String(X.value)}".`
    ) : X;
  }
}
function xF(Y) {
  if (typeof Y == "string" && Y.toLowerCase() === "0x")
    return new Uint8Array();
  try {
    return wr.create.call(void 0, Y, gF);
  } catch (X) {
    throw X instanceof wr.StructError ? new Error(
      `Expected a bytes-like value, got "${String(X.value)}".`
    ) : X;
  }
}
function wF(Y) {
  if (Y instanceof Uint8Array && Y.length === 0 || typeof Y == "string" && Y.toLowerCase() === "0x")
    return "0x";
  try {
    return wr.create.call(void 0, Y, mF);
  } catch (X) {
    throw X instanceof wr.StructError ? new Error(
      `Expected a bytes-like value, got "${String(X.value)}".`
    ) : X;
  }
}
Tc.createNumber = yF;
Tc.createBigInt = bF;
Tc.createBytes = xF;
Tc.createHex = wF;
var i0 = {}, wf = {};
Object.defineProperty(wf, "__esModule", { value: !0 });
var G3 = (Y, X, ee) => {
  if (!X.has(Y))
    throw TypeError("Cannot " + ee);
}, vF = (Y, X, ee) => (G3(Y, X, "read from private field"), ee ? ee.call(Y) : X.get(Y)), EF = (Y, X, ee) => {
  if (X.has(Y))
    throw TypeError("Cannot add the same private member more than once");
  X instanceof WeakSet ? X.add(Y) : X.set(Y, ee);
}, _F = (Y, X, ee, te) => (G3(Y, X, "write to private field"), te ? te.call(Y, ee) : X.set(Y, ee), ee);
wf.__privateGet = vF;
wf.__privateAdd = EF;
wf.__privateSet = _F;
Object.defineProperty(i0, "__esModule", { value: !0 });
var $r = wf, li, yy = class {
  constructor(Y) {
    $r.__privateAdd.call(void 0, this, li, void 0), $r.__privateSet.call(void 0, this, li, new Map(Y)), Object.freeze(this);
  }
  get size() {
    return $r.__privateGet.call(void 0, this, li).size;
  }
  [Symbol.iterator]() {
    return $r.__privateGet.call(void 0, this, li)[Symbol.iterator]();
  }
  entries() {
    return $r.__privateGet.call(void 0, this, li).entries();
  }
  forEach(Y, X) {
    return $r.__privateGet.call(void 0, this, li).forEach(
      (ee, te, ne) => Y.call(X, ee, te, this)
    );
  }
  get(Y) {
    return $r.__privateGet.call(void 0, this, li).get(Y);
  }
  has(Y) {
    return $r.__privateGet.call(void 0, this, li).has(Y);
  }
  keys() {
    return $r.__privateGet.call(void 0, this, li).keys();
  }
  values() {
    return $r.__privateGet.call(void 0, this, li).values();
  }
  toString() {
    return `FrozenMap(${this.size}) {${this.size > 0 ? ` ${[...this.entries()].map(([Y, X]) => `${String(Y)} => ${String(X)}`).join(", ")} ` : ""}}`;
  }
};
li = /* @__PURE__ */ new WeakMap();
var Pi, by = class {
  constructor(Y) {
    $r.__privateAdd.call(void 0, this, Pi, void 0), $r.__privateSet.call(void 0, this, Pi, new Set(Y)), Object.freeze(this);
  }
  get size() {
    return $r.__privateGet.call(void 0, this, Pi).size;
  }
  [Symbol.iterator]() {
    return $r.__privateGet.call(void 0, this, Pi)[Symbol.iterator]();
  }
  entries() {
    return $r.__privateGet.call(void 0, this, Pi).entries();
  }
  forEach(Y, X) {
    return $r.__privateGet.call(void 0, this, Pi).forEach(
      (ee, te, ne) => Y.call(X, ee, te, this)
    );
  }
  has(Y) {
    return $r.__privateGet.call(void 0, this, Pi).has(Y);
  }
  keys() {
    return $r.__privateGet.call(void 0, this, Pi).keys();
  }
  values() {
    return $r.__privateGet.call(void 0, this, Pi).values();
  }
  toString() {
    return `FrozenSet(${this.size}) {${this.size > 0 ? ` ${[...this.values()].map((Y) => String(Y)).join(", ")} ` : ""}}`;
  }
};
Pi = /* @__PURE__ */ new WeakMap();
Object.freeze(yy);
Object.freeze(yy.prototype);
Object.freeze(by);
Object.freeze(by.prototype);
i0.FrozenMap = yy;
i0.FrozenSet = by;
Object.defineProperty(pe, "__esModule", { value: !0 });
var s0 = vc, AF = Zm, xy = gf, Fs = Ei, Kt = $t, V3 = r0, sn = qr, SF = my, TF = n0, o0 = Tc, tr = qt, a0 = oi, vf = mo, Si = En, W3 = i0;
pe.AssertionError = a0.AssertionError;
pe.CAIP_ACCOUNT_ADDRESS_REGEX = sn.CAIP_ACCOUNT_ADDRESS_REGEX;
pe.CAIP_ACCOUNT_ID_REGEX = sn.CAIP_ACCOUNT_ID_REGEX;
pe.CAIP_CHAIN_ID_REGEX = sn.CAIP_CHAIN_ID_REGEX;
pe.CAIP_NAMESPACE_REGEX = sn.CAIP_NAMESPACE_REGEX;
pe.CAIP_REFERENCE_REGEX = sn.CAIP_REFERENCE_REGEX;
pe.CaipAccountAddressStruct = sn.CaipAccountAddressStruct;
pe.CaipAccountIdStruct = sn.CaipAccountIdStruct;
pe.CaipChainIdStruct = sn.CaipChainIdStruct;
pe.CaipNamespaceStruct = sn.CaipNamespaceStruct;
pe.CaipReferenceStruct = sn.CaipReferenceStruct;
pe.ChecksumStruct = SF.ChecksumStruct;
pe.Duration = xy.Duration;
pe.ESCAPE_CHARACTERS_REGEXP = Si.ESCAPE_CHARACTERS_REGEXP;
pe.FrozenMap = W3.FrozenMap;
pe.FrozenSet = W3.FrozenSet;
pe.HexAddressStruct = tr.HexAddressStruct;
pe.HexChecksumAddressStruct = tr.HexChecksumAddressStruct;
pe.HexStruct = tr.HexStruct;
pe.JsonRpcErrorStruct = Kt.JsonRpcErrorStruct;
pe.JsonRpcFailureStruct = Kt.JsonRpcFailureStruct;
pe.JsonRpcIdStruct = Kt.JsonRpcIdStruct;
pe.JsonRpcNotificationStruct = Kt.JsonRpcNotificationStruct;
pe.JsonRpcParamsStruct = Kt.JsonRpcParamsStruct;
pe.JsonRpcRequestStruct = Kt.JsonRpcRequestStruct;
pe.JsonRpcResponseStruct = Kt.JsonRpcResponseStruct;
pe.JsonRpcSuccessStruct = Kt.JsonRpcSuccessStruct;
pe.JsonRpcVersionStruct = Kt.JsonRpcVersionStruct;
pe.JsonSize = Si.JsonSize;
pe.JsonStruct = Kt.JsonStruct;
pe.PendingJsonRpcResponseStruct = Kt.PendingJsonRpcResponseStruct;
pe.StrictHexStruct = tr.StrictHexStruct;
pe.UnsafeJsonStruct = Kt.UnsafeJsonStruct;
pe.VersionRangeStruct = Fs.VersionRangeStruct;
pe.VersionStruct = Fs.VersionStruct;
pe.add0x = tr.add0x;
pe.assert = a0.assert;
pe.assertExhaustive = a0.assertExhaustive;
pe.assertIsBytes = tr.assertIsBytes;
pe.assertIsHexString = tr.assertIsHexString;
pe.assertIsJsonRpcError = Kt.assertIsJsonRpcError;
pe.assertIsJsonRpcFailure = Kt.assertIsJsonRpcFailure;
pe.assertIsJsonRpcNotification = Kt.assertIsJsonRpcNotification;
pe.assertIsJsonRpcRequest = Kt.assertIsJsonRpcRequest;
pe.assertIsJsonRpcResponse = Kt.assertIsJsonRpcResponse;
pe.assertIsJsonRpcSuccess = Kt.assertIsJsonRpcSuccess;
pe.assertIsPendingJsonRpcResponse = Kt.assertIsPendingJsonRpcResponse;
pe.assertIsSemVerRange = Fs.assertIsSemVerRange;
pe.assertIsSemVerVersion = Fs.assertIsSemVerVersion;
pe.assertIsStrictHexString = tr.assertIsStrictHexString;
pe.assertStruct = a0.assertStruct;
pe.base64 = TF.base64;
pe.base64ToBytes = tr.base64ToBytes;
pe.bigIntToBytes = tr.bigIntToBytes;
pe.bigIntToHex = s0.bigIntToHex;
pe.bytesToBase64 = tr.bytesToBase64;
pe.bytesToBigInt = tr.bytesToBigInt;
pe.bytesToHex = tr.bytesToHex;
pe.bytesToNumber = tr.bytesToNumber;
pe.bytesToSignedBigInt = tr.bytesToSignedBigInt;
pe.bytesToString = tr.bytesToString;
pe.calculateNumberSize = Si.calculateNumberSize;
pe.calculateStringSize = Si.calculateStringSize;
pe.concatBytes = tr.concatBytes;
pe.createBigInt = o0.createBigInt;
pe.createBytes = o0.createBytes;
pe.createDataView = tr.createDataView;
pe.createDeferredPromise = AF.createDeferredPromise;
pe.createHex = o0.createHex;
pe.createModuleLogger = V3.createModuleLogger;
pe.createNumber = o0.createNumber;
pe.createProjectLogger = V3.createProjectLogger;
pe.exactOptional = Kt.exactOptional;
pe.getChecksumAddress = tr.getChecksumAddress;
pe.getErrorMessage = vf.getErrorMessage;
pe.getJsonRpcIdValidator = Kt.getJsonRpcIdValidator;
pe.getJsonSize = Kt.getJsonSize;
pe.getKnownPropertyNames = Si.getKnownPropertyNames;
pe.getSafeJson = Kt.getSafeJson;
pe.gtRange = Fs.gtRange;
pe.gtVersion = Fs.gtVersion;
pe.hasProperty = Si.hasProperty;
pe.hexToBigInt = s0.hexToBigInt;
pe.hexToBytes = tr.hexToBytes;
pe.hexToNumber = s0.hexToNumber;
pe.inMilliseconds = xy.inMilliseconds;
pe.isASCII = Si.isASCII;
pe.isBytes = tr.isBytes;
pe.isCaipAccountAddress = sn.isCaipAccountAddress;
pe.isCaipAccountId = sn.isCaipAccountId;
pe.isCaipChainId = sn.isCaipChainId;
pe.isCaipNamespace = sn.isCaipNamespace;
pe.isCaipReference = sn.isCaipReference;
pe.isErrorWithCode = vf.isErrorWithCode;
pe.isErrorWithMessage = vf.isErrorWithMessage;
pe.isErrorWithStack = vf.isErrorWithStack;
pe.isHexString = tr.isHexString;
pe.isJsonRpcError = Kt.isJsonRpcError;
pe.isJsonRpcFailure = Kt.isJsonRpcFailure;
pe.isJsonRpcNotification = Kt.isJsonRpcNotification;
pe.isJsonRpcRequest = Kt.isJsonRpcRequest;
pe.isJsonRpcResponse = Kt.isJsonRpcResponse;
pe.isJsonRpcSuccess = Kt.isJsonRpcSuccess;
pe.isNonEmptyArray = Si.isNonEmptyArray;
pe.isNullOrUndefined = Si.isNullOrUndefined;
pe.isObject = Si.isObject;
pe.isPendingJsonRpcResponse = Kt.isPendingJsonRpcResponse;
pe.isPlainObject = Si.isPlainObject;
pe.isStrictHexString = tr.isStrictHexString;
pe.isValidChecksumAddress = tr.isValidChecksumAddress;
pe.isValidHexAddress = tr.isValidHexAddress;
pe.isValidJson = Kt.isValidJson;
pe.isValidSemVerRange = Fs.isValidSemVerRange;
pe.isValidSemVerVersion = Fs.isValidSemVerVersion;
pe.jsonrpc2 = Kt.jsonrpc2;
pe.numberToBytes = tr.numberToBytes;
pe.numberToHex = s0.numberToHex;
pe.object = Kt.object;
pe.parseCaipAccountId = sn.parseCaipAccountId;
pe.parseCaipChainId = sn.parseCaipChainId;
pe.remove0x = tr.remove0x;
pe.satisfiesVersionRange = Fs.satisfiesVersionRange;
pe.signedBigIntToBytes = tr.signedBigIntToBytes;
pe.stringToBytes = tr.stringToBytes;
pe.timeSince = xy.timeSince;
pe.valueToBytes = tr.valueToBytes;
pe.wrapError = vf.wrapError;
Object.defineProperty(tn, "__esModule", { value: !0 });
tn.normalize = tn.recoverPublicKey = tn.concatSig = tn.legacyToBuffer = tn.isNullish = tn.padWithZeroes = void 0;
const xs = Od, ka = pe;
function sg(Y, X) {
  if (Y !== "" && !/^[a-f0-9]+$/iu.test(Y))
    throw new Error(`Expected an unprefixed hex string. Received: ${Y}`);
  if (X < 0)
    throw new Error(`Expected a non-negative integer target length. Received: ${X}`);
  return String.prototype.padStart.call(Y, X, "0");
}
tn.padWithZeroes = sg;
function K3(Y) {
  return Y == null;
}
tn.isNullish = K3;
function IF(Y) {
  return typeof Y == "string" && !(0, xs.isHexString)(Y) ? Buffer.from(Y) : (0, xs.toBuffer)(Y);
}
tn.legacyToBuffer = IF;
function RF(Y, X, ee) {
  const te = (0, xs.fromSigned)(X), ne = (0, xs.fromSigned)(ee), ie = (0, xs.bufferToInt)(Y), oe = sg((0, xs.toUnsigned)(te).toString("hex"), 64), se = sg((0, xs.toUnsigned)(ne).toString("hex"), 64), ae = (0, ka.remove0x)((0, ka.numberToHex)(ie));
  return (0, ka.add0x)(oe.concat(se, ae));
}
tn.concatSig = RF;
function CF(Y, X) {
  const ee = (0, xs.fromRpcSig)(X);
  return (0, xs.ecrecover)(Y, ee.v, ee.r, ee.s);
}
tn.recoverPublicKey = CF;
function PF(Y) {
  if (!K3(Y)) {
    if (typeof Y == "number") {
      if (Y < 0)
        return "0x";
      const X = (0, ka.numberToBytes)(Y);
      Y = (0, ka.bytesToHex)(X);
    }
    if (typeof Y != "string") {
      let X = "eth-sig-util.normalize() requires hex string or integer input.";
      throw X += ` received ${typeof Y}: ${Y}`, new Error(X);
    }
    return (0, ka.add0x)(Y.toLowerCase());
  }
}
tn.normalize = PF;
Object.defineProperty(to, "__esModule", { value: !0 });
to.extractPublicKey = to.recoverPersonalSignature = to.personalSign = void 0;
const Ma = Od, qi = tn;
function OF({ privateKey: Y, data: X }) {
  if ((0, qi.isNullish)(X))
    throw new Error("Missing data parameter");
  if ((0, qi.isNullish)(Y))
    throw new Error("Missing privateKey parameter");
  const ee = (0, qi.legacyToBuffer)(X), te = (0, Ma.hashPersonalMessage)(ee), ne = (0, Ma.ecsign)(te, Y);
  return (0, qi.concatSig)((0, Ma.toBuffer)(ne.v), ne.r, ne.s);
}
to.personalSign = OF;
function BF({ data: Y, signature: X }) {
  if ((0, qi.isNullish)(Y))
    throw new Error("Missing data parameter");
  if ((0, qi.isNullish)(X))
    throw new Error("Missing signature parameter");
  const ee = J3(Y, X), te = (0, Ma.publicToAddress)(ee);
  return (0, Ma.bufferToHex)(te);
}
to.recoverPersonalSignature = BF;
function NF({ data: Y, signature: X }) {
  if ((0, qi.isNullish)(Y))
    throw new Error("Missing data parameter");
  if ((0, qi.isNullish)(X))
    throw new Error("Missing signature parameter");
  return `0x${J3(Y, X).toString("hex")}`;
}
to.extractPublicKey = NF;
function J3(Y, X) {
  const ee = (0, Ma.hashPersonalMessage)((0, qi.legacyToBuffer)(Y));
  return (0, qi.recoverPublicKey)(ee, X);
}
var Y3 = {}, X3 = {}, Z3 = {}, Ti = {};
(function(Y) {
  Object.defineProperty(Y, "__esModule", { value: !0 }), Y.ParserError = Y.getErrorStack = Y.getErrorMessage = void 0;
  const X = pe, ee = (ie) => typeof ie == "string" ? ie : ie instanceof Error || (0, X.isObject)(ie) && (0, X.hasProperty)(ie, "message") && typeof ie.message == "string" ? ie.message : "Unknown error.";
  Y.getErrorMessage = ee;
  const te = (ie) => {
    if (ie instanceof Error)
      return ie.stack;
  };
  Y.getErrorStack = te;
  class ne extends Error {
    constructor(oe, se) {
      super(oe), this.name = "ParserError";
      const ae = (0, Y.getErrorStack)(se);
      ae && (this.stack = ae);
    }
  }
  Y.ParserError = ne;
})(Ti);
var lp = {}, c0 = {};
Object.defineProperty(c0, "__esModule", { value: !0 });
c0.iterate = void 0;
const Pw = pe, kF = function* (Y, X = 32) {
  for (let ee = 0; ee < Y.length; ee += X) {
    const te = (ie) => {
      (0, Pw.assert)(ie >= 0, "Cannot skip a negative number of bytes."), (0, Pw.assert)(ie % X === 0, "Length must be a multiple of the size."), ee += ie;
    }, ne = Y.subarray(ee);
    yield { skip: te, value: ne };
  }
  return {
    skip: () => {
    },
    value: new Uint8Array()
  };
};
c0.iterate = kF;
var dp = {}, Q3 = {}, yo = {}, ro = {};
Object.defineProperty(ro, "__esModule", { value: !0 });
ro.padEnd = ro.padStart = ro.set = void 0;
const wy = pe, eA = 32, MF = (Y, X, ee) => (0, wy.concatBytes)([
  Y.subarray(0, ee),
  X,
  Y.subarray(ee + X.length)
]);
ro.set = MF;
const LF = (Y, X = eA) => {
  const ee = new Uint8Array(Math.max(X - Y.length, 0)).fill(0);
  return (0, wy.concatBytes)([ee, Y]);
};
ro.padStart = LF;
const FF = (Y, X = eA) => {
  const ee = new Uint8Array(Math.max(X - Y.length, 0)).fill(0);
  return (0, wy.concatBytes)([Y, ee]);
};
ro.padEnd = FF;
(function(Y) {
  var X = St && St.__createBinding || (Object.create ? function(te, ne, ie, oe) {
    oe === void 0 && (oe = ie);
    var se = Object.getOwnPropertyDescriptor(ne, ie);
    (!se || ("get" in se ? !ne.__esModule : se.writable || se.configurable)) && (se = { enumerable: !0, get: function() {
      return ne[ie];
    } }), Object.defineProperty(te, oe, se);
  } : function(te, ne, ie, oe) {
    oe === void 0 && (oe = ie), te[oe] = ne[ie];
  }), ee = St && St.__exportStar || function(te, ne) {
    for (var ie in te)
      ie !== "default" && !Object.prototype.hasOwnProperty.call(ne, ie) && X(ne, te, ie);
  };
  Object.defineProperty(Y, "__esModule", { value: !0 }), ee(ro, Y);
})(yo);
(function(Y) {
  Object.defineProperty(Y, "__esModule", { value: !0 }), Y.address = Y.getAddress = void 0;
  const X = pe, ee = Ti, te = yo, ne = (ie) => {
    const oe = (0, X.createBytes)(ie);
    return (0, X.assert)(oe.length <= 20, new ee.ParserError(`Invalid address value. Expected address to be 20 bytes long, but received ${oe.length} bytes.`)), (0, te.padStart)(oe, 20);
  };
  Y.getAddress = ne, Y.address = {
    isDynamic: !1,
    /**
     * Get if the given value is a valid address type. Since `address` is a simple
     * type, this is just a check that the value is "address".
     *
     * @param type - The type to check.
     * @returns Whether the type is a valid address type.
     */
    isType: (ie) => ie === "address",
    /**
     * Get the byte length of an encoded address. Since `address` is a simple
     * type, this always returns 32.
     *
     * Note that actual addresses are only 20 bytes long, but the encoding of
     * the `address` type is always 32 bytes long.
     *
     * @returns The byte length of an encoded address.
     */
    getByteLength() {
      return 32;
    },
    /**
     * Encode the given address to a 32-byte-long byte array.
     *
     * @param args - The encoding arguments.
     * @param args.buffer - The byte array to add to.
     * @param args.value - The address to encode.
     * @param args.packed - Whether to use packed encoding.
     * @returns The bytes with the encoded address added to it.
     */
    encode({ buffer: ie, value: oe, packed: se }) {
      const ae = (0, Y.getAddress)(oe);
      if (se)
        return (0, X.concatBytes)([ie, ae]);
      const ue = (0, te.padStart)(ae);
      return (0, X.concatBytes)([ie, ue]);
    },
    /**
     * Decode the given byte array to an address.
     *
     * @param args - The decoding arguments.
     * @param args.value - The byte array to decode.
     * @returns The decoded address as a hexadecimal string, starting with the
     * "0x"-prefix.
     */
    decode({ value: ie }) {
      return (0, X.add0x)((0, X.bytesToHex)(ie.slice(12, 32)));
    }
  };
})(Q3);
var hp = {}, u0 = {};
(function(Y) {
  Object.defineProperty(Y, "__esModule", { value: !0 }), Y.fixedBytes = Y.getByteLength = void 0;
  const X = pe, ee = Ti, te = yo, ne = /^bytes([0-9]{1,2})$/u, ie = (oe) => {
    var se;
    const ae = (se = oe.match(ne)) == null ? void 0 : se[1];
    (0, X.assert)(ae, `Invalid byte length. Expected a number between 1 and 32, but received "${oe}".`);
    const ue = Number(ae);
    return (0, X.assert)(ue > 0 && ue <= 32, new ee.ParserError(`Invalid byte length. Expected a number between 1 and 32, but received "${oe}".`)), ue;
  };
  Y.getByteLength = ie, Y.fixedBytes = {
    isDynamic: !1,
    /**
     * Check if a type is a fixed bytes type.
     *
     * @param type - The type to check.
     * @returns Whether the type is a fixed bytes type.
     */
    isType(oe) {
      return ne.test(oe);
    },
    /**
     * Get the byte length of an encoded fixed bytes type.
     *
     * @returns The byte length of the type.
     */
    getByteLength() {
      return 32;
    },
    /**
     * Encode a fixed bytes value.
     *
     * @param args - The arguments to encode.
     * @param args.type - The type of the value.
     * @param args.buffer - The byte array to add to.
     * @param args.value - The value to encode.
     * @param args.packed - Whether to use packed encoding.
     * @returns The bytes with the encoded value added to it.
     */
    encode({ type: oe, buffer: se, value: ae, packed: ue }) {
      const le = (0, Y.getByteLength)(oe), he = (0, X.createBytes)(ae);
      return (0, X.assert)(he.length <= le, new ee.ParserError(`Expected a value of length ${le}, but received a value of length ${he.length}.`)), ue ? (0, X.concatBytes)([se, (0, te.padEnd)(he, le)]) : (0, X.concatBytes)([se, (0, te.padEnd)(he)]);
    },
    /**
     * Decode a fixed bytes value.
     *
     * @param args - The arguments to decode.
     * @param args.type - The type of the value.
     * @param args.value - The value to decode.
     * @returns The decoded value as a `Uint8Array`.
     */
    decode({ type: oe, value: se }) {
      const ae = (0, Y.getByteLength)(oe);
      return se.slice(0, ae);
    }
  };
})(u0);
var pp = {}, Ow;
function tA() {
  return Ow || (Ow = 1, function(Y) {
    Object.defineProperty(Y, "__esModule", { value: !0 }), Y.tuple = Y.getTupleElements = void 0;
    const X = pe, ee = Ti, te = Ey(), ne = /^\((.+)\)$/u, ie = (se) => ne.test(se), oe = (se) => {
      (0, X.assert)(se.startsWith("(") && se.endsWith(")"), new ee.ParserError(`Invalid tuple type. Expected tuple type, but received "${se}".`));
      const ae = [];
      let ue = "", le = 0;
      for (let he = 1; he < se.length - 1; he++) {
        const me = se[he];
        me === "," && le === 0 ? (ae.push(ue.trim()), ue = "") : (ue += me, me === "(" ? le += 1 : me === ")" && (le -= 1));
      }
      return ue.trim() && ae.push(ue.trim()), ae;
    };
    Y.getTupleElements = oe, Y.tuple = {
      /**
       * Check if the tuple is dynamic. Tuples are dynamic if one or more elements
       * of the tuple are dynamic.
       *
       * @param type - The type to check.
       * @returns Whether the tuple is dynamic.
       */
      isDynamic(se) {
        return (0, Y.getTupleElements)(se).some((ae) => {
          const ue = (0, te.getParser)(ae);
          return (0, te.isDynamicParser)(ue, ae);
        });
      },
      /**
       * Check if a type is a tuple type.
       *
       * @param type - The type to check.
       * @returns Whether the type is a tuple type.
       */
      isType(se) {
        return ie(se);
      },
      /**
       * Get the byte length of a tuple type. If the tuple is dynamic, this will
       * always return 32. If the tuple is static, this will return the sum of the
       * byte lengths of the tuple elements.
       *
       * @param type - The type to get the byte length for.
       * @returns The byte length of the tuple type.
       */
      getByteLength(se) {
        return (0, te.isDynamicParser)(this, se) ? 32 : (0, Y.getTupleElements)(se).reduce((ae, ue) => ae + (0, te.getParser)(ue).getByteLength(ue), 0);
      },
      /**
       * Encode a tuple value.
       *
       * @param args - The encoding arguments.
       * @param args.type - The type of the value.
       * @param args.buffer - The byte array to add to.
       * @param args.value - The value to encode.
       * @param args.packed - Whether to use non-standard packed encoding.
       * @param args.tight - Whether to use non-standard tight encoding.
       * @returns The bytes with the encoded value added to it.
       */
      encode({ type: se, buffer: ae, value: ue, packed: le, tight: he }) {
        const me = (0, Y.getTupleElements)(se);
        return (0, te.pack)({
          types: me,
          values: ue,
          byteArray: ae,
          packed: le,
          tight: he
        });
      },
      /**
       * Decode a tuple value.
       *
       * @param args - The decoding arguments.
       * @param args.type - The type of the value.
       * @param args.value - The value to decode.
       * @param args.skip - A function to skip a number of bytes.
       * @returns The decoded value.
       */
      decode({ type: se, value: ae, skip: ue }) {
        const le = (0, Y.getTupleElements)(se), he = this.getByteLength(se) - 32;
        return ue(he), (0, te.unpack)(le, ae);
      }
    };
  }(pp)), pp;
}
var Bw;
function $F() {
  return Bw || (Bw = 1, function(Y) {
    Object.defineProperty(Y, "__esModule", { value: !0 }), Y.array = Y.getTupleType = Y.getArrayType = Y.isArrayType = void 0;
    const X = pe, ee = Ti, te = Ey(), ne = yo, ie = u0, oe = tA(), se = /^(?<type>.*)\[(?<length>\d*?)\]$/u, ae = (he) => se.test(he);
    Y.isArrayType = ae;
    const ue = (he) => {
      var me;
      const ye = he.match(se);
      return (0, X.assert)((me = ye == null ? void 0 : ye.groups) == null ? void 0 : me.type, new ee.ParserError(`Invalid array type. Expected an array type, but received "${he}".`)), [
        ye.groups.type,
        ye.groups.length ? parseInt(ye.groups.length, 10) : void 0
      ];
    };
    Y.getArrayType = ue;
    const le = (he, me) => `(${new Array(me).fill(he).join(",")})`;
    Y.getTupleType = le, Y.array = {
      /**
       * Check if the array is dynamic. Arrays are dynamic if the array does not
       * have a fixed length, or if the array type is dynamic.
       *
       * @param type - The type to check.
       * @returns Whether the array is dynamic.
       */
      isDynamic(he) {
        const [me, ye] = (0, Y.getArrayType)(he);
        return (
          // `T[]` is dynamic for any `T`. `T[k]` is dynamic for any dynamic `T` and
          // any `k >= 0`.
          ye === void 0 || (0, te.isDynamicParser)((0, te.getParser)(me), me)
        );
      },
      /**
       * Check if a type is an array type.
       *
       * @param type - The type to check.
       * @returns Whether the type is an array type.
       */
      isType(he) {
        return (0, Y.isArrayType)(he);
      },
      /**
       * Get the byte length of an encoded array. If the array is dynamic, this
       * returns 32, i.e., the length of the pointer to the array. If the array is
       * static, this returns the byte length of the resulting tuple type.
       *
       * @param type - The type to get the byte length for.
       * @returns The byte length of an encoded array.
       */
      getByteLength(he) {
        (0, X.assert)((0, Y.isArrayType)(he), new ee.ParserError(`Expected an array type, but received "${he}".`));
        const [me, ye] = (0, Y.getArrayType)(he);
        return !(0, te.isDynamicParser)(this, he) && ye !== void 0 ? oe.tuple.getByteLength((0, Y.getTupleType)(me, ye)) : 32;
      },
      /**
       * Encode the given array to a byte array. If the array is static, this uses
       * the tuple encoder.
       *
       * @param args - The encoding arguments.
       * @param args.type - The type of the array.
       * @param args.buffer - The byte array to add to.
       * @param args.value - The array to encode.
       * @param args.packed - Whether to use non-standard packed encoding.
       * @param args.tight - Whether to use non-standard tight encoding.
       * @returns The bytes with the encoded array added to it.
       */
      encode({ type: he, buffer: me, value: ye, packed: we, tight: Ee }) {
        const [Re, Ue] = (0, Y.getArrayType)(he);
        if ((0, X.assert)(!we || !(0, Y.isArrayType)(Re), new ee.ParserError("Cannot pack nested arrays.")), we && (0, te.isDynamicParser)((0, te.getParser)(Re), Re))
          return (0, te.pack)({
            types: new Array(ye.length).fill(Re),
            values: ye,
            byteArray: me,
            packed: we,
            arrayPacked: !0,
            tight: Ee
          });
        if (Ue)
          return (0, X.assert)(Ue === ye.length, new ee.ParserError(`Array length does not match type length. Expected a length of ${Ue}, but received ${ye.length}.`)), oe.tuple.encode({
            type: (0, Y.getTupleType)(Re, Ue),
            buffer: me,
            value: ye,
            // In "tight" mode, we don't pad the values to 32 bytes if the value is
            // of type `bytesN`. This is an edge case in `ethereumjs-abi` that we
            // support to provide compatibility with it.
            packed: ie.fixedBytes.isType(Re) && Ee,
            tight: Ee
          });
        if (we)
          return (0, te.pack)({
            types: new Array(ye.length).fill(Re),
            values: ye,
            byteArray: me,
            // In "tight" mode, we don't pad the values to 32 bytes if the value is
            // of type `bytesN`. This is an edge case in `ethereumjs-abi` that we
            // support to provide compatibility with it.
            packed: ie.fixedBytes.isType(Re) && Ee,
            arrayPacked: !0,
            tight: Ee
          });
        const Me = (0, ne.padStart)((0, X.numberToBytes)(ye.length));
        return (0, te.pack)({
          types: new Array(ye.length).fill(Re),
          values: ye,
          byteArray: (0, X.concatBytes)([me, Me]),
          packed: we,
          tight: Ee
        });
      },
      /**
       * Decode an array from the given byte array.
       *
       * @param args - The decoding arguments.
       * @param args.type - The type of the array.
       * @param args.value - The byte array to decode.
       * @returns The decoded array.
       */
      decode({ type: he, value: me, ...ye }) {
        const [we, Ee] = (0, Y.getArrayType)(he);
        if (Ee) {
          const Ue = oe.tuple.decode({
            type: (0, Y.getTupleType)(we, Ee),
            value: me,
            ...ye
          });
          return (0, X.assert)(Ue.length === Ee, new ee.ParserError(`Array length does not match type length. Expected a length of ${Ee}, but received ${Ue.length}.`)), Ue;
        }
        const Re = (0, X.bytesToNumber)(me.subarray(0, 32));
        return (0, te.unpack)(new Array(Re).fill(we), me.subarray(32));
      }
    };
  }(hp)), hp;
}
var rA = {}, vy = {};
(function(Y) {
  Object.defineProperty(Y, "__esModule", { value: !0 }), Y.number = Y.getBigInt = Y.assertNumberLength = Y.getLength = Y.isSigned = void 0;
  const X = pe, ee = Ti, te = yo, ne = /^u?int(?<length>[0-9]*)?$/u, ie = (ue) => !ue.startsWith("u");
  Y.isSigned = ie;
  const oe = (ue) => {
    var le;
    if (ue === "int" || ue === "uint")
      return 256;
    const he = ue.match(ne);
    (0, X.assert)((le = he == null ? void 0 : he.groups) == null ? void 0 : le.length, new ee.ParserError(`Invalid number type. Expected a number type, but received "${ue}".`));
    const me = parseInt(he.groups.length, 10);
    return (0, X.assert)(me >= 8 && me <= 256, new ee.ParserError(`Invalid number length. Expected a number between 8 and 256, but received "${ue}".`)), (0, X.assert)(me % 8 === 0, new ee.ParserError(`Invalid number length. Expected a multiple of 8, but received "${ue}".`)), me;
  };
  Y.getLength = oe;
  const se = (ue, le) => {
    const he = (0, Y.getLength)(le), me = BigInt(2) ** BigInt(he - ((0, Y.isSigned)(le) ? 1 : 0)) - BigInt(1);
    if ((0, Y.isSigned)(le)) {
      (0, X.assert)(ue >= -(me + BigInt(1)) && ue <= me, new ee.ParserError(`Number "${ue}" is out of range for type "${le}".`));
      return;
    }
    (0, X.assert)(ue <= me, new ee.ParserError(`Number "${ue}" is out of range for type "${le}".`));
  };
  Y.assertNumberLength = se;
  const ae = (ue) => {
    try {
      return (0, X.createBigInt)(ue);
    } catch {
      throw new ee.ParserError(`Invalid number. Expected a valid number value, but received "${ue}".`);
    }
  };
  Y.getBigInt = ae, Y.number = {
    isDynamic: !1,
    /**
     * Check if a type is a number type.
     *
     * @param type - The type to check.
     * @returns Whether the type is a number type.
     */
    isType(ue) {
      return ne.test(ue);
    },
    /**
     * Get the byte length of an encoded number type. Since `int` and `uint` are
     * simple types, this will always return 32.
     *
     * @returns The byte length of the type.
     */
    getByteLength() {
      return 32;
    },
    /**
     * Encode a number value.
     *
     * @param args - The arguments to encode.
     * @param args.type - The type of the value.
     * @param args.buffer - The byte array to add to.
     * @param args.value - The value to encode.
     * @param args.packed - Whether to use packed encoding.
     * @returns The bytes with the encoded value added to it.
     */
    encode({ type: ue, buffer: le, value: he, packed: me }) {
      const ye = (0, Y.getBigInt)(he);
      if ((0, Y.assertNumberLength)(ye, ue), (0, Y.isSigned)(ue)) {
        if (me) {
          const we = (0, Y.getLength)(ue) / 8;
          return (0, X.concatBytes)([le, (0, X.signedBigIntToBytes)(ye, we)]);
        }
        return (0, X.concatBytes)([
          le,
          (0, te.padStart)((0, X.signedBigIntToBytes)(ye, 32))
        ]);
      }
      if (me) {
        const we = (0, Y.getLength)(ue) / 8;
        return (0, X.concatBytes)([
          le,
          (0, te.padStart)((0, X.bigIntToBytes)(ye), we)
        ]);
      }
      return (0, X.concatBytes)([le, (0, te.padStart)((0, X.bigIntToBytes)(ye))]);
    },
    /**
     * Decode a number value.
     *
     * @param args - The decoding arguments.
     * @param args.type - The type of the value.
     * @param args.value - The value to decode.
     * @returns The decoded value.
     */
    decode({ type: ue, value: le }) {
      const he = le.subarray(0, 32);
      if ((0, Y.isSigned)(ue)) {
        const ye = (0, X.bytesToSignedBigInt)(he);
        return (0, Y.assertNumberLength)(ye, ue), ye;
      }
      const me = (0, X.bytesToBigInt)(he);
      return (0, Y.assertNumberLength)(me, ue), me;
    }
  };
})(vy);
(function(Y) {
  Object.defineProperty(Y, "__esModule", { value: !0 }), Y.bool = Y.getBooleanValue = void 0;
  const X = pe, ee = ns, te = Ti, ne = vy, ie = (0, ee.coerce)((0, ee.boolean)(), (0, ee.union)([(0, ee.literal)("true"), (0, ee.literal)("false")]), (se) => se === "true"), oe = (se) => {
    try {
      return (0, ee.create)(se, ie) ? BigInt(1) : BigInt(0);
    } catch {
      throw new te.ParserError(`Invalid boolean value. Expected a boolean literal, or the string "true" or "false", but received "${se}".`);
    }
  };
  Y.getBooleanValue = oe, Y.bool = {
    isDynamic: !1,
    /**
     * Get if the given value is a valid boolean type. Since `bool` is a simple
     * type, this is just a check that the value is "bool".
     *
     * @param type - The type to check.
     * @returns Whether the type is a valid boolean type.
     */
    isType: (se) => se === "bool",
    /**
     * Get the byte length of an encoded boolean. Since `bool` is a simple
     * type, this always returns 32.
     *
     * Note that actual booleans are only 1 byte long, but the encoding of
     * the `bool` type is always 32 bytes long.
     *
     * @returns The byte length of an encoded boolean.
     */
    getByteLength() {
      return 32;
    },
    /**
     * Encode the given boolean to a byte array.
     *
     * @param args - The encoding arguments.
     * @param args.buffer - The byte array to add to.
     * @param args.value - The boolean to encode.
     * @param args.packed - Whether the value is packed.
     * @param args.tight - Whether to use non-standard tight encoding.
     * @returns The bytes with the encoded boolean added to it.
     */
    encode({ buffer: se, value: ae, packed: ue, tight: le }) {
      const he = (0, Y.getBooleanValue)(ae);
      return ue ? (0, X.concatBytes)([se, (0, X.bigIntToBytes)(he)]) : ne.number.encode({
        type: "uint256",
        buffer: se,
        value: he,
        packed: ue,
        tight: le
      });
    },
    /**
     * Decode the given byte array to a boolean.
     *
     * @param args - The decoding arguments.
     * @returns The decoded boolean.
     */
    decode(se) {
      return ne.number.decode({ ...se, type: "uint256" }) === BigInt(1);
    }
  };
})(rA);
var Ef = {};
Object.defineProperty(Ef, "__esModule", { value: !0 });
Ef.bytes = void 0;
const Yc = pe, Nw = yo;
Ef.bytes = {
  isDynamic: !0,
  /**
   * Check if a type is a bytes type. Since `bytes` is a simple type, this is
   * just a check that the type is "bytes".
   *
   * @param type - The type to check.
   * @returns Whether the type is a bytes type.
   */
  isType: (Y) => Y === "bytes",
  /**
   * Get the byte length of an encoded bytes value. Since `bytes` is a simple
   * type, this always returns 32.
   *
   * Note that actual length of a bytes value is variable, but the encoded
   * static value (pointer) is always 32 bytes long.
   *
   * @returns The byte length of an encoded bytes value.
   */
  getByteLength() {
    return 32;
  },
  /**
   * Encode the given bytes value to a byte array.
   *
   * @param args - The encoding arguments.
   * @param args.buffer - The byte array to add to.
   * @param args.value - The bytes value to encode.
   * @param args.packed - Whether to use packed encoding.
   * @returns The bytes with the encoded bytes value added to it.
   */
  encode({ buffer: Y, value: X, packed: ee }) {
    const te = (0, Yc.createBytes)(X);
    if (ee)
      return (0, Yc.concatBytes)([Y, te]);
    const ne = Math.ceil(te.byteLength / 32) * 32;
    return (0, Yc.concatBytes)([
      Y,
      (0, Nw.padStart)((0, Yc.numberToBytes)(te.byteLength)),
      (0, Nw.padEnd)(te, ne)
    ]);
  },
  /**
   * Decode the given byte array to a bytes value.
   *
   * @param args - The decoding arguments.
   * @param args.value - The byte array to decode.
   * @returns The decoded bytes value as a `Uint8Array`.
   */
  decode({ value: Y }) {
    const X = Y.subarray(0, 32), ee = (0, Yc.bytesToNumber)(X);
    return Y.slice(32, 32 + ee);
  }
};
var nA = {};
(function(Y) {
  Object.defineProperty(Y, "__esModule", { value: !0 }), Y.fn = Y.getFunction = void 0;
  const X = pe, ee = ns, te = Ti, ne = u0, ie = (0, ee.coerce)((0, ee.object)({
    address: X.StrictHexStruct,
    selector: X.StrictHexStruct
  }), (0, ee.union)([X.StrictHexStruct, (0, ee.instance)(Uint8Array)]), (se) => {
    const ae = (0, X.createBytes)(se);
    return (0, X.assert)(ae.length === 24, new te.ParserError(`Invalid Solidity function. Expected function to be 24 bytes long, but received ${ae.length} bytes.`)), {
      address: (0, X.bytesToHex)(ae.subarray(0, 20)),
      selector: (0, X.bytesToHex)(ae.subarray(20, 24))
    };
  }), oe = (se) => {
    const ae = (0, ee.create)(se, ie);
    return (0, X.concatBytes)([(0, X.hexToBytes)(ae.address), (0, X.hexToBytes)(ae.selector)]);
  };
  Y.getFunction = oe, Y.fn = {
    isDynamic: !1,
    /**
     * Check if a type is a function type. Since `function` is a simple type, this
     * is just a check that the type is "function".
     *
     * @param type - The type to check.
     * @returns Whether the type is a function type.
     */
    isType: (se) => se === "function",
    /**
     * Get the byte length of an encoded function. Since `function` is a simple
     * type, this always returns 32.
     *
     * Note that actual functions are only 24 bytes long, but the encoding of
     * the `function` type is always 32 bytes long.
     *
     * @returns The byte length of an encoded function.
     */
    getByteLength() {
      return 32;
    },
    /**
     * Encode the given function to a byte array.
     *
     * @param args - The encoding arguments.
     * @param args.buffer - The byte array to add to.
     * @param args.value - The function to encode.
     * @param args.packed - Whether to use packed encoding.
     * @param args.tight - Whether to use non-standard tight encoding.
     * @returns The bytes with the encoded function added to it.
     */
    encode({ buffer: se, value: ae, packed: ue, tight: le }) {
      const he = (0, Y.getFunction)(ae);
      return ne.fixedBytes.encode({
        type: "bytes24",
        buffer: se,
        value: he,
        packed: ue,
        tight: le
      });
    },
    /**
     * Decode the given byte array to a function.
     *
     * @param args - The decoding arguments.
     * @param args.value - The byte array to decode.
     * @returns The decoded function as a {@link SolidityFunction} object.
     */
    decode({ value: se }) {
      return {
        address: (0, X.bytesToHex)(se.slice(0, 20)),
        selector: (0, X.bytesToHex)(se.slice(20, 24))
      };
    }
  };
})(nA);
var iA = {};
Object.defineProperty(iA, "__esModule", { value: !0 });
var f0 = {};
Object.defineProperty(f0, "__esModule", { value: !0 });
f0.string = void 0;
const kw = pe, Mw = Ef;
f0.string = {
  isDynamic: !0,
  /**
   * Check if a type is a string type. Since `string` is a simple type, this
   * is just a check if the type is "string".
   *
   * @param type - The type to check.
   * @returns Whether the type is a string type.
   */
  isType: (Y) => Y === "string",
  /**
   * Get the byte length of an encoded string type. Since `string` is a simple
   * type, this will always return 32.
   *
   * Note that actual strings are variable in length, but the encoded static
   * value (pointer) is always 32 bytes long.
   *
   * @returns The byte length of an encoded string.
   */
  getByteLength() {
    return 32;
  },
  /**
   * Encode the given string value to a byte array.
   *
   * @param args - The encoding arguments.
   * @param args.buffer - The byte array to add to.
   * @param args.value - The string value to encode.
   * @param args.packed - Whether to use packed encoding.
   * @param args.tight - Whether to use non-standard tight encoding.
   * @returns The bytes with the encoded string value added to it.
   */
  encode({ buffer: Y, value: X, packed: ee, tight: te }) {
    return Mw.bytes.encode({
      type: "bytes",
      buffer: Y,
      value: (0, kw.stringToBytes)(X),
      packed: ee,
      tight: te
    });
  },
  /**
   * Decode the given byte array to a string value.
   *
   * @param args - The decoding arguments.
   * @returns The decoded string value.
   */
  decode(Y) {
    return (0, kw.bytesToString)(Mw.bytes.decode(Y));
  }
};
var Lw;
function sA() {
  return Lw || (Lw = 1, function(Y) {
    var X = St && St.__createBinding || (Object.create ? function(te, ne, ie, oe) {
      oe === void 0 && (oe = ie);
      var se = Object.getOwnPropertyDescriptor(ne, ie);
      (!se || ("get" in se ? !ne.__esModule : se.writable || se.configurable)) && (se = { enumerable: !0, get: function() {
        return ne[ie];
      } }), Object.defineProperty(te, oe, se);
    } : function(te, ne, ie, oe) {
      oe === void 0 && (oe = ie), te[oe] = ne[ie];
    }), ee = St && St.__exportStar || function(te, ne) {
      for (var ie in te)
        ie !== "default" && !Object.prototype.hasOwnProperty.call(ne, ie) && X(ne, te, ie);
    };
    Object.defineProperty(Y, "__esModule", { value: !0 }), ee(Q3, Y), ee($F(), Y), ee(rA, Y), ee(Ef, Y), ee(u0, Y), ee(nA, Y), ee(vy, Y), ee(iA, Y), ee(f0, Y), ee(tA(), Y);
  }(dp)), dp;
}
var Fw;
function Ey() {
  return Fw || (Fw = 1, function(Y) {
    Object.defineProperty(Y, "__esModule", { value: !0 }), Y.unpack = Y.pack = Y.isDynamicParser = Y.getParser = void 0;
    const X = pe, ee = Ti, te = c0, ne = sA(), ie = yo, oe = (le) => {
      const he = {
        address: ne.address,
        array: ne.array,
        bool: ne.bool,
        bytes: ne.bytes,
        fixedBytes: ne.fixedBytes,
        function: ne.fn,
        number: ne.number,
        string: ne.string,
        tuple: ne.tuple
      }, me = he[le];
      if (me)
        return me;
      const ye = Object.values(he).find((we) => we.isType(le));
      if (ye)
        return ye;
      throw new ee.ParserError(`The type "${le}" is not supported.`);
    };
    Y.getParser = oe;
    const se = (le, he) => {
      const { isDynamic: me } = le;
      return typeof me == "function" ? me(he) : me;
    };
    Y.isDynamicParser = se;
    const ae = ({ types: le, values: he, packed: me = !1, tight: ye = !1, arrayPacked: we = !1, byteArray: Ee = new Uint8Array() }) => {
      (0, X.assert)(le.length === he.length, new ee.ParserError(`The number of types (${le.length}) does not match the number of values (${he.length}).`));
      const { staticBuffer: Re, dynamicBuffer: Ue, pointers: Me } = le.reduce(
        // eslint-disable-next-line @typescript-eslint/no-shadow
        ({ staticBuffer: Ke, dynamicBuffer: tt, pointers: rt }, it, _t) => {
          const Dt = (0, Y.getParser)(it), je = he[_t];
          if (me || we || !(0, Y.isDynamicParser)(Dt, it))
            return {
              staticBuffer: Dt.encode({
                buffer: Ke,
                value: je,
                type: it,
                packed: me,
                tight: ye
              }),
              dynamicBuffer: tt,
              pointers: rt
            };
          const ze = (0, X.concatBytes)([Ke, new Uint8Array(32)]), fe = Dt.encode({
            buffer: tt,
            value: je,
            type: it,
            packed: me,
            tight: ye
          });
          return {
            staticBuffer: ze,
            dynamicBuffer: fe,
            pointers: [
              ...rt,
              { position: Ke.length, pointer: tt.length }
            ]
          };
        },
        {
          staticBuffer: new Uint8Array(),
          dynamicBuffer: new Uint8Array(),
          pointers: []
        }
      );
      (0, X.assert)(!me && !we || Ue.length === 0, new ee.ParserError("Invalid pack state."));
      const De = Re.length, Fe = Me.reduce((Ke, { pointer: tt, position: rt }) => {
        const it = (0, ie.padStart)((0, X.numberToBytes)(De + tt));
        return (0, ie.set)(Ke, it, rt);
      }, Re);
      return (0, X.concatBytes)([Ee, Fe, Ue]);
    };
    Y.pack = ae;
    const ue = (le, he) => {
      const me = (0, te.iterate)(he);
      return le.map((ye) => {
        const { value: { value: we, skip: Ee }, done: Re } = me.next();
        (0, X.assert)(!Re, new ee.ParserError(`The encoded value is invalid for the provided types. Reached end of buffer while attempting to parse "${ye}".`));
        const Ue = (0, Y.getParser)(ye);
        if ((0, Y.isDynamicParser)(Ue, ye)) {
          const Me = (0, X.bytesToNumber)(we.subarray(0, 32)), De = he.subarray(Me);
          return Ue.decode({ type: ye, value: De, skip: Ee });
        }
        return Ue.decode({ type: ye, value: we, skip: Ee });
      });
    };
    Y.unpack = ue;
  }(lp)), lp;
}
(function(Y) {
  Object.defineProperty(Y, "__esModule", { value: !0 }), Y.decodeSingle = Y.decode = Y.encodePacked = Y.encodeSingle = Y.encode = void 0;
  const X = pe, ee = Ti, te = Ey(), ne = (ue, le, he, me) => {
    try {
      return (0, te.pack)({ types: ue, values: le, packed: he, tight: me });
    } catch (ye) {
      throw ye instanceof ee.ParserError ? new ee.ParserError(`Unable to encode value: ${ye.message}`, ye) : new ee.ParserError(`An unexpected error occurred: ${(0, ee.getErrorMessage)(ye)}`, ye);
    }
  };
  Y.encode = ne;
  const ie = (ue, le) => (0, Y.encode)([ue], [le]);
  Y.encodeSingle = ie;
  const oe = (ue, le, he) => (0, Y.encode)(ue, le, !0, he);
  Y.encodePacked = oe;
  const se = (ue, le) => {
    const he = (0, X.createBytes)(le);
    try {
      return (0, te.unpack)(ue, he);
    } catch (me) {
      throw me instanceof ee.ParserError ? new ee.ParserError(`Unable to decode value: ${me.message}`, me) : new ee.ParserError(`An unexpected error occurred: ${(0, ee.getErrorMessage)(me)}`, me);
    }
  };
  Y.decode = se;
  const ae = (ue, le) => {
    const he = (0, Y.decode)([ue], le);
    return (0, X.assert)(he.length === 1, new ee.ParserError("Decoded value array has unexpected length.")), he[0];
  };
  Y.decodeSingle = ae;
})(Z3);
var oA = {}, aA = {};
Object.defineProperty(aA, "__esModule", { value: !0 });
(function(Y) {
  var X = St && St.__createBinding || (Object.create ? function(te, ne, ie, oe) {
    oe === void 0 && (oe = ie);
    var se = Object.getOwnPropertyDescriptor(ne, ie);
    (!se || ("get" in se ? !ne.__esModule : se.writable || se.configurable)) && (se = { enumerable: !0, get: function() {
      return ne[ie];
    } }), Object.defineProperty(te, oe, se);
  } : function(te, ne, ie, oe) {
    oe === void 0 && (oe = ie), te[oe] = ne[ie];
  }), ee = St && St.__exportStar || function(te, ne) {
    for (var ie in te)
      ie !== "default" && !Object.prototype.hasOwnProperty.call(ne, ie) && X(ne, te, ie);
  };
  Object.defineProperty(Y, "__esModule", { value: !0 }), ee(aA, Y);
})(oA);
(function(Y) {
  var X = St && St.__createBinding || (Object.create ? function(te, ne, ie, oe) {
    oe === void 0 && (oe = ie);
    var se = Object.getOwnPropertyDescriptor(ne, ie);
    (!se || ("get" in se ? !ne.__esModule : se.writable || se.configurable)) && (se = { enumerable: !0, get: function() {
      return ne[ie];
    } }), Object.defineProperty(te, oe, se);
  } : function(te, ne, ie, oe) {
    oe === void 0 && (oe = ie), te[oe] = ne[ie];
  }), ee = St && St.__exportStar || function(te, ne) {
    for (var ie in te)
      ie !== "default" && !Object.prototype.hasOwnProperty.call(ne, ie) && X(ne, te, ie);
  };
  Object.defineProperty(Y, "__esModule", { value: !0 }), ee(Z3, Y), ee(Ti, Y), ee(oA, Y);
})(X3);
(function(Y) {
  Object.defineProperty(Y, "__esModule", { value: !0 }), Y.recoverTypedSignature = Y.signTypedData = Y.typedSignatureHash = Y.TypedDataUtils = Y.TYPED_MESSAGE_SCHEMA = Y.SignTypedDataVersion = void 0;
  const X = Od, ee = X3, te = sA(), ne = yo, ie = pe, oe = Zn, se = tn;
  var ae;
  (function(ze) {
    ze.V1 = "V1", ze.V3 = "V3", ze.V4 = "V4";
  })(ae = Y.SignTypedDataVersion || (Y.SignTypedDataVersion = {})), Y.TYPED_MESSAGE_SCHEMA = {
    type: "object",
    properties: {
      types: {
        type: "object",
        additionalProperties: {
          type: "array",
          items: {
            type: "object",
            properties: {
              name: { type: "string" },
              type: { type: "string" }
            },
            required: ["name", "type"]
          }
        }
      },
      primaryType: { type: "string" },
      domain: { type: "object" },
      message: { type: "object" }
    },
    required: ["types", "primaryType", "domain", "message"]
  };
  function ue(ze, fe) {
    if (Object.keys(ae).includes(ze)) {
      if (fe && !fe.includes(ze))
        throw new Error(`SignTypedDataVersion not allowed: '${ze}'. Allowed versions are: ${fe.join(", ")}`);
    } else
      throw new Error(`Invalid version: '${ze}'`);
  }
  function le(ze, fe) {
    (0, ie.assert)(fe !== null, `Unable to encode value: Invalid number. Expected a valid number value, but received "${fe}".`);
    const de = BigInt(fe), be = (0, te.getLength)(ze), Te = BigInt(2) ** BigInt(be) - BigInt(1);
    return (0, ie.assert)(de >= -Te && de <= Te, `Unable to encode value: Number "${fe}" is out of range for type "${ze}".`), de;
  }
  function he(ze) {
    let fe = BigInt(0);
    for (let de = 0; de < ze.length; de++) {
      const be = BigInt(ze.charCodeAt(de) - 48);
      fe *= BigInt(10), be >= 49 ? fe += be - BigInt(49) + BigInt(10) : be >= 17 ? fe += be - BigInt(17) + BigInt(10) : fe += be;
    }
    return (0, ne.padStart)((0, ie.bigIntToBytes)(fe), 20);
  }
  function me(ze, fe, de, be, Te) {
    if (ue(Te, [ae.V3, ae.V4]), ze[de] !== void 0)
      return [
        "bytes32",
        // TODO: return Buffer, remove string from return type
        Te === ae.V4 && be == null ? "0x0000000000000000000000000000000000000000000000000000000000000000" : (0, X.arrToBufArr)((0, oe.keccak256)(ye(de, be, ze, Te)))
      ];
    if (de === "function")
      throw new Error('Unsupported or invalid type: "function"');
    if (be === void 0)
      throw new Error(`missing value for field ${fe} of type ${de}`);
    if (de === "address") {
      if (typeof be == "number")
        return ["address", (0, ne.padStart)((0, ie.numberToBytes)(be), 20)];
      if ((0, ie.isStrictHexString)(be))
        return ["address", (0, ie.add0x)(be)];
      if (typeof be == "string")
        return ["address", he(be).subarray(0, 20)];
    }
    if (de === "bool")
      return ["bool", !!be];
    if (de === "bytes")
      return typeof be == "number" ? be = (0, ie.numberToBytes)(be) : (0, ie.isStrictHexString)(be) || be === "0x" ? be = (0, ie.hexToBytes)(be) : typeof be == "string" && (be = (0, ie.stringToBytes)(be)), ["bytes32", (0, X.arrToBufArr)((0, oe.keccak256)(be))];
    if (de.startsWith("bytes") && de !== "bytes" && !de.includes("["))
      return typeof be == "number" ? be < 0 ? ["bytes32", new Uint8Array(32)] : ["bytes32", (0, ie.bigIntToBytes)(BigInt(be))] : (0, ie.isStrictHexString)(be) ? ["bytes32", (0, ie.hexToBytes)(be)] : ["bytes32", be];
    if (de.startsWith("int") && !de.includes("[")) {
      const Ce = le(de, be);
      return Ce >= BigInt(0) ? ["uint256", Ce] : ["int256", Ce];
    }
    if (de === "string")
      return typeof be == "number" ? be = (0, ie.numberToBytes)(be) : be = (0, ie.stringToBytes)(be ?? ""), ["bytes32", (0, X.arrToBufArr)((0, oe.keccak256)(be))];
    if (de.endsWith("]")) {
      if (Te === ae.V3)
        throw new Error("Arrays are unimplemented in encodeData; use V4 extension");
      const Ce = de.slice(0, de.lastIndexOf("[")), Pe = be.map((Se) => me(ze, fe, Ce, Se, Te));
      return [
        "bytes32",
        (0, X.arrToBufArr)((0, oe.keccak256)((0, ee.encode)(Pe.map(([Se]) => Se), Pe.map(([, Se]) => Se))))
      ];
    }
    return [de, be];
  }
  function ye(ze, fe, de, be) {
    ue(be, [ae.V3, ae.V4]);
    const Te = ["bytes32"], Ce = [
      Ue(ze, de)
    ];
    for (const Pe of de[ze]) {
      if (be === ae.V3 && fe[Pe.name] === void 0)
        continue;
      const [Se, ke] = me(de, Pe.name, Pe.type, fe[Pe.name], be);
      Te.push(Se), Ce.push(ke);
    }
    return (0, X.arrToBufArr)((0, ee.encode)(Te, Ce));
  }
  function we(ze, fe) {
    let de = "";
    const be = Ee(ze, fe);
    be.delete(ze);
    const Te = [ze, ...Array.from(be).sort()];
    for (const Ce of Te) {
      if (!fe[Ce])
        throw new Error(`No type definition specified: ${Ce}`);
      de += `${Ce}(${fe[Ce].map(({ name: Pe, type: Se }) => `${Se} ${Pe}`).join(",")})`;
    }
    return de;
  }
  function Ee(ze, fe, de = /* @__PURE__ */ new Set()) {
    if (typeof ze != "string")
      throw new Error(`Invalid findTypeDependencies input ${JSON.stringify(ze)}`);
    if ([ze] = ze.match(/^\w*/u), de.has(ze) || fe[ze] === void 0)
      return de;
    de.add(ze);
    for (const be of fe[ze])
      Ee(be.type, fe, de);
    return de;
  }
  function Re(ze, fe, de, be) {
    ue(be, [ae.V3, ae.V4]);
    const Te = ye(ze, fe, de, be), Ce = (0, oe.keccak256)(Te);
    return (0, X.arrToBufArr)(Ce);
  }
  function Ue(ze, fe) {
    const de = (0, ie.stringToBytes)(we(ze, fe));
    return (0, X.arrToBufArr)((0, oe.keccak256)(de));
  }
  function Me(ze) {
    const fe = {};
    for (const de in Y.TYPED_MESSAGE_SCHEMA.properties)
      ze[de] && (fe[de] = ze[de]);
    return "types" in fe && (fe.types = Object.assign({ EIP712Domain: [] }, fe.types)), fe;
  }
  function De(ze, fe) {
    ue(fe, [ae.V3, ae.V4]);
    const de = Me(ze), { domain: be } = de, Te = { EIP712Domain: de.types.EIP712Domain };
    return Re("EIP712Domain", be, Te, fe);
  }
  function Fe(ze, fe) {
    ue(fe, [ae.V3, ae.V4]);
    const de = Me(ze), be = [(0, ie.hexToBytes)("1901")];
    return be.push(De(ze, fe)), de.primaryType !== "EIP712Domain" && be.push(Re(
      // TODO: Validate that this is a string, so this type cast can be removed.
      de.primaryType,
      de.message,
      de.types,
      fe
    )), (0, X.arrToBufArr)((0, oe.keccak256)((0, ie.concatBytes)(be)));
  }
  Y.TypedDataUtils = {
    encodeData: ye,
    encodeType: we,
    findTypeDependencies: Ee,
    hashStruct: Re,
    hashType: Ue,
    sanitizeData: Me,
    eip712Hash: Fe,
    eip712DomainHash: De
  };
  function Ke(ze) {
    const fe = _t(ze);
    return (0, ie.bytesToHex)(fe);
  }
  Y.typedSignatureHash = Ke;
  function tt(ze, fe) {
    if ((0, te.isArrayType)(ze) && Array.isArray(fe)) {
      const [de] = (0, te.getArrayType)(ze);
      return fe.map((be) => tt(de, be));
    }
    if (ze === "address") {
      if (typeof fe == "number")
        return (0, ne.padStart)((0, ie.numberToBytes)(fe), 20);
      if ((0, ie.isStrictHexString)(fe))
        return (0, ne.padStart)((0, ie.hexToBytes)(fe).subarray(0, 20), 20);
      if (fe instanceof Uint8Array)
        return (0, ne.padStart)(fe.subarray(0, 20), 20);
    }
    if (ze === "bool")
      return !!fe;
    if (ze.startsWith("bytes") && ze !== "bytes") {
      const de = (0, te.getByteLength)(ze);
      if (typeof fe == "number")
        return fe < 0 ? new Uint8Array() : (0, ie.numberToBytes)(fe).subarray(0, de);
      if ((0, ie.isStrictHexString)(fe))
        return (0, ie.hexToBytes)(fe).subarray(0, de);
      if (fe instanceof Uint8Array)
        return fe.subarray(0, de);
    }
    if (ze.startsWith("uint") && typeof fe == "number")
      return Math.abs(fe);
    if (ze.startsWith("int") && typeof fe == "number") {
      const de = (0, te.getLength)(ze);
      return BigInt.asIntN(de, BigInt(fe));
    }
    return fe;
  }
  function rt(ze) {
    return ze.map((fe) => typeof fe == "number" ? (0, ne.padStart)((0, ie.numberToBytes)(fe), 32) : (0, ie.isStrictHexString)(fe) ? (0, ne.padStart)((0, ie.hexToBytes)(fe).subarray(0, 32), 32) : fe instanceof Uint8Array ? (0, ne.padStart)(fe.subarray(0, 32), 32) : fe);
  }
  function it(ze, fe) {
    return fe.map((de) => {
      if (typeof de == "string" || typeof de == "number" || typeof de == "bigint") {
        const be = le(ze, de);
        if (be >= BigInt(0))
          return (0, ne.padStart)((0, ie.bigIntToBytes)(be), 32);
        const Te = (0, te.getLength)(ze), Ce = BigInt.asIntN(Te, be);
        return (0, ie.signedBigIntToBytes)(Ce, 32);
      }
      return de;
    });
  }
  function _t(ze) {
    const fe = new Error("Expect argument to be non-empty array");
    if (typeof ze != "object" || !("length" in ze) || !ze.length)
      throw fe;
    const de = ze.map(({ name: Pe, type: Se, value: ke }) => {
      if (Se === "address[]")
        return {
          name: Pe,
          type: "bytes32[]",
          value: rt(ke)
        };
      if (Se.startsWith("int") && (0, te.isArrayType)(Se)) {
        const [ge, Ae] = (0, te.getArrayType)(Se);
        return {
          name: Pe,
          type: `bytes32[${Ae ?? ""}]`,
          value: it(ge, ke)
        };
      }
      return {
        name: Pe,
        type: Se,
        value: tt(Se, ke)
      };
    }), be = de.map((Pe) => Pe.type !== "bytes" ? Pe.value : (0, se.legacyToBuffer)(Pe.value)), Te = de.map((Pe) => {
      if (Pe.type === "function")
        throw new Error('Unsupported or invalid type: "function"');
      return Pe.type;
    }), Ce = ze.map((Pe) => {
      if (!Pe.name)
        throw fe;
      return `${Pe.type} ${Pe.name}`;
    });
    return (0, X.arrToBufArr)((0, oe.keccak256)((0, ee.encodePacked)(["bytes32", "bytes32"], [
      (0, oe.keccak256)((0, ee.encodePacked)(["string[]"], [Ce], !0)),
      (0, oe.keccak256)((0, ee.encodePacked)(Te, be, !0))
    ])));
  }
  function Dt({ privateKey: ze, data: fe, version: de }) {
    if (ue(de), (0, se.isNullish)(fe))
      throw new Error("Missing data parameter");
    if ((0, se.isNullish)(ze))
      throw new Error("Missing private key parameter");
    const be = de === ae.V1 ? _t(fe) : Y.TypedDataUtils.eip712Hash(fe, de), Te = (0, X.ecsign)(be, ze);
    return (0, se.concatSig)((0, X.arrToBufArr)((0, ie.bigIntToBytes)(Te.v)), Te.r, Te.s);
  }
  Y.signTypedData = Dt;
  function je({ data: ze, signature: fe, version: de }) {
    if (ue(de), (0, se.isNullish)(ze))
      throw new Error("Missing data parameter");
    if ((0, se.isNullish)(fe))
      throw new Error("Missing signature parameter");
    const be = de === ae.V1 ? _t(ze) : Y.TypedDataUtils.eip712Hash(ze, de), Te = (0, se.recoverPublicKey)(be, fe), Ce = (0, X.publicToAddress)(Te);
    return (0, ie.bytesToHex)(Ce);
  }
  Y.recoverTypedSignature = je;
})(Y3);
var Xn = {}, cA = { exports: {} };
(function(Y) {
  (function(X) {
    var ee = function(qe) {
      var Qe, Ve = new Float64Array(16);
      if (qe)
        for (Qe = 0; Qe < qe.length; Qe++)
          Ve[Qe] = qe[Qe];
      return Ve;
    }, te = function() {
      throw new Error("no PRNG");
    }, ne = new Uint8Array(16), ie = new Uint8Array(32);
    ie[0] = 9;
    var oe = ee(), se = ee([1]), ae = ee([56129, 1]), ue = ee([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), le = ee([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]), he = ee([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]), me = ee([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]), ye = ee([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
    function we(qe, Qe, Ve, Ie) {
      qe[Qe] = Ve >> 24 & 255, qe[Qe + 1] = Ve >> 16 & 255, qe[Qe + 2] = Ve >> 8 & 255, qe[Qe + 3] = Ve & 255, qe[Qe + 4] = Ie >> 24 & 255, qe[Qe + 5] = Ie >> 16 & 255, qe[Qe + 6] = Ie >> 8 & 255, qe[Qe + 7] = Ie & 255;
    }
    function Ee(qe, Qe, Ve, Ie, nt) {
      var Et, xt = 0;
      for (Et = 0; Et < nt; Et++)
        xt |= qe[Qe + Et] ^ Ve[Ie + Et];
      return (1 & xt - 1 >>> 8) - 1;
    }
    function Re(qe, Qe, Ve, Ie) {
      return Ee(qe, Qe, Ve, Ie, 16);
    }
    function Ue(qe, Qe, Ve, Ie) {
      return Ee(qe, Qe, Ve, Ie, 32);
    }
    function Me(qe, Qe, Ve, Ie) {
      for (var nt = Ie[0] & 255 | (Ie[1] & 255) << 8 | (Ie[2] & 255) << 16 | (Ie[3] & 255) << 24, Et = Ve[0] & 255 | (Ve[1] & 255) << 8 | (Ve[2] & 255) << 16 | (Ve[3] & 255) << 24, xt = Ve[4] & 255 | (Ve[5] & 255) << 8 | (Ve[6] & 255) << 16 | (Ve[7] & 255) << 24, Jt = Ve[8] & 255 | (Ve[9] & 255) << 8 | (Ve[10] & 255) << 16 | (Ve[11] & 255) << 24, Yt = Ve[12] & 255 | (Ve[13] & 255) << 8 | (Ve[14] & 255) << 16 | (Ve[15] & 255) << 24, _r = Ie[4] & 255 | (Ie[5] & 255) << 8 | (Ie[6] & 255) << 16 | (Ie[7] & 255) << 24, cn = Qe[0] & 255 | (Qe[1] & 255) << 8 | (Qe[2] & 255) << 16 | (Qe[3] & 255) << 24, _X = Qe[4] & 255 | (Qe[5] & 255) << 8 | (Qe[6] & 255) << 16 | (Qe[7] & 255) << 24, un = Qe[8] & 255 | (Qe[9] & 255) << 8 | (Qe[10] & 255) << 16 | (Qe[11] & 255) << 24, aX = Qe[12] & 255 | (Qe[13] & 255) << 8 | (Qe[14] & 255) << 16 | (Qe[15] & 255) << 24, uX = Ie[8] & 255 | (Ie[9] & 255) << 8 | (Ie[10] & 255) << 16 | (Ie[11] & 255) << 24, fX = Ve[16] & 255 | (Ve[17] & 255) << 8 | (Ve[18] & 255) << 16 | (Ve[19] & 255) << 24, bX = Ve[20] & 255 | (Ve[21] & 255) << 8 | (Ve[22] & 255) << 16 | (Ve[23] & 255) << 24, dX = Ve[24] & 255 | (Ve[25] & 255) << 8 | (Ve[26] & 255) << 16 | (Ve[27] & 255) << 24, mX = Ve[28] & 255 | (Ve[29] & 255) << 8 | (Ve[30] & 255) << 16 | (Ve[31] & 255) << 24, pX = Ie[12] & 255 | (Ie[13] & 255) << 8 | (Ie[14] & 255) << 16 | (Ie[15] & 255) << 24, G_ = nt, iX = Et, og = xt, eX = Jt, tX = Yt, An = _r, Gt = cn, Wt = _X, vr = un, Qt = aX, rr = uX, Ir = fX, gX = bX, TX = dX, IX = mX, RX = pX, wt, CX = 0; CX < 20; CX += 2)
        wt = G_ + gX | 0, tX ^= wt << 7 | wt >>> 25, wt = tX + G_ | 0, vr ^= wt << 9 | wt >>> 23, wt = vr + tX | 0, gX ^= wt << 13 | wt >>> 19, wt = gX + vr | 0, G_ ^= wt << 18 | wt >>> 14, wt = An + iX | 0, Qt ^= wt << 7 | wt >>> 25, wt = Qt + An | 0, TX ^= wt << 9 | wt >>> 23, wt = TX + Qt | 0, iX ^= wt << 13 | wt >>> 19, wt = iX + TX | 0, An ^= wt << 18 | wt >>> 14, wt = rr + Gt | 0, IX ^= wt << 7 | wt >>> 25, wt = IX + rr | 0, og ^= wt << 9 | wt >>> 23, wt = og + IX | 0, Gt ^= wt << 13 | wt >>> 19, wt = Gt + og | 0, rr ^= wt << 18 | wt >>> 14, wt = RX + Ir | 0, eX ^= wt << 7 | wt >>> 25, wt = eX + RX | 0, Wt ^= wt << 9 | wt >>> 23, wt = Wt + eX | 0, Ir ^= wt << 13 | wt >>> 19, wt = Ir + Wt | 0, RX ^= wt << 18 | wt >>> 14, wt = G_ + eX | 0, iX ^= wt << 7 | wt >>> 25, wt = iX + G_ | 0, og ^= wt << 9 | wt >>> 23, wt = og + iX | 0, eX ^= wt << 13 | wt >>> 19, wt = eX + og | 0, G_ ^= wt << 18 | wt >>> 14, wt = An + tX | 0, Gt ^= wt << 7 | wt >>> 25, wt = Gt + An | 0, Wt ^= wt << 9 | wt >>> 23, wt = Wt + Gt | 0, tX ^= wt << 13 | wt >>> 19, wt = tX + Wt | 0, An ^= wt << 18 | wt >>> 14, wt = rr + Qt | 0, Ir ^= wt << 7 | wt >>> 25, wt = Ir + rr | 0, vr ^= wt << 9 | wt >>> 23, wt = vr + Ir | 0, Qt ^= wt << 13 | wt >>> 19, wt = Qt + vr | 0, rr ^= wt << 18 | wt >>> 14, wt = RX + IX | 0, gX ^= wt << 7 | wt >>> 25, wt = gX + RX | 0, TX ^= wt << 9 | wt >>> 23, wt = TX + gX | 0, IX ^= wt << 13 | wt >>> 19, wt = IX + TX | 0, RX ^= wt << 18 | wt >>> 14;
      G_ = G_ + nt | 0, iX = iX + Et | 0, og = og + xt | 0, eX = eX + Jt | 0, tX = tX + Yt | 0, An = An + _r | 0, Gt = Gt + cn | 0, Wt = Wt + _X | 0, vr = vr + un | 0, Qt = Qt + aX | 0, rr = rr + uX | 0, Ir = Ir + fX | 0, gX = gX + bX | 0, TX = TX + dX | 0, IX = IX + mX | 0, RX = RX + pX | 0, qe[0] = G_ >>> 0 & 255, qe[1] = G_ >>> 8 & 255, qe[2] = G_ >>> 16 & 255, qe[3] = G_ >>> 24 & 255, qe[4] = iX >>> 0 & 255, qe[5] = iX >>> 8 & 255, qe[6] = iX >>> 16 & 255, qe[7] = iX >>> 24 & 255, qe[8] = og >>> 0 & 255, qe[9] = og >>> 8 & 255, qe[10] = og >>> 16 & 255, qe[11] = og >>> 24 & 255, qe[12] = eX >>> 0 & 255, qe[13] = eX >>> 8 & 255, qe[14] = eX >>> 16 & 255, qe[15] = eX >>> 24 & 255, qe[16] = tX >>> 0 & 255, qe[17] = tX >>> 8 & 255, qe[18] = tX >>> 16 & 255, qe[19] = tX >>> 24 & 255, qe[20] = An >>> 0 & 255, qe[21] = An >>> 8 & 255, qe[22] = An >>> 16 & 255, qe[23] = An >>> 24 & 255, qe[24] = Gt >>> 0 & 255, qe[25] = Gt >>> 8 & 255, qe[26] = Gt >>> 16 & 255, qe[27] = Gt >>> 24 & 255, qe[28] = Wt >>> 0 & 255, qe[29] = Wt >>> 8 & 255, qe[30] = Wt >>> 16 & 255, qe[31] = Wt >>> 24 & 255, qe[32] = vr >>> 0 & 255, qe[33] = vr >>> 8 & 255, qe[34] = vr >>> 16 & 255, qe[35] = vr >>> 24 & 255, qe[36] = Qt >>> 0 & 255, qe[37] = Qt >>> 8 & 255, qe[38] = Qt >>> 16 & 255, qe[39] = Qt >>> 24 & 255, qe[40] = rr >>> 0 & 255, qe[41] = rr >>> 8 & 255, qe[42] = rr >>> 16 & 255, qe[43] = rr >>> 24 & 255, qe[44] = Ir >>> 0 & 255, qe[45] = Ir >>> 8 & 255, qe[46] = Ir >>> 16 & 255, qe[47] = Ir >>> 24 & 255, qe[48] = gX >>> 0 & 255, qe[49] = gX >>> 8 & 255, qe[50] = gX >>> 16 & 255, qe[51] = gX >>> 24 & 255, qe[52] = TX >>> 0 & 255, qe[53] = TX >>> 8 & 255, qe[54] = TX >>> 16 & 255, qe[55] = TX >>> 24 & 255, qe[56] = IX >>> 0 & 255, qe[57] = IX >>> 8 & 255, qe[58] = IX >>> 16 & 255, qe[59] = IX >>> 24 & 255, qe[60] = RX >>> 0 & 255, qe[61] = RX >>> 8 & 255, qe[62] = RX >>> 16 & 255, qe[63] = RX >>> 24 & 255;
    }
    function De(qe, Qe, Ve, Ie) {
      for (var nt = Ie[0] & 255 | (Ie[1] & 255) << 8 | (Ie[2] & 255) << 16 | (Ie[3] & 255) << 24, Et = Ve[0] & 255 | (Ve[1] & 255) << 8 | (Ve[2] & 255) << 16 | (Ve[3] & 255) << 24, xt = Ve[4] & 255 | (Ve[5] & 255) << 8 | (Ve[6] & 255) << 16 | (Ve[7] & 255) << 24, Jt = Ve[8] & 255 | (Ve[9] & 255) << 8 | (Ve[10] & 255) << 16 | (Ve[11] & 255) << 24, Yt = Ve[12] & 255 | (Ve[13] & 255) << 8 | (Ve[14] & 255) << 16 | (Ve[15] & 255) << 24, _r = Ie[4] & 255 | (Ie[5] & 255) << 8 | (Ie[6] & 255) << 16 | (Ie[7] & 255) << 24, cn = Qe[0] & 255 | (Qe[1] & 255) << 8 | (Qe[2] & 255) << 16 | (Qe[3] & 255) << 24, _X = Qe[4] & 255 | (Qe[5] & 255) << 8 | (Qe[6] & 255) << 16 | (Qe[7] & 255) << 24, un = Qe[8] & 255 | (Qe[9] & 255) << 8 | (Qe[10] & 255) << 16 | (Qe[11] & 255) << 24, aX = Qe[12] & 255 | (Qe[13] & 255) << 8 | (Qe[14] & 255) << 16 | (Qe[15] & 255) << 24, uX = Ie[8] & 255 | (Ie[9] & 255) << 8 | (Ie[10] & 255) << 16 | (Ie[11] & 255) << 24, fX = Ve[16] & 255 | (Ve[17] & 255) << 8 | (Ve[18] & 255) << 16 | (Ve[19] & 255) << 24, bX = Ve[20] & 255 | (Ve[21] & 255) << 8 | (Ve[22] & 255) << 16 | (Ve[23] & 255) << 24, dX = Ve[24] & 255 | (Ve[25] & 255) << 8 | (Ve[26] & 255) << 16 | (Ve[27] & 255) << 24, mX = Ve[28] & 255 | (Ve[29] & 255) << 8 | (Ve[30] & 255) << 16 | (Ve[31] & 255) << 24, pX = Ie[12] & 255 | (Ie[13] & 255) << 8 | (Ie[14] & 255) << 16 | (Ie[15] & 255) << 24, G_ = nt, iX = Et, og = xt, eX = Jt, tX = Yt, An = _r, Gt = cn, Wt = _X, vr = un, Qt = aX, rr = uX, Ir = fX, gX = bX, TX = dX, IX = mX, RX = pX, wt, CX = 0; CX < 20; CX += 2)
        wt = G_ + gX | 0, tX ^= wt << 7 | wt >>> 25, wt = tX + G_ | 0, vr ^= wt << 9 | wt >>> 23, wt = vr + tX | 0, gX ^= wt << 13 | wt >>> 19, wt = gX + vr | 0, G_ ^= wt << 18 | wt >>> 14, wt = An + iX | 0, Qt ^= wt << 7 | wt >>> 25, wt = Qt + An | 0, TX ^= wt << 9 | wt >>> 23, wt = TX + Qt | 0, iX ^= wt << 13 | wt >>> 19, wt = iX + TX | 0, An ^= wt << 18 | wt >>> 14, wt = rr + Gt | 0, IX ^= wt << 7 | wt >>> 25, wt = IX + rr | 0, og ^= wt << 9 | wt >>> 23, wt = og + IX | 0, Gt ^= wt << 13 | wt >>> 19, wt = Gt + og | 0, rr ^= wt << 18 | wt >>> 14, wt = RX + Ir | 0, eX ^= wt << 7 | wt >>> 25, wt = eX + RX | 0, Wt ^= wt << 9 | wt >>> 23, wt = Wt + eX | 0, Ir ^= wt << 13 | wt >>> 19, wt = Ir + Wt | 0, RX ^= wt << 18 | wt >>> 14, wt = G_ + eX | 0, iX ^= wt << 7 | wt >>> 25, wt = iX + G_ | 0, og ^= wt << 9 | wt >>> 23, wt = og + iX | 0, eX ^= wt << 13 | wt >>> 19, wt = eX + og | 0, G_ ^= wt << 18 | wt >>> 14, wt = An + tX | 0, Gt ^= wt << 7 | wt >>> 25, wt = Gt + An | 0, Wt ^= wt << 9 | wt >>> 23, wt = Wt + Gt | 0, tX ^= wt << 13 | wt >>> 19, wt = tX + Wt | 0, An ^= wt << 18 | wt >>> 14, wt = rr + Qt | 0, Ir ^= wt << 7 | wt >>> 25, wt = Ir + rr | 0, vr ^= wt << 9 | wt >>> 23, wt = vr + Ir | 0, Qt ^= wt << 13 | wt >>> 19, wt = Qt + vr | 0, rr ^= wt << 18 | wt >>> 14, wt = RX + IX | 0, gX ^= wt << 7 | wt >>> 25, wt = gX + RX | 0, TX ^= wt << 9 | wt >>> 23, wt = TX + gX | 0, IX ^= wt << 13 | wt >>> 19, wt = IX + TX | 0, RX ^= wt << 18 | wt >>> 14;
      qe[0] = G_ >>> 0 & 255, qe[1] = G_ >>> 8 & 255, qe[2] = G_ >>> 16 & 255, qe[3] = G_ >>> 24 & 255, qe[4] = An >>> 0 & 255, qe[5] = An >>> 8 & 255, qe[6] = An >>> 16 & 255, qe[7] = An >>> 24 & 255, qe[8] = rr >>> 0 & 255, qe[9] = rr >>> 8 & 255, qe[10] = rr >>> 16 & 255, qe[11] = rr >>> 24 & 255, qe[12] = RX >>> 0 & 255, qe[13] = RX >>> 8 & 255, qe[14] = RX >>> 16 & 255, qe[15] = RX >>> 24 & 255, qe[16] = Gt >>> 0 & 255, qe[17] = Gt >>> 8 & 255, qe[18] = Gt >>> 16 & 255, qe[19] = Gt >>> 24 & 255, qe[20] = Wt >>> 0 & 255, qe[21] = Wt >>> 8 & 255, qe[22] = Wt >>> 16 & 255, qe[23] = Wt >>> 24 & 255, qe[24] = vr >>> 0 & 255, qe[25] = vr >>> 8 & 255, qe[26] = vr >>> 16 & 255, qe[27] = vr >>> 24 & 255, qe[28] = Qt >>> 0 & 255, qe[29] = Qt >>> 8 & 255, qe[30] = Qt >>> 16 & 255, qe[31] = Qt >>> 24 & 255;
    }
    function Fe(qe, Qe, Ve, Ie) {
      Me(qe, Qe, Ve, Ie);
    }
    function Ke(qe, Qe, Ve, Ie) {
      De(qe, Qe, Ve, Ie);
    }
    var tt = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
    function rt(qe, Qe, Ve, Ie, nt, Et, xt) {
      var Jt = new Uint8Array(16), Yt = new Uint8Array(64), _r, cn;
      for (cn = 0; cn < 16; cn++)
        Jt[cn] = 0;
      for (cn = 0; cn < 8; cn++)
        Jt[cn] = Et[cn];
      for (; nt >= 64; ) {
        for (Fe(Yt, Jt, xt, tt), cn = 0; cn < 64; cn++)
          qe[Qe + cn] = Ve[Ie + cn] ^ Yt[cn];
        for (_r = 1, cn = 8; cn < 16; cn++)
          _r = _r + (Jt[cn] & 255) | 0, Jt[cn] = _r & 255, _r >>>= 8;
        nt -= 64, Qe += 64, Ie += 64;
      }
      if (nt > 0)
        for (Fe(Yt, Jt, xt, tt), cn = 0; cn < nt; cn++)
          qe[Qe + cn] = Ve[Ie + cn] ^ Yt[cn];
      return 0;
    }
    function it(qe, Qe, Ve, Ie, nt) {
      var Et = new Uint8Array(16), xt = new Uint8Array(64), Jt, Yt;
      for (Yt = 0; Yt < 16; Yt++)
        Et[Yt] = 0;
      for (Yt = 0; Yt < 8; Yt++)
        Et[Yt] = Ie[Yt];
      for (; Ve >= 64; ) {
        for (Fe(xt, Et, nt, tt), Yt = 0; Yt < 64; Yt++)
          qe[Qe + Yt] = xt[Yt];
        for (Jt = 1, Yt = 8; Yt < 16; Yt++)
          Jt = Jt + (Et[Yt] & 255) | 0, Et[Yt] = Jt & 255, Jt >>>= 8;
        Ve -= 64, Qe += 64;
      }
      if (Ve > 0)
        for (Fe(xt, Et, nt, tt), Yt = 0; Yt < Ve; Yt++)
          qe[Qe + Yt] = xt[Yt];
      return 0;
    }
    function _t(qe, Qe, Ve, Ie, nt) {
      var Et = new Uint8Array(32);
      Ke(Et, Ie, nt, tt);
      for (var xt = new Uint8Array(8), Jt = 0; Jt < 8; Jt++)
        xt[Jt] = Ie[Jt + 16];
      return it(qe, Qe, Ve, xt, Et);
    }
    function Dt(qe, Qe, Ve, Ie, nt, Et, xt) {
      var Jt = new Uint8Array(32);
      Ke(Jt, Et, xt, tt);
      for (var Yt = new Uint8Array(8), _r = 0; _r < 8; _r++)
        Yt[_r] = Et[_r + 16];
      return rt(qe, Qe, Ve, Ie, nt, Yt, Jt);
    }
    var je = function(qe) {
      this.buffer = new Uint8Array(16), this.r = new Uint16Array(10), this.h = new Uint16Array(10), this.pad = new Uint16Array(8), this.leftover = 0, this.fin = 0;
      var Qe, Ve, Ie, nt, Et, xt, Jt, Yt;
      Qe = qe[0] & 255 | (qe[1] & 255) << 8, this.r[0] = Qe & 8191, Ve = qe[2] & 255 | (qe[3] & 255) << 8, this.r[1] = (Qe >>> 13 | Ve << 3) & 8191, Ie = qe[4] & 255 | (qe[5] & 255) << 8, this.r[2] = (Ve >>> 10 | Ie << 6) & 7939, nt = qe[6] & 255 | (qe[7] & 255) << 8, this.r[3] = (Ie >>> 7 | nt << 9) & 8191, Et = qe[8] & 255 | (qe[9] & 255) << 8, this.r[4] = (nt >>> 4 | Et << 12) & 255, this.r[5] = Et >>> 1 & 8190, xt = qe[10] & 255 | (qe[11] & 255) << 8, this.r[6] = (Et >>> 14 | xt << 2) & 8191, Jt = qe[12] & 255 | (qe[13] & 255) << 8, this.r[7] = (xt >>> 11 | Jt << 5) & 8065, Yt = qe[14] & 255 | (qe[15] & 255) << 8, this.r[8] = (Jt >>> 8 | Yt << 8) & 8191, this.r[9] = Yt >>> 5 & 127, this.pad[0] = qe[16] & 255 | (qe[17] & 255) << 8, this.pad[1] = qe[18] & 255 | (qe[19] & 255) << 8, this.pad[2] = qe[20] & 255 | (qe[21] & 255) << 8, this.pad[3] = qe[22] & 255 | (qe[23] & 255) << 8, this.pad[4] = qe[24] & 255 | (qe[25] & 255) << 8, this.pad[5] = qe[26] & 255 | (qe[27] & 255) << 8, this.pad[6] = qe[28] & 255 | (qe[29] & 255) << 8, this.pad[7] = qe[30] & 255 | (qe[31] & 255) << 8;
    };
    je.prototype.blocks = function(qe, Qe, Ve) {
      for (var Ie = this.fin ? 0 : 2048, nt, Et, xt, Jt, Yt, _r, cn, _X, un, aX, uX, fX, bX, dX, mX, pX, G_, iX, og, eX = this.h[0], tX = this.h[1], An = this.h[2], Gt = this.h[3], Wt = this.h[4], vr = this.h[5], Qt = this.h[6], rr = this.h[7], Ir = this.h[8], gX = this.h[9], TX = this.r[0], IX = this.r[1], RX = this.r[2], wt = this.r[3], CX = this.r[4], LX = this.r[5], UX = this.r[6], $X = this.r[7], OX = this.r[8], NX = this.r[9]; Ve >= 16; )
        nt = qe[Qe + 0] & 255 | (qe[Qe + 1] & 255) << 8, eX += nt & 8191, Et = qe[Qe + 2] & 255 | (qe[Qe + 3] & 255) << 8, tX += (nt >>> 13 | Et << 3) & 8191, xt = qe[Qe + 4] & 255 | (qe[Qe + 5] & 255) << 8, An += (Et >>> 10 | xt << 6) & 8191, Jt = qe[Qe + 6] & 255 | (qe[Qe + 7] & 255) << 8, Gt += (xt >>> 7 | Jt << 9) & 8191, Yt = qe[Qe + 8] & 255 | (qe[Qe + 9] & 255) << 8, Wt += (Jt >>> 4 | Yt << 12) & 8191, vr += Yt >>> 1 & 8191, _r = qe[Qe + 10] & 255 | (qe[Qe + 11] & 255) << 8, Qt += (Yt >>> 14 | _r << 2) & 8191, cn = qe[Qe + 12] & 255 | (qe[Qe + 13] & 255) << 8, rr += (_r >>> 11 | cn << 5) & 8191, _X = qe[Qe + 14] & 255 | (qe[Qe + 15] & 255) << 8, Ir += (cn >>> 8 | _X << 8) & 8191, gX += _X >>> 5 | Ie, un = 0, aX = un, aX += eX * TX, aX += tX * (5 * NX), aX += An * (5 * OX), aX += Gt * (5 * $X), aX += Wt * (5 * UX), un = aX >>> 13, aX &= 8191, aX += vr * (5 * LX), aX += Qt * (5 * CX), aX += rr * (5 * wt), aX += Ir * (5 * RX), aX += gX * (5 * IX), un += aX >>> 13, aX &= 8191, uX = un, uX += eX * IX, uX += tX * TX, uX += An * (5 * NX), uX += Gt * (5 * OX), uX += Wt * (5 * $X), un = uX >>> 13, uX &= 8191, uX += vr * (5 * UX), uX += Qt * (5 * LX), uX += rr * (5 * CX), uX += Ir * (5 * wt), uX += gX * (5 * RX), un += uX >>> 13, uX &= 8191, fX = un, fX += eX * RX, fX += tX * IX, fX += An * TX, fX += Gt * (5 * NX), fX += Wt * (5 * OX), un = fX >>> 13, fX &= 8191, fX += vr * (5 * $X), fX += Qt * (5 * UX), fX += rr * (5 * LX), fX += Ir * (5 * CX), fX += gX * (5 * wt), un += fX >>> 13, fX &= 8191, bX = un, bX += eX * wt, bX += tX * RX, bX += An * IX, bX += Gt * TX, bX += Wt * (5 * NX), un = bX >>> 13, bX &= 8191, bX += vr * (5 * OX), bX += Qt * (5 * $X), bX += rr * (5 * UX), bX += Ir * (5 * LX), bX += gX * (5 * CX), un += bX >>> 13, bX &= 8191, dX = un, dX += eX * CX, dX += tX * wt, dX += An * RX, dX += Gt * IX, dX += Wt * TX, un = dX >>> 13, dX &= 8191, dX += vr * (5 * NX), dX += Qt * (5 * OX), dX += rr * (5 * $X), dX += Ir * (5 * UX), dX += gX * (5 * LX), un += dX >>> 13, dX &= 8191, mX = un, mX += eX * LX, mX += tX * CX, mX += An * wt, mX += Gt * RX, mX += Wt * IX, un = mX >>> 13, mX &= 8191, mX += vr * TX, mX += Qt * (5 * NX), mX += rr * (5 * OX), mX += Ir * (5 * $X), mX += gX * (5 * UX), un += mX >>> 13, mX &= 8191, pX = un, pX += eX * UX, pX += tX * LX, pX += An * CX, pX += Gt * wt, pX += Wt * RX, un = pX >>> 13, pX &= 8191, pX += vr * IX, pX += Qt * TX, pX += rr * (5 * NX), pX += Ir * (5 * OX), pX += gX * (5 * $X), un += pX >>> 13, pX &= 8191, G_ = un, G_ += eX * $X, G_ += tX * UX, G_ += An * LX, G_ += Gt * CX, G_ += Wt * wt, un = G_ >>> 13, G_ &= 8191, G_ += vr * RX, G_ += Qt * IX, G_ += rr * TX, G_ += Ir * (5 * NX), G_ += gX * (5 * OX), un += G_ >>> 13, G_ &= 8191, iX = un, iX += eX * OX, iX += tX * $X, iX += An * UX, iX += Gt * LX, iX += Wt * CX, un = iX >>> 13, iX &= 8191, iX += vr * wt, iX += Qt * RX, iX += rr * IX, iX += Ir * TX, iX += gX * (5 * NX), un += iX >>> 13, iX &= 8191, og = un, og += eX * NX, og += tX * OX, og += An * $X, og += Gt * UX, og += Wt * LX, un = og >>> 13, og &= 8191, og += vr * CX, og += Qt * wt, og += rr * RX, og += Ir * IX, og += gX * TX, un += og >>> 13, og &= 8191, un = (un << 2) + un | 0, un = un + aX | 0, aX = un & 8191, un = un >>> 13, uX += un, eX = aX, tX = uX, An = fX, Gt = bX, Wt = dX, vr = mX, Qt = pX, rr = G_, Ir = iX, gX = og, Qe += 16, Ve -= 16;
      this.h[0] = eX, this.h[1] = tX, this.h[2] = An, this.h[3] = Gt, this.h[4] = Wt, this.h[5] = vr, this.h[6] = Qt, this.h[7] = rr, this.h[8] = Ir, this.h[9] = gX;
    }, je.prototype.finish = function(qe, Qe) {
      var Ve = new Uint16Array(10), Ie, nt, Et, xt;
      if (this.leftover) {
        for (xt = this.leftover, this.buffer[xt++] = 1; xt < 16; xt++)
          this.buffer[xt] = 0;
        this.fin = 1, this.blocks(this.buffer, 0, 16);
      }
      for (Ie = this.h[1] >>> 13, this.h[1] &= 8191, xt = 2; xt < 10; xt++)
        this.h[xt] += Ie, Ie = this.h[xt] >>> 13, this.h[xt] &= 8191;
      for (this.h[0] += Ie * 5, Ie = this.h[0] >>> 13, this.h[0] &= 8191, this.h[1] += Ie, Ie = this.h[1] >>> 13, this.h[1] &= 8191, this.h[2] += Ie, Ve[0] = this.h[0] + 5, Ie = Ve[0] >>> 13, Ve[0] &= 8191, xt = 1; xt < 10; xt++)
        Ve[xt] = this.h[xt] + Ie, Ie = Ve[xt] >>> 13, Ve[xt] &= 8191;
      for (Ve[9] -= 8192, nt = (Ie ^ 1) - 1, xt = 0; xt < 10; xt++)
        Ve[xt] &= nt;
      for (nt = ~nt, xt = 0; xt < 10; xt++)
        this.h[xt] = this.h[xt] & nt | Ve[xt];
      for (this.h[0] = (this.h[0] | this.h[1] << 13) & 65535, this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 65535, this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 65535, this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 65535, this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 65535, this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 65535, this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 65535, this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 65535, Et = this.h[0] + this.pad[0], this.h[0] = Et & 65535, xt = 1; xt < 8; xt++)
        Et = (this.h[xt] + this.pad[xt] | 0) + (Et >>> 16) | 0, this.h[xt] = Et & 65535;
      qe[Qe + 0] = this.h[0] >>> 0 & 255, qe[Qe + 1] = this.h[0] >>> 8 & 255, qe[Qe + 2] = this.h[1] >>> 0 & 255, qe[Qe + 3] = this.h[1] >>> 8 & 255, qe[Qe + 4] = this.h[2] >>> 0 & 255, qe[Qe + 5] = this.h[2] >>> 8 & 255, qe[Qe + 6] = this.h[3] >>> 0 & 255, qe[Qe + 7] = this.h[3] >>> 8 & 255, qe[Qe + 8] = this.h[4] >>> 0 & 255, qe[Qe + 9] = this.h[4] >>> 8 & 255, qe[Qe + 10] = this.h[5] >>> 0 & 255, qe[Qe + 11] = this.h[5] >>> 8 & 255, qe[Qe + 12] = this.h[6] >>> 0 & 255, qe[Qe + 13] = this.h[6] >>> 8 & 255, qe[Qe + 14] = this.h[7] >>> 0 & 255, qe[Qe + 15] = this.h[7] >>> 8 & 255;
    }, je.prototype.update = function(qe, Qe, Ve) {
      var Ie, nt;
      if (this.leftover) {
        for (nt = 16 - this.leftover, nt > Ve && (nt = Ve), Ie = 0; Ie < nt; Ie++)
          this.buffer[this.leftover + Ie] = qe[Qe + Ie];
        if (Ve -= nt, Qe += nt, this.leftover += nt, this.leftover < 16)
          return;
        this.blocks(this.buffer, 0, 16), this.leftover = 0;
      }
      if (Ve >= 16 && (nt = Ve - Ve % 16, this.blocks(qe, Qe, nt), Qe += nt, Ve -= nt), Ve) {
        for (Ie = 0; Ie < Ve; Ie++)
          this.buffer[this.leftover + Ie] = qe[Qe + Ie];
        this.leftover += Ve;
      }
    };
    function ze(qe, Qe, Ve, Ie, nt, Et) {
      var xt = new je(Et);
      return xt.update(Ve, Ie, nt), xt.finish(qe, Qe), 0;
    }
    function fe(qe, Qe, Ve, Ie, nt, Et) {
      var xt = new Uint8Array(16);
      return ze(xt, 0, Ve, Ie, nt, Et), Re(qe, Qe, xt, 0);
    }
    function de(qe, Qe, Ve, Ie, nt) {
      var Et;
      if (Ve < 32)
        return -1;
      for (Dt(qe, 0, Qe, 0, Ve, Ie, nt), ze(qe, 16, qe, 32, Ve - 32, qe), Et = 0; Et < 16; Et++)
        qe[Et] = 0;
      return 0;
    }
    function be(qe, Qe, Ve, Ie, nt) {
      var Et, xt = new Uint8Array(32);
      if (Ve < 32 || (_t(xt, 0, 32, Ie, nt), fe(Qe, 16, Qe, 32, Ve - 32, xt) !== 0))
        return -1;
      for (Dt(qe, 0, Qe, 0, Ve, Ie, nt), Et = 0; Et < 32; Et++)
        qe[Et] = 0;
      return 0;
    }
    function Te(qe, Qe) {
      var Ve;
      for (Ve = 0; Ve < 16; Ve++)
        qe[Ve] = Qe[Ve] | 0;
    }
    function Ce(qe) {
      var Qe, Ve, Ie = 1;
      for (Qe = 0; Qe < 16; Qe++)
        Ve = qe[Qe] + Ie + 65535, Ie = Math.floor(Ve / 65536), qe[Qe] = Ve - Ie * 65536;
      qe[0] += Ie - 1 + 37 * (Ie - 1);
    }
    function Pe(qe, Qe, Ve) {
      for (var Ie, nt = ~(Ve - 1), Et = 0; Et < 16; Et++)
        Ie = nt & (qe[Et] ^ Qe[Et]), qe[Et] ^= Ie, Qe[Et] ^= Ie;
    }
    function Se(qe, Qe) {
      var Ve, Ie, nt, Et = ee(), xt = ee();
      for (Ve = 0; Ve < 16; Ve++)
        xt[Ve] = Qe[Ve];
      for (Ce(xt), Ce(xt), Ce(xt), Ie = 0; Ie < 2; Ie++) {
        for (Et[0] = xt[0] - 65517, Ve = 1; Ve < 15; Ve++)
          Et[Ve] = xt[Ve] - 65535 - (Et[Ve - 1] >> 16 & 1), Et[Ve - 1] &= 65535;
        Et[15] = xt[15] - 32767 - (Et[14] >> 16 & 1), nt = Et[15] >> 16 & 1, Et[14] &= 65535, Pe(xt, Et, 1 - nt);
      }
      for (Ve = 0; Ve < 16; Ve++)
        qe[2 * Ve] = xt[Ve] & 255, qe[2 * Ve + 1] = xt[Ve] >> 8;
    }
    function ke(qe, Qe) {
      var Ve = new Uint8Array(32), Ie = new Uint8Array(32);
      return Se(Ve, qe), Se(Ie, Qe), Ue(Ve, 0, Ie, 0);
    }
    function ge(qe) {
      var Qe = new Uint8Array(32);
      return Se(Qe, qe), Qe[0] & 1;
    }
    function Ae(qe, Qe) {
      var Ve;
      for (Ve = 0; Ve < 16; Ve++)
        qe[Ve] = Qe[2 * Ve] + (Qe[2 * Ve + 1] << 8);
      qe[15] &= 32767;
    }
    function Ge(qe, Qe, Ve) {
      for (var Ie = 0; Ie < 16; Ie++)
        qe[Ie] = Qe[Ie] + Ve[Ie];
    }
    function Xe(qe, Qe, Ve) {
      for (var Ie = 0; Ie < 16; Ie++)
        qe[Ie] = Qe[Ie] - Ve[Ie];
    }
    function $e(qe, Qe, Ve) {
      var Ie, nt, Et = 0, xt = 0, Jt = 0, Yt = 0, _r = 0, cn = 0, _X = 0, un = 0, aX = 0, uX = 0, fX = 0, bX = 0, dX = 0, mX = 0, pX = 0, G_ = 0, iX = 0, og = 0, eX = 0, tX = 0, An = 0, Gt = 0, Wt = 0, vr = 0, Qt = 0, rr = 0, Ir = 0, gX = 0, TX = 0, IX = 0, RX = 0, wt = Ve[0], CX = Ve[1], LX = Ve[2], UX = Ve[3], $X = Ve[4], OX = Ve[5], NX = Ve[6], GX = Ve[7], zX = Ve[8], qX = Ve[9], DX = Ve[10], HX = Ve[11], KX = Ve[12], WX = Ve[13], VX = Ve[14], JX = Ve[15];
      Ie = Qe[0], Et += Ie * wt, xt += Ie * CX, Jt += Ie * LX, Yt += Ie * UX, _r += Ie * $X, cn += Ie * OX, _X += Ie * NX, un += Ie * GX, aX += Ie * zX, uX += Ie * qX, fX += Ie * DX, bX += Ie * HX, dX += Ie * KX, mX += Ie * WX, pX += Ie * VX, G_ += Ie * JX, Ie = Qe[1], xt += Ie * wt, Jt += Ie * CX, Yt += Ie * LX, _r += Ie * UX, cn += Ie * $X, _X += Ie * OX, un += Ie * NX, aX += Ie * GX, uX += Ie * zX, fX += Ie * qX, bX += Ie * DX, dX += Ie * HX, mX += Ie * KX, pX += Ie * WX, G_ += Ie * VX, iX += Ie * JX, Ie = Qe[2], Jt += Ie * wt, Yt += Ie * CX, _r += Ie * LX, cn += Ie * UX, _X += Ie * $X, un += Ie * OX, aX += Ie * NX, uX += Ie * GX, fX += Ie * zX, bX += Ie * qX, dX += Ie * DX, mX += Ie * HX, pX += Ie * KX, G_ += Ie * WX, iX += Ie * VX, og += Ie * JX, Ie = Qe[3], Yt += Ie * wt, _r += Ie * CX, cn += Ie * LX, _X += Ie * UX, un += Ie * $X, aX += Ie * OX, uX += Ie * NX, fX += Ie * GX, bX += Ie * zX, dX += Ie * qX, mX += Ie * DX, pX += Ie * HX, G_ += Ie * KX, iX += Ie * WX, og += Ie * VX, eX += Ie * JX, Ie = Qe[4], _r += Ie * wt, cn += Ie * CX, _X += Ie * LX, un += Ie * UX, aX += Ie * $X, uX += Ie * OX, fX += Ie * NX, bX += Ie * GX, dX += Ie * zX, mX += Ie * qX, pX += Ie * DX, G_ += Ie * HX, iX += Ie * KX, og += Ie * WX, eX += Ie * VX, tX += Ie * JX, Ie = Qe[5], cn += Ie * wt, _X += Ie * CX, un += Ie * LX, aX += Ie * UX, uX += Ie * $X, fX += Ie * OX, bX += Ie * NX, dX += Ie * GX, mX += Ie * zX, pX += Ie * qX, G_ += Ie * DX, iX += Ie * HX, og += Ie * KX, eX += Ie * WX, tX += Ie * VX, An += Ie * JX, Ie = Qe[6], _X += Ie * wt, un += Ie * CX, aX += Ie * LX, uX += Ie * UX, fX += Ie * $X, bX += Ie * OX, dX += Ie * NX, mX += Ie * GX, pX += Ie * zX, G_ += Ie * qX, iX += Ie * DX, og += Ie * HX, eX += Ie * KX, tX += Ie * WX, An += Ie * VX, Gt += Ie * JX, Ie = Qe[7], un += Ie * wt, aX += Ie * CX, uX += Ie * LX, fX += Ie * UX, bX += Ie * $X, dX += Ie * OX, mX += Ie * NX, pX += Ie * GX, G_ += Ie * zX, iX += Ie * qX, og += Ie * DX, eX += Ie * HX, tX += Ie * KX, An += Ie * WX, Gt += Ie * VX, Wt += Ie * JX, Ie = Qe[8], aX += Ie * wt, uX += Ie * CX, fX += Ie * LX, bX += Ie * UX, dX += Ie * $X, mX += Ie * OX, pX += Ie * NX, G_ += Ie * GX, iX += Ie * zX, og += Ie * qX, eX += Ie * DX, tX += Ie * HX, An += Ie * KX, Gt += Ie * WX, Wt += Ie * VX, vr += Ie * JX, Ie = Qe[9], uX += Ie * wt, fX += Ie * CX, bX += Ie * LX, dX += Ie * UX, mX += Ie * $X, pX += Ie * OX, G_ += Ie * NX, iX += Ie * GX, og += Ie * zX, eX += Ie * qX, tX += Ie * DX, An += Ie * HX, Gt += Ie * KX, Wt += Ie * WX, vr += Ie * VX, Qt += Ie * JX, Ie = Qe[10], fX += Ie * wt, bX += Ie * CX, dX += Ie * LX, mX += Ie * UX, pX += Ie * $X, G_ += Ie * OX, iX += Ie * NX, og += Ie * GX, eX += Ie * zX, tX += Ie * qX, An += Ie * DX, Gt += Ie * HX, Wt += Ie * KX, vr += Ie * WX, Qt += Ie * VX, rr += Ie * JX, Ie = Qe[11], bX += Ie * wt, dX += Ie * CX, mX += Ie * LX, pX += Ie * UX, G_ += Ie * $X, iX += Ie * OX, og += Ie * NX, eX += Ie * GX, tX += Ie * zX, An += Ie * qX, Gt += Ie * DX, Wt += Ie * HX, vr += Ie * KX, Qt += Ie * WX, rr += Ie * VX, Ir += Ie * JX, Ie = Qe[12], dX += Ie * wt, mX += Ie * CX, pX += Ie * LX, G_ += Ie * UX, iX += Ie * $X, og += Ie * OX, eX += Ie * NX, tX += Ie * GX, An += Ie * zX, Gt += Ie * qX, Wt += Ie * DX, vr += Ie * HX, Qt += Ie * KX, rr += Ie * WX, Ir += Ie * VX, gX += Ie * JX, Ie = Qe[13], mX += Ie * wt, pX += Ie * CX, G_ += Ie * LX, iX += Ie * UX, og += Ie * $X, eX += Ie * OX, tX += Ie * NX, An += Ie * GX, Gt += Ie * zX, Wt += Ie * qX, vr += Ie * DX, Qt += Ie * HX, rr += Ie * KX, Ir += Ie * WX, gX += Ie * VX, TX += Ie * JX, Ie = Qe[14], pX += Ie * wt, G_ += Ie * CX, iX += Ie * LX, og += Ie * UX, eX += Ie * $X, tX += Ie * OX, An += Ie * NX, Gt += Ie * GX, Wt += Ie * zX, vr += Ie * qX, Qt += Ie * DX, rr += Ie * HX, Ir += Ie * KX, gX += Ie * WX, TX += Ie * VX, IX += Ie * JX, Ie = Qe[15], G_ += Ie * wt, iX += Ie * CX, og += Ie * LX, eX += Ie * UX, tX += Ie * $X, An += Ie * OX, Gt += Ie * NX, Wt += Ie * GX, vr += Ie * zX, Qt += Ie * qX, rr += Ie * DX, Ir += Ie * HX, gX += Ie * KX, TX += Ie * WX, IX += Ie * VX, RX += Ie * JX, Et += 38 * iX, xt += 38 * og, Jt += 38 * eX, Yt += 38 * tX, _r += 38 * An, cn += 38 * Gt, _X += 38 * Wt, un += 38 * vr, aX += 38 * Qt, uX += 38 * rr, fX += 38 * Ir, bX += 38 * gX, dX += 38 * TX, mX += 38 * IX, pX += 38 * RX, nt = 1, Ie = Et + nt + 65535, nt = Math.floor(Ie / 65536), Et = Ie - nt * 65536, Ie = xt + nt + 65535, nt = Math.floor(Ie / 65536), xt = Ie - nt * 65536, Ie = Jt + nt + 65535, nt = Math.floor(Ie / 65536), Jt = Ie - nt * 65536, Ie = Yt + nt + 65535, nt = Math.floor(Ie / 65536), Yt = Ie - nt * 65536, Ie = _r + nt + 65535, nt = Math.floor(Ie / 65536), _r = Ie - nt * 65536, Ie = cn + nt + 65535, nt = Math.floor(Ie / 65536), cn = Ie - nt * 65536, Ie = _X + nt + 65535, nt = Math.floor(Ie / 65536), _X = Ie - nt * 65536, Ie = un + nt + 65535, nt = Math.floor(Ie / 65536), un = Ie - nt * 65536, Ie = aX + nt + 65535, nt = Math.floor(Ie / 65536), aX = Ie - nt * 65536, Ie = uX + nt + 65535, nt = Math.floor(Ie / 65536), uX = Ie - nt * 65536, Ie = fX + nt + 65535, nt = Math.floor(Ie / 65536), fX = Ie - nt * 65536, Ie = bX + nt + 65535, nt = Math.floor(Ie / 65536), bX = Ie - nt * 65536, Ie = dX + nt + 65535, nt = Math.floor(Ie / 65536), dX = Ie - nt * 65536, Ie = mX + nt + 65535, nt = Math.floor(Ie / 65536), mX = Ie - nt * 65536, Ie = pX + nt + 65535, nt = Math.floor(Ie / 65536), pX = Ie - nt * 65536, Ie = G_ + nt + 65535, nt = Math.floor(Ie / 65536), G_ = Ie - nt * 65536, Et += nt - 1 + 37 * (nt - 1), nt = 1, Ie = Et + nt + 65535, nt = Math.floor(Ie / 65536), Et = Ie - nt * 65536, Ie = xt + nt + 65535, nt = Math.floor(Ie / 65536), xt = Ie - nt * 65536, Ie = Jt + nt + 65535, nt = Math.floor(Ie / 65536), Jt = Ie - nt * 65536, Ie = Yt + nt + 65535, nt = Math.floor(Ie / 65536), Yt = Ie - nt * 65536, Ie = _r + nt + 65535, nt = Math.floor(Ie / 65536), _r = Ie - nt * 65536, Ie = cn + nt + 65535, nt = Math.floor(Ie / 65536), cn = Ie - nt * 65536, Ie = _X + nt + 65535, nt = Math.floor(Ie / 65536), _X = Ie - nt * 65536, Ie = un + nt + 65535, nt = Math.floor(Ie / 65536), un = Ie - nt * 65536, Ie = aX + nt + 65535, nt = Math.floor(Ie / 65536), aX = Ie - nt * 65536, Ie = uX + nt + 65535, nt = Math.floor(Ie / 65536), uX = Ie - nt * 65536, Ie = fX + nt + 65535, nt = Math.floor(Ie / 65536), fX = Ie - nt * 65536, Ie = bX + nt + 65535, nt = Math.floor(Ie / 65536), bX = Ie - nt * 65536, Ie = dX + nt + 65535, nt = Math.floor(Ie / 65536), dX = Ie - nt * 65536, Ie = mX + nt + 65535, nt = Math.floor(Ie / 65536), mX = Ie - nt * 65536, Ie = pX + nt + 65535, nt = Math.floor(Ie / 65536), pX = Ie - nt * 65536, Ie = G_ + nt + 65535, nt = Math.floor(Ie / 65536), G_ = Ie - nt * 65536, Et += nt - 1 + 37 * (nt - 1), qe[0] = Et, qe[1] = xt, qe[2] = Jt, qe[3] = Yt, qe[4] = _r, qe[5] = cn, qe[6] = _X, qe[7] = un, qe[8] = aX, qe[9] = uX, qe[10] = fX, qe[11] = bX, qe[12] = dX, qe[13] = mX, qe[14] = pX, qe[15] = G_;
    }
    function Ze(qe, Qe) {
      $e(qe, Qe, Qe);
    }
    function ot(qe, Qe) {
      var Ve = ee(), Ie;
      for (Ie = 0; Ie < 16; Ie++)
        Ve[Ie] = Qe[Ie];
      for (Ie = 253; Ie >= 0; Ie--)
        Ze(Ve, Ve), Ie !== 2 && Ie !== 4 && $e(Ve, Ve, Qe);
      for (Ie = 0; Ie < 16; Ie++)
        qe[Ie] = Ve[Ie];
    }
    function ct(qe, Qe) {
      var Ve = ee(), Ie;
      for (Ie = 0; Ie < 16; Ie++)
        Ve[Ie] = Qe[Ie];
      for (Ie = 250; Ie >= 0; Ie--)
        Ze(Ve, Ve), Ie !== 1 && $e(Ve, Ve, Qe);
      for (Ie = 0; Ie < 16; Ie++)
        qe[Ie] = Ve[Ie];
    }
    function At(qe, Qe, Ve) {
      var Ie = new Uint8Array(32), nt = new Float64Array(80), Et, xt, Jt = ee(), Yt = ee(), _r = ee(), cn = ee(), _X = ee(), un = ee();
      for (xt = 0; xt < 31; xt++)
        Ie[xt] = Qe[xt];
      for (Ie[31] = Qe[31] & 127 | 64, Ie[0] &= 248, Ae(nt, Ve), xt = 0; xt < 16; xt++)
        Yt[xt] = nt[xt], cn[xt] = Jt[xt] = _r[xt] = 0;
      for (Jt[0] = cn[0] = 1, xt = 254; xt >= 0; --xt)
        Et = Ie[xt >>> 3] >>> (xt & 7) & 1, Pe(Jt, Yt, Et), Pe(_r, cn, Et), Ge(_X, Jt, _r), Xe(Jt, Jt, _r), Ge(_r, Yt, cn), Xe(Yt, Yt, cn), Ze(cn, _X), Ze(un, Jt), $e(Jt, _r, Jt), $e(_r, Yt, _X), Ge(_X, Jt, _r), Xe(Jt, Jt, _r), Ze(Yt, Jt), Xe(_r, cn, un), $e(Jt, _r, ae), Ge(Jt, Jt, cn), $e(_r, _r, Jt), $e(Jt, cn, un), $e(cn, Yt, nt), Ze(Yt, _X), Pe(Jt, Yt, Et), Pe(_r, cn, Et);
      for (xt = 0; xt < 16; xt++)
        nt[xt + 16] = Jt[xt], nt[xt + 32] = _r[xt], nt[xt + 48] = Yt[xt], nt[xt + 64] = cn[xt];
      var aX = nt.subarray(32), uX = nt.subarray(16);
      return ot(aX, aX), $e(uX, uX, aX), Se(qe, uX), 0;
    }
    function Tt(qe, Qe) {
      return At(qe, Qe, ie);
    }
    function dt(qe, Qe) {
      return te(Qe, 32), Tt(qe, Qe);
    }
    function vt(qe, Qe, Ve) {
      var Ie = new Uint8Array(32);
      return At(Ie, Ve, Qe), Ke(qe, ne, Ie, tt);
    }
    var Ut = de, It = be;
    function Er(qe, Qe, Ve, Ie, nt, Et) {
      var xt = new Uint8Array(32);
      return vt(xt, nt, Et), Ut(qe, Qe, Ve, Ie, xt);
    }
    function Fr(qe, Qe, Ve, Ie, nt, Et) {
      var xt = new Uint8Array(32);
      return vt(xt, nt, Et), It(qe, Qe, Ve, Ie, xt);
    }
    var an = [
      1116352408,
      3609767458,
      1899447441,
      602891725,
      3049323471,
      3964484399,
      3921009573,
      2173295548,
      961987163,
      4081628472,
      1508970993,
      3053834265,
      2453635748,
      2937671579,
      2870763221,
      3664609560,
      3624381080,
      2734883394,
      310598401,
      1164996542,
      607225278,
      1323610764,
      1426881987,
      3590304994,
      1925078388,
      4068182383,
      2162078206,
      991336113,
      2614888103,
      633803317,
      3248222580,
      3479774868,
      3835390401,
      2666613458,
      4022224774,
      944711139,
      264347078,
      2341262773,
      604807628,
      2007800933,
      770255983,
      1495990901,
      1249150122,
      1856431235,
      1555081692,
      3175218132,
      1996064986,
      2198950837,
      2554220882,
      3999719339,
      2821834349,
      766784016,
      2952996808,
      2566594879,
      3210313671,
      3203337956,
      3336571891,
      1034457026,
      3584528711,
      2466948901,
      113926993,
      3758326383,
      338241895,
      168717936,
      666307205,
      1188179964,
      773529912,
      1546045734,
      1294757372,
      1522805485,
      1396182291,
      2643833823,
      1695183700,
      2343527390,
      1986661051,
      1014477480,
      2177026350,
      1206759142,
      2456956037,
      344077627,
      2730485921,
      1290863460,
      2820302411,
      3158454273,
      3259730800,
      3505952657,
      3345764771,
      106217008,
      3516065817,
      3606008344,
      3600352804,
      1432725776,
      4094571909,
      1467031594,
      275423344,
      851169720,
      430227734,
      3100823752,
      506948616,
      1363258195,
      659060556,
      3750685593,
      883997877,
      3785050280,
      958139571,
      3318307427,
      1322822218,
      3812723403,
      1537002063,
      2003034995,
      1747873779,
      3602036899,
      1955562222,
      1575990012,
      2024104815,
      1125592928,
      2227730452,
      2716904306,
      2361852424,
      442776044,
      2428436474,
      593698344,
      2756734187,
      3733110249,
      3204031479,
      2999351573,
      3329325298,
      3815920427,
      3391569614,
      3928383900,
      3515267271,
      566280711,
      3940187606,
      3454069534,
      4118630271,
      4000239992,
      116418474,
      1914138554,
      174292421,
      2731055270,
      289380356,
      3203993006,
      460393269,
      320620315,
      685471733,
      587496836,
      852142971,
      1086792851,
      1017036298,
      365543100,
      1126000580,
      2618297676,
      1288033470,
      3409855158,
      1501505948,
      4234509866,
      1607167915,
      987167468,
      1816402316,
      1246189591
    ];
    function wX(qe, Qe, Ve, Ie) {
      for (var nt = new Int32Array(16), Et = new Int32Array(16), xt, Jt, Yt, _r, cn, _X, un, aX, uX, fX, bX, dX, mX, pX, G_, iX, og, eX, tX, An, Gt, Wt, vr, Qt, rr, Ir, gX = qe[0], TX = qe[1], IX = qe[2], RX = qe[3], wt = qe[4], CX = qe[5], LX = qe[6], UX = qe[7], $X = Qe[0], OX = Qe[1], NX = Qe[2], GX = Qe[3], zX = Qe[4], qX = Qe[5], DX = Qe[6], HX = Qe[7], KX = 0; Ie >= 128; ) {
        for (tX = 0; tX < 16; tX++)
          An = 8 * tX + KX, nt[tX] = Ve[An + 0] << 24 | Ve[An + 1] << 16 | Ve[An + 2] << 8 | Ve[An + 3], Et[tX] = Ve[An + 4] << 24 | Ve[An + 5] << 16 | Ve[An + 6] << 8 | Ve[An + 7];
        for (tX = 0; tX < 80; tX++)
          if (xt = gX, Jt = TX, Yt = IX, _r = RX, cn = wt, _X = CX, un = LX, aX = UX, uX = $X, fX = OX, bX = NX, dX = GX, mX = zX, pX = qX, G_ = DX, iX = HX, Gt = UX, Wt = HX, vr = Wt & 65535, Qt = Wt >>> 16, rr = Gt & 65535, Ir = Gt >>> 16, Gt = (wt >>> 14 | zX << 18) ^ (wt >>> 18 | zX << 14) ^ (zX >>> 9 | wt << 23), Wt = (zX >>> 14 | wt << 18) ^ (zX >>> 18 | wt << 14) ^ (wt >>> 9 | zX << 23), vr += Wt & 65535, Qt += Wt >>> 16, rr += Gt & 65535, Ir += Gt >>> 16, Gt = wt & CX ^ ~wt & LX, Wt = zX & qX ^ ~zX & DX, vr += Wt & 65535, Qt += Wt >>> 16, rr += Gt & 65535, Ir += Gt >>> 16, Gt = an[tX * 2], Wt = an[tX * 2 + 1], vr += Wt & 65535, Qt += Wt >>> 16, rr += Gt & 65535, Ir += Gt >>> 16, Gt = nt[tX % 16], Wt = Et[tX % 16], vr += Wt & 65535, Qt += Wt >>> 16, rr += Gt & 65535, Ir += Gt >>> 16, Qt += vr >>> 16, rr += Qt >>> 16, Ir += rr >>> 16, og = rr & 65535 | Ir << 16, eX = vr & 65535 | Qt << 16, Gt = og, Wt = eX, vr = Wt & 65535, Qt = Wt >>> 16, rr = Gt & 65535, Ir = Gt >>> 16, Gt = (gX >>> 28 | $X << 4) ^ ($X >>> 2 | gX << 30) ^ ($X >>> 7 | gX << 25), Wt = ($X >>> 28 | gX << 4) ^ (gX >>> 2 | $X << 30) ^ (gX >>> 7 | $X << 25), vr += Wt & 65535, Qt += Wt >>> 16, rr += Gt & 65535, Ir += Gt >>> 16, Gt = gX & TX ^ gX & IX ^ TX & IX, Wt = $X & OX ^ $X & NX ^ OX & NX, vr += Wt & 65535, Qt += Wt >>> 16, rr += Gt & 65535, Ir += Gt >>> 16, Qt += vr >>> 16, rr += Qt >>> 16, Ir += rr >>> 16, aX = rr & 65535 | Ir << 16, iX = vr & 65535 | Qt << 16, Gt = _r, Wt = dX, vr = Wt & 65535, Qt = Wt >>> 16, rr = Gt & 65535, Ir = Gt >>> 16, Gt = og, Wt = eX, vr += Wt & 65535, Qt += Wt >>> 16, rr += Gt & 65535, Ir += Gt >>> 16, Qt += vr >>> 16, rr += Qt >>> 16, Ir += rr >>> 16, _r = rr & 65535 | Ir << 16, dX = vr & 65535 | Qt << 16, TX = xt, IX = Jt, RX = Yt, wt = _r, CX = cn, LX = _X, UX = un, gX = aX, OX = uX, NX = fX, GX = bX, zX = dX, qX = mX, DX = pX, HX = G_, $X = iX, tX % 16 === 15)
            for (An = 0; An < 16; An++)
              Gt = nt[An], Wt = Et[An], vr = Wt & 65535, Qt = Wt >>> 16, rr = Gt & 65535, Ir = Gt >>> 16, Gt = nt[(An + 9) % 16], Wt = Et[(An + 9) % 16], vr += Wt & 65535, Qt += Wt >>> 16, rr += Gt & 65535, Ir += Gt >>> 16, og = nt[(An + 1) % 16], eX = Et[(An + 1) % 16], Gt = (og >>> 1 | eX << 31) ^ (og >>> 8 | eX << 24) ^ og >>> 7, Wt = (eX >>> 1 | og << 31) ^ (eX >>> 8 | og << 24) ^ (eX >>> 7 | og << 25), vr += Wt & 65535, Qt += Wt >>> 16, rr += Gt & 65535, Ir += Gt >>> 16, og = nt[(An + 14) % 16], eX = Et[(An + 14) % 16], Gt = (og >>> 19 | eX << 13) ^ (eX >>> 29 | og << 3) ^ og >>> 6, Wt = (eX >>> 19 | og << 13) ^ (og >>> 29 | eX << 3) ^ (eX >>> 6 | og << 26), vr += Wt & 65535, Qt += Wt >>> 16, rr += Gt & 65535, Ir += Gt >>> 16, Qt += vr >>> 16, rr += Qt >>> 16, Ir += rr >>> 16, nt[An] = rr & 65535 | Ir << 16, Et[An] = vr & 65535 | Qt << 16;
        Gt = gX, Wt = $X, vr = Wt & 65535, Qt = Wt >>> 16, rr = Gt & 65535, Ir = Gt >>> 16, Gt = qe[0], Wt = Qe[0], vr += Wt & 65535, Qt += Wt >>> 16, rr += Gt & 65535, Ir += Gt >>> 16, Qt += vr >>> 16, rr += Qt >>> 16, Ir += rr >>> 16, qe[0] = gX = rr & 65535 | Ir << 16, Qe[0] = $X = vr & 65535 | Qt << 16, Gt = TX, Wt = OX, vr = Wt & 65535, Qt = Wt >>> 16, rr = Gt & 65535, Ir = Gt >>> 16, Gt = qe[1], Wt = Qe[1], vr += Wt & 65535, Qt += Wt >>> 16, rr += Gt & 65535, Ir += Gt >>> 16, Qt += vr >>> 16, rr += Qt >>> 16, Ir += rr >>> 16, qe[1] = TX = rr & 65535 | Ir << 16, Qe[1] = OX = vr & 65535 | Qt << 16, Gt = IX, Wt = NX, vr = Wt & 65535, Qt = Wt >>> 16, rr = Gt & 65535, Ir = Gt >>> 16, Gt = qe[2], Wt = Qe[2], vr += Wt & 65535, Qt += Wt >>> 16, rr += Gt & 65535, Ir += Gt >>> 16, Qt += vr >>> 16, rr += Qt >>> 16, Ir += rr >>> 16, qe[2] = IX = rr & 65535 | Ir << 16, Qe[2] = NX = vr & 65535 | Qt << 16, Gt = RX, Wt = GX, vr = Wt & 65535, Qt = Wt >>> 16, rr = Gt & 65535, Ir = Gt >>> 16, Gt = qe[3], Wt = Qe[3], vr += Wt & 65535, Qt += Wt >>> 16, rr += Gt & 65535, Ir += Gt >>> 16, Qt += vr >>> 16, rr += Qt >>> 16, Ir += rr >>> 16, qe[3] = RX = rr & 65535 | Ir << 16, Qe[3] = GX = vr & 65535 | Qt << 16, Gt = wt, Wt = zX, vr = Wt & 65535, Qt = Wt >>> 16, rr = Gt & 65535, Ir = Gt >>> 16, Gt = qe[4], Wt = Qe[4], vr += Wt & 65535, Qt += Wt >>> 16, rr += Gt & 65535, Ir += Gt >>> 16, Qt += vr >>> 16, rr += Qt >>> 16, Ir += rr >>> 16, qe[4] = wt = rr & 65535 | Ir << 16, Qe[4] = zX = vr & 65535 | Qt << 16, Gt = CX, Wt = qX, vr = Wt & 65535, Qt = Wt >>> 16, rr = Gt & 65535, Ir = Gt >>> 16, Gt = qe[5], Wt = Qe[5], vr += Wt & 65535, Qt += Wt >>> 16, rr += Gt & 65535, Ir += Gt >>> 16, Qt += vr >>> 16, rr += Qt >>> 16, Ir += rr >>> 16, qe[5] = CX = rr & 65535 | Ir << 16, Qe[5] = qX = vr & 65535 | Qt << 16, Gt = LX, Wt = DX, vr = Wt & 65535, Qt = Wt >>> 16, rr = Gt & 65535, Ir = Gt >>> 16, Gt = qe[6], Wt = Qe[6], vr += Wt & 65535, Qt += Wt >>> 16, rr += Gt & 65535, Ir += Gt >>> 16, Qt += vr >>> 16, rr += Qt >>> 16, Ir += rr >>> 16, qe[6] = LX = rr & 65535 | Ir << 16, Qe[6] = DX = vr & 65535 | Qt << 16, Gt = UX, Wt = HX, vr = Wt & 65535, Qt = Wt >>> 16, rr = Gt & 65535, Ir = Gt >>> 16, Gt = qe[7], Wt = Qe[7], vr += Wt & 65535, Qt += Wt >>> 16, rr += Gt & 65535, Ir += Gt >>> 16, Qt += vr >>> 16, rr += Qt >>> 16, Ir += rr >>> 16, qe[7] = UX = rr & 65535 | Ir << 16, Qe[7] = HX = vr & 65535 | Qt << 16, KX += 128, Ie -= 128;
      }
      return Ie;
    }
    function Ct(qe, Qe, Ve) {
      var Ie = new Int32Array(8), nt = new Int32Array(8), Et = new Uint8Array(256), xt, Jt = Ve;
      for (Ie[0] = 1779033703, Ie[1] = 3144134277, Ie[2] = 1013904242, Ie[3] = 2773480762, Ie[4] = 1359893119, Ie[5] = 2600822924, Ie[6] = 528734635, Ie[7] = 1541459225, nt[0] = 4089235720, nt[1] = 2227873595, nt[2] = 4271175723, nt[3] = 1595750129, nt[4] = 2917565137, nt[5] = 725511199, nt[6] = 4215389547, nt[7] = 327033209, wX(Ie, nt, Qe, Ve), Ve %= 128, xt = 0; xt < Ve; xt++)
        Et[xt] = Qe[Jt - Ve + xt];
      for (Et[Ve] = 128, Ve = 256 - 128 * (Ve < 112 ? 1 : 0), Et[Ve - 9] = 0, we(Et, Ve - 8, Jt / 536870912 | 0, Jt << 3), wX(Ie, nt, Et, Ve), xt = 0; xt < 8; xt++)
        we(qe, 8 * xt, Ie[xt], nt[xt]);
      return 0;
    }
    function w_(qe, Qe) {
      var Ve = ee(), Ie = ee(), nt = ee(), Et = ee(), xt = ee(), Jt = ee(), Yt = ee(), _r = ee(), cn = ee();
      Xe(Ve, qe[1], qe[0]), Xe(cn, Qe[1], Qe[0]), $e(Ve, Ve, cn), Ge(Ie, qe[0], qe[1]), Ge(cn, Qe[0], Qe[1]), $e(Ie, Ie, cn), $e(nt, qe[3], Qe[3]), $e(nt, nt, le), $e(Et, qe[2], Qe[2]), Ge(Et, Et, Et), Xe(xt, Ie, Ve), Xe(Jt, Et, nt), Ge(Yt, Et, nt), Ge(_r, Ie, Ve), $e(qe[0], xt, Jt), $e(qe[1], _r, Yt), $e(qe[2], Yt, Jt), $e(qe[3], xt, _r);
    }
    function hX(qe, Qe, Ve) {
      var Ie;
      for (Ie = 0; Ie < 4; Ie++)
        Pe(qe[Ie], Qe[Ie], Ve);
    }
    function oX(qe, Qe) {
      var Ve = ee(), Ie = ee(), nt = ee();
      ot(nt, Qe[2]), $e(Ve, Qe[0], nt), $e(Ie, Qe[1], nt), Se(qe, Ie), qe[31] ^= ge(Ve) << 7;
    }
    function Nn(qe, Qe, Ve) {
      var Ie, nt;
      for (Te(qe[0], oe), Te(qe[1], se), Te(qe[2], se), Te(qe[3], oe), nt = 255; nt >= 0; --nt)
        Ie = Ve[nt / 8 | 0] >> (nt & 7) & 1, hX(qe, Qe, Ie), w_(Qe, qe), w_(qe, qe), hX(qe, Qe, Ie);
    }
    function SX(qe, Qe) {
      var Ve = [ee(), ee(), ee(), ee()];
      Te(Ve[0], he), Te(Ve[1], me), Te(Ve[2], se), $e(Ve[3], he, me), Nn(qe, Ve, Qe);
    }
    function sX(qe, Qe, Ve) {
      var Ie = new Uint8Array(64), nt = [ee(), ee(), ee(), ee()], Et;
      for (Ve || te(Qe, 32), Ct(Ie, Qe, 32), Ie[0] &= 248, Ie[31] &= 127, Ie[31] |= 64, SX(nt, Ie), oX(qe, nt), Et = 0; Et < 32; Et++)
        Qe[Et + 32] = qe[Et];
      return 0;
    }
    var nX = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
    function Ye(qe, Qe) {
      var Ve, Ie, nt, Et;
      for (Ie = 63; Ie >= 32; --Ie) {
        for (Ve = 0, nt = Ie - 32, Et = Ie - 12; nt < Et; ++nt)
          Qe[nt] += Ve - 16 * Qe[Ie] * nX[nt - (Ie - 32)], Ve = Math.floor((Qe[nt] + 128) / 256), Qe[nt] -= Ve * 256;
        Qe[nt] += Ve, Qe[Ie] = 0;
      }
      for (Ve = 0, nt = 0; nt < 32; nt++)
        Qe[nt] += Ve - (Qe[31] >> 4) * nX[nt], Ve = Qe[nt] >> 8, Qe[nt] &= 255;
      for (nt = 0; nt < 32; nt++)
        Qe[nt] -= Ve * nX[nt];
      for (Ie = 0; Ie < 32; Ie++)
        Qe[Ie + 1] += Qe[Ie] >> 8, qe[Ie] = Qe[Ie] & 255;
    }
    function lt(qe) {
      var Qe = new Float64Array(64), Ve;
      for (Ve = 0; Ve < 64; Ve++)
        Qe[Ve] = qe[Ve];
      for (Ve = 0; Ve < 64; Ve++)
        qe[Ve] = 0;
      Ye(qe, Qe);
    }
    function pt(qe, Qe, Ve, Ie) {
      var nt = new Uint8Array(64), Et = new Uint8Array(64), xt = new Uint8Array(64), Jt, Yt, _r = new Float64Array(64), cn = [ee(), ee(), ee(), ee()];
      Ct(nt, Ie, 32), nt[0] &= 248, nt[31] &= 127, nt[31] |= 64;
      var _X = Ve + 64;
      for (Jt = 0; Jt < Ve; Jt++)
        qe[64 + Jt] = Qe[Jt];
      for (Jt = 0; Jt < 32; Jt++)
        qe[32 + Jt] = nt[32 + Jt];
      for (Ct(xt, qe.subarray(32), Ve + 32), lt(xt), SX(cn, xt), oX(qe, cn), Jt = 32; Jt < 64; Jt++)
        qe[Jt] = Ie[Jt];
      for (Ct(Et, qe, Ve + 64), lt(Et), Jt = 0; Jt < 64; Jt++)
        _r[Jt] = 0;
      for (Jt = 0; Jt < 32; Jt++)
        _r[Jt] = xt[Jt];
      for (Jt = 0; Jt < 32; Jt++)
        for (Yt = 0; Yt < 32; Yt++)
          _r[Jt + Yt] += Et[Jt] * nt[Yt];
      return Ye(qe.subarray(32), _r), _X;
    }
    function He(qe, Qe) {
      var Ve = ee(), Ie = ee(), nt = ee(), Et = ee(), xt = ee(), Jt = ee(), Yt = ee();
      return Te(qe[2], se), Ae(qe[1], Qe), Ze(nt, qe[1]), $e(Et, nt, ue), Xe(nt, nt, qe[2]), Ge(Et, qe[2], Et), Ze(xt, Et), Ze(Jt, xt), $e(Yt, Jt, xt), $e(Ve, Yt, nt), $e(Ve, Ve, Et), ct(Ve, Ve), $e(Ve, Ve, nt), $e(Ve, Ve, Et), $e(Ve, Ve, Et), $e(qe[0], Ve, Et), Ze(Ie, qe[0]), $e(Ie, Ie, Et), ke(Ie, nt) && $e(qe[0], qe[0], ye), Ze(Ie, qe[0]), $e(Ie, Ie, Et), ke(Ie, nt) ? -1 : (ge(qe[0]) === Qe[31] >> 7 && Xe(qe[0], oe, qe[0]), $e(qe[3], qe[0], qe[1]), 0);
    }
    function Je(qe, Qe, Ve, Ie) {
      var nt, Et = new Uint8Array(32), xt = new Uint8Array(64), Jt = [ee(), ee(), ee(), ee()], Yt = [ee(), ee(), ee(), ee()];
      if (Ve < 64 || He(Yt, Ie))
        return -1;
      for (nt = 0; nt < Ve; nt++)
        qe[nt] = Qe[nt];
      for (nt = 0; nt < 32; nt++)
        qe[nt + 32] = Ie[nt];
      if (Ct(xt, qe, Ve), lt(xt), Nn(Jt, Yt, xt), SX(Yt, Qe.subarray(32)), w_(Jt, Yt), oX(Et, Jt), Ve -= 64, Ue(Qe, 0, Et, 0)) {
        for (nt = 0; nt < Ve; nt++)
          qe[nt] = 0;
        return -1;
      }
      for (nt = 0; nt < Ve; nt++)
        qe[nt] = Qe[nt + 64];
      return Ve;
    }
    var st = 32, gt = 24, kt = 32, Vt = 16, Lr = 32, Ci = 32, Qr = 32, xX = 32, lX = 32, rX = gt, FX = kt, BX = Vt, cX = 64, MX = 32, EX = 64, yX = 32, jX = 64;
    X.lowlevel = {
      crypto_core_hsalsa20: Ke,
      crypto_stream_xor: Dt,
      crypto_stream: _t,
      crypto_stream_salsa20_xor: rt,
      crypto_stream_salsa20: it,
      crypto_onetimeauth: ze,
      crypto_onetimeauth_verify: fe,
      crypto_verify_16: Re,
      crypto_verify_32: Ue,
      crypto_secretbox: de,
      crypto_secretbox_open: be,
      crypto_scalarmult: At,
      crypto_scalarmult_base: Tt,
      crypto_box_beforenm: vt,
      crypto_box_afternm: Ut,
      crypto_box: Er,
      crypto_box_open: Fr,
      crypto_box_keypair: dt,
      crypto_hash: Ct,
      crypto_sign: pt,
      crypto_sign_keypair: sX,
      crypto_sign_open: Je,
      crypto_secretbox_KEYBYTES: st,
      crypto_secretbox_NONCEBYTES: gt,
      crypto_secretbox_ZEROBYTES: kt,
      crypto_secretbox_BOXZEROBYTES: Vt,
      crypto_scalarmult_BYTES: Lr,
      crypto_scalarmult_SCALARBYTES: Ci,
      crypto_box_PUBLICKEYBYTES: Qr,
      crypto_box_SECRETKEYBYTES: xX,
      crypto_box_BEFORENMBYTES: lX,
      crypto_box_NONCEBYTES: rX,
      crypto_box_ZEROBYTES: FX,
      crypto_box_BOXZEROBYTES: BX,
      crypto_sign_BYTES: cX,
      crypto_sign_PUBLICKEYBYTES: MX,
      crypto_sign_SECRETKEYBYTES: EX,
      crypto_sign_SEEDBYTES: yX,
      crypto_hash_BYTES: jX,
      gf: ee,
      D: ue,
      L: nX,
      pack25519: Se,
      unpack25519: Ae,
      M: $e,
      A: Ge,
      S: Ze,
      Z: Xe,
      pow2523: ct,
      add: w_,
      set25519: Te,
      modL: Ye,
      scalarmult: Nn,
      scalarbase: SX
    };
    function AX(qe, Qe) {
      if (qe.length !== st)
        throw new Error("bad key size");
      if (Qe.length !== gt)
        throw new Error("bad nonce size");
    }
    function vX(qe, Qe) {
      if (qe.length !== Qr)
        throw new Error("bad public key size");
      if (Qe.length !== xX)
        throw new Error("bad secret key size");
    }
    function PX() {
      for (var qe = 0; qe < arguments.length; qe++)
        if (!(arguments[qe] instanceof Uint8Array))
          throw new TypeError("unexpected type, use Uint8Array");
    }
    function kX(qe) {
      for (var Qe = 0; Qe < qe.length; Qe++)
        qe[Qe] = 0;
    }
    X.randomBytes = function(qe) {
      var Qe = new Uint8Array(qe);
      return te(Qe, qe), Qe;
    }, X.secretbox = function(qe, Qe, Ve) {
      PX(qe, Qe, Ve), AX(Ve, Qe);
      for (var Ie = new Uint8Array(kt + qe.length), nt = new Uint8Array(Ie.length), Et = 0; Et < qe.length; Et++)
        Ie[Et + kt] = qe[Et];
      return de(nt, Ie, Ie.length, Qe, Ve), nt.subarray(Vt);
    }, X.secretbox.open = function(qe, Qe, Ve) {
      PX(qe, Qe, Ve), AX(Ve, Qe);
      for (var Ie = new Uint8Array(Vt + qe.length), nt = new Uint8Array(Ie.length), Et = 0; Et < qe.length; Et++)
        Ie[Et + Vt] = qe[Et];
      return Ie.length < 32 || be(nt, Ie, Ie.length, Qe, Ve) !== 0 ? null : nt.subarray(kt);
    }, X.secretbox.keyLength = st, X.secretbox.nonceLength = gt, X.secretbox.overheadLength = Vt, X.scalarMult = function(qe, Qe) {
      if (PX(qe, Qe), qe.length !== Ci)
        throw new Error("bad n size");
      if (Qe.length !== Lr)
        throw new Error("bad p size");
      var Ve = new Uint8Array(Lr);
      return At(Ve, qe, Qe), Ve;
    }, X.scalarMult.base = function(qe) {
      if (PX(qe), qe.length !== Ci)
        throw new Error("bad n size");
      var Qe = new Uint8Array(Lr);
      return Tt(Qe, qe), Qe;
    }, X.scalarMult.scalarLength = Ci, X.scalarMult.groupElementLength = Lr, X.box = function(qe, Qe, Ve, Ie) {
      var nt = X.box.before(Ve, Ie);
      return X.secretbox(qe, Qe, nt);
    }, X.box.before = function(qe, Qe) {
      PX(qe, Qe), vX(qe, Qe);
      var Ve = new Uint8Array(lX);
      return vt(Ve, qe, Qe), Ve;
    }, X.box.after = X.secretbox, X.box.open = function(qe, Qe, Ve, Ie) {
      var nt = X.box.before(Ve, Ie);
      return X.secretbox.open(qe, Qe, nt);
    }, X.box.open.after = X.secretbox.open, X.box.keyPair = function() {
      var qe = new Uint8Array(Qr), Qe = new Uint8Array(xX);
      return dt(qe, Qe), { publicKey: qe, secretKey: Qe };
    }, X.box.keyPair.fromSecretKey = function(qe) {
      if (PX(qe), qe.length !== xX)
        throw new Error("bad secret key size");
      var Qe = new Uint8Array(Qr);
      return Tt(Qe, qe), { publicKey: Qe, secretKey: new Uint8Array(qe) };
    }, X.box.publicKeyLength = Qr, X.box.secretKeyLength = xX, X.box.sharedKeyLength = lX, X.box.nonceLength = rX, X.box.overheadLength = X.secretbox.overheadLength, X.sign = function(qe, Qe) {
      if (PX(qe, Qe), Qe.length !== EX)
        throw new Error("bad secret key size");
      var Ve = new Uint8Array(cX + qe.length);
      return pt(Ve, qe, qe.length, Qe), Ve;
    }, X.sign.open = function(qe, Qe) {
      if (PX(qe, Qe), Qe.length !== MX)
        throw new Error("bad public key size");
      var Ve = new Uint8Array(qe.length), Ie = Je(Ve, qe, qe.length, Qe);
      if (Ie < 0)
        return null;
      for (var nt = new Uint8Array(Ie), Et = 0; Et < nt.length; Et++)
        nt[Et] = Ve[Et];
      return nt;
    }, X.sign.detached = function(qe, Qe) {
      for (var Ve = X.sign(qe, Qe), Ie = new Uint8Array(cX), nt = 0; nt < Ie.length; nt++)
        Ie[nt] = Ve[nt];
      return Ie;
    }, X.sign.detached.verify = function(qe, Qe, Ve) {
      if (PX(qe, Qe, Ve), Qe.length !== cX)
        throw new Error("bad signature size");
      if (Ve.length !== MX)
        throw new Error("bad public key size");
      var Ie = new Uint8Array(cX + qe.length), nt = new Uint8Array(cX + qe.length), Et;
      for (Et = 0; Et < cX; Et++)
        Ie[Et] = Qe[Et];
      for (Et = 0; Et < qe.length; Et++)
        Ie[Et + cX] = qe[Et];
      return Je(nt, Ie, Ie.length, Ve) >= 0;
    }, X.sign.keyPair = function() {
      var qe = new Uint8Array(MX), Qe = new Uint8Array(EX);
      return sX(qe, Qe), { publicKey: qe, secretKey: Qe };
    }, X.sign.keyPair.fromSecretKey = function(qe) {
      if (PX(qe), qe.length !== EX)
        throw new Error("bad secret key size");
      for (var Qe = new Uint8Array(MX), Ve = 0; Ve < Qe.length; Ve++)
        Qe[Ve] = qe[32 + Ve];
      return { publicKey: Qe, secretKey: new Uint8Array(qe) };
    }, X.sign.keyPair.fromSeed = function(qe) {
      if (PX(qe), qe.length !== yX)
        throw new Error("bad seed size");
      for (var Qe = new Uint8Array(MX), Ve = new Uint8Array(EX), Ie = 0; Ie < 32; Ie++)
        Ve[Ie] = qe[Ie];
      return sX(Qe, Ve, !0), { publicKey: Qe, secretKey: Ve };
    }, X.sign.publicKeyLength = MX, X.sign.secretKeyLength = EX, X.sign.seedLength = yX, X.sign.signatureLength = cX, X.hash = function(qe) {
      PX(qe);
      var Qe = new Uint8Array(jX);
      return Ct(Qe, qe, qe.length), Qe;
    }, X.hash.hashLength = jX, X.verify = function(qe, Qe) {
      return PX(qe, Qe), qe.length === 0 || Qe.length === 0 || qe.length !== Qe.length ? !1 : Ee(qe, 0, Qe, 0, qe.length) === 0;
    }, X.setPRNG = function(qe) {
      te = qe;
    }, function() {
      var qe = typeof self < "u" ? self.crypto || self.msCrypto : null;
      if (qe && qe.getRandomValues) {
        var Qe = 65536;
        X.setPRNG(function(Ve, Ie) {
          var nt, Et = new Uint8Array(Ie);
          for (nt = 0; nt < Ie; nt += Qe)
            qe.getRandomValues(Et.subarray(nt, nt + Math.min(Ie - nt, Qe)));
          for (nt = 0; nt < Ie; nt++)
            Ve[nt] = Et[nt];
          kX(Et);
        });
      } else
        typeof Qp < "u" && (qe = Ta, qe && qe.randomBytes && X.setPRNG(function(Ve, Ie) {
          var nt, Et = qe.randomBytes(Ie);
          for (nt = 0; nt < Ie; nt++)
            Ve[nt] = Et[nt];
          kX(Et);
        }));
    }();
  })(Y.exports ? Y.exports : self.nacl = self.nacl || {});
})(cA);
var DF = cA.exports, uA = { exports: {} };
(function(Y) {
  (function(X, ee) {
    Y.exports ? Y.exports = ee() : (X.nacl || (X.nacl = {}), X.nacl.util = ee());
  })(St, function() {
    var X = {};
    function ee(te) {
      if (!/^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/.test(te))
        throw new TypeError("invalid encoding");
    }
    return X.decodeUTF8 = function(te) {
      if (typeof te != "string")
        throw new TypeError("expected string");
      var ne, ie = unescape(encodeURIComponent(te)), oe = new Uint8Array(ie.length);
      for (ne = 0; ne < ie.length; ne++)
        oe[ne] = ie.charCodeAt(ne);
      return oe;
    }, X.encodeUTF8 = function(te) {
      var ne, ie = [];
      for (ne = 0; ne < te.length; ne++)
        ie.push(String.fromCharCode(te[ne]));
      return decodeURIComponent(escape(ie.join("")));
    }, typeof atob > "u" ? typeof Buffer.from < "u" ? (X.encodeBase64 = function(te) {
      return Buffer.from(te).toString("base64");
    }, X.decodeBase64 = function(te) {
      return ee(te), new Uint8Array(Array.prototype.slice.call(Buffer.from(te, "base64"), 0));
    }) : (X.encodeBase64 = function(te) {
      return new Buffer(te).toString("base64");
    }, X.decodeBase64 = function(te) {
      return ee(te), new Uint8Array(Array.prototype.slice.call(new Buffer(te, "base64"), 0));
    }) : (X.encodeBase64 = function(te) {
      var ne, ie = [], oe = te.length;
      for (ne = 0; ne < oe; ne++)
        ie.push(String.fromCharCode(te[ne]));
      return btoa(ie.join(""));
    }, X.decodeBase64 = function(te) {
      ee(te);
      var ne, ie = atob(te), oe = new Uint8Array(ie.length);
      for (ne = 0; ne < ie.length; ne++)
        oe[ne] = ie.charCodeAt(ne);
      return oe;
    }), X;
  });
})(uA);
var UF = uA.exports, jF = St && St.__createBinding || (Object.create ? function(Y, X, ee, te) {
  te === void 0 && (te = ee);
  var ne = Object.getOwnPropertyDescriptor(X, ee);
  (!ne || ("get" in ne ? !X.__esModule : ne.writable || ne.configurable)) && (ne = { enumerable: !0, get: function() {
    return X[ee];
  } }), Object.defineProperty(Y, te, ne);
} : function(Y, X, ee, te) {
  te === void 0 && (te = ee), Y[te] = X[ee];
}), HF = St && St.__setModuleDefault || (Object.create ? function(Y, X) {
  Object.defineProperty(Y, "default", { enumerable: !0, value: X });
} : function(Y, X) {
  Y.default = X;
}), fA = St && St.__importStar || function(Y) {
  if (Y && Y.__esModule)
    return Y;
  var X = {};
  if (Y != null)
    for (var ee in Y)
      ee !== "default" && Object.prototype.hasOwnProperty.call(Y, ee) && jF(X, Y, ee);
  return HF(X, Y), X;
};
Object.defineProperty(Xn, "__esModule", { value: !0 });
Xn.getEncryptionPublicKey = Xn.decryptSafely = Xn.decrypt = Xn.encryptSafely = Xn.encrypt = void 0;
const To = fA(DF), gi = fA(UF), Ji = tn;
function lA({ publicKey: Y, data: X, version: ee }) {
  if ((0, Ji.isNullish)(Y))
    throw new Error("Missing publicKey parameter");
  if ((0, Ji.isNullish)(X))
    throw new Error("Missing data parameter");
  if ((0, Ji.isNullish)(ee))
    throw new Error("Missing version parameter");
  switch (ee) {
    case "x25519-xsalsa20-poly1305": {
      if (typeof X != "string")
        throw new Error("Message data must be given as a string");
      const te = To.box.keyPair();
      let ne;
      try {
        ne = gi.decodeBase64(Y);
      } catch {
        throw new Error("Bad public key");
      }
      const ie = gi.decodeUTF8(X), oe = To.randomBytes(To.box.nonceLength), se = To.box(ie, oe, ne, te.secretKey);
      return {
        version: "x25519-xsalsa20-poly1305",
        nonce: gi.encodeBase64(oe),
        ephemPublicKey: gi.encodeBase64(te.publicKey),
        ciphertext: gi.encodeBase64(se)
      };
    }
    default:
      throw new Error("Encryption type/version not supported");
  }
}
Xn.encrypt = lA;
function zF({ publicKey: Y, data: X, version: ee }) {
  if ((0, Ji.isNullish)(Y))
    throw new Error("Missing publicKey parameter");
  if ((0, Ji.isNullish)(X))
    throw new Error("Missing data parameter");
  if ((0, Ji.isNullish)(ee))
    throw new Error("Missing version parameter");
  const te = 2 ** 11, ne = 16;
  if (typeof X == "object" && X && "toJSON" in X)
    throw new Error("Cannot encrypt with toJSON property.  Please remove toJSON property");
  const ie = {
    data: X,
    padding: ""
  }, oe = Buffer.byteLength(JSON.stringify(ie), "utf-8") % te;
  let se = 0;
  oe > 0 && (se = te - oe - ne), ie.padding = "0".repeat(se);
  const ae = JSON.stringify(ie);
  return lA({ publicKey: Y, data: ae, version: ee });
}
Xn.encryptSafely = zF;
function dA({ encryptedData: Y, privateKey: X }) {
  if ((0, Ji.isNullish)(Y))
    throw new Error("Missing encryptedData parameter");
  if ((0, Ji.isNullish)(X))
    throw new Error("Missing privateKey parameter");
  switch (Y.version) {
    case "x25519-xsalsa20-poly1305": {
      const ee = hA(X), te = To.box.keyPair.fromSecretKey(ee).secretKey, ne = gi.decodeBase64(Y.nonce), ie = gi.decodeBase64(Y.ciphertext), oe = gi.decodeBase64(Y.ephemPublicKey), se = To.box.open(ie, ne, oe, te);
      try {
        if (!se)
          throw new Error();
        const ae = gi.encodeUTF8(se);
        if (!ae)
          throw new Error();
        return ae;
      } catch (ae) {
        throw ae && typeof ae.message == "string" && ae.message.length ? new Error(`Decryption failed: ${ae.message}`) : new Error("Decryption failed.");
      }
    }
    default:
      throw new Error("Encryption type/version not supported.");
  }
}
Xn.decrypt = dA;
function qF({ encryptedData: Y, privateKey: X }) {
  if ((0, Ji.isNullish)(Y))
    throw new Error("Missing encryptedData parameter");
  if ((0, Ji.isNullish)(X))
    throw new Error("Missing privateKey parameter");
  return JSON.parse(dA({ encryptedData: Y, privateKey: X })).data;
}
Xn.decryptSafely = qF;
function GF(Y) {
  const X = hA(Y), ee = To.box.keyPair.fromSecretKey(X).publicKey;
  return gi.encodeBase64(ee);
}
Xn.getEncryptionPublicKey = GF;
function hA(Y) {
  const X = Buffer.from(Y, "hex").toString("base64");
  return gi.decodeBase64(X);
}
(function(Y) {
  var X = St && St.__createBinding || (Object.create ? function(ne, ie, oe, se) {
    se === void 0 && (se = oe);
    var ae = Object.getOwnPropertyDescriptor(ie, oe);
    (!ae || ("get" in ae ? !ie.__esModule : ae.writable || ae.configurable)) && (ae = { enumerable: !0, get: function() {
      return ie[oe];
    } }), Object.defineProperty(ne, se, ae);
  } : function(ne, ie, oe, se) {
    se === void 0 && (se = oe), ne[se] = ie[oe];
  }), ee = St && St.__exportStar || function(ne, ie) {
    for (var oe in ne)
      oe !== "default" && !Object.prototype.hasOwnProperty.call(ie, oe) && X(ie, ne, oe);
  };
  Object.defineProperty(Y, "__esModule", { value: !0 }), Y.normalize = Y.concatSig = void 0, ee(to, Y), ee(Y3, Y), ee(Xn, Y);
  var te = tn;
  Object.defineProperty(Y, "concatSig", { enumerable: !0, get: function() {
    return te.concatSig;
  } }), Object.defineProperty(Y, "normalize", { enumerable: !0, get: function() {
    return te.normalize;
  } });
})(w6);
const VF = [
  {
    constant: !0,
    inputs: [],
    name: "name",
    outputs: [{ name: "", type: "string" }],
    payable: !1,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: !1,
    inputs: [
      { name: "_spender", type: "address" },
      { name: "_value", type: "uint256" }
    ],
    name: "approve",
    outputs: [{ name: "", type: "bool" }],
    payable: !1,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: !0,
    inputs: [],
    name: "totalSupply",
    outputs: [{ name: "", type: "uint256" }],
    payable: !1,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: !1,
    inputs: [
      { name: "_from", type: "address" },
      { name: "_to", type: "address" },
      { name: "_value", type: "uint256" }
    ],
    name: "transferFrom",
    outputs: [{ name: "", type: "bool" }],
    payable: !1,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: !0,
    inputs: [],
    name: "decimals",
    outputs: [{ name: "", type: "uint8" }],
    payable: !1,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: !0,
    inputs: [{ name: "_owner", type: "address" }],
    name: "balanceOf",
    outputs: [{ name: "balance", type: "uint256" }],
    payable: !1,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: !0,
    inputs: [],
    name: "symbol",
    outputs: [{ name: "", type: "string" }],
    payable: !1,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: !1,
    inputs: [
      { name: "_to", type: "address" },
      { name: "_value", type: "uint256" }
    ],
    name: "transfer",
    outputs: [{ name: "", type: "bool" }],
    payable: !1,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: !0,
    inputs: [
      { name: "_owner", type: "address" },
      { name: "_spender", type: "address" }
    ],
    name: "allowance",
    outputs: [{ name: "", type: "uint256" }],
    payable: !1,
    stateMutability: "view",
    type: "function"
  },
  { payable: !0, stateMutability: "payable", type: "fallback" },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, name: "owner", type: "address" },
      { indexed: !0, name: "spender", type: "address" },
      { indexed: !1, name: "value", type: "uint256" }
    ],
    name: "Approval",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, name: "from", type: "address" },
      { indexed: !0, name: "to", type: "address" },
      { indexed: !1, name: "value", type: "uint256" }
    ],
    name: "Transfer",
    type: "event"
  }
], WF = [
  {
    constant: !1,
    inputs: [{ name: "_referral", type: "address" }],
    name: "submit",
    outputs: [{ name: "", type: "uint256" }],
    payable: !0,
    stateMutability: "payable",
    type: "function"
  }
], KF = "0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84", as = {
  ETH: "https://etherscan.io",
  POLYGON: "https://polygonscan.com",
  AVALANCHE: "https://snowtrace.io",
  ARBITRUM: "https://arbiscan.io",
  BINANCE: "https://bscscan.com",
  OPTIMISM: "https://optimistic.etherscan.io",
  FANTOM: "https://ftmscan.com",
  SOLANA: "https://solscan.io",
  APTOS: "https://explorer.aptoslabs.com",
  NEO: "https://neo3.neotube.io",
  SUI: "https://suiexplorer.com/?network=mainnet",
  FUSE: "https://explorer.fuse.io",
  MUMBAI: "https://mumbai.polygonscan.com"
}, JF = {
  ETH: `${as.ETH}/tx`,
  // /txHash
  POLYGON: `${as.POLYGON}/tx`,
  AVALANCHE: `${as.AVALANCHE}/tx`,
  ARBITRUM: `${as.ARBITRUM}/tx`,
  BINANCE: `${as.BINANCE}/tx`,
  OPTIMISM: `${as.OPTIMISM}/tx`,
  FANTOM: `${as.FANTOM}/tx`,
  FUSE: `${as.FUSE}/tx`,
  MUMBAI: `${as.MUMBAI}/tx`
}, $w = {
  ETH: {
    name: "Ether",
    symbol: "ETH",
    logoUrl: "https://www.datocms-assets.com/86369/1669619533-ethereum.png"
  },
  POLYGON: {
    name: "Matic Token",
    symbol: "MATIC",
    logoUrl: "https://logos.covalenthq.com/tokens/1/0x7d1afa7b718fb893db30a3abc0cfc608aacfebb0.png"
  },
  AVALANCHE: {
    name: "Avalanche Coin",
    symbol: "AVAX",
    logoUrl: "https://www.datocms-assets.com/86369/1686152997-avalanche-colour.png"
  },
  ARBITRUM: {
    name: "Arbitrum Mainnet Ether",
    symbol: "ETH",
    logoUrl: "https://www.datocms-assets.com/86369/1669925028-arbitrum.png"
  },
  BINANCE: {
    name: "Binance Coin",
    symbol: "BNB",
    logoUrl: "https://www.datocms-assets.com/86369/1670003837-biance-smart-chain-colour.png"
  },
  OPTIMISM: {
    name: "Ether",
    symbol: "ETH",
    logoUrl: "https://www.datocms-assets.com/86369/1670347461-optimisim-colour.png"
  },
  FANTOM: {
    name: "Fantom",
    symbol: "FTM",
    logoUrl: "https://www.datocms-assets.com/86369/1669925359-fantom-1.png"
  },
  FUSE: {
    name: "Fuse",
    symbol: "FUSE",
    logoUrl: "https://assets.coingecko.com/coins/images/10347/standard/fuse.png"
  },
  MUMBAI: {
    name: "Matic Token",
    symbol: "MATIC",
    logoUrl: "https://logos.covalenthq.com/tokens/1/0x7d1afa7b718fb893db30a3abc0cfc608aacfebb0.png"
  }
}, YF = [
  "ETH",
  "POLYGON",
  "AVALANCHE",
  "ARBITRUM",
  "BINANCE",
  "OPTIMISM",
  "FANTOM",
  "FUSE",
  "MUMBAI"
], Kn = (Y) => YF.includes(Y), ku = (Y) => pr(Y), XF = [
  {
    inputs: [
      {
        internalType: "string",
        name: "uri_",
        type: "string"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: !0,
        internalType: "address",
        name: "operator",
        type: "address"
      },
      {
        indexed: !1,
        internalType: "bool",
        name: "approved",
        type: "bool"
      }
    ],
    name: "ApprovalForAll",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        internalType: "address",
        name: "operator",
        type: "address"
      },
      {
        indexed: !0,
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        indexed: !0,
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        indexed: !1,
        internalType: "uint256[]",
        name: "ids",
        type: "uint256[]"
      },
      {
        indexed: !1,
        internalType: "uint256[]",
        name: "values",
        type: "uint256[]"
      }
    ],
    name: "TransferBatch",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        internalType: "address",
        name: "operator",
        type: "address"
      },
      {
        indexed: !0,
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        indexed: !0,
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        indexed: !1,
        internalType: "uint256",
        name: "id",
        type: "uint256"
      },
      {
        indexed: !1,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "TransferSingle",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !1,
        internalType: "string",
        name: "value",
        type: "string"
      },
      {
        indexed: !0,
        internalType: "uint256",
        name: "id",
        type: "uint256"
      }
    ],
    name: "URI",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "id",
        type: "uint256"
      }
    ],
    name: "balanceOf",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address[]",
        name: "accounts",
        type: "address[]"
      },
      {
        internalType: "uint256[]",
        name: "ids",
        type: "uint256[]"
      }
    ],
    name: "balanceOfBatch",
    outputs: [
      {
        internalType: "uint256[]",
        name: "",
        type: "uint256[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        internalType: "address",
        name: "operator",
        type: "address"
      }
    ],
    name: "isApprovedForAll",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256[]",
        name: "ids",
        type: "uint256[]"
      },
      {
        internalType: "uint256[]",
        name: "amounts",
        type: "uint256[]"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "safeBatchTransferFrom",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "id",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "safeTransferFrom",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "operator",
        type: "address"
      },
      {
        internalType: "bool",
        name: "approved",
        type: "bool"
      }
    ],
    name: "setApprovalForAll",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes4",
        name: "interfaceId",
        type: "bytes4"
      }
    ],
    name: "supportsInterface",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    name: "uri",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
], ZF = [
  {
    inputs: [
      {
        internalType: "string",
        name: "name_",
        type: "string"
      },
      {
        internalType: "string",
        name: "symbol_",
        type: "string"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        indexed: !0,
        internalType: "address",
        name: "approved",
        type: "address"
      },
      {
        indexed: !0,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "Approval",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        indexed: !0,
        internalType: "address",
        name: "operator",
        type: "address"
      },
      {
        indexed: !1,
        internalType: "bool",
        name: "approved",
        type: "bool"
      }
    ],
    name: "ApprovalForAll",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        indexed: !0,
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        indexed: !0,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "Transfer",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "approve",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      }
    ],
    name: "balanceOf",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "getApproved",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        internalType: "address",
        name: "operator",
        type: "address"
      }
    ],
    name: "isApprovedForAll",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "name",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "ownerOf",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "safeTransferFrom",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "safeTransferFrom",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "operator",
        type: "address"
      },
      {
        internalType: "bool",
        name: "approved",
        type: "bool"
      }
    ],
    name: "setApprovalForAll",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes4",
        name: "interfaceId",
        type: "bytes4"
      }
    ],
    name: "supportsInterface",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "symbol",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "tokenURI",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "transferFrom",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
], QF = [
  {
    inputs: [],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: !0,
        internalType: "address",
        name: "operator",
        type: "address"
      },
      {
        indexed: !1,
        internalType: "bool",
        name: "approved",
        type: "bool"
      }
    ],
    name: "ApprovalForAll",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !1,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        indexed: !1,
        internalType: "address",
        name: "claimer",
        type: "address"
      }
    ],
    name: "CouponClaimed",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !1,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        indexed: !1,
        internalType: "address",
        name: "creator",
        type: "address"
      }
    ],
    name: "CouponCreated",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        internalType: "address",
        name: "previousOwner",
        type: "address"
      },
      {
        indexed: !0,
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "OwnershipTransferred",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        internalType: "address",
        name: "operator",
        type: "address"
      },
      {
        indexed: !0,
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        indexed: !0,
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        indexed: !1,
        internalType: "uint256[]",
        name: "ids",
        type: "uint256[]"
      },
      {
        indexed: !1,
        internalType: "uint256[]",
        name: "values",
        type: "uint256[]"
      }
    ],
    name: "TransferBatch",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        internalType: "address",
        name: "operator",
        type: "address"
      },
      {
        indexed: !0,
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        indexed: !0,
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        indexed: !1,
        internalType: "uint256",
        name: "id",
        type: "uint256"
      },
      {
        indexed: !1,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "TransferSingle",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !1,
        internalType: "string",
        name: "value",
        type: "string"
      },
      {
        indexed: !0,
        internalType: "uint256",
        name: "id",
        type: "uint256"
      }
    ],
    name: "URI",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "id",
        type: "uint256"
      }
    ],
    name: "balanceOf",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address[]",
        name: "accounts",
        type: "address[]"
      },
      {
        internalType: "uint256[]",
        name: "ids",
        type: "uint256[]"
      }
    ],
    name: "balanceOfBatch",
    outputs: [
      {
        internalType: "uint256[]",
        name: "",
        type: "uint256[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "id",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "burn",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_tokenID",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "_claimer",
        type: "address"
      }
    ],
    name: "claimCoupon",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_creator",
        type: "address"
      },
      {
        internalType: "string",
        name: "_tokenURI",
        type: "string"
      }
    ],
    name: "createCoupon",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        internalType: "address",
        name: "operator",
        type: "address"
      }
    ],
    name: "isApprovedForAll",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "owner",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "renounceOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256[]",
        name: "ids",
        type: "uint256[]"
      },
      {
        internalType: "uint256[]",
        name: "amounts",
        type: "uint256[]"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "safeBatchTransferFrom",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "id",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "safeTransferFrom",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "operator",
        type: "address"
      },
      {
        internalType: "bool",
        name: "approved",
        type: "bool"
      }
    ],
    name: "setApprovalForAll",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes4",
        name: "interfaceId",
        type: "bytes4"
      }
    ],
    name: "supportsInterface",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "transferOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "uri",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "varieties",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
], e$ = "2.7.19", t$ = (Y) => Y, pA = (Y) => Y, r$ = () => `viem@${e$}`;
let Le = class mY extends Error {
  constructor(X, ee = {}) {
    var te;
    super(), Object.defineProperty(this, "details", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "docsPath", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "metaMessages", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "shortMessage", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ViemError"
    }), Object.defineProperty(this, "version", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: r$()
    });
    const ne = ee.cause instanceof mY ? ee.cause.details : (te = ee.cause) != null && te.message ? ee.cause.message : ee.details, ie = ee.cause instanceof mY && ee.cause.docsPath || ee.docsPath;
    this.message = [
      X || "An error occurred.",
      "",
      ...ee.metaMessages ? [...ee.metaMessages, ""] : [],
      ...ie ? [
        `Docs: https://viem.sh${ie}${ee.docsSlug ? `#${ee.docsSlug}` : ""}`
      ] : [],
      ...ne ? [`Details: ${ne}`] : [],
      `Version: ${this.version}`
    ].join(`
`), ee.cause && (this.cause = ee.cause), this.details = ne, this.docsPath = ie, this.metaMessages = ee.metaMessages, this.shortMessage = X;
  }
  walk(X) {
    return gA(this, X);
  }
};
function gA(Y, X) {
  return X != null && X(Y) ? Y : Y && typeof Y == "object" && "cause" in Y ? gA(Y.cause, X) : X ? null : Y;
}
class n$ extends Le {
  constructor({ max: X, min: ee, signed: te, size: ne, value: ie }) {
    super(`Number "${ie}" is not in safe ${ne ? `${ne * 8}-bit ${te ? "signed" : "unsigned"} ` : ""}integer range ${X ? `(${ee} to ${X})` : `(above ${ee})`}`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "IntegerOutOfRangeError"
    });
  }
}
class i$ extends Le {
  constructor(X) {
    super(`Bytes value "${X}" is not a valid boolean. The bytes array must contain a single byte of either a 0 or 1 value.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidBytesBooleanError"
    });
  }
}
class s$ extends Le {
  constructor({ givenSize: X, maxSize: ee }) {
    super(`Size cannot exceed ${ee} bytes. Given size: ${X} bytes.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "SizeOverflowError"
    });
  }
}
class mA extends Le {
  constructor({ offset: X, position: ee, size: te }) {
    super(`Slice ${ee === "start" ? "starting" : "ending"} at offset "${X}" is out-of-bounds (size: ${te}).`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "SliceOffsetOutOfBoundsError"
    });
  }
}
class yA extends Le {
  constructor({ size: X, targetSize: ee, type: te }) {
    super(`${te.charAt(0).toUpperCase()}${te.slice(1).toLowerCase()} size (${X}) exceeds padding size (${ee}).`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "SizeExceedsPaddingSizeError"
    });
  }
}
class Dw extends Le {
  constructor({ size: X, targetSize: ee, type: te }) {
    super(`${te.charAt(0).toUpperCase()}${te.slice(1).toLowerCase()} is expected to be ${ee} ${te} long, but is ${X} ${te} long.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidBytesLengthError"
    });
  }
}
function Ic(Y, { dir: X, size: ee = 32 } = {}) {
  return typeof Y == "string" ? no(Y, { dir: X, size: ee }) : o$(Y, { dir: X, size: ee });
}
function no(Y, { dir: X, size: ee = 32 } = {}) {
  if (ee === null)
    return Y;
  const te = Y.replace("0x", "");
  if (te.length > ee * 2)
    throw new yA({
      size: Math.ceil(te.length / 2),
      targetSize: ee,
      type: "hex"
    });
  return `0x${te[X === "right" ? "padEnd" : "padStart"](ee * 2, "0")}`;
}
function o$(Y, { dir: X, size: ee = 32 } = {}) {
  if (ee === null)
    return Y;
  if (Y.length > ee)
    throw new yA({
      size: Y.length,
      targetSize: ee,
      type: "bytes"
    });
  const te = new Uint8Array(ee);
  for (let ne = 0; ne < ee; ne++) {
    const ie = X === "right";
    te[ie ? ne : ee - ne - 1] = Y[ie ? ne : Y.length - ne - 1];
  }
  return te;
}
function es(Y, { strict: X = !0 } = {}) {
  return !Y || typeof Y != "string" ? !1 : X ? /^0x[0-9a-fA-F]*$/.test(Y) : Y.startsWith("0x");
}
function Hr(Y) {
  return es(Y, { strict: !1 }) ? Math.ceil((Y.length - 2) / 2) : Y.length;
}
function l0(Y, { dir: X = "left" } = {}) {
  let ee = typeof Y == "string" ? Y.replace("0x", "") : Y, te = 0;
  for (let ne = 0; ne < ee.length - 1 && ee[X === "left" ? ne : ee.length - ne - 1].toString() === "0"; ne++)
    te++;
  return ee = X === "left" ? ee.slice(te) : ee.slice(0, ee.length - te), typeof Y == "string" ? (ee.length === 1 && X === "right" && (ee = `${ee}0`), `0x${ee.length % 2 === 1 ? `0${ee}` : ee}`) : ee;
}
const a$ = /* @__PURE__ */ new TextEncoder();
function Do(Y, X = {}) {
  return typeof Y == "number" || typeof Y == "bigint" ? u$(Y, X) : typeof Y == "boolean" ? c$(Y, X) : es(Y) ? _y(Y, X) : As(Y, X);
}
function c$(Y, X = {}) {
  const ee = new Uint8Array(1);
  return ee[0] = Number(Y), typeof X.size == "number" ? (is$1(ee, { size: X.size }), Ic(ee, { size: X.size })) : ee;
}
const cs = {
  zero: 48,
  nine: 57,
  A: 65,
  F: 70,
  a: 97,
  f: 102
};
function Uw(Y) {
  if (Y >= cs.zero && Y <= cs.nine)
    return Y - cs.zero;
  if (Y >= cs.A && Y <= cs.F)
    return Y - (cs.A - 10);
  if (Y >= cs.a && Y <= cs.f)
    return Y - (cs.a - 10);
}
function _y(Y, X = {}) {
  let ee = Y;
  X.size && (is$1(ee, { size: X.size }), ee = Ic(ee, { dir: "right", size: X.size }));
  let te = ee.slice(2);
  te.length % 2 && (te = `0${te}`);
  const ne = te.length / 2, ie = new Uint8Array(ne);
  for (let oe = 0, se = 0; oe < ne; oe++) {
    const ae = Uw(te.charCodeAt(se++)), ue = Uw(te.charCodeAt(se++));
    if (ae === void 0 || ue === void 0)
      throw new Le(`Invalid byte sequence ("${te[se - 2]}${te[se - 1]}" in "${te}").`);
    ie[oe] = ae * 16 + ue;
  }
  return ie;
}
function u$(Y, X) {
  const ee = Rt(Y, X);
  return _y(ee);
}
function As(Y, X = {}) {
  const ee = a$.encode(Y);
  return typeof X.size == "number" ? (is$1(ee, { size: X.size }), Ic(ee, { dir: "right", size: X.size })) : ee;
}
function is$1(Y, { size: X }) {
  if (Hr(Y) > X)
    throw new s$({
      givenSize: Hr(Y),
      maxSize: X
    });
}
function d0(Y, X = {}) {
  const { signed: ee } = X;
  X.size && is$1(Y, { size: X.size });
  const te = BigInt(Y);
  if (!ee)
    return te;
  const ne = (Y.length - 2) / 2, ie = (1n << BigInt(ne) * 8n - 1n) - 1n;
  return te <= ie ? te : te - BigInt(`0x${"f".padStart(ne * 2, "f")}`) - 1n;
}
function co(Y, X = {}) {
  return Number(d0(Y, X));
}
const f$ = /* @__PURE__ */ Array.from({ length: 256 }, (Y, X) => X.toString(16).padStart(2, "0"));
function $s(Y, X = {}) {
  return typeof Y == "number" || typeof Y == "bigint" ? Rt(Y, X) : typeof Y == "string" ? Ay(Y, X) : typeof Y == "boolean" ? bA(Y, X) : wi(Y, X);
}
function bA(Y, X = {}) {
  const ee = `0x${Number(Y)}`;
  return typeof X.size == "number" ? (is$1(ee, { size: X.size }), Ic(ee, { size: X.size })) : ee;
}
function wi(Y, X = {}) {
  let ee = "";
  for (let ne = 0; ne < Y.length; ne++)
    ee += f$[Y[ne]];
  const te = `0x${ee}`;
  return typeof X.size == "number" ? (is$1(te, { size: X.size }), Ic(te, { dir: "right", size: X.size })) : te;
}
function Rt(Y, X = {}) {
  const { signed: ee, size: te } = X, ne = BigInt(Y);
  let ie;
  te ? ee ? ie = (1n << BigInt(te) * 8n - 1n) - 1n : ie = 2n ** (BigInt(te) * 8n) - 1n : typeof Y == "number" && (ie = BigInt(Number.MAX_SAFE_INTEGER));
  const oe = typeof ie == "bigint" && ee ? -ie - 1n : 0;
  if (ie && ne > ie || ne < oe) {
    const ae = typeof Y == "bigint" ? "n" : "";
    throw new n$({
      max: ie ? `${ie}${ae}` : void 0,
      min: `${oe}${ae}`,
      signed: ee,
      size: te,
      value: `${Y}${ae}`
    });
  }
  const se = `0x${(ee && ne < 0 ? (1n << BigInt(te * 8)) + BigInt(ne) : ne).toString(16)}`;
  return te ? Ic(se, { size: te }) : se;
}
const l$ = /* @__PURE__ */ new TextEncoder();
function Ay(Y, X = {}) {
  const ee = l$.encode(Y);
  return wi(ee, X);
}
async function d$(Y, { chain: X }) {
  const { id: ee, name: te, nativeCurrency: ne, rpcUrls: ie, blockExplorers: oe } = X;
  await Y.request({
    method: "wallet_addEthereumChain",
    params: [
      {
        chainId: Rt(ee),
        chainName: te,
        nativeCurrency: ne,
        rpcUrls: ie.default.http,
        blockExplorerUrls: oe ? Object.values(oe).map(({ url: se }) => se) : void 0
      }
    ]
  }, { retryCount: 0 });
}
function Ps(Y, { includeName: X = !1 } = {}) {
  if (Y.type !== "function" && Y.type !== "event" && Y.type !== "error")
    throw new S$(Y.type);
  return `${Y.name}(${h0(Y.inputs, { includeName: X })})`;
}
function h0(Y, { includeName: X = !1 } = {}) {
  return Y ? Y.map((ee) => h$(ee, { includeName: X })).join(X ? ", " : ",") : "";
}
function h$(Y, { includeName: X }) {
  return Y.type.startsWith("tuple") ? `(${h0(Y.components, { includeName: X })})${Y.type.slice(5)}` : Y.type + (X && Y.name ? ` ${Y.name}` : "");
}
class p$ extends Le {
  constructor({ docsPath: X }) {
    super([
      "A constructor was not found on the ABI.",
      "Make sure you are using the correct ABI and that the constructor exists on it."
    ].join(`
`), {
      docsPath: X
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiConstructorNotFoundError"
    });
  }
}
class jw extends Le {
  constructor({ docsPath: X }) {
    super([
      "Constructor arguments were provided (`args`), but a constructor parameters (`inputs`) were not found on the ABI.",
      "Make sure you are using the correct ABI, and that the `inputs` attribute on the constructor exists."
    ].join(`
`), {
      docsPath: X
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiConstructorParamsNotFoundError"
    });
  }
}
class xA extends Le {
  constructor({ data: X, params: ee, size: te }) {
    super([`Data size of ${te} bytes is too small for given parameters.`].join(`
`), {
      metaMessages: [
        `Params: (${h0(ee, { includeName: !0 })})`,
        `Data:   ${X} (${te} bytes)`
      ]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiDecodingDataSizeTooSmallError"
    }), Object.defineProperty(this, "data", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "params", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "size", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.data = X, this.params = ee, this.size = te;
  }
}
class p0 extends Le {
  constructor() {
    super('Cannot decode zero data ("0x") with ABI parameters.'), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiDecodingZeroDataError"
    });
  }
}
class g$ extends Le {
  constructor({ expectedLength: X, givenLength: ee, type: te }) {
    super([
      `ABI encoding array length mismatch for type ${te}.`,
      `Expected length: ${X}`,
      `Given length: ${ee}`
    ].join(`
`)), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiEncodingArrayLengthMismatchError"
    });
  }
}
class m$ extends Le {
  constructor({ expectedSize: X, value: ee }) {
    super(`Size of bytes "${ee}" (bytes${Hr(ee)}) does not match expected size (bytes${X}).`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiEncodingBytesSizeMismatchError"
    });
  }
}
class y$ extends Le {
  constructor({ expectedLength: X, givenLength: ee }) {
    super([
      "ABI encoding params/values length mismatch.",
      `Expected length (params): ${X}`,
      `Given length (values): ${ee}`
    ].join(`
`)), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiEncodingLengthMismatchError"
    });
  }
}
class wA extends Le {
  constructor(X, { docsPath: ee }) {
    super([
      `Encoded error signature "${X}" not found on ABI.`,
      "Make sure you are using the correct ABI and that the error exists on it.",
      `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${X}.`
    ].join(`
`), {
      docsPath: ee
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiErrorSignatureNotFoundError"
    }), Object.defineProperty(this, "signature", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.signature = X;
  }
}
class b$ extends Le {
  constructor({ docsPath: X }) {
    super("Cannot extract event signature from empty topics.", {
      docsPath: X
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiEventSignatureEmptyTopicsError"
    });
  }
}
class vA extends Le {
  constructor(X, { docsPath: ee }) {
    super([
      `Encoded event signature "${X}" not found on ABI.`,
      "Make sure you are using the correct ABI and that the event exists on it.",
      `You can look up the signature here: https://openchain.xyz/signatures?query=${X}.`
    ].join(`
`), {
      docsPath: ee
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiEventSignatureNotFoundError"
    });
  }
}
class Hw extends Le {
  constructor(X, { docsPath: ee } = {}) {
    super([
      `Event ${X ? `"${X}" ` : ""}not found on ABI.`,
      "Make sure you are using the correct ABI and that the event exists on it."
    ].join(`
`), {
      docsPath: ee
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiEventNotFoundError"
    });
  }
}
class Xl extends Le {
  constructor(X, { docsPath: ee } = {}) {
    super([
      `Function ${X ? `"${X}" ` : ""}not found on ABI.`,
      "Make sure you are using the correct ABI and that the function exists on it."
    ].join(`
`), {
      docsPath: ee
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiFunctionNotFoundError"
    });
  }
}
class x$ extends Le {
  constructor(X, { docsPath: ee }) {
    super([
      `Function "${X}" does not contain any \`outputs\` on ABI.`,
      "Cannot decode function result without knowing what the parameter types are.",
      "Make sure you are using the correct ABI and that the function exists on it."
    ].join(`
`), {
      docsPath: ee
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiFunctionOutputsNotFoundError"
    });
  }
}
class w$ extends Le {
  constructor(X, ee) {
    super("Found ambiguous types in overloaded ABI items.", {
      metaMessages: [
        `\`${X.type}\` in \`${Ps(X.abiItem)}\`, and`,
        `\`${ee.type}\` in \`${Ps(ee.abiItem)}\``,
        "",
        "These types encode differently and cannot be distinguished at runtime.",
        "Remove one of the ambiguous items in the ABI."
      ]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AbiItemAmbiguityError"
    });
  }
}
class v$ extends Le {
  constructor({ expectedSize: X, givenSize: ee }) {
    super(`Expected bytes${X}, got bytes${ee}.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "BytesSizeMismatchError"
    });
  }
}
class Mu extends Le {
  constructor({ abiItem: X, data: ee, params: te, size: ne }) {
    super([
      `Data size of ${ne} bytes is too small for non-indexed event parameters.`
    ].join(`
`), {
      metaMessages: [
        `Params: (${h0(te, { includeName: !0 })})`,
        `Data:   ${ee} (${ne} bytes)`
      ]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "DecodeLogDataMismatch"
    }), Object.defineProperty(this, "abiItem", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "data", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "params", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "size", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.abiItem = X, this.data = ee, this.params = te, this.size = ne;
  }
}
class g0 extends Le {
  constructor({ abiItem: X, param: ee }) {
    super([
      `Expected a topic for indexed event parameter${ee.name ? ` "${ee.name}"` : ""} on event "${Ps(X, { includeName: !0 })}".`
    ].join(`
`)), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "DecodeLogTopicsMismatch"
    }), Object.defineProperty(this, "abiItem", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.abiItem = X;
  }
}
class E$ extends Le {
  constructor(X, { docsPath: ee }) {
    super([
      `Type "${X}" is not a valid encoding type.`,
      "Please provide a valid ABI type."
    ].join(`
`), { docsPath: ee }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidAbiEncodingType"
    });
  }
}
class _$ extends Le {
  constructor(X, { docsPath: ee }) {
    super([
      `Type "${X}" is not a valid decoding type.`,
      "Please provide a valid ABI type."
    ].join(`
`), { docsPath: ee }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidAbiDecodingType"
    });
  }
}
class A$ extends Le {
  constructor(X) {
    super([`Value "${X}" is not a valid array.`].join(`
`)), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidArrayError"
    });
  }
}
class S$ extends Le {
  constructor(X) {
    super([
      `"${X}" is not a valid definition type.`,
      'Valid types: "function", "event", "error"'
    ].join(`
`)), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidDefinitionTypeError"
    });
  }
}
function Os(Y) {
  return typeof Y[0] == "string" ? Sy(Y) : T$(Y);
}
function T$(Y) {
  let X = 0;
  for (const ne of Y)
    X += ne.length;
  const ee = new Uint8Array(X);
  let te = 0;
  for (const ne of Y)
    ee.set(ne, te), te += ne.length;
  return ee;
}
function Sy(Y) {
  return `0x${Y.reduce((X, ee) => X + ee.replace("0x", ""), "")}`;
}
class Za extends Le {
  constructor({ address: X }) {
    super(`Address "${X}" is invalid.`, {
      metaMessages: [
        "- Address must be a hex value of 20 bytes (40 hex characters).",
        "- Address must match its checksum counterpart."
      ]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidAddressError"
    });
  }
}
class I$ extends Map {
  constructor(X) {
    super(), Object.defineProperty(this, "maxSize", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.maxSize = X;
  }
  set(X, ee) {
    return super.set(X, ee), this.maxSize && this.size > this.maxSize && this.delete(this.keys().next().value), this;
  }
}
function zw(Y) {
  if (!Number.isSafeInteger(Y) || Y < 0)
    throw new Error(`Wrong positive integer: ${Y}`);
}
function EA(Y, ...X) {
  if (!(Y instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (X.length > 0 && !X.includes(Y.length))
    throw new Error(`Expected Uint8Array of length ${X}, not of length=${Y.length}`);
}
function qw(Y, X = !0) {
  if (Y.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (X && Y.finished)
    throw new Error("Hash#digest() has already been called");
}
function R$(Y, X) {
  EA(Y);
  const ee = X.outputLen;
  if (Y.length < ee)
    throw new Error(`digestInto() expects output buffer of length at least ${ee}`);
}
const Qf = /* @__PURE__ */ BigInt(2 ** 32 - 1), Gw = /* @__PURE__ */ BigInt(32);
function C$(Y, X = !1) {
  return X ? { h: Number(Y & Qf), l: Number(Y >> Gw & Qf) } : { h: Number(Y >> Gw & Qf) | 0, l: Number(Y & Qf) | 0 };
}
function P$(Y, X = !1) {
  let ee = new Uint32Array(Y.length), te = new Uint32Array(Y.length);
  for (let ne = 0; ne < Y.length; ne++) {
    const { h: ie, l: oe } = C$(Y[ne], X);
    [ee[ne], te[ne]] = [ie, oe];
  }
  return [ee, te];
}
const O$ = (Y, X, ee) => Y << ee | X >>> 32 - ee, B$ = (Y, X, ee) => X << ee | Y >>> 32 - ee, N$ = (Y, X, ee) => X << ee - 32 | Y >>> 64 - ee, k$ = (Y, X, ee) => Y << ee - 32 | X >>> 64 - ee;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const M$ = (Y) => Y instanceof Uint8Array, L$ = (Y) => new Uint32Array(Y.buffer, Y.byteOffset, Math.floor(Y.byteLength / 4)), F$ = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!F$)
  throw new Error("Non little-endian hardware is not supported");
function $$(Y) {
  if (typeof Y != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof Y}`);
  return new Uint8Array(new TextEncoder().encode(Y));
}
function _A(Y) {
  if (typeof Y == "string" && (Y = $$(Y)), !M$(Y))
    throw new Error(`expected Uint8Array, got ${typeof Y}`);
  return Y;
}
class D$ {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
}
function U$(Y) {
  const X = (te) => Y().update(_A(te)).digest(), ee = Y();
  return X.outputLen = ee.outputLen, X.blockLen = ee.blockLen, X.create = () => Y(), X;
}
const [AA, SA, TA] = [[], [], []], j$ = /* @__PURE__ */ BigInt(0), Xc = /* @__PURE__ */ BigInt(1), H$ = /* @__PURE__ */ BigInt(2), z$ = /* @__PURE__ */ BigInt(7), q$ = /* @__PURE__ */ BigInt(256), G$ = /* @__PURE__ */ BigInt(113);
for (let Y = 0, X = Xc, ee = 1, te = 0; Y < 24; Y++) {
  [ee, te] = [te, (2 * ee + 3 * te) % 5], AA.push(2 * (5 * te + ee)), SA.push((Y + 1) * (Y + 2) / 2 % 64);
  let ne = j$;
  for (let ie = 0; ie < 7; ie++)
    X = (X << Xc ^ (X >> z$) * G$) % q$, X & H$ && (ne ^= Xc << (Xc << /* @__PURE__ */ BigInt(ie)) - Xc);
  TA.push(ne);
}
const [V$, W$] = /* @__PURE__ */ P$(TA, !0), Vw = (Y, X, ee) => ee > 32 ? N$(Y, X, ee) : O$(Y, X, ee), Ww = (Y, X, ee) => ee > 32 ? k$(Y, X, ee) : B$(Y, X, ee);
function K$(Y, X = 24) {
  const ee = new Uint32Array(10);
  for (let te = 24 - X; te < 24; te++) {
    for (let oe = 0; oe < 10; oe++)
      ee[oe] = Y[oe] ^ Y[oe + 10] ^ Y[oe + 20] ^ Y[oe + 30] ^ Y[oe + 40];
    for (let oe = 0; oe < 10; oe += 2) {
      const se = (oe + 8) % 10, ae = (oe + 2) % 10, ue = ee[ae], le = ee[ae + 1], he = Vw(ue, le, 1) ^ ee[se], me = Ww(ue, le, 1) ^ ee[se + 1];
      for (let ye = 0; ye < 50; ye += 10)
        Y[oe + ye] ^= he, Y[oe + ye + 1] ^= me;
    }
    let ne = Y[2], ie = Y[3];
    for (let oe = 0; oe < 24; oe++) {
      const se = SA[oe], ae = Vw(ne, ie, se), ue = Ww(ne, ie, se), le = AA[oe];
      ne = Y[le], ie = Y[le + 1], Y[le] = ae, Y[le + 1] = ue;
    }
    for (let oe = 0; oe < 50; oe += 10) {
      for (let se = 0; se < 10; se++)
        ee[se] = Y[oe + se];
      for (let se = 0; se < 10; se++)
        Y[oe + se] ^= ~ee[(se + 2) % 10] & ee[(se + 4) % 10];
    }
    Y[0] ^= V$[te], Y[1] ^= W$[te];
  }
  ee.fill(0);
}
class Ty extends D$ {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(X, ee, te, ne = !1, ie = 24) {
    if (super(), this.blockLen = X, this.suffix = ee, this.outputLen = te, this.enableXOF = ne, this.rounds = ie, this.pos = 0, this.posOut = 0, this.finished = !1, this.destroyed = !1, zw(te), 0 >= this.blockLen || this.blockLen >= 200)
      throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200), this.state32 = L$(this.state);
  }
  keccak() {
    K$(this.state32, this.rounds), this.posOut = 0, this.pos = 0;
  }
  update(X) {
    qw(this);
    const { blockLen: ee, state: te } = this;
    X = _A(X);
    const ne = X.length;
    for (let ie = 0; ie < ne; ) {
      const oe = Math.min(ee - this.pos, ne - ie);
      for (let se = 0; se < oe; se++)
        te[this.pos++] ^= X[ie++];
      this.pos === ee && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = !0;
    const { state: X, suffix: ee, pos: te, blockLen: ne } = this;
    X[te] ^= ee, ee & 128 && te === ne - 1 && this.keccak(), X[ne - 1] ^= 128, this.keccak();
  }
  writeInto(X) {
    qw(this, !1), EA(X), this.finish();
    const ee = this.state, { blockLen: te } = this;
    for (let ne = 0, ie = X.length; ne < ie; ) {
      this.posOut >= te && this.keccak();
      const oe = Math.min(te - this.posOut, ie - ne);
      X.set(ee.subarray(this.posOut, this.posOut + oe), ne), this.posOut += oe, ne += oe;
    }
    return X;
  }
  xofInto(X) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(X);
  }
  xof(X) {
    return zw(X), this.xofInto(new Uint8Array(X));
  }
  digestInto(X) {
    if (R$(X, this), this.finished)
      throw new Error("digest() was already called");
    return this.writeInto(X), this.destroy(), X;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = !0, this.state.fill(0);
  }
  _cloneInto(X) {
    const { blockLen: ee, suffix: te, outputLen: ne, rounds: ie, enableXOF: oe } = this;
    return X || (X = new Ty(ee, te, ne, oe, ie)), X.state32.set(this.state32), X.pos = this.pos, X.posOut = this.posOut, X.finished = this.finished, X.rounds = ie, X.suffix = te, X.outputLen = ne, X.enableXOF = oe, X.destroyed = this.destroyed, X;
  }
}
const J$ = (Y, X, ee) => U$(() => new Ty(X, Y, ee)), Y$ = /* @__PURE__ */ J$(1, 136, 256 / 8);
function Rn(Y, X) {
  const ee = X || "hex", te = Y$(es(Y, { strict: !1 }) ? Do(Y) : Y);
  return ee === "bytes" ? te : $s(te);
}
function m0(Y, X) {
  const ee = X ? `${X}${Y.toLowerCase()}` : Y.substring(2).toLowerCase(), te = Rn(As(ee), "bytes"), ne = (X ? ee.substring(`${X}0x`.length) : ee).split("");
  for (let ie = 0; ie < 40; ie += 2)
    te[ie >> 1] >> 4 >= 8 && ne[ie] && (ne[ie] = ne[ie].toUpperCase()), (te[ie >> 1] & 15) >= 8 && ne[ie + 1] && (ne[ie + 1] = ne[ie + 1].toUpperCase());
  return `0x${ne.join("")}`;
}
function X$(Y, X) {
  if (!Bs(Y))
    throw new Za({ address: Y });
  return m0(Y, X);
}
const Z$ = /^0x[a-fA-F0-9]{40}$/, gp = /* @__PURE__ */ new I$(8192);
function Bs(Y, { strict: X = !0 } = {}) {
  if (gp.has(Y))
    return gp.get(Y);
  const ee = Z$.test(Y) ? Y.toLowerCase() === Y ? !0 : X ? m0(Y) === Y : !0 : !1;
  return gp.set(Y, ee), ee;
}
function Zl(Y, X, ee, { strict: te } = {}) {
  return es(Y, { strict: !1 }) ? Q$(Y, X, ee, {
    strict: te
  }) : CA(Y, X, ee, {
    strict: te
  });
}
function IA(Y, X) {
  if (typeof X == "number" && X > 0 && X > Hr(Y) - 1)
    throw new mA({
      offset: X,
      position: "start",
      size: Hr(Y)
    });
}
function RA(Y, X, ee) {
  if (typeof X == "number" && typeof ee == "number" && Hr(Y) !== ee - X)
    throw new mA({
      offset: ee,
      position: "end",
      size: Hr(Y)
    });
}
function CA(Y, X, ee, { strict: te } = {}) {
  IA(Y, X);
  const ne = Y.slice(X, ee);
  return te && RA(ne, X, ee), ne;
}
function Q$(Y, X, ee, { strict: te } = {}) {
  IA(Y, X);
  const ne = `0x${Y.replace("0x", "").slice((X ?? 0) * 2, (ee ?? Y.length) * 2)}`;
  return te && RA(ne, X, ee), ne;
}
function _f(Y, X) {
  if (Y.length !== X.length)
    throw new y$({
      expectedLength: Y.length,
      givenLength: X.length
    });
  const ee = eD({
    params: Y,
    values: X
  }), te = Ry(ee);
  return te.length === 0 ? "0x" : te;
}
function eD({ params: Y, values: X }) {
  const ee = [];
  for (let te = 0; te < Y.length; te++)
    ee.push(Iy({ param: Y[te], value: X[te] }));
  return ee;
}
function Iy({ param: Y, value: X }) {
  const ee = Cy(Y.type);
  if (ee) {
    const [te, ne] = ee;
    return rD(X, { length: te, param: { ...Y, type: ne } });
  }
  if (Y.type === "tuple")
    return aD(X, {
      param: Y
    });
  if (Y.type === "address")
    return tD(X);
  if (Y.type === "bool")
    return iD(X);
  if (Y.type.startsWith("uint") || Y.type.startsWith("int")) {
    const te = Y.type.startsWith("int");
    return sD(X, { signed: te });
  }
  if (Y.type.startsWith("bytes"))
    return nD(X, { param: Y });
  if (Y.type === "string")
    return oD(X);
  throw new E$(Y.type, {
    docsPath: "/docs/contract/encodeAbiParameters"
  });
}
function Ry(Y) {
  let X = 0;
  for (let ie = 0; ie < Y.length; ie++) {
    const { dynamic: oe, encoded: se } = Y[ie];
    oe ? X += 32 : X += Hr(se);
  }
  const ee = [], te = [];
  let ne = 0;
  for (let ie = 0; ie < Y.length; ie++) {
    const { dynamic: oe, encoded: se } = Y[ie];
    oe ? (ee.push(Rt(X + ne, { size: 32 })), te.push(se), ne += Hr(se)) : ee.push(se);
  }
  return Os([...ee, ...te]);
}
function tD(Y) {
  if (!Bs(Y))
    throw new Za({ address: Y });
  return { dynamic: !1, encoded: no(Y.toLowerCase()) };
}
function rD(Y, { length: X, param: ee }) {
  const te = X === null;
  if (!Array.isArray(Y))
    throw new A$(Y);
  if (!te && Y.length !== X)
    throw new g$({
      expectedLength: X,
      givenLength: Y.length,
      type: `${ee.type}[${X}]`
    });
  let ne = !1;
  const ie = [];
  for (let oe = 0; oe < Y.length; oe++) {
    const se = Iy({ param: ee, value: Y[oe] });
    se.dynamic && (ne = !0), ie.push(se);
  }
  if (te || ne) {
    const oe = Ry(ie);
    if (te) {
      const se = Rt(ie.length, { size: 32 });
      return {
        dynamic: !0,
        encoded: ie.length > 0 ? Os([se, oe]) : se
      };
    }
    if (ne)
      return { dynamic: !0, encoded: oe };
  }
  return {
    dynamic: !1,
    encoded: Os(ie.map(({ encoded: oe }) => oe))
  };
}
function nD(Y, { param: X }) {
  const [, ee] = X.type.split("bytes"), te = Hr(Y);
  if (!ee) {
    let ne = Y;
    return te % 32 !== 0 && (ne = no(ne, {
      dir: "right",
      size: Math.ceil((Y.length - 2) / 2 / 32) * 32
    })), {
      dynamic: !0,
      encoded: Os([no(Rt(te, { size: 32 })), ne])
    };
  }
  if (te !== parseInt(ee))
    throw new m$({
      expectedSize: parseInt(ee),
      value: Y
    });
  return { dynamic: !1, encoded: no(Y, { dir: "right" }) };
}
function iD(Y) {
  return { dynamic: !1, encoded: no(bA(Y)) };
}
function sD(Y, { signed: X }) {
  return {
    dynamic: !1,
    encoded: Rt(Y, {
      size: 32,
      signed: X
    })
  };
}
function oD(Y) {
  const X = Ay(Y), ee = Math.ceil(Hr(X) / 32), te = [];
  for (let ne = 0; ne < ee; ne++)
    te.push(no(Zl(X, ne * 32, (ne + 1) * 32), {
      dir: "right"
    }));
  return {
    dynamic: !0,
    encoded: Os([
      no(Rt(Hr(X), { size: 32 })),
      ...te
    ])
  };
}
function aD(Y, { param: X }) {
  let ee = !1;
  const te = [];
  for (let ne = 0; ne < X.components.length; ne++) {
    const ie = X.components[ne], oe = Array.isArray(Y) ? ne : ie.name, se = Iy({
      param: ie,
      value: Y[oe]
    });
    te.push(se), se.dynamic && (ee = !0);
  }
  return {
    dynamic: ee,
    encoded: ee ? Ry(te) : Os(te.map(({ encoded: ne }) => ne))
  };
}
function Cy(Y) {
  const X = Y.match(/^(.*)\[(\d+)?\]$/);
  return X ? (
    // Return `null` if the array is dynamic.
    [X[2] ? Number(X[2]) : null, X[1]]
  ) : void 0;
}
const mp = "/docs/contract/encodeDeployData";
function PA(Y) {
  const { abi: X, args: ee, bytecode: te } = Y;
  if (!ee || ee.length === 0)
    return te;
  const ne = X.find((oe) => "type" in oe && oe.type === "constructor");
  if (!ne)
    throw new p$({ docsPath: mp });
  if (!("inputs" in ne))
    throw new jw({ docsPath: mp });
  if (!ne.inputs || ne.inputs.length === 0)
    throw new jw({ docsPath: mp });
  const ie = _f(ne.inputs, ee);
  return Sy([te, ie]);
}
function Hn(Y) {
  return typeof Y == "string" ? { address: Y, type: "json-rpc" } : Y;
}
class y0 extends Le {
  constructor({ docsPath: X } = {}) {
    super([
      "Could not find an Account to execute with this Action.",
      "Please provide an Account with the `account` argument on the Action, or by supplying an `account` to the WalletClient."
    ].join(`
`), {
      docsPath: X,
      docsSlug: "account"
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AccountNotFoundError"
    });
  }
}
class ag extends Le {
  constructor({ blockNumber: X, chain: ee, contract: te }) {
    super(`Chain "${ee.name}" does not support contract "${te.name}".`, {
      metaMessages: [
        "This could be due to any of the following:",
        ...X && te.blockCreated && te.blockCreated > X ? [
          `- The contract "${te.name}" was not deployed until block ${te.blockCreated} (current block ${X}).`
        ] : [
          `- The chain does not have the contract "${te.name}" configured.`
        ]
      ]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ChainDoesNotSupportContract"
    });
  }
}
class cD extends Le {
  constructor({ chain: X, currentChainId: ee }) {
    super(`The current chain of the wallet (id: ${ee}) does not match the target chain for the transaction (id: ${X.id}  ${X.name}).`, {
      metaMessages: [
        `Current Chain ID:  ${ee}`,
        `Expected Chain ID: ${X.id}  ${X.name}`
      ]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ChainMismatchError"
    });
  }
}
class uD extends Le {
  constructor() {
    super([
      "No chain was provided to the request.",
      "Please provide a chain with the `chain` argument on the Action, or by supplying a `chain` to WalletClient."
    ].join(`
`)), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ChainNotFoundError"
    });
  }
}
class OA extends Le {
  constructor() {
    super("No chain was provided to the Client."), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ClientChainNotConfiguredError"
    });
  }
}
function BA({ chain: Y, currentChainId: X }) {
  if (!Y)
    throw new uD();
  if (X !== Y.id)
    throw new cD({ chain: Y, currentChainId: X });
}
const fD = {
  gwei: 9,
  wei: 18
}, lD = {
  ether: -9,
  wei: 9
};
function NA(Y, X) {
  let ee = Y.toString();
  const te = ee.startsWith("-");
  te && (ee = ee.slice(1)), ee = ee.padStart(X, "0");
  let [ne, ie] = [
    ee.slice(0, ee.length - X),
    ee.slice(ee.length - X)
  ];
  return ie = ie.replace(/(0+)$/, ""), `${te ? "-" : ""}${ne || "0"}${ie ? `.${ie}` : ""}`;
}
function Cn(Y, X = "wei") {
  return NA(Y, lD[X]);
}
class xa extends Le {
  constructor({ cause: X, message: ee } = {}) {
    var te;
    const ne = (te = ee == null ? void 0 : ee.replace("execution reverted: ", "")) == null ? void 0 : te.replace("execution reverted", "");
    super(`Execution reverted ${ne ? `with reason: ${ne}` : "for an unknown reason"}.`, {
      cause: X
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ExecutionRevertedError"
    });
  }
}
Object.defineProperty(xa, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 3
});
Object.defineProperty(xa, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /execution reverted/
});
class Ql extends Le {
  constructor({ cause: X, maxFeePerGas: ee } = {}) {
    super(`The fee cap (\`maxFeePerGas\`${ee ? ` = ${Cn(ee)} gwei` : ""}) cannot be higher than the maximum allowed value (2^256-1).`, {
      cause: X
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "FeeCapTooHigh"
    });
  }
}
Object.defineProperty(Ql, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /max fee per gas higher than 2\^256-1|fee cap higher than 2\^256-1/
});
class cg extends Le {
  constructor({ cause: X, maxFeePerGas: ee } = {}) {
    super(`The fee cap (\`maxFeePerGas\`${ee ? ` = ${Cn(ee)}` : ""} gwei) cannot be lower than the block base fee.`, {
      cause: X
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "FeeCapTooLow"
    });
  }
}
Object.defineProperty(cg, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /max fee per gas less than block base fee|fee cap less than block base fee|transaction is outdated/
});
class ug extends Le {
  constructor({ cause: X, nonce: ee } = {}) {
    super(`Nonce provided for the transaction ${ee ? `(${ee}) ` : ""}is higher than the next one expected.`, { cause: X }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "NonceTooHighError"
    });
  }
}
Object.defineProperty(ug, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /nonce too high/
});
class fg extends Le {
  constructor({ cause: X, nonce: ee } = {}) {
    super([
      `Nonce provided for the transaction ${ee ? `(${ee}) ` : ""}is lower than the current nonce of the account.`,
      "Try increasing the nonce or find the latest nonce with `getTransactionCount`."
    ].join(`
`), { cause: X }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "NonceTooLowError"
    });
  }
}
Object.defineProperty(fg, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /nonce too low|transaction already imported|already known/
});
class lg extends Le {
  constructor({ cause: X, nonce: ee } = {}) {
    super(`Nonce provided for the transaction ${ee ? `(${ee}) ` : ""}exceeds the maximum allowed nonce.`, { cause: X }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "NonceMaxValueError"
    });
  }
}
Object.defineProperty(lg, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /nonce has max value/
});
class dg extends Le {
  constructor({ cause: X } = {}) {
    super([
      "The total cost (gas * gas fee + value) of executing this transaction exceeds the balance of the account."
    ].join(`
`), {
      cause: X,
      metaMessages: [
        "This error could arise when the account does not have enough funds to:",
        " - pay for the total gas fee,",
        " - pay for the value to send.",
        " ",
        "The cost of the transaction is calculated as `gas * gas fee + value`, where:",
        " - `gas` is the amount of gas needed for transaction to execute,",
        " - `gas fee` is the gas fee,",
        " - `value` is the amount of ether to send to the recipient."
      ]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InsufficientFundsError"
    });
  }
}
Object.defineProperty(dg, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /insufficient funds/
});
class hg extends Le {
  constructor({ cause: X, gas: ee } = {}) {
    super(`The amount of gas ${ee ? `(${ee}) ` : ""}provided for the transaction exceeds the limit allowed for the block.`, {
      cause: X
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "IntrinsicGasTooHighError"
    });
  }
}
Object.defineProperty(hg, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /intrinsic gas too high|gas limit reached/
});
class pg extends Le {
  constructor({ cause: X, gas: ee } = {}) {
    super(`The amount of gas ${ee ? `(${ee}) ` : ""}provided for the transaction is too low.`, {
      cause: X
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "IntrinsicGasTooLowError"
    });
  }
}
Object.defineProperty(pg, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /intrinsic gas too low/
});
class gg extends Le {
  constructor({ cause: X }) {
    super("The transaction type is not supported for this chain.", {
      cause: X
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "TransactionTypeNotSupportedError"
    });
  }
}
Object.defineProperty(gg, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /transaction type not valid/
});
class ed extends Le {
  constructor({ cause: X, maxPriorityFeePerGas: ee, maxFeePerGas: te } = {}) {
    super([
      `The provided tip (\`maxPriorityFeePerGas\`${ee ? ` = ${Cn(ee)} gwei` : ""}) cannot be higher than the fee cap (\`maxFeePerGas\`${te ? ` = ${Cn(te)} gwei` : ""}).`
    ].join(`
`), {
      cause: X
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "TipAboveFeeCapError"
    });
  }
}
Object.defineProperty(ed, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /max priority fee per gas higher than max fee per gas|tip higher than fee cap/
});
class b0 extends Le {
  constructor({ cause: X }) {
    super(`An error occurred while executing: ${X == null ? void 0 : X.shortMessage}`, {
      cause: X
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "UnknownNodeError"
    });
  }
}
function Py(Y, X = "wei") {
  return NA(Y, fD[X]);
}
function Af(Y) {
  const X = Object.entries(Y).map(([te, ne]) => ne === void 0 || ne === !1 ? null : [te, ne]).filter(Boolean), ee = X.reduce((te, [ne]) => Math.max(te, ne.length), 0);
  return X.map(([te, ne]) => `  ${`${te}:`.padEnd(ee + 1)}  ${ne}`).join(`
`);
}
class dD extends Le {
  constructor() {
    super([
      "Cannot specify both a `gasPrice` and a `maxFeePerGas`/`maxPriorityFeePerGas`.",
      "Use `maxFeePerGas`/`maxPriorityFeePerGas` for EIP-1559 compatible networks, and `gasPrice` for others."
    ].join(`
`)), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "FeeConflictError"
    });
  }
}
class hD extends Le {
  constructor({ transaction: X }) {
    super("Cannot infer a transaction type from provided transaction.", {
      metaMessages: [
        "Provided Transaction:",
        "{",
        Af(X),
        "}",
        "",
        "To infer the type, either provide:",
        "- a `type` to the Transaction, or",
        "- an EIP-1559 Transaction with `maxFeePerGas`, or",
        "- an EIP-2930 Transaction with `gasPrice` & `accessList`, or",
        "- a Legacy Transaction with `gasPrice`"
      ]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidSerializableTransactionError"
    });
  }
}
class pD extends Le {
  constructor(X, { account: ee, docsPath: te, chain: ne, data: ie, gas: oe, gasPrice: se, maxFeePerGas: ae, maxPriorityFeePerGas: ue, nonce: le, to: he, value: me }) {
    var ye;
    const we = Af({
      chain: ne && `${ne == null ? void 0 : ne.name} (id: ${ne == null ? void 0 : ne.id})`,
      from: ee == null ? void 0 : ee.address,
      to: he,
      value: typeof me < "u" && `${Py(me)} ${((ye = ne == null ? void 0 : ne.nativeCurrency) == null ? void 0 : ye.symbol) || "ETH"}`,
      data: ie,
      gas: oe,
      gasPrice: typeof se < "u" && `${Cn(se)} gwei`,
      maxFeePerGas: typeof ae < "u" && `${Cn(ae)} gwei`,
      maxPriorityFeePerGas: typeof ue < "u" && `${Cn(ue)} gwei`,
      nonce: le
    });
    super(X.shortMessage, {
      cause: X,
      docsPath: te,
      metaMessages: [
        ...X.metaMessages ? [...X.metaMessages, " "] : [],
        "Request Arguments:",
        we
      ].filter(Boolean)
    }), Object.defineProperty(this, "cause", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "TransactionExecutionError"
    }), this.cause = X;
  }
}
class kA extends Le {
  constructor({ blockHash: X, blockNumber: ee, blockTag: te, hash: ne, index: ie }) {
    let oe = "Transaction";
    te && ie !== void 0 && (oe = `Transaction at block time "${te}" at index "${ie}"`), X && ie !== void 0 && (oe = `Transaction at block hash "${X}" at index "${ie}"`), ee && ie !== void 0 && (oe = `Transaction at block number "${ee}" at index "${ie}"`), ne && (oe = `Transaction with hash "${ne}"`), super(`${oe} could not be found.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "TransactionNotFoundError"
    });
  }
}
class MA extends Le {
  constructor({ hash: X }) {
    super(`Transaction receipt with hash "${X}" could not be found. The Transaction may not be processed on a block yet.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "TransactionReceiptNotFoundError"
    });
  }
}
class gD extends Le {
  constructor({ hash: X }) {
    super(`Timed out while waiting for transaction with hash "${X}" to be confirmed.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "WaitForTransactionReceiptTimeoutError"
    });
  }
}
const ss = (Y, X, ee) => JSON.stringify(Y, (te, ne) => {
  const ie = typeof ne == "bigint" ? ne.toString() : ne;
  return typeof X == "function" ? X(te, ie) : ie;
}, ee);
class LA extends Le {
  constructor({ body: X, details: ee, headers: te, status: ne, url: ie }) {
    super("HTTP request failed.", {
      details: ee,
      metaMessages: [
        ne && `Status: ${ne}`,
        `URL: ${pA(ie)}`,
        X && `Request body: ${ss(X)}`
      ].filter(Boolean)
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "HttpRequestError"
    }), Object.defineProperty(this, "body", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "headers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "status", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "url", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.body = X, this.headers = te, this.status = ne, this.url = ie;
  }
}
class mD extends Le {
  constructor({ body: X, error: ee, url: te }) {
    super("RPC Request failed.", {
      cause: ee,
      details: ee.message,
      metaMessages: [`URL: ${pA(te)}`, `Request body: ${ss(X)}`]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "RpcRequestError"
    }), Object.defineProperty(this, "code", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.code = ee.code;
  }
}
const yD = -1;
class Bn extends Le {
  constructor(X, { code: ee, docsPath: te, metaMessages: ne, shortMessage: ie }) {
    super(ie, {
      cause: X,
      docsPath: te,
      metaMessages: ne || (X == null ? void 0 : X.metaMessages)
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "RpcError"
    }), Object.defineProperty(this, "code", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.name = X.name, this.code = X instanceof mD ? X.code : ee ?? yD;
  }
}
class Rc extends Bn {
  constructor(X, ee) {
    super(X, ee), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ProviderRpcError"
    }), Object.defineProperty(this, "data", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.data = ee.data;
  }
}
class Lu extends Bn {
  constructor(X) {
    super(X, {
      code: Lu.code,
      shortMessage: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ParseRpcError"
    });
  }
}
Object.defineProperty(Lu, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32700
});
class Fu extends Bn {
  constructor(X) {
    super(X, {
      code: Fu.code,
      shortMessage: "JSON is not a valid request object."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidRequestRpcError"
    });
  }
}
Object.defineProperty(Fu, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32600
});
class $u extends Bn {
  constructor(X) {
    super(X, {
      code: $u.code,
      shortMessage: "The method does not exist / is not available."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "MethodNotFoundRpcError"
    });
  }
}
Object.defineProperty($u, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32601
});
class Du extends Bn {
  constructor(X) {
    super(X, {
      code: Du.code,
      shortMessage: [
        "Invalid parameters were provided to the RPC method.",
        "Double check you have provided the correct parameters."
      ].join(`
`)
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidParamsRpcError"
    });
  }
}
Object.defineProperty(Du, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32602
});
class Uo extends Bn {
  constructor(X) {
    super(X, {
      code: Uo.code,
      shortMessage: "An internal error was received."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InternalRpcError"
    });
  }
}
Object.defineProperty(Uo, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32603
});
class jo extends Bn {
  constructor(X) {
    super(X, {
      code: jo.code,
      shortMessage: [
        "Missing or invalid parameters.",
        "Double check you have provided the correct parameters."
      ].join(`
`)
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "InvalidInputRpcError"
    });
  }
}
Object.defineProperty(jo, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32e3
});
class Uu extends Bn {
  constructor(X) {
    super(X, {
      code: Uu.code,
      shortMessage: "Requested resource not found."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ResourceNotFoundRpcError"
    });
  }
}
Object.defineProperty(Uu, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32001
});
class ju extends Bn {
  constructor(X) {
    super(X, {
      code: ju.code,
      shortMessage: "Requested resource not available."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ResourceUnavailableRpcError"
    });
  }
}
Object.defineProperty(ju, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32002
});
class Hu extends Bn {
  constructor(X) {
    super(X, {
      code: Hu.code,
      shortMessage: "Transaction creation failed."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "TransactionRejectedRpcError"
    });
  }
}
Object.defineProperty(Hu, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32003
});
class zu extends Bn {
  constructor(X) {
    super(X, {
      code: zu.code,
      shortMessage: "Method is not implemented."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "MethodNotSupportedRpcError"
    });
  }
}
Object.defineProperty(zu, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32004
});
class Qa extends Bn {
  constructor(X) {
    super(X, {
      code: Qa.code,
      shortMessage: "Request exceeds defined limit."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "LimitExceededRpcError"
    });
  }
}
Object.defineProperty(Qa, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32005
});
class qu extends Bn {
  constructor(X) {
    super(X, {
      code: qu.code,
      shortMessage: "Version of JSON-RPC protocol is not supported."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "JsonRpcVersionUnsupportedError"
    });
  }
}
Object.defineProperty(qu, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32006
});
class La extends Rc {
  constructor(X) {
    super(X, {
      code: La.code,
      shortMessage: "User rejected the request."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "UserRejectedRequestError"
    });
  }
}
Object.defineProperty(La, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 4001
});
class Gu extends Rc {
  constructor(X) {
    super(X, {
      code: Gu.code,
      shortMessage: "The requested method and/or account has not been authorized by the user."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "UnauthorizedProviderError"
    });
  }
}
Object.defineProperty(Gu, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 4100
});
class Vu extends Rc {
  constructor(X) {
    super(X, {
      code: Vu.code,
      shortMessage: "The Provider does not support the requested method."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "UnsupportedProviderMethodError"
    });
  }
}
Object.defineProperty(Vu, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 4200
});
class Wu extends Rc {
  constructor(X) {
    super(X, {
      code: Wu.code,
      shortMessage: "The Provider is disconnected from all chains."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ProviderDisconnectedError"
    });
  }
}
Object.defineProperty(Wu, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 4900
});
class Ku extends Rc {
  constructor(X) {
    super(X, {
      code: Ku.code,
      shortMessage: "The Provider is not connected to the requested chain."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ChainDisconnectedError"
    });
  }
}
Object.defineProperty(Ku, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 4901
});
class Ju extends Rc {
  constructor(X) {
    super(X, {
      code: Ju.code,
      shortMessage: "An error occurred when attempting to switch chain."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "SwitchChainError"
    });
  }
}
Object.defineProperty(Ju, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 4902
});
class bD extends Bn {
  constructor(X) {
    super(X, {
      shortMessage: "An unknown RPC error occurred."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "UnknownRpcError"
    });
  }
}
function Oy(Y, X) {
  const ee = (Y.details || "").toLowerCase(), te = Y instanceof Le ? Y.walk((ne) => ne.code === xa.code) : Y;
  return te instanceof Le ? new xa({
    cause: Y,
    message: te.details
  }) : xa.nodeMessage.test(ee) ? new xa({
    cause: Y,
    message: Y.details
  }) : Ql.nodeMessage.test(ee) ? new Ql({
    cause: Y,
    maxFeePerGas: X == null ? void 0 : X.maxFeePerGas
  }) : cg.nodeMessage.test(ee) ? new cg({
    cause: Y,
    maxFeePerGas: X == null ? void 0 : X.maxFeePerGas
  }) : ug.nodeMessage.test(ee) ? new ug({ cause: Y, nonce: X == null ? void 0 : X.nonce }) : fg.nodeMessage.test(ee) ? new fg({ cause: Y, nonce: X == null ? void 0 : X.nonce }) : lg.nodeMessage.test(ee) ? new lg({ cause: Y, nonce: X == null ? void 0 : X.nonce }) : dg.nodeMessage.test(ee) ? new dg({ cause: Y }) : hg.nodeMessage.test(ee) ? new hg({ cause: Y, gas: X == null ? void 0 : X.gas }) : pg.nodeMessage.test(ee) ? new pg({ cause: Y, gas: X == null ? void 0 : X.gas }) : gg.nodeMessage.test(ee) ? new gg({ cause: Y }) : ed.nodeMessage.test(ee) ? new ed({
    cause: Y,
    maxFeePerGas: X == null ? void 0 : X.maxFeePerGas,
    maxPriorityFeePerGas: X == null ? void 0 : X.maxPriorityFeePerGas
  }) : new b0({
    cause: Y
  });
}
function xD(Y, { docsPath: X, ...ee }) {
  const te = (() => {
    const ne = Oy(Y, ee);
    return ne instanceof b0 ? Y : ne;
  })();
  return new pD(te, {
    docsPath: X,
    ...ee
  });
}
function By(Y, { format: X }) {
  if (!X)
    return {};
  const ee = {};
  function te(ie) {
    const oe = Object.keys(ie);
    for (const se of oe)
      se in Y && (ee[se] = Y[se]), ie[se] && typeof ie[se] == "object" && !Array.isArray(ie[se]) && te(ie[se]);
  }
  const ne = X(Y || {});
  return te(ne), ee;
}
const wD = {
  legacy: "0x0",
  eip2930: "0x1",
  eip1559: "0x2",
  eip4844: "0x3"
};
function x0(Y) {
  return {
    ...Y,
    gas: typeof Y.gas < "u" ? Rt(Y.gas) : void 0,
    gasPrice: typeof Y.gasPrice < "u" ? Rt(Y.gasPrice) : void 0,
    maxFeePerGas: typeof Y.maxFeePerGas < "u" ? Rt(Y.maxFeePerGas) : void 0,
    maxPriorityFeePerGas: typeof Y.maxPriorityFeePerGas < "u" ? Rt(Y.maxPriorityFeePerGas) : void 0,
    nonce: typeof Y.nonce < "u" ? Rt(Y.nonce) : void 0,
    type: typeof Y.type < "u" ? wD[Y.type] : void 0,
    value: typeof Y.value < "u" ? Rt(Y.value) : void 0
  };
}
function at(Y, X, ee) {
  return (te) => {
    var ne;
    return ((ne = Y[X.name || ee]) == null ? void 0 : ne.call(Y, te)) ?? X(Y, te);
  };
}
function Sf(Y) {
  const { account: X, gasPrice: ee, maxFeePerGas: te, maxPriorityFeePerGas: ne, to: ie } = Y, oe = X ? Hn(X) : void 0;
  if (oe && !Bs(oe.address))
    throw new Za({ address: oe.address });
  if (ie && !Bs(ie))
    throw new Za({ address: ie });
  if (typeof ee < "u" && (typeof te < "u" || typeof ne < "u"))
    throw new dD();
  if (te && te > 2n ** 256n - 1n)
    throw new Ql({ maxFeePerGas: te });
  if (ne && te && ne > te)
    throw new ed({ maxFeePerGas: te, maxPriorityFeePerGas: ne });
}
async function Yu(Y) {
  const X = await Y.request({
    method: "eth_chainId"
  });
  return co(X);
}
class vD extends Le {
  constructor() {
    super("`baseFeeMultiplier` must be greater than 1."), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "BaseFeeScalarError"
    });
  }
}
class Ny extends Le {
  constructor() {
    super("Chain does not support EIP-1559 fees."), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "Eip1559FeesNotSupportedError"
    });
  }
}
class ED extends Le {
  constructor({ maxPriorityFeePerGas: X }) {
    super(`\`maxFeePerGas\` cannot be less than the \`maxPriorityFeePerGas\` (${Cn(X)} gwei).`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "MaxFeePerGasTooLowError"
    });
  }
}
class FA extends Le {
  constructor({ blockHash: X, blockNumber: ee }) {
    let te = "Block";
    X && (te = `Block at hash "${X}"`), ee && (te = `Block at number "${ee}"`), super(`${te} could not be found.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "BlockNotFoundError"
    });
  }
}
const $A = {
  "0x0": "legacy",
  "0x1": "eip2930",
  "0x2": "eip1559",
  "0x3": "eip4844"
};
function DA(Y) {
  const X = {
    ...Y,
    blockHash: Y.blockHash ? Y.blockHash : null,
    blockNumber: Y.blockNumber ? BigInt(Y.blockNumber) : null,
    chainId: Y.chainId ? co(Y.chainId) : void 0,
    gas: Y.gas ? BigInt(Y.gas) : void 0,
    gasPrice: Y.gasPrice ? BigInt(Y.gasPrice) : void 0,
    maxFeePerBlobGas: Y.maxFeePerBlobGas ? BigInt(Y.maxFeePerBlobGas) : void 0,
    maxFeePerGas: Y.maxFeePerGas ? BigInt(Y.maxFeePerGas) : void 0,
    maxPriorityFeePerGas: Y.maxPriorityFeePerGas ? BigInt(Y.maxPriorityFeePerGas) : void 0,
    nonce: Y.nonce ? co(Y.nonce) : void 0,
    to: Y.to ? Y.to : null,
    transactionIndex: Y.transactionIndex ? Number(Y.transactionIndex) : null,
    type: Y.type ? $A[Y.type] : void 0,
    typeHex: Y.type ? Y.type : void 0,
    value: Y.value ? BigInt(Y.value) : void 0,
    v: Y.v ? BigInt(Y.v) : void 0
  };
  return X.yParity = (() => {
    if (Y.yParity)
      return Number(Y.yParity);
    if (typeof X.v == "bigint") {
      if (X.v === 0n || X.v === 27n)
        return 0;
      if (X.v === 1n || X.v === 28n)
        return 1;
      if (X.v >= 35n)
        return X.v % 2n === 0n ? 1 : 0;
    }
  })(), X.type === "legacy" && (delete X.accessList, delete X.maxFeePerBlobGas, delete X.maxFeePerGas, delete X.maxPriorityFeePerGas, delete X.yParity), X.type === "eip2930" && (delete X.maxFeePerBlobGas, delete X.maxFeePerGas, delete X.maxPriorityFeePerGas), X.type === "eip1559" && delete X.maxFeePerBlobGas, X;
}
function UA(Y) {
  var X;
  const ee = (X = Y.transactions) == null ? void 0 : X.map((te) => typeof te == "string" ? te : DA(te));
  return {
    ...Y,
    baseFeePerGas: Y.baseFeePerGas ? BigInt(Y.baseFeePerGas) : null,
    blobGasUsed: Y.blobGasUsed ? BigInt(Y.blobGasUsed) : void 0,
    difficulty: Y.difficulty ? BigInt(Y.difficulty) : void 0,
    excessBlobGas: Y.excessBlobGas ? BigInt(Y.excessBlobGas) : void 0,
    gasLimit: Y.gasLimit ? BigInt(Y.gasLimit) : void 0,
    gasUsed: Y.gasUsed ? BigInt(Y.gasUsed) : void 0,
    hash: Y.hash ? Y.hash : null,
    logsBloom: Y.logsBloom ? Y.logsBloom : null,
    nonce: Y.nonce ? Y.nonce : null,
    number: Y.number ? BigInt(Y.number) : null,
    size: Y.size ? BigInt(Y.size) : void 0,
    timestamp: Y.timestamp ? BigInt(Y.timestamp) : void 0,
    transactions: ee,
    totalDifficulty: Y.totalDifficulty ? BigInt(Y.totalDifficulty) : null
  };
}
async function uo(Y, { blockHash: X, blockNumber: ee, blockTag: te, includeTransactions: ne } = {}) {
  var ie, oe, se;
  const ae = te ?? "latest", ue = ne ?? !1, le = ee !== void 0 ? Rt(ee) : void 0;
  let he = null;
  if (X ? he = await Y.request({
    method: "eth_getBlockByHash",
    params: [X, ue]
  }) : he = await Y.request({
    method: "eth_getBlockByNumber",
    params: [le || ae, ue]
  }), !he)
    throw new FA({ blockHash: X, blockNumber: ee });
  return (((se = (oe = (ie = Y.chain) == null ? void 0 : ie.formatters) == null ? void 0 : oe.block) == null ? void 0 : se.format) || UA)(he);
}
async function ky(Y) {
  const X = await Y.request({
    method: "eth_gasPrice"
  });
  return BigInt(X);
}
async function _D(Y, X) {
  return jA(Y, X);
}
async function jA(Y, X) {
  var ee, te, ne;
  const { block: ie, chain: oe = Y.chain, request: se } = X || {};
  if (typeof ((ee = oe == null ? void 0 : oe.fees) == null ? void 0 : ee.defaultPriorityFee) == "function") {
    const ae = ie || await at(Y, uo, "getBlock")({});
    return oe.fees.defaultPriorityFee({
      block: ae,
      client: Y,
      request: se
    });
  }
  if (typeof ((te = oe == null ? void 0 : oe.fees) == null ? void 0 : te.defaultPriorityFee) < "u")
    return (ne = oe == null ? void 0 : oe.fees) == null ? void 0 : ne.defaultPriorityFee;
  try {
    const ae = await Y.request({
      method: "eth_maxPriorityFeePerGas"
    });
    return d0(ae);
  } catch {
    const [ae, ue] = await Promise.all([
      ie ? Promise.resolve(ie) : at(Y, uo, "getBlock")({}),
      at(Y, ky, "getGasPrice")({})
    ]);
    if (typeof ae.baseFeePerGas != "bigint")
      throw new Ny();
    const le = ue - ae.baseFeePerGas;
    return le < 0n ? 0n : le;
  }
}
async function AD(Y, X) {
  return mg(Y, X);
}
async function mg(Y, X) {
  var ee, te;
  const { block: ne, chain: ie = Y.chain, request: oe, type: se = "eip1559" } = X || {}, ae = await (async () => {
    var me, ye;
    return typeof ((me = ie == null ? void 0 : ie.fees) == null ? void 0 : me.baseFeeMultiplier) == "function" ? ie.fees.baseFeeMultiplier({
      block: ne,
      client: Y,
      request: oe
    }) : ((ye = ie == null ? void 0 : ie.fees) == null ? void 0 : ye.baseFeeMultiplier) ?? 1.2;
  })();
  if (ae < 1)
    throw new vD();
  const ue = 10 ** (((ee = ae.toString().split(".")[1]) == null ? void 0 : ee.length) ?? 0), le = (me) => me * BigInt(Math.ceil(ae * ue)) / BigInt(ue), he = ne || await at(Y, uo, "getBlock")({});
  if (typeof ((te = ie == null ? void 0 : ie.fees) == null ? void 0 : te.estimateFeesPerGas) == "function")
    return ie.fees.estimateFeesPerGas({
      block: ne,
      client: Y,
      multiply: le,
      request: oe,
      type: se
    });
  if (se === "eip1559") {
    if (typeof he.baseFeePerGas != "bigint")
      throw new Ny();
    const me = typeof (oe == null ? void 0 : oe.maxPriorityFeePerGas) == "bigint" ? oe.maxPriorityFeePerGas : await jA(Y, {
      block: he,
      chain: ie,
      request: oe
    }), ye = le(he.baseFeePerGas);
    return {
      maxFeePerGas: (oe == null ? void 0 : oe.maxFeePerGas) ?? ye + me,
      maxPriorityFeePerGas: me
    };
  }
  return {
    gasPrice: (oe == null ? void 0 : oe.gasPrice) ?? le(await at(Y, ky, "getGasPrice")({}))
  };
}
class SD extends Le {
  constructor(X, { account: ee, docsPath: te, chain: ne, data: ie, gas: oe, gasPrice: se, maxFeePerGas: ae, maxPriorityFeePerGas: ue, nonce: le, to: he, value: me }) {
    var ye;
    const we = Af({
      from: ee == null ? void 0 : ee.address,
      to: he,
      value: typeof me < "u" && `${Py(me)} ${((ye = ne == null ? void 0 : ne.nativeCurrency) == null ? void 0 : ye.symbol) || "ETH"}`,
      data: ie,
      gas: oe,
      gasPrice: typeof se < "u" && `${Cn(se)} gwei`,
      maxFeePerGas: typeof ae < "u" && `${Cn(ae)} gwei`,
      maxPriorityFeePerGas: typeof ue < "u" && `${Cn(ue)} gwei`,
      nonce: le
    });
    super(X.shortMessage, {
      cause: X,
      docsPath: te,
      metaMessages: [
        ...X.metaMessages ? [...X.metaMessages, " "] : [],
        "Estimate Gas Arguments:",
        we
      ].filter(Boolean)
    }), Object.defineProperty(this, "cause", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "EstimateGasExecutionError"
    }), this.cause = X;
  }
}
function TD(Y, { docsPath: X, ...ee }) {
  const te = (() => {
    const ne = Oy(Y, ee);
    return ne instanceof b0 ? Y : ne;
  })();
  return new SD(te, {
    docsPath: X,
    ...ee
  });
}
async function My(Y, X) {
  var ee, te, ne;
  const ie = X.account ?? Y.account, oe = ie ? Hn(ie) : void 0;
  try {
    const { accessList: se, blockNumber: ae, blockTag: ue, data: le, gas: he, gasPrice: me, maxFeePerGas: ye, maxPriorityFeePerGas: we, nonce: Ee, to: Re, value: Ue, ...Me } = (oe == null ? void 0 : oe.type) === "local" ? await w0(Y, X) : X, De = (ae ? Rt(ae) : void 0) || ue;
    Sf(X);
    const Fe = (ne = (te = (ee = Y.chain) == null ? void 0 : ee.formatters) == null ? void 0 : te.transactionRequest) == null ? void 0 : ne.format, Ke = (Fe || x0)({
      // Pick out extra data that might exist on the chain's transaction request type.
      ...By(Me, { format: Fe }),
      from: oe == null ? void 0 : oe.address,
      accessList: se,
      data: le,
      gas: he,
      gasPrice: me,
      maxFeePerGas: ye,
      maxPriorityFeePerGas: we,
      nonce: Ee,
      to: Re,
      value: Ue
    }), tt = await Y.request({
      method: "eth_estimateGas",
      params: De ? [Ke, De] : [Ke]
    });
    return BigInt(tt);
  } catch (se) {
    throw TD(se, {
      ...X,
      account: oe,
      chain: Y.chain
    });
  }
}
async function HA(Y, { address: X, blockTag: ee = "latest", blockNumber: te }) {
  const ne = await Y.request({
    method: "eth_getTransactionCount",
    params: [X, te ? Rt(te) : ee]
  });
  return co(ne);
}
function ID(Y) {
  if (Y.type)
    return Y.type;
  if (typeof Y.maxFeePerGas < "u" || typeof Y.maxPriorityFeePerGas < "u")
    return "eip1559";
  if (typeof Y.gasPrice < "u")
    return typeof Y.accessList < "u" ? "eip2930" : "legacy";
  throw new hD({ transaction: Y });
}
async function w0(Y, X) {
  const { account: ee = Y.account, chain: te, gas: ne, nonce: ie, parameters: oe = ["fees", "gas", "nonce", "type"], type: se } = X, ae = ee ? Hn(ee) : void 0, ue = await at(Y, uo, "getBlock")({ blockTag: "latest" }), le = { ...X, ...ae ? { from: ae == null ? void 0 : ae.address } : {} };
  if (oe.includes("nonce") && typeof ie > "u" && ae && (le.nonce = await at(Y, HA, "getTransactionCount")({
    address: ae.address,
    blockTag: "pending"
  })), (oe.includes("fees") || oe.includes("type")) && typeof se > "u")
    try {
      le.type = ID(le);
    } catch {
      le.type = typeof ue.baseFeePerGas == "bigint" ? "eip1559" : "legacy";
    }
  if (oe.includes("fees"))
    if (le.type === "eip1559") {
      const { maxFeePerGas: he, maxPriorityFeePerGas: me } = await mg(Y, {
        block: ue,
        chain: te,
        request: le
      });
      if (typeof X.maxPriorityFeePerGas > "u" && X.maxFeePerGas && X.maxFeePerGas < me)
        throw new ED({
          maxPriorityFeePerGas: me
        });
      le.maxPriorityFeePerGas = me, le.maxFeePerGas = he;
    } else {
      if (typeof X.maxFeePerGas < "u" || typeof X.maxPriorityFeePerGas < "u")
        throw new Ny();
      const { gasPrice: he } = await mg(Y, {
        block: ue,
        chain: te,
        request: le,
        type: "legacy"
      });
      le.gasPrice = he;
    }
  return oe.includes("gas") && typeof ne > "u" && (le.gas = await at(Y, My, "estimateGas")({
    ...le,
    account: ae ? { address: ae.address, type: "json-rpc" } : void 0
  })), Sf(le), delete le.parameters, le;
}
async function Ly(Y, { serializedTransaction: X }) {
  return Y.request({
    method: "eth_sendRawTransaction",
    params: [X]
  }, { retryCount: 0 });
}
async function Fy(Y, X) {
  var ee, te, ne, ie;
  const { account: oe = Y.account, chain: se = Y.chain, accessList: ae, data: ue, gas: le, gasPrice: he, maxFeePerGas: me, maxPriorityFeePerGas: ye, nonce: we, to: Ee, value: Re, ...Ue } = X;
  if (!oe)
    throw new y0({
      docsPath: "/docs/actions/wallet/sendTransaction"
    });
  const Me = Hn(oe);
  try {
    Sf(X);
    let De;
    if (se !== null && (De = await at(Y, Yu, "getChainId")({}), BA({
      currentChainId: De,
      chain: se
    })), Me.type === "local") {
      const tt = await at(Y, w0, "prepareTransactionRequest")({
        account: Me,
        accessList: ae,
        chain: se,
        data: ue,
        gas: le,
        gasPrice: he,
        maxFeePerGas: me,
        maxPriorityFeePerGas: ye,
        nonce: we,
        to: Ee,
        value: Re,
        ...Ue
      });
      De || (De = await at(Y, Yu, "getChainId")({}));
      const rt = (ee = se == null ? void 0 : se.serializers) == null ? void 0 : ee.transaction, it = await Me.signTransaction({
        ...tt,
        chainId: De
      }, { serializer: rt });
      return await at(Y, Ly, "sendRawTransaction")({
        serializedTransaction: it
      });
    }
    const Fe = (ie = (ne = (te = Y.chain) == null ? void 0 : te.formatters) == null ? void 0 : ne.transactionRequest) == null ? void 0 : ie.format, Ke = (Fe || x0)({
      // Pick out extra data that might exist on the chain's transaction request type.
      ...By(Ue, { format: Fe }),
      accessList: ae,
      data: ue,
      from: Me.address,
      gas: le,
      gasPrice: he,
      maxFeePerGas: me,
      maxPriorityFeePerGas: ye,
      nonce: we,
      to: Ee,
      value: Re
    });
    return await Y.request({
      method: "eth_sendTransaction",
      params: [Ke]
    }, { retryCount: 0 });
  } catch (De) {
    throw xD(De, {
      ...X,
      account: Me,
      chain: X.chain || void 0
    });
  }
}
function RD(Y, X) {
  const { abi: ee, args: te, bytecode: ne, ...ie } = X, oe = PA({ abi: ee, args: te, bytecode: ne });
  return Fy(Y, {
    ...ie,
    data: oe
  });
}
const yg = [
  {
    inputs: [
      {
        components: [
          {
            name: "target",
            type: "address"
          },
          {
            name: "allowFailure",
            type: "bool"
          },
          {
            name: "callData",
            type: "bytes"
          }
        ],
        name: "calls",
        type: "tuple[]"
      }
    ],
    name: "aggregate3",
    outputs: [
      {
        components: [
          {
            name: "success",
            type: "bool"
          },
          {
            name: "returnData",
            type: "bytes"
          }
        ],
        name: "returnData",
        type: "tuple[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
], zA = [
  {
    inputs: [],
    name: "ResolverNotFound",
    type: "error"
  },
  {
    inputs: [],
    name: "ResolverWildcardNotSupported",
    type: "error"
  },
  {
    inputs: [],
    name: "ResolverNotContract",
    type: "error"
  },
  {
    inputs: [
      {
        name: "returnData",
        type: "bytes"
      }
    ],
    name: "ResolverError",
    type: "error"
  },
  {
    inputs: [
      {
        components: [
          {
            name: "status",
            type: "uint16"
          },
          {
            name: "message",
            type: "string"
          }
        ],
        name: "errors",
        type: "tuple[]"
      }
    ],
    name: "HttpError",
    type: "error"
  }
], qA = [
  ...zA,
  {
    name: "resolve",
    type: "function",
    stateMutability: "view",
    inputs: [
      { name: "name", type: "bytes" },
      { name: "data", type: "bytes" }
    ],
    outputs: [
      { name: "", type: "bytes" },
      { name: "address", type: "address" }
    ]
  },
  {
    name: "resolve",
    type: "function",
    stateMutability: "view",
    inputs: [
      { name: "name", type: "bytes" },
      { name: "data", type: "bytes" },
      { name: "gateways", type: "string[]" }
    ],
    outputs: [
      { name: "", type: "bytes" },
      { name: "address", type: "address" }
    ]
  }
], CD = [
  ...zA,
  {
    name: "reverse",
    type: "function",
    stateMutability: "view",
    inputs: [{ type: "bytes", name: "reverseName" }],
    outputs: [
      { type: "string", name: "resolvedName" },
      { type: "address", name: "resolvedAddress" },
      { type: "address", name: "reverseResolver" },
      { type: "address", name: "resolver" }
    ]
  },
  {
    name: "reverse",
    type: "function",
    stateMutability: "view",
    inputs: [
      { type: "bytes", name: "reverseName" },
      { type: "string[]", name: "gateways" }
    ],
    outputs: [
      { type: "string", name: "resolvedName" },
      { type: "address", name: "resolvedAddress" },
      { type: "address", name: "reverseResolver" },
      { type: "address", name: "resolver" }
    ]
  }
], Kw = [
  {
    name: "text",
    type: "function",
    stateMutability: "view",
    inputs: [
      { name: "name", type: "bytes32" },
      { name: "key", type: "string" }
    ],
    outputs: [{ name: "", type: "string" }]
  }
], Jw = [
  {
    name: "addr",
    type: "function",
    stateMutability: "view",
    inputs: [{ name: "name", type: "bytes32" }],
    outputs: [{ name: "", type: "address" }]
  },
  {
    name: "addr",
    type: "function",
    stateMutability: "view",
    inputs: [
      { name: "name", type: "bytes32" },
      { name: "coinType", type: "uint256" }
    ],
    outputs: [{ name: "", type: "bytes" }]
  }
], PD = [
  {
    inputs: [
      {
        internalType: "address",
        name: "_signer",
        type: "address"
      },
      {
        internalType: "bytes32",
        name: "_hash",
        type: "bytes32"
      },
      {
        internalType: "bytes",
        name: "_signature",
        type: "bytes"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  }
];
class Yw extends Le {
  constructor({ offset: X }) {
    super(`Offset \`${X}\` cannot be negative.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "NegativeOffsetError"
    });
  }
}
class GA extends Le {
  constructor({ length: X, position: ee }) {
    super(`Position \`${ee}\` is out of bounds (\`0 < position < ${X}\`).`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "PositionOutOfBoundsError"
    });
  }
}
class OD extends Le {
  constructor({ count: X, limit: ee }) {
    super(`Recursive read limit of \`${ee}\` exceeded (recursive read count: \`${X}\`).`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "RecursiveReadLimitExceededError"
    });
  }
}
const BD = {
  bytes: new Uint8Array(),
  dataView: new DataView(new ArrayBuffer(0)),
  position: 0,
  positionReadCount: /* @__PURE__ */ new Map(),
  recursiveReadCount: 0,
  recursiveReadLimit: 1 / 0,
  assertReadLimit() {
    if (this.recursiveReadCount >= this.recursiveReadLimit)
      throw new OD({
        count: this.recursiveReadCount + 1,
        limit: this.recursiveReadLimit
      });
  },
  assertPosition(Y) {
    if (Y < 0 || Y > this.bytes.length - 1)
      throw new GA({
        length: this.bytes.length,
        position: Y
      });
  },
  decrementPosition(Y) {
    if (Y < 0)
      throw new Yw({ offset: Y });
    const X = this.position - Y;
    this.assertPosition(X), this.position = X;
  },
  getReadCount(Y) {
    return this.positionReadCount.get(Y || this.position) || 0;
  },
  incrementPosition(Y) {
    if (Y < 0)
      throw new Yw({ offset: Y });
    const X = this.position + Y;
    this.assertPosition(X), this.position = X;
  },
  inspectByte(Y) {
    const X = Y ?? this.position;
    return this.assertPosition(X), this.bytes[X];
  },
  inspectBytes(Y, X) {
    const ee = X ?? this.position;
    return this.assertPosition(ee + Y - 1), this.bytes.subarray(ee, ee + Y);
  },
  inspectUint8(Y) {
    const X = Y ?? this.position;
    return this.assertPosition(X), this.bytes[X];
  },
  inspectUint16(Y) {
    const X = Y ?? this.position;
    return this.assertPosition(X + 1), this.dataView.getUint16(X);
  },
  inspectUint24(Y) {
    const X = Y ?? this.position;
    return this.assertPosition(X + 2), (this.dataView.getUint16(X) << 8) + this.dataView.getUint8(X + 2);
  },
  inspectUint32(Y) {
    const X = Y ?? this.position;
    return this.assertPosition(X + 3), this.dataView.getUint32(X);
  },
  pushByte(Y) {
    this.assertPosition(this.position), this.bytes[this.position] = Y, this.position++;
  },
  pushBytes(Y) {
    this.assertPosition(this.position + Y.length - 1), this.bytes.set(Y, this.position), this.position += Y.length;
  },
  pushUint8(Y) {
    this.assertPosition(this.position), this.bytes[this.position] = Y, this.position++;
  },
  pushUint16(Y) {
    this.assertPosition(this.position + 1), this.dataView.setUint16(this.position, Y), this.position += 2;
  },
  pushUint24(Y) {
    this.assertPosition(this.position + 2), this.dataView.setUint16(this.position, Y >> 8), this.dataView.setUint8(this.position + 2, Y & 255), this.position += 3;
  },
  pushUint32(Y) {
    this.assertPosition(this.position + 3), this.dataView.setUint32(this.position, Y), this.position += 4;
  },
  readByte() {
    this.assertReadLimit(), this._touch();
    const Y = this.inspectByte();
    return this.position++, Y;
  },
  readBytes(Y, X) {
    this.assertReadLimit(), this._touch();
    const ee = this.inspectBytes(Y);
    return this.position += X ?? Y, ee;
  },
  readUint8() {
    this.assertReadLimit(), this._touch();
    const Y = this.inspectUint8();
    return this.position += 1, Y;
  },
  readUint16() {
    this.assertReadLimit(), this._touch();
    const Y = this.inspectUint16();
    return this.position += 2, Y;
  },
  readUint24() {
    this.assertReadLimit(), this._touch();
    const Y = this.inspectUint24();
    return this.position += 3, Y;
  },
  readUint32() {
    this.assertReadLimit(), this._touch();
    const Y = this.inspectUint32();
    return this.position += 4, Y;
  },
  setPosition(Y) {
    const X = this.position;
    return this.assertPosition(Y), this.position = Y, () => this.position = X;
  },
  _touch() {
    if (this.recursiveReadLimit === 1 / 0)
      return;
    const Y = this.getReadCount();
    this.positionReadCount.set(this.position, Y + 1), Y > 0 && this.recursiveReadCount++;
  }
};
function ND(Y, { recursiveReadLimit: X = 8192 } = {}) {
  const ee = Object.create(BD);
  return ee.bytes = Y, ee.dataView = new DataView(Y.buffer, Y.byteOffset, Y.byteLength), ee.positionReadCount = /* @__PURE__ */ new Map(), ee.recursiveReadLimit = X, ee;
}
function kD(Y, X = {}) {
  typeof X.size < "u" && is$1(Y, { size: X.size });
  const ee = wi(Y, X);
  return d0(ee, X);
}
function MD(Y, X = {}) {
  let ee = Y;
  if (typeof X.size < "u" && (is$1(ee, { size: X.size }), ee = l0(ee)), ee.length > 1 || ee[0] > 1)
    throw new i$(ee);
  return !!ee[0];
}
function Ss(Y, X = {}) {
  typeof X.size < "u" && is$1(Y, { size: X.size });
  const ee = wi(Y, X);
  return co(ee, X);
}
function LD(Y, X = {}) {
  let ee = Y;
  return typeof X.size < "u" && (is$1(ee, { size: X.size }), ee = l0(ee, { dir: "right" })), new TextDecoder().decode(ee);
}
function v0(Y, X) {
  const ee = typeof X == "string" ? _y(X) : X, te = ND(ee);
  if (Hr(ee) === 0 && Y.length > 0)
    throw new p0();
  if (Hr(X) && Hr(X) < 32)
    throw new xA({
      data: typeof X == "string" ? X : wi(X),
      params: Y,
      size: Hr(X)
    });
  let ne = 0;
  const ie = [];
  for (let oe = 0; oe < Y.length; ++oe) {
    const se = Y[oe];
    te.setPosition(ne);
    const [ae, ue] = Fa(te, se, {
      staticPosition: 0
    });
    ne += ue, ie.push(ae);
  }
  return ie;
}
function Fa(Y, X, { staticPosition: ee }) {
  const te = Cy(X.type);
  if (te) {
    const [ne, ie] = te;
    return $D(Y, { ...X, type: ie }, { length: ne, staticPosition: ee });
  }
  if (X.type === "tuple")
    return HD(Y, X, { staticPosition: ee });
  if (X.type === "address")
    return FD(Y);
  if (X.type === "bool")
    return DD(Y);
  if (X.type.startsWith("bytes"))
    return UD(Y, X, { staticPosition: ee });
  if (X.type.startsWith("uint") || X.type.startsWith("int"))
    return jD(Y, X);
  if (X.type === "string")
    return zD(Y, { staticPosition: ee });
  throw new _$(X.type, {
    docsPath: "/docs/contract/decodeAbiParameters"
  });
}
const Xw = 32, bg = 32;
function FD(Y) {
  const X = Y.readBytes(32);
  return [m0(wi(CA(X, -20))), 32];
}
function $D(Y, X, { length: ee, staticPosition: te }) {
  if (!ee) {
    const oe = Ss(Y.readBytes(bg)), se = te + oe, ae = se + Xw;
    Y.setPosition(se);
    const ue = Ss(Y.readBytes(Xw)), le = Xu(X);
    let he = 0;
    const me = [];
    for (let ye = 0; ye < ue; ++ye) {
      Y.setPosition(ae + (le ? ye * 32 : he));
      const [we, Ee] = Fa(Y, X, {
        staticPosition: ae
      });
      he += Ee, me.push(we);
    }
    return Y.setPosition(te + 32), [me, 32];
  }
  if (Xu(X)) {
    const oe = Ss(Y.readBytes(bg)), se = te + oe, ae = [];
    for (let ue = 0; ue < ee; ++ue) {
      Y.setPosition(se + ue * 32);
      const [le] = Fa(Y, X, {
        staticPosition: se
      });
      ae.push(le);
    }
    return Y.setPosition(te + 32), [ae, 32];
  }
  let ne = 0;
  const ie = [];
  for (let oe = 0; oe < ee; ++oe) {
    const [se, ae] = Fa(Y, X, {
      staticPosition: te + ne
    });
    ne += ae, ie.push(se);
  }
  return [ie, ne];
}
function DD(Y) {
  return [MD(Y.readBytes(32), { size: 32 }), 32];
}
function UD(Y, X, { staticPosition: ee }) {
  const [te, ne] = X.type.split("bytes");
  if (!ne) {
    const ie = Ss(Y.readBytes(32));
    Y.setPosition(ee + ie);
    const oe = Ss(Y.readBytes(32));
    if (oe === 0)
      return Y.setPosition(ee + 32), ["0x", 32];
    const se = Y.readBytes(oe);
    return Y.setPosition(ee + 32), [wi(se), 32];
  }
  return [wi(Y.readBytes(parseInt(ne), 32)), 32];
}
function jD(Y, X) {
  const ee = X.type.startsWith("int"), te = parseInt(X.type.split("int")[1] || "256"), ne = Y.readBytes(32);
  return [
    te > 48 ? kD(ne, { signed: ee }) : Ss(ne, { signed: ee }),
    32
  ];
}
function HD(Y, X, { staticPosition: ee }) {
  const te = X.components.length === 0 || X.components.some(({ name: oe }) => !oe), ne = te ? [] : {};
  let ie = 0;
  if (Xu(X)) {
    const oe = Ss(Y.readBytes(bg)), se = ee + oe;
    for (let ae = 0; ae < X.components.length; ++ae) {
      const ue = X.components[ae];
      Y.setPosition(se + ie);
      const [le, he] = Fa(Y, ue, {
        staticPosition: se
      });
      ie += he, ne[te ? ae : ue == null ? void 0 : ue.name] = le;
    }
    return Y.setPosition(ee + 32), [ne, 32];
  }
  for (let oe = 0; oe < X.components.length; ++oe) {
    const se = X.components[oe], [ae, ue] = Fa(Y, se, {
      staticPosition: ee
    });
    ne[te ? oe : se == null ? void 0 : se.name] = ae, ie += ue;
  }
  return [ne, ie];
}
function zD(Y, { staticPosition: X }) {
  const ee = Ss(Y.readBytes(32)), te = X + ee;
  Y.setPosition(te);
  const ne = Ss(Y.readBytes(32));
  if (ne === 0)
    return Y.setPosition(X + 32), ["", 32];
  const ie = Y.readBytes(ne, 32), oe = LD(l0(ie));
  return Y.setPosition(X + 32), [oe, 32];
}
function Xu(Y) {
  var X;
  const { type: ee } = Y;
  if (ee === "string" || ee === "bytes" || ee.endsWith("[]"))
    return !0;
  if (ee === "tuple")
    return (X = Y.components) == null ? void 0 : X.some(Xu);
  const te = Cy(Y.type);
  return !!(te && Xu({ ...Y, type: te[1] }));
}
function qD(Y, X) {
  const ee = Y.exec(X);
  return ee == null ? void 0 : ee.groups;
}
const Zw = /^tuple(?<array>(\[(\d*)\])*)$/;
function xg(Y) {
  let X = Y.type;
  if (Zw.test(Y.type) && "components" in Y) {
    X = "(";
    const ee = Y.components.length;
    for (let ne = 0; ne < ee; ne++) {
      const ie = Y.components[ne];
      X += xg(ie), ne < ee - 1 && (X += ", ");
    }
    const te = qD(Zw, Y.type);
    return X += `)${(te == null ? void 0 : te.array) ?? ""}`, xg({
      ...Y,
      type: X
    });
  }
  return "indexed" in Y && Y.indexed && (X = `${X} indexed`), Y.name ? `${X} ${Y.name}` : X;
}
function Zc(Y) {
  let X = "";
  const ee = Y.length;
  for (let te = 0; te < ee; te++) {
    const ne = Y[te];
    X += xg(ne), te !== ee - 1 && (X += ", ");
  }
  return X;
}
function GD(Y) {
  return Y.type === "function" ? `function ${Y.name}(${Zc(Y.inputs)})${Y.stateMutability && Y.stateMutability !== "nonpayable" ? ` ${Y.stateMutability}` : ""}${Y.outputs.length ? ` returns (${Zc(Y.outputs)})` : ""}` : Y.type === "event" ? `event ${Y.name}(${Zc(Y.inputs)})` : Y.type === "error" ? `error ${Y.name}(${Zc(Y.inputs)})` : Y.type === "constructor" ? `constructor(${Zc(Y.inputs)})${Y.stateMutability === "payable" ? " payable" : ""}` : Y.type === "fallback" ? "fallback()" : "receive() external payable";
}
const VD = (Y) => Rn(Do(Y));
function WD(Y) {
  return VD(Y);
}
function KD(Y) {
  let X = !0, ee = "", te = 0, ne = "", ie = !1;
  for (let oe = 0; oe < Y.length; oe++) {
    const se = Y[oe];
    if (["(", ")", ","].includes(se) && (X = !0), se === "(" && te++, se === ")" && te--, !!X) {
      if (te === 0) {
        if (se === " " && ["event", "function", ""].includes(ne))
          ne = "";
        else if (ne += se, se === ")") {
          ie = !0;
          break;
        }
        continue;
      }
      if (se === " ") {
        Y[oe - 1] !== "," && ee !== "," && ee !== ",(" && (ee = "", X = !1);
        continue;
      }
      ne += se, ee += se;
    }
  }
  if (!ie)
    throw new Le("Unable to normalize signature.");
  return ne;
}
const JD = (Y) => {
  const X = typeof Y == "string" ? Y : GD(Y);
  return KD(X);
};
function VA(Y) {
  return WD(JD(Y));
}
const $y = VA, Dy = (Y) => Zl(VA(Y), 0, 4);
function Tf(Y) {
  const { abi: X, args: ee = [], name: te } = Y, ne = es(te, { strict: !1 }), ie = X.filter((se) => ne ? se.type === "function" ? Dy(se) === te : se.type === "event" ? $y(se) === te : !1 : "name" in se && se.name === te);
  if (ie.length === 0)
    return;
  if (ie.length === 1)
    return ie[0];
  let oe;
  for (const se of ie)
    if ("inputs" in se) {
      if (!ee || ee.length === 0) {
        if (!se.inputs || se.inputs.length === 0)
          return se;
        continue;
      }
      if (!(!se.inputs || se.inputs.length === 0 || se.inputs.length !== ee.length) && ee.every((ae, ue) => {
        const le = "inputs" in se && se.inputs[ue];
        return le ? wg(ae, le) : !1;
      })) {
        if (oe && "inputs" in oe && oe.inputs) {
          const ae = WA(se.inputs, oe.inputs, ee);
          if (ae)
            throw new w$({
              abiItem: se,
              type: ae[0]
            }, {
              abiItem: oe,
              type: ae[1]
            });
        }
        oe = se;
      }
    }
  return oe || ie[0];
}
function wg(Y, X) {
  const ee = typeof Y, te = X.type;
  switch (te) {
    case "address":
      return Bs(Y, { strict: !1 });
    case "bool":
      return ee === "boolean";
    case "function":
      return ee === "string";
    case "string":
      return ee === "string";
    default:
      return te === "tuple" && "components" in X ? Object.values(X.components).every((ne, ie) => wg(Object.values(Y)[ie], ne)) : /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(te) ? ee === "number" || ee === "bigint" : /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(te) ? ee === "string" || Y instanceof Uint8Array : /[a-z]+[1-9]{0,3}(\[[0-9]{0,}\])+$/.test(te) ? Array.isArray(Y) && Y.every((ne) => wg(ne, {
        ...X,
        // Pop off `[]` or `[M]` from end of type
        type: te.replace(/(\[[0-9]{0,}\])$/, "")
      })) : !1;
  }
}
function WA(Y, X, ee) {
  for (const te in Y) {
    const ne = Y[te], ie = X[te];
    if (ne.type === "tuple" && ie.type === "tuple" && "components" in ne && "components" in ie)
      return WA(ne.components, ie.components, ee[te]);
    const oe = [ne.type, ie.type];
    if (oe.includes("address") && oe.includes("bytes20") || (oe.includes("address") && oe.includes("string") ? Bs(ee[te], { strict: !1 }) : oe.includes("address") && oe.includes("bytes") && Bs(ee[te], { strict: !1 })))
      return oe;
  }
}
const yp = "/docs/contract/decodeFunctionResult";
function Cc(Y) {
  const { abi: X, args: ee, functionName: te, data: ne } = Y;
  let ie = X[0];
  if (te) {
    const se = Tf({ abi: X, args: ee, name: te });
    if (!se)
      throw new Xl(te, { docsPath: yp });
    ie = se;
  }
  if (ie.type !== "function")
    throw new Xl(void 0, { docsPath: yp });
  if (!ie.outputs)
    throw new x$(ie.name, { docsPath: yp });
  const oe = v0(ie.outputs, ne);
  if (oe && oe.length > 1)
    return oe;
  if (oe && oe.length === 1)
    return oe[0];
}
const Qw = "/docs/contract/encodeFunctionData";
function bo(Y) {
  const { abi: X, args: ee, functionName: te } = Y;
  let ne = X[0];
  if (te) {
    const ae = Tf({
      abi: X,
      args: ee,
      name: te
    });
    if (!ae)
      throw new Xl(te, { docsPath: Qw });
    ne = ae;
  }
  if (ne.type !== "function")
    throw new Xl(void 0, { docsPath: Qw });
  const ie = Ps(ne), oe = Dy(ie), se = "inputs" in ne && ne.inputs ? _f(ne.inputs, ee ?? []) : void 0;
  return Sy([oe, se ?? "0x"]);
}
function Pc({ blockNumber: Y, chain: X, contract: ee }) {
  var te;
  const ne = (te = X == null ? void 0 : X.contracts) == null ? void 0 : te[ee];
  if (!ne)
    throw new ag({
      chain: X,
      contract: { name: ee }
    });
  if (Y && ne.blockCreated && ne.blockCreated > Y)
    throw new ag({
      blockNumber: Y,
      chain: X,
      contract: {
        name: ee,
        blockCreated: ne.blockCreated
      }
    });
  return ne.address;
}
const KA = {
  1: "An `assert` condition failed.",
  17: "Arithmetic operation resulted in underflow or overflow.",
  18: "Division or modulo by zero (e.g. `5 / 0` or `23 % 0`).",
  33: "Attempted to convert to an invalid type.",
  34: "Attempted to access a storage byte array that is incorrectly encoded.",
  49: "Performed `.pop()` on an empty array",
  50: "Array index is out of bounds.",
  65: "Allocated too much memory or created an array which is too large.",
  81: "Attempted to call a zero-initialized variable of internal function type."
}, YD = {
  inputs: [
    {
      name: "message",
      type: "string"
    }
  ],
  name: "Error",
  type: "error"
}, XD = {
  inputs: [
    {
      name: "reason",
      type: "uint256"
    }
  ],
  name: "Panic",
  type: "error"
};
function ZD(Y) {
  const { abi: X, data: ee } = Y, te = Zl(ee, 0, 4);
  if (te === "0x")
    throw new p0();
  const ne = [...X || [], YD, XD].find((ie) => ie.type === "error" && te === Dy(Ps(ie)));
  if (!ne)
    throw new wA(te, {
      docsPath: "/docs/contract/decodeErrorResult"
    });
  return {
    abiItem: ne,
    args: "inputs" in ne && ne.inputs && ne.inputs.length > 0 ? v0(ne.inputs, Zl(ee, 4)) : void 0,
    errorName: ne.name
  };
}
function JA({ abiItem: Y, args: X, includeFunctionName: ee = !0, includeName: te = !1 }) {
  if ("name" in Y && "inputs" in Y && Y.inputs)
    return `${ee ? Y.name : ""}(${Y.inputs.map((ne, ie) => `${te && ne.name ? `${ne.name}: ` : ""}${typeof X[ie] == "object" ? ss(X[ie]) : X[ie]}`).join(", ")})`;
}
class QD extends Le {
  constructor({ address: X }) {
    super(`State for account "${X}" is set multiple times.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "AccountStateConflictError"
    });
  }
}
class eU extends Le {
  constructor() {
    super("state and stateDiff are set on the same account."), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "StateAssignmentConflictError"
    });
  }
}
function ev(Y) {
  return Y.reduce((X, { slot: ee, value: te }) => `${X}        ${ee}: ${te}
`, "");
}
function tU(Y) {
  return Y.reduce((X, { address: ee, ...te }) => {
    let ne = `${X}    ${ee}:
`;
    return te.nonce && (ne += `      nonce: ${te.nonce}
`), te.balance && (ne += `      balance: ${te.balance}
`), te.code && (ne += `      code: ${te.code}
`), te.state && (ne += `      state:
`, ne += ev(te.state)), te.stateDiff && (ne += `      stateDiff:
`, ne += ev(te.stateDiff)), ne;
  }, `  State Override:
`).slice(0, -1);
}
class YA extends Le {
  constructor(X, { account: ee, docsPath: te, chain: ne, data: ie, gas: oe, gasPrice: se, maxFeePerGas: ae, maxPriorityFeePerGas: ue, nonce: le, to: he, value: me, stateOverride: ye }) {
    var we;
    const Ee = ee ? Hn(ee) : void 0;
    let Re = Af({
      from: Ee == null ? void 0 : Ee.address,
      to: he,
      value: typeof me < "u" && `${Py(me)} ${((we = ne == null ? void 0 : ne.nativeCurrency) == null ? void 0 : we.symbol) || "ETH"}`,
      data: ie,
      gas: oe,
      gasPrice: typeof se < "u" && `${Cn(se)} gwei`,
      maxFeePerGas: typeof ae < "u" && `${Cn(ae)} gwei`,
      maxPriorityFeePerGas: typeof ue < "u" && `${Cn(ue)} gwei`,
      nonce: le
    });
    ye && (Re += `
${tU(ye)}`), super(X.shortMessage, {
      cause: X,
      docsPath: te,
      metaMessages: [
        ...X.metaMessages ? [...X.metaMessages, " "] : [],
        "Raw Call Arguments:",
        Re
      ].filter(Boolean)
    }), Object.defineProperty(this, "cause", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "CallExecutionError"
    }), this.cause = X;
  }
}
class rU extends Le {
  constructor(X, { abi: ee, args: te, contractAddress: ne, docsPath: ie, functionName: oe, sender: se }) {
    const ae = Tf({ abi: ee, args: te, name: oe }), ue = ae ? JA({
      abiItem: ae,
      args: te,
      includeFunctionName: !1,
      includeName: !1
    }) : void 0, le = ae ? Ps(ae, { includeName: !0 }) : void 0, he = Af({
      address: ne && t$(ne),
      function: le,
      args: ue && ue !== "()" && `${[...Array((oe == null ? void 0 : oe.length) ?? 0).keys()].map(() => " ").join("")}${ue}`,
      sender: se
    });
    super(X.shortMessage || `An unknown error occurred while executing the contract function "${oe}".`, {
      cause: X,
      docsPath: ie,
      metaMessages: [
        ...X.metaMessages ? [...X.metaMessages, " "] : [],
        "Contract Call:",
        he
      ].filter(Boolean)
    }), Object.defineProperty(this, "abi", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "args", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "cause", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "contractAddress", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "formattedArgs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "functionName", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "sender", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ContractFunctionExecutionError"
    }), this.abi = ee, this.args = te, this.cause = X, this.contractAddress = ne, this.functionName = oe, this.sender = se;
  }
}
class vg extends Le {
  constructor({ abi: X, data: ee, functionName: te, message: ne }) {
    let ie, oe, se, ae;
    if (ee && ee !== "0x")
      try {
        oe = ZD({ abi: X, data: ee });
        const { abiItem: le, errorName: he, args: me } = oe;
        if (he === "Error")
          ae = me[0];
        else if (he === "Panic") {
          const [ye] = me;
          ae = KA[ye];
        } else {
          const ye = le ? Ps(le, { includeName: !0 }) : void 0, we = le && me ? JA({
            abiItem: le,
            args: me,
            includeFunctionName: !1,
            includeName: !1
          }) : void 0;
          se = [
            ye ? `Error: ${ye}` : "",
            we && we !== "()" ? `       ${[...Array((he == null ? void 0 : he.length) ?? 0).keys()].map(() => " ").join("")}${we}` : ""
          ];
        }
      } catch (le) {
        ie = le;
      }
    else
      ne && (ae = ne);
    let ue;
    ie instanceof wA && (ue = ie.signature, se = [
      `Unable to decode signature "${ue}" as it was not found on the provided ABI.`,
      "Make sure you are using the correct ABI and that the error exists on it.",
      `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${ue}.`
    ]), super(ae && ae !== "execution reverted" || ue ? [
      `The contract function "${te}" reverted with the following ${ue ? "signature" : "reason"}:`,
      ae || ue
    ].join(`
`) : `The contract function "${te}" reverted.`, {
      cause: ie,
      metaMessages: se
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ContractFunctionRevertedError"
    }), Object.defineProperty(this, "data", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "reason", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "signature", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.data = oe, this.reason = ae, this.signature = ue;
  }
}
class nU extends Le {
  constructor({ functionName: X }) {
    super(`The contract function "${X}" returned no data ("0x").`, {
      metaMessages: [
        "This could be due to any of the following:",
        `  - The contract does not have the function "${X}",`,
        "  - The parameters passed to the contract function may be invalid, or",
        "  - The address is not a contract."
      ]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ContractFunctionZeroDataError"
    });
  }
}
class Uy extends Le {
  constructor({ data: X, message: ee }) {
    super(ee || ""), Object.defineProperty(this, "code", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 3
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "RawContractError"
    }), Object.defineProperty(this, "data", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.data = X;
  }
}
function jy(Y, X) {
  var ee, te, ne, ie, oe, se;
  if (!(Y instanceof Le))
    return !1;
  const ae = Y.walk((ue) => ue instanceof vg);
  return ae instanceof vg ? !!(((ee = ae.data) == null ? void 0 : ee.errorName) === "ResolverNotFound" || ((te = ae.data) == null ? void 0 : te.errorName) === "ResolverWildcardNotSupported" || ((ne = ae.data) == null ? void 0 : ne.errorName) === "ResolverNotContract" || ((ie = ae.data) == null ? void 0 : ie.errorName) === "ResolverError" || ((oe = ae.data) == null ? void 0 : oe.errorName) === "HttpError" || (se = ae.reason) != null && se.includes("Wildcard on non-extended resolvers is not supported") || X === "reverse" && ae.reason === KA[50]) : !1;
}
function XA(Y) {
  if (Y.length !== 66 || Y.indexOf("[") !== 0 || Y.indexOf("]") !== 65)
    return null;
  const X = `0x${Y.slice(1, 65)}`;
  return es(X) ? X : null;
}
function Tl(Y) {
  let X = new Uint8Array(32).fill(0);
  if (!Y)
    return wi(X);
  const ee = Y.split(".");
  for (let te = ee.length - 1; te >= 0; te -= 1) {
    const ne = XA(ee[te]), ie = ne ? Do(ne) : Rn(As(ee[te]), "bytes");
    X = Rn(Os([X, ie]), "bytes");
  }
  return wi(X);
}
function iU(Y) {
  return `[${Y.slice(2)}]`;
}
function sU(Y) {
  const X = new Uint8Array(32).fill(0);
  return Y ? XA(Y) || Rn(As(Y)) : wi(X);
}
function E0(Y) {
  const X = Y.replace(/^\.|\.$/gm, "");
  if (X.length === 0)
    return new Uint8Array(1);
  const ee = new Uint8Array(As(X).byteLength + 2);
  let te = 0;
  const ne = X.split(".");
  for (let ie = 0; ie < ne.length; ie++) {
    let oe = As(ne[ie]);
    oe.byteLength > 255 && (oe = As(iU(sU(ne[ie])))), ee[te] = oe.length, ee.set(oe, te + 1), te += oe.length + 1;
  }
  return ee.byteLength !== te + 1 ? ee.slice(0, te + 1) : ee;
}
const oU = 3;
function Zu(Y, { abi: X, address: ee, args: te, docsPath: ne, functionName: ie, sender: oe }) {
  const { code: se, data: ae, message: ue, shortMessage: le } = Y instanceof Uy ? Y : Y instanceof Le ? Y.walk((me) => "data" in me) || Y.walk() : {}, he = Y instanceof p0 ? new nU({ functionName: ie }) : [oU, Uo.code].includes(se) && (ae || ue || le) ? new vg({
    abi: X,
    data: typeof ae == "object" ? ae.data : ae,
    functionName: ie,
    message: le ?? ue
  }) : Y;
  return new rU(he, {
    abi: X,
    args: te,
    contractAddress: ee,
    docsPath: ne,
    functionName: ie,
    sender: oe
  });
}
const aU = "0x82ad56cb";
function cU(Y, { docsPath: X, ...ee }) {
  const te = (() => {
    const ne = Oy(Y, ee);
    return ne instanceof b0 ? Y : ne;
  })();
  return new YA(te, {
    docsPath: X,
    ...ee
  });
}
const bp = /* @__PURE__ */ new Map();
function uU({ fn: Y, id: X, shouldSplitBatch: ee, wait: te = 0, sort: ne }) {
  const ie = async () => {
    const le = ae();
    oe();
    const he = le.map(({ args: me }) => me);
    he.length !== 0 && Y(he).then((me) => {
      var ye;
      ne && Array.isArray(me) && me.sort(ne);
      for (let we = 0; we < le.length; we++) {
        const { pendingPromise: Ee } = le[we];
        (ye = Ee.resolve) == null || ye.call(Ee, [me[we], me]);
      }
    }).catch((me) => {
      var ye;
      for (let we = 0; we < le.length; we++) {
        const { pendingPromise: Ee } = le[we];
        (ye = Ee.reject) == null || ye.call(Ee, me);
      }
    });
  }, oe = () => bp.delete(X), se = () => ae().map(({ args: le }) => le), ae = () => bp.get(X) || [], ue = (le) => bp.set(X, [...ae(), le]);
  return {
    flush: oe,
    async schedule(le) {
      const he = {}, me = new Promise((ye, we) => {
        he.resolve = ye, he.reject = we;
      });
      return ee != null && ee([...se(), le]) && ie(), ae().length > 0 ? (ue({ args: le, pendingPromise: he }), me) : (ue({ args: le, pendingPromise: he }), setTimeout(ie, te), me);
    }
  };
}
async function _0(Y, X) {
  var ee, te, ne, ie;
  const { account: oe = Y.account, batch: se = !!((ee = Y.batch) != null && ee.multicall), blockNumber: ae, blockTag: ue = "latest", accessList: le, data: he, gas: me, gasPrice: ye, maxFeePerGas: we, maxPriorityFeePerGas: Ee, nonce: Re, to: Ue, value: Me, stateOverride: De, ...Fe } = X, Ke = oe ? Hn(oe) : void 0;
  try {
    Sf(X);
    const tt = (ae ? Rt(ae) : void 0) || ue, rt = pU(De), it = (ie = (ne = (te = Y.chain) == null ? void 0 : te.formatters) == null ? void 0 : ne.transactionRequest) == null ? void 0 : ie.format, _t = (it || x0)({
      // Pick out extra data that might exist on the chain's transaction request type.
      ...By(Fe, { format: it }),
      from: Ke == null ? void 0 : Ke.address,
      accessList: le,
      data: he,
      gas: me,
      gasPrice: ye,
      maxFeePerGas: we,
      maxPriorityFeePerGas: Ee,
      nonce: Re,
      to: Ue,
      value: Me
    });
    if (se && fU({ request: _t }) && !rt)
      try {
        return await lU(Y, {
          ..._t,
          blockNumber: ae,
          blockTag: ue
        });
      } catch (je) {
        if (!(je instanceof OA) && !(je instanceof ag))
          throw je;
      }
    const Dt = await Y.request({
      method: "eth_call",
      params: rt ? [_t, tt, rt] : [_t, tt]
    });
    return Dt === "0x" ? { data: void 0 } : { data: Dt };
  } catch (tt) {
    const rt = dU(tt), { offchainLookup: it, offchainLookupSignature: _t } = await import("./ccip-BP_X23CM-Bp9dDwC5-CD11B-vo.mjs");
    if ((rt == null ? void 0 : rt.slice(0, 10)) === _t && Ue)
      return { data: await it(Y, { data: rt, to: Ue }) };
    throw cU(tt, {
      ...X,
      account: Ke,
      chain: Y.chain
    });
  }
}
function fU({ request: Y }) {
  const { data: X, to: ee, ...te } = Y;
  return !(!X || X.startsWith(aU) || !ee || Object.values(te).filter((ne) => typeof ne < "u").length > 0);
}
async function lU(Y, X) {
  var ee;
  const { batchSize: te = 1024, wait: ne = 0 } = typeof ((ee = Y.batch) == null ? void 0 : ee.multicall) == "object" ? Y.batch.multicall : {}, { blockNumber: ie, blockTag: oe = "latest", data: se, multicallAddress: ae, to: ue } = X;
  let le = ae;
  if (!le) {
    if (!Y.chain)
      throw new OA();
    le = Pc({
      blockNumber: ie,
      chain: Y.chain,
      contract: "multicall3"
    });
  }
  const he = (ie ? Rt(ie) : void 0) || oe, { schedule: me } = uU({
    id: `${Y.uid}.${he}`,
    wait: ne,
    shouldSplitBatch(Ee) {
      return Ee.reduce((Re, { data: Ue }) => Re + (Ue.length - 2), 0) > te * 2;
    },
    fn: async (Ee) => {
      const Re = Ee.map((De) => ({
        allowFailure: !0,
        callData: De.data,
        target: De.to
      })), Ue = bo({
        abi: yg,
        args: [Re],
        functionName: "aggregate3"
      }), Me = await Y.request({
        method: "eth_call",
        params: [
          {
            data: Ue,
            to: le
          },
          he
        ]
      });
      return Cc({
        abi: yg,
        args: [Re],
        functionName: "aggregate3",
        data: Me || "0x"
      });
    }
  }), [{ returnData: ye, success: we }] = await me({ data: se, to: ue });
  if (!we)
    throw new Uy({ data: ye });
  return ye === "0x" ? { data: void 0 } : { data: ye };
}
function dU(Y) {
  if (!(Y instanceof Le))
    return;
  const X = Y.walk();
  return typeof X.data == "object" ? X.data.data : X.data;
}
function tv(Y) {
  if (!(!Y || Y.length === 0))
    return Y.reduce((X, { slot: ee, value: te }) => {
      if (ee.length !== 66)
        throw new Dw({
          size: ee.length,
          targetSize: 66,
          type: "hex"
        });
      if (te.length !== 66)
        throw new Dw({
          size: te.length,
          targetSize: 66,
          type: "hex"
        });
      return X[ee] = te, X;
    }, {});
}
function hU(Y) {
  const { balance: X, nonce: ee, state: te, stateDiff: ne, code: ie } = Y, oe = {};
  if (ie !== void 0 && (oe.code = ie), X !== void 0 && (oe.balance = Rt(X, { size: 32 })), ee !== void 0 && (oe.nonce = Rt(ee, { size: 8 })), te !== void 0 && (oe.state = tv(te)), ne !== void 0) {
    if (oe.state)
      throw new eU();
    oe.stateDiff = tv(ne);
  }
  return oe;
}
function pU(Y) {
  if (!Y)
    return;
  const X = {};
  for (const { address: ee, ...te } of Y) {
    if (!Bs(ee, { strict: !1 }))
      throw new Za({ address: ee });
    if (X[ee])
      throw new QD({ address: ee });
    X[ee] = hU(te);
  }
  return X;
}
async function fo(Y, X) {
  const { abi: ee, address: te, args: ne, functionName: ie, ...oe } = X, se = bo({
    abi: ee,
    args: ne,
    functionName: ie
  });
  try {
    const { data: ae } = await at(Y, _0, "call")({
      ...oe,
      data: se,
      to: te
    });
    return Cc({
      abi: ee,
      args: ne,
      functionName: ie,
      data: ae || "0x"
    });
  } catch (ae) {
    throw Zu(ae, {
      abi: ee,
      address: te,
      args: ne,
      docsPath: "/docs/contract/readContract",
      functionName: ie
    });
  }
}
async function gU(Y, { blockNumber: X, blockTag: ee, coinType: te, name: ne, gatewayUrls: ie, strict: oe, universalResolverAddress: se }) {
  let ae = se;
  if (!ae) {
    if (!Y.chain)
      throw new Error("client chain not configured. universalResolverAddress is required.");
    ae = Pc({
      blockNumber: X,
      chain: Y.chain,
      contract: "ensUniversalResolver"
    });
  }
  try {
    const ue = bo({
      abi: Jw,
      functionName: "addr",
      ...te != null ? { args: [Tl(ne), BigInt(te)] } : { args: [Tl(ne)] }
    }), le = {
      address: ae,
      abi: qA,
      functionName: "resolve",
      args: [$s(E0(ne)), ue],
      blockNumber: X,
      blockTag: ee
    }, he = at(Y, fo, "readContract"), me = ie ? await he({
      ...le,
      args: [...le.args, ie]
    }) : await he(le);
    if (me[0] === "0x")
      return null;
    const ye = Cc({
      abi: Jw,
      args: te != null ? [Tl(ne), BigInt(te)] : void 0,
      functionName: "addr",
      data: me[0]
    });
    return ye === "0x" || l0(ye) === "0x00" ? null : ye;
  } catch (ue) {
    if (oe)
      throw ue;
    if (jy(ue, "resolve"))
      return null;
    throw ue;
  }
}
class mU extends Le {
  constructor({ data: X }) {
    super("Unable to extract image from metadata. The metadata may be malformed or invalid.", {
      metaMessages: [
        "- Metadata must be a JSON object with at least an `image`, `image_url` or `image_data` property.",
        "",
        `Provided data: ${JSON.stringify(X)}`
      ]
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "EnsAvatarInvalidMetadataError"
    });
  }
}
class Qc extends Le {
  constructor({ reason: X }) {
    super(`ENS NFT avatar URI is invalid. ${X}`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "EnsAvatarInvalidNftUriError"
    });
  }
}
class Hy extends Le {
  constructor({ uri: X }) {
    super(`Unable to resolve ENS avatar URI "${X}". The URI may be malformed, invalid, or does not respond with a valid image.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "EnsAvatarUriResolutionError"
    });
  }
}
class yU extends Le {
  constructor({ namespace: X }) {
    super(`ENS NFT avatar namespace "${X}" is not supported. Must be "erc721" or "erc1155".`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "EnsAvatarUnsupportedNamespaceError"
    });
  }
}
const bU = /(?<protocol>https?:\/\/[^\/]*|ipfs:\/|ipns:\/|ar:\/)?(?<root>\/)?(?<subpath>ipfs\/|ipns\/)?(?<target>[\w\-.]+)(?<subtarget>\/.*)?/, xU = /^(Qm[1-9A-HJ-NP-Za-km-z]{44,}|b[A-Za-z2-7]{58,}|B[A-Z2-7]{58,}|z[1-9A-HJ-NP-Za-km-z]{48,}|F[0-9A-F]{50,})(\/(?<target>[\w\-.]+))?(?<subtarget>\/.*)?$/, wU = /^data:([a-zA-Z\-/+]*);base64,([^"].*)/, vU = /^data:([a-zA-Z\-/+]*)?(;[a-zA-Z0-9].*?)?(,)/;
async function EU(Y) {
  try {
    const X = await fetch(Y, { method: "HEAD" });
    if (X.status === 200) {
      const ee = X.headers.get("content-type");
      return ee == null ? void 0 : ee.startsWith("image/");
    }
    return !1;
  } catch (X) {
    return typeof X == "object" && typeof X.response < "u" || !globalThis.hasOwnProperty("Image") ? !1 : new Promise((ee) => {
      const te = new Image();
      te.onload = () => {
        ee(!0);
      }, te.onerror = () => {
        ee(!1);
      }, te.src = Y;
    });
  }
}
function rv(Y, X) {
  return Y ? Y.endsWith("/") ? Y.slice(0, -1) : Y : X;
}
function ZA({ uri: Y, gatewayUrls: X }) {
  const ee = wU.test(Y);
  if (ee)
    return { uri: Y, isOnChain: !0, isEncoded: ee };
  const te = rv(X == null ? void 0 : X.ipfs, "https://ipfs.io"), ne = rv(X == null ? void 0 : X.arweave, "https://arweave.net"), ie = Y.match(bU), { protocol: oe, subpath: se, target: ae, subtarget: ue = "" } = (ie == null ? void 0 : ie.groups) || {}, le = oe === "ipns:/" || se === "ipns/", he = oe === "ipfs:/" || se === "ipfs/" || xU.test(Y);
  if (Y.startsWith("http") && !le && !he) {
    let ye = Y;
    return X != null && X.arweave && (ye = Y.replace(/https:\/\/arweave.net/g, X == null ? void 0 : X.arweave)), { uri: ye, isOnChain: !1, isEncoded: !1 };
  }
  if ((le || he) && ae)
    return {
      uri: `${te}/${le ? "ipns" : "ipfs"}/${ae}${ue}`,
      isOnChain: !1,
      isEncoded: !1
    };
  if (oe === "ar:/" && ae)
    return {
      uri: `${ne}/${ae}${ue || ""}`,
      isOnChain: !1,
      isEncoded: !1
    };
  let me = Y.replace(vU, "");
  if (me.startsWith("<svg") && (me = `data:image/svg+xml;base64,${btoa(me)}`), me.startsWith("data:") || me.startsWith("{"))
    return {
      uri: me,
      isOnChain: !0,
      isEncoded: !1
    };
  throw new Hy({ uri: Y });
}
function QA(Y) {
  if (typeof Y != "object" || !("image" in Y) && !("image_url" in Y) && !("image_data" in Y))
    throw new mU({ data: Y });
  return Y.image || Y.image_url || Y.image_data;
}
async function _U({ gatewayUrls: Y, uri: X }) {
  try {
    const ee = await fetch(X).then((te) => te.json());
    return await zy({
      gatewayUrls: Y,
      uri: QA(ee)
    });
  } catch {
    throw new Hy({ uri: X });
  }
}
async function zy({ gatewayUrls: Y, uri: X }) {
  const { uri: ee, isOnChain: te } = ZA({ uri: X, gatewayUrls: Y });
  if (te || await EU(ee))
    return ee;
  throw new Hy({ uri: X });
}
function AU(Y) {
  let X = Y;
  X.startsWith("did:nft:") && (X = X.replace("did:nft:", "").replace(/_/g, "/"));
  const [ee, te, ne] = X.split("/"), [ie, oe] = ee.split(":"), [se, ae] = te.split(":");
  if (!ie || ie.toLowerCase() !== "eip155")
    throw new Qc({ reason: "Only EIP-155 supported" });
  if (!oe)
    throw new Qc({ reason: "Chain ID not found" });
  if (!ae)
    throw new Qc({
      reason: "Contract address not found"
    });
  if (!ne)
    throw new Qc({ reason: "Token ID not found" });
  if (!se)
    throw new Qc({ reason: "ERC namespace not found" });
  return {
    chainID: parseInt(oe),
    namespace: se.toLowerCase(),
    contractAddress: ae,
    tokenID: ne
  };
}
async function SU(Y, { nft: X }) {
  if (X.namespace === "erc721")
    return fo(Y, {
      address: X.contractAddress,
      abi: [
        {
          name: "tokenURI",
          type: "function",
          stateMutability: "view",
          inputs: [{ name: "tokenId", type: "uint256" }],
          outputs: [{ name: "", type: "string" }]
        }
      ],
      functionName: "tokenURI",
      args: [BigInt(X.tokenID)]
    });
  if (X.namespace === "erc1155")
    return fo(Y, {
      address: X.contractAddress,
      abi: [
        {
          name: "uri",
          type: "function",
          stateMutability: "view",
          inputs: [{ name: "_id", type: "uint256" }],
          outputs: [{ name: "", type: "string" }]
        }
      ],
      functionName: "uri",
      args: [BigInt(X.tokenID)]
    });
  throw new yU({ namespace: X.namespace });
}
async function TU(Y, { gatewayUrls: X, record: ee }) {
  return /eip155:/i.test(ee) ? IU(Y, { gatewayUrls: X, record: ee }) : zy({ uri: ee, gatewayUrls: X });
}
async function IU(Y, { gatewayUrls: X, record: ee }) {
  const te = AU(ee), ne = await SU(Y, { nft: te }), { uri: ie, isOnChain: oe, isEncoded: se } = ZA({ uri: ne, gatewayUrls: X });
  if (oe && (ie.includes("data:application/json;base64,") || ie.startsWith("{"))) {
    const ue = se ? (
      // if it is encoded, decode it
      atob(ie.replace("data:application/json;base64,", ""))
    ) : (
      // if it isn't encoded assume it is a JSON string, but it could be anything (it will error if it is)
      ie
    ), le = JSON.parse(ue);
    return zy({ uri: QA(le), gatewayUrls: X });
  }
  let ae = te.tokenID;
  return te.namespace === "erc1155" && (ae = ae.replace("0x", "").padStart(64, "0")), _U({
    gatewayUrls: X,
    uri: ie.replace(/(?:0x)?{id}/, ae)
  });
}
async function eS(Y, { blockNumber: X, blockTag: ee, name: te, key: ne, gatewayUrls: ie, strict: oe, universalResolverAddress: se }) {
  let ae = se;
  if (!ae) {
    if (!Y.chain)
      throw new Error("client chain not configured. universalResolverAddress is required.");
    ae = Pc({
      blockNumber: X,
      chain: Y.chain,
      contract: "ensUniversalResolver"
    });
  }
  try {
    const ue = {
      address: ae,
      abi: qA,
      functionName: "resolve",
      args: [
        $s(E0(te)),
        bo({
          abi: Kw,
          functionName: "text",
          args: [Tl(te), ne]
        })
      ],
      blockNumber: X,
      blockTag: ee
    }, le = at(Y, fo, "readContract"), he = ie ? await le({
      ...ue,
      args: [...ue.args, ie]
    }) : await le(ue);
    if (he[0] === "0x")
      return null;
    const me = Cc({
      abi: Kw,
      functionName: "text",
      data: he[0]
    });
    return me === "" ? null : me;
  } catch (ue) {
    if (oe)
      throw ue;
    if (jy(ue, "resolve"))
      return null;
    throw ue;
  }
}
async function RU(Y, { blockNumber: X, blockTag: ee, assetGatewayUrls: te, name: ne, gatewayUrls: ie, strict: oe, universalResolverAddress: se }) {
  const ae = await at(Y, eS, "getEnsText")({
    blockNumber: X,
    blockTag: ee,
    key: "avatar",
    name: ne,
    universalResolverAddress: se,
    gatewayUrls: ie,
    strict: oe
  });
  if (!ae)
    return null;
  try {
    return await TU(Y, {
      record: ae,
      gatewayUrls: te
    });
  } catch {
    return null;
  }
}
async function CU(Y, { address: X, blockNumber: ee, blockTag: te, gatewayUrls: ne, strict: ie, universalResolverAddress: oe }) {
  let se = oe;
  if (!se) {
    if (!Y.chain)
      throw new Error("client chain not configured. universalResolverAddress is required.");
    se = Pc({
      blockNumber: ee,
      chain: Y.chain,
      contract: "ensUniversalResolver"
    });
  }
  const ae = `${X.toLowerCase().substring(2)}.addr.reverse`;
  try {
    const ue = {
      address: se,
      abi: CD,
      functionName: "reverse",
      args: [$s(E0(ae))],
      blockNumber: ee,
      blockTag: te
    }, le = at(Y, fo, "readContract"), [he, me] = ne ? await le({
      ...ue,
      args: [...ue.args, ne]
    }) : await le(ue);
    return X.toLowerCase() !== me.toLowerCase() ? null : he;
  } catch (ue) {
    if (ie)
      throw ue;
    if (jy(ue, "reverse"))
      return null;
    throw ue;
  }
}
async function PU(Y, { blockNumber: X, blockTag: ee, name: te, universalResolverAddress: ne }) {
  let ie = ne;
  if (!ie) {
    if (!Y.chain)
      throw new Error("client chain not configured. universalResolverAddress is required.");
    ie = Pc({
      blockNumber: X,
      chain: Y.chain,
      contract: "ensUniversalResolver"
    });
  }
  const [oe] = await at(Y, fo, "readContract")({
    address: ie,
    abi: [
      {
        inputs: [{ type: "bytes" }],
        name: "findResolver",
        outputs: [{ type: "address" }, { type: "bytes32" }],
        stateMutability: "view",
        type: "function"
      }
    ],
    functionName: "findResolver",
    args: [$s(E0(te))],
    blockNumber: X,
    blockTag: ee
  });
  return oe;
}
function A0(Y, { method: X }) {
  var ee, te;
  const ne = {};
  return Y.transport.type === "fallback" && ((te = (ee = Y.transport).onResponse) == null || te.call(ee, ({ method: ie, response: oe, status: se, transport: ae }) => {
    se === "success" && X === ie && (ne[oe] = ae.request);
  })), (ie) => ne[ie] || Y.request;
}
async function OU(Y) {
  const X = A0(Y, {
    method: "eth_newBlockFilter"
  }), ee = await Y.request({
    method: "eth_newBlockFilter"
  });
  return { id: ee, request: X(ee), type: "block" };
}
class BU extends Le {
  constructor(X) {
    super(`Filter type "${X}" is not supported.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "FilterTypeNotSupportedError"
    });
  }
}
const nv = "/docs/contract/encodeEventTopics";
function If(Y) {
  var X;
  const { abi: ee, eventName: te, args: ne } = Y;
  let ie = ee[0];
  if (te) {
    const ue = Tf({ abi: ee, name: te });
    if (!ue)
      throw new Hw(te, { docsPath: nv });
    ie = ue;
  }
  if (ie.type !== "event")
    throw new Hw(void 0, { docsPath: nv });
  const oe = Ps(ie), se = $y(oe);
  let ae = [];
  if (ne && "inputs" in ie) {
    const ue = (X = ie.inputs) == null ? void 0 : X.filter((he) => "indexed" in he && he.indexed), le = Array.isArray(ne) ? ne : Object.values(ne).length > 0 ? (ue == null ? void 0 : ue.map((he) => ne[he.name])) ?? [] : [];
    le.length > 0 && (ae = (ue == null ? void 0 : ue.map((he, me) => Array.isArray(le[me]) ? le[me].map((ye, we) => iv({ param: he, value: le[me][we] })) : le[me] ? iv({ param: he, value: le[me] }) : null)) ?? []);
  }
  return [se, ...ae];
}
function iv({ param: Y, value: X }) {
  if (Y.type === "string" || Y.type === "bytes")
    return Rn(Do(X));
  if (Y.type === "tuple" || Y.type.match(/^(.*)\[(\d+)?\]$/))
    throw new BU(Y.type);
  return _f([Y], [X]);
}
async function tS(Y, X) {
  const { address: ee, abi: te, args: ne, eventName: ie, fromBlock: oe, strict: se, toBlock: ae } = X, ue = A0(Y, {
    method: "eth_newFilter"
  }), le = ie ? If({
    abi: te,
    args: ne,
    eventName: ie
  }) : void 0, he = await Y.request({
    method: "eth_newFilter",
    params: [
      {
        address: ee,
        fromBlock: typeof oe == "bigint" ? Rt(oe) : oe,
        toBlock: typeof ae == "bigint" ? Rt(ae) : ae,
        topics: le
      }
    ]
  });
  return {
    abi: te,
    args: ne,
    eventName: ie,
    id: he,
    request: ue(he),
    strict: !!se,
    type: "event"
  };
}
async function rS(Y, { address: X, args: ee, event: te, events: ne, fromBlock: ie, strict: oe, toBlock: se } = {}) {
  const ae = ne ?? (te ? [te] : void 0), ue = A0(Y, {
    method: "eth_newFilter"
  });
  let le = [];
  ae && (le = [
    ae.flatMap((me) => If({
      abi: [me],
      eventName: me.name,
      args: ee
    }))
  ], te && (le = le[0]));
  const he = await Y.request({
    method: "eth_newFilter",
    params: [
      {
        address: X,
        fromBlock: typeof ie == "bigint" ? Rt(ie) : ie,
        toBlock: typeof se == "bigint" ? Rt(se) : se,
        ...le.length ? { topics: le } : {}
      }
    ]
  });
  return {
    abi: ae,
    args: ee,
    eventName: te ? te.name : void 0,
    fromBlock: ie,
    id: he,
    request: ue(he),
    strict: !!oe,
    toBlock: se,
    type: "event"
  };
}
async function nS(Y) {
  const X = A0(Y, {
    method: "eth_newPendingTransactionFilter"
  }), ee = await Y.request({
    method: "eth_newPendingTransactionFilter"
  });
  return { id: ee, request: X(ee), type: "transaction" };
}
async function NU(Y, X) {
  const { abi: ee, address: te, args: ne, functionName: ie, ...oe } = X, se = bo({
    abi: ee,
    args: ne,
    functionName: ie
  });
  try {
    return await at(Y, My, "estimateGas")({
      data: se,
      to: te,
      ...oe
    });
  } catch (ae) {
    const ue = oe.account ? Hn(oe.account) : void 0;
    throw Zu(ae, {
      abi: ee,
      address: te,
      args: ne,
      docsPath: "/docs/contract/estimateContractGas",
      functionName: ie,
      sender: ue == null ? void 0 : ue.address
    });
  }
}
async function kU(Y, { address: X, blockNumber: ee, blockTag: te = "latest" }) {
  const ne = ee ? Rt(ee) : void 0, ie = await Y.request({
    method: "eth_getBalance",
    params: [X, ne || te]
  });
  return BigInt(ie);
}
const MU = /* @__PURE__ */ new Map(), LU = /* @__PURE__ */ new Map();
function FU(Y) {
  const X = (ne, ie) => ({
    clear: () => ie.delete(ne),
    get: () => ie.get(ne),
    set: (oe) => ie.set(ne, oe)
  }), ee = X(Y, MU), te = X(Y, LU);
  return {
    clear: () => {
      ee.clear(), te.clear();
    },
    promise: ee,
    response: te
  };
}
async function $U(Y, { cacheKey: X, cacheTime: ee = 1 / 0 }) {
  const te = FU(X), ne = te.response.get();
  if (ne && ee > 0 && (/* @__PURE__ */ new Date()).getTime() - ne.created.getTime() < ee)
    return ne.data;
  let ie = te.promise.get();
  ie || (ie = Y(), te.promise.set(ie));
  try {
    const oe = await ie;
    return te.response.set({ created: /* @__PURE__ */ new Date(), data: oe }), oe;
  } finally {
    te.promise.clear();
  }
}
const DU = (Y) => `blockNumber.${Y}`;
async function Rf(Y, { cacheTime: X = Y.cacheTime } = {}) {
  const ee = await $U(() => Y.request({
    method: "eth_blockNumber"
  }), { cacheKey: DU(Y.uid), cacheTime: X });
  return BigInt(ee);
}
async function UU(Y, { blockHash: X, blockNumber: ee, blockTag: te = "latest" } = {}) {
  const ne = ee !== void 0 ? Rt(ee) : void 0;
  let ie;
  return X ? ie = await Y.request({
    method: "eth_getBlockTransactionCountByHash",
    params: [X]
  }) : ie = await Y.request({
    method: "eth_getBlockTransactionCountByNumber",
    params: [ne || te]
  }), co(ie);
}
async function jU(Y, { address: X, blockNumber: ee, blockTag: te = "latest" }) {
  const ne = ee !== void 0 ? Rt(ee) : void 0, ie = await Y.request({
    method: "eth_getCode",
    params: [X, ne || te]
  });
  if (ie !== "0x")
    return ie;
}
const sv = "/docs/contract/decodeEventLog";
function qy(Y) {
  const { abi: X, data: ee, strict: te, topics: ne } = Y, ie = te ?? !0, [oe, ...se] = ne;
  if (!oe)
    throw new b$({ docsPath: sv });
  const ae = X.find((Ee) => Ee.type === "event" && oe === $y(Ps(Ee)));
  if (!(ae && "name" in ae) || ae.type !== "event")
    throw new vA(oe, { docsPath: sv });
  const { name: ue, inputs: le } = ae, he = le == null ? void 0 : le.some((Ee) => !("name" in Ee && Ee.name));
  let me = he ? [] : {};
  const ye = le.filter((Ee) => "indexed" in Ee && Ee.indexed);
  for (let Ee = 0; Ee < ye.length; Ee++) {
    const Re = ye[Ee], Ue = se[Ee];
    if (!Ue)
      throw new g0({
        abiItem: ae,
        param: Re
      });
    me[Re.name || Ee] = HU({ param: Re, value: Ue });
  }
  const we = le.filter((Ee) => !("indexed" in Ee && Ee.indexed));
  if (we.length > 0) {
    if (ee && ee !== "0x")
      try {
        const Ee = v0(we, ee);
        if (Ee)
          if (he)
            me = [...me, ...Ee];
          else
            for (let Re = 0; Re < we.length; Re++)
              me[we[Re].name] = Ee[Re];
      } catch (Ee) {
        if (ie)
          throw Ee instanceof xA || Ee instanceof GA ? new Mu({
            abiItem: ae,
            data: ee,
            params: we,
            size: Hr(ee)
          }) : Ee;
      }
    else if (ie)
      throw new Mu({
        abiItem: ae,
        data: "0x",
        params: we,
        size: 0
      });
  }
  return {
    eventName: ue,
    args: Object.values(me).length > 0 ? me : void 0
  };
}
function HU({ param: Y, value: X }) {
  return Y.type === "string" || Y.type === "bytes" || Y.type === "tuple" || Y.type.match(/^(.*)\[(\d+)?\]$/) ? X : (v0([Y], X) || [])[0];
}
async function zU(Y, X) {
  const { abi: ee, address: te, args: ne, dataSuffix: ie, functionName: oe, ...se } = X, ae = se.account ? Hn(se.account) : Y.account, ue = bo({ abi: ee, args: ne, functionName: oe });
  try {
    const { data: le } = await at(Y, _0, "call")({
      batch: !1,
      data: `${ue}${ie ? ie.replace("0x", "") : ""}`,
      to: te,
      ...se,
      account: ae
    }), he = Cc({
      abi: ee,
      args: ne,
      functionName: oe,
      data: le || "0x"
    }), me = ee.filter((ye) => "name" in ye && ye.name === X.functionName);
    return {
      result: he,
      request: {
        abi: me,
        address: te,
        args: ne,
        dataSuffix: ie,
        functionName: oe,
        ...se,
        account: ae
      }
    };
  } catch (le) {
    throw Zu(le, {
      abi: ee,
      address: te,
      args: ne,
      docsPath: "/docs/contract/simulateContract",
      functionName: oe,
      sender: ae == null ? void 0 : ae.address
    });
  }
}
function lo(Y, { args: X, eventName: ee } = {}) {
  return {
    ...Y,
    blockHash: Y.blockHash ? Y.blockHash : null,
    blockNumber: Y.blockNumber ? BigInt(Y.blockNumber) : null,
    logIndex: Y.logIndex ? Number(Y.logIndex) : null,
    transactionHash: Y.transactionHash ? Y.transactionHash : null,
    transactionIndex: Y.transactionIndex ? Number(Y.transactionIndex) : null,
    ...ee ? { args: X, eventName: ee } : {}
  };
}
const xp = /* @__PURE__ */ new Map(), ov = /* @__PURE__ */ new Map();
let qU = 0;
function Oc(Y, X, ee) {
  const te = ++qU, ne = () => xp.get(Y) || [], ie = () => {
    const le = ne();
    xp.set(Y, le.filter((he) => he.id !== te));
  }, oe = () => {
    const le = ov.get(Y);
    ne().length === 1 && le && le(), ie();
  }, se = ne();
  if (xp.set(Y, [
    ...se,
    { id: te, fns: X }
  ]), se && se.length > 0)
    return oe;
  const ae = {};
  for (const le in X)
    ae[le] = (...he) => {
      var me, ye;
      const we = ne();
      if (we.length !== 0)
        for (const Ee of we)
          (ye = (me = Ee.fns)[le]) == null || ye.call(me, ...he);
    };
  const ue = ee(ae);
  return typeof ue == "function" && ov.set(Y, ue), oe;
}
async function Eg(Y) {
  return new Promise((X) => setTimeout(X, Y));
}
function Cf(Y, { emitOnBegin: X, initialWaitTime: ee, interval: te }) {
  let ne = !0;
  const ie = () => ne = !1;
  return (async () => {
    let oe;
    X && (oe = await Y({ unpoll: ie }));
    const se = await (ee == null ? void 0 : ee(oe)) ?? te;
    await Eg(se);
    const ae = async () => {
      ne && (await Y({ unpoll: ie }), await Eg(te), ae());
    };
    ae();
  })(), ie;
}
async function S0(Y, { filter: X }) {
  const ee = "strict" in X && X.strict, te = await X.request({
    method: "eth_getFilterChanges",
    params: [X.id]
  });
  if (typeof te[0] == "string")
    return te;
  const ne = te.map((ie) => lo(ie));
  return !("abi" in X) || !X.abi ? ne : Vy({
    abi: X.abi,
    logs: ne,
    strict: ee
  });
}
async function T0(Y, { filter: X }) {
  return X.request({
    method: "eth_uninstallFilter",
    params: [X.id]
  });
}
function GU(Y, X) {
  const { abi: ee, address: te, args: ne, batch: ie = !0, eventName: oe, onError: se, onLogs: ae, poll: ue, pollingInterval: le = Y.pollingInterval, strict: he } = X;
  return (typeof ue < "u" ? ue : Y.transport.type !== "webSocket") ? (() => {
    const me = ss([
      "watchContractEvent",
      te,
      ne,
      ie,
      Y.uid,
      oe,
      le
    ]), ye = he ?? !1;
    return Oc(me, { onLogs: ae, onError: se }, (we) => {
      let Ee, Re, Ue = !1;
      const Me = Cf(async () => {
        var De;
        if (!Ue) {
          try {
            Re = await at(Y, tS, "createContractEventFilter")({
              abi: ee,
              address: te,
              args: ne,
              eventName: oe,
              strict: ye
            });
          } catch {
          }
          Ue = !0;
          return;
        }
        try {
          let Fe;
          if (Re)
            Fe = await at(Y, S0, "getFilterChanges")({ filter: Re });
          else {
            const Ke = await at(Y, Rf, "getBlockNumber")({});
            Ee && Ee !== Ke ? Fe = await at(Y, hS, "getContractEvents")({
              abi: ee,
              address: te,
              args: ne,
              eventName: oe,
              fromBlock: Ee + 1n,
              toBlock: Ke,
              strict: ye
            }) : Fe = [], Ee = Ke;
          }
          if (Fe.length === 0)
            return;
          if (ie)
            we.onLogs(Fe);
          else
            for (const Ke of Fe)
              we.onLogs([Ke]);
        } catch (Fe) {
          Re && Fe instanceof jo && (Ue = !1), (De = we.onError) == null || De.call(we, Fe);
        }
      }, {
        emitOnBegin: !0,
        interval: le
      });
      return async () => {
        Re && await at(Y, T0, "uninstallFilter")({ filter: Re }), Me();
      };
    });
  })() : (() => {
    let me = !0, ye = () => me = !1;
    return (async () => {
      try {
        const we = oe ? If({
          abi: ee,
          eventName: oe,
          args: ne
        }) : [], { unsubscribe: Ee } = await Y.transport.subscribe({
          params: ["logs", { address: te, topics: we }],
          onData(Re) {
            var Ue;
            if (!me)
              return;
            const Me = Re.result;
            try {
              const { eventName: De, args: Fe } = qy({
                abi: ee,
                data: Me.data,
                topics: Me.topics,
                strict: he
              }), Ke = lo(Me, {
                args: Fe,
                eventName: De
              });
              ae([Ke]);
            } catch (De) {
              let Fe, Ke;
              if (De instanceof Mu || De instanceof g0) {
                if (he)
                  return;
                Fe = De.abiItem.name, Ke = (Ue = De.abiItem.inputs) == null ? void 0 : Ue.some((rt) => !("name" in rt && rt.name));
              }
              const tt = lo(Me, {
                args: Ke ? [] : {},
                eventName: Fe
              });
              ae([tt]);
            }
          },
          onError(Re) {
            se == null || se(Re);
          }
        });
        ye = Ee, me || ye();
      } catch (we) {
        se == null || se(we);
      }
    })(), ye;
  })();
}
async function VU(Y, X) {
  const { abi: ee, address: te, args: ne, dataSuffix: ie, functionName: oe, ...se } = X, ae = bo({
    abi: ee,
    args: ne,
    functionName: oe
  });
  return at(Y, Fy, "sendTransaction")({
    data: `${ae}${ie ? ie.replace("0x", "") : ""}`,
    to: te,
    ...se
  });
}
const _g = 256;
let el = _g, tl;
function WU(Y = 11) {
  if (!tl || el + Y > _g * 2) {
    tl = "", el = 0;
    for (let X = 0; X < _g; X++)
      tl += (256 + Math.random() * 256 | 0).toString(16).substring(1);
  }
  return tl.substring(el, el++ + Y);
}
function KU(Y) {
  const { batch: X, cacheTime: ee = Y.pollingInterval ?? 4e3, key: te = "base", name: ne = "Base Client", pollingInterval: ie = 4e3, type: oe = "base" } = Y, se = Y.chain, ae = Y.account ? Hn(Y.account) : void 0, { config: ue, request: le, value: he } = Y.transport({
    chain: se,
    pollingInterval: ie
  }), me = { ...ue, ...he }, ye = {
    account: ae,
    batch: X,
    cacheTime: ee,
    chain: se,
    key: te,
    name: ne,
    pollingInterval: ie,
    request: le,
    transport: me,
    type: oe,
    uid: WU()
  };
  function we(Ee) {
    return (Re) => {
      const Ue = Re(Ee);
      for (const De in ye)
        delete Ue[De];
      const Me = { ...Ee, ...Ue };
      return Object.assign(Me, { extend: we(Me) });
    };
  }
  return Object.assign(ye, { extend: we(ye) });
}
function Ag(Y, { delay: X = 100, retryCount: ee = 2, shouldRetry: te = () => !0 } = {}) {
  return new Promise((ne, ie) => {
    const oe = async ({ count: se = 0 } = {}) => {
      const ae = async ({ error: ue }) => {
        const le = typeof X == "function" ? X({ count: se, error: ue }) : X;
        le && await Eg(le), oe({ count: se + 1 });
      };
      try {
        const ue = await Y();
        ne(ue);
      } catch (ue) {
        if (se < ee && await te({ count: se, error: ue }))
          return ae({ error: ue });
        ie(ue);
      }
    };
    oe();
  });
}
function JU(Y, X = {}) {
  return async (ee, te = {}) => {
    const { retryDelay: ne = 150, retryCount: ie = 3 } = {
      ...X,
      ...te
    };
    return Ag(async () => {
      try {
        return await Y(ee);
      } catch (oe) {
        const se = oe;
        switch (se.code) {
          case Lu.code:
            throw new Lu(se);
          case Fu.code:
            throw new Fu(se);
          case $u.code:
            throw new $u(se);
          case Du.code:
            throw new Du(se);
          case Uo.code:
            throw new Uo(se);
          case jo.code:
            throw new jo(se);
          case Uu.code:
            throw new Uu(se);
          case ju.code:
            throw new ju(se);
          case Hu.code:
            throw new Hu(se);
          case zu.code:
            throw new zu(se);
          case Qa.code:
            throw new Qa(se);
          case qu.code:
            throw new qu(se);
          case La.code:
            throw new La(se);
          case Gu.code:
            throw new Gu(se);
          case Vu.code:
            throw new Vu(se);
          case Wu.code:
            throw new Wu(se);
          case Ku.code:
            throw new Ku(se);
          case Ju.code:
            throw new Ju(se);
          case 5e3:
            throw new La(se);
          default:
            throw oe instanceof Le ? oe : new bD(se);
        }
      }
    }, {
      delay: ({ count: oe, error: se }) => {
        var ae;
        if (se && se instanceof LA) {
          const ue = (ae = se == null ? void 0 : se.headers) == null ? void 0 : ae.get("Retry-After");
          if (ue != null && ue.match(/\d/))
            return parseInt(ue) * 1e3;
        }
        return ~~(1 << oe) * ne;
      },
      retryCount: ie,
      shouldRetry: ({ error: oe }) => YU(oe)
    });
  };
}
function YU(Y) {
  return "code" in Y && typeof Y.code == "number" ? Y.code === -1 || Y.code === Qa.code || Y.code === Uo.code : Y instanceof LA && Y.status ? Y.status === 403 || Y.status === 408 || Y.status === 413 || Y.status === 429 || Y.status === 500 || Y.status === 502 || Y.status === 503 || Y.status === 504 : !0;
}
function XU({ key: Y, name: X, request: ee, retryCount: te = 3, retryDelay: ne = 150, timeout: ie, type: oe }, se) {
  return {
    config: { key: Y, name: X, request: ee, retryCount: te, retryDelay: ne, timeout: ie, type: oe },
    request: JU(ee, { retryCount: te, retryDelay: ne }),
    value: se
  };
}
function ZU(Y, X = {}) {
  const { key: ee = "custom", name: te = "Custom Provider", retryDelay: ne } = X;
  return ({ retryCount: ie }) => XU({
    key: ee,
    name: te,
    request: Y.request.bind(Y),
    retryCount: X.retryCount ?? ie,
    retryDelay: ne,
    type: "custom"
  });
}
function QU(Y) {
  var X;
  return {
    baseFeePerGas: Y.baseFeePerGas.map((ee) => BigInt(ee)),
    gasUsedRatio: Y.gasUsedRatio,
    oldestBlock: BigInt(Y.oldestBlock),
    reward: (X = Y.reward) == null ? void 0 : X.map((ee) => ee.map((te) => BigInt(te)))
  };
}
async function ej(Y, { blockCount: X, blockNumber: ee, blockTag: te = "latest", rewardPercentiles: ne }) {
  const ie = ee ? Rt(ee) : void 0, oe = await Y.request({
    method: "eth_feeHistory",
    params: [
      Rt(X),
      ie || te,
      ne
    ]
  });
  return QU(oe);
}
async function tj(Y, { filter: X }) {
  const ee = X.strict ?? !1, te = (await X.request({
    method: "eth_getFilterLogs",
    params: [X.id]
  })).map((ne) => lo(ne));
  return X.abi ? Vy({
    abi: X.abi,
    logs: te,
    strict: ee
  }) : te;
}
function iS(Y) {
  return {
    formatters: void 0,
    fees: void 0,
    serializers: void 0,
    ...Y
  };
}
const rj = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/, nj = /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;
function ij(Y) {
  const { domain: X = {}, message: ee, primaryType: te } = Y, ne = {
    EIP712Domain: fS({ domain: X }),
    ...Y.types
  };
  uS({
    domain: X,
    message: ee,
    primaryType: te,
    types: ne
  });
  const ie = ["0x1901"];
  return X && ie.push(sj({
    domain: X,
    types: ne
  })), te !== "EIP712Domain" && ie.push(sS({
    data: ee,
    primaryType: te,
    types: ne
  })), Rn(Os(ie));
}
function sj({ domain: Y, types: X }) {
  return sS({
    data: Y,
    primaryType: "EIP712Domain",
    types: X
  });
}
function sS({ data: Y, primaryType: X, types: ee }) {
  const te = oS({
    data: Y,
    primaryType: X,
    types: ee
  });
  return Rn(te);
}
function oS({ data: Y, primaryType: X, types: ee }) {
  const te = [{ type: "bytes32" }], ne = [oj({ primaryType: X, types: ee })];
  for (const ie of ee[X]) {
    const [oe, se] = cS({
      types: ee,
      name: ie.name,
      type: ie.type,
      value: Y[ie.name]
    });
    te.push(oe), ne.push(se);
  }
  return _f(te, ne);
}
function oj({ primaryType: Y, types: X }) {
  const ee = $s(aj({ primaryType: Y, types: X }));
  return Rn(ee);
}
function aj({ primaryType: Y, types: X }) {
  let ee = "";
  const te = aS({ primaryType: Y, types: X });
  te.delete(Y);
  const ne = [Y, ...Array.from(te).sort()];
  for (const ie of ne)
    ee += `${ie}(${X[ie].map(({ name: oe, type: se }) => `${se} ${oe}`).join(",")})`;
  return ee;
}
function aS({ primaryType: Y, types: X }, ee = /* @__PURE__ */ new Set()) {
  const te = Y.match(/^\w*/u), ne = te == null ? void 0 : te[0];
  if (ee.has(ne) || X[ne] === void 0)
    return ee;
  ee.add(ne);
  for (const ie of X[ne])
    aS({ primaryType: ie.type, types: X }, ee);
  return ee;
}
function cS({ types: Y, name: X, type: ee, value: te }) {
  if (Y[ee] !== void 0)
    return [
      { type: "bytes32" },
      Rn(oS({ data: te, primaryType: ee, types: Y }))
    ];
  if (ee === "bytes")
    return te = `0x${(te.length % 2 ? "0" : "") + te.slice(2)}`, [{ type: "bytes32" }, Rn(te)];
  if (ee === "string")
    return [{ type: "bytes32" }, Rn($s(te))];
  if (ee.lastIndexOf("]") === ee.length - 1) {
    const ne = ee.slice(0, ee.lastIndexOf("[")), ie = te.map((oe) => cS({
      name: X,
      type: ne,
      types: Y,
      value: oe
    }));
    return [
      { type: "bytes32" },
      Rn(_f(ie.map(([oe]) => oe), ie.map(([, oe]) => oe)))
    ];
  }
  return [{ type: ee }, te];
}
function uS(Y) {
  const { domain: X, message: ee, primaryType: te, types: ne } = Y, ie = (oe, se) => {
    for (const ae of oe) {
      const { name: ue, type: le } = ae, he = se[ue], me = le.match(nj);
      if (me && (typeof he == "number" || typeof he == "bigint")) {
        const [Ee, Re, Ue] = me;
        Rt(he, {
          signed: Re === "int",
          size: parseInt(Ue) / 8
        });
      }
      if (le === "address" && typeof he == "string" && !Bs(he))
        throw new Za({ address: he });
      const ye = le.match(rj);
      if (ye) {
        const [Ee, Re] = ye;
        if (Re && Hr(he) !== parseInt(Re))
          throw new v$({
            expectedSize: parseInt(Re),
            givenSize: Hr(he)
          });
      }
      const we = ne[le];
      we && ie(we, he);
    }
  };
  if (ne.EIP712Domain && X && ie(ne.EIP712Domain, X), te !== "EIP712Domain") {
    const oe = ne[te];
    ie(oe, ee);
  }
}
function fS({ domain: Y }) {
  return [
    typeof (Y == null ? void 0 : Y.name) == "string" && { name: "name", type: "string" },
    (Y == null ? void 0 : Y.version) && { name: "version", type: "string" },
    typeof (Y == null ? void 0 : Y.chainId) == "number" && {
      name: "chainId",
      type: "uint256"
    },
    (Y == null ? void 0 : Y.verifyingContract) && {
      name: "verifyingContract",
      type: "address"
    },
    (Y == null ? void 0 : Y.salt) && { name: "salt", type: "bytes32" }
  ].filter(Boolean);
}
const cj = {
  "0x0": "reverted",
  "0x1": "success"
};
function uj(Y) {
  const X = {
    ...Y,
    blockNumber: Y.blockNumber ? BigInt(Y.blockNumber) : null,
    contractAddress: Y.contractAddress ? Y.contractAddress : null,
    cumulativeGasUsed: Y.cumulativeGasUsed ? BigInt(Y.cumulativeGasUsed) : null,
    effectiveGasPrice: Y.effectiveGasPrice ? BigInt(Y.effectiveGasPrice) : null,
    gasUsed: Y.gasUsed ? BigInt(Y.gasUsed) : null,
    logs: Y.logs ? Y.logs.map((ee) => lo(ee)) : null,
    to: Y.to ? Y.to : null,
    transactionIndex: Y.transactionIndex ? co(Y.transactionIndex) : null,
    status: Y.status ? cj[Y.status] : null,
    type: Y.type ? $A[Y.type] || Y.type : null
  };
  return Y.blobGasPrice && (X.blobGasPrice = BigInt(Y.blobGasPrice)), Y.blobGasUsed && (X.blobGasUsed = BigInt(Y.blobGasUsed)), X;
}
const fj = `Ethereum Signed Message:
`;
function lj(Y, X) {
  const ee = typeof Y == "string" ? As(Y) : Y.raw instanceof Uint8Array ? Y.raw : Do(Y.raw), te = As(`${fj}${ee.length}`);
  return Rn(Os([te, ee]), X);
}
function dj(Y) {
  return Y.map((X) => ({
    ...X,
    value: BigInt(X.value)
  }));
}
function hj(Y) {
  return {
    ...Y,
    balance: Y.balance ? BigInt(Y.balance) : void 0,
    nonce: Y.nonce ? co(Y.nonce) : void 0,
    storageProof: Y.storageProof ? dj(Y.storageProof) : void 0
  };
}
async function pj(Y, { address: X, blockNumber: ee, blockTag: te, storageKeys: ne }) {
  const ie = te ?? "latest", oe = ee !== void 0 ? Rt(ee) : void 0, se = await Y.request({
    method: "eth_getProof",
    params: [X, ne, oe || ie]
  });
  return hj(se);
}
async function gj(Y, { address: X, blockNumber: ee, blockTag: te = "latest", slot: ne }) {
  const ie = ee !== void 0 ? Rt(ee) : void 0;
  return await Y.request({
    method: "eth_getStorageAt",
    params: [X, ne, ie || te]
  });
}
async function Gy(Y, { blockHash: X, blockNumber: ee, blockTag: te, hash: ne, index: ie }) {
  var oe, se, ae;
  const ue = te || "latest", le = ee !== void 0 ? Rt(ee) : void 0;
  let he = null;
  if (ne ? he = await Y.request({
    method: "eth_getTransactionByHash",
    params: [ne]
  }) : X ? he = await Y.request({
    method: "eth_getTransactionByBlockHashAndIndex",
    params: [X, Rt(ie)]
  }) : (le || ue) && (he = await Y.request({
    method: "eth_getTransactionByBlockNumberAndIndex",
    params: [le || ue, Rt(ie)]
  })), !he)
    throw new kA({
      blockHash: X,
      blockNumber: ee,
      blockTag: ue,
      hash: ne,
      index: ie
    });
  return (((ae = (se = (oe = Y.chain) == null ? void 0 : oe.formatters) == null ? void 0 : se.transaction) == null ? void 0 : ae.format) || DA)(he);
}
async function mj(Y, { hash: X, transactionReceipt: ee }) {
  const [te, ne] = await Promise.all([
    at(Y, Rf, "getBlockNumber")({}),
    X ? at(Y, Gy, "getBlockNumber")({ hash: X }) : void 0
  ]), ie = (ee == null ? void 0 : ee.blockNumber) || (ne == null ? void 0 : ne.blockNumber);
  return ie ? te - ie + 1n : 0n;
}
async function Sg(Y, { hash: X }) {
  var ee, te, ne;
  const ie = await Y.request({
    method: "eth_getTransactionReceipt",
    params: [X]
  });
  if (!ie)
    throw new MA({ hash: X });
  return (((ne = (te = (ee = Y.chain) == null ? void 0 : ee.formatters) == null ? void 0 : te.transactionReceipt) == null ? void 0 : ne.format) || uj)(ie);
}
async function yj(Y, X) {
  var ee;
  const { allowFailure: te = !0, batchSize: ne, blockNumber: ie, blockTag: oe, multicallAddress: se, stateOverride: ae } = X, ue = X.contracts, le = ne ?? (typeof ((ee = Y.batch) == null ? void 0 : ee.multicall) == "object" && Y.batch.multicall.batchSize || 1024);
  let he = se;
  if (!he) {
    if (!Y.chain)
      throw new Error("client chain not configured. multicallAddress is required.");
    he = Pc({
      blockNumber: ie,
      chain: Y.chain,
      contract: "multicall3"
    });
  }
  const me = [[]];
  let ye = 0, we = 0;
  for (let Ue = 0; Ue < ue.length; Ue++) {
    const { abi: Me, address: De, args: Fe, functionName: Ke } = ue[Ue];
    try {
      const tt = bo({ abi: Me, args: Fe, functionName: Ke });
      we += (tt.length - 2) / 2, // Check if batching is enabled.
      le > 0 && // Check if the current size of the batch exceeds the size limit.
      we > le && // Check if the current chunk is not already empty.
      me[ye].length > 0 && (ye++, we = (tt.length - 2) / 2, me[ye] = []), me[ye] = [
        ...me[ye],
        {
          allowFailure: !0,
          callData: tt,
          target: De
        }
      ];
    } catch (tt) {
      const rt = Zu(tt, {
        abi: Me,
        address: De,
        args: Fe,
        docsPath: "/docs/contract/multicall",
        functionName: Ke
      });
      if (!te)
        throw rt;
      me[ye] = [
        ...me[ye],
        {
          allowFailure: !0,
          callData: "0x",
          target: De
        }
      ];
    }
  }
  const Ee = await Promise.allSettled(me.map((Ue) => at(Y, fo, "readContract")({
    abi: yg,
    address: he,
    args: [Ue],
    blockNumber: ie,
    blockTag: oe,
    functionName: "aggregate3",
    stateOverride: ae
  }))), Re = [];
  for (let Ue = 0; Ue < Ee.length; Ue++) {
    const Me = Ee[Ue];
    if (Me.status === "rejected") {
      if (!te)
        throw Me.reason;
      for (let Fe = 0; Fe < me[Ue].length; Fe++)
        Re.push({
          status: "failure",
          error: Me.reason,
          result: void 0
        });
      continue;
    }
    const De = Me.value;
    for (let Fe = 0; Fe < De.length; Fe++) {
      const { returnData: Ke, success: tt } = De[Fe], { callData: rt } = me[Ue][Fe], { abi: it, address: _t, functionName: Dt, args: je } = ue[Re.length];
      try {
        if (rt === "0x")
          throw new p0();
        if (!tt)
          throw new Uy({ data: Ke });
        const ze = Cc({
          abi: it,
          args: je,
          data: Ke,
          functionName: Dt
        });
        Re.push(te ? { result: ze, status: "success" } : ze);
      } catch (ze) {
        const fe = Zu(ze, {
          abi: it,
          address: _t,
          args: je,
          docsPath: "/docs/contract/multicall",
          functionName: Dt
        });
        if (!te)
          throw fe;
        Re.push({ error: fe, result: void 0, status: "failure" });
      }
    }
  }
  if (Re.length !== ue.length)
    throw new Le("multicall results mismatch");
  return Re;
}
const bj = "0x60806040523480156200001157600080fd5b50604051620007003803806200070083398101604081905262000034916200056f565b6000620000438484846200004f565b9050806000526001601ff35b600080846001600160a01b0316803b806020016040519081016040528181526000908060200190933c90507f6492649264926492649264926492649264926492649264926492649264926492620000a68462000451565b036200021f57600060608085806020019051810190620000c79190620005ce565b8651929550909350915060000362000192576000836001600160a01b031683604051620000f5919062000643565b6000604051808303816000865af19150503d806000811462000134576040519150601f19603f3d011682016040523d82523d6000602084013e62000139565b606091505b5050905080620001905760405162461bcd60e51b815260206004820152601e60248201527f5369676e617475726556616c696461746f723a206465706c6f796d656e74000060448201526064015b60405180910390fd5b505b604051630b135d3f60e11b808252906001600160a01b038a1690631626ba7e90620001c4908b90869060040162000661565b602060405180830381865afa158015620001e2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906200020891906200069d565b6001600160e01b031916149450505050506200044a565b805115620002b157604051630b135d3f60e11b808252906001600160a01b03871690631626ba7e9062000259908890889060040162000661565b602060405180830381865afa15801562000277573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906200029d91906200069d565b6001600160e01b031916149150506200044a565b8251604114620003195760405162461bcd60e51b815260206004820152603a6024820152600080516020620006e083398151915260448201527f3a20696e76616c6964207369676e6174757265206c656e677468000000000000606482015260840162000187565b620003236200046b565b506020830151604080850151855186939260009185919081106200034b576200034b620006c9565b016020015160f81c9050601b81148015906200036b57508060ff16601c14155b15620003cf5760405162461bcd60e51b815260206004820152603b6024820152600080516020620006e083398151915260448201527f3a20696e76616c6964207369676e617475726520762076616c75650000000000606482015260840162000187565b6040805160008152602081018083528a905260ff83169181019190915260608101849052608081018390526001600160a01b038a169060019060a0016020604051602081039080840390855afa1580156200042e573d6000803e3d6000fd5b505050602060405103516001600160a01b031614955050505050505b9392505050565b60006020825110156200046357600080fd5b508051015190565b60405180606001604052806003906020820280368337509192915050565b6001600160a01b03811681146200049f57600080fd5b50565b634e487b7160e01b600052604160045260246000fd5b60005b83811015620004d5578181015183820152602001620004bb565b50506000910152565b600082601f830112620004f057600080fd5b81516001600160401b03808211156200050d576200050d620004a2565b604051601f8301601f19908116603f01168101908282118183101715620005385762000538620004a2565b816040528381528660208588010111156200055257600080fd5b62000565846020830160208901620004b8565b9695505050505050565b6000806000606084860312156200058557600080fd5b8351620005928162000489565b6020850151604086015191945092506001600160401b03811115620005b657600080fd5b620005c486828701620004de565b9150509250925092565b600080600060608486031215620005e457600080fd5b8351620005f18162000489565b60208501519093506001600160401b03808211156200060f57600080fd5b6200061d87838801620004de565b935060408601519150808211156200063457600080fd5b50620005c486828701620004de565b6000825162000657818460208701620004b8565b9190910192915050565b828152604060208201526000825180604084015262000688816060850160208701620004b8565b601f01601f1916919091016060019392505050565b600060208284031215620006b057600080fd5b81516001600160e01b0319811681146200044a57600080fd5b634e487b7160e01b600052603260045260246000fdfe5369676e617475726556616c696461746f72237265636f7665725369676e6572";
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
BigInt(0);
BigInt(1);
BigInt(2);
function xj(Y, X) {
  if (Y.length !== X.length)
    return !1;
  for (let ee = 0; ee < Y.length; ee++)
    if (Y[ee] !== X[ee])
      return !1;
  return !0;
}
function wj(Y, X) {
  const ee = es(Y) ? Do(Y) : Y, te = es(X) ? Do(X) : X;
  return xj(ee, te);
}
async function lS(Y, { address: X, hash: ee, signature: te, ...ne }) {
  const ie = es(te) ? te : $s(te);
  try {
    const { data: oe } = await at(Y, _0, "call")({
      data: PA({
        abi: PD,
        args: [X, ee, ie],
        bytecode: bj
      }),
      ...ne
    });
    return wj(oe ?? "0x0", "0x1");
  } catch (oe) {
    if (oe instanceof YA)
      return !1;
    throw oe;
  }
}
async function vj(Y, { address: X, message: ee, signature: te, ...ne }) {
  const ie = lj(ee);
  return lS(Y, {
    address: X,
    hash: ie,
    signature: te,
    ...ne
  });
}
async function Ej(Y, X) {
  const { address: ee, signature: te, message: ne, primaryType: ie, types: oe, domain: se, ...ae } = X, ue = ij({ message: ne, primaryType: ie, types: oe, domain: se });
  return lS(Y, {
    address: ee,
    hash: ue,
    signature: te,
    ...ae
  });
}
function dS(Y, { emitOnBegin: X = !1, emitMissed: ee = !1, onBlockNumber: te, onError: ne, poll: ie, pollingInterval: oe = Y.pollingInterval }) {
  const se = typeof ie < "u" ? ie : Y.transport.type !== "webSocket";
  let ae;
  return se ? (() => {
    const ue = ss([
      "watchBlockNumber",
      Y.uid,
      X,
      ee,
      oe
    ]);
    return Oc(ue, { onBlockNumber: te, onError: ne }, (le) => Cf(async () => {
      var he;
      try {
        const me = await at(Y, Rf, "getBlockNumber")({ cacheTime: 0 });
        if (ae) {
          if (me === ae)
            return;
          if (me - ae > 1 && ee)
            for (let ye = ae + 1n; ye < me; ye++)
              le.onBlockNumber(ye, ae), ae = ye;
        }
        (!ae || me > ae) && (le.onBlockNumber(me, ae), ae = me);
      } catch (me) {
        (he = le.onError) == null || he.call(le, me);
      }
    }, {
      emitOnBegin: X,
      interval: oe
    }));
  })() : (() => {
    let ue = !0, le = () => ue = !1;
    return (async () => {
      try {
        const { unsubscribe: he } = await Y.transport.subscribe({
          params: ["newHeads"],
          onData(me) {
            var ye;
            if (!ue)
              return;
            const we = d0((ye = me.result) == null ? void 0 : ye.number);
            te(we, ae), ae = we;
          },
          onError(me) {
            ne == null || ne(me);
          }
        });
        le = he, ue || le();
      } catch (he) {
        ne == null || ne(he);
      }
    })(), le;
  })();
}
async function _j(Y, {
  confirmations: X = 1,
  hash: ee,
  onReplaced: te,
  pollingInterval: ne = Y.pollingInterval,
  retryCount: ie = 6,
  retryDelay: oe = ({ count: ae }) => ~~(1 << ae) * 200,
  // exponential backoff
  timeout: se
}) {
  const ae = ss(["waitForTransactionReceipt", Y.uid, ee]);
  let ue, le, he, me = !1;
  return new Promise((ye, we) => {
    se && setTimeout(() => we(new gD({ hash: ee })), se);
    const Ee = Oc(ae, { onReplaced: te, resolve: ye, reject: we }, (Re) => {
      const Ue = at(Y, dS, "watchBlockNumber")({
        emitMissed: !0,
        emitOnBegin: !0,
        poll: !0,
        pollingInterval: ne,
        async onBlockNumber(Me) {
          if (me)
            return;
          let De = Me;
          const Fe = (Ke) => {
            Ue(), Ke(), Ee();
          };
          try {
            if (he) {
              if (X > 1 && (!he.blockNumber || De - he.blockNumber + 1n < X))
                return;
              Fe(() => Re.resolve(he));
              return;
            }
            if (ue || (me = !0, await Ag(async () => {
              ue = await at(Y, Gy, "getTransaction")({ hash: ee }), ue.blockNumber && (De = ue.blockNumber);
            }, {
              delay: oe,
              retryCount: ie
            }), me = !1), he = await at(Y, Sg, "getTransactionReceipt")({ hash: ee }), X > 1 && (!he.blockNumber || De - he.blockNumber + 1n < X))
              return;
            Fe(() => Re.resolve(he));
          } catch (Ke) {
            if (Ke instanceof kA || Ke instanceof MA) {
              if (!ue) {
                me = !1;
                return;
              }
              try {
                le = ue, me = !0;
                const tt = await Ag(() => at(Y, uo, "getBlock")({
                  blockNumber: De,
                  includeTransactions: !0
                }), {
                  delay: oe,
                  retryCount: ie,
                  shouldRetry: ({ error: _t }) => _t instanceof FA
                });
                me = !1;
                const rt = tt.transactions.find(({ from: _t, nonce: Dt }) => _t === le.from && Dt === le.nonce);
                if (!rt || (he = await at(Y, Sg, "getTransactionReceipt")({
                  hash: rt.hash
                }), X > 1 && (!he.blockNumber || De - he.blockNumber + 1n < X)))
                  return;
                let it = "replaced";
                rt.to === le.to && rt.value === le.value ? it = "repriced" : rt.from === rt.to && rt.value === 0n && (it = "cancelled"), Fe(() => {
                  var _t;
                  (_t = Re.onReplaced) == null || _t.call(Re, {
                    reason: it,
                    replacedTransaction: le,
                    transaction: rt,
                    transactionReceipt: he
                  }), Re.resolve(he);
                });
              } catch (tt) {
                Fe(() => Re.reject(tt));
              }
            } else
              Fe(() => Re.reject(Ke));
          }
        }
      });
    });
  });
}
function Aj(Y, { blockTag: X = "latest", emitMissed: ee = !1, emitOnBegin: te = !1, onBlock: ne, onError: ie, includeTransactions: oe, poll: se, pollingInterval: ae = Y.pollingInterval }) {
  const ue = typeof se < "u" ? se : Y.transport.type !== "webSocket", le = oe ?? !1;
  let he;
  return ue ? (() => {
    const me = ss([
      "watchBlocks",
      Y.uid,
      ee,
      te,
      le,
      ae
    ]);
    return Oc(me, { onBlock: ne, onError: ie }, (ye) => Cf(async () => {
      var we;
      try {
        const Ee = await at(Y, uo, "getBlock")({
          blockTag: X,
          includeTransactions: le
        });
        if (Ee.number && he != null && he.number) {
          if (Ee.number === he.number)
            return;
          if (Ee.number - he.number > 1 && ee)
            for (let Re = (he == null ? void 0 : he.number) + 1n; Re < Ee.number; Re++) {
              const Ue = await at(Y, uo, "getBlock")({
                blockNumber: Re,
                includeTransactions: le
              });
              ye.onBlock(Ue, he), he = Ue;
            }
        }
        (!(he != null && he.number) || // If the block tag is "pending" with no block number, emit.
        X === "pending" && !(Ee != null && Ee.number) || // If the next block number is greater than the previous block number, emit.
        // We don't want to emit blocks in the past.
        Ee.number && Ee.number > he.number) && (ye.onBlock(Ee, he), he = Ee);
      } catch (Ee) {
        (we = ye.onError) == null || we.call(ye, Ee);
      }
    }, {
      emitOnBegin: te,
      interval: ae
    }));
  })() : (() => {
    let me = !0, ye = () => me = !1;
    return (async () => {
      try {
        const { unsubscribe: we } = await Y.transport.subscribe({
          params: ["newHeads"],
          onData(Ee) {
            var Re, Ue, Me;
            if (!me)
              return;
            const De = (((Me = (Ue = (Re = Y.chain) == null ? void 0 : Re.formatters) == null ? void 0 : Ue.block) == null ? void 0 : Me.format) || UA)(Ee.result);
            ne(De, he), he = De;
          },
          onError(Ee) {
            ie == null || ie(Ee);
          }
        });
        ye = we, me || ye();
      } catch (we) {
        ie == null || ie(we);
      }
    })(), ye;
  })();
}
function Sj(Y, { address: X, args: ee, batch: te = !0, event: ne, events: ie, onError: oe, onLogs: se, poll: ae, pollingInterval: ue = Y.pollingInterval, strict: le }) {
  const he = typeof ae < "u" ? ae : Y.transport.type !== "webSocket", me = le ?? !1;
  return he ? (() => {
    const ye = ss([
      "watchEvent",
      X,
      ee,
      te,
      Y.uid,
      ne,
      ue
    ]);
    return Oc(ye, { onLogs: se, onError: oe }, (we) => {
      let Ee, Re, Ue = !1;
      const Me = Cf(async () => {
        var De;
        if (!Ue) {
          try {
            Re = await at(Y, rS, "createEventFilter")({
              address: X,
              args: ee,
              event: ne,
              events: ie,
              strict: me
            });
          } catch {
          }
          Ue = !0;
          return;
        }
        try {
          let Fe;
          if (Re)
            Fe = await at(Y, S0, "getFilterChanges")({ filter: Re });
          else {
            const Ke = await at(Y, Rf, "getBlockNumber")({});
            Ee && Ee !== Ke ? Fe = await at(Y, Wy, "getLogs")({
              address: X,
              args: ee,
              event: ne,
              events: ie,
              fromBlock: Ee + 1n,
              toBlock: Ke
            }) : Fe = [], Ee = Ke;
          }
          if (Fe.length === 0)
            return;
          if (te)
            we.onLogs(Fe);
          else
            for (const Ke of Fe)
              we.onLogs([Ke]);
        } catch (Fe) {
          Re && Fe instanceof jo && (Ue = !1), (De = we.onError) == null || De.call(we, Fe);
        }
      }, {
        emitOnBegin: !0,
        interval: ue
      });
      return async () => {
        Re && await at(Y, T0, "uninstallFilter")({ filter: Re }), Me();
      };
    });
  })() : (() => {
    let ye = !0, we = () => ye = !1;
    return (async () => {
      try {
        const Ee = ie ?? (ne ? [ne] : void 0);
        let Re = [];
        Ee && (Re = [
          Ee.flatMap((Me) => If({
            abi: [Me],
            eventName: Me.name,
            args: ee
          }))
        ], ne && (Re = Re[0]));
        const { unsubscribe: Ue } = await Y.transport.subscribe({
          params: ["logs", { address: X, topics: Re }],
          onData(Me) {
            var De;
            if (!ye)
              return;
            const Fe = Me.result;
            try {
              const { eventName: Ke, args: tt } = qy({
                abi: Ee ?? [],
                data: Fe.data,
                topics: Fe.topics,
                strict: me
              }), rt = lo(Fe, { args: tt, eventName: Ke });
              se([rt]);
            } catch (Ke) {
              let tt, rt;
              if (Ke instanceof Mu || Ke instanceof g0) {
                if (le)
                  return;
                tt = Ke.abiItem.name, rt = (De = Ke.abiItem.inputs) == null ? void 0 : De.some((_t) => !("name" in _t && _t.name));
              }
              const it = lo(Fe, {
                args: rt ? [] : {},
                eventName: tt
              });
              se([it]);
            }
          },
          onError(Me) {
            oe == null || oe(Me);
          }
        });
        we = Ue, ye || we();
      } catch (Ee) {
        oe == null || oe(Ee);
      }
    })(), we;
  })();
}
function Tj(Y, { batch: X = !0, onError: ee, onTransactions: te, poll: ne, pollingInterval: ie = Y.pollingInterval }) {
  return (typeof ne < "u" ? ne : Y.transport.type !== "webSocket") ? (() => {
    const oe = ss([
      "watchPendingTransactions",
      Y.uid,
      X,
      ie
    ]);
    return Oc(oe, { onTransactions: te, onError: ee }, (se) => {
      let ae;
      const ue = Cf(async () => {
        var le;
        try {
          if (!ae)
            try {
              ae = await at(Y, nS, "createPendingTransactionFilter")({});
              return;
            } catch (me) {
              throw ue(), me;
            }
          const he = await at(Y, S0, "getFilterChanges")({ filter: ae });
          if (he.length === 0)
            return;
          if (X)
            se.onTransactions(he);
          else
            for (const me of he)
              se.onTransactions([me]);
        } catch (he) {
          (le = se.onError) == null || le.call(se, he);
        }
      }, {
        emitOnBegin: !0,
        interval: ie
      });
      return async () => {
        ae && await at(Y, T0, "uninstallFilter")({ filter: ae }), ue();
      };
    });
  })() : (() => {
    let oe = !0, se = () => oe = !1;
    return (async () => {
      try {
        const { unsubscribe: ae } = await Y.transport.subscribe({
          params: ["newPendingTransactions"],
          onData(ue) {
            if (!oe)
              return;
            const le = ue.result;
            te([le]);
          },
          onError(ue) {
            ee == null || ee(ue);
          }
        });
        se = ae, oe || se();
      } catch (ae) {
        ee == null || ee(ae);
      }
    })(), se;
  })();
}
function Ij(Y) {
  return {
    call: (X) => _0(Y, X),
    createBlockFilter: () => OU(Y),
    createContractEventFilter: (X) => tS(Y, X),
    createEventFilter: (X) => rS(Y, X),
    createPendingTransactionFilter: () => nS(Y),
    estimateContractGas: (X) => NU(Y, X),
    estimateGas: (X) => My(Y, X),
    getBalance: (X) => kU(Y, X),
    getBlock: (X) => uo(Y, X),
    getBlockNumber: (X) => Rf(Y, X),
    getBlockTransactionCount: (X) => UU(Y, X),
    getBytecode: (X) => jU(Y, X),
    getChainId: () => Yu(Y),
    getContractEvents: (X) => hS(Y, X),
    getEnsAddress: (X) => gU(Y, X),
    getEnsAvatar: (X) => RU(Y, X),
    getEnsName: (X) => CU(Y, X),
    getEnsResolver: (X) => PU(Y, X),
    getEnsText: (X) => eS(Y, X),
    getFeeHistory: (X) => ej(Y, X),
    estimateFeesPerGas: (X) => AD(Y, X),
    getFilterChanges: (X) => S0(Y, X),
    getFilterLogs: (X) => tj(Y, X),
    getGasPrice: () => ky(Y),
    getLogs: (X) => Wy(Y, X),
    getProof: (X) => pj(Y, X),
    estimateMaxPriorityFeePerGas: (X) => _D(Y, X),
    getStorageAt: (X) => gj(Y, X),
    getTransaction: (X) => Gy(Y, X),
    getTransactionConfirmations: (X) => mj(Y, X),
    getTransactionCount: (X) => HA(Y, X),
    getTransactionReceipt: (X) => Sg(Y, X),
    multicall: (X) => yj(Y, X),
    prepareTransactionRequest: (X) => w0(Y, X),
    readContract: (X) => fo(Y, X),
    sendRawTransaction: (X) => Ly(Y, X),
    simulateContract: (X) => zU(Y, X),
    verifyMessage: (X) => vj(Y, X),
    verifyTypedData: (X) => Ej(Y, X),
    uninstallFilter: (X) => T0(Y, X),
    waitForTransactionReceipt: (X) => _j(Y, X),
    watchBlocks: (X) => Aj(Y, X),
    watchBlockNumber: (X) => dS(Y, X),
    watchContractEvent: (X) => GU(Y, X),
    watchEvent: (X) => Sj(Y, X),
    watchPendingTransactions: (X) => Tj(Y, X)
  };
}
async function Rj(Y) {
  var X;
  return ((X = Y.account) == null ? void 0 : X.type) === "local" ? [Y.account.address] : (await Y.request({ method: "eth_accounts" })).map((ee) => m0(ee));
}
async function Cj(Y) {
  return await Y.request({ method: "wallet_getPermissions" });
}
async function Pj(Y) {
  return (await Y.request({ method: "eth_requestAccounts" }, { retryCount: 0 })).map((X) => X$(X));
}
async function Oj(Y, X) {
  return Y.request({
    method: "wallet_requestPermissions",
    params: [X]
  }, { retryCount: 0 });
}
async function Bj(Y, { account: X = Y.account, message: ee }) {
  if (!X)
    throw new y0({
      docsPath: "/docs/actions/wallet/signMessage"
    });
  const te = Hn(X);
  if (te.type === "local")
    return te.signMessage({ message: ee });
  const ne = typeof ee == "string" ? Ay(ee) : ee.raw instanceof Uint8Array ? $s(ee.raw) : ee.raw;
  return Y.request({
    method: "personal_sign",
    params: [ne, te.address]
  }, { retryCount: 0 });
}
async function Nj(Y, X) {
  var ee, te, ne, ie;
  const { account: oe = Y.account, chain: se = Y.chain, ...ae } = X;
  if (!oe)
    throw new y0({
      docsPath: "/docs/actions/wallet/signTransaction"
    });
  const ue = Hn(oe);
  Sf({
    account: ue,
    ...X
  });
  const le = await at(Y, Yu, "getChainId")({});
  se !== null && BA({
    currentChainId: le,
    chain: se
  });
  const he = (se == null ? void 0 : se.formatters) || ((ee = Y.chain) == null ? void 0 : ee.formatters), me = ((te = he == null ? void 0 : he.transactionRequest) == null ? void 0 : te.format) || x0;
  return ue.type === "local" ? ue.signTransaction({
    ...ae,
    chainId: le
  }, { serializer: (ie = (ne = Y.chain) == null ? void 0 : ne.serializers) == null ? void 0 : ie.transaction }) : await Y.request({
    method: "eth_signTransaction",
    params: [
      {
        ...me(ae),
        chainId: Rt(le),
        from: ue.address
      }
    ]
  }, { retryCount: 0 });
}
async function kj(Y, X) {
  const { account: ee = Y.account, domain: te, message: ne, primaryType: ie } = X;
  if (!ee)
    throw new y0({
      docsPath: "/docs/actions/wallet/signTypedData"
    });
  const oe = Hn(ee), se = {
    EIP712Domain: fS({ domain: te }),
    ...X.types
  };
  if (uS({ domain: te, message: ne, primaryType: ie, types: se }), oe.type === "local")
    return oe.signTypedData({ domain: te, message: ne, primaryType: ie, types: se });
  const ae = ss({ domain: te ?? {}, message: ne, primaryType: ie, types: se }, (ue, le) => es(le) ? le.toLowerCase() : le);
  return Y.request({
    method: "eth_signTypedData_v4",
    params: [oe.address, ae]
  }, { retryCount: 0 });
}
async function Mj(Y, { id: X }) {
  await Y.request({
    method: "wallet_switchEthereumChain",
    params: [
      {
        chainId: Rt(X)
      }
    ]
  }, { retryCount: 0 });
}
async function Lj(Y, X) {
  return await Y.request({
    method: "wallet_watchAsset",
    params: X
  }, { retryCount: 0 });
}
function av(Y) {
  return {
    addChain: (X) => d$(Y, X),
    deployContract: (X) => RD(Y, X),
    getAddresses: () => Rj(Y),
    getChainId: () => Yu(Y),
    getPermissions: () => Cj(Y),
    prepareTransactionRequest: (X) => w0(Y, X),
    requestAddresses: () => Pj(Y),
    requestPermissions: (X) => Oj(Y, X),
    sendRawTransaction: (X) => Ly(Y, X),
    sendTransaction: (X) => Fy(Y, X),
    signMessage: (X) => Bj(Y, X),
    signTransaction: (X) => Nj(Y, X),
    signTypedData: (X) => kj(Y, X),
    switchChain: (X) => Mj(Y, X),
    watchAsset: (X) => Lj(Y, X),
    writeContract: (X) => VU(Y, X)
  };
}
function Vy({ abi: Y, eventName: X, logs: ee, strict: te = !0 }) {
  return ee.map((ne) => {
    var ie;
    try {
      const oe = qy({
        ...ne,
        abi: Y,
        strict: te
      });
      return X && !X.includes(oe.eventName) ? null : { ...oe, ...ne };
    } catch (oe) {
      let se, ae;
      if (oe instanceof vA)
        return null;
      if (oe instanceof Mu || oe instanceof g0) {
        if (te)
          return null;
        se = oe.abiItem.name, ae = (ie = oe.abiItem.inputs) == null ? void 0 : ie.some((ue) => !("name" in ue && ue.name));
      }
      return { ...ne, args: ae ? [] : {}, eventName: se };
    }
  }).filter(Boolean);
}
async function Wy(Y, { address: X, blockHash: ee, fromBlock: te, toBlock: ne, event: ie, events: oe, args: se, strict: ae } = {}) {
  const ue = ae ?? !1, le = oe ?? (ie ? [ie] : void 0);
  let he = [];
  le && (he = [
    le.flatMap((we) => If({
      abi: [we],
      eventName: we.name,
      args: se
    }))
  ], ie && (he = he[0]));
  let me;
  ee ? me = await Y.request({
    method: "eth_getLogs",
    params: [{ address: X, topics: he, blockHash: ee }]
  }) : me = await Y.request({
    method: "eth_getLogs",
    params: [
      {
        address: X,
        topics: he,
        fromBlock: typeof te == "bigint" ? Rt(te) : te,
        toBlock: typeof ne == "bigint" ? Rt(ne) : ne
      }
    ]
  });
  const ye = me.map((we) => lo(we));
  return le ? Vy({
    abi: le,
    logs: ye,
    strict: ue
  }) : ye;
}
async function hS(Y, X) {
  const { abi: ee, address: te, args: ne, blockHash: ie, eventName: oe, fromBlock: se, toBlock: ae, strict: ue } = X, le = oe ? Tf({ abi: ee, name: oe }) : void 0, he = le ? void 0 : ee.filter((me) => me.type === "event");
  return at(Y, Wy, "getLogs")({
    address: te,
    args: ne,
    blockHash: ie,
    event: le,
    events: he,
    fromBlock: se,
    toBlock: ae,
    strict: ue
  });
}
const Fj = "2.6.5", $j = () => `@wagmi/core@${Fj}`;
var pS = function(Y, X, ee, te) {
  if (ee === "a" && !te)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof X == "function" ? Y !== X || !te : !X.has(Y))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return ee === "m" ? te : ee === "a" ? te.call(Y) : te ? te.value : X.get(Y);
}, td, gS;
class Ho extends Error {
  get docsBaseUrl() {
    return "https://wagmi.sh/core";
  }
  get version() {
    return $j();
  }
  constructor(X, ee = {}) {
    var te;
    super(), td.add(this), Object.defineProperty(this, "details", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "docsPath", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "metaMessages", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "shortMessage", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "WagmiCoreError"
    });
    const ne = ee.cause instanceof Ho ? ee.cause.details : (te = ee.cause) != null && te.message ? ee.cause.message : ee.details, ie = ee.cause instanceof Ho && ee.cause.docsPath || ee.docsPath;
    this.message = [
      X || "An error occurred.",
      "",
      ...ee.metaMessages ? [...ee.metaMessages, ""] : [],
      ...ie ? [
        `Docs: ${this.docsBaseUrl}${ie}.html${ee.docsSlug ? `#${ee.docsSlug}` : ""}`
      ] : [],
      ...ne ? [`Details: ${ne}`] : [],
      `Version: ${this.version}`
    ].join(`
`), ee.cause && (this.cause = ee.cause), this.details = ne, this.docsPath = ie, this.metaMessages = ee.metaMessages, this.shortMessage = X;
  }
  walk(X) {
    return pS(this, td, "m", gS).call(this, this, X);
  }
}
td = /* @__PURE__ */ new WeakSet(), gS = function Y(X, ee) {
  return ee != null && ee(X) ? X : X.cause ? pS(this, td, "m", Y).call(this, X.cause, ee) : X;
};
class Dj extends Ho {
  constructor() {
    super("Chain not configured."), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ChainNotConfiguredError"
    });
  }
}
class Uj extends Ho {
  constructor() {
    super("Connector not connected."), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ConnectorNotConnectedError"
    });
  }
}
class jj extends Ho {
  constructor({ address: X, connector: ee }) {
    super(`Account "${X}" not found for connector "${ee.name}".`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ConnectorAccountNotFoundError"
    });
  }
}
class Hj extends Ho {
  constructor({ connector: X }) {
    super(`"${X.name}" does not support programmatic chain switching.`), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "SwitchChainNotSupportedError"
    });
  }
}
async function zj(Y, X = {}) {
  let ee;
  if (X.connector) {
    const { connector: ae } = X, [ue, le] = await Promise.all([
      ae.getAccounts(),
      ae.getChainId()
    ]);
    ee = {
      accounts: ue,
      chainId: le,
      connector: ae
    };
  } else
    ee = Y.state.connections.get(Y.state.current);
  if (!ee)
    throw new Uj();
  const te = X.chainId ?? ee.chainId, ne = ee.connector;
  if (ne.getClient)
    return ne.getClient({ chainId: te });
  const ie = Hn(X.account ?? ee.accounts[0]), oe = Y.chains.find((ae) => ae.id === te), se = await ee.connector.getProvider({ chainId: te });
  if (X.account && !ee.accounts.includes(ie.address))
    throw new jj({
      address: ie.address,
      connector: ne
    });
  return KU({
    account: ie,
    chain: oe,
    name: "Connector Client",
    transport: (ae) => ZU(se)({ ...ae, retryCount: 0 })
  });
}
function qj(Y) {
  return Y.state.chainId;
}
function Gj(Y, X = {}) {
  let ee;
  try {
    ee = Y.getClient(X);
  } catch {
  }
  return ee;
}
function Vj(Y, X = {}) {
  const ee = Gj(Y, X);
  return ee == null ? void 0 : ee.extend(Ij);
}
async function Wj(Y, X = {}) {
  const ee = await zj(Y, X);
  return ee.extend(av), ee.extend(av);
}
async function Kj(Y, X) {
  var ee;
  const { chainId: te } = X, ne = Y.state.connections.get(((ee = X.connector) == null ? void 0 : ee.uid) ?? Y.state.current);
  if (ne) {
    const oe = ne.connector;
    if (!oe.switchChain)
      throw new Hj({ connector: oe });
    return await oe.switchChain({ chainId: te });
  }
  const ie = Y.chains.find((oe) => oe.id === te);
  if (!ie)
    throw new Dj();
  return Y.setState((oe) => ({ ...oe, chainId: te })), ie;
}
const Jj = /* @__PURE__ */ iS({
  id: 122,
  name: "Fuse",
  nativeCurrency: { name: "Fuse", symbol: "FUSE", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://rpc.fuse.io"] }
  },
  blockExplorers: {
    default: {
      name: "Fuse Explorer",
      url: "https://explorer.fuse.io",
      apiUrl: "https://explorer.fuse.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 16146628
    }
  }
}), Yj = /* @__PURE__ */ iS({
  id: 80001,
  name: "Polygon Mumbai",
  nativeCurrency: { name: "MATIC", symbol: "MATIC", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.ankr.com/polygon_mumbai"]
    }
  },
  blockExplorers: {
    default: {
      name: "PolygonScan",
      url: "https://mumbai.polygonscan.com",
      apiUrl: "https://mumbai.polygonscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 25770160
    }
  },
  testnet: !0
});
function Xj(Y) {
  var X, ee;
  const { chain: te, transport: ne } = Y, ie = {
    chainId: te == null ? void 0 : te.id,
    name: te == null ? void 0 : te.name,
    ensAddress: (ee = (X = te.contracts) == null ? void 0 : X.ensRegistry) == null ? void 0 : ee.address
  };
  return ne.type === "fallback" ? new V9(
    ne.transports.map(
      ({ value: oe }) => new zl$1(oe == null ? void 0 : oe.url, ie)
    )
  ) : new zl$1(ne.url, ie);
}
async function Zj({ config: Y }) {
  const X = await Vj(Y);
  return Xj(X);
}
function Qj(Y, X) {
  var ee, te;
  const { account: ne, chain: ie, transport: oe } = Y;
  console.log("walletClientToSigner", { account: ne, chainWc: ie, transport: oe });
  let se;
  ie ? se = ie : X && (se = X);
  const ae = {
    chainId: se.id,
    name: se.name,
    ensAddress: (te = (ee = se.contracts) == null ? void 0 : ee.ensRegistry) == null ? void 0 : te.address
  };
  return new J9(oe, ae).getSigner(ne.address);
}
async function eH({
  config: Y,
  chainId: X
}) {
  await qj(Y) !== X && await Kj(Y, { chainId: X });
  let ee;
  X == 122 ? ee = Jj : X == 80001 && (ee = Yj);
  const te = await Wj(Y, { chainId: X });
  if (te)
    return Qj(te, ee);
}
class us {
  /**
   * In case of EVM, uses the rpcUrl to make a provider
   *
   * Sets the chain id and provider instance
   *
   * @param chainId - A chain id for using 1inch apis.
   * @param rpcUrl - A rpcUrl for the provider
   */
  constructor(X, ee, te, ne, ie, oe) {
    this.okxDexApiUrl = "https://www.okx.com/api/v5/dex/aggregator", this.walletType = oe, this.rpcUrl = te, this.chainId = ee, this.chainName = ie, this.triaApiBaseUrl = `${X}/api/v1`, this.userService = new j2(X), this.config = ne;
  }
  /**
   * Get RPC provider for embedded or external wallet
   *
   * @returns providerInstance
   */
  async getProvider() {
    var X;
    let ee;
    return (X = this.walletType) != null && X.embedded || !this.walletType ? ee = new zl$1(this.rpcUrl) : ee = await Zj({ config: this.config }), ee;
  }
  async waitForTransaction(X) {
    return await (await this.getProvider()).waitForTransaction(X);
  }
  /**
   * Derives new wallet for a chain using mnemonic and derivation path
   *
   * Returns the publicKey and privateKey
   *
   * @param mnemonic - An account address.
   * @param derivationPath - derivation path chain specific and derivationIndex calc?
   * @param derivationPathIndex - index
   * @returns The public key and private key.
   */
  async createWallet(X, ee) {
    const te = Ys.fromMnemonic(
      X,
      `m/44'/60'/0'/0/${ee}`
    );
    return {
      address: te.address,
      privateKey: te.privateKey
    };
  }
  async getTokenDetails(X, ee) {
    try {
      let te, ne, ie, oe;
      if (X) {
        const { contract: se } = await this.getContract(X);
        te = await se.name(), ne = await se.symbol(), ie = await se.decimals(), ee && (oe = await se.balanceOf(ee));
      } else
        te = $w[this.chainName].name, ne = $w[this.chainName].symbol, ie = 18, ee && (oe = await (await this.getProvider()).getBalance(ee));
      return {
        name: te,
        symbol: ne,
        decimals: ie,
        balance: oe
      };
    } catch (te) {
      throw te;
    }
  }
  /**
   * Gets balance for native token or asset
   *
   * Returns the currently initialized keyring that manages
   * the specified `address` if one exists.
   *
   * @param accountAddress - An account address.
   * @param tokenAddress - A asset contract address
   * @returns The keyring of the account, if it exists.
   */
  async getBalance(X, ee) {
    try {
      const { name: te, symbol: ne, decimals: ie, balance: oe } = await this.getTokenDetails(
        ee,
        X
      );
      return {
        name: te,
        symbol: ne,
        balance: parseFloat(
          ie ? x6(oe, ie) : Jx(oe)
        ),
        balanceInUnits: oe.toString(),
        // bignumber
        decimals: ie
      };
    } catch (te) {
      throw te;
    }
  }
  /**
   *
   * @param data Encrypt data with user's public key.
   * @param publicKey
   * @returns
   */
  async encrypt(X, ee, te, ne) {
    const ie = await X.provider.send("eth_getEncryptionPublicKey", [
      te
    ]), oe = w6.encrypt({
      publicKey: ie,
      data: ee,
      version: ne || "x25519-xsalsa20-poly1305"
    });
    return { success: !0, data: JSON.stringify(oe) };
  }
  /**
   * Decrypt data with private key
   * @param signer
   * @param encryptedData
   * @param address
   * @returns
   */
  async decrypt(X, ee, te) {
    const ne = te || await X.getAddress();
    return { success: !0, data: await X.provider.send("eth_decrypt", [
      ee,
      ne
    ]) };
  }
  /**
   * Checks the validity of a txn based on the balance and transfer amount.
   *
   *
   * @param accountAddress - An account address.
   * @param amount - Amount to transfer
   * @param tokenAddress - A asset contract address // optional
   * @returns The keyring of the account, if it exists.
   */
  async checkSendValidity(X, ee, te) {
    let { balanceInUnits: ne, decimals: ie } = await this.getBalance(
      X,
      te
    );
    return (ie ? da(ee.toFixed(ie), ie) : Vf(ee.toFixed(18))).lt(Be.from(ne));
  }
  /**
   * Sends the token amount
   *
   * @param signer - for signing txns
   * @param tokenAddress - if transferring a ERC20 token
   * @param amount - amount to transfer
   *
   * @returns Returns the txn object or hash - tbd
   */
  async send({
    signer: X,
    fromAddress: ee,
    tokenAddress: te,
    recipientAddress: ne,
    amount: ie
  }) {
    const oe = await this.getSendTxnObject(
      ee,
      ne,
      ie,
      te
    );
    return oe.success && oe != null && oe.txnObject ? await this.broadcastTransaction(X, oe == null ? void 0 : oe.txnObject) : oe;
  }
  async getSendFee(X, ee, te, ne) {
    console.log("getSendTxnObject");
    const ie = await this.getSendTxnObject(
      X,
      ee,
      te,
      ne
    );
    return ie.success ? await this.getEstimateFee(ie.txnObject) : ie;
  }
  async getSendTxnObject(X, ee, te, ne) {
    try {
      let ie;
      if (ne) {
        const { contract: oe } = await this.getContract(ne), se = await oe.decimals();
        console.log({ decimals: se }), ie = await oe.populateTransaction.transfer(
          ee,
          da(te.toFixed(se), se)
          // {
          //   gasPrice,
          //   nonce,
          // }
        ), console.log({ res: ie });
      } else
        ie = {
          to: ee,
          value: Vf(te.toFixed(18)),
          // gasPrice,
          // nonce,
          data: "0x"
        };
      return { success: !0, txnObject: { ...ie, from: X } };
    } catch (ie) {
      throw ie;
    }
  }
  /**
   * Swap tokens using 1inch aggregator
   *
   * Swap from asset to asset working
   * Naitve token to asset params to be figured out
   *
   * @param signer - to broadcast swap txn
   * @param fromTokenAddress - token to be swapped
   * @param toTokenAddress - token to be returned
   * @param amount - from amount - in number e.g. 0.1 ETH
   * @param fromAddress - address performing txn
   * @param slippage - in percentage e.g. 1%
   *
   */
  async swap({
    signer: X,
    fromTokenAddress: ee,
    toTokenAddress: te,
    amount: ne,
    slippage: ie
  }) {
    const oe = await X.getAddress(), se = await this.getSwapTxnObject(
      oe,
      ee,
      te,
      ne,
      ie
    );
    return se.success && se != null && se.txnObject ? await this.broadcastTransaction(X, se == null ? void 0 : se.txnObject) : se;
  }
  async getSwapTxnObject(X, ee, te, ne, ie) {
    console.log("getSwapTxnObject");
    let oe;
    ee && (oe = (await this.getContract(ee)).contract);
    const se = oe ? await (oe == null ? void 0 : oe.decimals()) : 18;
    console.log({ decimals: se });
    const ae = await this.get1inchRouterContractAddress(), ue = await this.checkTokenAllowance({
      accountAddress: X,
      tokenAddress: ee,
      amount: ne,
      spender: ae
    });
    console.log({ valid: ue });
    const le = da(ne.toFixed(se), se).toString(), he = {
      fromTokenAddress: ee,
      toTokenAddress: te,
      parsedAmount: le,
      fromAddress: X,
      slippage: ie.toString()
    };
    if (ue) {
      let me;
      if (this.chainId == 66) {
        const ye = await this.swapOnOkx(he);
        if (ye.success)
          me = ye == null ? void 0 : ye.txnObject;
        else
          return ye;
      } else {
        const ye = await this.swapOn1inch(he);
        if (ye.success)
          me = ye == null ? void 0 : ye.txnObject;
        else
          return ye;
      }
      return { success: !0, txnObject: me };
    } else
      return {
        success: !1,
        message: "Invalid swap txn, increase allowance"
      };
  }
  async getSwapFee(X, ee, te, ne, ie) {
    const oe = await this.getSwapTxnObject(
      X,
      ee,
      te,
      ne,
      ie
    );
    return oe.success ? await this.getEstimateFee(oe.txnObject) : oe;
  }
  async getEstimateFee(X) {
    try {
      console.log("estimating gas..", X);
      const ee = await this.getProvider(), te = await ee.estimateGas(X);
      console.log("gas", te.toString());
      const ne = await ee.getGasPrice(), ie = await this.userService.getTokenData(this.chainName), oe = te.mul(ne), se = Jx(oe);
      let ae;
      return (ie == null ? void 0 : ie.usd) >= 0 && (ae = parseFloat(se) * (ie == null ? void 0 : ie.usd)), {
        success: !0,
        fee: { eth: se, usd: ae == null ? void 0 : ae.toString() }
      };
    } catch (ee) {
      return console.error(ee), {
        success: !1,
        message: "Insufficient gas or error while estimating fee",
        error: ee
      };
    }
  }
  async getSwapTargets(X, ee, te) {
    try {
      const { data: ne } = await nr.get(
        `${this.triaApiBaseUrl}/chain/${this.chainId}/tokens`
      ), ie = ne == null ? void 0 : ne.tokens;
      let oe = [];
      for (let [, se] of Object.entries(ie)) {
        const ae = se == null ? void 0 : se.address, ue = {
          // @ts-ignore
          name: se == null ? void 0 : se.name,
          // @ts-ignore
          symbol: se == null ? void 0 : se.symbol,
          tokenAddress: ae !== "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee" ? ku(ae) : null,
          // @ts-ignore
          logoUrl: se == null ? void 0 : se.logoURI
          // decimals
        };
        ue.tokenAddress !== X && (te ? te && // @ts-ignore
        se != null && se.symbol.toLowerCase().includes(te.toLowerCase()) && oe.push(ue) : oe.push(ue));
      }
      return oe.slice(0, ee);
    } catch (ne) {
      throw new Error(ne);
    }
  }
  async stake(X, ee, te) {
    const ne = ee, { contract: ie } = await this.getContract(
      KF,
      X,
      WF
    ), oe = ie.submit(ne, {
      from: ee,
      value: Vf(te.toFixed(18))
    });
    return await this.broadcastTransaction(X, oe);
  }
  /**
   * Approve tokens to be spent by 1inch router contract
   *
   * @param signer
   * @param tokenAddress - token contract address to be swapped
   * @param accountAddress
   * @returns
   */
  async approve({
    signer: X,
    fromAddress: ee,
    tokenAddress: te,
    amount: ne,
    spender: ie
  }) {
    if (!te)
      return { success: !1, message: "Token address is null" };
    console.log({ fromAddress: ee, tokenAddress: te, amount: ne });
    const oe = await this.getApproveTxnObject(
      ee,
      te,
      ne,
      ie
    );
    return oe.success && oe != null && oe.txnObject ? (console.log("broadcasting approve"), console.log("res?.txnObject ", oe == null ? void 0 : oe.txnObject), await this.broadcastTransaction(X, oe == null ? void 0 : oe.txnObject)) : oe;
  }
  async getApproveFee(X, ee, te, ne) {
    if (!ee)
      return { success: !1, message: "Token address is null" };
    const ie = await this.getApproveTxnObject(
      X,
      ee,
      te,
      ne
    );
    return ie.success ? (console.log("res.txnObject ", ie.txnObject), await this.getEstimateFee(ie.txnObject)) : ie;
  }
  async getApproveTxnObject(X, ee, te, ne) {
    const { contract: ie } = await this.getContract(ee), oe = await ie.decimals(), se = da(
      te.toFixed(oe),
      oe
    );
    try {
      return { success: !0, txnObject: { ...await ie.populateTransaction.approve(
        ne,
        se
      ), from: X } };
    } catch {
      return { success: !1, message: "Error approving token." };
    }
  }
  // async getApproveTxnObject(
  //   fromAddress: string,
  //   tokenAddress: string,
  //   amount: number,
  //   contractAddress: string
  // ): Promise<TxnObjectResponse> {
  //   const { contract } = await this.getContract(tokenAddress);
  //   const decimals = await contract.decimals();
  //   const parsedAmount = ethers.utils.parseUnits(amount.toString(), decimals);
  //   try {
  //     /* or get spenderAddress, i.e., 1inch router contract address
  //       and call approve function
  //     */
  //     let txnObject;
  //     if (this.chainId == 66) {
  //       // OKX
  //       const res = await this.approveOnOkx({
  //         tokenAddress,
  //         parsedAmount: parsedAmount.toString(),
  //         fromAddress,
  //       });
  //       if (res.success) {
  //         txnObject = res?.txnObject;
  //       } else return res;
  //     } else {
  //       // Other EVMs except CELO
  //       const res = await this.approveOn1inch({ tokenAddress, parsedAmount });
  //       if (res.success) {
  //         txnObject = res?.txnObject;
  //       } else return res;
  //     }
  //     console.log({ parsedAmount, txnObject, fromAddress });
  //     return {
  //       success: true,
  //       txnObject: {
  //         ...txnObject,
  //         from: fromAddress,
  //         gasPrice: ethers.utils.hexlify(parseInt(txnObject?.gasPrice)),
  //         value: ethers.utils.hexlify(parseInt(txnObject?.value)),
  //       },
  //     };
  //   } catch (error: any) {
  //     // throw error;
  //     return { success: false, message: `Error approving tokens on 1inch ${tokenAddress}` };
  //   }
  // }
  async swapOn1inch({
    fromTokenAddress: X,
    toTokenAddress: ee,
    parsedAmount: te,
    fromAddress: ne,
    slippage: ie
  }) {
    var oe;
    console.log("swapOn1inch");
    try {
      const { data: se } = await nr.get(
        `${this.triaApiBaseUrl}/chain/${this.chainId}/swap`,
        {
          params: {
            fromTokenAddress: X,
            toTokenAddress: ee,
            fromAddress: ne,
            parsedAmount: te,
            slippage: ie
          }
        }
      ), ae = {
        ...se.tx,
        gasLimit: Oe(se.tx.gas),
        // not working hexlifying these.
        gasPrice: Oe(parseInt(se.tx.gasPrice)),
        value: Oe(parseInt(se.tx.value))
      };
      return delete ae.gas, console.log({ swapOn1inch: ae }), { success: !0, txnObject: ae };
    } catch (se) {
      return {
        success: !1,
        message: ((oe = se == null ? void 0 : se.data) == null ? void 0 : oe.description) || "Error estimating swap details, check if enough gas"
      };
    }
  }
  async swapOnOkx({
    fromTokenAddress: X,
    toTokenAddress: ee,
    parsedAmount: te,
    fromAddress: ne,
    slippage: ie
  }) {
    var oe;
    try {
      const { data: se } = await nr.get(`${this.okxDexApiUrl}/swap`, {
        params: {
          chainId: this.chainId,
          fromTokenAddress: X,
          toTokenAddress: ee,
          amount: te,
          userWalletAddress: ne,
          slippage: ie
          // in percent 0.5 -> 0.5%
        }
      }), { data: ae, from: ue, gasPrice: le, gas: he, to: me, value: ye } = se.data[0].tx;
      return { success: !0, txnObject: {
        data: ae,
        from: ue,
        gasPrice: Oe(parseInt(le)),
        gasLimit: Oe(parseInt(he)),
        to: me,
        value: Oe(parseInt(ye))
      } };
    } catch (se) {
      return {
        success: !1,
        message: ((oe = se == null ? void 0 : se.data) == null ? void 0 : oe.description) || "Error estimating swap details, try increasing slippage"
      };
    }
  }
  async approveOn1inch({ tokenAddress: X, parsedAmount: ee }) {
    try {
      const { data: te } = await nr.get(
        `${this.triaApiBaseUrl}/chain/${this.chainId}/approve/transaction`,
        {
          params: {
            tokenAddress: X,
            parsedAmount: ee
          }
        }
      );
      return { success: !0, txnObject: te };
    } catch {
      return { success: !1, message: "Error creating approve txn object" };
    }
  }
  async approveOnOkx({ tokenAddress: X, parsedAmount: ee, fromAddress: te }) {
    try {
      const { data: ne } = await nr.get(
        `${this.okxDexApiUrl}/approve-transaction`,
        {
          params: {
            chainId: this.chainId,
            tokenContractAddress: X,
            approveAmount: ee
          }
        }
      ), ie = ne.data[0];
      return { success: !0, txnObject: {
        data: ie.data,
        from: te,
        to: X,
        gasLimit: Oe(parseInt(ie.gasLimit)),
        gasPrice: Oe(parseInt(ie.gasPrice)),
        value: 0
      } };
    } catch {
      return {
        success: !1,
        message: "Error making approve txn object on OKX"
      };
    }
  }
  /**
   *
   * Checks allowance for the 1inch router contract address
   *
   * @param accountAddress - account holding tokens
   * @param tokenAddress - token to check allowance
   * @param amount - amount to be spent, e.g. 0.1 ETH
   *
   * @returns bool if allowance needed or not
   */
  async checkTokenAllowance({
    accountAddress: X,
    tokenAddress: ee,
    amount: te,
    spender: ne
  }) {
    if (!ee)
      return !0;
    const { contract: ie } = await this.getContract(ee), oe = await ie.decimals(), se = da(
      te.toFixed(oe),
      oe
    );
    console.log("checkTokenAllowance", {
      accountAddress: X,
      tokenAddress: ee,
      amount: te,
      spender: ne
    });
    const ae = await ie.allowance(X, ne);
    return console.log({
      allowanceNum: ae.toString(),
      amountToSpendString: se.toString()
    }), ae >= se;
  }
  // async getAllowanceOn1inch({ accountAddress, tokenAddress }: any) {
  //   try {
  //     const {
  //       data: { allowance },
  //     } = await axios.get(`${this.oneinchApiBaseUrl}/${this.chainId}/approve/allowance`, {
  //       headers: {
  //         Accept: 'application/json',
  //         Authorization: `Bearer ${this.oneinchApiKey}`,
  //       },
  //       params: {
  //         tokenAddress: tokenAddress,
  //         walletAddress: accountAddress,
  //       },
  //     });
  //     console.log(allowance);
  //     return allowance;
  //   } catch (err) {
  //     throw err;
  //   }
  // }
  async getAllowanceOnOkx({ accountAddress: X, tokenAddress: ee }) {
    try {
      const { data: te } = await nr.get(`${this.okxDexApiUrl}/get-allowance`, {
        params: {
          chainId: this.chainId,
          userWalletAddress: X,
          tokenContractAddress: ee
        }
      });
      return te.data[0].allowanceAmount;
    } catch (te) {
      throw te;
    }
  }
  /**
   * Broadcasts the txn on-chain.
   *
   * @param signer
   * @param txnObject - Txn object data to broadcast
   * @returns
   */
  async broadcastTransaction(X, ee) {
    try {
      const te = await X.sendTransaction(ee);
      return {
        success: !0,
        data: {
          txnId: te.hash,
          // @ts-ignore
          viewInExplorer: `${JF[this.chainName]}/${te.hash}`,
          wait: te.wait
        }
      };
    } catch (te) {
      throw te;
    }
  }
  /**
   * Helper function for creating contract instance
   *
   * Returns the contract instance
   *
   * TODO - add error handling for invalid erc20 contract addresss
   *
   * @param contractAddress - An account address.
   * @param abi - A asset contract address
   * @returns The contract instance.
   */
  async getContract(X, ee, te) {
    try {
      const ne = te || VF;
      return {
        contract: new BC(
          X,
          ne,
          ee || await this.getProvider()
        )
      };
    } catch {
      throw new Error("Error making contract instance");
    }
  }
  async callContract(X, ee) {
    try {
      const te = await ee.getAddress(), ne = await this.createCallContractTxnObject(
        X,
        te
      );
      return ne.success && ne != null && ne.txnObject ? await this.broadcastTransaction(ee, ne == null ? void 0 : ne.txnObject) : ne;
    } catch (te) {
      throw console.error("Error interacting with the contract:", te), te;
    }
  }
  async getCallContractFee(X, ee) {
    const te = await this.createCallContractTxnObject(
      X,
      ee
    );
    return te.success ? await this.getEstimateFee(te.txnObject) : te;
  }
  async createCallContractTxnObject(X, ee) {
    try {
      const { contractAddress: te, abi: ne, functionName: ie, args: oe, value: se } = X, { contract: ae } = await this.getContract(
        te,
        void 0,
        ne
      ), ue = await ae.populateTransaction[ie](
        ...oe,
        {
          value: se ? Vf(se.toFixed(18)) : 0
          // gasPrice,
          // nonce,
        }
      );
      return console.log("createCallContractTxnObject", ue), { success: !0, txnObject: { ...ue, from: ee } };
    } catch (te) {
      throw te;
    }
  }
  async readContract(X) {
    try {
      const { contractAddress: ee, abi: te, functionName: ne, args: ie } = X, { contract: oe } = await this.getContract(
        ee,
        void 0,
        te
      );
      return { success: !0, data: await oe[ne](...ie) };
    } catch (ee) {
      return console.error(ee), { success: !1, message: "Error reading contract", error: ee };
    }
  }
  /**
   * Helper function for creating signer and getting nonce and gas
   *
   * @param privateKey - A private key.
   * @returns The signer, nonce, gas, gasPrice.
   */
  async getSigner(X) {
    return {
      signer: X ? new Ys(X, await this.getProvider()) : await eH({
        config: this.config,
        chainId: this.chainId
      })
    };
  }
  async getGasDetailsAndNonce(X) {
    const ee = await this.getProvider(), te = (await ee.getFeeData()).gasPrice;
    return {
      nonce: await ee.getTransactionCount(X),
      gasPrice: te,
      gasLimit: 21e3
    };
  }
  async signMessage(X, ee) {
    return await X.signMessage(ee);
  }
  async getTxnDetails(X) {
    return await (await this.getProvider()).getTransactionReceipt(X);
  }
  async isContractAddress(X) {
    try {
      const ee = pr(X);
      return await (await this.getProvider()).getCode(ee) !== "0x";
    } catch {
      return !1;
    }
  }
  async isERC20Address(X) {
    try {
      const ee = pr(X), { contract: te } = await this.getContract(ee);
      return await te.balanceOf(ee), await te.decimals(), await te.totalSupply(), !0;
    } catch {
      return console.log("Not erc20 contract"), !1;
    }
  }
  async is1inchRouterContract(X) {
    try {
      const ee = await this.get1inchRouterContractAddress();
      return X.toLowerCase() === ee.toLowerCase();
    } catch {
      return !1;
    }
  }
  async get1inchRouterContractAddress() {
    try {
      const {
        data: { address: X }
      } = await nr.get(
        `${this.triaApiBaseUrl}/chain/${this.chainId}/approve/spender`
      );
      return X;
    } catch {
      throw new Error("Unable to fetch 1inch router contract address");
    }
  }
  async getSendNFTFee(X, ee, te) {
    const ne = await this.getSendNFTTxnObject(
      X,
      ee,
      te
    );
    return ne.success ? await this.getEstimateFee(ne == null ? void 0 : ne.txnObject) : ne;
  }
  async sendNFT(X, ee, te, ne) {
    const ie = await this.getSendNFTTxnObject(
      ee,
      te,
      ne
    );
    return ie.success ? await this.broadcastTransaction(
      X,
      ie == null ? void 0 : ie.txnObject
    ) : ie;
  }
  async getSendNFTTxnObject(X, ee, { type: te, tokenAddress: ne, tokenId: ie, amount: oe }) {
    let se;
    try {
      if (te == "ERC1155") {
        const { contract: ae } = await this.getContract(
          ne,
          void 0,
          XF
        );
        se = await ae.populateTransaction.safeTransferFrom(
          X,
          ee,
          ie,
          oe,
          "0x"
          // {
          //   gasPrice,
          //   nonce,
          // }
        );
      } else if (te == "ERC721") {
        console.log({ type: te, tokenAddress: ne, tokenId: ie, amount: oe, fromAddress: X });
        const { contract: ae } = await this.getContract(
          ne,
          void 0,
          ZF
        );
        se = await ae.populateTransaction["safeTransferFrom(address,address,uint256)"](
          X,
          ee,
          ie
          // {
          //   gasPrice,
          //   nonce,
          // }
        );
      } else
        return { success: !1, message: "NFT type not mentioned" };
      return se = { ...se, from: X }, {
        success: !0,
        txnObject: se
      };
    } catch (ae) {
      throw ae;
    }
  }
  /**
   * Bali beta specific.
   * To redeem food coupons.
   *
   */
  async burnNFT(X, { type: ee, tokenAddress: te, tokenId: ne, amount: ie }) {
    const oe = await X.getAddress();
    let se;
    if (ee == "ERC1155")
      try {
        const { contract: ae } = await this.getContract(
          te,
          void 0,
          QF
        ), { gasPrice: ue, nonce: le } = await this.getGasDetailsAndNonce(
          oe
        );
        se = await ae.populateTransaction.burn(ne, ie, {
          gasPrice: ue,
          nonce: le
        });
      } catch (ae) {
        return { success: !1, message: "BURN not supported", error: ae };
      }
    else
      return { success: !1, message: "NFT type not supported." };
    return await this.broadcastTransaction(X, se);
  }
  /**
   *
   * @param data Decryt encrypted data with private key.
   * @param privateKey
   * @returns
   */
  // async decrypt(data: Uint8Array, privateKey: string, signer?: ethers.providers.JsonRpcSigner) {
  //   const dec = new TextDecoder('utf-8');
  //   const encryptedAppString = dec.decode(data);
  //   console.log('decrypt', { encryptedAppString });
  //   let ethEncryptedData: sigUtil.EthEncryptedData = JSON.parse(encryptedAppString);
  //   const result = sigUtil.decrypt({
  //     encryptedData: ethEncryptedData,
  //     privateKey,
  //   });
  //   return result;
  // }
}
class mS {
  constructor(X, ee, te) {
    this.chains = {}, this.walletType = te, this.chains.MUMBAI = new us(
      ee,
      80001,
      "https://polygon-mumbai.blockpi.network/v1/rpc/public",
      X,
      "MUMBAI",
      te
    ), this.chains.ETH = new us(
      ee,
      1,
      "https://eth.llamarpc.com",
      X,
      "ETH",
      te
    ), this.chains.POLYGON = new us(
      ee,
      137,
      "https://polygon.llamarpc.com",
      X,
      "POLYGON",
      te
    ), this.chains.AVALANCHE = new us(
      ee,
      43114,
      "https://avalanche-c-chain.publicnode.com",
      X,
      "AVALANCHE",
      te
    ), this.chains.ARBITRUM = new us(
      ee,
      42161,
      "https://arbitrum-one.publicnode.com",
      X,
      "ARBITRUM",
      te
    ), this.chains.BINANCE = new us(
      ee,
      56,
      "https://bsc.publicnode.com",
      X,
      "BINANCE",
      te
    ), this.chains.OPTIMISM = new us(
      ee,
      10,
      "https://optimism.meowrpc.com",
      X,
      "OPTIMISM",
      te
    ), this.chains.FANTOM = new us(
      ee,
      250,
      "https://fantom.publicnode.com",
      X,
      "FANTOM",
      te
    ), this.chains.FUSE = new us(
      ee,
      122,
      "https://rpc.fuse.io/",
      X,
      "FUSE",
      te
    );
  }
}
const yS = Object.prototype.toString;
function bS(Y) {
  switch (yS.call(Y)) {
    case "[object Error]":
    case "[object Exception]":
    case "[object DOMException]":
      return !0;
    default:
      return Ns(Y, Error);
  }
}
function Bc(Y, X) {
  return yS.call(Y) === `[object ${X}]`;
}
function Ky(Y) {
  return Bc(Y, "ErrorEvent");
}
function cv(Y) {
  return Bc(Y, "DOMError");
}
function tH(Y) {
  return Bc(Y, "DOMException");
}
function Yi(Y) {
  return Bc(Y, "String");
}
function Jy(Y) {
  return typeof Y == "object" && Y !== null && "__sentry_template_string__" in Y && "__sentry_template_values__" in Y;
}
function Yy(Y) {
  return Y === null || Jy(Y) || typeof Y != "object" && typeof Y != "function";
}
function ec$2(Y) {
  return Bc(Y, "Object");
}
function I0(Y) {
  return typeof Event < "u" && Ns(Y, Event);
}
function rH(Y) {
  return typeof Element < "u" && Ns(Y, Element);
}
function nH(Y) {
  return Bc(Y, "RegExp");
}
function R0(Y) {
  return !!(Y && Y.then && typeof Y.then == "function");
}
function iH(Y) {
  return ec$2(Y) && "nativeEvent" in Y && "preventDefault" in Y && "stopPropagation" in Y;
}
function xS(Y) {
  return typeof Y == "number" && Y !== Y;
}
function Ns(Y, X) {
  try {
    return Y instanceof X;
  } catch {
    return !1;
  }
}
function wS(Y) {
  return !!(typeof Y == "object" && Y !== null && (Y.__isVue || Y._isVue));
}
function $a(Y, X = 0) {
  return typeof Y != "string" || X === 0 || Y.length <= X ? Y : `${Y.slice(0, X)}...`;
}
function uv(Y, X) {
  if (!Array.isArray(Y))
    return "";
  const ee = [];
  for (let te = 0; te < Y.length; te++) {
    const ne = Y[te];
    try {
      wS(ne) ? ee.push("[VueViewModel]") : ee.push(String(ne));
    } catch {
      ee.push("[value cannot be serialized]");
    }
  }
  return ee.join(X);
}
function sH(Y, X, ee = !1) {
  return Yi(Y) ? nH(X) ? X.test(Y) : Yi(X) ? ee ? Y === X : Y.includes(X) : !1 : !1;
}
function Nc(Y, X = [], ee = !1) {
  return X.some((te) => sH(Y, te, ee));
}
function oH(Y, X, ee = 250, te, ne, ie, oe) {
  if (!ie.exception || !ie.exception.values || !oe || !Ns(oe.originalException, Error))
    return;
  const se = ie.exception.values.length > 0 ? ie.exception.values[ie.exception.values.length - 1] : void 0;
  se && (ie.exception.values = aH(
    Tg(
      Y,
      X,
      ne,
      oe.originalException,
      te,
      ie.exception.values,
      se,
      0
    ),
    ee
  ));
}
function Tg(Y, X, ee, te, ne, ie, oe, se) {
  if (ie.length >= ee + 1)
    return ie;
  let ae = [...ie];
  if (Ns(te[ne], Error)) {
    fv(oe, se);
    const ue = Y(X, te[ne]), le = ae.length;
    lv(ue, ne, le, se), ae = Tg(
      Y,
      X,
      ee,
      te[ne],
      ne,
      [ue, ...ae],
      ue,
      le
    );
  }
  return Array.isArray(te.errors) && te.errors.forEach((ue, le) => {
    if (Ns(ue, Error)) {
      fv(oe, se);
      const he = Y(X, ue), me = ae.length;
      lv(he, `errors[${le}]`, me, se), ae = Tg(
        Y,
        X,
        ee,
        ue,
        ne,
        [he, ...ae],
        he,
        me
      );
    }
  }), ae;
}
function fv(Y, X) {
  Y.mechanism = Y.mechanism || { type: "generic", handled: !0 }, Y.mechanism = {
    ...Y.mechanism,
    ...Y.type === "AggregateError" && { is_exception_group: !0 },
    exception_id: X
  };
}
function lv(Y, X, ee, te) {
  Y.mechanism = Y.mechanism || { type: "generic", handled: !0 }, Y.mechanism = {
    ...Y.mechanism,
    type: "chained",
    source: X,
    exception_id: ee,
    parent_id: te
  };
}
function aH(Y, X) {
  return Y.map((ee) => (ee.value && (ee.value = $a(ee.value, X)), ee));
}
function rl(Y) {
  return Y && Y.Math == Math ? Y : void 0;
}
const zt = typeof globalThis == "object" && rl(globalThis) || // eslint-disable-next-line no-restricted-globals
typeof window == "object" && rl(window) || typeof self == "object" && rl(self) || typeof window == "object" && rl(window) || /* @__PURE__ */ function() {
  return this;
}() || {};
function Xy() {
  return zt;
}
function vS(Y, X, ee) {
  const te = ee || zt, ne = te.__SENTRY__ = te.__SENTRY__ || {};
  return ne[Y] || (ne[Y] = X());
}
const Da = Xy(), cH = 80;
function zo(Y, X = {}) {
  if (!Y)
    return "<unknown>";
  try {
    let ee = Y;
    const te = 5, ne = [];
    let ie = 0, oe = 0;
    const se = " > ", ae = se.length;
    let ue;
    const le = Array.isArray(X) ? X : X.keyAttrs, he = !Array.isArray(X) && X.maxStringLength || cH;
    for (; ee && ie++ < te && (ue = uH(ee, le), !(ue === "html" || ie > 1 && oe + ne.length * ae + ue.length >= he)); )
      ne.push(ue), oe += ue.length, ee = ee.parentNode;
    return ne.reverse().join(se);
  } catch {
    return "<unknown>";
  }
}
function uH(Y, X) {
  const ee = Y, te = [];
  let ne, ie, oe, se, ae;
  if (!ee || !ee.tagName)
    return "";
  if (Da.HTMLElement && ee instanceof HTMLElement && ee.dataset && ee.dataset.sentryComponent)
    return ee.dataset.sentryComponent;
  te.push(ee.tagName.toLowerCase());
  const ue = X && X.length ? X.filter((he) => ee.getAttribute(he)).map((he) => [he, ee.getAttribute(he)]) : null;
  if (ue && ue.length)
    ue.forEach((he) => {
      te.push(`[${he[0]}="${he[1]}"]`);
    });
  else if (ee.id && te.push(`#${ee.id}`), ne = ee.className, ne && Yi(ne))
    for (ie = ne.split(/\s+/), ae = 0; ae < ie.length; ae++)
      te.push(`.${ie[ae]}`);
  const le = ["aria-label", "type", "name", "title", "alt"];
  for (ae = 0; ae < le.length; ae++)
    oe = le[ae], se = ee.getAttribute(oe), se && te.push(`[${oe}="${se}"]`);
  return te.join("");
}
function fH() {
  try {
    return Da.document.location.href;
  } catch {
    return "";
  }
}
function lH(Y) {
  return Da.document && Da.document.querySelector ? Da.document.querySelector(Y) : null;
}
function ES(Y) {
  if (!Da.HTMLElement)
    return null;
  let X = Y;
  const ee = 5;
  for (let te = 0; te < ee; te++) {
    if (!X)
      return null;
    if (X instanceof HTMLElement && X.dataset.sentryComponent)
      return X.dataset.sentryComponent;
    X = X.parentNode;
  }
  return null;
}
const kc = typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__, dH = "Sentry Logger ", Ig = [
  "debug",
  "info",
  "warn",
  "error",
  "log",
  "assert",
  "trace"
], rd = {};
function qo(Y) {
  if (!("console" in zt))
    return Y();
  const X = zt.console, ee = {}, te = Object.keys(rd);
  te.forEach((ne) => {
    const ie = rd[ne];
    ee[ne] = X[ne], X[ne] = ie;
  });
  try {
    return Y();
  } finally {
    te.forEach((ne) => {
      X[ne] = ee[ne];
    });
  }
}
function hH() {
  let Y = !1;
  const X = {
    enable: () => {
      Y = !0;
    },
    disable: () => {
      Y = !1;
    },
    isEnabled: () => Y
  };
  return kc ? Ig.forEach((ee) => {
    X[ee] = (...te) => {
      Y && qo(() => {
        zt.console[ee](`${dH}[${ee}]:`, ...te);
      });
    };
  }) : Ig.forEach((ee) => {
    X[ee] = () => {
    };
  }), X;
}
const xe = hH(), pH = /^(?:(\w+):)\/\/(?:(\w+)(?::(\w+)?)?@)([\w.-]+)(?::(\d+))?\/(.+)/;
function gH(Y) {
  return Y === "http" || Y === "https";
}
function Pf(Y, X = !1) {
  const { host: ee, path: te, pass: ne, port: ie, projectId: oe, protocol: se, publicKey: ae } = Y;
  return `${se}://${ae}${X && ne ? `:${ne}` : ""}@${ee}${ie ? `:${ie}` : ""}/${te && `${te}/`}${oe}`;
}
function mH(Y) {
  const X = pH.exec(Y);
  if (!X) {
    qo(() => {
      console.error(`Invalid Sentry Dsn: ${Y}`);
    });
    return;
  }
  const [ee, te, ne = "", ie, oe = "", se] = X.slice(1);
  let ae = "", ue = se;
  const le = ue.split("/");
  if (le.length > 1 && (ae = le.slice(0, -1).join("/"), ue = le.pop()), ue) {
    const he = ue.match(/^\d+/);
    he && (ue = he[0]);
  }
  return _S({ host: ie, pass: ne, path: ae, projectId: ue, port: oe, protocol: ee, publicKey: te });
}
function _S(Y) {
  return {
    protocol: Y.protocol,
    publicKey: Y.publicKey || "",
    pass: Y.pass || "",
    host: Y.host,
    port: Y.port || "",
    path: Y.path || "",
    projectId: Y.projectId
  };
}
function yH(Y) {
  if (!kc)
    return !0;
  const { port: X, projectId: ee, protocol: te } = Y;
  return ["protocol", "publicKey", "host", "projectId"].find((ne) => Y[ne] ? !1 : (xe.error(`Invalid Sentry Dsn: ${ne} missing`), !0)) ? !1 : ee.match(/^\d+$/) ? gH(te) ? X && isNaN(parseInt(X, 10)) ? (xe.error(`Invalid Sentry Dsn: Invalid port ${X}`), !1) : !0 : (xe.error(`Invalid Sentry Dsn: Invalid protocol ${te}`), !1) : (xe.error(`Invalid Sentry Dsn: Invalid projectId ${ee}`), !1);
}
function bH(Y) {
  const X = typeof Y == "string" ? mH(Y) : _S(Y);
  if (!(!X || !yH(X)))
    return X;
}
class Di extends Error {
  /** Display name of this error instance. */
  constructor(X, ee = "warn") {
    super(X), this.message = X, this.name = new.target.prototype.constructor.name, Object.setPrototypeOf(this, new.target.prototype), this.logLevel = ee;
  }
}
function Yr(Y, X, ee) {
  if (!(X in Y))
    return;
  const te = Y[X], ne = ee(te);
  typeof ne == "function" && AS(ne, te), Y[X] = ne;
}
function Go(Y, X, ee) {
  try {
    Object.defineProperty(Y, X, {
      // enumerable: false, // the default, so we can save on bundle size by not explicitly setting it
      value: ee,
      writable: !0,
      configurable: !0
    });
  } catch {
    kc && xe.log(`Failed to add non-enumerable property "${X}" to object`, Y);
  }
}
function AS(Y, X) {
  try {
    const ee = X.prototype || {};
    Y.prototype = X.prototype = ee, Go(Y, "__sentry_original__", X);
  } catch {
  }
}
function Zy(Y) {
  return Y.__sentry_original__;
}
function xH(Y) {
  return Object.keys(Y).map((X) => `${encodeURIComponent(X)}=${encodeURIComponent(Y[X])}`).join("&");
}
function SS(Y) {
  if (bS(Y))
    return {
      message: Y.message,
      name: Y.name,
      stack: Y.stack,
      ...hv(Y)
    };
  if (I0(Y)) {
    const X = {
      type: Y.type,
      target: dv(Y.target),
      currentTarget: dv(Y.currentTarget),
      ...hv(Y)
    };
    return typeof CustomEvent < "u" && Ns(Y, CustomEvent) && (X.detail = Y.detail), X;
  } else
    return Y;
}
function dv(Y) {
  try {
    return rH(Y) ? zo(Y) : Object.prototype.toString.call(Y);
  } catch {
    return "<unknown>";
  }
}
function hv(Y) {
  if (typeof Y == "object" && Y !== null) {
    const X = {};
    for (const ee in Y)
      Object.prototype.hasOwnProperty.call(Y, ee) && (X[ee] = Y[ee]);
    return X;
  } else
    return {};
}
function wH(Y, X = 40) {
  const ee = Object.keys(SS(Y));
  if (ee.sort(), !ee.length)
    return "[object has no keys]";
  if (ee[0].length >= X)
    return $a(ee[0], X);
  for (let te = ee.length; te > 0; te--) {
    const ne = ee.slice(0, te).join(", ");
    if (!(ne.length > X))
      return te === ee.length ? ne : $a(ne, X);
  }
  return "";
}
function xn(Y) {
  return Rg(Y, /* @__PURE__ */ new Map());
}
function Rg(Y, X) {
  if (vH(Y)) {
    const ee = X.get(Y);
    if (ee !== void 0)
      return ee;
    const te = {};
    X.set(Y, te);
    for (const ne of Object.keys(Y))
      typeof Y[ne] < "u" && (te[ne] = Rg(Y[ne], X));
    return te;
  }
  if (Array.isArray(Y)) {
    const ee = X.get(Y);
    if (ee !== void 0)
      return ee;
    const te = [];
    return X.set(Y, te), Y.forEach((ne) => {
      te.push(Rg(ne, X));
    }), te;
  }
  return Y;
}
function vH(Y) {
  if (!ec$2(Y))
    return !1;
  try {
    const X = Object.getPrototypeOf(Y).constructor.name;
    return !X || X === "Object";
  } catch {
    return !0;
  }
}
const TS = 50, pv = /\(error: (.*)\)/, gv = /captureMessage|captureException/;
function IS(...Y) {
  const X = Y.sort((ee, te) => ee[0] - te[0]).map((ee) => ee[1]);
  return (ee, te = 0) => {
    const ne = [], ie = ee.split(`
`);
    for (let oe = te; oe < ie.length; oe++) {
      const se = ie[oe];
      if (se.length > 1024)
        continue;
      const ae = pv.test(se) ? se.replace(pv, "$1") : se;
      if (!ae.match(/\S*Error: /)) {
        for (const ue of X) {
          const le = ue(ae);
          if (le) {
            ne.push(le);
            break;
          }
        }
        if (ne.length >= TS)
          break;
      }
    }
    return _H(ne);
  };
}
function EH(Y) {
  return Array.isArray(Y) ? IS(...Y) : Y;
}
function _H(Y) {
  if (!Y.length)
    return [];
  const X = Array.from(Y);
  return /sentryWrapped/.test(X[X.length - 1].function || "") && X.pop(), X.reverse(), gv.test(X[X.length - 1].function || "") && (X.pop(), gv.test(X[X.length - 1].function || "") && X.pop()), X.slice(0, TS).map((ee) => ({
    ...ee,
    filename: ee.filename || X[X.length - 1].filename,
    function: ee.function || "?"
  }));
}
const wp = "<anonymous>";
function ks(Y) {
  try {
    return !Y || typeof Y != "function" ? wp : Y.name || wp;
  } catch {
    return wp;
  }
}
const Il = {}, mv = {};
function Zo(Y, X) {
  Il[Y] = Il[Y] || [], Il[Y].push(X);
}
function Qo(Y, X) {
  mv[Y] || (X(), mv[Y] = !0);
}
function bi(Y, X) {
  const ee = Y && Il[Y];
  if (ee)
    for (const te of ee)
      try {
        te(X);
      } catch (ne) {
        kc && xe.error(
          `Error while triggering instrumentation handler.
Type: ${Y}
Name: ${ks(te)}
Error:`,
          ne
        );
      }
}
function AH(Y) {
  const X = "console";
  Zo(X, Y), Qo(X, SH);
}
function SH() {
  "console" in zt && Ig.forEach(function(Y) {
    Y in zt.console && Yr(zt.console, Y, function(X) {
      return rd[Y] = X, function(...ee) {
        bi("console", { args: ee, level: Y });
        const te = rd[Y];
        te && te.apply(zt.console, ee);
      };
    });
  });
}
function Tr() {
  const Y = zt, X = Y.crypto || Y.msCrypto;
  let ee = () => Math.random() * 16;
  try {
    if (X && X.randomUUID)
      return X.randomUUID().replace(/-/g, "");
    X && X.getRandomValues && (ee = () => {
      const te = new Uint8Array(1);
      return X.getRandomValues(te), te[0];
    });
  } catch {
  }
  return ("10000000100040008000" + 1e11).replace(
    /[018]/g,
    (te) => (
      // eslint-disable-next-line no-bitwise
      (te ^ (ee() & 15) >> te / 4).toString(16)
    )
  );
}
function RS(Y) {
  return Y.exception && Y.exception.values ? Y.exception.values[0] : void 0;
}
function Zs(Y) {
  const { message: X, event_id: ee } = Y;
  if (X)
    return X;
  const te = RS(Y);
  return te ? te.type && te.value ? `${te.type}: ${te.value}` : te.type || te.value || ee || "<unknown>" : ee || "<unknown>";
}
function Cg(Y, X, ee) {
  const te = Y.exception = Y.exception || {}, ne = te.values = te.values || [], ie = ne[0] = ne[0] || {};
  ie.value || (ie.value = X || ""), ie.type || (ie.type = ee || "Error");
}
function Qu(Y, X) {
  const ee = RS(Y);
  if (!ee)
    return;
  const te = { type: "generic", handled: !0 }, ne = ee.mechanism;
  if (ee.mechanism = { ...te, ...ne, ...X }, X && "data" in X) {
    const ie = { ...ne && ne.data, ...X.data };
    ee.mechanism.data = ie;
  }
}
function yv(Y) {
  if (Y && Y.__sentry_captured__)
    return !0;
  try {
    Go(Y, "__sentry_captured__", !0);
  } catch {
  }
  return !1;
}
function CS(Y) {
  return Array.isArray(Y) ? Y : [Y];
}
const ha = zt, TH = 1e3;
let bv, Pg, Og;
function PS(Y) {
  const X = "dom";
  Zo(X, Y), Qo(X, IH);
}
function IH() {
  if (!ha.document)
    return;
  const Y = bi.bind(null, "dom"), X = xv(Y, !0);
  ha.document.addEventListener("click", X, !1), ha.document.addEventListener("keypress", X, !1), ["EventTarget", "Node"].forEach((ee) => {
    const te = ha[ee] && ha[ee].prototype;
    !te || !te.hasOwnProperty || !te.hasOwnProperty("addEventListener") || (Yr(te, "addEventListener", function(ne) {
      return function(ie, oe, se) {
        if (ie === "click" || ie == "keypress")
          try {
            const ae = this, ue = ae.__sentry_instrumentation_handlers__ = ae.__sentry_instrumentation_handlers__ || {}, le = ue[ie] = ue[ie] || { refCount: 0 };
            if (!le.handler) {
              const he = xv(Y);
              le.handler = he, ne.call(this, ie, he, se);
            }
            le.refCount++;
          } catch {
          }
        return ne.call(this, ie, oe, se);
      };
    }), Yr(
      te,
      "removeEventListener",
      function(ne) {
        return function(ie, oe, se) {
          if (ie === "click" || ie == "keypress")
            try {
              const ae = this, ue = ae.__sentry_instrumentation_handlers__ || {}, le = ue[ie];
              le && (le.refCount--, le.refCount <= 0 && (ne.call(this, ie, le.handler, se), le.handler = void 0, delete ue[ie]), Object.keys(ue).length === 0 && delete ae.__sentry_instrumentation_handlers__);
            } catch {
            }
          return ne.call(this, ie, oe, se);
        };
      }
    ));
  });
}
function RH(Y) {
  if (Y.type !== Pg)
    return !1;
  try {
    if (!Y.target || Y.target._sentryId !== Og)
      return !1;
  } catch {
  }
  return !0;
}
function CH(Y, X) {
  return Y !== "keypress" ? !1 : !X || !X.tagName ? !0 : !(X.tagName === "INPUT" || X.tagName === "TEXTAREA" || X.isContentEditable);
}
function xv(Y, X = !1) {
  return (ee) => {
    if (!ee || ee._sentryCaptured)
      return;
    const te = PH(ee);
    if (CH(ee.type, te))
      return;
    Go(ee, "_sentryCaptured", !0), te && !te._sentryId && Go(te, "_sentryId", Tr());
    const ne = ee.type === "keypress" ? "input" : ee.type;
    RH(ee) || (Y({ event: ee, name: ne, global: X }), Pg = ee.type, Og = te ? te._sentryId : void 0), clearTimeout(bv), bv = ha.setTimeout(() => {
      Og = void 0, Pg = void 0;
    }, TH);
  };
}
function PH(Y) {
  try {
    return Y.target;
  } catch {
    return null;
  }
}
const Bg = Xy();
function OS() {
  if (!("fetch" in Bg))
    return !1;
  try {
    return new Headers(), new Request("http://www.example.com"), new Response(), !0;
  } catch {
    return !1;
  }
}
function Ng(Y) {
  return Y && /^function fetch\(\)\s+\{\s+\[native code\]\s+\}$/.test(Y.toString());
}
function OH() {
  if (typeof EdgeRuntime == "string")
    return !0;
  if (!OS())
    return !1;
  if (Ng(Bg.fetch))
    return !0;
  let Y = !1;
  const X = Bg.document;
  if (X && typeof X.createElement == "function")
    try {
      const ee = X.createElement("iframe");
      ee.hidden = !0, X.head.appendChild(ee), ee.contentWindow && ee.contentWindow.fetch && (Y = Ng(ee.contentWindow.fetch)), X.head.removeChild(ee);
    } catch (ee) {
      kc && xe.warn("Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ", ee);
    }
  return Y;
}
function Qy(Y) {
  const X = "fetch";
  Zo(X, Y), Qo(X, BH);
}
function BH() {
  OH() && Yr(zt, "fetch", function(Y) {
    return function(...X) {
      const { method: ee, url: te } = NH(X), ne = {
        args: X,
        fetchData: {
          method: ee,
          url: te
        },
        startTimestamp: Date.now()
      };
      return bi("fetch", {
        ...ne
      }), Y.apply(zt, X).then(
        (ie) => {
          const oe = {
            ...ne,
            endTimestamp: Date.now(),
            response: ie
          };
          return bi("fetch", oe), ie;
        },
        (ie) => {
          const oe = {
            ...ne,
            endTimestamp: Date.now(),
            error: ie
          };
          throw bi("fetch", oe), ie;
        }
      );
    };
  });
}
function kg(Y, X) {
  return !!Y && typeof Y == "object" && !!Y[X];
}
function wv(Y) {
  return typeof Y == "string" ? Y : Y ? kg(Y, "url") ? Y.url : Y.toString ? Y.toString() : "" : "";
}
function NH(Y) {
  if (Y.length === 0)
    return { method: "GET", url: "" };
  if (Y.length === 2) {
    const [ee, te] = Y;
    return {
      url: wv(ee),
      method: kg(te, "method") ? String(te.method).toUpperCase() : "GET"
    };
  }
  const X = Y[0];
  return {
    url: wv(X),
    method: kg(X, "method") ? String(X.method).toUpperCase() : "GET"
  };
}
let nl = null;
function BS(Y) {
  const X = "error";
  Zo(X, Y), Qo(X, kH);
}
function kH() {
  nl = zt.onerror, zt.onerror = function(Y, X, ee, te, ne) {
    return bi("error", {
      column: te,
      error: ne,
      line: ee,
      msg: Y,
      url: X
    }), nl && !nl.__SENTRY_LOADER__ ? nl.apply(this, arguments) : !1;
  }, zt.onerror.__SENTRY_INSTRUMENTED__ = !0;
}
let il = null;
function NS(Y) {
  const X = "unhandledrejection";
  Zo(X, Y), Qo(X, MH);
}
function MH() {
  il = zt.onunhandledrejection, zt.onunhandledrejection = function(Y) {
    return bi("unhandledrejection", Y), il && !il.__SENTRY_LOADER__ ? il.apply(this, arguments) : !0;
  }, zt.onunhandledrejection.__SENTRY_INSTRUMENTED__ = !0;
}
const sl$1 = Xy();
function LH() {
  const Y = sl$1.chrome, X = Y && Y.app && Y.app.runtime, ee = "history" in sl$1 && !!sl$1.history.pushState && !!sl$1.history.replaceState;
  return !X && ee;
}
const eu = zt;
let ol;
function C0(Y) {
  const X = "history";
  Zo(X, Y), Qo(X, FH);
}
function FH() {
  if (!LH())
    return;
  const Y = eu.onpopstate;
  eu.onpopstate = function(...ee) {
    const te = eu.location.href, ne = ol;
    if (ol = te, bi("history", { from: ne, to: te }), Y)
      try {
        return Y.apply(this, ee);
      } catch {
      }
  };
  function X(ee) {
    return function(...te) {
      const ne = te.length > 2 ? te[2] : void 0;
      if (ne) {
        const ie = ol, oe = String(ne);
        ol = oe, bi("history", { from: ie, to: oe });
      }
      return ee.apply(this, te);
    };
  }
  Yr(eu.history, "pushState", X), Yr(eu.history, "replaceState", X);
}
const $H = zt, eo = "__sentry_xhr_v3__";
function eb(Y) {
  const X = "xhr";
  Zo(X, Y), Qo(X, DH);
}
function DH() {
  if (!$H.XMLHttpRequest)
    return;
  const Y = XMLHttpRequest.prototype;
  Yr(Y, "open", function(X) {
    return function(...ee) {
      const te = Date.now(), ne = Yi(ee[0]) ? ee[0].toUpperCase() : void 0, ie = UH(ee[1]);
      if (!ne || !ie)
        return X.apply(this, ee);
      this[eo] = {
        method: ne,
        url: ie,
        request_headers: {}
      }, ne === "POST" && ie.match(/sentry_key/) && (this.__sentry_own_request__ = !0);
      const oe = () => {
        const se = this[eo];
        if (se && this.readyState === 4) {
          try {
            se.status_code = this.status;
          } catch {
          }
          const ae = {
            args: [ne, ie],
            endTimestamp: Date.now(),
            startTimestamp: te,
            xhr: this
          };
          bi("xhr", ae);
        }
      };
      return "onreadystatechange" in this && typeof this.onreadystatechange == "function" ? Yr(this, "onreadystatechange", function(se) {
        return function(...ae) {
          return oe(), se.apply(this, ae);
        };
      }) : this.addEventListener("readystatechange", oe), Yr(this, "setRequestHeader", function(se) {
        return function(...ae) {
          const [ue, le] = ae, he = this[eo];
          return he && Yi(ue) && Yi(le) && (he.request_headers[ue.toLowerCase()] = le), se.apply(this, ae);
        };
      }), X.apply(this, ee);
    };
  }), Yr(Y, "send", function(X) {
    return function(...ee) {
      const te = this[eo];
      if (!te)
        return X.apply(this, ee);
      ee[0] !== void 0 && (te.body = ee[0]);
      const ne = {
        args: [te.method, te.url],
        startTimestamp: Date.now(),
        xhr: this
      };
      return bi("xhr", ne), X.apply(this, ee);
    };
  });
}
function UH(Y) {
  if (Yi(Y))
    return Y;
  try {
    return Y.toString();
  } catch {
  }
}
function jH() {
  return typeof __SENTRY_BROWSER_BUNDLE__ < "u" && !!__SENTRY_BROWSER_BUNDLE__;
}
function HH() {
  return "npm";
}
function zH() {
  return !jH() && Object.prototype.toString.call(typeof process < "u" ? process : 0) === "[object process]";
}
function vv() {
  return typeof window < "u" && (!zH() || qH());
}
function qH() {
  return (
    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-explicit-any
    zt.process !== void 0 && zt.process.type === "renderer"
  );
}
function GH() {
  const Y = typeof WeakSet == "function", X = Y ? /* @__PURE__ */ new WeakSet() : [];
  function ee(ne) {
    if (Y)
      return X.has(ne) ? !0 : (X.add(ne), !1);
    for (let ie = 0; ie < X.length; ie++)
      if (X[ie] === ne)
        return !0;
    return X.push(ne), !1;
  }
  function te(ne) {
    if (Y)
      X.delete(ne);
    else
      for (let ie = 0; ie < X.length; ie++)
        if (X[ie] === ne) {
          X.splice(ie, 1);
          break;
        }
  }
  return [ee, te];
}
function ki(Y, X = 100, ee = 1 / 0) {
  try {
    return Mg("", Y, X, ee);
  } catch (te) {
    return { ERROR: `**non-serializable** (${te})` };
  }
}
function kS(Y, X = 3, ee = 100 * 1024) {
  const te = ki(Y, X);
  return JH(te) > ee ? kS(Y, X - 1, ee) : te;
}
function Mg(Y, X, ee = 1 / 0, te = 1 / 0, ne = GH()) {
  const [ie, oe] = ne;
  if (X == null || // this matches null and undefined -> eqeq not eqeqeq
  ["number", "boolean", "string"].includes(typeof X) && !xS(X))
    return X;
  const se = VH(Y, X);
  if (!se.startsWith("[object "))
    return se;
  if (X.__sentry_skip_normalization__)
    return X;
  const ae = typeof X.__sentry_override_normalization_depth__ == "number" ? X.__sentry_override_normalization_depth__ : ee;
  if (ae === 0)
    return se.replace("object ", "");
  if (ie(X))
    return "[Circular ~]";
  const ue = X;
  if (ue && typeof ue.toJSON == "function")
    try {
      const ye = ue.toJSON();
      return Mg("", ye, ae - 1, te, ne);
    } catch {
    }
  const le = Array.isArray(X) ? [] : {};
  let he = 0;
  const me = SS(X);
  for (const ye in me) {
    if (!Object.prototype.hasOwnProperty.call(me, ye))
      continue;
    if (he >= te) {
      le[ye] = "[MaxProperties ~]";
      break;
    }
    const we = me[ye];
    le[ye] = Mg(ye, we, ae - 1, te, ne), he++;
  }
  return oe(X), le;
}
function VH(Y, X) {
  try {
    if (Y === "domain" && X && typeof X == "object" && X._events)
      return "[Domain]";
    if (Y === "domainEmitter")
      return "[DomainEmitter]";
    if (typeof window < "u" && X === window)
      return "[Global]";
    if (typeof window < "u" && X === window)
      return "[Window]";
    if (typeof document < "u" && X === document)
      return "[Document]";
    if (wS(X))
      return "[VueViewModel]";
    if (iH(X))
      return "[SyntheticEvent]";
    if (typeof X == "number" && X !== X)
      return "[NaN]";
    if (typeof X == "function")
      return `[Function: ${ks(X)}]`;
    if (typeof X == "symbol")
      return `[${String(X)}]`;
    if (typeof X == "bigint")
      return `[BigInt: ${String(X)}]`;
    const ee = WH(X);
    return /^HTML(\w*)Element$/.test(ee) ? `[HTMLElement: ${ee}]` : `[object ${ee}]`;
  } catch (ee) {
    return `**non-serializable** (${ee})`;
  }
}
function WH(Y) {
  const X = Object.getPrototypeOf(Y);
  return X ? X.constructor.name : "null prototype";
}
function KH(Y) {
  return ~-encodeURI(Y).split(/%..|./).length;
}
function JH(Y) {
  return KH(JSON.stringify(Y));
}
var gs;
(function(Y) {
  Y[Y.PENDING = 0] = "PENDING";
  const X = 1;
  Y[Y.RESOLVED = X] = "RESOLVED";
  const ee = 2;
  Y[Y.REJECTED = ee] = "REJECTED";
})(gs || (gs = {}));
function tc(Y) {
  return new Dn((X) => {
    X(Y);
  });
}
function tb(Y) {
  return new Dn((X, ee) => {
    ee(Y);
  });
}
class Dn {
  constructor(X) {
    Dn.prototype.__init.call(this), Dn.prototype.__init2.call(this), Dn.prototype.__init3.call(this), Dn.prototype.__init4.call(this), this._state = gs.PENDING, this._handlers = [];
    try {
      X(this._resolve, this._reject);
    } catch (ee) {
      this._reject(ee);
    }
  }
  /** JSDoc */
  then(X, ee) {
    return new Dn((te, ne) => {
      this._handlers.push([
        !1,
        (ie) => {
          if (!X)
            te(ie);
          else
            try {
              te(X(ie));
            } catch (oe) {
              ne(oe);
            }
        },
        (ie) => {
          if (!ee)
            ne(ie);
          else
            try {
              te(ee(ie));
            } catch (oe) {
              ne(oe);
            }
        }
      ]), this._executeHandlers();
    });
  }
  /** JSDoc */
  catch(X) {
    return this.then((ee) => ee, X);
  }
  /** JSDoc */
  finally(X) {
    return new Dn((ee, te) => {
      let ne, ie;
      return this.then(
        (oe) => {
          ie = !1, ne = oe, X && X();
        },
        (oe) => {
          ie = !0, ne = oe, X && X();
        }
      ).then(() => {
        if (ie) {
          te(ne);
          return;
        }
        ee(ne);
      });
    });
  }
  /** JSDoc */
  __init() {
    this._resolve = (X) => {
      this._setResult(gs.RESOLVED, X);
    };
  }
  /** JSDoc */
  __init2() {
    this._reject = (X) => {
      this._setResult(gs.REJECTED, X);
    };
  }
  /** JSDoc */
  __init3() {
    this._setResult = (X, ee) => {
      if (this._state === gs.PENDING) {
        if (R0(ee)) {
          ee.then(this._resolve, this._reject);
          return;
        }
        this._state = X, this._value = ee, this._executeHandlers();
      }
    };
  }
  /** JSDoc */
  __init4() {
    this._executeHandlers = () => {
      if (this._state === gs.PENDING)
        return;
      const X = this._handlers.slice();
      this._handlers = [], X.forEach((ee) => {
        ee[0] || (this._state === gs.RESOLVED && ee[1](this._value), this._state === gs.REJECTED && ee[2](this._value), ee[0] = !0);
      });
    };
  }
}
function YH(Y) {
  const X = [];
  function ee() {
    return Y === void 0 || X.length < Y;
  }
  function te(oe) {
    return X.splice(X.indexOf(oe), 1)[0];
  }
  function ne(oe) {
    if (!ee())
      return tb(new Di("Not adding Promise because buffer limit was reached."));
    const se = oe();
    return X.indexOf(se) === -1 && X.push(se), se.then(() => te(se)).then(
      null,
      () => te(se).then(null, () => {
      })
    ), se;
  }
  function ie(oe) {
    return new Dn((se, ae) => {
      let ue = X.length;
      if (!ue)
        return se(!0);
      const le = setTimeout(() => {
        oe && oe > 0 && se(!1);
      }, oe);
      X.forEach((he) => {
        tc(he).then(() => {
          --ue || (clearTimeout(le), se(!0));
        }, ae);
      });
    });
  }
  return {
    $: X,
    add: ne,
    drain: ie
  };
}
function Rl(Y) {
  if (!Y)
    return {};
  const X = Y.match(/^(([^:/?#]+):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$/);
  if (!X)
    return {};
  const ee = X[6] || "", te = X[8] || "";
  return {
    host: X[4],
    path: X[5],
    protocol: X[2],
    search: ee,
    hash: te,
    relative: X[5] + ee + te
    // everything minus origin
  };
}
const XH = ["fatal", "error", "warning", "log", "info", "debug"];
function ZH(Y) {
  return Y === "warn" ? "warning" : XH.includes(Y) ? Y : "log";
}
const MS = 1e3;
function Of() {
  return Date.now() / MS;
}
function QH() {
  const { performance: Y } = zt;
  if (!Y || !Y.now)
    return Of;
  const X = Date.now() - Y.now(), ee = Y.timeOrigin == null ? X : Y.timeOrigin;
  return () => (ee + Y.now()) / MS;
}
const Bf = QH(), vi = (() => {
  const { performance: Y } = zt;
  if (!Y || !Y.now)
    return;
  const X = 3600 * 1e3, ee = Y.now(), te = Date.now(), ne = Y.timeOrigin ? Math.abs(Y.timeOrigin + ee - te) : X, ie = ne < X, oe = Y.timing && Y.timing.navigationStart, se = typeof oe == "number" ? Math.abs(oe + ee - te) : X, ae = se < X;
  return ie || ae ? ne <= se ? Y.timeOrigin : oe : te;
})(), Lg = "baggage", LS = "sentry-", ez = /^sentry-/, tz = 8192;
function rz(Y) {
  if (!Yi(Y) && !Array.isArray(Y))
    return;
  let X = {};
  if (Array.isArray(Y))
    X = Y.reduce((te, ne) => {
      const ie = Ev(ne);
      for (const oe of Object.keys(ie))
        te[oe] = ie[oe];
      return te;
    }, {});
  else {
    if (!Y)
      return;
    X = Ev(Y);
  }
  const ee = Object.entries(X).reduce((te, [ne, ie]) => {
    if (ne.match(ez)) {
      const oe = ne.slice(LS.length);
      te[oe] = ie;
    }
    return te;
  }, {});
  if (Object.keys(ee).length > 0)
    return ee;
}
function FS(Y) {
  if (!Y)
    return;
  const X = Object.entries(Y).reduce(
    (ee, [te, ne]) => (ne && (ee[`${LS}${te}`] = ne), ee),
    {}
  );
  return nz(X);
}
function Ev(Y) {
  return Y.split(",").map((X) => X.split("=").map((ee) => decodeURIComponent(ee.trim()))).reduce((X, [ee, te]) => (X[ee] = te, X), {});
}
function nz(Y) {
  if (Object.keys(Y).length !== 0)
    return Object.entries(Y).reduce((X, [ee, te], ne) => {
      const ie = `${encodeURIComponent(ee)}=${encodeURIComponent(te)}`, oe = ne === 0 ? ie : `${X},${ie}`;
      return oe.length > tz ? (kc && xe.warn(
        `Not adding key: ${ee} with val: ${te} to baggage header due to exceeding baggage size limits.`
      ), X) : oe;
    }, "");
}
const iz = new RegExp(
  "^[ \\t]*([0-9a-f]{32})?-?([0-9a-f]{16})?-?([01])?[ \\t]*$"
  // whitespace
);
function sz(Y) {
  if (!Y)
    return;
  const X = Y.match(iz);
  if (!X)
    return;
  let ee;
  return X[3] === "1" ? ee = !0 : X[3] === "0" && (ee = !1), {
    traceId: X[1],
    parentSampled: ee,
    parentSpanId: X[2]
  };
}
function oz(Y, X) {
  const ee = sz(Y), te = rz(X), { traceId: ne, parentSpanId: ie, parentSampled: oe } = ee || {};
  return ee ? {
    traceId: ne || Tr(),
    parentSpanId: ie || Tr().substring(16),
    spanId: Tr().substring(16),
    sampled: oe,
    dsc: te || {}
    // If we have traceparent data but no DSC it means we are not head of trace and we must freeze it
  } : {
    traceId: ne || Tr(),
    spanId: Tr().substring(16)
  };
}
function rb(Y = Tr(), X = Tr().substring(16), ee) {
  let te = "";
  return ee !== void 0 && (te = ee ? "-1" : "-0"), `${Y}-${X}${te}`;
}
function ea(Y, X = []) {
  return [Y, X];
}
function az(Y, X) {
  const [ee, te] = Y;
  return [ee, [...te, X]];
}
function _v(Y, X) {
  const ee = Y[1];
  for (const te of ee) {
    const ne = te[0].type;
    if (X(te, ne))
      return !0;
  }
  return !1;
}
function Fg(Y, X) {
  return (X || new TextEncoder()).encode(Y);
}
function cz(Y, X) {
  const [ee, te] = Y;
  let ne = JSON.stringify(ee);
  function ie(oe) {
    typeof ne == "string" ? ne = typeof oe == "string" ? ne + oe : [Fg(ne, X), oe] : ne.push(typeof oe == "string" ? Fg(oe, X) : oe);
  }
  for (const oe of te) {
    const [se, ae] = oe;
    if (ie(`
${JSON.stringify(se)}
`), typeof ae == "string" || ae instanceof Uint8Array)
      ie(ae);
    else {
      let ue;
      try {
        ue = JSON.stringify(ae);
      } catch {
        ue = JSON.stringify(ki(ae));
      }
      ie(ue);
    }
  }
  return typeof ne == "string" ? ne : uz(ne);
}
function uz(Y) {
  const X = Y.reduce((ne, ie) => ne + ie.length, 0), ee = new Uint8Array(X);
  let te = 0;
  for (const ne of Y)
    ee.set(ne, te), te += ne.length;
  return ee;
}
function fz(Y, X) {
  const ee = typeof Y.data == "string" ? Fg(Y.data, X) : Y.data;
  return [
    xn({
      type: "attachment",
      length: ee.length,
      filename: Y.filename,
      content_type: Y.contentType,
      attachment_type: Y.attachmentType
    }),
    ee
  ];
}
const lz = {
  session: "session",
  sessions: "session",
  attachment: "attachment",
  transaction: "transaction",
  event: "error",
  client_report: "internal",
  user_report: "default",
  profile: "profile",
  replay_event: "replay",
  replay_recording: "replay",
  check_in: "monitor",
  feedback: "feedback",
  span: "span",
  // TODO: This is a temporary workaround until we have a proper data category for metrics
  statsd: "unknown"
};
function Av(Y) {
  return lz[Y];
}
function nb(Y) {
  if (!Y || !Y.sdk)
    return;
  const { name: X, version: ee } = Y.sdk;
  return { name: X, version: ee };
}
function $S(Y, X, ee, te) {
  const ne = Y.sdkProcessingMetadata && Y.sdkProcessingMetadata.dynamicSamplingContext;
  return {
    event_id: Y.event_id,
    sent_at: (/* @__PURE__ */ new Date()).toISOString(),
    ...X && { sdk: X },
    ...!!ee && te && { dsn: Pf(te) },
    ...ne && {
      trace: xn({ ...ne })
    }
  };
}
function dz(Y, X, ee) {
  const te = [
    { type: "client_report" },
    {
      timestamp: ee || Of(),
      discarded_events: Y
    }
  ];
  return ea(X ? { dsn: X } : {}, [te]);
}
const hz = 60 * 1e3;
function pz(Y, X = Date.now()) {
  const ee = parseInt(`${Y}`, 10);
  if (!isNaN(ee))
    return ee * 1e3;
  const te = Date.parse(`${Y}`);
  return isNaN(te) ? hz : te - X;
}
function gz(Y, X) {
  return Y[X] || Y.all || 0;
}
function DS(Y, X, ee = Date.now()) {
  return gz(Y, X) > ee;
}
function US(Y, { statusCode: X, headers: ee }, te = Date.now()) {
  const ne = {
    ...Y
  }, ie = ee && ee["x-sentry-rate-limits"], oe = ee && ee["retry-after"];
  if (ie)
    for (const se of ie.trim().split(",")) {
      const [ae, ue] = se.split(":", 2), le = parseInt(ae, 10), he = (isNaN(le) ? 60 : le) * 1e3;
      if (!ue)
        ne.all = te + he;
      else
        for (const me of ue.split(";"))
          ne[me] = te + he;
    }
  else
    oe ? ne.all = te + pz(oe, te) : X === 429 && (ne.all = te + 60 * 1e3);
  return ne;
}
function mz(Y, X) {
  return Y ?? X();
}
function vp(Y) {
  let X, ee = Y[0], te = 1;
  for (; te < Y.length; ) {
    const ne = Y[te], ie = Y[te + 1];
    if (te += 2, (ne === "optionalAccess" || ne === "optionalCall") && ee == null)
      return;
    ne === "access" || ne === "optionalAccess" ? (X = ee, ee = ie(ee)) : (ne === "call" || ne === "optionalCall") && (ee = ie((...oe) => ee.call(X, ...oe)), X = void 0);
  }
  return ee;
}
const et = typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__, P0 = "production";
function ib() {
  return vS("globalEventProcessors", () => []);
}
function yz(Y) {
  ib().push(Y);
}
function nd(Y, X, ee, te = 0) {
  return new Dn((ne, ie) => {
    const oe = Y[te];
    if (X === null || typeof oe != "function")
      ne(X);
    else {
      const se = oe({ ...X }, ee);
      et && oe.id && se === null && xe.log(`Event processor "${oe.id}" dropped event`), R0(se) ? se.then((ae) => nd(Y, ae, ee, te + 1).then(ne)).then(null, ie) : nd(Y, se, ee, te + 1).then(ne).then(null, ie);
    }
  });
}
function jS(Y) {
  const X = Bf(), ee = {
    sid: Tr(),
    init: !0,
    timestamp: X,
    started: X,
    duration: 0,
    status: "ok",
    errors: 0,
    ignoreDuration: !1,
    toJSON: () => bz(ee)
  };
  return Y && Vo(ee, Y), ee;
}
function Vo(Y, X = {}) {
  if (X.user && (!Y.ipAddress && X.user.ip_address && (Y.ipAddress = X.user.ip_address), !Y.did && !X.did && (Y.did = X.user.id || X.user.email || X.user.username)), Y.timestamp = X.timestamp || Bf(), X.abnormal_mechanism && (Y.abnormal_mechanism = X.abnormal_mechanism), X.ignoreDuration && (Y.ignoreDuration = X.ignoreDuration), X.sid && (Y.sid = X.sid.length === 32 ? X.sid : Tr()), X.init !== void 0 && (Y.init = X.init), !Y.did && X.did && (Y.did = `${X.did}`), typeof X.started == "number" && (Y.started = X.started), Y.ignoreDuration)
    Y.duration = void 0;
  else if (typeof X.duration == "number")
    Y.duration = X.duration;
  else {
    const ee = Y.timestamp - Y.started;
    Y.duration = ee >= 0 ? ee : 0;
  }
  X.release && (Y.release = X.release), X.environment && (Y.environment = X.environment), !Y.ipAddress && X.ipAddress && (Y.ipAddress = X.ipAddress), !Y.userAgent && X.userAgent && (Y.userAgent = X.userAgent), typeof X.errors == "number" && (Y.errors = X.errors), X.status && (Y.status = X.status);
}
function HS(Y, X) {
  let ee = {};
  X ? ee = { status: X } : Y.status === "ok" && (ee = { status: "exited" }), Vo(Y, ee);
}
function bz(Y) {
  return xn({
    sid: `${Y.sid}`,
    init: Y.init,
    // Make sure that sec is converted to ms for date constructor
    started: new Date(Y.started * 1e3).toISOString(),
    timestamp: new Date(Y.timestamp * 1e3).toISOString(),
    status: Y.status,
    errors: Y.errors,
    did: typeof Y.did == "number" || typeof Y.did == "string" ? `${Y.did}` : void 0,
    duration: Y.duration,
    abnormal_mechanism: Y.abnormal_mechanism,
    attrs: {
      release: Y.release,
      environment: Y.environment,
      ip_address: Y.ipAddress,
      user_agent: Y.userAgent
    }
  });
}
const xz = 0, zS = 1;
function sb(Y) {
  const { spanId: X, traceId: ee } = Y.spanContext(), { data: te, op: ne, parent_span_id: ie, status: oe, tags: se, origin: ae } = rn(Y);
  return xn({
    data: te,
    op: ne,
    parent_span_id: ie,
    span_id: X,
    status: oe,
    tags: se,
    trace_id: ee,
    origin: ae
  });
}
function O0(Y) {
  const { traceId: X, spanId: ee } = Y.spanContext(), te = ob(Y);
  return rb(X, ee, te);
}
function B0(Y) {
  return typeof Y == "number" ? Sv(Y) : Array.isArray(Y) ? Y[0] + Y[1] / 1e9 : Y instanceof Date ? Sv(Y.getTime()) : Bf();
}
function Sv(Y) {
  return Y > 9999999999 ? Y / 1e3 : Y;
}
function rn(Y) {
  return wz(Y) ? Y.getSpanJSON() : typeof Y.toJSON == "function" ? Y.toJSON() : {};
}
function wz(Y) {
  return typeof Y.getSpanJSON == "function";
}
function ob(Y) {
  const { traceFlags: X } = Y.spanContext();
  return !!(X & zS);
}
function qS(Y, X, ee, te, ne, ie) {
  const { normalizeDepth: oe = 3, normalizeMaxBreadth: se = 1e3 } = Y, ae = {
    ...X,
    event_id: X.event_id || ee.event_id || Tr(),
    timestamp: X.timestamp || Of()
  }, ue = ee.integrations || Y.integrations.map((Ee) => Ee.name);
  vz(ae, Y), Az(ae, ue), X.type === void 0 && Ez(ae, Y.stackParser);
  const le = Tz(te, ee.captureContext);
  ee.mechanism && Qu(ae, ee.mechanism);
  const he = ne && ne.getEventProcessors ? ne.getEventProcessors() : [], me = Dz().getScopeData();
  if (ie) {
    const Ee = ie.getScopeData();
    Cv(me, Ee);
  }
  if (le) {
    const Ee = le.getScopeData();
    Cv(me, Ee);
  }
  const ye = [...ee.attachments || [], ...me.attachments];
  ye.length && (ee.attachments = ye), KS(ae, me);
  const we = [
    ...he,
    // eslint-disable-next-line deprecation/deprecation
    ...ib(),
    // Run scope event processors _after_ all other processors
    ...me.eventProcessors
  ];
  return nd(we, ae, ee).then((Ee) => (Ee && _z(Ee), typeof oe == "number" && oe > 0 ? Sz(Ee, oe, se) : Ee));
}
function vz(Y, X) {
  const { environment: ee, release: te, dist: ne, maxValueLength: ie = 250 } = X;
  "environment" in Y || (Y.environment = "environment" in X ? ee : P0), Y.release === void 0 && te !== void 0 && (Y.release = te), Y.dist === void 0 && ne !== void 0 && (Y.dist = ne), Y.message && (Y.message = $a(Y.message, ie));
  const oe = Y.exception && Y.exception.values && Y.exception.values[0];
  oe && oe.value && (oe.value = $a(oe.value, ie));
  const se = Y.request;
  se && se.url && (se.url = $a(se.url, ie));
}
const Tv = /* @__PURE__ */ new WeakMap();
function Ez(Y, X) {
  const ee = zt._sentryDebugIds;
  if (!ee)
    return;
  let te;
  const ne = Tv.get(X);
  ne ? te = ne : (te = /* @__PURE__ */ new Map(), Tv.set(X, te));
  const ie = Object.keys(ee).reduce((oe, se) => {
    let ae;
    const ue = te.get(se);
    ue ? ae = ue : (ae = X(se), te.set(se, ae));
    for (let le = ae.length - 1; le >= 0; le--) {
      const he = ae[le];
      if (he.filename) {
        oe[he.filename] = ee[se];
        break;
      }
    }
    return oe;
  }, {});
  try {
    Y.exception.values.forEach((oe) => {
      oe.stacktrace.frames.forEach((se) => {
        se.filename && (se.debug_id = ie[se.filename]);
      });
    });
  } catch {
  }
}
function _z(Y) {
  const X = {};
  try {
    Y.exception.values.forEach((te) => {
      te.stacktrace.frames.forEach((ne) => {
        ne.debug_id && (ne.abs_path ? X[ne.abs_path] = ne.debug_id : ne.filename && (X[ne.filename] = ne.debug_id), delete ne.debug_id);
      });
    });
  } catch {
  }
  if (Object.keys(X).length === 0)
    return;
  Y.debug_meta = Y.debug_meta || {}, Y.debug_meta.images = Y.debug_meta.images || [];
  const ee = Y.debug_meta.images;
  Object.keys(X).forEach((te) => {
    ee.push({
      type: "sourcemap",
      code_file: te,
      debug_id: X[te]
    });
  });
}
function Az(Y, X) {
  X.length > 0 && (Y.sdk = Y.sdk || {}, Y.sdk.integrations = [...Y.sdk.integrations || [], ...X]);
}
function Sz(Y, X, ee) {
  if (!Y)
    return null;
  const te = {
    ...Y,
    ...Y.breadcrumbs && {
      breadcrumbs: Y.breadcrumbs.map((ne) => ({
        ...ne,
        ...ne.data && {
          data: ki(ne.data, X, ee)
        }
      }))
    },
    ...Y.user && {
      user: ki(Y.user, X, ee)
    },
    ...Y.contexts && {
      contexts: ki(Y.contexts, X, ee)
    },
    ...Y.extra && {
      extra: ki(Y.extra, X, ee)
    }
  };
  return Y.contexts && Y.contexts.trace && te.contexts && (te.contexts.trace = Y.contexts.trace, Y.contexts.trace.data && (te.contexts.trace.data = ki(Y.contexts.trace.data, X, ee))), Y.spans && (te.spans = Y.spans.map((ne) => {
    const ie = rn(ne).data;
    return ie && (ne.data = ki(ie, X, ee)), ne;
  })), te;
}
function Tz(Y, X) {
  if (!X)
    return Y;
  const ee = Y ? Y.clone() : new Ts();
  return ee.update(X), ee;
}
function Iz(Y) {
  if (Y)
    return Rz(Y) ? { captureContext: Y } : Pz(Y) ? {
      captureContext: Y
    } : Y;
}
function Rz(Y) {
  return Y instanceof Ts || typeof Y == "function";
}
const Cz = [
  "user",
  "level",
  "extra",
  "contexts",
  "tags",
  "fingerprint",
  "requestSession",
  "propagationContext"
];
function Pz(Y) {
  return Object.keys(Y).some((X) => Cz.includes(X));
}
function ab(Y, X) {
  return zn().captureException(Y, Iz(X));
}
function GS(Y, X) {
  return zn().captureEvent(Y, X);
}
function ho(Y, X) {
  zn().addBreadcrumb(Y, X);
}
function Oz(Y, X) {
  zn().setContext(Y, X);
}
function Bz(...Y) {
  const X = zn();
  if (Y.length === 2) {
    const [ee, te] = Y;
    return ee ? X.withScope(() => (X.getStackTop().scope = ee, te(ee))) : X.withScope(te);
  }
  return X.withScope(Y[0]);
}
function cr() {
  return zn().getClient();
}
function ai() {
  return zn().getScope();
}
function Iv(Y) {
  const X = cr(), ee = xo(), te = ai(), { release: ne, environment: ie = P0 } = X && X.getOptions() || {}, { userAgent: oe } = zt.navigator || {}, se = jS({
    release: ne,
    environment: ie,
    user: te.getUser() || ee.getUser(),
    ...oe && { userAgent: oe },
    ...Y
  }), ae = ee.getSession();
  return ae && ae.status === "ok" && Vo(ae, { status: "exited" }), VS(), ee.setSession(se), te.setSession(se), se;
}
function VS() {
  const Y = xo(), X = ai(), ee = X.getSession() || Y.getSession();
  ee && HS(ee), WS$1(), Y.setSession(), X.setSession();
}
function WS$1() {
  const Y = xo(), X = ai(), ee = cr(), te = X.getSession() || Y.getSession();
  te && ee && ee.captureSession && ee.captureSession(te);
}
function Rv(Y = !1) {
  if (Y) {
    VS();
    return;
  }
  WS$1();
}
function id$1(Y) {
  return Y.transaction;
}
function N0(Y, X, ee) {
  const te = X.getOptions(), { publicKey: ne } = X.getDsn() || {}, { segment: ie } = ee && ee.getUser() || {}, oe = xn({
    environment: te.environment || P0,
    release: te.release,
    user_segment: ie,
    public_key: ne,
    trace_id: Y
  });
  return X.emit && X.emit("createDsc", oe), oe;
}
function rc(Y) {
  const X = cr();
  if (!X)
    return {};
  const ee = N0(rn(Y).trace_id || "", X, ai()), te = id$1(Y);
  if (!te)
    return ee;
  const ne = te && te._frozenDynamicSamplingContext;
  if (ne)
    return ne;
  const { sampleRate: ie, source: oe } = te.metadata;
  ie != null && (ee.sample_rate = `${ie}`);
  const se = rn(te);
  return oe && oe !== "url" && (ee.transaction = se.description), ee.sampled = String(ob(te)), X.emit && X.emit("createDsc", ee), ee;
}
function KS(Y, X) {
  const { fingerprint: ee, span: te, breadcrumbs: ne, sdkProcessingMetadata: ie } = X;
  Nz(Y, X), te && Lz(Y, te), Fz(Y, ee), kz(Y, ne), Mz(Y, ie);
}
function Cv(Y, X) {
  const {
    extra: ee,
    tags: te,
    user: ne,
    contexts: ie,
    level: oe,
    sdkProcessingMetadata: se,
    breadcrumbs: ae,
    fingerprint: ue,
    eventProcessors: le,
    attachments: he,
    propagationContext: me,
    // eslint-disable-next-line deprecation/deprecation
    transactionName: ye,
    span: we
  } = X;
  tu(Y, "extra", ee), tu(Y, "tags", te), tu(Y, "user", ne), tu(Y, "contexts", ie), tu(Y, "sdkProcessingMetadata", se), oe && (Y.level = oe), ye && (Y.transactionName = ye), we && (Y.span = we), ae.length && (Y.breadcrumbs = [...Y.breadcrumbs, ...ae]), ue.length && (Y.fingerprint = [...Y.fingerprint, ...ue]), le.length && (Y.eventProcessors = [...Y.eventProcessors, ...le]), he.length && (Y.attachments = [...Y.attachments, ...he]), Y.propagationContext = { ...Y.propagationContext, ...me };
}
function tu(Y, X, ee) {
  if (ee && Object.keys(ee).length) {
    Y[X] = { ...Y[X] };
    for (const te in ee)
      Object.prototype.hasOwnProperty.call(ee, te) && (Y[X][te] = ee[te]);
  }
}
function Nz(Y, X) {
  const {
    extra: ee,
    tags: te,
    user: ne,
    contexts: ie,
    level: oe,
    // eslint-disable-next-line deprecation/deprecation
    transactionName: se
  } = X, ae = xn(ee);
  ae && Object.keys(ae).length && (Y.extra = { ...ae, ...Y.extra });
  const ue = xn(te);
  ue && Object.keys(ue).length && (Y.tags = { ...ue, ...Y.tags });
  const le = xn(ne);
  le && Object.keys(le).length && (Y.user = { ...le, ...Y.user });
  const he = xn(ie);
  he && Object.keys(he).length && (Y.contexts = { ...he, ...Y.contexts }), oe && (Y.level = oe), se && (Y.transaction = se);
}
function kz(Y, X) {
  const ee = [...Y.breadcrumbs || [], ...X];
  Y.breadcrumbs = ee.length ? ee : void 0;
}
function Mz(Y, X) {
  Y.sdkProcessingMetadata = {
    ...Y.sdkProcessingMetadata,
    ...X
  };
}
function Lz(Y, X) {
  Y.contexts = { trace: sb(X), ...Y.contexts };
  const ee = id$1(X);
  if (ee) {
    Y.sdkProcessingMetadata = {
      dynamicSamplingContext: rc(X),
      ...Y.sdkProcessingMetadata
    };
    const te = rn(ee).description;
    te && (Y.tags = { transaction: te, ...Y.tags });
  }
}
function Fz(Y, X) {
  Y.fingerprint = Y.fingerprint ? CS(Y.fingerprint) : [], X && (Y.fingerprint = Y.fingerprint.concat(X)), Y.fingerprint && !Y.fingerprint.length && delete Y.fingerprint;
}
const $z = 100;
let Ep;
class Ts {
  /** Flag if notifying is happening. */
  /** Callback for client to receive scope changes. */
  /** Callback list that will be called after {@link applyToEvent}. */
  /** Array of breadcrumbs. */
  /** User */
  /** Tags */
  /** Extra */
  /** Contexts */
  /** Attachments */
  /** Propagation Context for distributed tracing */
  /**
   * A place to stash data which is needed at some point in the SDK's event processing pipeline but which shouldn't get
   * sent to Sentry
   */
  /** Fingerprint */
  /** Severity */
  // eslint-disable-next-line deprecation/deprecation
  /**
   * Transaction Name
   */
  /** Span */
  /** Session */
  /** Request Mode Session Status */
  /** The client on this scope */
  // NOTE: Any field which gets added here should get added not only to the constructor but also to the `clone` method.
  constructor() {
    this._notifyingListeners = !1, this._scopeListeners = [], this._eventProcessors = [], this._breadcrumbs = [], this._attachments = [], this._user = {}, this._tags = {}, this._extra = {}, this._contexts = {}, this._sdkProcessingMetadata = {}, this._propagationContext = Pv();
  }
  /**
   * Inherit values from the parent scope.
   * @deprecated Use `scope.clone()` and `new Scope()` instead.
   */
  static clone(X) {
    return X ? X.clone() : new Ts();
  }
  /**
   * Clone this scope instance.
   */
  clone() {
    const X = new Ts();
    return X._breadcrumbs = [...this._breadcrumbs], X._tags = { ...this._tags }, X._extra = { ...this._extra }, X._contexts = { ...this._contexts }, X._user = this._user, X._level = this._level, X._span = this._span, X._session = this._session, X._transactionName = this._transactionName, X._fingerprint = this._fingerprint, X._eventProcessors = [...this._eventProcessors], X._requestSession = this._requestSession, X._attachments = [...this._attachments], X._sdkProcessingMetadata = { ...this._sdkProcessingMetadata }, X._propagationContext = { ...this._propagationContext }, X._client = this._client, X;
  }
  /** Update the client on the scope. */
  setClient(X) {
    this._client = X;
  }
  /**
   * Get the client assigned to this scope.
   *
   * It is generally recommended to use the global function `Sentry.getClient()` instead, unless you know what you are doing.
   */
  getClient() {
    return this._client;
  }
  /**
   * Add internal on change listener. Used for sub SDKs that need to store the scope.
   * @hidden
   */
  addScopeListener(X) {
    this._scopeListeners.push(X);
  }
  /**
   * @inheritDoc
   */
  addEventProcessor(X) {
    return this._eventProcessors.push(X), this;
  }
  /**
   * @inheritDoc
   */
  setUser(X) {
    return this._user = X || {
      email: void 0,
      id: void 0,
      ip_address: void 0,
      segment: void 0,
      username: void 0
    }, this._session && Vo(this._session, { user: X }), this._notifyScopeListeners(), this;
  }
  /**
   * @inheritDoc
   */
  getUser() {
    return this._user;
  }
  /**
   * @inheritDoc
   */
  getRequestSession() {
    return this._requestSession;
  }
  /**
   * @inheritDoc
   */
  setRequestSession(X) {
    return this._requestSession = X, this;
  }
  /**
   * @inheritDoc
   */
  setTags(X) {
    return this._tags = {
      ...this._tags,
      ...X
    }, this._notifyScopeListeners(), this;
  }
  /**
   * @inheritDoc
   */
  setTag(X, ee) {
    return this._tags = { ...this._tags, [X]: ee }, this._notifyScopeListeners(), this;
  }
  /**
   * @inheritDoc
   */
  setExtras(X) {
    return this._extra = {
      ...this._extra,
      ...X
    }, this._notifyScopeListeners(), this;
  }
  /**
   * @inheritDoc
   */
  setExtra(X, ee) {
    return this._extra = { ...this._extra, [X]: ee }, this._notifyScopeListeners(), this;
  }
  /**
   * @inheritDoc
   */
  setFingerprint(X) {
    return this._fingerprint = X, this._notifyScopeListeners(), this;
  }
  /**
   * @inheritDoc
   */
  setLevel(X) {
    return this._level = X, this._notifyScopeListeners(), this;
  }
  /**
   * Sets the transaction name on the scope for future events.
   * @deprecated Use extra or tags instead.
   */
  setTransactionName(X) {
    return this._transactionName = X, this._notifyScopeListeners(), this;
  }
  /**
   * @inheritDoc
   */
  setContext(X, ee) {
    return ee === null ? delete this._contexts[X] : this._contexts[X] = ee, this._notifyScopeListeners(), this;
  }
  /**
   * Sets the Span on the scope.
   * @param span Span
   * @deprecated Instead of setting a span on a scope, use `startSpan()`/`startSpanManual()` instead.
   */
  setSpan(X) {
    return this._span = X, this._notifyScopeListeners(), this;
  }
  /**
   * Returns the `Span` if there is one.
   * @deprecated Use `getActiveSpan()` instead.
   */
  getSpan() {
    return this._span;
  }
  /**
   * Returns the `Transaction` attached to the scope (if there is one).
   * @deprecated You should not rely on the transaction, but just use `startSpan()` APIs instead.
   */
  getTransaction() {
    const X = this._span;
    return X && X.transaction;
  }
  /**
   * @inheritDoc
   */
  setSession(X) {
    return X ? this._session = X : delete this._session, this._notifyScopeListeners(), this;
  }
  /**
   * @inheritDoc
   */
  getSession() {
    return this._session;
  }
  /**
   * @inheritDoc
   */
  update(X) {
    if (!X)
      return this;
    const ee = typeof X == "function" ? X(this) : X;
    if (ee instanceof Ts) {
      const te = ee.getScopeData();
      this._tags = { ...this._tags, ...te.tags }, this._extra = { ...this._extra, ...te.extra }, this._contexts = { ...this._contexts, ...te.contexts }, te.user && Object.keys(te.user).length && (this._user = te.user), te.level && (this._level = te.level), te.fingerprint.length && (this._fingerprint = te.fingerprint), ee.getRequestSession() && (this._requestSession = ee.getRequestSession()), te.propagationContext && (this._propagationContext = te.propagationContext);
    } else if (ec$2(ee)) {
      const te = X;
      this._tags = { ...this._tags, ...te.tags }, this._extra = { ...this._extra, ...te.extra }, this._contexts = { ...this._contexts, ...te.contexts }, te.user && (this._user = te.user), te.level && (this._level = te.level), te.fingerprint && (this._fingerprint = te.fingerprint), te.requestSession && (this._requestSession = te.requestSession), te.propagationContext && (this._propagationContext = te.propagationContext);
    }
    return this;
  }
  /**
   * @inheritDoc
   */
  clear() {
    return this._breadcrumbs = [], this._tags = {}, this._extra = {}, this._user = {}, this._contexts = {}, this._level = void 0, this._transactionName = void 0, this._fingerprint = void 0, this._requestSession = void 0, this._span = void 0, this._session = void 0, this._notifyScopeListeners(), this._attachments = [], this._propagationContext = Pv(), this;
  }
  /**
   * @inheritDoc
   */
  addBreadcrumb(X, ee) {
    const te = typeof ee == "number" ? ee : $z;
    if (te <= 0)
      return this;
    const ne = {
      timestamp: Of(),
      ...X
    }, ie = this._breadcrumbs;
    return ie.push(ne), this._breadcrumbs = ie.length > te ? ie.slice(-te) : ie, this._notifyScopeListeners(), this;
  }
  /**
   * @inheritDoc
   */
  getLastBreadcrumb() {
    return this._breadcrumbs[this._breadcrumbs.length - 1];
  }
  /**
   * @inheritDoc
   */
  clearBreadcrumbs() {
    return this._breadcrumbs = [], this._notifyScopeListeners(), this;
  }
  /**
   * @inheritDoc
   */
  addAttachment(X) {
    return this._attachments.push(X), this;
  }
  /**
   * @inheritDoc
   * @deprecated Use `getScopeData()` instead.
   */
  getAttachments() {
    return this.getScopeData().attachments;
  }
  /**
   * @inheritDoc
   */
  clearAttachments() {
    return this._attachments = [], this;
  }
  /** @inheritDoc */
  getScopeData() {
    const {
      _breadcrumbs: X,
      _attachments: ee,
      _contexts: te,
      _tags: ne,
      _extra: ie,
      _user: oe,
      _level: se,
      _fingerprint: ae,
      _eventProcessors: ue,
      _propagationContext: le,
      _sdkProcessingMetadata: he,
      _transactionName: me,
      _span: ye
    } = this;
    return {
      breadcrumbs: X,
      attachments: ee,
      contexts: te,
      tags: ne,
      extra: ie,
      user: oe,
      level: se,
      fingerprint: ae || [],
      eventProcessors: ue,
      propagationContext: le,
      sdkProcessingMetadata: he,
      transactionName: me,
      span: ye
    };
  }
  /**
   * Applies data from the scope to the event and runs all event processors on it.
   *
   * @param event Event
   * @param hint Object containing additional information about the original exception, for use by the event processors.
   * @hidden
   * @deprecated Use `applyScopeDataToEvent()` directly
   */
  applyToEvent(X, ee = {}, te = []) {
    KS(X, this.getScopeData());
    const ne = [
      ...te,
      // eslint-disable-next-line deprecation/deprecation
      ...ib(),
      ...this._eventProcessors
    ];
    return nd(ne, X, ee);
  }
  /**
   * Add data which will be accessible during event processing but won't get sent to Sentry
   */
  setSDKProcessingMetadata(X) {
    return this._sdkProcessingMetadata = { ...this._sdkProcessingMetadata, ...X }, this;
  }
  /**
   * @inheritDoc
   */
  setPropagationContext(X) {
    return this._propagationContext = X, this;
  }
  /**
   * @inheritDoc
   */
  getPropagationContext() {
    return this._propagationContext;
  }
  /**
   * Capture an exception for this scope.
   *
   * @param exception The exception to capture.
   * @param hint Optinal additional data to attach to the Sentry event.
   * @returns the id of the captured Sentry event.
   */
  captureException(X, ee) {
    const te = ee && ee.event_id ? ee.event_id : Tr();
    if (!this._client)
      return xe.warn("No client configured on scope - will not capture exception!"), te;
    const ne = new Error("Sentry syntheticException");
    return this._client.captureException(
      X,
      {
        originalException: X,
        syntheticException: ne,
        ...ee,
        event_id: te
      },
      this
    ), te;
  }
  /**
   * Capture a message for this scope.
   *
   * @param message The message to capture.
   * @param level An optional severity level to report the message with.
   * @param hint Optional additional data to attach to the Sentry event.
   * @returns the id of the captured message.
   */
  captureMessage(X, ee, te) {
    const ne = te && te.event_id ? te.event_id : Tr();
    if (!this._client)
      return xe.warn("No client configured on scope - will not capture message!"), ne;
    const ie = new Error(X);
    return this._client.captureMessage(
      X,
      ee,
      {
        originalException: X,
        syntheticException: ie,
        ...te,
        event_id: ne
      },
      this
    ), ne;
  }
  /**
   * Captures a manually created event for this scope and sends it to Sentry.
   *
   * @param exception The event to capture.
   * @param hint Optional additional data to attach to the Sentry event.
   * @returns the id of the captured event.
   */
  captureEvent(X, ee) {
    const te = ee && ee.event_id ? ee.event_id : Tr();
    return this._client ? (this._client.captureEvent(X, { ...ee, event_id: te }, this), te) : (xe.warn("No client configured on scope - will not capture event!"), te);
  }
  /**
   * This will be called on every set call.
   */
  _notifyScopeListeners() {
    this._notifyingListeners || (this._notifyingListeners = !0, this._scopeListeners.forEach((X) => {
      X(this);
    }), this._notifyingListeners = !1);
  }
}
function Dz() {
  return Ep || (Ep = new Ts()), Ep;
}
function Pv() {
  return {
    traceId: Tr(),
    spanId: Tr().substring(16)
  };
}
const $g = "7.104.0", JS = parseFloat($g), Uz = 100;
class YS {
  /** Is a {@link Layer}[] containing the client and scope */
  /** Contains the last event id of a captured event.  */
  /**
   * Creates a new instance of the hub, will push one {@link Layer} into the
   * internal stack on creation.
   *
   * @param client bound to the hub.
   * @param scope bound to the hub.
   * @param version number, higher number means higher priority.
   *
   * @deprecated Instantiation of Hub objects is deprecated and the constructor will be removed in version 8 of the SDK.
   *
   * If you are currently using the Hub for multi-client use like so:
   *
   * ```
   * // OLD
   * const hub = new Hub();
   * hub.bindClient(client);
   * makeMain(hub)
   * ```
   *
   * instead initialize the client as follows:
   *
   * ```
   * // NEW
   * Sentry.withIsolationScope(() => {
   *    Sentry.setCurrentClient(client);
   *    client.init();
   * });
   * ```
   *
   * If you are using the Hub to capture events like so:
   *
   * ```
   * // OLD
   * const client = new Client();
   * const hub = new Hub(client);
   * hub.captureException()
   * ```
   *
   * instead capture isolated events as follows:
   *
   * ```
   * // NEW
   * const client = new Client();
   * const scope = new Scope();
   * scope.setClient(client);
   * scope.captureException();
   * ```
   */
  constructor(X, ee, te, ne = JS) {
    this._version = ne;
    let ie;
    ee ? ie = ee : (ie = new Ts(), ie.setClient(X));
    let oe;
    te ? oe = te : (oe = new Ts(), oe.setClient(X)), this._stack = [{ scope: ie }], X && this.bindClient(X), this._isolationScope = oe;
  }
  /**
   * Checks if this hub's version is older than the given version.
   *
   * @param version A version number to compare to.
   * @return True if the given version is newer; otherwise false.
   *
   * @deprecated This will be removed in v8.
   */
  isOlderThan(X) {
    return this._version < X;
  }
  /**
   * This binds the given client to the current scope.
   * @param client An SDK client (client) instance.
   *
   * @deprecated Use `initAndBind()` directly, or `setCurrentClient()` and/or `client.init()` instead.
   */
  bindClient(X) {
    const ee = this.getStackTop();
    ee.client = X, ee.scope.setClient(X), X && X.setupIntegrations && X.setupIntegrations();
  }
  /**
   * @inheritDoc
   *
   * @deprecated Use `withScope` instead.
   */
  pushScope() {
    const X = this.getScope().clone();
    return this.getStack().push({
      // eslint-disable-next-line deprecation/deprecation
      client: this.getClient(),
      scope: X
    }), X;
  }
  /**
   * @inheritDoc
   *
   * @deprecated Use `withScope` instead.
   */
  popScope() {
    return this.getStack().length <= 1 ? !1 : !!this.getStack().pop();
  }
  /**
   * @inheritDoc
   *
   * @deprecated Use `Sentry.withScope()` instead.
   */
  withScope(X) {
    const ee = this.pushScope();
    let te;
    try {
      te = X(ee);
    } catch (ne) {
      throw this.popScope(), ne;
    }
    return R0(te) ? te.then(
      (ne) => (this.popScope(), ne),
      (ne) => {
        throw this.popScope(), ne;
      }
    ) : (this.popScope(), te);
  }
  /**
   * @inheritDoc
   *
   * @deprecated Use `Sentry.getClient()` instead.
   */
  getClient() {
    return this.getStackTop().client;
  }
  /**
   * Returns the scope of the top stack.
   *
   * @deprecated Use `Sentry.getCurrentScope()` instead.
   */
  getScope() {
    return this.getStackTop().scope;
  }
  /**
   * @deprecated Use `Sentry.getIsolationScope()` instead.
   */
  getIsolationScope() {
    return this._isolationScope;
  }
  /**
   * Returns the scope stack for domains or the process.
   * @deprecated This will be removed in v8.
   */
  getStack() {
    return this._stack;
  }
  /**
   * Returns the topmost scope layer in the order domain > local > process.
   * @deprecated This will be removed in v8.
   */
  getStackTop() {
    return this._stack[this._stack.length - 1];
  }
  /**
   * @inheritDoc
   *
   * @deprecated Use `Sentry.captureException()` instead.
   */
  captureException(X, ee) {
    const te = this._lastEventId = ee && ee.event_id ? ee.event_id : Tr(), ne = new Error("Sentry syntheticException");
    return this.getScope().captureException(X, {
      originalException: X,
      syntheticException: ne,
      ...ee,
      event_id: te
    }), te;
  }
  /**
   * @inheritDoc
   *
   * @deprecated Use  `Sentry.captureMessage()` instead.
   */
  captureMessage(X, ee, te) {
    const ne = this._lastEventId = te && te.event_id ? te.event_id : Tr(), ie = new Error(X);
    return this.getScope().captureMessage(X, ee, {
      originalException: X,
      syntheticException: ie,
      ...te,
      event_id: ne
    }), ne;
  }
  /**
   * @inheritDoc
   *
   * @deprecated Use `Sentry.captureEvent()` instead.
   */
  captureEvent(X, ee) {
    const te = ee && ee.event_id ? ee.event_id : Tr();
    return X.type || (this._lastEventId = te), this.getScope().captureEvent(X, { ...ee, event_id: te }), te;
  }
  /**
   * @inheritDoc
   *
   * @deprecated This will be removed in v8.
   */
  lastEventId() {
    return this._lastEventId;
  }
  /**
   * @inheritDoc
   *
   * @deprecated Use `Sentry.addBreadcrumb()` instead.
   */
  addBreadcrumb(X, ee) {
    const { scope: te, client: ne } = this.getStackTop();
    if (!ne)
      return;
    const { beforeBreadcrumb: ie = null, maxBreadcrumbs: oe = Uz } = ne.getOptions && ne.getOptions() || {};
    if (oe <= 0)
      return;
    const se = { timestamp: Of(), ...X }, ae = ie ? qo(() => ie(se, ee)) : se;
    ae !== null && (ne.emit && ne.emit("beforeAddBreadcrumb", ae, ee), te.addBreadcrumb(ae, oe));
  }
  /**
   * @inheritDoc
   * @deprecated Use `Sentry.setUser()` instead.
   */
  setUser(X) {
    this.getScope().setUser(X), this.getIsolationScope().setUser(X);
  }
  /**
   * @inheritDoc
   * @deprecated Use `Sentry.setTags()` instead.
   */
  setTags(X) {
    this.getScope().setTags(X), this.getIsolationScope().setTags(X);
  }
  /**
   * @inheritDoc
   * @deprecated Use `Sentry.setExtras()` instead.
   */
  setExtras(X) {
    this.getScope().setExtras(X), this.getIsolationScope().setExtras(X);
  }
  /**
   * @inheritDoc
   * @deprecated Use `Sentry.setTag()` instead.
   */
  setTag(X, ee) {
    this.getScope().setTag(X, ee), this.getIsolationScope().setTag(X, ee);
  }
  /**
   * @inheritDoc
   * @deprecated Use `Sentry.setExtra()` instead.
   */
  setExtra(X, ee) {
    this.getScope().setExtra(X, ee), this.getIsolationScope().setExtra(X, ee);
  }
  /**
   * @inheritDoc
   * @deprecated Use `Sentry.setContext()` instead.
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  setContext(X, ee) {
    this.getScope().setContext(X, ee), this.getIsolationScope().setContext(X, ee);
  }
  /**
   * @inheritDoc
   *
   * @deprecated Use `getScope()` directly.
   */
  configureScope(X) {
    const { scope: ee, client: te } = this.getStackTop();
    te && X(ee);
  }
  /**
   * @inheritDoc
   */
  run(X) {
    const ee = Ov(this);
    try {
      X(this);
    } finally {
      Ov(ee);
    }
  }
  /**
   * @inheritDoc
   * @deprecated Use `Sentry.getClient().getIntegrationByName()` instead.
   */
  getIntegration(X) {
    const ee = this.getClient();
    if (!ee)
      return null;
    try {
      return ee.getIntegration(X);
    } catch {
      return et && xe.warn(`Cannot retrieve integration ${X.id} from the current Hub`), null;
    }
  }
  /**
   * Starts a new `Transaction` and returns it. This is the entry point to manual tracing instrumentation.
   *
   * A tree structure can be built by adding child spans to the transaction, and child spans to other spans. To start a
   * new child span within the transaction or any span, call the respective `.startChild()` method.
   *
   * Every child span must be finished before the transaction is finished, otherwise the unfinished spans are discarded.
   *
   * The transaction must be finished with a call to its `.end()` method, at which point the transaction with all its
   * finished child spans will be sent to Sentry.
   *
   * @param context Properties of the new `Transaction`.
   * @param customSamplingContext Information given to the transaction sampling function (along with context-dependent
   * default values). See {@link Options.tracesSampler}.
   *
   * @returns The transaction which was just started
   *
   * @deprecated Use `startSpan()`, `startSpanManual()` or `startInactiveSpan()` instead.
   */
  startTransaction(X, ee) {
    const te = this._callExtensionMethod("startTransaction", X, ee);
    return et && !te && (this.getClient() ? xe.warn(`Tracing extension 'startTransaction' has not been added. Call 'addTracingExtensions' before calling 'init':
Sentry.addTracingExtensions();
Sentry.init({...});
`) : xe.warn(
      "Tracing extension 'startTransaction' is missing. You should 'init' the SDK before calling 'startTransaction'"
    )), te;
  }
  /**
   * @inheritDoc
   * @deprecated Use `spanToTraceHeader()` instead.
   */
  traceHeaders() {
    return this._callExtensionMethod("traceHeaders");
  }
  /**
   * @inheritDoc
   *
   * @deprecated Use top level `captureSession` instead.
   */
  captureSession(X = !1) {
    if (X)
      return this.endSession();
    this._sendSessionUpdate();
  }
  /**
   * @inheritDoc
   * @deprecated Use top level `endSession` instead.
   */
  endSession() {
    const X = this.getStackTop().scope, ee = X.getSession();
    ee && HS(ee), this._sendSessionUpdate(), X.setSession();
  }
  /**
   * @inheritDoc
   * @deprecated Use top level `startSession` instead.
   */
  startSession(X) {
    const { scope: ee, client: te } = this.getStackTop(), { release: ne, environment: ie = P0 } = te && te.getOptions() || {}, { userAgent: oe } = zt.navigator || {}, se = jS({
      release: ne,
      environment: ie,
      user: ee.getUser(),
      ...oe && { userAgent: oe },
      ...X
    }), ae = ee.getSession && ee.getSession();
    return ae && ae.status === "ok" && Vo(ae, { status: "exited" }), this.endSession(), ee.setSession(se), se;
  }
  /**
   * Returns if default PII should be sent to Sentry and propagated in ourgoing requests
   * when Tracing is used.
   *
   * @deprecated Use top-level `getClient().getOptions().sendDefaultPii` instead. This function
   * only unnecessarily increased API surface but only wrapped accessing the option.
   */
  shouldSendDefaultPii() {
    const X = this.getClient(), ee = X && X.getOptions();
    return !!(ee && ee.sendDefaultPii);
  }
  /**
   * Sends the current Session on the scope
   */
  _sendSessionUpdate() {
    const { scope: X, client: ee } = this.getStackTop(), te = X.getSession();
    te && ee && ee.captureSession && ee.captureSession(te);
  }
  /**
   * Calls global extension method and binding current instance to the function call
   */
  // @ts-expect-error Function lacks ending return statement and return type does not include 'undefined'. ts(2366)
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  _callExtensionMethod(X, ...ee) {
    const te = Nf().__SENTRY__;
    if (te && te.extensions && typeof te.extensions[X] == "function")
      return te.extensions[X].apply(this, ee);
    et && xe.warn(`Extension method ${X} couldn't be found, doing nothing.`);
  }
}
function Nf() {
  return zt.__SENTRY__ = zt.__SENTRY__ || {
    extensions: {},
    hub: void 0
  }, zt;
}
function Ov(Y) {
  const X = Nf(), ee = Dg(X);
  return XS(X, Y), ee;
}
function zn() {
  const Y = Nf();
  if (Y.__SENTRY__ && Y.__SENTRY__.acs) {
    const X = Y.__SENTRY__.acs.getCurrentHub();
    if (X)
      return X;
  }
  return jz(Y);
}
function xo() {
  return zn().getIsolationScope();
}
function jz(Y = Nf()) {
  return (!Hz(Y) || // eslint-disable-next-line deprecation/deprecation
  Dg(Y).isOlderThan(JS)) && XS(Y, new YS()), Dg(Y);
}
function Hz(Y) {
  return !!(Y && Y.__SENTRY__ && Y.__SENTRY__.hub);
}
function Dg(Y) {
  return vS("hub", () => new YS(), Y);
}
function XS(Y, X) {
  if (!Y)
    return !1;
  const ee = Y.__SENTRY__ = Y.__SENTRY__ || {};
  return ee.hub = X, !0;
}
function Mc(Y) {
  return (Y || zn()).getScope().getTransaction();
}
let Bv = !1;
function zz() {
  Bv || (Bv = !0, BS(Ug), NS(Ug));
}
function Ug() {
  const Y = Mc();
  if (Y) {
    const X = "internal_error";
    et && xe.log(`[Tracing] Transaction: ${X} -> Global error occured`), Y.setStatus(X);
  }
}
Ug.tag = "sentry_tracingErrorCallback";
var Nv;
(function(Y) {
  const X = "ok";
  Y.Ok = X;
  const ee = "deadline_exceeded";
  Y.DeadlineExceeded = ee;
  const te = "unauthenticated";
  Y.Unauthenticated = te;
  const ne = "permission_denied";
  Y.PermissionDenied = ne;
  const ie = "not_found";
  Y.NotFound = ie;
  const oe = "resource_exhausted";
  Y.ResourceExhausted = oe;
  const se = "invalid_argument";
  Y.InvalidArgument = se;
  const ae = "unimplemented";
  Y.Unimplemented = ae;
  const ue = "unavailable";
  Y.Unavailable = ue;
  const le = "internal_error";
  Y.InternalError = le;
  const he = "unknown_error";
  Y.UnknownError = he;
  const me = "cancelled";
  Y.Cancelled = me;
  const ye = "already_exists";
  Y.AlreadyExists = ye;
  const we = "failed_precondition";
  Y.FailedPrecondition = we;
  const Ee = "aborted";
  Y.Aborted = Ee;
  const Re = "out_of_range";
  Y.OutOfRange = Re;
  const Ue = "data_loss";
  Y.DataLoss = Ue;
})(Nv || (Nv = {}));
function qz(Y) {
  if (Y < 400 && Y >= 100)
    return "ok";
  if (Y >= 400 && Y < 500)
    switch (Y) {
      case 401:
        return "unauthenticated";
      case 403:
        return "permission_denied";
      case 404:
        return "not_found";
      case 409:
        return "already_exists";
      case 413:
        return "failed_precondition";
      case 429:
        return "resource_exhausted";
      default:
        return "invalid_argument";
    }
  if (Y >= 500 && Y < 600)
    switch (Y) {
      case 501:
        return "unimplemented";
      case 503:
        return "unavailable";
      case 504:
        return "deadline_exceeded";
      default:
        return "internal_error";
    }
  return "unknown_error";
}
function cb(Y, X) {
  Y.setTag("http.status_code", String(X)), Y.setData("http.response.status_code", X);
  const ee = qz(X);
  ee !== "unknown_error" && Y.setStatus(ee);
}
function kf(Y) {
  if (typeof __SENTRY_TRACING__ == "boolean" && !__SENTRY_TRACING__)
    return !1;
  const X = cr(), ee = Y || X && X.getOptions();
  return !!ee && (ee.enableTracing || "tracesSampleRate" in ee || "tracesSampler" in ee);
}
function ZS(Y) {
  if (!kf())
    return;
  const X = Wz(Y), ee = zn(), te = Y.scope ? (
    // eslint-disable-next-line deprecation/deprecation
    Y.scope.getSpan()
  ) : Gz();
  if (Y.onlyIfParent && !te)
    return;
  const ne = (Y.scope || ai()).clone();
  return Vz(ee, {
    parentSpan: te,
    spanContext: X,
    forceTransaction: Y.forceTransaction,
    scope: ne
  });
}
function Gz() {
  return ai().getSpan();
}
function Vz(Y, {
  parentSpan: X,
  spanContext: ee,
  forceTransaction: te,
  scope: ne
}) {
  if (!kf())
    return;
  const ie = xo();
  let oe;
  if (X && !te)
    oe = X.startChild(ee);
  else if (X) {
    const se = rc(X), { traceId: ae, spanId: ue } = X.spanContext(), le = ob(X);
    oe = Y.startTransaction({
      traceId: ae,
      parentSpanId: ue,
      parentSampled: le,
      ...ee,
      metadata: {
        dynamicSamplingContext: se,
        // eslint-disable-next-line deprecation/deprecation
        ...ee.metadata
      }
    });
  } else {
    const { traceId: se, dsc: ae, parentSpanId: ue, sampled: le } = {
      ...ie.getPropagationContext(),
      ...ne.getPropagationContext()
    };
    oe = Y.startTransaction({
      traceId: se,
      parentSpanId: ue,
      parentSampled: le,
      ...ee,
      metadata: {
        dynamicSamplingContext: ae,
        // eslint-disable-next-line deprecation/deprecation
        ...ee.metadata
      }
    });
  }
  return ne.setSpan(oe), Kz(oe, ne, ie), oe;
}
function Wz(Y) {
  if (Y.startTime) {
    const X = { ...Y };
    return X.startTimestamp = B0(Y.startTime), delete X.startTime, X;
  }
  return Y;
}
const QS = "_sentryScope", e5 = "_sentryIsolationScope";
function Kz(Y, X, ee) {
  Y && (Go(Y, e5, ee), Go(Y, QS, X));
}
function Jz(Y) {
  return {
    scope: Y[QS],
    isolationScope: Y[e5]
  };
}
const Po = "sentry.source", wa = "sentry.sample_rate", al = "sentry.op", va = "sentry.origin", Yz = "profile_id";
class t5 {
  constructor(X = 1e3) {
    this._maxlen = X, this.spans = [];
  }
  /**
   * This is just so that we don't run out of memory while recording a lot
   * of spans. At some point we just stop and flush out the start of the
   * trace tree (i.e.the first n spans with the smallest
   * start_timestamp).
   */
  add(X) {
    this.spans.length > this._maxlen ? X.spanRecorder = void 0 : this.spans.push(X);
  }
}
class ub {
  /**
   * Tags for the span.
   * @deprecated Use `spanToJSON(span).atttributes` instead.
   */
  /**
   * Data for the span.
   * @deprecated Use `spanToJSON(span).atttributes` instead.
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  /**
   * List of spans that were finalized
   *
   * @deprecated This property will no longer be public. Span recording will be handled internally.
   */
  /**
   * @inheritDoc
   * @deprecated Use top level `Sentry.getRootSpan()` instead
   */
  /**
   * The instrumenter that created this span.
   *
   * TODO (v8): This can probably be replaced by an `instanceOf` check of the span class.
   *            the instrumenter can only be sentry or otel so we can check the span instance
   *            to verify which one it is and remove this field entirely.
   *
   * @deprecated This field will be removed.
   */
  /** Epoch timestamp in seconds when the span started. */
  /** Epoch timestamp in seconds when the span ended. */
  /** Internal keeper of the status */
  /**
   * You should never call the constructor manually, always use `Sentry.startTransaction()`
   * or call `startChild()` on an existing span.
   * @internal
   * @hideconstructor
   * @hidden
   */
  constructor(X = {}) {
    this._traceId = X.traceId || Tr(), this._spanId = X.spanId || Tr().substring(16), this._startTime = X.startTimestamp || Bf(), this.tags = X.tags ? { ...X.tags } : {}, this.data = X.data ? { ...X.data } : {}, this.instrumenter = X.instrumenter || "sentry", this._attributes = {}, this.setAttributes({
      [va]: X.origin || "manual",
      [al]: X.op,
      ...X.attributes
    }), this._name = X.name || X.description, X.parentSpanId && (this._parentSpanId = X.parentSpanId), "sampled" in X && (this._sampled = X.sampled), X.status && (this._status = X.status), X.endTimestamp && (this._endTime = X.endTimestamp), X.exclusiveTime && (this._exclusiveTime = X.exclusiveTime), this._measurements = X.measurements ? { ...X.measurements } : {};
  }
  // This rule conflicts with another eslint rule :(
  /* eslint-disable @typescript-eslint/member-ordering */
  /**
   * An alias for `description` of the Span.
   * @deprecated Use `spanToJSON(span).description` instead.
   */
  get name() {
    return this._name || "";
  }
  /**
   * Update the name of the span.
   * @deprecated Use `spanToJSON(span).description` instead.
   */
  set name(X) {
    this.updateName(X);
  }
  /**
   * Get the description of the Span.
   * @deprecated Use `spanToJSON(span).description` instead.
   */
  get description() {
    return this._name;
  }
  /**
   * Get the description of the Span.
   * @deprecated Use `spanToJSON(span).description` instead.
   */
  set description(X) {
    this._name = X;
  }
  /**
   * The ID of the trace.
   * @deprecated Use `spanContext().traceId` instead.
   */
  get traceId() {
    return this._traceId;
  }
  /**
   * The ID of the trace.
   * @deprecated You cannot update the traceId of a span after span creation.
   */
  set traceId(X) {
    this._traceId = X;
  }
  /**
   * The ID of the span.
   * @deprecated Use `spanContext().spanId` instead.
   */
  get spanId() {
    return this._spanId;
  }
  /**
   * The ID of the span.
   * @deprecated You cannot update the spanId of a span after span creation.
   */
  set spanId(X) {
    this._spanId = X;
  }
  /**
   * @inheritDoc
   *
   * @deprecated Use `startSpan` functions instead.
   */
  set parentSpanId(X) {
    this._parentSpanId = X;
  }
  /**
   * @inheritDoc
   *
   * @deprecated Use `spanToJSON(span).parent_span_id` instead.
   */
  get parentSpanId() {
    return this._parentSpanId;
  }
  /**
   * Was this span chosen to be sent as part of the sample?
   * @deprecated Use `isRecording()` instead.
   */
  get sampled() {
    return this._sampled;
  }
  /**
   * Was this span chosen to be sent as part of the sample?
   * @deprecated You cannot update the sampling decision of a span after span creation.
   */
  set sampled(X) {
    this._sampled = X;
  }
  /**
   * Attributes for the span.
   * @deprecated Use `spanToJSON(span).atttributes` instead.
   */
  get attributes() {
    return this._attributes;
  }
  /**
   * Attributes for the span.
   * @deprecated Use `setAttributes()` instead.
   */
  set attributes(X) {
    this._attributes = X;
  }
  /**
   * Timestamp in seconds (epoch time) indicating when the span started.
   * @deprecated Use `spanToJSON()` instead.
   */
  get startTimestamp() {
    return this._startTime;
  }
  /**
   * Timestamp in seconds (epoch time) indicating when the span started.
   * @deprecated In v8, you will not be able to update the span start time after creation.
   */
  set startTimestamp(X) {
    this._startTime = X;
  }
  /**
   * Timestamp in seconds when the span ended.
   * @deprecated Use `spanToJSON()` instead.
   */
  get endTimestamp() {
    return this._endTime;
  }
  /**
   * Timestamp in seconds when the span ended.
   * @deprecated Set the end time via `span.end()` instead.
   */
  set endTimestamp(X) {
    this._endTime = X;
  }
  /**
   * The status of the span.
   *
   * @deprecated Use `spanToJSON().status` instead to get the status.
   */
  get status() {
    return this._status;
  }
  /**
   * The status of the span.
   *
   * @deprecated Use `.setStatus()` instead to set or update the status.
   */
  set status(X) {
    this._status = X;
  }
  /**
   * Operation of the span
   *
   * @deprecated Use `spanToJSON().op` to read the op instead.
   */
  get op() {
    return this._attributes[al];
  }
  /**
   * Operation of the span
   *
   * @deprecated Use `startSpan()` functions to set or `span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_OP, 'op')
   *             to update the span instead.
   */
  set op(X) {
    this.setAttribute(al, X);
  }
  /**
   * The origin of the span, giving context about what created the span.
   *
   * @deprecated Use `spanToJSON().origin` to read the origin instead.
   */
  get origin() {
    return this._attributes[va];
  }
  /**
   * The origin of the span, giving context about what created the span.
   *
   * @deprecated Use `startSpan()` functions to set the origin instead.
   */
  set origin(X) {
    this.setAttribute(va, X);
  }
  /* eslint-enable @typescript-eslint/member-ordering */
  /** @inheritdoc */
  spanContext() {
    const { _spanId: X, _traceId: ee, _sampled: te } = this;
    return {
      spanId: X,
      traceId: ee,
      traceFlags: te ? zS : xz
    };
  }
  /**
   * Creates a new `Span` while setting the current `Span.id` as `parentSpanId`.
   * Also the `sampled` decision will be inherited.
   *
   * @deprecated Use `startSpan()`, `startSpanManual()` or `startInactiveSpan()` instead.
   */
  startChild(X) {
    const ee = new ub({
      ...X,
      parentSpanId: this._spanId,
      sampled: this._sampled,
      traceId: this._traceId
    });
    ee.spanRecorder = this.spanRecorder, ee.spanRecorder && ee.spanRecorder.add(ee);
    const te = id$1(this);
    if (ee.transaction = te, et && te) {
      const ne = X && X.op || "< unknown op >", ie = rn(ee).description || "< unknown name >", oe = te.spanContext().spanId, se = `[Tracing] Starting '${ne}' span on transaction '${ie}' (${oe}).`;
      xe.log(se), this._logMessage = se;
    }
    return ee;
  }
  /**
   * Sets the tag attribute on the current span.
   *
   * Can also be used to unset a tag, by passing `undefined`.
   *
   * @param key Tag key
   * @param value Tag value
   * @deprecated Use `setAttribute()` instead.
   */
  setTag(X, ee) {
    return this.tags = { ...this.tags, [X]: ee }, this;
  }
  /**
   * Sets the data attribute on the current span
   * @param key Data key
   * @param value Data value
   * @deprecated Use `setAttribute()` instead.
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  setData(X, ee) {
    return this.data = { ...this.data, [X]: ee }, this;
  }
  /** @inheritdoc */
  setAttribute(X, ee) {
    ee === void 0 ? delete this._attributes[X] : this._attributes[X] = ee;
  }
  /** @inheritdoc */
  setAttributes(X) {
    Object.keys(X).forEach((ee) => this.setAttribute(ee, X[ee]));
  }
  /**
   * @inheritDoc
   */
  setStatus(X) {
    return this._status = X, this;
  }
  /**
   * @inheritDoc
   * @deprecated Use top-level `setHttpStatus()` instead.
   */
  setHttpStatus(X) {
    return cb(this, X), this;
  }
  /**
   * @inheritdoc
   *
   * @deprecated Use `.updateName()` instead.
   */
  setName(X) {
    this.updateName(X);
  }
  /**
   * @inheritDoc
   */
  updateName(X) {
    return this._name = X, this;
  }
  /**
   * @inheritDoc
   *
   * @deprecated Use `spanToJSON(span).status === 'ok'` instead.
   */
  isSuccess() {
    return this._status === "ok";
  }
  /**
   * @inheritDoc
   *
   * @deprecated Use `.end()` instead.
   */
  finish(X) {
    return this.end(X);
  }
  /** @inheritdoc */
  end(X) {
    if (this._endTime)
      return;
    const ee = id$1(this);
    if (et && // Don't call this for transactions
    ee && ee.spanContext().spanId !== this._spanId) {
      const te = this._logMessage;
      te && xe.log(te.replace("Starting", "Finishing"));
    }
    this._endTime = B0(X);
  }
  /**
   * @inheritDoc
   *
   * @deprecated Use `spanToTraceHeader()` instead.
   */
  toTraceparent() {
    return O0(this);
  }
  /**
   * @inheritDoc
   *
   * @deprecated Use `spanToJSON()` or access the fields directly instead.
   */
  toContext() {
    return xn({
      data: this._getData(),
      description: this._name,
      endTimestamp: this._endTime,
      // eslint-disable-next-line deprecation/deprecation
      op: this.op,
      parentSpanId: this._parentSpanId,
      sampled: this._sampled,
      spanId: this._spanId,
      startTimestamp: this._startTime,
      status: this._status,
      // eslint-disable-next-line deprecation/deprecation
      tags: this.tags,
      traceId: this._traceId
    });
  }
  /**
   * @inheritDoc
   *
   * @deprecated Update the fields directly instead.
   */
  updateWithContext(X) {
    return this.data = X.data || {}, this._name = X.name || X.description, this._endTime = X.endTimestamp, this.op = X.op, this._parentSpanId = X.parentSpanId, this._sampled = X.sampled, this._spanId = X.spanId || this._spanId, this._startTime = X.startTimestamp || this._startTime, this._status = X.status, this.tags = X.tags || {}, this._traceId = X.traceId || this._traceId, this;
  }
  /**
   * @inheritDoc
   *
   * @deprecated Use `spanToTraceContext()` util function instead.
   */
  getTraceContext() {
    return sb(this);
  }
  /**
   * Get JSON representation of this span.
   *
   * @hidden
   * @internal This method is purely for internal purposes and should not be used outside
   * of SDK code. If you need to get a JSON representation of a span,
   * use `spanToJSON(span)` instead.
   */
  getSpanJSON() {
    return xn({
      data: this._getData(),
      description: this._name,
      op: this._attributes[al],
      parent_span_id: this._parentSpanId,
      span_id: this._spanId,
      start_timestamp: this._startTime,
      status: this._status,
      // eslint-disable-next-line deprecation/deprecation
      tags: Object.keys(this.tags).length > 0 ? this.tags : void 0,
      timestamp: this._endTime,
      trace_id: this._traceId,
      origin: this._attributes[va],
      _metrics_summary: void 0,
      profile_id: this._attributes[Yz],
      exclusive_time: this._exclusiveTime,
      measurements: Object.keys(this._measurements).length > 0 ? this._measurements : void 0
    });
  }
  /** @inheritdoc */
  isRecording() {
    return !this._endTime && !!this._sampled;
  }
  /**
   * Convert the object to JSON.
   * @deprecated Use `spanToJSON(span)` instead.
   */
  toJSON() {
    return this.getSpanJSON();
  }
  /**
   * Get the merged data for this span.
   * For now, this combines `data` and `attributes` together,
   * until eventually we can ingest `attributes` directly.
   */
  _getData() {
    const { data: X, _attributes: ee } = this, te = Object.keys(X).length > 0, ne = Object.keys(ee).length > 0;
    if (!(!te && !ne))
      return te && ne ? {
        ...X,
        ...ee
      } : te ? X : ee;
  }
}
class r5 extends ub {
  /**
   * The reference to the current hub.
   */
  // DO NOT yet remove this property, it is used in a hack for v7 backwards compatibility.
  /**
   * This constructor should never be called manually. Those instrumenting tracing should use
   * `Sentry.startTransaction()`, and internal methods should use `hub.startTransaction()`.
   * @internal
   * @hideconstructor
   * @hidden
   *
   * @deprecated Transactions will be removed in v8. Use spans instead.
   */
  constructor(X, ee) {
    super(X), this._contexts = {}, this._hub = ee || zn(), this._name = X.name || "", this._metadata = {
      // eslint-disable-next-line deprecation/deprecation
      ...X.metadata
    }, this._trimEnd = X.trimEnd, this.transaction = this;
    const te = this._metadata.dynamicSamplingContext;
    te && (this._frozenDynamicSamplingContext = { ...te });
  }
  // This sadly conflicts with the getter/setter ordering :(
  /* eslint-disable @typescript-eslint/member-ordering */
  /**
   * Getter for `name` property.
   * @deprecated Use `spanToJSON(span).description` instead.
   */
  get name() {
    return this._name;
  }
  /**
   * Setter for `name` property, which also sets `source` as custom.
   * @deprecated Use `updateName()` and `setMetadata()` instead.
   */
  set name(X) {
    this.setName(X);
  }
  /**
   * Get the metadata for this transaction.
   * @deprecated Use `spanGetMetadata(transaction)` instead.
   */
  get metadata() {
    return {
      // Defaults
      // eslint-disable-next-line deprecation/deprecation
      source: "custom",
      spanMetadata: {},
      // Legacy metadata
      ...this._metadata,
      // From attributes
      ...this._attributes[Po] && {
        source: this._attributes[Po]
      },
      ...this._attributes[wa] && {
        sampleRate: this._attributes[wa]
      }
    };
  }
  /**
   * Update the metadata for this transaction.
   * @deprecated Use `spanGetMetadata(transaction)` instead.
   */
  set metadata(X) {
    this._metadata = X;
  }
  /* eslint-enable @typescript-eslint/member-ordering */
  /**
   * Setter for `name` property, which also sets `source` on the metadata.
   *
   * @deprecated Use `.updateName()` and `.setAttribute()` instead.
   */
  setName(X, ee = "custom") {
    this._name = X, this.setAttribute(Po, ee);
  }
  /** @inheritdoc */
  updateName(X) {
    return this._name = X, this;
  }
  /**
   * Attaches SpanRecorder to the span itself
   * @param maxlen maximum number of spans that can be recorded
   */
  initSpanRecorder(X = 1e3) {
    this.spanRecorder || (this.spanRecorder = new t5(X)), this.spanRecorder.add(this);
  }
  /**
   * Set the context of a transaction event.
   * @deprecated Use either `.setAttribute()`, or set the context on the scope before creating the transaction.
   */
  setContext(X, ee) {
    ee === null ? delete this._contexts[X] : this._contexts[X] = ee;
  }
  /**
   * @inheritDoc
   *
   * @deprecated Use top-level `setMeasurement()` instead.
   */
  setMeasurement(X, ee, te = "") {
    this._measurements[X] = { value: ee, unit: te };
  }
  /**
   * Store metadata on this transaction.
   * @deprecated Use attributes or store data on the scope instead.
   */
  setMetadata(X) {
    this._metadata = { ...this._metadata, ...X };
  }
  /**
   * @inheritDoc
   */
  end(X) {
    const ee = B0(X), te = this._finishTransaction(ee);
    if (te)
      return this._hub.captureEvent(te);
  }
  /**
   * @inheritDoc
   */
  toContext() {
    const X = super.toContext();
    return xn({
      ...X,
      name: this._name,
      trimEnd: this._trimEnd
    });
  }
  /**
   * @inheritDoc
   */
  updateWithContext(X) {
    return super.updateWithContext(X), this._name = X.name || "", this._trimEnd = X.trimEnd, this;
  }
  /**
   * @inheritdoc
   *
   * @experimental
   *
   * @deprecated Use top-level `getDynamicSamplingContextFromSpan` instead.
   */
  getDynamicSamplingContext() {
    return rc(this);
  }
  /**
   * Override the current hub with a new one.
   * Used if you want another hub to finish the transaction.
   *
   * @internal
   */
  setHub(X) {
    this._hub = X;
  }
  /**
   * Get the profile id of the transaction.
   */
  getProfileId() {
    if (this._contexts !== void 0 && this._contexts.profile !== void 0)
      return this._contexts.profile.profile_id;
  }
  /**
   * Finish the transaction & prepare the event to send to Sentry.
   */
  _finishTransaction(X) {
    if (this._endTime !== void 0)
      return;
    this._name || (et && xe.warn("Transaction has no name, falling back to `<unlabeled transaction>`."), this._name = "<unlabeled transaction>"), super.end(X);
    const ee = this._hub.getClient();
    if (ee && ee.emit && ee.emit("finishTransaction", this), this._sampled !== !0) {
      et && xe.log("[Tracing] Discarding transaction because its trace was not chosen to be sampled."), ee && ee.recordDroppedEvent("sample_rate", "transaction");
      return;
    }
    const te = this.spanRecorder ? (
      // eslint-disable-next-line deprecation/deprecation
      this.spanRecorder.spans.filter((ue) => ue !== this && rn(ue).timestamp)
    ) : [];
    if (this._trimEnd && te.length > 0) {
      const ue = te.map((le) => rn(le).timestamp).filter(Boolean);
      this._endTime = ue.reduce((le, he) => le > he ? le : he);
    }
    const { scope: ne, isolationScope: ie } = Jz(this), { metadata: oe } = this, { source: se } = oe, ae = {
      contexts: {
        ...this._contexts,
        // We don't want to override trace context
        trace: sb(this)
      },
      // TODO: Pass spans serialized via `spanToJSON()` here instead in v8.
      spans: te,
      start_timestamp: this._startTime,
      // eslint-disable-next-line deprecation/deprecation
      tags: this.tags,
      timestamp: this._endTime,
      transaction: this._name,
      type: "transaction",
      sdkProcessingMetadata: {
        ...oe,
        capturedSpanScope: ne,
        capturedSpanIsolationScope: ie,
        ...xn({
          dynamicSamplingContext: rc(this)
        })
      },
      _metrics_summary: void 0,
      ...se && {
        transaction_info: {
          source: se
        }
      }
    };
    return Object.keys(this._measurements).length > 0 && (et && xe.log(
      "[Measurements] Adding measurements to transaction",
      JSON.stringify(this._measurements, void 0, 2)
    ), ae.measurements = this._measurements), et && xe.log(`[Tracing] Finishing ${this.op} transaction: ${this._name}.`), ae;
  }
}
const Cl = {
  idleTimeout: 1e3,
  finalTimeout: 3e4,
  heartbeatInterval: 5e3
}, Xz = "finishReason", ua = [
  "heartbeatFailed",
  "idleTimeout",
  "documentHidden",
  "finalTimeout",
  "externalFinish",
  "cancelled"
];
class Zz extends t5 {
  constructor(X, ee, te, ne) {
    super(ne), this._pushActivity = X, this._popActivity = ee, this.transactionSpanId = te;
  }
  /**
   * @inheritDoc
   */
  add(X) {
    if (X.spanContext().spanId !== this.transactionSpanId) {
      const ee = X.end;
      X.end = (...te) => (this._popActivity(X.spanContext().spanId), ee.apply(X, te)), rn(X).timestamp === void 0 && this._pushActivity(X.spanContext().spanId);
    }
    super.add(X);
  }
}
class Qz extends r5 {
  // Activities store a list of active spans
  // Track state of activities in previous heartbeat
  // Amount of times heartbeat has counted. Will cause transaction to finish after 3 beats.
  // We should not use heartbeat if we finished a transaction
  // Idle timeout was canceled and we should finish the transaction with the last span end.
  /**
   * Timer that tracks Transaction idleTimeout
   */
  /**
   * @deprecated Transactions will be removed in v8. Use spans instead.
   */
  constructor(X, ee, te = Cl.idleTimeout, ne = Cl.finalTimeout, ie = Cl.heartbeatInterval, oe = !1, se = !1) {
    super(X, ee), this._idleHub = ee, this._idleTimeout = te, this._finalTimeout = ne, this._heartbeatInterval = ie, this._onScope = oe, this.activities = {}, this._heartbeatCounter = 0, this._finished = !1, this._idleTimeoutCanceledPermanently = !1, this._beforeFinishCallbacks = [], this._finishReason = ua[4], this._autoFinishAllowed = !se, oe && (et && xe.log(`Setting idle transaction on scope. Span ID: ${this.spanContext().spanId}`), ee.getScope().setSpan(this)), se || this._restartIdleTimeout(), setTimeout(() => {
      this._finished || (this.setStatus("deadline_exceeded"), this._finishReason = ua[3], this.end());
    }, this._finalTimeout);
  }
  /** {@inheritDoc} */
  end(X) {
    const ee = B0(X);
    if (this._finished = !0, this.activities = {}, this.op === "ui.action.click" && this.setAttribute(Xz, this._finishReason), this.spanRecorder) {
      et && // eslint-disable-next-line deprecation/deprecation
      xe.log("[Tracing] finishing IdleTransaction", new Date(ee * 1e3).toISOString(), this.op);
      for (const te of this._beforeFinishCallbacks)
        te(this, ee);
      this.spanRecorder.spans = this.spanRecorder.spans.filter((te) => {
        if (te.spanContext().spanId === this.spanContext().spanId)
          return !0;
        rn(te).timestamp || (te.setStatus("cancelled"), te.end(ee), et && xe.log("[Tracing] cancelling span since transaction ended early", JSON.stringify(te, void 0, 2)));
        const { start_timestamp: ne, timestamp: ie } = rn(te), oe = ne && ne < ee, se = (this._finalTimeout + this._idleTimeout) / 1e3, ae = ie && ne && ie - ne < se;
        if (et) {
          const ue = JSON.stringify(te, void 0, 2);
          oe ? ae || xe.log("[Tracing] discarding Span since it finished after Transaction final timeout", ue) : xe.log("[Tracing] discarding Span since it happened after Transaction was finished", ue);
        }
        return oe && ae;
      }), et && xe.log("[Tracing] flushing IdleTransaction");
    } else
      et && xe.log("[Tracing] No active IdleTransaction");
    if (this._onScope) {
      const te = this._idleHub.getScope();
      te.getTransaction() === this && te.setSpan(void 0);
    }
    return super.end(X);
  }
  /**
   * Register a callback function that gets executed before the transaction finishes.
   * Useful for cleanup or if you want to add any additional spans based on current context.
   *
   * This is exposed because users have no other way of running something before an idle transaction
   * finishes.
   */
  registerBeforeFinishCallback(X) {
    this._beforeFinishCallbacks.push(X);
  }
  /**
   * @inheritDoc
   */
  initSpanRecorder(X) {
    if (!this.spanRecorder) {
      const ee = (ne) => {
        this._finished || this._pushActivity(ne);
      }, te = (ne) => {
        this._finished || this._popActivity(ne);
      };
      this.spanRecorder = new Zz(ee, te, this.spanContext().spanId, X), et && xe.log("Starting heartbeat"), this._pingHeartbeat();
    }
    this.spanRecorder.add(this);
  }
  /**
   * Cancels the existing idle timeout, if there is one.
   * @param restartOnChildSpanChange Default is `true`.
   *                                 If set to false the transaction will end
   *                                 with the last child span.
   */
  cancelIdleTimeout(X, {
    restartOnChildSpanChange: ee
  } = {
    restartOnChildSpanChange: !0
  }) {
    this._idleTimeoutCanceledPermanently = ee === !1, this._idleTimeoutID && (clearTimeout(this._idleTimeoutID), this._idleTimeoutID = void 0, Object.keys(this.activities).length === 0 && this._idleTimeoutCanceledPermanently && (this._finishReason = ua[5], this.end(X)));
  }
  /**
   * Temporary method used to externally set the transaction's `finishReason`
   *
   * ** WARNING**
   * This is for the purpose of experimentation only and will be removed in the near future, do not use!
   *
   * @internal
   *
   */
  setFinishReason(X) {
    this._finishReason = X;
  }
  /**
   * Permits the IdleTransaction to automatically end itself via the idle timeout and heartbeat mechanisms when the `delayAutoFinishUntilSignal` option was set to `true`.
   */
  sendAutoFinishSignal() {
    this._autoFinishAllowed || (et && xe.log("[Tracing] Received finish signal for idle transaction."), this._restartIdleTimeout(), this._autoFinishAllowed = !0);
  }
  /**
   * Restarts idle timeout, if there is no running idle timeout it will start one.
   */
  _restartIdleTimeout(X) {
    this.cancelIdleTimeout(), this._idleTimeoutID = setTimeout(() => {
      !this._finished && Object.keys(this.activities).length === 0 && (this._finishReason = ua[1], this.end(X));
    }, this._idleTimeout);
  }
  /**
   * Start tracking a specific activity.
   * @param spanId The span id that represents the activity
   */
  _pushActivity(X) {
    this.cancelIdleTimeout(void 0, { restartOnChildSpanChange: !this._idleTimeoutCanceledPermanently }), et && xe.log(`[Tracing] pushActivity: ${X}`), this.activities[X] = !0, et && xe.log("[Tracing] new activities count", Object.keys(this.activities).length);
  }
  /**
   * Remove an activity from usage
   * @param spanId The span id that represents the activity
   */
  _popActivity(X) {
    if (this.activities[X] && (et && xe.log(`[Tracing] popActivity ${X}`), delete this.activities[X], et && xe.log("[Tracing] new activities count", Object.keys(this.activities).length)), Object.keys(this.activities).length === 0) {
      const ee = Bf();
      this._idleTimeoutCanceledPermanently ? this._autoFinishAllowed && (this._finishReason = ua[5], this.end(ee)) : this._restartIdleTimeout(ee + this._idleTimeout / 1e3);
    }
  }
  /**
   * Checks when entries of this.activities are not changing for 3 beats.
   * If this occurs we finish the transaction.
   */
  _beat() {
    if (this._finished)
      return;
    const X = Object.keys(this.activities).join("");
    X === this._prevHeartbeatString ? this._heartbeatCounter++ : this._heartbeatCounter = 1, this._prevHeartbeatString = X, this._heartbeatCounter >= 3 ? this._autoFinishAllowed && (et && xe.log("[Tracing] Transaction finished because of no change for 3 heart beats"), this.setStatus("deadline_exceeded"), this._finishReason = ua[0], this.end()) : this._pingHeartbeat();
  }
  /**
   * Pings the heartbeat
   */
  _pingHeartbeat() {
    et && xe.log(`pinging Heartbeat -> current counter: ${this._heartbeatCounter}`), setTimeout(() => {
      this._beat();
    }, this._heartbeatInterval);
  }
}
function n5(Y, X, ee) {
  if (!kf(X))
    return Y.sampled = !1, Y;
  if (Y.sampled !== void 0)
    return Y.setAttribute(wa, Number(Y.sampled)), Y;
  let te;
  return typeof X.tracesSampler == "function" ? (te = X.tracesSampler(ee), Y.setAttribute(wa, Number(te))) : ee.parentSampled !== void 0 ? te = ee.parentSampled : typeof X.tracesSampleRate < "u" ? (te = X.tracesSampleRate, Y.setAttribute(wa, Number(te))) : (te = 1, Y.setAttribute(wa, te)), eq(te) ? te ? (Y.sampled = Math.random() < te, Y.sampled ? (et && // eslint-disable-next-line deprecation/deprecation
  xe.log(`[Tracing] starting ${Y.op} transaction - ${rn(Y).description}`), Y) : (et && xe.log(
    `[Tracing] Discarding transaction because it's not included in the random sample (sampling rate = ${Number(
      te
    )})`
  ), Y)) : (et && xe.log(
    `[Tracing] Discarding transaction because ${typeof X.tracesSampler == "function" ? "tracesSampler returned 0 or false" : "a negative sampling decision was inherited or tracesSampleRate is set to 0"}`
  ), Y.sampled = !1, Y) : (et && xe.warn("[Tracing] Discarding transaction because of invalid sample rate."), Y.sampled = !1, Y);
}
function eq(Y) {
  return xS(Y) || !(typeof Y == "number" || typeof Y == "boolean") ? (et && xe.warn(
    `[Tracing] Given sample rate is invalid. Sample rate must be a boolean or a number between 0 and 1. Got ${JSON.stringify(
      Y
    )} of type ${JSON.stringify(typeof Y)}.`
  ), !1) : Y < 0 || Y > 1 ? (et && xe.warn(`[Tracing] Given sample rate is invalid. Sample rate must be between 0 and 1. Got ${Y}.`), !1) : !0;
}
function tq() {
  const Y = this.getScope().getSpan();
  return Y ? {
    "sentry-trace": O0(Y)
  } : {};
}
function rq(Y, X) {
  const ee = this.getClient(), te = ee && ee.getOptions() || {}, ne = te.instrumenter || "sentry", ie = Y.instrumenter || "sentry";
  ne !== ie && (et && xe.error(
    `A transaction was started with instrumenter=\`${ie}\`, but the SDK is configured with the \`${ne}\` instrumenter.
The transaction will not be sampled. Please use the ${ne} instrumentation to start transactions.`
  ), Y.sampled = !1);
  let oe = new r5(Y, this);
  return oe = n5(oe, te, {
    name: Y.name,
    parentSampled: Y.parentSampled,
    transactionContext: Y,
    attributes: {
      // eslint-disable-next-line deprecation/deprecation
      ...Y.data,
      ...Y.attributes
    },
    ...X
  }), oe.isRecording() && oe.initSpanRecorder(te._experiments && te._experiments.maxSpans), ee && ee.emit && ee.emit("startTransaction", oe), oe;
}
function kv(Y, X, ee, te, ne, ie, oe, se = !1) {
  const ae = Y.getClient(), ue = ae && ae.getOptions() || {};
  let le = new Qz(
    X,
    Y,
    ee,
    te,
    oe,
    ne,
    se
  );
  return le = n5(le, ue, {
    name: X.name,
    parentSampled: X.parentSampled,
    transactionContext: X,
    attributes: {
      // eslint-disable-next-line deprecation/deprecation
      ...X.data,
      ...X.attributes
    },
    ...ie
  }), le.isRecording() && le.initSpanRecorder(ue._experiments && ue._experiments.maxSpans), ae && ae.emit && ae.emit("startTransaction", le), le;
}
function nq() {
  const Y = Nf();
  Y.__SENTRY__ && (Y.__SENTRY__.extensions = Y.__SENTRY__.extensions || {}, Y.__SENTRY__.extensions.startTransaction || (Y.__SENTRY__.extensions.startTransaction = rq), Y.__SENTRY__.extensions.traceHeaders || (Y.__SENTRY__.extensions.traceHeaders = tq), zz());
}
function iq(Y, X, ee) {
  const te = Mc();
  te && te.setMeasurement(Y, X, ee);
}
function sq(Y, X) {
  return X && (Y.sdk = Y.sdk || {}, Y.sdk.name = Y.sdk.name || X.name, Y.sdk.version = Y.sdk.version || X.version, Y.sdk.integrations = [...Y.sdk.integrations || [], ...X.integrations || []], Y.sdk.packages = [...Y.sdk.packages || [], ...X.packages || []]), Y;
}
function oq(Y, X, ee, te) {
  const ne = nb(ee), ie = {
    sent_at: (/* @__PURE__ */ new Date()).toISOString(),
    ...ne && { sdk: ne },
    ...!!te && X && { dsn: Pf(X) }
  }, oe = "aggregates" in Y ? [{ type: "sessions" }, Y] : [{ type: "session" }, Y.toJSON()];
  return ea(ie, [oe]);
}
function aq(Y, X, ee, te) {
  const ne = nb(ee), ie = Y.type && Y.type !== "replay_event" ? Y.type : "event";
  sq(Y, ee && ee.sdk);
  const oe = $S(Y, ne, te, X);
  return delete Y.sdkProcessingMetadata, ea(oe, [[{ type: ie }, Y]]);
}
const cq = "7";
function uq(Y) {
  const X = Y.protocol ? `${Y.protocol}:` : "", ee = Y.port ? `:${Y.port}` : "";
  return `${X}//${Y.host}${ee}${Y.path ? `/${Y.path}` : ""}/api/`;
}
function fq(Y) {
  return `${uq(Y)}${Y.projectId}/envelope/`;
}
function lq(Y, X) {
  return xH({
    // We send only the minimum set of required information. See
    // https://github.com/getsentry/sentry-javascript/issues/2572.
    sentry_key: Y.publicKey,
    sentry_version: cq,
    ...X && { sentry_client: `${X.name}/${X.version}` }
  });
}
function dq(Y, X = {}) {
  const ee = typeof X == "string" ? X : X.tunnel, te = typeof X == "string" || !X._metadata ? void 0 : X._metadata.sdk;
  return ee || `${fq(Y)}?${lq(Y, te)}`;
}
const Mv = [];
function hq(Y) {
  const X = {};
  return Y.forEach((ee) => {
    const { name: te } = ee, ne = X[te];
    ne && !ne.isDefaultInstance && ee.isDefaultInstance || (X[te] = ee);
  }), Object.keys(X).map((ee) => X[ee]);
}
function pq(Y) {
  const X = Y.defaultIntegrations || [], ee = Y.integrations;
  X.forEach((oe) => {
    oe.isDefaultInstance = !0;
  });
  let te;
  Array.isArray(ee) ? te = [...X, ...ee] : typeof ee == "function" ? te = CS(ee(X)) : te = X;
  const ne = hq(te), ie = mq(ne, (oe) => oe.name === "Debug");
  if (ie !== -1) {
    const [oe] = ne.splice(ie, 1);
    ne.push(oe);
  }
  return ne;
}
function gq(Y, X) {
  const ee = {};
  return X.forEach((te) => {
    te && i5(Y, te, ee);
  }), ee;
}
function Lv(Y, X) {
  for (const ee of X)
    ee && ee.afterAllSetup && ee.afterAllSetup(Y);
}
function i5(Y, X, ee) {
  if (ee[X.name]) {
    et && xe.log(`Integration skipped because it was already installed: ${X.name}`);
    return;
  }
  if (ee[X.name] = X, Mv.indexOf(X.name) === -1 && (X.setupOnce(yz, zn), Mv.push(X.name)), X.setup && typeof X.setup == "function" && X.setup(Y), Y.on && typeof X.preprocessEvent == "function") {
    const te = X.preprocessEvent.bind(X);
    Y.on("preprocessEvent", (ne, ie) => te(ne, ie, Y));
  }
  if (Y.addEventProcessor && typeof X.processEvent == "function") {
    const te = X.processEvent.bind(X), ne = Object.assign((ie, oe) => te(ie, oe, Y), {
      id: X.name
    });
    Y.addEventProcessor(ne);
  }
  et && xe.log(`Integration installed: ${X.name}`);
}
function mq(Y, X) {
  for (let ee = 0; ee < Y.length; ee++)
    if (X(Y[ee]) === !0)
      return ee;
  return -1;
}
function wo(Y, X) {
  return Object.assign(
    function(...ee) {
      return X(...ee);
    },
    { id: Y }
  );
}
function yq(Y) {
  let X = "";
  for (const ee of Y) {
    const te = Object.entries(ee.tags), ne = te.length > 0 ? `|#${te.map(([ie, oe]) => `${ie}:${oe}`).join(",")}` : "";
    X += `${ee.name}@${ee.unit}:${ee.metric}|${ee.metricType}${ne}|T${ee.timestamp}
`;
  }
  return X;
}
function bq(Y, X, ee, te) {
  const ne = {
    sent_at: (/* @__PURE__ */ new Date()).toISOString()
  };
  ee && ee.sdk && (ne.sdk = {
    name: ee.sdk.name,
    version: ee.sdk.version
  }), te && X && (ne.dsn = Pf(X));
  const ie = xq(Y);
  return ea(ne, [ie]);
}
function xq(Y) {
  const X = yq(Y);
  return [{
    type: "statsd",
    length: X.length
  }, X];
}
const Fv = "Not capturing exception because it's already been captured.";
class wq {
  /**
   * A reference to a metrics aggregator
   *
   * @experimental Note this is alpha API. It may experience breaking changes in the future.
   */
  /** Options passed to the SDK. */
  /** The client Dsn, if specified in options. Without this Dsn, the SDK will be disabled. */
  /** Array of set up integrations. */
  /** Indicates whether this client's integrations have been set up. */
  /** Number of calls being processed */
  /** Holds flushable  */
  // eslint-disable-next-line @typescript-eslint/ban-types
  /**
   * Initializes this client instance.
   *
   * @param options Options for the client.
   */
  constructor(X) {
    if (this._options = X, this._integrations = {}, this._integrationsInitialized = !1, this._numProcessing = 0, this._outcomes = {}, this._hooks = {}, this._eventProcessors = [], X.dsn ? this._dsn = bH(X.dsn) : et && xe.warn("No DSN provided, client will not send events."), this._dsn) {
      const ee = dq(this._dsn, X);
      this._transport = X.transport({
        recordDroppedEvent: this.recordDroppedEvent.bind(this),
        ...X.transportOptions,
        url: ee
      });
    }
  }
  /**
   * @inheritDoc
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
  captureException(X, ee, te) {
    if (yv(X)) {
      et && xe.log(Fv);
      return;
    }
    let ne = ee && ee.event_id;
    return this._process(
      this.eventFromException(X, ee).then((ie) => this._captureEvent(ie, ee, te)).then((ie) => {
        ne = ie;
      })
    ), ne;
  }
  /**
   * @inheritDoc
   */
  captureMessage(X, ee, te, ne) {
    let ie = te && te.event_id;
    const oe = Jy(X) ? X : String(X), se = Yy(X) ? this.eventFromMessage(oe, ee, te) : this.eventFromException(X, te);
    return this._process(
      se.then((ae) => this._captureEvent(ae, te, ne)).then((ae) => {
        ie = ae;
      })
    ), ie;
  }
  /**
   * @inheritDoc
   */
  captureEvent(X, ee, te) {
    if (ee && ee.originalException && yv(ee.originalException)) {
      et && xe.log(Fv);
      return;
    }
    let ne = ee && ee.event_id;
    const ie = (X.sdkProcessingMetadata || {}).capturedSpanScope;
    return this._process(
      this._captureEvent(X, ee, ie || te).then((oe) => {
        ne = oe;
      })
    ), ne;
  }
  /**
   * @inheritDoc
   */
  captureSession(X) {
    typeof X.release != "string" ? et && xe.warn("Discarded session because of missing or non-string release") : (this.sendSession(X), Vo(X, { init: !1 }));
  }
  /**
   * @inheritDoc
   */
  getDsn() {
    return this._dsn;
  }
  /**
   * @inheritDoc
   */
  getOptions() {
    return this._options;
  }
  /**
   * @see SdkMetadata in @sentry/types
   *
   * @return The metadata of the SDK
   */
  getSdkMetadata() {
    return this._options._metadata;
  }
  /**
   * @inheritDoc
   */
  getTransport() {
    return this._transport;
  }
  /**
   * @inheritDoc
   */
  flush(X) {
    const ee = this._transport;
    return ee ? (this.metricsAggregator && this.metricsAggregator.flush(), this._isClientDoneProcessing(X).then((te) => ee.flush(X).then((ne) => te && ne))) : tc(!0);
  }
  /**
   * @inheritDoc
   */
  close(X) {
    return this.flush(X).then((ee) => (this.getOptions().enabled = !1, this.metricsAggregator && this.metricsAggregator.close(), ee));
  }
  /** Get all installed event processors. */
  getEventProcessors() {
    return this._eventProcessors;
  }
  /** @inheritDoc */
  addEventProcessor(X) {
    this._eventProcessors.push(X);
  }
  /**
   * This is an internal function to setup all integrations that should run on the client.
   * @deprecated Use `client.init()` instead.
   */
  setupIntegrations(X) {
    (X && !this._integrationsInitialized || this._isEnabled() && !this._integrationsInitialized) && this._setupIntegrations();
  }
  /** @inheritdoc */
  init() {
    this._isEnabled() && this._setupIntegrations();
  }
  /**
   * Gets an installed integration by its `id`.
   *
   * @returns The installed integration or `undefined` if no integration with that `id` was installed.
   * @deprecated Use `getIntegrationByName()` instead.
   */
  getIntegrationById(X) {
    return this.getIntegrationByName(X);
  }
  /**
   * Gets an installed integration by its name.
   *
   * @returns The installed integration or `undefined` if no integration with that `name` was installed.
   */
  getIntegrationByName(X) {
    return this._integrations[X];
  }
  /**
   * Returns the client's instance of the given integration class, it any.
   * @deprecated Use `getIntegrationByName()` instead.
   */
  getIntegration(X) {
    try {
      return this._integrations[X.id] || null;
    } catch {
      return et && xe.warn(`Cannot retrieve integration ${X.id} from the current Client`), null;
    }
  }
  /**
   * @inheritDoc
   */
  addIntegration(X) {
    const ee = this._integrations[X.name];
    i5(this, X, this._integrations), ee || Lv(this, [X]);
  }
  /**
   * @inheritDoc
   */
  sendEvent(X, ee = {}) {
    this.emit("beforeSendEvent", X, ee);
    let te = aq(X, this._dsn, this._options._metadata, this._options.tunnel);
    for (const ie of ee.attachments || [])
      te = az(
        te,
        fz(
          ie,
          this._options.transportOptions && this._options.transportOptions.textEncoder
        )
      );
    const ne = this._sendEnvelope(te);
    ne && ne.then((ie) => this.emit("afterSendEvent", X, ie), null);
  }
  /**
   * @inheritDoc
   */
  sendSession(X) {
    const ee = oq(X, this._dsn, this._options._metadata, this._options.tunnel);
    this._sendEnvelope(ee);
  }
  /**
   * @inheritDoc
   */
  recordDroppedEvent(X, ee, te) {
    if (this._options.sendClientReports) {
      const ne = `${X}:${ee}`;
      et && xe.log(`Adding outcome: "${ne}"`), this._outcomes[ne] = this._outcomes[ne] + 1 || 1;
    }
  }
  /**
   * @inheritDoc
   */
  captureAggregateMetrics(X) {
    et && xe.log(`Flushing aggregated metrics, number of metrics: ${X.length}`);
    const ee = bq(
      X,
      this._dsn,
      this._options._metadata,
      this._options.tunnel
    );
    this._sendEnvelope(ee);
  }
  // Keep on() & emit() signatures in sync with types' client.ts interface
  /* eslint-disable @typescript-eslint/unified-signatures */
  /** @inheritdoc */
  /** @inheritdoc */
  on(X, ee) {
    this._hooks[X] || (this._hooks[X] = []), this._hooks[X].push(ee);
  }
  /** @inheritdoc */
  /** @inheritdoc */
  emit(X, ...ee) {
    this._hooks[X] && this._hooks[X].forEach((te) => te(...ee));
  }
  /* eslint-enable @typescript-eslint/unified-signatures */
  /** Setup integrations for this client. */
  _setupIntegrations() {
    const { integrations: X } = this._options;
    this._integrations = gq(this, X), Lv(this, X), this._integrationsInitialized = !0;
  }
  /** Updates existing session based on the provided event */
  _updateSessionFromEvent(X, ee) {
    let te = !1, ne = !1;
    const ie = ee.exception && ee.exception.values;
    if (ie) {
      ne = !0;
      for (const se of ie) {
        const ae = se.mechanism;
        if (ae && ae.handled === !1) {
          te = !0;
          break;
        }
      }
    }
    const oe = X.status === "ok";
    (oe && X.errors === 0 || oe && te) && (Vo(X, {
      ...te && { status: "crashed" },
      errors: X.errors || Number(ne || te)
    }), this.captureSession(X));
  }
  /**
   * Determine if the client is finished processing. Returns a promise because it will wait `timeout` ms before saying
   * "no" (resolving to `false`) in order to give the client a chance to potentially finish first.
   *
   * @param timeout The time, in ms, after which to resolve to `false` if the client is still busy. Passing `0` (or not
   * passing anything) will make the promise wait as long as it takes for processing to finish before resolving to
   * `true`.
   * @returns A promise which will resolve to `true` if processing is already done or finishes before the timeout, and
   * `false` otherwise
   */
  _isClientDoneProcessing(X) {
    return new Dn((ee) => {
      let te = 0;
      const ne = 1, ie = setInterval(() => {
        this._numProcessing == 0 ? (clearInterval(ie), ee(!0)) : (te += ne, X && te >= X && (clearInterval(ie), ee(!1)));
      }, ne);
    });
  }
  /** Determines whether this SDK is enabled and a transport is present. */
  _isEnabled() {
    return this.getOptions().enabled !== !1 && this._transport !== void 0;
  }
  /**
   * Adds common information to events.
   *
   * The information includes release and environment from `options`,
   * breadcrumbs and context (extra, tags and user) from the scope.
   *
   * Information that is already present in the event is never overwritten. For
   * nested objects, such as the context, keys are merged.
   *
   * @param event The original event.
   * @param hint May contain additional information about the original exception.
   * @param scope A scope containing event metadata.
   * @returns A new event with more information.
   */
  _prepareEvent(X, ee, te, ne = xo()) {
    const ie = this.getOptions(), oe = Object.keys(this._integrations);
    return !ee.integrations && oe.length > 0 && (ee.integrations = oe), this.emit("preprocessEvent", X, ee), qS(ie, X, ee, te, this, ne).then((se) => {
      if (se === null)
        return se;
      const ae = {
        ...ne.getPropagationContext(),
        ...te ? te.getPropagationContext() : void 0
      };
      if (!(se.contexts && se.contexts.trace) && ae) {
        const { traceId: ue, spanId: le, parentSpanId: he, dsc: me } = ae;
        se.contexts = {
          trace: {
            trace_id: ue,
            span_id: le,
            parent_span_id: he
          },
          ...se.contexts
        };
        const ye = me || N0(ue, this, te);
        se.sdkProcessingMetadata = {
          dynamicSamplingContext: ye,
          ...se.sdkProcessingMetadata
        };
      }
      return se;
    });
  }
  /**
   * Processes the event and logs an error in case of rejection
   * @param event
   * @param hint
   * @param scope
   */
  _captureEvent(X, ee = {}, te) {
    return this._processEvent(X, ee, te).then(
      (ne) => ne.event_id,
      (ne) => {
        if (et) {
          const ie = ne;
          ie.logLevel === "log" ? xe.log(ie.message) : xe.warn(ie);
        }
      }
    );
  }
  /**
   * Processes an event (either error or message) and sends it to Sentry.
   *
   * This also adds breadcrumbs and context information to the event. However,
   * platform specific meta data (such as the User's IP address) must be added
   * by the SDK implementor.
   *
   *
   * @param event The event to send to Sentry.
   * @param hint May contain additional information about the original exception.
   * @param scope A scope containing event metadata.
   * @returns A SyncPromise that resolves with the event or rejects in case event was/will not be send.
   */
  _processEvent(X, ee, te) {
    const ne = this.getOptions(), { sampleRate: ie } = ne, oe = o5(X), se = s5(X), ae = X.type || "error", ue = `before send for type \`${ae}\``;
    if (se && typeof ie == "number" && Math.random() > ie)
      return this.recordDroppedEvent("sample_rate", "error", X), tb(
        new Di(
          `Discarding event because it's not included in the random sample (sampling rate = ${ie})`,
          "log"
        )
      );
    const le = ae === "replay_event" ? "replay" : ae, he = (X.sdkProcessingMetadata || {}).capturedSpanIsolationScope;
    return this._prepareEvent(X, ee, te, he).then((me) => {
      if (me === null)
        throw this.recordDroppedEvent("event_processor", le, X), new Di("An event processor returned `null`, will not send event.", "log");
      if (ee.data && ee.data.__sentry__ === !0)
        return me;
      const ye = Eq(ne, me, ee);
      return vq(ye, ue);
    }).then((me) => {
      if (me === null)
        throw this.recordDroppedEvent("before_send", le, X), new Di(`${ue} returned \`null\`, will not send event.`, "log");
      const ye = te && te.getSession();
      !oe && ye && this._updateSessionFromEvent(ye, me);
      const we = me.transaction_info;
      if (oe && we && me.transaction !== X.transaction) {
        const Ee = "custom";
        me.transaction_info = {
          ...we,
          source: Ee
        };
      }
      return this.sendEvent(me, ee), me;
    }).then(null, (me) => {
      throw me instanceof Di ? me : (this.captureException(me, {
        data: {
          __sentry__: !0
        },
        originalException: me
      }), new Di(
        `Event processing pipeline threw an error, original event will not be sent. Details have been sent as a new event.
Reason: ${me}`
      ));
    });
  }
  /**
   * Occupies the client with processing and event
   */
  _process(X) {
    this._numProcessing++, X.then(
      (ee) => (this._numProcessing--, ee),
      (ee) => (this._numProcessing--, ee)
    );
  }
  /**
   * @inheritdoc
   */
  _sendEnvelope(X) {
    if (this.emit("beforeEnvelope", X), this._isEnabled() && this._transport)
      return this._transport.send(X).then(null, (ee) => {
        et && xe.error("Error while sending event:", ee);
      });
    et && xe.error("Transport disabled");
  }
  /**
   * Clears outcomes on this client and returns them.
   */
  _clearOutcomes() {
    const X = this._outcomes;
    return this._outcomes = {}, Object.keys(X).map((ee) => {
      const [te, ne] = ee.split(":");
      return {
        reason: te,
        category: ne,
        quantity: X[ee]
      };
    });
  }
  /**
   * @inheritDoc
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
}
function vq(Y, X) {
  const ee = `${X} must return \`null\` or a valid event.`;
  if (R0(Y))
    return Y.then(
      (te) => {
        if (!ec$2(te) && te !== null)
          throw new Di(ee);
        return te;
      },
      (te) => {
        throw new Di(`${X} rejected with ${te}`);
      }
    );
  if (!ec$2(Y) && Y !== null)
    throw new Di(ee);
  return Y;
}
function Eq(Y, X, ee) {
  const { beforeSend: te, beforeSendTransaction: ne } = Y;
  return s5(X) && te ? te(X, ee) : o5(X) && ne ? ne(X, ee) : X;
}
function s5(Y) {
  return Y.type === void 0;
}
function o5(Y) {
  return Y.type === "transaction";
}
function _q(Y) {
  const X = cr();
  !X || !X.addEventProcessor || X.addEventProcessor(Y);
}
function Aq(Y, X) {
  X.debug === !0 && (et ? xe.enable() : qo(() => {
    console.warn("[Sentry] Cannot initialize SDK with `debug` option using a non-debug bundle.");
  })), ai().update(X.initialScope);
  const ee = new Y(X);
  Sq(ee), Tq(ee);
}
function Sq(Y) {
  const X = zn().getStackTop();
  X.client = Y, X.scope.setClient(Y);
}
function Tq(Y) {
  Y.init ? Y.init() : Y.setupIntegrations && Y.setupIntegrations();
}
const Iq = 30;
function a5(Y, X, ee = YH(
  Y.bufferSize || Iq
)) {
  let te = {};
  const ne = (oe) => ee.drain(oe);
  function ie(oe) {
    const se = [];
    if (_v(oe, (he, me) => {
      const ye = Av(me);
      if (DS(te, ye)) {
        const we = $v(he, me);
        Y.recordDroppedEvent("ratelimit_backoff", ye, we);
      } else
        se.push(he);
    }), se.length === 0)
      return tc();
    const ae = ea(oe[0], se), ue = (he) => {
      _v(ae, (me, ye) => {
        const we = $v(me, ye);
        Y.recordDroppedEvent(he, Av(ye), we);
      });
    }, le = () => X({ body: cz(ae, Y.textEncoder) }).then(
      (he) => (he.statusCode !== void 0 && (he.statusCode < 200 || he.statusCode >= 300) && et && xe.warn(`Sentry responded with status code ${he.statusCode} to sent event.`), te = US(te, he), he),
      (he) => {
        throw ue("network_error"), he;
      }
    );
    return ee.add(le).then(
      (he) => he,
      (he) => {
        if (he instanceof Di)
          return et && xe.error("Skipped sending event because buffer is full."), ue("queue_overflow"), tc();
        throw he;
      }
    );
  }
  return ie.__sentry__baseTransport__ = !0, {
    send: ie,
    flush: ne
  };
}
function $v(Y, X) {
  if (!(X !== "event" && X !== "transaction"))
    return Array.isArray(Y) ? Y[1] : void 0;
}
function Rq(Y, X) {
  const ee = X && Oq(X) ? (
    // eslint-disable-next-line deprecation/deprecation
    X.getClient()
  ) : X, te = ee && ee.getDsn(), ne = ee && ee.getOptions().tunnel;
  return Pq(Y, te) || Cq(Y, ne);
}
function Cq(Y, X) {
  return X ? Dv(Y) === Dv(X) : !1;
}
function Pq(Y, X) {
  return X ? Y.includes(X.host) : !1;
}
function Dv(Y) {
  return Y[Y.length - 1] === "/" ? Y.slice(0, -1) : Y;
}
function Oq(Y) {
  return Y.getClient !== void 0;
}
function Bq(Y, X, ee = [X], te = "npm") {
  const ne = Y._metadata || {};
  ne.sdk || (ne.sdk = {
    name: `sentry.javascript.${X}`,
    packages: ee.map((ie) => ({
      name: `${te}:@sentry/${ie}`,
      version: $g
    })),
    version: $g
  }), Y._metadata = ne;
}
const Nq = [/^Script error\.?$/, /^Javascript error: Script error\.? on line 0$/], kq = [
  /^.*\/healthcheck$/,
  /^.*\/healthy$/,
  /^.*\/live$/,
  /^.*\/ready$/,
  /^.*\/heartbeat$/,
  /^.*\/health$/,
  /^.*\/healthz$/
], c5 = "InboundFilters", Mq = (Y = {}) => ({
  name: c5,
  // TODO v8: Remove this
  setupOnce() {
  },
  // eslint-disable-line @typescript-eslint/no-empty-function
  processEvent(X, ee, te) {
    const ne = te.getOptions(), ie = Lq(Y, ne);
    return Fq(X, ie) ? null : X;
  }
}), u5 = Mq;
wo(
  c5,
  u5
);
function Lq(Y = {}, X = {}) {
  return {
    allowUrls: [...Y.allowUrls || [], ...X.allowUrls || []],
    denyUrls: [...Y.denyUrls || [], ...X.denyUrls || []],
    ignoreErrors: [
      ...Y.ignoreErrors || [],
      ...X.ignoreErrors || [],
      ...Y.disableErrorDefaults ? [] : Nq
    ],
    ignoreTransactions: [
      ...Y.ignoreTransactions || [],
      ...X.ignoreTransactions || [],
      ...Y.disableTransactionDefaults ? [] : kq
    ],
    ignoreInternal: Y.ignoreInternal !== void 0 ? Y.ignoreInternal : !0
  };
}
function Fq(Y, X) {
  return X.ignoreInternal && zq(Y) ? (et && xe.warn(`Event dropped due to being internal Sentry Error.
Event: ${Zs(Y)}`), !0) : $q(Y, X.ignoreErrors) ? (et && xe.warn(
    `Event dropped due to being matched by \`ignoreErrors\` option.
Event: ${Zs(Y)}`
  ), !0) : Dq(Y, X.ignoreTransactions) ? (et && xe.warn(
    `Event dropped due to being matched by \`ignoreTransactions\` option.
Event: ${Zs(Y)}`
  ), !0) : Uq(Y, X.denyUrls) ? (et && xe.warn(
    `Event dropped due to being matched by \`denyUrls\` option.
Event: ${Zs(
      Y
    )}.
Url: ${sd(Y)}`
  ), !0) : jq(Y, X.allowUrls) ? !1 : (et && xe.warn(
    `Event dropped due to not being matched by \`allowUrls\` option.
Event: ${Zs(
      Y
    )}.
Url: ${sd(Y)}`
  ), !0);
}
function $q(Y, X) {
  return Y.type || !X || !X.length ? !1 : Hq(Y).some((ee) => Nc(ee, X));
}
function Dq(Y, X) {
  if (Y.type !== "transaction" || !X || !X.length)
    return !1;
  const ee = Y.transaction;
  return ee ? Nc(ee, X) : !1;
}
function Uq(Y, X) {
  if (!X || !X.length)
    return !1;
  const ee = sd(Y);
  return ee ? Nc(ee, X) : !1;
}
function jq(Y, X) {
  if (!X || !X.length)
    return !0;
  const ee = sd(Y);
  return ee ? Nc(ee, X) : !0;
}
function Hq(Y) {
  const X = [];
  Y.message && X.push(Y.message);
  let ee;
  try {
    ee = Y.exception.values[Y.exception.values.length - 1];
  } catch {
  }
  return ee && ee.value && (X.push(ee.value), ee.type && X.push(`${ee.type}: ${ee.value}`)), et && X.length === 0 && xe.error(`Could not extract message for event ${Zs(Y)}`), X;
}
function zq(Y) {
  try {
    return Y.exception.values[0].type === "SentryError";
  } catch {
  }
  return !1;
}
function qq(Y = []) {
  for (let X = Y.length - 1; X >= 0; X--) {
    const ee = Y[X];
    if (ee && ee.filename !== "<anonymous>" && ee.filename !== "[native code]")
      return ee.filename || null;
  }
  return null;
}
function sd(Y) {
  try {
    let X;
    try {
      X = Y.exception.values[0].stacktrace.frames;
    } catch {
    }
    return X ? qq(X) : null;
  } catch {
    return et && xe.error(`Cannot extract url for event ${Zs(Y)}`), null;
  }
}
let Uv;
const f5 = "FunctionToString", jv = /* @__PURE__ */ new WeakMap(), Gq = () => ({
  name: f5,
  setupOnce() {
    Uv = Function.prototype.toString;
    try {
      Function.prototype.toString = function(...Y) {
        const X = Zy(this), ee = jv.has(cr()) && X !== void 0 ? X : this;
        return Uv.apply(ee, Y);
      };
    } catch {
    }
  },
  setup(Y) {
    jv.set(Y, !0);
  }
}), l5 = Gq;
wo(
  f5,
  l5
);
const xr = typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__, er = zt;
function Vq() {
  er && er.document ? er.document.addEventListener("visibilitychange", () => {
    const Y = Mc();
    if (er.document.hidden && Y) {
      const X = "cancelled", { op: ee, status: te } = rn(Y);
      xr && xe.log(`[Tracing] Transaction: ${X} -> since tab moved to the background, op: ${ee}`), te || Y.setStatus(X), Y.setTag("visibilitychange", "document.hidden"), Y.end();
    }
  }) : xr && xe.warn("[Tracing] Could not set up background tab detection due to lack of global document");
}
const fb = (Y, X, ee) => {
  let te, ne;
  return (ie) => {
    X.value >= 0 && (ie || ee) && (ne = X.value - (te || 0), (ne || te === void 0) && (te = X.value, X.delta = ne, Y(X)));
  };
}, Wq = () => `v3-${Date.now()}-${Math.floor(Math.random() * (9e12 - 1)) + 1e12}`, Kq = () => {
  const Y = er.performance.timing, X = er.performance.navigation.type, ee = {
    entryType: "navigation",
    startTime: 0,
    type: X == 2 ? "back_forward" : X === 1 ? "reload" : "navigate"
  };
  for (const te in Y)
    te !== "navigationStart" && te !== "toJSON" && (ee[te] = Math.max(Y[te] - Y.navigationStart, 0));
  return ee;
}, d5 = () => er.__WEB_VITALS_POLYFILL__ ? er.performance && (performance.getEntriesByType && performance.getEntriesByType("navigation")[0] || Kq()) : er.performance && performance.getEntriesByType && performance.getEntriesByType("navigation")[0], h5 = () => {
  const Y = d5();
  return Y && Y.activationStart || 0;
}, lb = (Y, X) => {
  const ee = d5();
  let te = "navigate";
  return ee && (er.document.prerendering || h5() > 0 ? te = "prerender" : te = ee.type.replace(/_/g, "-")), {
    name: Y,
    value: typeof X > "u" ? -1 : X,
    rating: "good",
    // Will be updated if the value changes.
    delta: 0,
    entries: [],
    id: Wq(),
    navigationType: te
  };
}, k0 = (Y, X, ee) => {
  try {
    if (PerformanceObserver.supportedEntryTypes.includes(Y)) {
      const te = new PerformanceObserver((ne) => {
        X(ne.getEntries());
      });
      return te.observe(
        Object.assign(
          {
            type: Y,
            buffered: !0
          },
          ee || {}
        )
      ), te;
    }
  } catch {
  }
}, M0 = (Y, X) => {
  const ee = (te) => {
    (te.type === "pagehide" || er.document.visibilityState === "hidden") && (Y(te), X && (removeEventListener("visibilitychange", ee, !0), removeEventListener("pagehide", ee, !0)));
  };
  addEventListener("visibilitychange", ee, !0), addEventListener("pagehide", ee, !0);
}, Jq = (Y) => {
  const X = lb("CLS", 0);
  let ee, te = 0, ne = [];
  const ie = (se) => {
    se.forEach((ae) => {
      if (!ae.hadRecentInput) {
        const ue = ne[0], le = ne[ne.length - 1];
        te && ne.length !== 0 && ae.startTime - le.startTime < 1e3 && ae.startTime - ue.startTime < 5e3 ? (te += ae.value, ne.push(ae)) : (te = ae.value, ne = [ae]), te > X.value && (X.value = te, X.entries = ne, ee && ee());
      }
    });
  }, oe = k0("layout-shift", ie);
  if (oe) {
    ee = fb(Y, X);
    const se = () => {
      ie(oe.takeRecords()), ee(!0);
    };
    return M0(se), se;
  }
};
let Pl = -1;
const Yq = () => er.document.visibilityState === "hidden" && !er.document.prerendering ? 0 : 1 / 0, Xq = () => {
  M0(({ timeStamp: Y }) => {
    Pl = Y;
  }, !0);
}, db = () => (Pl < 0 && (Pl = Yq(), Xq()), {
  get firstHiddenTime() {
    return Pl;
  }
}), Zq = (Y) => {
  const X = db(), ee = lb("FID");
  let te;
  const ne = (se) => {
    se.startTime < X.firstHiddenTime && (ee.value = se.processingStart - se.startTime, ee.entries.push(se), te(!0));
  }, ie = (se) => {
    se.forEach(ne);
  }, oe = k0("first-input", ie);
  te = fb(Y, ee), oe && M0(() => {
    ie(oe.takeRecords()), oe.disconnect();
  }, !0);
}, Hv = {}, Qq = (Y) => {
  const X = db(), ee = lb("LCP");
  let te;
  const ne = (oe) => {
    const se = oe[oe.length - 1];
    if (se) {
      const ae = Math.max(se.startTime - h5(), 0);
      ae < X.firstHiddenTime && (ee.value = ae, ee.entries = [se], te());
    }
  }, ie = k0("largest-contentful-paint", ne);
  if (ie) {
    te = fb(Y, ee);
    const oe = () => {
      Hv[ee.id] || (ne(ie.takeRecords()), ie.disconnect(), Hv[ee.id] = !0, te(!0));
    };
    return ["keydown", "click"].forEach((se) => {
      addEventListener(se, oe, { once: !0, capture: !0 });
    }), M0(oe, !0), oe;
  }
}, hu = {}, od = {};
let p5, g5, m5;
function eG(Y, X = !1) {
  return hb("cls", Y, rG, p5, X);
}
function y5(Y, X = !1) {
  return hb("lcp", Y, iG, m5, X);
}
function tG(Y) {
  return hb("fid", Y, nG, g5);
}
function L0(Y, X) {
  return b5(Y, X), od[Y] || (sG(Y), od[Y] = !0), x5(Y, X);
}
function F0(Y, X) {
  const ee = hu[Y];
  if (!(!ee || !ee.length))
    for (const te of ee)
      try {
        te(X);
      } catch (ne) {
        xr && xe.error(
          `Error while triggering instrumentation handler.
Type: ${Y}
Name: ${ks(te)}
Error:`,
          ne
        );
      }
}
function rG() {
  return Jq((Y) => {
    F0("cls", {
      metric: Y
    }), p5 = Y;
  });
}
function nG() {
  return Zq((Y) => {
    F0("fid", {
      metric: Y
    }), g5 = Y;
  });
}
function iG() {
  return Qq((Y) => {
    F0("lcp", {
      metric: Y
    }), m5 = Y;
  });
}
function hb(Y, X, ee, te, ne = !1) {
  b5(Y, X);
  let ie;
  return od[Y] || (ie = ee(), od[Y] = !0), te && X({ metric: te }), x5(Y, X, ne ? ie : void 0);
}
function sG(Y) {
  const X = {};
  Y === "event" && (X.durationThreshold = 0), k0(
    Y,
    (ee) => {
      F0(Y, { entries: ee });
    },
    X
  );
}
function b5(Y, X) {
  hu[Y] = hu[Y] || [], hu[Y].push(X);
}
function x5(Y, X, ee) {
  return () => {
    ee && ee();
    const te = hu[Y];
    if (!te)
      return;
    const ne = te.indexOf(X);
    ne !== -1 && te.splice(ne, 1);
  };
}
function _p(Y) {
  return typeof Y == "number" && isFinite(Y);
}
function nc(Y, { startTimestamp: X, ...ee }) {
  return X && Y.startTimestamp > X && (Y.startTimestamp = X), Y.startChild({
    startTimestamp: X,
    ...ee
  });
}
const oG = 2147483647;
function Ur(Y) {
  return Y / 1e3;
}
function w5() {
  return er && er.addEventListener && er.performance;
}
let zv = 0, Rr = {}, Oi, pu;
function aG() {
  const Y = w5();
  if (Y && vi) {
    Y.mark && er.performance.mark("sentry-tracing-init");
    const X = dG(), ee = fG(), te = lG();
    return () => {
      X(), ee(), te();
    };
  }
  return () => {
  };
}
function cG() {
  L0("longtask", ({ entries: Y }) => {
    for (const X of Y) {
      const ee = Mc();
      if (!ee)
        return;
      const te = Ur(vi + X.startTime), ne = Ur(X.duration);
      ee.startChild({
        description: "Main UI thread blocked",
        op: "ui.long-task",
        origin: "auto.ui.browser.metrics",
        startTimestamp: te,
        endTimestamp: te + ne
      });
    }
  });
}
function uG() {
  L0("event", ({ entries: Y }) => {
    for (const X of Y) {
      const ee = Mc();
      if (!ee)
        return;
      if (X.name === "click") {
        const te = Ur(vi + X.startTime), ne = Ur(X.duration), ie = {
          description: zo(X.target),
          op: `ui.interaction.${X.name}`,
          origin: "auto.ui.browser.metrics",
          startTimestamp: te,
          endTimestamp: te + ne
        }, oe = ES(X.target);
        oe && (ie.attributes = { "ui.component_name": oe }), ee.startChild(ie);
      }
    }
  });
}
function fG() {
  return eG(({ metric: Y }) => {
    const X = Y.entries[Y.entries.length - 1];
    X && (xr && xe.log("[Measurements] Adding CLS"), Rr.cls = { value: Y.value, unit: "" }, pu = X);
  }, !0);
}
function lG() {
  return y5(({ metric: Y }) => {
    const X = Y.entries[Y.entries.length - 1];
    X && (xr && xe.log("[Measurements] Adding LCP"), Rr.lcp = { value: Y.value, unit: "millisecond" }, Oi = X);
  }, !0);
}
function dG() {
  return tG(({ metric: Y }) => {
    const X = Y.entries[Y.entries.length - 1];
    if (!X)
      return;
    const ee = Ur(vi), te = Ur(X.startTime);
    xr && xe.log("[Measurements] Adding FID"), Rr.fid = { value: Y.value, unit: "millisecond" }, Rr["mark.fid"] = { value: ee + te, unit: "second" };
  });
}
function hG(Y) {
  const X = w5();
  if (!X || !er.performance.getEntries || !vi)
    return;
  xr && xe.log("[Tracing] Adding & adjusting spans using Performance API");
  const ee = Ur(vi), te = X.getEntries();
  let ne, ie;
  const { op: oe, start_timestamp: se } = rn(Y);
  if (te.slice(zv).forEach((ae) => {
    const ue = Ur(ae.startTime), le = Ur(ae.duration);
    if (!(Y.op === "navigation" && se && ee + ue < se))
      switch (ae.entryType) {
        case "navigation": {
          gG(Y, ae, ee), ne = ee + Ur(ae.responseStart), ie = ee + Ur(ae.requestStart);
          break;
        }
        case "mark":
        case "paint":
        case "measure": {
          pG(Y, ae, ue, le, ee);
          const he = db(), me = ae.startTime < he.firstHiddenTime;
          ae.name === "first-paint" && me && (xr && xe.log("[Measurements] Adding FP"), Rr.fp = { value: ae.startTime, unit: "millisecond" }), ae.name === "first-contentful-paint" && me && (xr && xe.log("[Measurements] Adding FCP"), Rr.fcp = { value: ae.startTime, unit: "millisecond" });
          break;
        }
        case "resource": {
          yG(Y, ae, ae.name, ue, le, ee);
          break;
        }
      }
  }), zv = Math.max(te.length - 1, 0), bG(Y), oe === "pageload") {
    wG(Rr, ne, ie, se), ["fcp", "fp", "lcp"].forEach((ue) => {
      if (!Rr[ue] || !se || ee >= se)
        return;
      const le = Rr[ue].value, he = ee + Ur(le), me = Math.abs((he - se) * 1e3), ye = me - le;
      xr && xe.log(`[Measurements] Normalized ${ue} from ${le} to ${me} (${ye})`), Rr[ue].value = me;
    });
    const ae = Rr["mark.fid"];
    ae && Rr.fid && (nc(Y, {
      description: "first input delay",
      endTimestamp: ae.value + Ur(Rr.fid.value),
      op: "ui.action",
      origin: "auto.ui.browser.metrics",
      startTimestamp: ae.value
    }), delete Rr["mark.fid"]), "fcp" in Rr || delete Rr.cls, Object.keys(Rr).forEach((ue) => {
      iq(ue, Rr[ue].value, Rr[ue].unit);
    }), xG(Y);
  }
  Oi = void 0, pu = void 0, Rr = {};
}
function pG(Y, X, ee, te, ne) {
  const ie = ne + ee, oe = ie + te;
  return nc(Y, {
    description: X.name,
    endTimestamp: oe,
    op: X.entryType,
    origin: "auto.resource.browser.metrics",
    startTimestamp: ie
  }), ie;
}
function gG(Y, X, ee) {
  ["unloadEvent", "redirect", "domContentLoadedEvent", "loadEvent", "connect"].forEach((te) => {
    cl(Y, X, te, ee);
  }), cl(Y, X, "secureConnection", ee, "TLS/SSL", "connectEnd"), cl(Y, X, "fetch", ee, "cache", "domainLookupStart"), cl(Y, X, "domainLookup", ee, "DNS"), mG(Y, X, ee);
}
function cl(Y, X, ee, te, ne, ie) {
  const oe = ie ? X[ie] : X[`${ee}End`], se = X[`${ee}Start`];
  !se || !oe || nc(Y, {
    op: "browser",
    origin: "auto.browser.browser.metrics",
    description: ne || ee,
    startTimestamp: te + Ur(se),
    endTimestamp: te + Ur(oe)
  });
}
function mG(Y, X, ee) {
  X.responseEnd && (nc(Y, {
    op: "browser",
    origin: "auto.browser.browser.metrics",
    description: "request",
    startTimestamp: ee + Ur(X.requestStart),
    endTimestamp: ee + Ur(X.responseEnd)
  }), nc(Y, {
    op: "browser",
    origin: "auto.browser.browser.metrics",
    description: "response",
    startTimestamp: ee + Ur(X.responseStart),
    endTimestamp: ee + Ur(X.responseEnd)
  }));
}
function yG(Y, X, ee, te, ne, ie) {
  if (X.initiatorType === "xmlhttprequest" || X.initiatorType === "fetch")
    return;
  const oe = Rl(ee), se = {};
  Ap(se, X, "transferSize", "http.response_transfer_size"), Ap(se, X, "encodedBodySize", "http.response_content_length"), Ap(se, X, "decodedBodySize", "http.decoded_response_content_length"), "renderBlockingStatus" in X && (se["resource.render_blocking_status"] = X.renderBlockingStatus), oe.protocol && (se["url.scheme"] = oe.protocol.split(":").pop()), oe.host && (se["server.address"] = oe.host), se["url.same_origin"] = ee.includes(er.location.origin);
  const ae = ie + te, ue = ae + ne;
  nc(Y, {
    description: ee.replace(er.location.origin, ""),
    endTimestamp: ue,
    op: X.initiatorType ? `resource.${X.initiatorType}` : "resource.other",
    origin: "auto.resource.browser.metrics",
    startTimestamp: ae,
    data: se
  });
}
function bG(Y) {
  const X = er.navigator;
  if (!X)
    return;
  const ee = X.connection;
  ee && (ee.effectiveType && Y.setTag("effectiveConnectionType", ee.effectiveType), ee.type && Y.setTag("connectionType", ee.type), _p(ee.rtt) && (Rr["connection.rtt"] = { value: ee.rtt, unit: "millisecond" })), _p(X.deviceMemory) && Y.setTag("deviceMemory", `${X.deviceMemory} GB`), _p(X.hardwareConcurrency) && Y.setTag("hardwareConcurrency", String(X.hardwareConcurrency));
}
function xG(Y) {
  Oi && (xr && xe.log("[Measurements] Adding LCP Data"), Oi.element && Y.setTag("lcp.element", zo(Oi.element)), Oi.id && Y.setTag("lcp.id", Oi.id), Oi.url && Y.setTag("lcp.url", Oi.url.trim().slice(0, 200)), Y.setTag("lcp.size", Oi.size)), pu && pu.sources && (xr && xe.log("[Measurements] Adding CLS Data"), pu.sources.forEach(
    (X, ee) => (
      // TODO: Can we rewrite this to an attribute?
      // eslint-disable-next-line deprecation/deprecation
      Y.setTag(`cls.source.${ee + 1}`, zo(X.node))
    )
  ));
}
function Ap(Y, X, ee, te) {
  const ne = X[ee];
  ne != null && ne < oG && (Y[te] = ne);
}
function wG(Y, X, ee, te) {
  typeof X == "number" && te && (xr && xe.log("[Measurements] Adding TTFB"), Y.ttfb = {
    // As per https://developer.mozilla.org/en-US/docs/Web/API/PerformanceResourceTiming/responseStart,
    // responseStart can be 0 if the request is coming straight from the cache.
    // This might lead us to calculate a negative ttfb if we don't use Math.max here.
    //
    // This logic is the same as what is in the web-vitals library to calculate ttfb
    // https://github.com/GoogleChrome/web-vitals/blob/2301de5015e82b09925238a228a0893635854587/src/onTTFB.ts#L92
    // TODO(abhi): We should use the web-vitals library instead of this custom calculation.
    value: Math.max(X - te, 0) * 1e3,
    unit: "millisecond"
  }, typeof ee == "number" && ee <= X && (Y["ttfb.requestTime"] = {
    value: (X - ee) * 1e3,
    unit: "millisecond"
  }));
}
function vG(Y, X, ee, te, ne = "auto.http.browser") {
  if (!kf() || !Y.fetchData)
    return;
  const ie = X(Y.fetchData.url);
  if (Y.endTimestamp && ie) {
    const he = Y.fetchData.__span;
    if (!he)
      return;
    const me = te[he];
    if (me) {
      if (Y.response) {
        cb(me, Y.response.status);
        const ye = Y.response && Y.response.headers && Y.response.headers.get("content-length");
        if (ye) {
          const we = parseInt(ye);
          we > 0 && me.setAttribute("http.response_content_length", we);
        }
      } else
        Y.error && me.setStatus("internal_error");
      me.end(), delete te[he];
    }
    return;
  }
  const oe = ai(), se = cr(), { method: ae, url: ue } = Y.fetchData, le = ie ? ZS({
    name: `${ae} ${ue}`,
    onlyIfParent: !0,
    attributes: {
      url: ue,
      type: "fetch",
      "http.method": ae,
      [va]: ne
    },
    op: "http.client"
  }) : void 0;
  if (le && (Y.fetchData.__span = le.spanContext().spanId, te[le.spanContext().spanId] = le), ee(Y.fetchData.url) && se) {
    const he = Y.args[0];
    Y.args[1] = Y.args[1] || {};
    const me = Y.args[1];
    me.headers = EG(he, se, oe, me, le);
  }
  return le;
}
function EG(Y, X, ee, te, ne) {
  const ie = ne || ee.getSpan(), oe = xo(), { traceId: se, spanId: ae, sampled: ue, dsc: le } = {
    ...oe.getPropagationContext(),
    ...ee.getPropagationContext()
  }, he = ie ? O0(ie) : rb(se, ae, ue), me = FS(
    le || (ie ? rc(ie) : N0(se, X, ee))
  ), ye = te.headers || (typeof Request < "u" && Ns(Y, Request) ? Y.headers : void 0);
  if (ye)
    if (typeof Headers < "u" && Ns(ye, Headers)) {
      const we = new Headers(ye);
      return we.append("sentry-trace", he), me && we.append(Lg, me), we;
    } else if (Array.isArray(ye)) {
      const we = [...ye, ["sentry-trace", he]];
      return me && we.push([Lg, me]), we;
    } else {
      const we = "baggage" in ye ? ye.baggage : void 0, Ee = [];
      return Array.isArray(we) ? Ee.push(...we) : we && Ee.push(we), me && Ee.push(me), {
        ...ye,
        "sentry-trace": he,
        baggage: Ee.length > 0 ? Ee.join(",") : void 0
      };
    }
  else
    return { "sentry-trace": he, baggage: me };
}
const jg = ["localhost", /^\/(?!\/)/], Hg = {
  traceFetch: !0,
  traceXHR: !0,
  enableHTTPTimings: !0,
  // TODO (v8): Remove this property
  tracingOrigins: jg,
  tracePropagationTargets: jg
};
function _G(Y) {
  const {
    traceFetch: X,
    traceXHR: ee,
    // eslint-disable-next-line deprecation/deprecation
    tracePropagationTargets: te,
    // eslint-disable-next-line deprecation/deprecation
    tracingOrigins: ne,
    shouldCreateSpanForRequest: ie,
    enableHTTPTimings: oe
  } = {
    traceFetch: Hg.traceFetch,
    traceXHR: Hg.traceXHR,
    ...Y
  }, se = typeof ie == "function" ? ie : (le) => !0, ae = (le) => IG(le, te || ne), ue = {};
  X && Qy((le) => {
    const he = vG(le, se, ae, ue);
    oe && he && qv(he);
  }), ee && eb((le) => {
    const he = RG(le, se, ae, ue);
    oe && he && qv(he);
  });
}
function AG(Y) {
  return Y.entryType === "resource" && "initiatorType" in Y && typeof Y.nextHopProtocol == "string" && (Y.initiatorType === "fetch" || Y.initiatorType === "xmlhttprequest");
}
function qv(Y) {
  const { url: X } = rn(Y).data || {};
  if (!X || typeof X != "string")
    return;
  const ee = L0("resource", ({ entries: te }) => {
    te.forEach((ne) => {
      AG(ne) && ne.name.endsWith(X) && (TG(ne).forEach((ie) => Y.setAttribute(...ie)), setTimeout(ee));
    });
  });
}
function SG(Y) {
  let X = "unknown", ee = "unknown", te = "";
  for (const ne of Y) {
    if (ne === "/") {
      [X, ee] = Y.split("/");
      break;
    }
    if (!isNaN(Number(ne))) {
      X = te === "h" ? "http" : te, ee = Y.split(te)[1];
      break;
    }
    te += ne;
  }
  return te === Y && (X = te), { name: X, version: ee };
}
function Ii(Y = 0) {
  return ((vi || performance.timeOrigin) + Y) / 1e3;
}
function TG(Y) {
  const { name: X, version: ee } = SG(Y.nextHopProtocol), te = [];
  return te.push(["network.protocol.version", ee], ["network.protocol.name", X]), vi ? [
    ...te,
    ["http.request.redirect_start", Ii(Y.redirectStart)],
    ["http.request.fetch_start", Ii(Y.fetchStart)],
    ["http.request.domain_lookup_start", Ii(Y.domainLookupStart)],
    ["http.request.domain_lookup_end", Ii(Y.domainLookupEnd)],
    ["http.request.connect_start", Ii(Y.connectStart)],
    ["http.request.secure_connection_start", Ii(Y.secureConnectionStart)],
    ["http.request.connection_end", Ii(Y.connectEnd)],
    ["http.request.request_start", Ii(Y.requestStart)],
    ["http.request.response_start", Ii(Y.responseStart)],
    ["http.request.response_end", Ii(Y.responseEnd)]
  ] : te;
}
function IG(Y, X) {
  return Nc(Y, X || jg);
}
function RG(Y, X, ee, te) {
  const ne = Y.xhr, ie = ne && ne[eo];
  if (!kf() || !ne || ne.__sentry_own_request__ || !ie)
    return;
  const oe = X(ie.url);
  if (Y.endTimestamp && oe) {
    const he = ne.__sentry_xhr_span_id__;
    if (!he)
      return;
    const me = te[he];
    me && ie.status_code !== void 0 && (cb(me, ie.status_code), me.end(), delete te[he]);
    return;
  }
  const se = ai(), ae = xo(), ue = oe ? ZS({
    name: `${ie.method} ${ie.url}`,
    onlyIfParent: !0,
    attributes: {
      type: "xhr",
      "http.method": ie.method,
      url: ie.url,
      [va]: "auto.http.browser"
    },
    op: "http.client"
  }) : void 0;
  ue && (ne.__sentry_xhr_span_id__ = ue.spanContext().spanId, te[ne.__sentry_xhr_span_id__] = ue);
  const le = cr();
  if (ne.setRequestHeader && ee(ie.url) && le) {
    const { traceId: he, spanId: me, sampled: ye, dsc: we } = {
      ...ae.getPropagationContext(),
      ...se.getPropagationContext()
    }, Ee = ue ? O0(ue) : rb(he, me, ye), Re = FS(
      we || (ue ? rc(ue) : N0(he, le, se))
    );
    CG(ne, Ee, Re);
  }
  return ue;
}
function CG(Y, X, ee) {
  try {
    Y.setRequestHeader("sentry-trace", X), ee && Y.setRequestHeader(Lg, ee);
  } catch {
  }
}
function PG(Y, X = !0, ee = !0) {
  if (!er || !er.location) {
    xr && xe.warn("Could not initialize routing instrumentation due to invalid location");
    return;
  }
  let te = er.location.href, ne;
  X && (ne = Y({
    name: er.location.pathname,
    // pageload should always start at timeOrigin (and needs to be in s, not ms)
    startTimestamp: vi ? vi / 1e3 : void 0,
    op: "pageload",
    origin: "auto.pageload.browser",
    metadata: { source: "url" }
  })), ee && C0(({ to: ie, from: oe }) => {
    if (oe === void 0 && te && te.indexOf(ie) !== -1) {
      te = void 0;
      return;
    }
    oe !== ie && (te = void 0, ne && (xr && xe.log(`[Tracing] Finishing current transaction with op: ${ne.op}`), ne.end()), ne = Y({
      name: er.location.pathname,
      op: "navigation",
      origin: "auto.navigation.browser",
      metadata: { source: "url" }
    }));
  });
}
const OG = "BrowserTracing", BG = {
  ...Cl,
  markBackgroundTransactions: !0,
  routingInstrumentation: PG,
  startTransactionOnLocationChange: !0,
  startTransactionOnPageLoad: !0,
  enableLongTask: !0,
  _experiments: {},
  ...Hg
};
class NG {
  // This class currently doesn't have a static `id` field like the other integration classes, because it prevented
  // @sentry/tracing from being treeshaken. Tree shakers do not like static fields, because they behave like side effects.
  // TODO: Come up with a better plan, than using static fields on integration classes, and use that plan on all
  // integrations.
  /** Browser Tracing integration options */
  /**
   * @inheritDoc
   */
  constructor(X) {
    this.name = OG, this._hasSetTracePropagationTargets = !1, nq(), xr && (this._hasSetTracePropagationTargets = !!(X && // eslint-disable-next-line deprecation/deprecation
    (X.tracePropagationTargets || X.tracingOrigins))), this.options = {
      ...BG,
      ...X
    }, this.options._experiments.enableLongTask !== void 0 && (this.options.enableLongTask = this.options._experiments.enableLongTask), X && !X.tracePropagationTargets && X.tracingOrigins && (this.options.tracePropagationTargets = X.tracingOrigins), this._collectWebVitals = aG(), this.options.enableLongTask && cG(), this.options._experiments.enableInteractions && uG();
  }
  /**
   * @inheritDoc
   */
  setupOnce(X, ee) {
    this._getCurrentHub = ee;
    const te = ee().getClient(), ne = te && te.getOptions(), {
      routingInstrumentation: ie,
      startTransactionOnLocationChange: oe,
      startTransactionOnPageLoad: se,
      markBackgroundTransactions: ae,
      traceFetch: ue,
      traceXHR: le,
      shouldCreateSpanForRequest: he,
      enableHTTPTimings: me,
      _experiments: ye
    } = this.options, we = ne && ne.tracePropagationTargets, Ee = we || this.options.tracePropagationTargets;
    xr && this._hasSetTracePropagationTargets && we && xe.warn(
      "[Tracing] The `tracePropagationTargets` option was set in the BrowserTracing integration and top level `Sentry.init`. The top level `Sentry.init` value is being used."
    ), ie(
      (Re) => {
        const Ue = this._createRouteTransaction(Re);
        return this.options._experiments.onStartRouteTransaction && this.options._experiments.onStartRouteTransaction(Ue, Re, ee), Ue;
      },
      se,
      oe
    ), ae && Vq(), ye.enableInteractions && this._registerInteractionListener(), _G({
      traceFetch: ue,
      traceXHR: le,
      tracePropagationTargets: Ee,
      shouldCreateSpanForRequest: he,
      enableHTTPTimings: me
    });
  }
  /** Create routing idle transaction. */
  _createRouteTransaction(X) {
    if (!this._getCurrentHub) {
      xr && xe.warn(`[Tracing] Did not create ${X.op} transaction because _getCurrentHub is invalid.`);
      return;
    }
    const ee = this._getCurrentHub(), { beforeNavigate: te, idleTimeout: ne, finalTimeout: ie, heartbeatInterval: oe } = this.options, se = X.op === "pageload";
    let ae;
    if (se) {
      const ye = se ? Gv("sentry-trace") : "", we = se ? Gv("baggage") : void 0, { traceId: Ee, dsc: Re, parentSpanId: Ue, sampled: Me } = oz(ye, we);
      ae = {
        traceId: Ee,
        parentSpanId: Ue,
        parentSampled: Me,
        ...X,
        metadata: {
          // eslint-disable-next-line deprecation/deprecation
          ...X.metadata,
          dynamicSamplingContext: Re
        },
        trimEnd: !0
      };
    } else
      ae = {
        trimEnd: !0,
        ...X
      };
    const ue = typeof te == "function" ? te(ae) : ae, le = ue === void 0 ? { ...ae, sampled: !1 } : ue;
    le.metadata = le.name !== ae.name ? (
      // eslint-disable-next-line deprecation/deprecation
      { ...le.metadata, source: "custom" }
    ) : (
      // eslint-disable-next-line deprecation/deprecation
      le.metadata
    ), this._latestRouteName = le.name, this._latestRouteSource = kG(le), le.sampled === !1 && xr && xe.log(`[Tracing] Will not send ${le.op} transaction because of beforeNavigate.`), xr && xe.log(`[Tracing] Starting ${le.op} transaction on scope`);
    const { location: he } = er, me = kv(
      ee,
      le,
      ne,
      ie,
      !0,
      { location: he },
      // for use in the tracesSampler
      oe,
      se
      // should wait for finish signal if it's a pageload transaction
    );
    return se && (er.document.addEventListener("readystatechange", () => {
      ["interactive", "complete"].includes(er.document.readyState) && me.sendAutoFinishSignal();
    }), ["interactive", "complete"].includes(er.document.readyState) && me.sendAutoFinishSignal()), me.registerBeforeFinishCallback((ye) => {
      this._collectWebVitals(), hG(ye);
    }), me;
  }
  /** Start listener for interaction transactions */
  _registerInteractionListener() {
    let X;
    const ee = () => {
      const { idleTimeout: te, finalTimeout: ne, heartbeatInterval: ie } = this.options, oe = "ui.action.click", se = Mc();
      if (se && se.op && ["navigation", "pageload"].includes(se.op)) {
        xr && xe.warn(
          `[Tracing] Did not create ${oe} transaction because a pageload or navigation transaction is in progress.`
        );
        return;
      }
      if (X && (X.setFinishReason("interactionInterrupted"), X.end(), X = void 0), !this._getCurrentHub) {
        xr && xe.warn(`[Tracing] Did not create ${oe} transaction because _getCurrentHub is invalid.`);
        return;
      }
      if (!this._latestRouteName) {
        xr && xe.warn(`[Tracing] Did not create ${oe} transaction because _latestRouteName is missing.`);
        return;
      }
      const ae = this._getCurrentHub(), { location: ue } = er, le = {
        name: this._latestRouteName,
        op: oe,
        trimEnd: !0,
        data: {
          [Po]: this._latestRouteSource || "url"
        }
      };
      X = kv(
        ae,
        le,
        te,
        ne,
        !0,
        { location: ue },
        // for use in the tracesSampler
        ie
      );
    };
    ["click"].forEach((te) => {
      addEventListener(te, ee, { once: !1, capture: !0 });
    });
  }
}
function Gv(Y) {
  const X = lH(`meta[name=${Y}]`);
  return X ? X.getAttribute("content") : void 0;
}
function kG(Y) {
  const X = Y.attributes && Y.attributes[Po], ee = Y.data && Y.data[Po], te = Y.metadata && Y.metadata.source;
  return X || ee || te;
}
const or = zt;
let zg = 0;
function v5$2() {
  return zg > 0;
}
function MG() {
  zg++, setTimeout(() => {
    zg--;
  });
}
function ic(Y, X = {}, ee) {
  if (typeof Y != "function")
    return Y;
  try {
    const ne = Y.__sentry_wrapped__;
    if (ne)
      return ne;
    if (Zy(Y))
      return Y;
  } catch {
    return Y;
  }
  const te = function() {
    const ne = Array.prototype.slice.call(arguments);
    try {
      ee && typeof ee == "function" && ee.apply(this, arguments);
      const ie = ne.map((oe) => ic(oe, X));
      return Y.apply(this, ie);
    } catch (ie) {
      throw MG(), Bz((oe) => {
        oe.addEventProcessor((se) => (X.mechanism && (Cg(se, void 0, void 0), Qu(se, X.mechanism)), se.extra = {
          ...se.extra,
          arguments: ne
        }, se)), ab(ie);
      }), ie;
    }
  };
  try {
    for (const ne in Y)
      Object.prototype.hasOwnProperty.call(Y, ne) && (te[ne] = Y[ne]);
  } catch {
  }
  AS(te, Y), Go(Y, "__sentry_wrapped__", te);
  try {
    Object.getOwnPropertyDescriptor(te, "name").configurable && Object.defineProperty(te, "name", {
      get() {
        return Y.name;
      }
    });
  } catch {
  }
  return te;
}
const vs = typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__;
function E5(Y, X) {
  const ee = pb(Y, X), te = {
    type: X && X.name,
    value: DG(X)
  };
  return ee.length && (te.stacktrace = { frames: ee }), te.type === void 0 && te.value === "" && (te.value = "Unrecoverable error caught"), te;
}
function LG(Y, X, ee, te) {
  const ne = cr(), ie = ne && ne.getOptions().normalizeDepth, oe = {
    exception: {
      values: [
        {
          type: I0(X) ? X.constructor.name : te ? "UnhandledRejection" : "Error",
          value: HG(X, { isUnhandledRejection: te })
        }
      ]
    },
    extra: {
      __serialized__: kS(X, ie)
    }
  };
  if (ee) {
    const se = pb(Y, ee);
    se.length && (oe.exception.values[0].stacktrace = { frames: se });
  }
  return oe;
}
function Sp(Y, X) {
  return {
    exception: {
      values: [E5(Y, X)]
    }
  };
}
function pb(Y, X) {
  const ee = X.stacktrace || X.stack || "", te = $G(X);
  try {
    return Y(ee, te);
  } catch {
  }
  return [];
}
const FG = /Minified React error #\d+;/i;
function $G(Y) {
  if (Y) {
    if (typeof Y.framesToPop == "number")
      return Y.framesToPop;
    if (FG.test(Y.message))
      return 1;
  }
  return 0;
}
function DG(Y) {
  const X = Y && Y.message;
  return X ? X.error && typeof X.error.message == "string" ? X.error.message : X : "No error message";
}
function UG(Y, X, ee, te) {
  const ne = ee && ee.syntheticException || void 0, ie = gb(Y, X, ne, te);
  return Qu(ie), ie.level = "error", ee && ee.event_id && (ie.event_id = ee.event_id), tc(ie);
}
function jG(Y, X, ee = "info", te, ne) {
  const ie = te && te.syntheticException || void 0, oe = qg(Y, X, ie, ne);
  return oe.level = ee, te && te.event_id && (oe.event_id = te.event_id), tc(oe);
}
function gb(Y, X, ee, te, ne) {
  let ie;
  if (Ky(X) && X.error)
    return Sp(Y, X.error);
  if (cv(X) || tH(X)) {
    const oe = X;
    if ("stack" in X)
      ie = Sp(Y, X);
    else {
      const se = oe.name || (cv(oe) ? "DOMError" : "DOMException"), ae = oe.message ? `${se}: ${oe.message}` : se;
      ie = qg(Y, ae, ee, te), Cg(ie, ae);
    }
    return "code" in oe && (ie.tags = { ...ie.tags, "DOMException.code": `${oe.code}` }), ie;
  }
  return bS(X) ? Sp(Y, X) : ec$2(X) || I0(X) ? (ie = LG(Y, X, ee, ne), Qu(ie, {
    synthetic: !0
  }), ie) : (ie = qg(Y, X, ee, te), Cg(ie, `${X}`, void 0), Qu(ie, {
    synthetic: !0
  }), ie);
}
function qg(Y, X, ee, te) {
  const ne = {};
  if (te && ee) {
    const ie = pb(Y, ee);
    ie.length && (ne.exception = {
      values: [{ value: X, stacktrace: { frames: ie } }]
    });
  }
  if (Jy(X)) {
    const { __sentry_template_string__: ie, __sentry_template_values__: oe } = X;
    return ne.logentry = {
      message: ie,
      params: oe
    }, ne;
  }
  return ne.message = X, ne;
}
function HG(Y, { isUnhandledRejection: X }) {
  const ee = wH(Y), te = X ? "promise rejection" : "exception";
  return Ky(Y) ? `Event \`ErrorEvent\` captured as ${te} with message \`${Y.message}\`` : I0(Y) ? `Event \`${zG(Y)}\` (type=${Y.type}) captured as ${te}` : `Object captured as ${te} with keys: ${ee}`;
}
function zG(Y) {
  try {
    const X = Object.getPrototypeOf(Y);
    return X ? X.constructor.name : void 0;
  } catch {
  }
}
function qG(Y, {
  metadata: X,
  tunnel: ee,
  dsn: te
}) {
  const ne = {
    event_id: Y.event_id,
    sent_at: (/* @__PURE__ */ new Date()).toISOString(),
    ...X && X.sdk && {
      sdk: {
        name: X.sdk.name,
        version: X.sdk.version
      }
    },
    ...!!ee && !!te && { dsn: Pf(te) }
  }, ie = GG(Y);
  return ea(ne, [ie]);
}
function GG(Y) {
  return [{
    type: "user_report"
  }, Y];
}
class VG extends wq {
  /**
   * Creates a new Browser SDK instance.
   *
   * @param options Configuration options for this SDK.
   */
  constructor(X) {
    const ee = or.SENTRY_SDK_SOURCE || HH();
    Bq(X, "browser", ["browser"], ee), super(X), X.sendClientReports && or.document && or.document.addEventListener("visibilitychange", () => {
      or.document.visibilityState === "hidden" && this._flushOutcomes();
    });
  }
  /**
   * @inheritDoc
   */
  eventFromException(X, ee) {
    return UG(this._options.stackParser, X, ee, this._options.attachStacktrace);
  }
  /**
   * @inheritDoc
   */
  eventFromMessage(X, ee = "info", te) {
    return jG(this._options.stackParser, X, ee, te, this._options.attachStacktrace);
  }
  /**
   * Sends user feedback to Sentry.
   */
  captureUserFeedback(X) {
    if (!this._isEnabled()) {
      vs && xe.warn("SDK not enabled, will not capture user feedback.");
      return;
    }
    const ee = qG(X, {
      metadata: this.getSdkMetadata(),
      dsn: this.getDsn(),
      tunnel: this.getOptions().tunnel
    });
    this._sendEnvelope(ee);
  }
  /**
   * @inheritDoc
   */
  _prepareEvent(X, ee, te) {
    return X.platform = X.platform || "javascript", super._prepareEvent(X, ee, te);
  }
  /**
   * Sends client reports as an envelope.
   */
  _flushOutcomes() {
    const X = this._clearOutcomes();
    if (X.length === 0) {
      vs && xe.log("No outcomes to send");
      return;
    }
    if (!this._dsn) {
      vs && xe.log("No dsn provided, will not send outcomes");
      return;
    }
    vs && xe.log("Sending outcomes:", X);
    const ee = dz(X, this._options.tunnel && Pf(this._dsn));
    this._sendEnvelope(ee);
  }
}
let su;
function WG() {
  if (su)
    return su;
  if (Ng(or.fetch))
    return su = or.fetch.bind(or);
  const Y = or.document;
  let X = or.fetch;
  if (Y && typeof Y.createElement == "function")
    try {
      const ee = Y.createElement("iframe");
      ee.hidden = !0, Y.head.appendChild(ee);
      const te = ee.contentWindow;
      te && te.fetch && (X = te.fetch), Y.head.removeChild(ee);
    } catch (ee) {
      vs && xe.warn("Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ", ee);
    }
  return su = X.bind(or);
}
function KG() {
  su = void 0;
}
function JG(Y, X = WG()) {
  let ee = 0, te = 0;
  function ne(ie) {
    const oe = ie.body.length;
    ee += oe, te++;
    const se = {
      body: ie.body,
      method: "POST",
      referrerPolicy: "origin",
      headers: Y.headers,
      // Outgoing requests are usually cancelled when navigating to a different page, causing a "TypeError: Failed to
      // fetch" error and sending a "network_error" client-outcome - in Chrome, the request status shows "(cancelled)".
      // The `keepalive` flag keeps outgoing requests alive, even when switching pages. We want this since we're
      // frequently sending events right before the user is switching pages (eg. whenfinishing navigation transactions).
      // Gotchas:
      // - `keepalive` isn't supported by Firefox
      // - As per spec (https://fetch.spec.whatwg.org/#http-network-or-cache-fetch):
      //   If the sum of contentLength and inflightKeepaliveBytes is greater than 64 kibibytes, then return a network error.
      //   We will therefore only activate the flag when we're below that limit.
      // There is also a limit of requests that can be open at the same time, so we also limit this to 15
      // See https://github.com/getsentry/sentry-javascript/pull/7553 for details
      keepalive: ee <= 6e4 && te < 15,
      ...Y.fetchOptions
    };
    try {
      return X(Y.url, se).then((ae) => (ee -= oe, te--, {
        statusCode: ae.status,
        headers: {
          "x-sentry-rate-limits": ae.headers.get("X-Sentry-Rate-Limits"),
          "retry-after": ae.headers.get("Retry-After")
        }
      }));
    } catch (ae) {
      return KG(), ee -= oe, te--, tb(ae);
    }
  }
  return a5(Y, ne);
}
const YG = 4;
function XG(Y) {
  function X(ee) {
    return new Dn((te, ne) => {
      const ie = new XMLHttpRequest();
      ie.onerror = ne, ie.onreadystatechange = () => {
        ie.readyState === YG && te({
          statusCode: ie.status,
          headers: {
            "x-sentry-rate-limits": ie.getResponseHeader("X-Sentry-Rate-Limits"),
            "retry-after": ie.getResponseHeader("Retry-After")
          }
        });
      }, ie.open("POST", Y.url);
      for (const oe in Y.headers)
        Object.prototype.hasOwnProperty.call(Y.headers, oe) && ie.setRequestHeader(oe, Y.headers[oe]);
      ie.send(ee.body);
    });
  }
  return a5(Y, X);
}
const $0 = "?", ZG = 30, QG = 40, eV = 50;
function mb(Y, X, ee, te) {
  const ne = {
    filename: Y,
    function: X,
    in_app: !0
    // All browser frames are considered in_app
  };
  return ee !== void 0 && (ne.lineno = ee), te !== void 0 && (ne.colno = te), ne;
}
const tV = /^\s*at (?:(.+?\)(?: \[.+\])?|.*?) ?\((?:address at )?)?(?:async )?((?:<anonymous>|[-a-z]+:|.*bundle|\/)?.*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i, rV = /\((\S*)(?::(\d+))(?::(\d+))\)/, nV = (Y) => {
  const X = tV.exec(Y);
  if (X) {
    if (X[2] && X[2].indexOf("eval") === 0) {
      const ne = rV.exec(X[2]);
      ne && (X[2] = ne[1], X[3] = ne[2], X[4] = ne[3]);
    }
    const [ee, te] = _5(X[1] || $0, X[2]);
    return mb(te, ee, X[3] ? +X[3] : void 0, X[4] ? +X[4] : void 0);
  }
}, iV = [ZG, nV], sV = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)?((?:[-a-z]+)?:\/.*?|\[native code\]|[^@]*(?:bundle|\d+\.js)|\/[\w\-. /=]+)(?::(\d+))?(?::(\d+))?\s*$/i, oV = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i, aV = (Y) => {
  const X = sV.exec(Y);
  if (X) {
    if (X[3] && X[3].indexOf(" > eval") > -1) {
      const ne = oV.exec(X[3]);
      ne && (X[1] = X[1] || "eval", X[3] = ne[1], X[4] = ne[2], X[5] = "");
    }
    let ee = X[3], te = X[1] || $0;
    return [te, ee] = _5(te, ee), mb(ee, te, X[4] ? +X[4] : void 0, X[5] ? +X[5] : void 0);
  }
}, cV = [eV, aV], uV = /^\s*at (?:((?:\[object object\])?.+) )?\(?((?:[-a-z]+):.*?):(\d+)(?::(\d+))?\)?\s*$/i, fV = (Y) => {
  const X = uV.exec(Y);
  return X ? mb(X[2], X[1] || $0, +X[3], X[4] ? +X[4] : void 0) : void 0;
}, lV = [QG, fV], dV = [iV, cV, lV], hV = IS(...dV), _5 = (Y, X) => {
  const ee = Y.indexOf("safari-extension") !== -1, te = Y.indexOf("safari-web-extension") !== -1;
  return ee || te ? [
    Y.indexOf("@") !== -1 ? Y.split("@")[0] : $0,
    ee ? `safari-extension:${X}` : `safari-web-extension:${X}`
  ] : [Y, X];
}, ul = 1024, A5 = "Breadcrumbs", pV = (Y = {}) => {
  const X = {
    console: !0,
    dom: !0,
    fetch: !0,
    history: !0,
    sentry: !0,
    xhr: !0,
    ...Y
  };
  return {
    name: A5,
    // TODO v8: Remove this
    setupOnce() {
    },
    // eslint-disable-line @typescript-eslint/no-empty-function
    setup(ee) {
      X.console && AH(yV(ee)), X.dom && PS(mV(ee, X.dom)), X.xhr && eb(bV(ee)), X.fetch && Qy(xV(ee)), X.history && C0(wV(ee)), X.sentry && ee.on && ee.on("beforeSendEvent", gV(ee));
    }
  };
}, S5 = pV;
wo(A5, S5);
function gV(Y) {
  return function(X) {
    cr() === Y && ho(
      {
        category: `sentry.${X.type === "transaction" ? "transaction" : "event"}`,
        event_id: X.event_id,
        level: X.level,
        message: Zs(X)
      },
      {
        event: X
      }
    );
  };
}
function mV(Y, X) {
  return function(ee) {
    if (cr() !== Y)
      return;
    let te, ne, ie = typeof X == "object" ? X.serializeAttribute : void 0, oe = typeof X == "object" && typeof X.maxStringLength == "number" ? X.maxStringLength : void 0;
    oe && oe > ul && (vs && xe.warn(
      `\`dom.maxStringLength\` cannot exceed ${ul}, but a value of ${oe} was configured. Sentry will use ${ul} instead.`
    ), oe = ul), typeof ie == "string" && (ie = [ie]);
    try {
      const ae = ee.event, ue = vV(ae) ? ae.target : ae;
      te = zo(ue, { keyAttrs: ie, maxStringLength: oe }), ne = ES(ue);
    } catch {
      te = "<unknown>";
    }
    if (te.length === 0)
      return;
    const se = {
      category: `ui.${ee.name}`,
      message: te
    };
    ne && (se.data = { "ui.component_name": ne }), ho(se, {
      event: ee.event,
      name: ee.name,
      global: ee.global
    });
  };
}
function yV(Y) {
  return function(X) {
    if (cr() !== Y)
      return;
    const ee = {
      category: "console",
      data: {
        arguments: X.args,
        logger: "console"
      },
      level: ZH(X.level),
      message: uv(X.args, " ")
    };
    if (X.level === "assert")
      if (X.args[0] === !1)
        ee.message = `Assertion failed: ${uv(X.args.slice(1), " ") || "console.assert"}`, ee.data.arguments = X.args.slice(1);
      else
        return;
    ho(ee, {
      input: X.args,
      level: X.level
    });
  };
}
function bV(Y) {
  return function(X) {
    if (cr() !== Y)
      return;
    const { startTimestamp: ee, endTimestamp: te } = X, ne = X.xhr[eo];
    if (!ee || !te || !ne)
      return;
    const { method: ie, url: oe, status_code: se, body: ae } = ne, ue = {
      method: ie,
      url: oe,
      status_code: se
    }, le = {
      xhr: X.xhr,
      input: ae,
      startTimestamp: ee,
      endTimestamp: te
    };
    ho(
      {
        category: "xhr",
        data: ue,
        type: "http"
      },
      le
    );
  };
}
function xV(Y) {
  return function(X) {
    if (cr() !== Y)
      return;
    const { startTimestamp: ee, endTimestamp: te } = X;
    if (te && !(X.fetchData.url.match(/sentry_key/) && X.fetchData.method === "POST"))
      if (X.error) {
        const ne = X.fetchData, ie = {
          data: X.error,
          input: X.args,
          startTimestamp: ee,
          endTimestamp: te
        };
        ho(
          {
            category: "fetch",
            data: ne,
            level: "error",
            type: "http"
          },
          ie
        );
      } else {
        const ne = X.response, ie = {
          ...X.fetchData,
          status_code: ne && ne.status
        }, oe = {
          input: X.args,
          response: ne,
          startTimestamp: ee,
          endTimestamp: te
        };
        ho(
          {
            category: "fetch",
            data: ie,
            type: "http"
          },
          oe
        );
      }
  };
}
function wV(Y) {
  return function(X) {
    if (cr() !== Y)
      return;
    let ee = X.from, te = X.to;
    const ne = Rl(or.location.href);
    let ie = ee ? Rl(ee) : void 0;
    const oe = Rl(te);
    (!ie || !ie.path) && (ie = ne), ne.protocol === oe.protocol && ne.host === oe.host && (te = oe.relative), ne.protocol === ie.protocol && ne.host === ie.host && (ee = ie.relative), ho({
      category: "navigation",
      data: {
        from: ee,
        to: te
      }
    });
  };
}
function vV(Y) {
  return !!Y && !!Y.target;
}
const T5 = "Dedupe", EV = () => {
  let Y;
  return {
    name: T5,
    // TODO v8: Remove this
    setupOnce() {
    },
    // eslint-disable-line @typescript-eslint/no-empty-function
    processEvent(X) {
      if (X.type)
        return X;
      try {
        if (_V(X, Y))
          return vs && xe.warn("Event dropped due to being a duplicate of previously captured event."), null;
      } catch {
      }
      return Y = X;
    }
  };
}, I5 = EV;
wo(T5, I5);
function _V(Y, X) {
  return X ? !!(AV(Y, X) || SV(Y, X)) : !1;
}
function AV(Y, X) {
  const ee = Y.message, te = X.message;
  return !(!ee && !te || ee && !te || !ee && te || ee !== te || !C5(Y, X) || !R5(Y, X));
}
function SV(Y, X) {
  const ee = Vv(X), te = Vv(Y);
  return !(!ee || !te || ee.type !== te.type || ee.value !== te.value || !C5(Y, X) || !R5(Y, X));
}
function R5(Y, X) {
  let ee = Wv(Y), te = Wv(X);
  if (!ee && !te)
    return !0;
  if (ee && !te || !ee && te || (ee = ee, te = te, te.length !== ee.length))
    return !1;
  for (let ne = 0; ne < te.length; ne++) {
    const ie = te[ne], oe = ee[ne];
    if (ie.filename !== oe.filename || ie.lineno !== oe.lineno || ie.colno !== oe.colno || ie.function !== oe.function)
      return !1;
  }
  return !0;
}
function C5(Y, X) {
  let ee = Y.fingerprint, te = X.fingerprint;
  if (!ee && !te)
    return !0;
  if (ee && !te || !ee && te)
    return !1;
  ee = ee, te = te;
  try {
    return ee.join("") === te.join("");
  } catch {
    return !1;
  }
}
function Vv(Y) {
  return Y.exception && Y.exception.values && Y.exception.values[0];
}
function Wv(Y) {
  const X = Y.exception;
  if (X)
    try {
      return X.values[0].stacktrace.frames;
    } catch {
      return;
    }
}
const P5 = "GlobalHandlers", TV = (Y = {}) => {
  const X = {
    onerror: !0,
    onunhandledrejection: !0,
    ...Y
  };
  return {
    name: P5,
    setupOnce() {
      Error.stackTraceLimit = 50;
    },
    setup(ee) {
      X.onerror && (IV$2(ee), Kv("onerror")), X.onunhandledrejection && (RV(ee), Kv("onunhandledrejection"));
    }
  };
}, O5 = TV;
wo(
  P5,
  O5
);
function IV$2(Y) {
  BS((X) => {
    const { stackParser: ee, attachStacktrace: te } = N5();
    if (cr() !== Y || v5$2())
      return;
    const { msg: ne, url: ie, line: oe, column: se, error: ae } = X, ue = ae === void 0 && Yi(ne) ? OV(ne, ie, oe, se) : B5(
      gb(ee, ae || ne, void 0, te, !1),
      ie,
      oe,
      se
    );
    ue.level = "error", GS(ue, {
      originalException: ae,
      mechanism: {
        handled: !1,
        type: "onerror"
      }
    });
  });
}
function RV(Y) {
  NS((X) => {
    const { stackParser: ee, attachStacktrace: te } = N5();
    if (cr() !== Y || v5$2())
      return;
    const ne = CV(X), ie = Yy(ne) ? PV(ne) : gb(ee, ne, void 0, te, !0);
    ie.level = "error", GS(ie, {
      originalException: ne,
      mechanism: {
        handled: !1,
        type: "onunhandledrejection"
      }
    });
  });
}
function CV(Y) {
  if (Yy(Y))
    return Y;
  const X = Y;
  try {
    if ("reason" in X)
      return X.reason;
    if ("detail" in X && "reason" in X.detail)
      return X.detail.reason;
  } catch {
  }
  return Y;
}
function PV(Y) {
  return {
    exception: {
      values: [
        {
          type: "UnhandledRejection",
          // String() is needed because the Primitive type includes symbols (which can't be automatically stringified)
          value: `Non-Error promise rejection captured with value: ${String(Y)}`
        }
      ]
    }
  };
}
function OV(Y, X, ee, te) {
  const ne = /^(?:[Uu]ncaught (?:exception: )?)?(?:((?:Eval|Internal|Range|Reference|Syntax|Type|URI|)Error): )?(.*)$/i;
  let ie = Ky(Y) ? Y.message : Y, oe = "Error";
  const se = ie.match(ne);
  return se && (oe = se[1], ie = se[2]), B5({
    exception: {
      values: [
        {
          type: oe,
          value: ie
        }
      ]
    }
  }, X, ee, te);
}
function B5(Y, X, ee, te) {
  const ne = Y.exception = Y.exception || {}, ie = ne.values = ne.values || [], oe = ie[0] = ie[0] || {}, se = oe.stacktrace = oe.stacktrace || {}, ae = se.frames = se.frames || [], ue = isNaN(parseInt(te, 10)) ? void 0 : te, le = isNaN(parseInt(ee, 10)) ? void 0 : ee, he = Yi(X) && X.length > 0 ? X : fH();
  return ae.length === 0 && ae.push({
    colno: ue,
    filename: he,
    function: "?",
    in_app: !0,
    lineno: le
  }), Y;
}
function Kv(Y) {
  vs && xe.log(`Global Handler attached: ${Y}`);
}
function N5() {
  const Y = cr();
  return Y && Y.getOptions() || {
    stackParser: () => [],
    attachStacktrace: !1
  };
}
const k5 = "HttpContext", BV = () => ({
  name: k5,
  // TODO v8: Remove this
  setupOnce() {
  },
  // eslint-disable-line @typescript-eslint/no-empty-function
  preprocessEvent(Y) {
    if (!or.navigator && !or.location && !or.document)
      return;
    const X = Y.request && Y.request.url || or.location && or.location.href, { referrer: ee } = or.document || {}, { userAgent: te } = or.navigator || {}, ne = {
      ...Y.request && Y.request.headers,
      ...ee && { Referer: ee },
      ...te && { "User-Agent": te }
    }, ie = { ...Y.request, ...X && { url: X }, headers: ne };
    Y.request = ie;
  }
}), M5 = BV;
wo(k5, M5);
const NV = "cause", kV = 5, L5 = "LinkedErrors", MV = (Y = {}) => {
  const X = Y.limit || kV, ee = Y.key || NV;
  return {
    name: L5,
    // TODO v8: Remove this
    setupOnce() {
    },
    // eslint-disable-line @typescript-eslint/no-empty-function
    preprocessEvent(te, ne, ie) {
      const oe = ie.getOptions();
      oH(
        // This differs from the LinkedErrors integration in core by using a different exceptionFromError function
        E5,
        oe.stackParser,
        oe.maxValueLength,
        ee,
        X,
        te,
        ne
      );
    }
  };
}, F5 = MV;
wo(L5, F5);
const LV = [
  "EventTarget",
  "Window",
  "Node",
  "ApplicationCache",
  "AudioTrackList",
  "BroadcastChannel",
  "ChannelMergerNode",
  "CryptoOperation",
  "EventSource",
  "FileReader",
  "HTMLUnknownElement",
  "IDBDatabase",
  "IDBRequest",
  "IDBTransaction",
  "KeyOperation",
  "MediaController",
  "MessagePort",
  "ModalWindow",
  "Notification",
  "SVGElementInstance",
  "Screen",
  "SharedWorker",
  "TextTrack",
  "TextTrackCue",
  "TextTrackList",
  "WebSocket",
  "WebSocketWorker",
  "Worker",
  "XMLHttpRequest",
  "XMLHttpRequestEventTarget",
  "XMLHttpRequestUpload"
], $5 = "TryCatch", FV = (Y = {}) => {
  const X = {
    XMLHttpRequest: !0,
    eventTarget: !0,
    requestAnimationFrame: !0,
    setInterval: !0,
    setTimeout: !0,
    ...Y
  };
  return {
    name: $5,
    // TODO: This currently only works for the first client this is setup
    // We may want to adjust this to check for client etc.
    setupOnce() {
      X.setTimeout && Yr(or, "setTimeout", Jv), X.setInterval && Yr(or, "setInterval", Jv), X.requestAnimationFrame && Yr(or, "requestAnimationFrame", $V), X.XMLHttpRequest && "XMLHttpRequest" in or && Yr(XMLHttpRequest.prototype, "send", DV);
      const ee = X.eventTarget;
      ee && (Array.isArray(ee) ? ee : LV).forEach(UV);
    }
  };
}, D5 = FV;
wo(
  $5,
  D5
);
function Jv(Y) {
  return function(...X) {
    const ee = X[0];
    return X[0] = ic(ee, {
      mechanism: {
        data: { function: ks(Y) },
        handled: !1,
        type: "instrument"
      }
    }), Y.apply(this, X);
  };
}
function $V(Y) {
  return function(X) {
    return Y.apply(this, [
      ic(X, {
        mechanism: {
          data: {
            function: "requestAnimationFrame",
            handler: ks(Y)
          },
          handled: !1,
          type: "instrument"
        }
      })
    ]);
  };
}
function DV(Y) {
  return function(...X) {
    const ee = this;
    return ["onload", "onerror", "onprogress", "onreadystatechange"].forEach((te) => {
      te in ee && typeof ee[te] == "function" && Yr(ee, te, function(ne) {
        const ie = {
          mechanism: {
            data: {
              function: te,
              handler: ks(ne)
            },
            handled: !1,
            type: "instrument"
          }
        }, oe = Zy(ne);
        return oe && (ie.mechanism.data.handler = ks(oe)), ic(ne, ie);
      });
    }), Y.apply(this, X);
  };
}
function UV(Y) {
  const X = or, ee = X[Y] && X[Y].prototype;
  !ee || !ee.hasOwnProperty || !ee.hasOwnProperty("addEventListener") || (Yr(ee, "addEventListener", function(te) {
    return function(ne, ie, oe) {
      try {
        typeof ie.handleEvent == "function" && (ie.handleEvent = ic(ie.handleEvent, {
          mechanism: {
            data: {
              function: "handleEvent",
              handler: ks(ie),
              target: Y
            },
            handled: !1,
            type: "instrument"
          }
        }));
      } catch {
      }
      return te.apply(this, [
        ne,
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        ic(ie, {
          mechanism: {
            data: {
              function: "addEventListener",
              handler: ks(ie),
              target: Y
            },
            handled: !1,
            type: "instrument"
          }
        }),
        oe
      ]);
    };
  }), Yr(
    ee,
    "removeEventListener",
    function(te) {
      return function(ne, ie, oe) {
        const se = ie;
        try {
          const ae = se && se.__sentry_wrapped__;
          ae && te.call(this, ne, ae, oe);
        } catch {
        }
        return te.call(this, ne, se, oe);
      };
    }
  ));
}
const jV = [
  u5(),
  l5(),
  D5(),
  S5(),
  O5(),
  F5(),
  I5(),
  M5()
];
function HV(Y) {
  return [
    // eslint-disable-next-line deprecation/deprecation
    ...jV
  ];
}
function zV(Y = {}) {
  Y.defaultIntegrations === void 0 && (Y.defaultIntegrations = HV()), Y.release === void 0 && (typeof __SENTRY_RELEASE__ == "string" && (Y.release = __SENTRY_RELEASE__), or.SENTRY_RELEASE && or.SENTRY_RELEASE.id && (Y.release = or.SENTRY_RELEASE.id)), Y.autoSessionTracking === void 0 && (Y.autoSessionTracking = !0), Y.sendClientReports === void 0 && (Y.sendClientReports = !0);
  const X = {
    ...Y,
    stackParser: EH(Y.stackParser || hV),
    integrations: pq(Y),
    transport: Y.transport || (OS() ? JG : XG)
  };
  Aq(VG, X), Y.autoSessionTracking && qV();
}
function qV() {
  if (typeof or.document > "u") {
    vs && xe.warn("Session tracking in non-browser environment with @sentry/browser is not supported.");
    return;
  }
  Iv({ ignoreDuration: !0 }), Rv(), C0(({ from: Y, to: X }) => {
    Y !== void 0 && Y !== X && (Iv({ ignoreDuration: !0 }), Rv());
  });
}
const fr = zt, yb = "sentryReplaySession", GV = "replay_event", bb = "Unable to send Replay", VV = 3e5, WV = 9e5, KV = 5e3, JV = 5500, YV = 6e4, XV = 5e3, ZV = 3, Yv = 15e4, fl = 5e3, QV = 3e3, eW = 300, xb = 2e7, tW = 4999, rW = 15e3, Xv = 36e5;
function nW(Y, X) {
  return Y ?? X();
}
function ad(Y) {
  let X, ee = Y[0], te = 1;
  for (; te < Y.length; ) {
    const ne = Y[te], ie = Y[te + 1];
    if (te += 2, (ne === "optionalAccess" || ne === "optionalCall") && ee == null)
      return;
    ne === "access" || ne === "optionalAccess" ? (X = ee, ee = ie(ee)) : (ne === "call" || ne === "optionalCall") && (ee = ie((...oe) => ee.call(X, ...oe)), X = void 0);
  }
  return ee;
}
var jr;
(function(Y) {
  Y[Y.Document = 0] = "Document", Y[Y.DocumentType = 1] = "DocumentType", Y[Y.Element = 2] = "Element", Y[Y.Text = 3] = "Text", Y[Y.CDATA = 4] = "CDATA", Y[Y.Comment = 5] = "Comment";
})(jr || (jr = {}));
function iW(Y) {
  return Y.nodeType === Y.ELEMENT_NODE;
}
function gu(Y) {
  const X = ad([Y, "optionalAccess", (ee) => ee.host]);
  return ad([X, "optionalAccess", (ee) => ee.shadowRoot]) === Y;
}
function mu(Y) {
  return Object.prototype.toString.call(Y) === "[object ShadowRoot]";
}
function sW(Y) {
  return Y.includes(" background-clip: text;") && !Y.includes(" -webkit-background-clip: text;") && (Y = Y.replace(" background-clip: text;", " -webkit-background-clip: text; background-clip: text;")), Y;
}
function oW(Y) {
  const { cssText: X } = Y;
  if (X.split('"').length < 3)
    return X;
  const ee = ["@import", `url(${JSON.stringify(Y.href)})`];
  return Y.layerName === "" ? ee.push("layer") : Y.layerName && ee.push(`layer(${Y.layerName})`), Y.supportsText && ee.push(`supports(${Y.supportsText})`), Y.media.length && ee.push(Y.media.mediaText), ee.join(" ") + ";";
}
function cd(Y) {
  try {
    const X = Y.rules || Y.cssRules;
    return X ? sW(Array.from(X, U5).join("")) : null;
  } catch {
    return null;
  }
}
function U5(Y) {
  let X;
  if (cW(Y))
    try {
      X = cd(Y.styleSheet) || oW(Y);
    } catch {
    }
  else if (uW(Y) && Y.selectorText.includes(":"))
    return aW(Y.cssText);
  return X || Y.cssText;
}
function aW(Y) {
  const X = /(\[(?:[\w-]+)[^\\])(:(?:[\w-]+)\])/gm;
  return Y.replace(X, "$1\\$2");
}
function cW(Y) {
  return "styleSheet" in Y;
}
function uW(Y) {
  return "selectorText" in Y;
}
class j5 {
  constructor() {
    this.idNodeMap = /* @__PURE__ */ new Map(), this.nodeMetaMap = /* @__PURE__ */ new WeakMap();
  }
  getId(X) {
    if (!X)
      return -1;
    const ee = ad([this, "access", (te) => te.getMeta, "call", (te) => te(X), "optionalAccess", (te) => te.id]);
    return nW(ee, () => -1);
  }
  getNode(X) {
    return this.idNodeMap.get(X) || null;
  }
  getIds() {
    return Array.from(this.idNodeMap.keys());
  }
  getMeta(X) {
    return this.nodeMetaMap.get(X) || null;
  }
  removeNodeFromMap(X) {
    const ee = this.getId(X);
    this.idNodeMap.delete(ee), X.childNodes && X.childNodes.forEach((te) => this.removeNodeFromMap(te));
  }
  has(X) {
    return this.idNodeMap.has(X);
  }
  hasNode(X) {
    return this.nodeMetaMap.has(X);
  }
  add(X, ee) {
    const te = ee.id;
    this.idNodeMap.set(te, X), this.nodeMetaMap.set(X, ee);
  }
  replace(X, ee) {
    const te = this.getNode(X);
    if (te) {
      const ne = this.nodeMetaMap.get(te);
      ne && this.nodeMetaMap.set(ee, ne);
    }
    this.idNodeMap.set(X, ee);
  }
  reset() {
    this.idNodeMap = /* @__PURE__ */ new Map(), this.nodeMetaMap = /* @__PURE__ */ new WeakMap();
  }
}
function fW() {
  return new j5();
}
function D0({ maskInputOptions: Y, tagName: X, type: ee }) {
  return X === "OPTION" && (X = "SELECT"), !!(Y[X.toLowerCase()] || ee && Y[ee] || ee === "password" || X === "INPUT" && !ee && Y.text);
}
function ef({ isMasked: Y, element: X, value: ee, maskInputFn: te }) {
  let ne = ee || "";
  return Y ? (te && (ne = te(ne, X)), "*".repeat(ne.length)) : ne;
}
function sc(Y) {
  return Y.toLowerCase();
}
function Gg(Y) {
  return Y.toUpperCase();
}
const Zv = "__rrweb_original__";
function lW(Y) {
  const X = Y.getContext("2d");
  if (!X)
    return !0;
  const ee = 50;
  for (let te = 0; te < Y.width; te += ee)
    for (let ne = 0; ne < Y.height; ne += ee) {
      const ie = X.getImageData, oe = Zv in ie ? ie[Zv] : ie;
      if (new Uint32Array(oe.call(X, te, ne, Math.min(ee, Y.width - te), Math.min(ee, Y.height - ne)).data.buffer).some((se) => se !== 0))
        return !1;
    }
  return !0;
}
function wb(Y) {
  const X = Y.type;
  return Y.hasAttribute("data-rr-is-password") ? "password" : X ? sc(X) : null;
}
function ud(Y, X, ee) {
  return X === "INPUT" && (ee === "radio" || ee === "checkbox") ? Y.getAttribute("value") || "" : Y.value;
}
let dW = 1;
const hW = new RegExp("[^a-z0-9-_:]"), tf = -2;
function vb() {
  return dW++;
}
function pW(Y) {
  if (Y instanceof HTMLFormElement)
    return "form";
  const X = sc(Y.tagName);
  return hW.test(X) ? "div" : X;
}
function gW(Y) {
  let X = "";
  return Y.indexOf("//") > -1 ? X = Y.split("/").slice(0, 3).join("/") : X = Y.split("/")[0], X = X.split("?")[0], X;
}
let fa, Qv;
const mW = /url\((?:(')([^']*)'|(")(.*?)"|([^)]*))\)/gm, yW = /^(?:[a-z+]+:)?\/\//i, bW = /^www\..*/i, xW = /^(data:)([^,]*),(.*)/i;
function fd(Y, X) {
  return (Y || "").replace(mW, (ee, te, ne, ie, oe, se) => {
    const ae = ne || oe || se, ue = te || ie || "";
    if (!ae)
      return ee;
    if (yW.test(ae) || bW.test(ae))
      return `url(${ue}${ae}${ue})`;
    if (xW.test(ae))
      return `url(${ue}${ae}${ue})`;
    if (ae[0] === "/")
      return `url(${ue}${gW(X) + ae}${ue})`;
    const le = X.split("/"), he = ae.split("/");
    le.pop();
    for (const me of he)
      me !== "." && (me === ".." ? le.pop() : le.push(me));
    return `url(${ue}${le.join("/")}${ue})`;
  });
}
const wW = /^[^ \t\n\r\u000c]+/, vW = /^[, \t\n\r\u000c]+/;
function EW(Y, X) {
  if (X.trim() === "")
    return X;
  let ee = 0;
  function te(ie) {
    let oe;
    const se = ie.exec(X.substring(ee));
    return se ? (oe = se[0], ee += oe.length, oe) : "";
  }
  const ne = [];
  for (; te(vW), !(ee >= X.length); ) {
    let ie = te(wW);
    if (ie.slice(-1) === ",")
      ie = Ea(Y, ie.substring(0, ie.length - 1)), ne.push(ie);
    else {
      let oe = "";
      ie = Ea(Y, ie);
      let se = !1;
      for (; ; ) {
        const ae = X.charAt(ee);
        if (ae === "") {
          ne.push((ie + oe).trim());
          break;
        } else if (se)
          ae === ")" && (se = !1);
        else if (ae === ",") {
          ee += 1, ne.push((ie + oe).trim());
          break;
        } else
          ae === "(" && (se = !0);
        oe += ae, ee += 1;
      }
    }
  }
  return ne.join(", ");
}
function Ea(Y, X) {
  if (!X || X.trim() === "")
    return X;
  const ee = Y.createElement("a");
  return ee.href = X, ee.href;
}
function _W(Y) {
  return !!(Y.tagName === "svg" || Y.ownerSVGElement);
}
function Eb() {
  const Y = document.createElement("a");
  return Y.href = "", Y.href;
}
function H5(Y, X, ee, te, ne, ie) {
  return te && (ee === "src" || ee === "href" && !(X === "use" && te[0] === "#") || ee === "xlink:href" && te[0] !== "#" || ee === "background" && (X === "table" || X === "td" || X === "th") ? Ea(Y, te) : ee === "srcset" ? EW(Y, te) : ee === "style" ? fd(te, Eb()) : X === "object" && ee === "data" ? Ea(Y, te) : typeof ie == "function" ? ie(ee, te, ne) : te);
}
function z5(Y, X, ee) {
  return (Y === "video" || Y === "audio") && X === "autoplay";
}
function AW(Y, X, ee, te) {
  try {
    if (te && Y.matches(te))
      return !1;
    if (typeof X == "string") {
      if (Y.classList.contains(X))
        return !0;
    } else
      for (let ne = Y.classList.length; ne--; ) {
        const ie = Y.classList[ne];
        if (X.test(ie))
          return !0;
      }
    if (ee)
      return Y.matches(ee);
  } catch {
  }
  return !1;
}
function SW(Y, X) {
  for (let ee = Y.classList.length; ee--; ) {
    const te = Y.classList[ee];
    if (X.test(te))
      return !0;
  }
  return !1;
}
function Io(Y, X, ee = 1 / 0, te = 0) {
  return !Y || Y.nodeType !== Y.ELEMENT_NODE || te > ee ? -1 : X(Y) ? te : Io(Y.parentNode, X, ee, te + 1);
}
function _a(Y, X) {
  return (ee) => {
    const te = ee;
    if (te === null)
      return !1;
    try {
      if (Y) {
        if (typeof Y == "string") {
          if (te.matches(`.${Y}`))
            return !0;
        } else if (SW(te, Y))
          return !0;
      }
      return !!(X && te.matches(X));
    } catch {
      return !1;
    }
  };
}
function oc(Y, X, ee, te, ne, ie) {
  try {
    const oe = Y.nodeType === Y.ELEMENT_NODE ? Y : Y.parentElement;
    if (oe === null)
      return !1;
    if (oe.tagName === "INPUT") {
      const ue = oe.getAttribute("autocomplete");
      if ([
        "current-password",
        "new-password",
        "cc-number",
        "cc-exp",
        "cc-exp-month",
        "cc-exp-year",
        "cc-csc"
      ].includes(ue))
        return !0;
    }
    let se = -1, ae = -1;
    if (ie) {
      if (ae = Io(oe, _a(te, ne)), ae < 0)
        return !0;
      se = Io(oe, _a(X, ee), ae >= 0 ? ae : 1 / 0);
    } else {
      if (se = Io(oe, _a(X, ee)), se < 0)
        return !1;
      ae = Io(oe, _a(te, ne), se >= 0 ? se : 1 / 0);
    }
    return se >= 0 ? ae >= 0 ? se <= ae : !0 : ae >= 0 ? !1 : !!ie;
  } catch {
  }
  return !!ie;
}
function TW(Y, X, ee) {
  const te = Y.contentWindow;
  if (!te)
    return;
  let ne = !1, ie;
  try {
    ie = te.document.readyState;
  } catch {
    return;
  }
  if (ie !== "complete") {
    const se = setTimeout(() => {
      ne || (X(), ne = !0);
    }, ee);
    Y.addEventListener("load", () => {
      clearTimeout(se), ne = !0, X();
    });
    return;
  }
  const oe = "about:blank";
  if (te.location.href !== oe || Y.src === oe || Y.src === "")
    return setTimeout(X, 0), Y.addEventListener("load", X);
  Y.addEventListener("load", X);
}
function IW(Y, X, ee) {
  let te = !1, ne;
  try {
    ne = Y.sheet;
  } catch {
    return;
  }
  if (ne)
    return;
  const ie = setTimeout(() => {
    te || (X(), te = !0);
  }, ee);
  Y.addEventListener("load", () => {
    clearTimeout(ie), te = !0, X();
  });
}
function RW(Y, X) {
  const { doc: ee, mirror: te, blockClass: ne, blockSelector: ie, unblockSelector: oe, maskAllText: se, maskAttributeFn: ae, maskTextClass: ue, unmaskTextClass: le, maskTextSelector: he, unmaskTextSelector: me, inlineStylesheet: ye, maskInputOptions: we = {}, maskTextFn: Ee, maskInputFn: Re, dataURLOptions: Ue = {}, inlineImages: Me, recordCanvas: De, keepIframeSrcFn: Fe, newlyAddedElement: Ke = !1 } = X, tt = CW(ee, te);
  switch (Y.nodeType) {
    case Y.DOCUMENT_NODE:
      return Y.compatMode !== "CSS1Compat" ? {
        type: jr.Document,
        childNodes: [],
        compatMode: Y.compatMode
      } : {
        type: jr.Document,
        childNodes: []
      };
    case Y.DOCUMENT_TYPE_NODE:
      return {
        type: jr.DocumentType,
        name: Y.name,
        publicId: Y.publicId,
        systemId: Y.systemId,
        rootId: tt
      };
    case Y.ELEMENT_NODE:
      return OW(Y, {
        doc: ee,
        blockClass: ne,
        blockSelector: ie,
        unblockSelector: oe,
        inlineStylesheet: ye,
        maskAttributeFn: ae,
        maskInputOptions: we,
        maskInputFn: Re,
        dataURLOptions: Ue,
        inlineImages: Me,
        recordCanvas: De,
        keepIframeSrcFn: Fe,
        newlyAddedElement: Ke,
        rootId: tt,
        maskAllText: se,
        maskTextClass: ue,
        unmaskTextClass: le,
        maskTextSelector: he,
        unmaskTextSelector: me
      });
    case Y.TEXT_NODE:
      return PW(Y, {
        maskAllText: se,
        maskTextClass: ue,
        unmaskTextClass: le,
        maskTextSelector: he,
        unmaskTextSelector: me,
        maskTextFn: Ee,
        maskInputOptions: we,
        maskInputFn: Re,
        rootId: tt
      });
    case Y.CDATA_SECTION_NODE:
      return {
        type: jr.CDATA,
        textContent: "",
        rootId: tt
      };
    case Y.COMMENT_NODE:
      return {
        type: jr.Comment,
        textContent: Y.textContent || "",
        rootId: tt
      };
    default:
      return !1;
  }
}
function CW(Y, X) {
  if (!X.hasNode(Y))
    return;
  const ee = X.getId(Y);
  return ee === 1 ? void 0 : ee;
}
function PW(Y, X) {
  const { maskAllText: ee, maskTextClass: te, unmaskTextClass: ne, maskTextSelector: ie, unmaskTextSelector: oe, maskTextFn: se, maskInputOptions: ae, maskInputFn: ue, rootId: le } = X, he = Y.parentNode && Y.parentNode.tagName;
  let me = Y.textContent;
  const ye = he === "STYLE" ? !0 : void 0, we = he === "SCRIPT" ? !0 : void 0, Ee = he === "TEXTAREA" ? !0 : void 0;
  if (ye && me) {
    try {
      Y.nextSibling || Y.previousSibling || ad([Y, "access", (Ue) => Ue.parentNode, "access", (Ue) => Ue.sheet, "optionalAccess", (Ue) => Ue.cssRules]) && (me = cd(Y.parentNode.sheet));
    } catch (Ue) {
      console.warn(`Cannot get CSS styles from text's parentNode. Error: ${Ue}`, Y);
    }
    me = fd(me, Eb());
  }
  we && (me = "SCRIPT_PLACEHOLDER");
  const Re = oc(Y, te, ie, ne, oe, ee);
  if (!ye && !we && !Ee && me && Re && (me = se ? se(me) : me.replace(/[\S]/g, "*")), Ee && me && (ae.textarea || Re) && (me = ue ? ue(me, Y.parentNode) : me.replace(/[\S]/g, "*")), he === "OPTION" && me) {
    const Ue = D0({
      type: null,
      tagName: he,
      maskInputOptions: ae
    });
    me = ef({
      isMasked: oc(Y, te, ie, ne, oe, Ue),
      element: Y,
      value: me,
      maskInputFn: ue
    });
  }
  return {
    type: jr.Text,
    textContent: me || "",
    isStyle: ye,
    rootId: le
  };
}
function OW(Y, X) {
  const { doc: ee, blockClass: te, blockSelector: ne, unblockSelector: ie, inlineStylesheet: oe, maskInputOptions: se = {}, maskAttributeFn: ae, maskInputFn: ue, dataURLOptions: le = {}, inlineImages: he, recordCanvas: me, keepIframeSrcFn: ye, newlyAddedElement: we = !1, rootId: Ee, maskAllText: Re, maskTextClass: Ue, unmaskTextClass: Me, maskTextSelector: De, unmaskTextSelector: Fe } = X, Ke = AW(Y, te, ne, ie), tt = pW(Y);
  let rt = {};
  const it = Y.attributes.length;
  for (let Dt = 0; Dt < it; Dt++) {
    const je = Y.attributes[Dt];
    je.name && !z5(tt, je.name, je.value) && (rt[je.name] = H5(ee, tt, sc(je.name), je.value, Y, ae));
  }
  if (tt === "link" && oe) {
    const Dt = Array.from(ee.styleSheets).find((ze) => ze.href === Y.href);
    let je = null;
    Dt && (je = cd(Dt)), je && (delete rt.rel, delete rt.href, rt._cssText = fd(je, Dt.href));
  }
  if (tt === "style" && Y.sheet && !(Y.innerText || Y.textContent || "").trim().length) {
    const Dt = cd(Y.sheet);
    Dt && (rt._cssText = fd(Dt, Eb()));
  }
  if (tt === "input" || tt === "textarea" || tt === "select" || tt === "option") {
    const Dt = Y, je = wb(Dt), ze = ud(Dt, Gg(tt), je), fe = Dt.checked;
    if (je !== "submit" && je !== "button" && ze) {
      const de = oc(Dt, Ue, De, Me, Fe, D0({
        type: je,
        tagName: Gg(tt),
        maskInputOptions: se
      }));
      rt.value = ef({
        isMasked: de,
        element: Dt,
        value: ze,
        maskInputFn: ue
      });
    }
    fe && (rt.checked = fe);
  }
  if (tt === "option" && (Y.selected && !se.select ? rt.selected = !0 : delete rt.selected), tt === "canvas" && me) {
    if (Y.__context === "2d")
      lW(Y) || (rt.rr_dataURL = Y.toDataURL(le.type, le.quality));
    else if (!("__context" in Y)) {
      const Dt = Y.toDataURL(le.type, le.quality), je = document.createElement("canvas");
      je.width = Y.width, je.height = Y.height;
      const ze = je.toDataURL(le.type, le.quality);
      Dt !== ze && (rt.rr_dataURL = Dt);
    }
  }
  if (tt === "img" && he) {
    fa || (fa = ee.createElement("canvas"), Qv = fa.getContext("2d"));
    const Dt = Y, je = Dt.crossOrigin;
    Dt.crossOrigin = "anonymous";
    const ze = () => {
      Dt.removeEventListener("load", ze);
      try {
        fa.width = Dt.naturalWidth, fa.height = Dt.naturalHeight, Qv.drawImage(Dt, 0, 0), rt.rr_dataURL = fa.toDataURL(le.type, le.quality);
      } catch (fe) {
        console.warn(`Cannot inline img src=${Dt.currentSrc}! Error: ${fe}`);
      }
      je ? rt.crossOrigin = je : Dt.removeAttribute("crossorigin");
    };
    Dt.complete && Dt.naturalWidth !== 0 ? ze() : Dt.addEventListener("load", ze);
  }
  if ((tt === "audio" || tt === "video") && (rt.rr_mediaState = Y.paused ? "paused" : "played", rt.rr_mediaCurrentTime = Y.currentTime), we || (Y.scrollLeft && (rt.rr_scrollLeft = Y.scrollLeft), Y.scrollTop && (rt.rr_scrollTop = Y.scrollTop)), Ke) {
    const { width: Dt, height: je } = Y.getBoundingClientRect();
    rt = {
      class: rt.class,
      rr_width: `${Dt}px`,
      rr_height: `${je}px`
    };
  }
  tt === "iframe" && !ye(rt.src) && (Y.contentDocument || (rt.rr_src = rt.src), delete rt.src);
  let _t;
  try {
    customElements.get(tt) && (_t = !0);
  } catch {
  }
  return {
    type: jr.Element,
    tagName: tt,
    attributes: rt,
    childNodes: [],
    isSVG: _W(Y) || void 0,
    needBlock: Ke,
    rootId: Ee,
    isCustom: _t
  };
}
function ur(Y) {
  return Y == null ? "" : Y.toLowerCase();
}
function BW(Y, X) {
  return !!(X.comment && Y.type === jr.Comment || Y.type === jr.Element && (X.script && (Y.tagName === "script" || Y.tagName === "link" && (Y.attributes.rel === "preload" || Y.attributes.rel === "modulepreload") && Y.attributes.as === "script" || Y.tagName === "link" && Y.attributes.rel === "prefetch" && typeof Y.attributes.href == "string" && Y.attributes.href.endsWith(".js")) || X.headFavicon && (Y.tagName === "link" && Y.attributes.rel === "shortcut icon" || Y.tagName === "meta" && (ur(Y.attributes.name).match(/^msapplication-tile(image|color)$/) || ur(Y.attributes.name) === "application-name" || ur(Y.attributes.rel) === "icon" || ur(Y.attributes.rel) === "apple-touch-icon" || ur(Y.attributes.rel) === "shortcut icon")) || Y.tagName === "meta" && (X.headMetaDescKeywords && ur(Y.attributes.name).match(/^description|keywords$/) || X.headMetaSocial && (ur(Y.attributes.property).match(/^(og|twitter|fb):/) || ur(Y.attributes.name).match(/^(og|twitter):/) || ur(Y.attributes.name) === "pinterest") || X.headMetaRobots && (ur(Y.attributes.name) === "robots" || ur(Y.attributes.name) === "googlebot" || ur(Y.attributes.name) === "bingbot") || X.headMetaHttpEquiv && Y.attributes["http-equiv"] !== void 0 || X.headMetaAuthorship && (ur(Y.attributes.name) === "author" || ur(Y.attributes.name) === "generator" || ur(Y.attributes.name) === "framework" || ur(Y.attributes.name) === "publisher" || ur(Y.attributes.name) === "progid" || ur(Y.attributes.property).match(/^article:/) || ur(Y.attributes.property).match(/^product:/)) || X.headMetaVerification && (ur(Y.attributes.name) === "google-site-verification" || ur(Y.attributes.name) === "yandex-verification" || ur(Y.attributes.name) === "csrf-token" || ur(Y.attributes.name) === "p:domain_verify" || ur(Y.attributes.name) === "verify-v1" || ur(Y.attributes.name) === "verification" || ur(Y.attributes.name) === "shopify-checkout-api-token"))));
}
function Aa(Y, X) {
  const { doc: ee, mirror: te, blockClass: ne, blockSelector: ie, unblockSelector: oe, maskAllText: se, maskTextClass: ae, unmaskTextClass: ue, maskTextSelector: le, unmaskTextSelector: he, skipChild: me = !1, inlineStylesheet: ye = !0, maskInputOptions: we = {}, maskAttributeFn: Ee, maskTextFn: Re, maskInputFn: Ue, slimDOMOptions: Me, dataURLOptions: De = {}, inlineImages: Fe = !1, recordCanvas: Ke = !1, onSerialize: tt, onIframeLoad: rt, iframeLoadTimeout: it = 5e3, onStylesheetLoad: _t, stylesheetLoadTimeout: Dt = 5e3, keepIframeSrcFn: je = () => !1, newlyAddedElement: ze = !1 } = X;
  let { preserveWhiteSpace: fe = !0 } = X;
  const de = RW(Y, {
    doc: ee,
    mirror: te,
    blockClass: ne,
    blockSelector: ie,
    maskAllText: se,
    unblockSelector: oe,
    maskTextClass: ae,
    unmaskTextClass: ue,
    maskTextSelector: le,
    unmaskTextSelector: he,
    inlineStylesheet: ye,
    maskInputOptions: we,
    maskAttributeFn: Ee,
    maskTextFn: Re,
    maskInputFn: Ue,
    dataURLOptions: De,
    inlineImages: Fe,
    recordCanvas: Ke,
    keepIframeSrcFn: je,
    newlyAddedElement: ze
  });
  if (!de)
    return console.warn(Y, "not serialized"), null;
  let be;
  te.hasNode(Y) ? be = te.getId(Y) : BW(de, Me) || !fe && de.type === jr.Text && !de.isStyle && !de.textContent.replace(/^\s+|\s+$/gm, "").length ? be = tf : be = vb();
  const Te = Object.assign(de, { id: be });
  if (te.add(Y, Te), be === tf)
    return null;
  tt && tt(Y);
  let Ce = !me;
  if (Te.type === jr.Element) {
    Ce = Ce && !Te.needBlock, delete Te.needBlock;
    const Pe = Y.shadowRoot;
    Pe && mu(Pe) && (Te.isShadowHost = !0);
  }
  if ((Te.type === jr.Document || Te.type === jr.Element) && Ce) {
    Me.headWhitespace && Te.type === jr.Element && Te.tagName === "head" && (fe = !1);
    const Pe = {
      doc: ee,
      mirror: te,
      blockClass: ne,
      blockSelector: ie,
      maskAllText: se,
      unblockSelector: oe,
      maskTextClass: ae,
      unmaskTextClass: ue,
      maskTextSelector: le,
      unmaskTextSelector: he,
      skipChild: me,
      inlineStylesheet: ye,
      maskInputOptions: we,
      maskAttributeFn: Ee,
      maskTextFn: Re,
      maskInputFn: Ue,
      slimDOMOptions: Me,
      dataURLOptions: De,
      inlineImages: Fe,
      recordCanvas: Ke,
      preserveWhiteSpace: fe,
      onSerialize: tt,
      onIframeLoad: rt,
      iframeLoadTimeout: it,
      onStylesheetLoad: _t,
      stylesheetLoadTimeout: Dt,
      keepIframeSrcFn: je
    };
    for (const Se of Array.from(Y.childNodes)) {
      const ke = Aa(Se, Pe);
      ke && Te.childNodes.push(ke);
    }
    if (iW(Y) && Y.shadowRoot)
      for (const Se of Array.from(Y.shadowRoot.childNodes)) {
        const ke = Aa(Se, Pe);
        ke && (mu(Y.shadowRoot) && (ke.isShadow = !0), Te.childNodes.push(ke));
      }
  }
  return Y.parentNode && gu(Y.parentNode) && mu(Y.parentNode) && (Te.isShadow = !0), Te.type === jr.Element && Te.tagName === "iframe" && TW(Y, () => {
    const Pe = Y.contentDocument;
    if (Pe && rt) {
      const Se = Aa(Pe, {
        doc: Pe,
        mirror: te,
        blockClass: ne,
        blockSelector: ie,
        unblockSelector: oe,
        maskAllText: se,
        maskTextClass: ae,
        unmaskTextClass: ue,
        maskTextSelector: le,
        unmaskTextSelector: he,
        skipChild: !1,
        inlineStylesheet: ye,
        maskInputOptions: we,
        maskAttributeFn: Ee,
        maskTextFn: Re,
        maskInputFn: Ue,
        slimDOMOptions: Me,
        dataURLOptions: De,
        inlineImages: Fe,
        recordCanvas: Ke,
        preserveWhiteSpace: fe,
        onSerialize: tt,
        onIframeLoad: rt,
        iframeLoadTimeout: it,
        onStylesheetLoad: _t,
        stylesheetLoadTimeout: Dt,
        keepIframeSrcFn: je
      });
      Se && rt(Y, Se);
    }
  }, it), Te.type === jr.Element && Te.tagName === "link" && Te.attributes.rel === "stylesheet" && IW(Y, () => {
    if (_t) {
      const Pe = Aa(Y, {
        doc: ee,
        mirror: te,
        blockClass: ne,
        blockSelector: ie,
        unblockSelector: oe,
        maskAllText: se,
        maskTextClass: ae,
        unmaskTextClass: ue,
        maskTextSelector: le,
        unmaskTextSelector: he,
        skipChild: !1,
        inlineStylesheet: ye,
        maskInputOptions: we,
        maskAttributeFn: Ee,
        maskTextFn: Re,
        maskInputFn: Ue,
        slimDOMOptions: Me,
        dataURLOptions: De,
        inlineImages: Fe,
        recordCanvas: Ke,
        preserveWhiteSpace: fe,
        onSerialize: tt,
        onIframeLoad: rt,
        iframeLoadTimeout: it,
        onStylesheetLoad: _t,
        stylesheetLoadTimeout: Dt,
        keepIframeSrcFn: je
      });
      Pe && _t(Y, Pe);
    }
  }, Dt), Te;
}
function NW(Y, X) {
  const { mirror: ee = new j5(), blockClass: te = "rr-block", blockSelector: ne = null, unblockSelector: ie = null, maskAllText: oe = !1, maskTextClass: se = "rr-mask", unmaskTextClass: ae = null, maskTextSelector: ue = null, unmaskTextSelector: le = null, inlineStylesheet: he = !0, inlineImages: me = !1, recordCanvas: ye = !1, maskAllInputs: we = !1, maskAttributeFn: Ee, maskTextFn: Re, maskInputFn: Ue, slimDOM: Me = !1, dataURLOptions: De, preserveWhiteSpace: Fe, onSerialize: Ke, onIframeLoad: tt, iframeLoadTimeout: rt, onStylesheetLoad: it, stylesheetLoadTimeout: _t, keepIframeSrcFn: Dt = () => !1 } = X || {};
  return Aa(Y, {
    doc: Y,
    mirror: ee,
    blockClass: te,
    blockSelector: ne,
    unblockSelector: ie,
    maskAllText: oe,
    maskTextClass: se,
    unmaskTextClass: ae,
    maskTextSelector: ue,
    unmaskTextSelector: le,
    skipChild: !1,
    inlineStylesheet: he,
    maskInputOptions: we === !0 ? {
      color: !0,
      date: !0,
      "datetime-local": !0,
      email: !0,
      month: !0,
      number: !0,
      range: !0,
      search: !0,
      tel: !0,
      text: !0,
      time: !0,
      url: !0,
      week: !0,
      textarea: !0,
      select: !0
    } : we === !1 ? {} : we,
    maskAttributeFn: Ee,
    maskTextFn: Re,
    maskInputFn: Ue,
    slimDOMOptions: Me === !0 || Me === "all" ? {
      script: !0,
      comment: !0,
      headFavicon: !0,
      headWhitespace: !0,
      headMetaDescKeywords: Me === "all",
      headMetaSocial: !0,
      headMetaRobots: !0,
      headMetaHttpEquiv: !0,
      headMetaAuthorship: !0,
      headMetaVerification: !0
    } : Me === !1 ? {} : Me,
    dataURLOptions: De,
    inlineImages: me,
    recordCanvas: ye,
    preserveWhiteSpace: Fe,
    onSerialize: Ke,
    onIframeLoad: tt,
    iframeLoadTimeout: rt,
    onStylesheetLoad: it,
    stylesheetLoadTimeout: _t,
    keepIframeSrcFn: Dt,
    newlyAddedElement: !1
  });
}
function Gs(Y) {
  let X, ee = Y[0], te = 1;
  for (; te < Y.length; ) {
    const ne = Y[te], ie = Y[te + 1];
    if (te += 2, (ne === "optionalAccess" || ne === "optionalCall") && ee == null)
      return;
    ne === "access" || ne === "optionalAccess" ? (X = ee, ee = ie(ee)) : (ne === "call" || ne === "optionalCall") && (ee = ie((...oe) => ee.call(X, ...oe)), X = void 0);
  }
  return ee;
}
function bn$3(Y, X, ee = document) {
  const te = { capture: !0, passive: !0 };
  return ee.addEventListener(Y, X, te), () => ee.removeEventListener(Y, X, te);
}
const pa = `Please stop import mirror directly. Instead of that,\r
now you can use replayer.getMirror() to access the mirror instance of a replayer,\r
or you can use record.mirror to access the mirror instance during recording.`;
let e2 = {
  map: {},
  getId() {
    return console.error(pa), -1;
  },
  getNode() {
    return console.error(pa), null;
  },
  removeNodeFromMap() {
    console.error(pa);
  },
  has() {
    return console.error(pa), !1;
  },
  reset() {
    console.error(pa);
  }
};
typeof window < "u" && window.Proxy && window.Reflect && (e2 = new Proxy(e2, {
  get(Y, X, ee) {
    return X === "map" && console.error(pa), Reflect.get(Y, X, ee);
  }
}));
function rf(Y, X, ee = {}) {
  let te = null, ne = 0;
  return function(...ie) {
    const oe = Date.now();
    !ne && ee.leading === !1 && (ne = oe);
    const se = X - (oe - ne), ae = this;
    se <= 0 || se > X ? (te && (clearTimeout(te), te = null), ne = oe, Y.apply(ae, ie)) : !te && ee.trailing !== !1 && (te = setTimeout(() => {
      ne = ee.leading === !1 ? 0 : Date.now(), te = null, Y.apply(ae, ie);
    }, se));
  };
}
function q5(Y, X, ee, te, ne = window) {
  const ie = ne.Object.getOwnPropertyDescriptor(Y, X);
  return ne.Object.defineProperty(Y, X, te ? ee : {
    set(oe) {
      setTimeout(() => {
        ee.set.call(this, oe);
      }, 0), ie && ie.set && ie.set.call(this, oe);
    }
  }), () => q5(Y, X, ie || {}, !0);
}
function _b(Y, X, ee) {
  try {
    if (!(X in Y))
      return () => {
      };
    const te = Y[X], ne = ee(te);
    return typeof ne == "function" && (ne.prototype = ne.prototype || {}, Object.defineProperties(ne, {
      __rrweb_original__: {
        enumerable: !1,
        value: te
      }
    })), Y[X] = ne, () => {
      Y[X] = te;
    };
  } catch {
    return () => {
    };
  }
}
let ld = Date.now;
/[1-9][0-9]{12}/.test(Date.now().toString()) || (ld = () => (/* @__PURE__ */ new Date()).getTime());
function G5(Y) {
  const X = Y.document;
  return {
    left: X.scrollingElement ? X.scrollingElement.scrollLeft : Y.pageXOffset !== void 0 ? Y.pageXOffset : Gs([X, "optionalAccess", (ee) => ee.documentElement, "access", (ee) => ee.scrollLeft]) || Gs([X, "optionalAccess", (ee) => ee.body, "optionalAccess", (ee) => ee.parentElement, "optionalAccess", (ee) => ee.scrollLeft]) || Gs([X, "optionalAccess", (ee) => ee.body, "optionalAccess", (ee) => ee.scrollLeft]) || 0,
    top: X.scrollingElement ? X.scrollingElement.scrollTop : Y.pageYOffset !== void 0 ? Y.pageYOffset : Gs([X, "optionalAccess", (ee) => ee.documentElement, "access", (ee) => ee.scrollTop]) || Gs([X, "optionalAccess", (ee) => ee.body, "optionalAccess", (ee) => ee.parentElement, "optionalAccess", (ee) => ee.scrollTop]) || Gs([X, "optionalAccess", (ee) => ee.body, "optionalAccess", (ee) => ee.scrollTop]) || 0
  };
}
function V5() {
  return window.innerHeight || document.documentElement && document.documentElement.clientHeight || document.body && document.body.clientHeight;
}
function W5() {
  return window.innerWidth || document.documentElement && document.documentElement.clientWidth || document.body && document.body.clientWidth;
}
function mi(Y, X, ee, te, ne) {
  if (!Y)
    return !1;
  const ie = Y.nodeType === Y.ELEMENT_NODE ? Y : Y.parentElement;
  if (!ie)
    return !1;
  const oe = _a(X, ee);
  if (!ne) {
    const ue = te && ie.matches(te);
    return oe(ie) && !ue;
  }
  const se = Io(ie, oe);
  let ae = -1;
  return se < 0 ? !1 : (te && (ae = Io(ie, _a(null, te))), se > -1 && ae < 0 ? !0 : se < ae);
}
function kW(Y, X) {
  return X.getId(Y) !== -1;
}
function Tp(Y, X) {
  return X.getId(Y) === tf;
}
function K5(Y, X) {
  if (gu(Y))
    return !1;
  const ee = X.getId(Y);
  return X.has(ee) ? Y.parentNode && Y.parentNode.nodeType === Y.DOCUMENT_NODE ? !1 : Y.parentNode ? K5(Y.parentNode, X) : !0 : !0;
}
function Vg(Y) {
  return !!Y.changedTouches;
}
function MW(Y = window) {
  "NodeList" in Y && !Y.NodeList.prototype.forEach && (Y.NodeList.prototype.forEach = Array.prototype.forEach), "DOMTokenList" in Y && !Y.DOMTokenList.prototype.forEach && (Y.DOMTokenList.prototype.forEach = Array.prototype.forEach), Node.prototype.contains || (Node.prototype.contains = (...X) => {
    let ee = X[0];
    if (!(0 in X))
      throw new TypeError("1 argument is required");
    do
      if (this === ee)
        return !0;
    while (ee = ee && ee.parentNode);
    return !1;
  });
}
function J5(Y, X) {
  return !!(Y.nodeName === "IFRAME" && X.getMeta(Y));
}
function Y5(Y, X) {
  return !!(Y.nodeName === "LINK" && Y.nodeType === Y.ELEMENT_NODE && Y.getAttribute && Y.getAttribute("rel") === "stylesheet" && X.getMeta(Y));
}
function Wg(Y) {
  return !!Gs([Y, "optionalAccess", (X) => X.shadowRoot]);
}
class LW {
  constructor() {
    this.id = 1, this.styleIDMap = /* @__PURE__ */ new WeakMap(), this.idStyleMap = /* @__PURE__ */ new Map();
  }
  getId(X) {
    return mz(this.styleIDMap.get(X), () => -1);
  }
  has(X) {
    return this.styleIDMap.has(X);
  }
  add(X, ee) {
    if (this.has(X))
      return this.getId(X);
    let te;
    return ee === void 0 ? te = this.id++ : te = ee, this.styleIDMap.set(X, te), this.idStyleMap.set(te, X), te;
  }
  getStyle(X) {
    return this.idStyleMap.get(X) || null;
  }
  reset() {
    this.styleIDMap = /* @__PURE__ */ new WeakMap(), this.idStyleMap = /* @__PURE__ */ new Map(), this.id = 1;
  }
  generateId() {
    return this.id++;
  }
}
function X5(Y) {
  let X = null;
  return Gs([Y, "access", (ee) => ee.getRootNode, "optionalCall", (ee) => ee(), "optionalAccess", (ee) => ee.nodeType]) === Node.DOCUMENT_FRAGMENT_NODE && Y.getRootNode().host && (X = Y.getRootNode().host), X;
}
function FW(Y) {
  let X = Y, ee;
  for (; ee = X5(X); )
    X = ee;
  return X;
}
function $W(Y) {
  const X = Y.ownerDocument;
  if (!X)
    return !1;
  const ee = FW(Y);
  return X.contains(ee);
}
function Z5(Y) {
  const X = Y.ownerDocument;
  return X ? X.contains(Y) || $W(Y) : !1;
}
let Ip;
function DW() {
  if (Ip)
    return Ip;
  const Y = window.document;
  let X = window.requestAnimationFrame;
  if (Y && typeof Y.createElement == "function")
    try {
      const ee = Y.createElement("iframe");
      ee.hidden = !0, Y.head.appendChild(ee);
      const te = ee.contentWindow;
      te && te.requestAnimationFrame && (X = te.requestAnimationFrame), Y.head.removeChild(ee);
    } catch {
    }
  return Ip = X.bind(window);
}
function UW(...Y) {
  return DW()(...Y);
}
var Pt = /* @__PURE__ */ ((Y) => (Y[Y.DomContentLoaded = 0] = "DomContentLoaded", Y[Y.Load = 1] = "Load", Y[Y.FullSnapshot = 2] = "FullSnapshot", Y[Y.IncrementalSnapshot = 3] = "IncrementalSnapshot", Y[Y.Meta = 4] = "Meta", Y[Y.Custom = 5] = "Custom", Y[Y.Plugin = 6] = "Plugin", Y))(Pt || {}), Ot = /* @__PURE__ */ ((Y) => (Y[Y.Mutation = 0] = "Mutation", Y[Y.MouseMove = 1] = "MouseMove", Y[Y.MouseInteraction = 2] = "MouseInteraction", Y[Y.Scroll = 3] = "Scroll", Y[Y.ViewportResize = 4] = "ViewportResize", Y[Y.Input = 5] = "Input", Y[Y.TouchMove = 6] = "TouchMove", Y[Y.MediaInteraction = 7] = "MediaInteraction", Y[Y.StyleSheetRule = 8] = "StyleSheetRule", Y[Y.CanvasMutation = 9] = "CanvasMutation", Y[Y.Font = 10] = "Font", Y[Y.Log = 11] = "Log", Y[Y.Drag = 12] = "Drag", Y[Y.StyleDeclaration = 13] = "StyleDeclaration", Y[Y.Selection = 14] = "Selection", Y[Y.AdoptedStyleSheet = 15] = "AdoptedStyleSheet", Y[Y.CustomElement = 16] = "CustomElement", Y))(Ot || {}), pn = /* @__PURE__ */ ((Y) => (Y[Y.MouseUp = 0] = "MouseUp", Y[Y.MouseDown = 1] = "MouseDown", Y[Y.Click = 2] = "Click", Y[Y.ContextMenu = 3] = "ContextMenu", Y[Y.DblClick = 4] = "DblClick", Y[Y.Focus = 5] = "Focus", Y[Y.Blur = 6] = "Blur", Y[Y.TouchStart = 7] = "TouchStart", Y[Y.TouchMove_Departed = 8] = "TouchMove_Departed", Y[Y.TouchEnd = 9] = "TouchEnd", Y[Y.TouchCancel = 10] = "TouchCancel", Y))(pn || {}), fs = /* @__PURE__ */ ((Y) => (Y[Y.Mouse = 0] = "Mouse", Y[Y.Pen = 1] = "Pen", Y[Y.Touch = 2] = "Touch", Y))(fs || {});
function jW(Y) {
  let X, ee = Y[0], te = 1;
  for (; te < Y.length; ) {
    const ne = Y[te], ie = Y[te + 1];
    if (te += 2, (ne === "optionalAccess" || ne === "optionalCall") && ee == null)
      return;
    ne === "access" || ne === "optionalAccess" ? (X = ee, ee = ie(ee)) : (ne === "call" || ne === "optionalCall") && (ee = ie((...oe) => ee.call(X, ...oe)), X = void 0);
  }
  return ee;
}
function t2(Y) {
  return "__ln" in Y;
}
class HW {
  constructor() {
    this.length = 0, this.head = null, this.tail = null;
  }
  get(X) {
    if (X >= this.length)
      throw new Error("Position outside of list range");
    let ee = this.head;
    for (let te = 0; te < X; te++)
      ee = jW([ee, "optionalAccess", (ne) => ne.next]) || null;
    return ee;
  }
  addNode(X) {
    const ee = {
      value: X,
      previous: null,
      next: null
    };
    if (X.__ln = ee, X.previousSibling && t2(X.previousSibling)) {
      const te = X.previousSibling.__ln.next;
      ee.next = te, ee.previous = X.previousSibling.__ln, X.previousSibling.__ln.next = ee, te && (te.previous = ee);
    } else if (X.nextSibling && t2(X.nextSibling) && X.nextSibling.__ln.previous) {
      const te = X.nextSibling.__ln.previous;
      ee.previous = te, ee.next = X.nextSibling.__ln, X.nextSibling.__ln.previous = ee, te && (te.next = ee);
    } else
      this.head && (this.head.previous = ee), ee.next = this.head, this.head = ee;
    ee.next === null && (this.tail = ee), this.length++;
  }
  removeNode(X) {
    const ee = X.__ln;
    this.head && (ee.previous ? (ee.previous.next = ee.next, ee.next ? ee.next.previous = ee.previous : this.tail = ee.previous) : (this.head = ee.next, this.head ? this.head.previous = null : this.tail = null), X.__ln && delete X.__ln, this.length--);
  }
}
const r2 = (Y, X) => `${Y}@${X}`;
class zW {
  constructor() {
    this.frozen = !1, this.locked = !1, this.texts = [], this.attributes = [], this.removes = [], this.mapRemoves = [], this.movedMap = {}, this.addedSet = /* @__PURE__ */ new Set(), this.movedSet = /* @__PURE__ */ new Set(), this.droppedSet = /* @__PURE__ */ new Set(), this.processMutations = (X) => {
      X.forEach(this.processMutation), this.emit();
    }, this.emit = () => {
      if (this.frozen || this.locked)
        return;
      const X = [], ee = /* @__PURE__ */ new Set(), te = new HW(), ne = (ae) => {
        let ue = ae, le = tf;
        for (; le === tf; )
          ue = ue && ue.nextSibling, le = ue && this.mirror.getId(ue);
        return le;
      }, ie = (ae) => {
        if (!ae.parentNode || !Z5(ae))
          return;
        const ue = gu(ae.parentNode) ? this.mirror.getId(X5(ae)) : this.mirror.getId(ae.parentNode), le = ne(ae);
        if (ue === -1 || le === -1)
          return te.addNode(ae);
        const he = Aa(ae, {
          doc: this.doc,
          mirror: this.mirror,
          blockClass: this.blockClass,
          blockSelector: this.blockSelector,
          maskAllText: this.maskAllText,
          unblockSelector: this.unblockSelector,
          maskTextClass: this.maskTextClass,
          unmaskTextClass: this.unmaskTextClass,
          maskTextSelector: this.maskTextSelector,
          unmaskTextSelector: this.unmaskTextSelector,
          skipChild: !0,
          newlyAddedElement: !0,
          inlineStylesheet: this.inlineStylesheet,
          maskInputOptions: this.maskInputOptions,
          maskAttributeFn: this.maskAttributeFn,
          maskTextFn: this.maskTextFn,
          maskInputFn: this.maskInputFn,
          slimDOMOptions: this.slimDOMOptions,
          dataURLOptions: this.dataURLOptions,
          recordCanvas: this.recordCanvas,
          inlineImages: this.inlineImages,
          onSerialize: (me) => {
            J5(me, this.mirror) && this.iframeManager.addIframe(me), Y5(me, this.mirror) && this.stylesheetManager.trackLinkElement(me), Wg(ae) && this.shadowDomManager.addShadowRoot(ae.shadowRoot, this.doc);
          },
          onIframeLoad: (me, ye) => {
            this.iframeManager.attachIframe(me, ye), this.shadowDomManager.observeAttachShadow(me);
          },
          onStylesheetLoad: (me, ye) => {
            this.stylesheetManager.attachLinkElement(me, ye);
          }
        });
        he && (X.push({
          parentId: ue,
          nextId: le,
          node: he
        }), ee.add(he.id));
      };
      for (; this.mapRemoves.length; )
        this.mirror.removeNodeFromMap(this.mapRemoves.shift());
      for (const ae of this.movedSet)
        n2(this.removes, ae, this.mirror) && !this.movedSet.has(ae.parentNode) || ie(ae);
      for (const ae of this.addedSet)
        !i2(this.droppedSet, ae) && !n2(this.removes, ae, this.mirror) || i2(this.movedSet, ae) ? ie(ae) : this.droppedSet.add(ae);
      let oe = null;
      for (; te.length; ) {
        let ae = null;
        if (oe) {
          const ue = this.mirror.getId(oe.value.parentNode), le = ne(oe.value);
          ue !== -1 && le !== -1 && (ae = oe);
        }
        if (!ae) {
          let ue = te.tail;
          for (; ue; ) {
            const le = ue;
            if (ue = ue.previous, le) {
              const he = this.mirror.getId(le.value.parentNode);
              if (ne(le.value) === -1)
                continue;
              if (he !== -1) {
                ae = le;
                break;
              } else {
                const me = le.value;
                if (me.parentNode && me.parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
                  const ye = me.parentNode.host;
                  if (this.mirror.getId(ye) !== -1) {
                    ae = le;
                    break;
                  }
                }
              }
            }
          }
        }
        if (!ae) {
          for (; te.head; )
            te.removeNode(te.head.value);
          break;
        }
        oe = ae.previous, te.removeNode(ae.value), ie(ae.value);
      }
      const se = {
        texts: this.texts.map((ae) => ({
          id: this.mirror.getId(ae.node),
          value: ae.value
        })).filter((ae) => !ee.has(ae.id)).filter((ae) => this.mirror.has(ae.id)),
        attributes: this.attributes.map((ae) => {
          const { attributes: ue } = ae;
          if (typeof ue.style == "string") {
            const le = JSON.stringify(ae.styleDiff), he = JSON.stringify(ae._unchangedStyles);
            le.length < ue.style.length && (le + he).split("var(").length === ue.style.split("var(").length && (ue.style = ae.styleDiff);
          }
          return {
            id: this.mirror.getId(ae.node),
            attributes: ue
          };
        }).filter((ae) => !ee.has(ae.id)).filter((ae) => this.mirror.has(ae.id)),
        removes: this.removes,
        adds: X
      };
      !se.texts.length && !se.attributes.length && !se.removes.length && !se.adds.length || (this.texts = [], this.attributes = [], this.removes = [], this.addedSet = /* @__PURE__ */ new Set(), this.movedSet = /* @__PURE__ */ new Set(), this.droppedSet = /* @__PURE__ */ new Set(), this.movedMap = {}, this.mutationCb(se));
    }, this.processMutation = (X) => {
      if (Tp(X.target, this.mirror))
        return;
      let ee;
      try {
        ee = document.implementation.createHTMLDocument();
      } catch {
        ee = this.doc;
      }
      switch (X.type) {
        case "characterData": {
          const te = X.target.textContent;
          !mi(X.target, this.blockClass, this.blockSelector, this.unblockSelector, !1) && te !== X.oldValue && this.texts.push({
            value: oc(X.target, this.maskTextClass, this.maskTextSelector, this.unmaskTextClass, this.unmaskTextSelector, this.maskAllText) && te ? this.maskTextFn ? this.maskTextFn(te) : te.replace(/[\S]/g, "*") : te,
            node: X.target
          });
          break;
        }
        case "attributes": {
          const te = X.target;
          let ne = X.attributeName, ie = X.target.getAttribute(ne);
          if (ne === "value") {
            const se = wb(te), ae = te.tagName;
            ie = ud(te, ae, se);
            const ue = D0({
              maskInputOptions: this.maskInputOptions,
              tagName: ae,
              type: se
            }), le = oc(X.target, this.maskTextClass, this.maskTextSelector, this.unmaskTextClass, this.unmaskTextSelector, ue);
            ie = ef({
              isMasked: le,
              element: te,
              value: ie,
              maskInputFn: this.maskInputFn
            });
          }
          if (mi(X.target, this.blockClass, this.blockSelector, this.unblockSelector, !1) || ie === X.oldValue)
            return;
          let oe = this.attributes.find((se) => se.node === X.target);
          if (te.tagName === "IFRAME" && ne === "src" && !this.keepIframeSrcFn(ie))
            if (!te.contentDocument)
              ne = "rr_src";
            else
              return;
          if (oe || (oe = {
            node: X.target,
            attributes: {},
            styleDiff: {},
            _unchangedStyles: {}
          }, this.attributes.push(oe)), ne === "type" && te.tagName === "INPUT" && (X.oldValue || "").toLowerCase() === "password" && te.setAttribute("data-rr-is-password", "true"), !z5(te.tagName, ne) && (oe.attributes[ne] = H5(this.doc, sc(te.tagName), sc(ne), ie, te, this.maskAttributeFn), ne === "style")) {
            const se = ee.createElement("span");
            X.oldValue && se.setAttribute("style", X.oldValue);
            for (const ae of Array.from(te.style)) {
              const ue = te.style.getPropertyValue(ae), le = te.style.getPropertyPriority(ae);
              ue !== se.style.getPropertyValue(ae) || le !== se.style.getPropertyPriority(ae) ? le === "" ? oe.styleDiff[ae] = ue : oe.styleDiff[ae] = [ue, le] : oe._unchangedStyles[ae] = [ue, le];
            }
            for (const ae of Array.from(se.style))
              te.style.getPropertyValue(ae) === "" && (oe.styleDiff[ae] = !1);
          }
          break;
        }
        case "childList": {
          if (mi(X.target, this.blockClass, this.blockSelector, this.unblockSelector, !0))
            return;
          X.addedNodes.forEach((te) => this.genAdds(te, X.target)), X.removedNodes.forEach((te) => {
            const ne = this.mirror.getId(te), ie = gu(X.target) ? this.mirror.getId(X.target.host) : this.mirror.getId(X.target);
            mi(X.target, this.blockClass, this.blockSelector, this.unblockSelector, !1) || Tp(te, this.mirror) || !kW(te, this.mirror) || (this.addedSet.has(te) ? (Kg(this.addedSet, te), this.droppedSet.add(te)) : this.addedSet.has(X.target) && ne === -1 || K5(X.target, this.mirror) || (this.movedSet.has(te) && this.movedMap[r2(ne, ie)] ? Kg(this.movedSet, te) : this.removes.push({
              parentId: ie,
              id: ne,
              isShadow: gu(X.target) && mu(X.target) ? !0 : void 0
            })), this.mapRemoves.push(te));
          });
          break;
        }
      }
    }, this.genAdds = (X, ee) => {
      if (!this.processedNodeManager.inOtherBuffer(X, this) && !(this.addedSet.has(X) || this.movedSet.has(X))) {
        if (this.mirror.hasNode(X)) {
          if (Tp(X, this.mirror))
            return;
          this.movedSet.add(X);
          let te = null;
          ee && this.mirror.hasNode(ee) && (te = this.mirror.getId(ee)), te && te !== -1 && (this.movedMap[r2(this.mirror.getId(X), te)] = !0);
        } else
          this.addedSet.add(X), this.droppedSet.delete(X);
        mi(X, this.blockClass, this.blockSelector, this.unblockSelector, !1) || (X.childNodes.forEach((te) => this.genAdds(te)), Wg(X) && X.shadowRoot.childNodes.forEach((te) => {
          this.processedNodeManager.add(te, this), this.genAdds(te, X);
        }));
      }
    };
  }
  init(X) {
    [
      "mutationCb",
      "blockClass",
      "blockSelector",
      "unblockSelector",
      "maskAllText",
      "maskTextClass",
      "unmaskTextClass",
      "maskTextSelector",
      "unmaskTextSelector",
      "inlineStylesheet",
      "maskInputOptions",
      "maskAttributeFn",
      "maskTextFn",
      "maskInputFn",
      "keepIframeSrcFn",
      "recordCanvas",
      "inlineImages",
      "slimDOMOptions",
      "dataURLOptions",
      "doc",
      "mirror",
      "iframeManager",
      "stylesheetManager",
      "shadowDomManager",
      "canvasManager",
      "processedNodeManager"
    ].forEach((ee) => {
      this[ee] = X[ee];
    });
  }
  freeze() {
    this.frozen = !0, this.canvasManager.freeze();
  }
  unfreeze() {
    this.frozen = !1, this.canvasManager.unfreeze(), this.emit();
  }
  isFrozen() {
    return this.frozen;
  }
  lock() {
    this.locked = !0, this.canvasManager.lock();
  }
  unlock() {
    this.locked = !1, this.canvasManager.unlock(), this.emit();
  }
  reset() {
    this.shadowDomManager.reset(), this.canvasManager.reset();
  }
}
function Kg(Y, X) {
  Y.delete(X), X.childNodes.forEach((ee) => Kg(Y, ee));
}
function n2(Y, X, ee) {
  return Y.length === 0 ? !1 : Q5(Y, X, ee);
}
function Q5(Y, X, ee) {
  const { parentNode: te } = X;
  if (!te)
    return !1;
  const ne = ee.getId(te);
  return Y.some((ie) => ie.id === ne) ? !0 : Q5(Y, te, ee);
}
function i2(Y, X) {
  return Y.size === 0 ? !1 : e8(Y, X);
}
function e8(Y, X) {
  const { parentNode: ee } = X;
  return ee ? Y.has(ee) ? !0 : e8(Y, ee) : !1;
}
let yu;
function qW(Y) {
  yu = Y;
}
function GW() {
  yu = void 0;
}
const Ht = (Y) => yu ? (...X) => {
  try {
    return Y(...X);
  } catch (ee) {
    if (yu && yu(ee) === !0)
      return () => {
      };
    throw ee;
  }
} : Y;
function Mi(Y) {
  let X, ee = Y[0], te = 1;
  for (; te < Y.length; ) {
    const ne = Y[te], ie = Y[te + 1];
    if (te += 2, (ne === "optionalAccess" || ne === "optionalCall") && ee == null)
      return;
    ne === "access" || ne === "optionalAccess" ? (X = ee, ee = ie(ee)) : (ne === "call" || ne === "optionalCall") && (ee = ie((...oe) => ee.call(X, ...oe)), X = void 0);
  }
  return ee;
}
const Sa = [];
function Mf(Y) {
  try {
    if ("composedPath" in Y) {
      const X = Y.composedPath();
      if (X.length)
        return X[0];
    } else if ("path" in Y && Y.path.length)
      return Y.path[0];
  } catch {
  }
  return Y && Y.target;
}
function t8(Y, X) {
  const ee = new zW();
  Sa.push(ee), ee.init(Y);
  let te = window.MutationObserver || window.__rrMutationObserver;
  const ne = Mi([window, "optionalAccess", (oe) => oe.Zone, "optionalAccess", (oe) => oe.__symbol__, "optionalCall", (oe) => oe("MutationObserver")]);
  ne && window[ne] && (te = window[ne]);
  const ie = new te(Ht((oe) => {
    Y.onMutation && Y.onMutation(oe) === !1 || ee.processMutations.bind(ee)(oe);
  }));
  return ie.observe(X, {
    attributes: !0,
    attributeOldValue: !0,
    characterData: !0,
    characterDataOldValue: !0,
    childList: !0,
    subtree: !0
  }), ie;
}
function VW({ mousemoveCb: Y, sampling: X, doc: ee, mirror: te }) {
  if (X.mousemove === !1)
    return () => {
    };
  const ne = typeof X.mousemove == "number" ? X.mousemove : 50, ie = typeof X.mousemoveCallback == "number" ? X.mousemoveCallback : 500;
  let oe = [], se;
  const ae = rf(Ht((he) => {
    const me = Date.now() - se;
    Y(oe.map((ye) => (ye.timeOffset -= me, ye)), he), oe = [], se = null;
  }), ie), ue = Ht(rf(Ht((he) => {
    const me = Mf(he), { clientX: ye, clientY: we } = Vg(he) ? he.changedTouches[0] : he;
    se || (se = ld()), oe.push({
      x: ye,
      y: we,
      id: te.getId(me),
      timeOffset: ld() - se
    }), ae(typeof DragEvent < "u" && he instanceof DragEvent ? Ot.Drag : he instanceof MouseEvent ? Ot.MouseMove : Ot.TouchMove);
  }), ne, {
    trailing: !1
  })), le = [
    bn$3("mousemove", ue, ee),
    bn$3("touchmove", ue, ee),
    bn$3("drag", ue, ee)
  ];
  return Ht(() => {
    le.forEach((he) => he());
  });
}
function WW({ mouseInteractionCb: Y, doc: X, mirror: ee, blockClass: te, blockSelector: ne, unblockSelector: ie, sampling: oe }) {
  if (oe.mouseInteraction === !1)
    return () => {
    };
  const se = oe.mouseInteraction === !0 || oe.mouseInteraction === void 0 ? {} : oe.mouseInteraction, ae = [];
  let ue = null;
  const le = (he) => (me) => {
    const ye = Mf(me);
    if (mi(ye, te, ne, ie, !0))
      return;
    let we = null, Ee = he;
    if ("pointerType" in me) {
      switch (me.pointerType) {
        case "mouse":
          we = fs.Mouse;
          break;
        case "touch":
          we = fs.Touch;
          break;
        case "pen":
          we = fs.Pen;
          break;
      }
      we === fs.Touch ? pn[he] === pn.MouseDown ? Ee = "TouchStart" : pn[he] === pn.MouseUp && (Ee = "TouchEnd") : fs.Pen;
    } else
      Vg(me) && (we = fs.Touch);
    we !== null ? (ue = we, (Ee.startsWith("Touch") && we === fs.Touch || Ee.startsWith("Mouse") && we === fs.Mouse) && (we = null)) : pn[he] === pn.Click && (we = ue, ue = null);
    const Re = Vg(me) ? me.changedTouches[0] : me;
    if (!Re)
      return;
    const Ue = ee.getId(ye), { clientX: Me, clientY: De } = Re;
    Ht(Y)({
      type: pn[Ee],
      id: Ue,
      x: Me,
      y: De,
      ...we !== null && { pointerType: we }
    });
  };
  return Object.keys(pn).filter((he) => Number.isNaN(Number(he)) && !he.endsWith("_Departed") && se[he] !== !1).forEach((he) => {
    let me = sc(he);
    const ye = le(he);
    if (window.PointerEvent)
      switch (pn[he]) {
        case pn.MouseDown:
        case pn.MouseUp:
          me = me.replace("mouse", "pointer");
          break;
        case pn.TouchStart:
        case pn.TouchEnd:
          return;
      }
    ae.push(bn$3(me, ye, X));
  }), Ht(() => {
    ae.forEach((he) => he());
  });
}
function r8({ scrollCb: Y, doc: X, mirror: ee, blockClass: te, blockSelector: ne, unblockSelector: ie, sampling: oe }) {
  const se = Ht(rf(Ht((ae) => {
    const ue = Mf(ae);
    if (!ue || mi(ue, te, ne, ie, !0))
      return;
    const le = ee.getId(ue);
    if (ue === X && X.defaultView) {
      const he = G5(X.defaultView);
      Y({
        id: le,
        x: he.left,
        y: he.top
      });
    } else
      Y({
        id: le,
        x: ue.scrollLeft,
        y: ue.scrollTop
      });
  }), oe.scroll || 100));
  return bn$3("scroll", se, X);
}
function KW({ viewportResizeCb: Y }, { win: X }) {
  let ee = -1, te = -1;
  const ne = Ht(rf(Ht(() => {
    const ie = V5(), oe = W5();
    (ee !== ie || te !== oe) && (Y({
      width: Number(oe),
      height: Number(ie)
    }), ee = ie, te = oe);
  }), 200));
  return bn$3("resize", ne, X);
}
const JW = ["INPUT", "TEXTAREA", "SELECT"], s2 = /* @__PURE__ */ new WeakMap();
function YW({ inputCb: Y, doc: X, mirror: ee, blockClass: te, blockSelector: ne, unblockSelector: ie, ignoreClass: oe, ignoreSelector: se, maskInputOptions: ae, maskInputFn: ue, sampling: le, userTriggeredOnInput: he, maskTextClass: me, unmaskTextClass: ye, maskTextSelector: we, unmaskTextSelector: Ee }) {
  function Re(tt) {
    let rt = Mf(tt);
    const it = tt.isTrusted, _t = rt && Gg(rt.tagName);
    if (_t === "OPTION" && (rt = rt.parentElement), !rt || !_t || JW.indexOf(_t) < 0 || mi(rt, te, ne, ie, !0))
      return;
    const Dt = rt;
    if (Dt.classList.contains(oe) || se && Dt.matches(se))
      return;
    const je = wb(rt);
    let ze = ud(Dt, _t, je), fe = !1;
    const de = D0({
      maskInputOptions: ae,
      tagName: _t,
      type: je
    }), be = oc(rt, me, we, ye, Ee, de);
    (je === "radio" || je === "checkbox") && (fe = rt.checked), ze = ef({
      isMasked: be,
      element: rt,
      value: ze,
      maskInputFn: ue
    }), Ue(rt, he ? { text: ze, isChecked: fe, userTriggered: it } : { text: ze, isChecked: fe });
    const Te = rt.name;
    je === "radio" && Te && fe && X.querySelectorAll(`input[type="radio"][name="${Te}"]`).forEach((Ce) => {
      if (Ce !== rt) {
        const Pe = ef({
          isMasked: be,
          element: Ce,
          value: ud(Ce, _t, je),
          maskInputFn: ue
        });
        Ue(Ce, he ? { text: Pe, isChecked: !fe, userTriggered: !1 } : { text: Pe, isChecked: !fe });
      }
    });
  }
  function Ue(tt, rt) {
    const it = s2.get(tt);
    if (!it || it.text !== rt.text || it.isChecked !== rt.isChecked) {
      s2.set(tt, rt);
      const _t = ee.getId(tt);
      Ht(Y)({
        ...rt,
        id: _t
      });
    }
  }
  const Me = (le.input === "last" ? ["change"] : ["input", "change"]).map((tt) => bn$3(tt, Ht(Re), X)), De = X.defaultView;
  if (!De)
    return () => {
      Me.forEach((tt) => tt());
    };
  const Fe = De.Object.getOwnPropertyDescriptor(De.HTMLInputElement.prototype, "value"), Ke = [
    [De.HTMLInputElement.prototype, "value"],
    [De.HTMLInputElement.prototype, "checked"],
    [De.HTMLSelectElement.prototype, "value"],
    [De.HTMLTextAreaElement.prototype, "value"],
    [De.HTMLSelectElement.prototype, "selectedIndex"],
    [De.HTMLOptionElement.prototype, "selected"]
  ];
  return Fe && Fe.set && Me.push(...Ke.map((tt) => q5(tt[0], tt[1], {
    set() {
      Ht(Re)({
        target: this,
        isTrusted: !1
      });
    }
  }, !1, De))), Ht(() => {
    Me.forEach((tt) => tt());
  });
}
function dd(Y) {
  const X = [];
  function ee(te, ne) {
    if (ll("CSSGroupingRule") && te.parentRule instanceof CSSGroupingRule || ll("CSSMediaRule") && te.parentRule instanceof CSSMediaRule || ll("CSSSupportsRule") && te.parentRule instanceof CSSSupportsRule || ll("CSSConditionRule") && te.parentRule instanceof CSSConditionRule) {
      const ie = Array.from(te.parentRule.cssRules).indexOf(te);
      ne.unshift(ie);
    } else if (te.parentStyleSheet) {
      const ie = Array.from(te.parentStyleSheet.cssRules).indexOf(te);
      ne.unshift(ie);
    }
    return ne;
  }
  return ee(Y, X);
}
function Vs(Y, X, ee) {
  let te, ne;
  return Y ? (Y.ownerNode ? te = X.getId(Y.ownerNode) : ne = ee.getId(Y), {
    styleId: ne,
    id: te
  }) : {};
}
function XW({ styleSheetRuleCb: Y, mirror: X, stylesheetManager: ee }, { win: te }) {
  if (!te.CSSStyleSheet || !te.CSSStyleSheet.prototype)
    return () => {
    };
  const ne = te.CSSStyleSheet.prototype.insertRule;
  te.CSSStyleSheet.prototype.insertRule = new Proxy(ne, {
    apply: Ht((le, he, me) => {
      const [ye, we] = me, { id: Ee, styleId: Re } = Vs(he, X, ee.styleMirror);
      return (Ee && Ee !== -1 || Re && Re !== -1) && Y({
        id: Ee,
        styleId: Re,
        adds: [{ rule: ye, index: we }]
      }), le.apply(he, me);
    })
  });
  const ie = te.CSSStyleSheet.prototype.deleteRule;
  te.CSSStyleSheet.prototype.deleteRule = new Proxy(ie, {
    apply: Ht((le, he, me) => {
      const [ye] = me, { id: we, styleId: Ee } = Vs(he, X, ee.styleMirror);
      return (we && we !== -1 || Ee && Ee !== -1) && Y({
        id: we,
        styleId: Ee,
        removes: [{ index: ye }]
      }), le.apply(he, me);
    })
  });
  let oe;
  te.CSSStyleSheet.prototype.replace && (oe = te.CSSStyleSheet.prototype.replace, te.CSSStyleSheet.prototype.replace = new Proxy(oe, {
    apply: Ht((le, he, me) => {
      const [ye] = me, { id: we, styleId: Ee } = Vs(he, X, ee.styleMirror);
      return (we && we !== -1 || Ee && Ee !== -1) && Y({
        id: we,
        styleId: Ee,
        replace: ye
      }), le.apply(he, me);
    })
  }));
  let se;
  te.CSSStyleSheet.prototype.replaceSync && (se = te.CSSStyleSheet.prototype.replaceSync, te.CSSStyleSheet.prototype.replaceSync = new Proxy(se, {
    apply: Ht((le, he, me) => {
      const [ye] = me, { id: we, styleId: Ee } = Vs(he, X, ee.styleMirror);
      return (we && we !== -1 || Ee && Ee !== -1) && Y({
        id: we,
        styleId: Ee,
        replaceSync: ye
      }), le.apply(he, me);
    })
  }));
  const ae = {};
  dl("CSSGroupingRule") ? ae.CSSGroupingRule = te.CSSGroupingRule : (dl("CSSMediaRule") && (ae.CSSMediaRule = te.CSSMediaRule), dl("CSSConditionRule") && (ae.CSSConditionRule = te.CSSConditionRule), dl("CSSSupportsRule") && (ae.CSSSupportsRule = te.CSSSupportsRule));
  const ue = {};
  return Object.entries(ae).forEach(([le, he]) => {
    ue[le] = {
      insertRule: he.prototype.insertRule,
      deleteRule: he.prototype.deleteRule
    }, he.prototype.insertRule = new Proxy(ue[le].insertRule, {
      apply: Ht((me, ye, we) => {
        const [Ee, Re] = we, { id: Ue, styleId: Me } = Vs(ye.parentStyleSheet, X, ee.styleMirror);
        return (Ue && Ue !== -1 || Me && Me !== -1) && Y({
          id: Ue,
          styleId: Me,
          adds: [
            {
              rule: Ee,
              index: [
                ...dd(ye),
                Re || 0
              ]
            }
          ]
        }), me.apply(ye, we);
      })
    }), he.prototype.deleteRule = new Proxy(ue[le].deleteRule, {
      apply: Ht((me, ye, we) => {
        const [Ee] = we, { id: Re, styleId: Ue } = Vs(ye.parentStyleSheet, X, ee.styleMirror);
        return (Re && Re !== -1 || Ue && Ue !== -1) && Y({
          id: Re,
          styleId: Ue,
          removes: [
            { index: [...dd(ye), Ee] }
          ]
        }), me.apply(ye, we);
      })
    });
  }), Ht(() => {
    te.CSSStyleSheet.prototype.insertRule = ne, te.CSSStyleSheet.prototype.deleteRule = ie, oe && (te.CSSStyleSheet.prototype.replace = oe), se && (te.CSSStyleSheet.prototype.replaceSync = se), Object.entries(ae).forEach(([le, he]) => {
      he.prototype.insertRule = ue[le].insertRule, he.prototype.deleteRule = ue[le].deleteRule;
    });
  });
}
function n8({ mirror: Y, stylesheetManager: X }, ee) {
  let te = null;
  ee.nodeName === "#document" ? te = Y.getId(ee) : te = Y.getId(ee.host);
  const ne = ee.nodeName === "#document" ? Mi([ee, "access", (oe) => oe.defaultView, "optionalAccess", (oe) => oe.Document]) : Mi([ee, "access", (oe) => oe.ownerDocument, "optionalAccess", (oe) => oe.defaultView, "optionalAccess", (oe) => oe.ShadowRoot]), ie = Mi([ne, "optionalAccess", (oe) => oe.prototype]) ? Object.getOwnPropertyDescriptor(Mi([ne, "optionalAccess", (oe) => oe.prototype]), "adoptedStyleSheets") : void 0;
  return te === null || te === -1 || !ne || !ie ? () => {
  } : (Object.defineProperty(ee, "adoptedStyleSheets", {
    configurable: ie.configurable,
    enumerable: ie.enumerable,
    get() {
      return Mi([ie, "access", (oe) => oe.get, "optionalAccess", (oe) => oe.call, "call", (oe) => oe(this)]);
    },
    set(oe) {
      const se = Mi([ie, "access", (ae) => ae.set, "optionalAccess", (ae) => ae.call, "call", (ae) => ae(this, oe)]);
      if (te !== null && te !== -1)
        try {
          X.adoptStyleSheets(oe, te);
        } catch {
        }
      return se;
    }
  }), Ht(() => {
    Object.defineProperty(ee, "adoptedStyleSheets", {
      configurable: ie.configurable,
      enumerable: ie.enumerable,
      get: ie.get,
      set: ie.set
    });
  }));
}
function ZW({ styleDeclarationCb: Y, mirror: X, ignoreCSSAttributes: ee, stylesheetManager: te }, { win: ne }) {
  const ie = ne.CSSStyleDeclaration.prototype.setProperty;
  ne.CSSStyleDeclaration.prototype.setProperty = new Proxy(ie, {
    apply: Ht((se, ae, ue) => {
      const [le, he, me] = ue;
      if (ee.has(le))
        return ie.apply(ae, [le, he, me]);
      const { id: ye, styleId: we } = Vs(Mi([ae, "access", (Ee) => Ee.parentRule, "optionalAccess", (Ee) => Ee.parentStyleSheet]), X, te.styleMirror);
      return (ye && ye !== -1 || we && we !== -1) && Y({
        id: ye,
        styleId: we,
        set: {
          property: le,
          value: he,
          priority: me
        },
        index: dd(ae.parentRule)
      }), se.apply(ae, ue);
    })
  });
  const oe = ne.CSSStyleDeclaration.prototype.removeProperty;
  return ne.CSSStyleDeclaration.prototype.removeProperty = new Proxy(oe, {
    apply: Ht((se, ae, ue) => {
      const [le] = ue;
      if (ee.has(le))
        return oe.apply(ae, [le]);
      const { id: he, styleId: me } = Vs(Mi([ae, "access", (ye) => ye.parentRule, "optionalAccess", (ye) => ye.parentStyleSheet]), X, te.styleMirror);
      return (he && he !== -1 || me && me !== -1) && Y({
        id: he,
        styleId: me,
        remove: {
          property: le
        },
        index: dd(ae.parentRule)
      }), se.apply(ae, ue);
    })
  }), Ht(() => {
    ne.CSSStyleDeclaration.prototype.setProperty = ie, ne.CSSStyleDeclaration.prototype.removeProperty = oe;
  });
}
function QW({ mediaInteractionCb: Y, blockClass: X, blockSelector: ee, unblockSelector: te, mirror: ne, sampling: ie, doc: oe }) {
  const se = Ht((ue) => rf(Ht((le) => {
    const he = Mf(le);
    if (!he || mi(he, X, ee, te, !0))
      return;
    const { currentTime: me, volume: ye, muted: we, playbackRate: Ee } = he;
    Y({
      type: ue,
      id: ne.getId(he),
      currentTime: me,
      volume: ye,
      muted: we,
      playbackRate: Ee
    });
  }), ie.media || 500)), ae = [
    bn$3("play", se(0), oe),
    bn$3("pause", se(1), oe),
    bn$3("seeked", se(2), oe),
    bn$3("volumechange", se(3), oe),
    bn$3("ratechange", se(4), oe)
  ];
  return Ht(() => {
    ae.forEach((ue) => ue());
  });
}
function eK({ fontCb: Y, doc: X }) {
  const ee = X.defaultView;
  if (!ee)
    return () => {
    };
  const te = [], ne = /* @__PURE__ */ new WeakMap(), ie = ee.FontFace;
  ee.FontFace = function(se, ae, ue) {
    const le = new ie(se, ae, ue);
    return ne.set(le, {
      family: se,
      buffer: typeof ae != "string",
      descriptors: ue,
      fontSource: typeof ae == "string" ? ae : JSON.stringify(Array.from(new Uint8Array(ae)))
    }), le;
  };
  const oe = _b(X.fonts, "add", function(se) {
    return function(ae) {
      return setTimeout(Ht(() => {
        const ue = ne.get(ae);
        ue && (Y(ue), ne.delete(ae));
      }), 0), se.apply(this, [ae]);
    };
  });
  return te.push(() => {
    ee.FontFace = ie;
  }), te.push(oe), Ht(() => {
    te.forEach((se) => se());
  });
}
function tK(Y) {
  const { doc: X, mirror: ee, blockClass: te, blockSelector: ne, unblockSelector: ie, selectionCb: oe } = Y;
  let se = !0;
  const ae = Ht(() => {
    const ue = X.getSelection();
    if (!ue || se && Mi([ue, "optionalAccess", (me) => me.isCollapsed]))
      return;
    se = ue.isCollapsed || !1;
    const le = [], he = ue.rangeCount || 0;
    for (let me = 0; me < he; me++) {
      const ye = ue.getRangeAt(me), { startContainer: we, startOffset: Ee, endContainer: Re, endOffset: Ue } = ye;
      mi(we, te, ne, ie, !0) || mi(Re, te, ne, ie, !0) || le.push({
        start: ee.getId(we),
        startOffset: Ee,
        end: ee.getId(Re),
        endOffset: Ue
      });
    }
    oe({ ranges: le });
  });
  return ae(), bn$3("selectionchange", ae);
}
function rK({ doc: Y, customElementCb: X }) {
  const ee = Y.defaultView;
  return !ee || !ee.customElements ? () => {
  } : _b(ee.customElements, "define", function(te) {
    return function(ne, ie, oe) {
      try {
        X({
          define: {
            name: ne
          }
        });
      } catch {
      }
      return te.apply(this, [ne, ie, oe]);
    };
  });
}
function nK(Y, X = {}) {
  const ee = Y.doc.defaultView;
  if (!ee)
    return () => {
    };
  const te = t8(Y, Y.doc), ne = VW(Y), ie = WW(Y), oe = r8(Y), se = KW(Y, {
    win: ee
  }), ae = YW(Y), ue = QW(Y), le = XW(Y, { win: ee }), he = n8(Y, Y.doc), me = ZW(Y, {
    win: ee
  }), ye = Y.collectFonts ? eK(Y) : () => {
  }, we = tK(Y), Ee = rK(Y), Re = [];
  for (const Ue of Y.plugins)
    Re.push(Ue.observer(Ue.callback, ee, Ue.options));
  return Ht(() => {
    Sa.forEach((Ue) => Ue.reset()), te.disconnect(), ne(), ie(), oe(), se(), ae(), ue(), le(), he(), me(), ye(), we(), Ee(), Re.forEach((Ue) => Ue());
  });
}
function ll(Y) {
  return typeof window[Y] < "u";
}
function dl(Y) {
  return !!(typeof window[Y] < "u" && window[Y].prototype && "insertRule" in window[Y].prototype && "deleteRule" in window[Y].prototype);
}
class Jg {
  constructor(X) {
    this.generateIdFn = X, this.iframeIdToRemoteIdMap = /* @__PURE__ */ new WeakMap(), this.iframeRemoteIdToIdMap = /* @__PURE__ */ new WeakMap();
  }
  getId(X, ee, te, ne) {
    const ie = te || this.getIdToRemoteIdMap(X), oe = ne || this.getRemoteIdToIdMap(X);
    let se = ie.get(ee);
    return se || (se = this.generateIdFn(), ie.set(ee, se), oe.set(se, ee)), se;
  }
  getIds(X, ee) {
    const te = this.getIdToRemoteIdMap(X), ne = this.getRemoteIdToIdMap(X);
    return ee.map((ie) => this.getId(X, ie, te, ne));
  }
  getRemoteId(X, ee, te) {
    const ne = te || this.getRemoteIdToIdMap(X);
    return typeof ee != "number" ? ee : ne.get(ee) || -1;
  }
  getRemoteIds(X, ee) {
    const te = this.getRemoteIdToIdMap(X);
    return ee.map((ne) => this.getRemoteId(X, ne, te));
  }
  reset(X) {
    if (!X) {
      this.iframeIdToRemoteIdMap = /* @__PURE__ */ new WeakMap(), this.iframeRemoteIdToIdMap = /* @__PURE__ */ new WeakMap();
      return;
    }
    this.iframeIdToRemoteIdMap.delete(X), this.iframeRemoteIdToIdMap.delete(X);
  }
  getIdToRemoteIdMap(X) {
    let ee = this.iframeIdToRemoteIdMap.get(X);
    return ee || (ee = /* @__PURE__ */ new Map(), this.iframeIdToRemoteIdMap.set(X, ee)), ee;
  }
  getRemoteIdToIdMap(X) {
    let ee = this.iframeRemoteIdToIdMap.get(X);
    return ee || (ee = /* @__PURE__ */ new Map(), this.iframeRemoteIdToIdMap.set(X, ee)), ee;
  }
}
function o2(Y) {
  let X, ee = Y[0], te = 1;
  for (; te < Y.length; ) {
    const ne = Y[te], ie = Y[te + 1];
    if (te += 2, (ne === "optionalAccess" || ne === "optionalCall") && ee == null)
      return;
    ne === "access" || ne === "optionalAccess" ? (X = ee, ee = ie(ee)) : (ne === "call" || ne === "optionalCall") && (ee = ie((...oe) => ee.call(X, ...oe)), X = void 0);
  }
  return ee;
}
class iK {
  constructor() {
    this.crossOriginIframeMirror = new Jg(vb), this.crossOriginIframeRootIdMap = /* @__PURE__ */ new WeakMap();
  }
  addIframe() {
  }
  addLoadListener() {
  }
  attachIframe() {
  }
}
class sK {
  constructor(X) {
    this.iframes = /* @__PURE__ */ new WeakMap(), this.crossOriginIframeMap = /* @__PURE__ */ new WeakMap(), this.crossOriginIframeMirror = new Jg(vb), this.crossOriginIframeRootIdMap = /* @__PURE__ */ new WeakMap(), this.mutationCb = X.mutationCb, this.wrappedEmit = X.wrappedEmit, this.stylesheetManager = X.stylesheetManager, this.recordCrossOriginIframes = X.recordCrossOriginIframes, this.crossOriginIframeStyleMirror = new Jg(this.stylesheetManager.styleMirror.generateId.bind(this.stylesheetManager.styleMirror)), this.mirror = X.mirror, this.recordCrossOriginIframes && window.addEventListener("message", this.handleMessage.bind(this));
  }
  addIframe(X) {
    this.iframes.set(X, !0), X.contentWindow && this.crossOriginIframeMap.set(X.contentWindow, X);
  }
  addLoadListener(X) {
    this.loadListener = X;
  }
  attachIframe(X, ee) {
    this.mutationCb({
      adds: [
        {
          parentId: this.mirror.getId(X),
          nextId: null,
          node: ee
        }
      ],
      removes: [],
      texts: [],
      attributes: [],
      isAttachIframe: !0
    }), o2([this, "access", (te) => te.loadListener, "optionalCall", (te) => te(X)]), X.contentDocument && X.contentDocument.adoptedStyleSheets && X.contentDocument.adoptedStyleSheets.length > 0 && this.stylesheetManager.adoptStyleSheets(X.contentDocument.adoptedStyleSheets, this.mirror.getId(X.contentDocument));
  }
  handleMessage(X) {
    const ee = X;
    if (ee.data.type !== "rrweb" || ee.origin !== ee.data.origin || !X.source)
      return;
    const te = this.crossOriginIframeMap.get(X.source);
    if (!te)
      return;
    const ne = this.transformCrossOriginEvent(te, ee.data.event);
    ne && this.wrappedEmit(ne, ee.data.isCheckout);
  }
  transformCrossOriginEvent(X, ee) {
    switch (ee.type) {
      case Pt.FullSnapshot: {
        this.crossOriginIframeMirror.reset(X), this.crossOriginIframeStyleMirror.reset(X), this.replaceIdOnNode(ee.data.node, X);
        const te = ee.data.node.id;
        return this.crossOriginIframeRootIdMap.set(X, te), this.patchRootIdOnNode(ee.data.node, te), {
          timestamp: ee.timestamp,
          type: Pt.IncrementalSnapshot,
          data: {
            source: Ot.Mutation,
            adds: [
              {
                parentId: this.mirror.getId(X),
                nextId: null,
                node: ee.data.node
              }
            ],
            removes: [],
            texts: [],
            attributes: [],
            isAttachIframe: !0
          }
        };
      }
      case Pt.Meta:
      case Pt.Load:
      case Pt.DomContentLoaded:
        return !1;
      case Pt.Plugin:
        return ee;
      case Pt.Custom:
        return this.replaceIds(ee.data.payload, X, ["id", "parentId", "previousId", "nextId"]), ee;
      case Pt.IncrementalSnapshot:
        switch (ee.data.source) {
          case Ot.Mutation:
            return ee.data.adds.forEach((te) => {
              this.replaceIds(te, X, [
                "parentId",
                "nextId",
                "previousId"
              ]), this.replaceIdOnNode(te.node, X);
              const ne = this.crossOriginIframeRootIdMap.get(X);
              ne && this.patchRootIdOnNode(te.node, ne);
            }), ee.data.removes.forEach((te) => {
              this.replaceIds(te, X, ["parentId", "id"]);
            }), ee.data.attributes.forEach((te) => {
              this.replaceIds(te, X, ["id"]);
            }), ee.data.texts.forEach((te) => {
              this.replaceIds(te, X, ["id"]);
            }), ee;
          case Ot.Drag:
          case Ot.TouchMove:
          case Ot.MouseMove:
            return ee.data.positions.forEach((te) => {
              this.replaceIds(te, X, ["id"]);
            }), ee;
          case Ot.ViewportResize:
            return !1;
          case Ot.MediaInteraction:
          case Ot.MouseInteraction:
          case Ot.Scroll:
          case Ot.CanvasMutation:
          case Ot.Input:
            return this.replaceIds(ee.data, X, ["id"]), ee;
          case Ot.StyleSheetRule:
          case Ot.StyleDeclaration:
            return this.replaceIds(ee.data, X, ["id"]), this.replaceStyleIds(ee.data, X, ["styleId"]), ee;
          case Ot.Font:
            return ee;
          case Ot.Selection:
            return ee.data.ranges.forEach((te) => {
              this.replaceIds(te, X, ["start", "end"]);
            }), ee;
          case Ot.AdoptedStyleSheet:
            return this.replaceIds(ee.data, X, ["id"]), this.replaceStyleIds(ee.data, X, ["styleIds"]), o2([ee, "access", (te) => te.data, "access", (te) => te.styles, "optionalAccess", (te) => te.forEach, "call", (te) => te((ne) => {
              this.replaceStyleIds(ne, X, ["styleId"]);
            })]), ee;
        }
    }
    return !1;
  }
  replace(X, ee, te, ne) {
    for (const ie of ne)
      !Array.isArray(ee[ie]) && typeof ee[ie] != "number" || (Array.isArray(ee[ie]) ? ee[ie] = X.getIds(te, ee[ie]) : ee[ie] = X.getId(te, ee[ie]));
    return ee;
  }
  replaceIds(X, ee, te) {
    return this.replace(this.crossOriginIframeMirror, X, ee, te);
  }
  replaceStyleIds(X, ee, te) {
    return this.replace(this.crossOriginIframeStyleMirror, X, ee, te);
  }
  replaceIdOnNode(X, ee) {
    this.replaceIds(X, ee, ["id", "rootId"]), "childNodes" in X && X.childNodes.forEach((te) => {
      this.replaceIdOnNode(te, ee);
    });
  }
  patchRootIdOnNode(X, ee) {
    X.type !== jr.Document && !X.rootId && (X.rootId = ee), "childNodes" in X && X.childNodes.forEach((te) => {
      this.patchRootIdOnNode(te, ee);
    });
  }
}
class oK {
  init() {
  }
  addShadowRoot() {
  }
  observeAttachShadow() {
  }
  reset() {
  }
}
class aK {
  constructor(X) {
    this.shadowDoms = /* @__PURE__ */ new WeakSet(), this.restoreHandlers = [], this.mutationCb = X.mutationCb, this.scrollCb = X.scrollCb, this.bypassOptions = X.bypassOptions, this.mirror = X.mirror, this.init();
  }
  init() {
    this.reset(), this.patchAttachShadow(Element, document);
  }
  addShadowRoot(X, ee) {
    if (!mu(X) || this.shadowDoms.has(X))
      return;
    this.shadowDoms.add(X);
    const te = t8({
      ...this.bypassOptions,
      doc: ee,
      mutationCb: this.mutationCb,
      mirror: this.mirror,
      shadowDomManager: this
    }, X);
    this.restoreHandlers.push(() => te.disconnect()), this.restoreHandlers.push(r8({
      ...this.bypassOptions,
      scrollCb: this.scrollCb,
      doc: X,
      mirror: this.mirror
    })), setTimeout(() => {
      X.adoptedStyleSheets && X.adoptedStyleSheets.length > 0 && this.bypassOptions.stylesheetManager.adoptStyleSheets(X.adoptedStyleSheets, this.mirror.getId(X.host)), this.restoreHandlers.push(n8({
        mirror: this.mirror,
        stylesheetManager: this.bypassOptions.stylesheetManager
      }, X));
    }, 0);
  }
  observeAttachShadow(X) {
    !X.contentWindow || !X.contentDocument || this.patchAttachShadow(X.contentWindow.Element, X.contentDocument);
  }
  patchAttachShadow(X, ee) {
    const te = this;
    this.restoreHandlers.push(_b(X.prototype, "attachShadow", function(ne) {
      return function(ie) {
        const oe = ne.call(this, ie);
        return this.shadowRoot && Z5(this) && te.addShadowRoot(this.shadowRoot, ee), oe;
      };
    }));
  }
  reset() {
    this.restoreHandlers.forEach((X) => {
      try {
        X();
      } catch {
      }
    }), this.restoreHandlers = [], this.shadowDoms = /* @__PURE__ */ new WeakSet();
  }
}
class a2 {
  reset() {
  }
  freeze() {
  }
  unfreeze() {
  }
  lock() {
  }
  unlock() {
  }
  snapshot() {
  }
}
class cK {
  constructor(X) {
    this.trackedLinkElements = /* @__PURE__ */ new WeakSet(), this.styleMirror = new LW(), this.mutationCb = X.mutationCb, this.adoptedStyleSheetCb = X.adoptedStyleSheetCb;
  }
  attachLinkElement(X, ee) {
    "_cssText" in ee.attributes && this.mutationCb({
      adds: [],
      removes: [],
      texts: [],
      attributes: [
        {
          id: ee.id,
          attributes: ee.attributes
        }
      ]
    }), this.trackLinkElement(X);
  }
  trackLinkElement(X) {
    this.trackedLinkElements.has(X) || (this.trackedLinkElements.add(X), this.trackStylesheetInLinkElement(X));
  }
  adoptStyleSheets(X, ee) {
    if (X.length === 0)
      return;
    const te = {
      id: ee,
      styleIds: []
    }, ne = [];
    for (const ie of X) {
      let oe;
      this.styleMirror.has(ie) ? oe = this.styleMirror.getId(ie) : (oe = this.styleMirror.add(ie), ne.push({
        styleId: oe,
        rules: Array.from(ie.rules || CSSRule, (se, ae) => ({
          rule: U5(se),
          index: ae
        }))
      })), te.styleIds.push(oe);
    }
    ne.length > 0 && (te.styles = ne), this.adoptedStyleSheetCb(te);
  }
  reset() {
    this.styleMirror.reset(), this.trackedLinkElements = /* @__PURE__ */ new WeakSet();
  }
  trackStylesheetInLinkElement(X) {
  }
}
class uK {
  constructor() {
    this.nodeMap = /* @__PURE__ */ new WeakMap(), this.loop = !0, this.periodicallyClear();
  }
  periodicallyClear() {
    UW(() => {
      this.clear(), this.loop && this.periodicallyClear();
    });
  }
  inOtherBuffer(X, ee) {
    const te = this.nodeMap.get(X);
    return te && Array.from(te).some((ne) => ne !== ee);
  }
  add(X, ee) {
    this.nodeMap.set(X, (this.nodeMap.get(X) || /* @__PURE__ */ new Set()).add(ee));
  }
  clear() {
    this.nodeMap = /* @__PURE__ */ new WeakMap();
  }
  destroy() {
    this.loop = !1;
  }
}
function kr(Y) {
  const X = Y;
  return X.timestamp = ld(), X;
}
let hd;
const di = fW();
function io(Y = {}) {
  const { emit: X, checkoutEveryNms: ee, checkoutEveryNth: te, blockClass: ne = "rr-block", blockSelector: ie = null, unblockSelector: oe = null, ignoreClass: se = "rr-ignore", ignoreSelector: ae = null, maskAllText: ue = !1, maskTextClass: le = "rr-mask", unmaskTextClass: he = null, maskTextSelector: me = null, unmaskTextSelector: ye = null, inlineStylesheet: we = !0, maskAllInputs: Ee, maskInputOptions: Re, slimDOMOptions: Ue, maskAttributeFn: Me, maskInputFn: De, maskTextFn: Fe, packFn: Ke, sampling: tt = {}, dataURLOptions: rt = {}, mousemoveWait: it, recordCanvas: _t = !1, recordCrossOriginIframes: Dt = !1, recordAfter: je = Y.recordAfter === "DOMContentLoaded" ? Y.recordAfter : "load", userTriggeredOnInput: ze = !1, collectFonts: fe = !1, inlineImages: de = !1, plugins: be, keepIframeSrcFn: Te = () => !1, ignoreCSSAttributes: Ce = /* @__PURE__ */ new Set([]), errorHandler: Pe, onMutation: Se, getCanvasManager: ke } = Y;
  qW(Pe);
  const ge = Dt ? window.parent === window : !0;
  let Ae = !1;
  if (!ge)
    try {
      window.parent.document && (Ae = !1);
    } catch {
      Ae = !0;
    }
  if (ge && !X)
    throw new Error("emit function is required");
  it !== void 0 && tt.mousemove === void 0 && (tt.mousemove = it), di.reset();
  const Ge = Ee === !0 ? {
    color: !0,
    date: !0,
    "datetime-local": !0,
    email: !0,
    month: !0,
    number: !0,
    range: !0,
    search: !0,
    tel: !0,
    text: !0,
    time: !0,
    url: !0,
    week: !0,
    textarea: !0,
    select: !0,
    radio: !0,
    checkbox: !0
  } : Re !== void 0 ? Re : {}, Xe = Ue === !0 || Ue === "all" ? {
    script: !0,
    comment: !0,
    headFavicon: !0,
    headWhitespace: !0,
    headMetaSocial: !0,
    headMetaRobots: !0,
    headMetaHttpEquiv: !0,
    headMetaVerification: !0,
    headMetaAuthorship: Ue === "all",
    headMetaDescKeywords: Ue === "all"
  } : Ue || {};
  MW();
  let $e, Ze = 0;
  const ot = (Ct) => {
    for (const w_ of be || [])
      w_.eventProcessor && (Ct = w_.eventProcessor(Ct));
    return Ke && !Ae && (Ct = Ke(Ct)), Ct;
  }, ct = (Ct, w_) => {
    if (vp([Sa, "access", (hX) => hX[0], "optionalAccess", (hX) => hX.isFrozen, "call", (hX) => hX()]) && Ct.type !== Pt.FullSnapshot && !(Ct.type === Pt.IncrementalSnapshot && Ct.data.source === Ot.Mutation) && Sa.forEach((hX) => hX.unfreeze()), ge)
      vp([X, "optionalCall", (hX) => hX(ot(Ct), w_)]);
    else if (Ae) {
      const hX = {
        type: "rrweb",
        event: ot(Ct),
        origin: window.location.origin,
        isCheckout: w_
      };
      window.parent.postMessage(hX, "*");
    }
    if (Ct.type === Pt.FullSnapshot)
      $e = Ct, Ze = 0;
    else if (Ct.type === Pt.IncrementalSnapshot) {
      if (Ct.data.source === Ot.Mutation && Ct.data.isAttachIframe)
        return;
      Ze++;
      const hX = te && Ze >= te, oX = ee && Ct.timestamp - $e.timestamp > ee;
      (hX || oX) && wX(!0);
    }
  }, At = (Ct) => {
    ct(kr({
      type: Pt.IncrementalSnapshot,
      data: {
        source: Ot.Mutation,
        ...Ct
      }
    }));
  }, Tt = (Ct) => ct(kr({
    type: Pt.IncrementalSnapshot,
    data: {
      source: Ot.Scroll,
      ...Ct
    }
  })), dt = (Ct) => ct(kr({
    type: Pt.IncrementalSnapshot,
    data: {
      source: Ot.CanvasMutation,
      ...Ct
    }
  })), vt = (Ct) => ct(kr({
    type: Pt.IncrementalSnapshot,
    data: {
      source: Ot.AdoptedStyleSheet,
      ...Ct
    }
  })), Ut = new cK({
    mutationCb: At,
    adoptedStyleSheetCb: vt
  }), It = typeof __RRWEB_EXCLUDE_IFRAME__ == "boolean" && __RRWEB_EXCLUDE_IFRAME__ ? new iK() : new sK({
    mirror: di,
    mutationCb: At,
    stylesheetManager: Ut,
    recordCrossOriginIframes: Dt,
    wrappedEmit: ct
  });
  for (const Ct of be || [])
    Ct.getMirror && Ct.getMirror({
      nodeMirror: di,
      crossOriginIframeMirror: It.crossOriginIframeMirror,
      crossOriginIframeStyleMirror: It.crossOriginIframeStyleMirror
    });
  const Er = new uK(), Fr = lK(ke, {
    mirror: di,
    win: window,
    mutationCb: (Ct) => ct(kr({
      type: Pt.IncrementalSnapshot,
      data: {
        source: Ot.CanvasMutation,
        ...Ct
      }
    })),
    recordCanvas: _t,
    blockClass: ne,
    blockSelector: ie,
    unblockSelector: oe,
    sampling: tt.canvas,
    dataURLOptions: rt,
    errorHandler: Pe
  }), an = typeof __RRWEB_EXCLUDE_SHADOW_DOM__ == "boolean" && __RRWEB_EXCLUDE_SHADOW_DOM__ ? new oK() : new aK({
    mutationCb: At,
    scrollCb: Tt,
    bypassOptions: {
      onMutation: Se,
      blockClass: ne,
      blockSelector: ie,
      unblockSelector: oe,
      maskAllText: ue,
      maskTextClass: le,
      unmaskTextClass: he,
      maskTextSelector: me,
      unmaskTextSelector: ye,
      inlineStylesheet: we,
      maskInputOptions: Ge,
      dataURLOptions: rt,
      maskAttributeFn: Me,
      maskTextFn: Fe,
      maskInputFn: De,
      recordCanvas: _t,
      inlineImages: de,
      sampling: tt,
      slimDOMOptions: Xe,
      iframeManager: It,
      stylesheetManager: Ut,
      canvasManager: Fr,
      keepIframeSrcFn: Te,
      processedNodeManager: Er
    },
    mirror: di
  }), wX = (Ct = !1) => {
    ct(kr({
      type: Pt.Meta,
      data: {
        href: window.location.href,
        width: W5(),
        height: V5()
      }
    }), Ct), Ut.reset(), an.init(), Sa.forEach((hX) => hX.lock());
    const w_ = NW(document, {
      mirror: di,
      blockClass: ne,
      blockSelector: ie,
      unblockSelector: oe,
      maskAllText: ue,
      maskTextClass: le,
      unmaskTextClass: he,
      maskTextSelector: me,
      unmaskTextSelector: ye,
      inlineStylesheet: we,
      maskAllInputs: Ge,
      maskAttributeFn: Me,
      maskInputFn: De,
      maskTextFn: Fe,
      slimDOM: Xe,
      dataURLOptions: rt,
      recordCanvas: _t,
      inlineImages: de,
      onSerialize: (hX) => {
        J5(hX, di) && It.addIframe(hX), Y5(hX, di) && Ut.trackLinkElement(hX), Wg(hX) && an.addShadowRoot(hX.shadowRoot, document);
      },
      onIframeLoad: (hX, oX) => {
        It.attachIframe(hX, oX), an.observeAttachShadow(hX);
      },
      onStylesheetLoad: (hX, oX) => {
        Ut.attachLinkElement(hX, oX);
      },
      keepIframeSrcFn: Te
    });
    if (!w_)
      return console.warn("Failed to snapshot the document");
    ct(kr({
      type: Pt.FullSnapshot,
      data: {
        node: w_,
        initialOffset: G5(window)
      }
    })), Sa.forEach((hX) => hX.unlock()), document.adoptedStyleSheets && document.adoptedStyleSheets.length > 0 && Ut.adoptStyleSheets(document.adoptedStyleSheets, di.getId(document));
  };
  hd = wX;
  try {
    const Ct = [], w_ = (oX) => Ht(nK)({
      onMutation: Se,
      mutationCb: At,
      mousemoveCb: (Nn, SX) => ct(kr({
        type: Pt.IncrementalSnapshot,
        data: {
          source: SX,
          positions: Nn
        }
      })),
      mouseInteractionCb: (Nn) => ct(kr({
        type: Pt.IncrementalSnapshot,
        data: {
          source: Ot.MouseInteraction,
          ...Nn
        }
      })),
      scrollCb: Tt,
      viewportResizeCb: (Nn) => ct(kr({
        type: Pt.IncrementalSnapshot,
        data: {
          source: Ot.ViewportResize,
          ...Nn
        }
      })),
      inputCb: (Nn) => ct(kr({
        type: Pt.IncrementalSnapshot,
        data: {
          source: Ot.Input,
          ...Nn
        }
      })),
      mediaInteractionCb: (Nn) => ct(kr({
        type: Pt.IncrementalSnapshot,
        data: {
          source: Ot.MediaInteraction,
          ...Nn
        }
      })),
      styleSheetRuleCb: (Nn) => ct(kr({
        type: Pt.IncrementalSnapshot,
        data: {
          source: Ot.StyleSheetRule,
          ...Nn
        }
      })),
      styleDeclarationCb: (Nn) => ct(kr({
        type: Pt.IncrementalSnapshot,
        data: {
          source: Ot.StyleDeclaration,
          ...Nn
        }
      })),
      canvasMutationCb: dt,
      fontCb: (Nn) => ct(kr({
        type: Pt.IncrementalSnapshot,
        data: {
          source: Ot.Font,
          ...Nn
        }
      })),
      selectionCb: (Nn) => {
        ct(kr({
          type: Pt.IncrementalSnapshot,
          data: {
            source: Ot.Selection,
            ...Nn
          }
        }));
      },
      customElementCb: (Nn) => {
        ct(kr({
          type: Pt.IncrementalSnapshot,
          data: {
            source: Ot.CustomElement,
            ...Nn
          }
        }));
      },
      blockClass: ne,
      ignoreClass: se,
      ignoreSelector: ae,
      maskAllText: ue,
      maskTextClass: le,
      unmaskTextClass: he,
      maskTextSelector: me,
      unmaskTextSelector: ye,
      maskInputOptions: Ge,
      inlineStylesheet: we,
      sampling: tt,
      recordCanvas: _t,
      inlineImages: de,
      userTriggeredOnInput: ze,
      collectFonts: fe,
      doc: oX,
      maskAttributeFn: Me,
      maskInputFn: De,
      maskTextFn: Fe,
      keepIframeSrcFn: Te,
      blockSelector: ie,
      unblockSelector: oe,
      slimDOMOptions: Xe,
      dataURLOptions: rt,
      mirror: di,
      iframeManager: It,
      stylesheetManager: Ut,
      shadowDomManager: an,
      processedNodeManager: Er,
      canvasManager: Fr,
      ignoreCSSAttributes: Ce,
      plugins: vp([
        be,
        "optionalAccess",
        (Nn) => Nn.filter,
        "call",
        (Nn) => Nn((SX) => SX.observer),
        "optionalAccess",
        (Nn) => Nn.map,
        "call",
        (Nn) => Nn((SX) => ({
          observer: SX.observer,
          options: SX.options,
          callback: (sX) => ct(kr({
            type: Pt.Plugin,
            data: {
              plugin: SX.name,
              payload: sX
            }
          }))
        }))
      ]) || []
    }, {});
    It.addLoadListener((oX) => {
      try {
        Ct.push(w_(oX.contentDocument));
      } catch (Nn) {
        console.warn(Nn);
      }
    });
    const hX = () => {
      wX(), Ct.push(w_(document));
    };
    return document.readyState === "interactive" || document.readyState === "complete" ? hX() : (Ct.push(bn$3("DOMContentLoaded", () => {
      ct(kr({
        type: Pt.DomContentLoaded,
        data: {}
      })), je === "DOMContentLoaded" && hX();
    })), Ct.push(bn$3("load", () => {
      ct(kr({
        type: Pt.Load,
        data: {}
      })), je === "load" && hX();
    }, window))), () => {
      Ct.forEach((oX) => oX()), Er.destroy(), hd = void 0, GW();
    };
  } catch (Ct) {
    console.warn(Ct);
  }
}
function fK(Y) {
  if (!hd)
    throw new Error("please take full snapshot after start recording");
  hd(Y);
}
io.mirror = di;
io.takeFullSnapshot = fK;
function lK(Y, X) {
  try {
    return Y ? Y(X) : new a2();
  } catch {
    return console.warn("Unable to initialize CanvasManager"), new a2();
  }
}
const dK = 3, hK = 5;
function Ab(Y) {
  return Y > 9999999999 ? Y : Y * 1e3;
}
function Rp(Y) {
  return Y > 9999999999 ? Y / 1e3 : Y;
}
function Lf(Y, X) {
  X.category !== "sentry.transaction" && (["ui.click", "ui.input"].includes(X.category) ? Y.triggerUserActivity() : Y.checkAndHandleExpiredSession(), Y.addUpdate(() => (Y.throttledAddEvent({
    type: Pt.Custom,
    // TODO: We were converting from ms to seconds for breadcrumbs, spans,
    // but maybe we should just keep them as milliseconds
    timestamp: (X.timestamp || 0) * 1e3,
    data: {
      tag: "breadcrumb",
      // normalize to max. 10 depth and 1_000 properties per object
      payload: ki(X, 10, 1e3)
    }
  }), X.category === "console")));
}
const pK = "button,a";
function i8(Y) {
  return Y.closest(pK) || Y;
}
function s8(Y) {
  const X = o8(Y);
  return !X || !(X instanceof Element) ? X : i8(X);
}
function o8(Y) {
  return gK(Y) ? Y.target : Y;
}
function gK(Y) {
  return typeof Y == "object" && !!Y && "target" in Y;
}
let Ws;
function mK(Y) {
  return Ws || (Ws = [], yK()), Ws.push(Y), () => {
    const X = Ws ? Ws.indexOf(Y) : -1;
    X > -1 && Ws.splice(X, 1);
  };
}
function yK() {
  Yr(fr, "open", function(Y) {
    return function(...X) {
      if (Ws)
        try {
          Ws.forEach((ee) => ee());
        } catch {
        }
      return Y.apply(fr, X);
    };
  });
}
function bK(Y, X, ee) {
  Y.handleClick(X, ee);
}
class xK {
  // protected for testing
  constructor(X, ee, te = Lf) {
    this._lastMutation = 0, this._lastScroll = 0, this._clicks = [], this._timeout = ee.timeout / 1e3, this._threshold = ee.threshold / 1e3, this._scollTimeout = ee.scrollTimeout / 1e3, this._replay = X, this._ignoreSelector = ee.ignoreSelector, this._addBreadcrumbEvent = te;
  }
  /** Register click detection handlers on mutation or scroll. */
  addListeners() {
    const X = mK(() => {
      this._lastMutation = c2();
    });
    this._teardown = () => {
      X(), this._clicks = [], this._lastMutation = 0, this._lastScroll = 0;
    };
  }
  /** Clean up listeners. */
  removeListeners() {
    this._teardown && this._teardown(), this._checkClickTimeout && clearTimeout(this._checkClickTimeout);
  }
  /** @inheritDoc */
  handleClick(X, ee) {
    if (vK(ee, this._ignoreSelector) || !EK(X))
      return;
    const te = {
      timestamp: Rp(X.timestamp),
      clickBreadcrumb: X,
      // Set this to 0 so we know it originates from the click breadcrumb
      clickCount: 0,
      node: ee
    };
    this._clicks.some((ne) => ne.node === te.node && Math.abs(ne.timestamp - te.timestamp) < 1) || (this._clicks.push(te), this._clicks.length === 1 && this._scheduleCheckClicks());
  }
  /** @inheritDoc */
  registerMutation(X = Date.now()) {
    this._lastMutation = Rp(X);
  }
  /** @inheritDoc */
  registerScroll(X = Date.now()) {
    this._lastScroll = Rp(X);
  }
  /** @inheritDoc */
  registerClick(X) {
    const ee = i8(X);
    this._handleMultiClick(ee);
  }
  /** Count multiple clicks on elements. */
  _handleMultiClick(X) {
    this._getClicks(X).forEach((ee) => {
      ee.clickCount++;
    });
  }
  /** Get all pending clicks for a given node. */
  _getClicks(X) {
    return this._clicks.filter((ee) => ee.node === X);
  }
  /** Check the clicks that happened. */
  _checkClicks() {
    const X = [], ee = c2();
    this._clicks.forEach((te) => {
      !te.mutationAfter && this._lastMutation && (te.mutationAfter = te.timestamp <= this._lastMutation ? this._lastMutation - te.timestamp : void 0), !te.scrollAfter && this._lastScroll && (te.scrollAfter = te.timestamp <= this._lastScroll ? this._lastScroll - te.timestamp : void 0), te.timestamp + this._timeout <= ee && X.push(te);
    });
    for (const te of X) {
      const ne = this._clicks.indexOf(te);
      ne > -1 && (this._generateBreadcrumbs(te), this._clicks.splice(ne, 1));
    }
    this._clicks.length && this._scheduleCheckClicks();
  }
  /** Generate matching breadcrumb(s) for the click. */
  _generateBreadcrumbs(X) {
    const ee = this._replay, te = X.scrollAfter && X.scrollAfter <= this._scollTimeout, ne = X.mutationAfter && X.mutationAfter <= this._threshold, ie = !te && !ne, { clickCount: oe, clickBreadcrumb: se } = X;
    if (ie) {
      const ae = Math.min(X.mutationAfter || this._timeout, this._timeout) * 1e3, ue = ae < this._timeout * 1e3 ? "mutation" : "timeout", le = {
        type: "default",
        message: se.message,
        timestamp: se.timestamp,
        category: "ui.slowClickDetected",
        data: {
          ...se.data,
          url: fr.location.href,
          route: ee.getCurrentRoute(),
          timeAfterClickMs: ae,
          endReason: ue,
          // If clickCount === 0, it means multiClick was not correctly captured here
          // - we still want to send 1 in this case
          clickCount: oe || 1
        }
      };
      this._addBreadcrumbEvent(ee, le);
      return;
    }
    if (oe > 1) {
      const ae = {
        type: "default",
        message: se.message,
        timestamp: se.timestamp,
        category: "ui.multiClick",
        data: {
          ...se.data,
          url: fr.location.href,
          route: ee.getCurrentRoute(),
          clickCount: oe,
          metric: !0
        }
      };
      this._addBreadcrumbEvent(ee, ae);
    }
  }
  /** Schedule to check current clicks. */
  _scheduleCheckClicks() {
    this._checkClickTimeout && clearTimeout(this._checkClickTimeout), this._checkClickTimeout = setTimeout(() => this._checkClicks(), 1e3);
  }
}
const wK = ["A", "BUTTON", "INPUT"];
function vK(Y, X) {
  return !!(!wK.includes(Y.tagName) || Y.tagName === "INPUT" && !["submit", "button"].includes(Y.getAttribute("type") || "") || Y.tagName === "A" && (Y.hasAttribute("download") || Y.hasAttribute("target") && Y.getAttribute("target") !== "_self") || X && Y.matches(X));
}
function EK(Y) {
  return !!(Y.data && typeof Y.data.nodeId == "number" && Y.timestamp);
}
function c2() {
  return Date.now() / 1e3;
}
function _K(Y, X) {
  try {
    if (!AK(X))
      return;
    const { source: ee } = X.data;
    if (ee === Ot.Mutation && Y.registerMutation(X.timestamp), ee === Ot.Scroll && Y.registerScroll(X.timestamp), SK(X)) {
      const { type: te, id: ne } = X.data, ie = io.mirror.getNode(ne);
      ie instanceof HTMLElement && te === pn.Click && Y.registerClick(ie);
    }
  } catch {
  }
}
function AK(Y) {
  return Y.type === dK;
}
function SK(Y) {
  return Y.data.source === Ot.MouseInteraction;
}
function Gi(Y) {
  return {
    timestamp: Date.now() / 1e3,
    type: "default",
    ...Y
  };
}
var pd;
(function(Y) {
  Y[Y.Document = 0] = "Document", Y[Y.DocumentType = 1] = "DocumentType", Y[Y.Element = 2] = "Element", Y[Y.Text = 3] = "Text", Y[Y.CDATA = 4] = "CDATA", Y[Y.Comment = 5] = "Comment";
})(pd || (pd = {}));
const TK = /* @__PURE__ */ new Set([
  "id",
  "class",
  "aria-label",
  "role",
  "name",
  "alt",
  "title",
  "data-test-id",
  "data-testid",
  "disabled",
  "aria-disabled",
  "data-sentry-component"
]);
function IK(Y) {
  const X = {};
  for (const ee in Y)
    if (TK.has(ee)) {
      let te = ee;
      (ee === "data-testid" || ee === "data-test-id") && (te = "testId"), X[te] = Y[ee];
    }
  return X;
}
const RK = (Y) => (X) => {
  if (!Y.isEnabled())
    return;
  const ee = CK(X);
  if (!ee)
    return;
  const te = X.name === "click", ne = te ? X.event : void 0;
  te && Y.clickDetector && ne && ne.target && !ne.altKey && !ne.metaKey && !ne.ctrlKey && !ne.shiftKey && bK(
    Y.clickDetector,
    ee,
    s8(X.event)
  ), Lf(Y, ee);
};
function a8(Y, X) {
  const ee = io.mirror.getId(Y), te = ee && io.mirror.getNode(ee), ne = te && io.mirror.getMeta(te), ie = ne && OK(ne) ? ne : null;
  return {
    message: X,
    data: ie ? {
      nodeId: ee,
      node: {
        id: ee,
        tagName: ie.tagName,
        textContent: Array.from(ie.childNodes).map((oe) => oe.type === pd.Text && oe.textContent).filter(Boolean).map((oe) => oe.trim()).join(""),
        attributes: IK(ie.attributes)
      }
    } : {}
  };
}
function CK(Y) {
  const { target: X, message: ee } = PK(Y);
  return Gi({
    category: `ui.${Y.name}`,
    ...a8(X, ee)
  });
}
function PK(Y) {
  const X = Y.name === "click";
  let ee, te = null;
  try {
    te = X ? s8(Y.event) : o8(Y.event), ee = zo(te, { maxStringLength: 200 }) || "<unknown>";
  } catch {
    ee = "<unknown>";
  }
  return { target: te, message: ee };
}
function OK(Y) {
  return Y.type === pd.Element;
}
function BK(Y, X) {
  if (!Y.isEnabled())
    return;
  Y.updateUserActivity();
  const ee = NK(X);
  ee && Lf(Y, ee);
}
function NK(Y) {
  const { metaKey: X, shiftKey: ee, ctrlKey: te, altKey: ne, key: ie, target: oe } = Y;
  if (!oe || kK(oe) || !ie)
    return null;
  const se = X || te || ne, ae = ie.length === 1;
  if (!se && ae)
    return null;
  const ue = zo(oe, { maxStringLength: 200 }) || "<unknown>", le = a8(oe, ue);
  return Gi({
    category: "ui.keyDown",
    message: ue,
    data: {
      ...le.data,
      metaKey: X,
      shiftKey: ee,
      ctrlKey: te,
      altKey: ne,
      key: ie
    }
  });
}
function kK(Y) {
  return Y.tagName === "INPUT" || Y.tagName === "TEXTAREA" || Y.isContentEditable;
}
const u2 = {
  // @ts-expect-error TODO: entry type does not fit the create* functions entry type
  resource: DK,
  paint: FK,
  // @ts-expect-error TODO: entry type does not fit the create* functions entry type
  navigation: $K
};
function MK(Y) {
  return Y.map(LK).filter(Boolean);
}
function LK(Y) {
  return u2[Y.entryType] ? u2[Y.entryType](Y) : null;
}
function ac(Y) {
  return ((vi || fr.performance.timeOrigin) + Y) / 1e3;
}
function FK(Y) {
  const { duration: X, entryType: ee, name: te, startTime: ne } = Y, ie = ac(ne);
  return {
    type: ee,
    name: te,
    start: ie,
    end: ie + X,
    data: void 0
  };
}
function $K(Y) {
  const {
    entryType: X,
    name: ee,
    decodedBodySize: te,
    duration: ne,
    domComplete: ie,
    encodedBodySize: oe,
    domContentLoadedEventStart: se,
    domContentLoadedEventEnd: ae,
    domInteractive: ue,
    loadEventStart: le,
    loadEventEnd: he,
    redirectCount: me,
    startTime: ye,
    transferSize: we,
    type: Ee
  } = Y;
  return ne === 0 ? null : {
    type: `${X}.${Ee}`,
    start: ac(ye),
    end: ac(ie),
    name: ee,
    data: {
      size: we,
      decodedBodySize: te,
      encodedBodySize: oe,
      duration: ne,
      domInteractive: ue,
      domContentLoadedEventStart: se,
      domContentLoadedEventEnd: ae,
      loadEventStart: le,
      loadEventEnd: he,
      domComplete: ie,
      redirectCount: me
    }
  };
}
function DK(Y) {
  const {
    entryType: X,
    initiatorType: ee,
    name: te,
    responseEnd: ne,
    startTime: ie,
    decodedBodySize: oe,
    encodedBodySize: se,
    responseStatus: ae,
    transferSize: ue
  } = Y;
  return ["fetch", "xmlhttprequest"].includes(ee) ? null : {
    type: `${X}.${ee}`,
    start: ac(ie),
    end: ac(ne),
    name: te,
    data: {
      size: ue,
      statusCode: ae,
      decodedBodySize: oe,
      encodedBodySize: se
    }
  };
}
function UK(Y) {
  const X = Y.entries, ee = X[X.length - 1], te = ee ? ee.element : void 0, ne = Y.value, ie = ac(ne);
  return {
    type: "largest-contentful-paint",
    name: "largest-contentful-paint",
    start: ie,
    end: ie,
    data: {
      value: ne,
      size: ne,
      nodeId: te ? io.mirror.getId(te) : void 0
    }
  };
}
function jK(Y) {
  function X(ne) {
    Y.performanceEntries.includes(ne) || Y.performanceEntries.push(ne);
  }
  function ee({ entries: ne }) {
    ne.forEach(X);
  }
  const te = [];
  return ["navigation", "paint", "resource"].forEach((ne) => {
    te.push(L0(ne, ee));
  }), te.push(
    y5(({ metric: ne }) => {
      Y.replayPerformanceEntries.push(UK(ne));
    })
  ), () => {
    te.forEach((ne) => ne());
  };
}
const ar = typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__, HK = 'var t=Uint8Array,n=Uint16Array,r=Int32Array,e=new t([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),i=new t([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),a=new t([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),s=function(t,e){for(var i=new n(31),a=0;a<31;++a)i[a]=e+=1<<t[a-1];var s=new r(i[30]);for(a=1;a<30;++a)for(var o=i[a];o<i[a+1];++o)s[o]=o-i[a]<<5|a;return{b:i,r:s}},o=s(e,2),f=o.b,h=o.r;f[28]=258,h[258]=28;for(var l=s(i,0).r,u=new n(32768),c=0;c<32768;++c){var v=(43690&c)>>1|(21845&c)<<1;v=(61680&(v=(52428&v)>>2|(13107&v)<<2))>>4|(3855&v)<<4,u[c]=((65280&v)>>8|(255&v)<<8)>>1}var d=function(t,r,e){for(var i=t.length,a=0,s=new n(r);a<i;++a)t[a]&&++s[t[a]-1];var o,f=new n(r);for(a=1;a<r;++a)f[a]=f[a-1]+s[a-1]<<1;if(e){o=new n(1<<r);var h=15-r;for(a=0;a<i;++a)if(t[a])for(var l=a<<4|t[a],c=r-t[a],v=f[t[a]-1]++<<c,d=v|(1<<c)-1;v<=d;++v)o[u[v]>>h]=l}else for(o=new n(i),a=0;a<i;++a)t[a]&&(o[a]=u[f[t[a]-1]++]>>15-t[a]);return o},g=new t(288);for(c=0;c<144;++c)g[c]=8;for(c=144;c<256;++c)g[c]=9;for(c=256;c<280;++c)g[c]=7;for(c=280;c<288;++c)g[c]=8;var w=new t(32);for(c=0;c<32;++c)w[c]=5;var p=d(g,9,0),y=d(w,5,0),m=function(t){return(t+7)/8|0},b=function(n,r,e){return(null==r||r<0)&&(r=0),(null==e||e>n.length)&&(e=n.length),new t(n.subarray(r,e))},M=["unexpected EOF","invalid block type","invalid length/literal","invalid distance","stream finished","no stream handler",,"no callback","invalid UTF-8 data","extra field too long","date not in range 1980-2099","filename too long","stream finishing","invalid zip data"],E=function(t,n,r){var e=new Error(n||M[t]);if(e.code=t,Error.captureStackTrace&&Error.captureStackTrace(e,E),!r)throw e;return e},z=function(t,n,r){r<<=7&n;var e=n/8|0;t[e]|=r,t[e+1]|=r>>8},A=function(t,n,r){r<<=7&n;var e=n/8|0;t[e]|=r,t[e+1]|=r>>8,t[e+2]|=r>>16},_=function(r,e){for(var i=[],a=0;a<r.length;++a)r[a]&&i.push({s:a,f:r[a]});var s=i.length,o=i.slice();if(!s)return{t:F,l:0};if(1==s){var f=new t(i[0].s+1);return f[i[0].s]=1,{t:f,l:1}}i.sort((function(t,n){return t.f-n.f})),i.push({s:-1,f:25001});var h=i[0],l=i[1],u=0,c=1,v=2;for(i[0]={s:-1,f:h.f+l.f,l:h,r:l};c!=s-1;)h=i[i[u].f<i[v].f?u++:v++],l=i[u!=c&&i[u].f<i[v].f?u++:v++],i[c++]={s:-1,f:h.f+l.f,l:h,r:l};var d=o[0].s;for(a=1;a<s;++a)o[a].s>d&&(d=o[a].s);var g=new n(d+1),w=x(i[c-1],g,0);if(w>e){a=0;var p=0,y=w-e,m=1<<y;for(o.sort((function(t,n){return g[n.s]-g[t.s]||t.f-n.f}));a<s;++a){var b=o[a].s;if(!(g[b]>e))break;p+=m-(1<<w-g[b]),g[b]=e}for(p>>=y;p>0;){var M=o[a].s;g[M]<e?p-=1<<e-g[M]++-1:++a}for(;a>=0&&p;--a){var E=o[a].s;g[E]==e&&(--g[E],++p)}w=e}return{t:new t(g),l:w}},x=function(t,n,r){return-1==t.s?Math.max(x(t.l,n,r+1),x(t.r,n,r+1)):n[t.s]=r},D=function(t){for(var r=t.length;r&&!t[--r];);for(var e=new n(++r),i=0,a=t[0],s=1,o=function(t){e[i++]=t},f=1;f<=r;++f)if(t[f]==a&&f!=r)++s;else{if(!a&&s>2){for(;s>138;s-=138)o(32754);s>2&&(o(s>10?s-11<<5|28690:s-3<<5|12305),s=0)}else if(s>3){for(o(a),--s;s>6;s-=6)o(8304);s>2&&(o(s-3<<5|8208),s=0)}for(;s--;)o(a);s=1,a=t[f]}return{c:e.subarray(0,i),n:r}},T=function(t,n){for(var r=0,e=0;e<n.length;++e)r+=t[e]*n[e];return r},k=function(t,n,r){var e=r.length,i=m(n+2);t[i]=255&e,t[i+1]=e>>8,t[i+2]=255^t[i],t[i+3]=255^t[i+1];for(var a=0;a<e;++a)t[i+a+4]=r[a];return 8*(i+4+e)},C=function(t,r,s,o,f,h,l,u,c,v,m){z(r,m++,s),++f[256];for(var b=_(f,15),M=b.t,E=b.l,x=_(h,15),C=x.t,U=x.l,F=D(M),I=F.c,S=F.n,L=D(C),O=L.c,j=L.n,q=new n(19),B=0;B<I.length;++B)++q[31&I[B]];for(B=0;B<O.length;++B)++q[31&O[B]];for(var G=_(q,7),H=G.t,J=G.l,K=19;K>4&&!H[a[K-1]];--K);var N,P,Q,R,V=v+5<<3,W=T(f,g)+T(h,w)+l,X=T(f,M)+T(h,C)+l+14+3*K+T(q,H)+2*q[16]+3*q[17]+7*q[18];if(c>=0&&V<=W&&V<=X)return k(r,m,t.subarray(c,c+v));if(z(r,m,1+(X<W)),m+=2,X<W){N=d(M,E,0),P=M,Q=d(C,U,0),R=C;var Y=d(H,J,0);z(r,m,S-257),z(r,m+5,j-1),z(r,m+10,K-4),m+=14;for(B=0;B<K;++B)z(r,m+3*B,H[a[B]]);m+=3*K;for(var Z=[I,O],$=0;$<2;++$){var tt=Z[$];for(B=0;B<tt.length;++B){var nt=31&tt[B];z(r,m,Y[nt]),m+=H[nt],nt>15&&(z(r,m,tt[B]>>5&127),m+=tt[B]>>12)}}}else N=p,P=g,Q=y,R=w;for(B=0;B<u;++B){var rt=o[B];if(rt>255){A(r,m,N[(nt=rt>>18&31)+257]),m+=P[nt+257],nt>7&&(z(r,m,rt>>23&31),m+=e[nt]);var et=31&rt;A(r,m,Q[et]),m+=R[et],et>3&&(A(r,m,rt>>5&8191),m+=i[et])}else A(r,m,N[rt]),m+=P[rt]}return A(r,m,N[256]),m+P[256]},U=new r([65540,131080,131088,131104,262176,1048704,1048832,2114560,2117632]),F=new t(0),I=function(){for(var t=new Int32Array(256),n=0;n<256;++n){for(var r=n,e=9;--e;)r=(1&r&&-306674912)^r>>>1;t[n]=r}return t}(),S=function(){var t=1,n=0;return{p:function(r){for(var e=t,i=n,a=0|r.length,s=0;s!=a;){for(var o=Math.min(s+2655,a);s<o;++s)i+=e+=r[s];e=(65535&e)+15*(e>>16),i=(65535&i)+15*(i>>16)}t=e,n=i},d:function(){return(255&(t%=65521))<<24|(65280&t)<<8|(255&(n%=65521))<<8|n>>8}}},L=function(a,s,o,f,u){if(!u&&(u={l:1},s.dictionary)){var c=s.dictionary.subarray(-32768),v=new t(c.length+a.length);v.set(c),v.set(a,c.length),a=v,u.w=c.length}return function(a,s,o,f,u,c){var v=c.z||a.length,d=new t(f+v+5*(1+Math.ceil(v/7e3))+u),g=d.subarray(f,d.length-u),w=c.l,p=7&(c.r||0);if(s){p&&(g[0]=c.r>>3);for(var y=U[s-1],M=y>>13,E=8191&y,z=(1<<o)-1,A=c.p||new n(32768),_=c.h||new n(z+1),x=Math.ceil(o/3),D=2*x,T=function(t){return(a[t]^a[t+1]<<x^a[t+2]<<D)&z},F=new r(25e3),I=new n(288),S=new n(32),L=0,O=0,j=c.i||0,q=0,B=c.w||0,G=0;j+2<v;++j){var H=T(j),J=32767&j,K=_[H];if(A[J]=K,_[H]=J,B<=j){var N=v-j;if((L>7e3||q>24576)&&(N>423||!w)){p=C(a,g,0,F,I,S,O,q,G,j-G,p),q=L=O=0,G=j;for(var P=0;P<286;++P)I[P]=0;for(P=0;P<30;++P)S[P]=0}var Q=2,R=0,V=E,W=J-K&32767;if(N>2&&H==T(j-W))for(var X=Math.min(M,N)-1,Y=Math.min(32767,j),Z=Math.min(258,N);W<=Y&&--V&&J!=K;){if(a[j+Q]==a[j+Q-W]){for(var $=0;$<Z&&a[j+$]==a[j+$-W];++$);if($>Q){if(Q=$,R=W,$>X)break;var tt=Math.min(W,$-2),nt=0;for(P=0;P<tt;++P){var rt=j-W+P&32767,et=rt-A[rt]&32767;et>nt&&(nt=et,K=rt)}}}W+=(J=K)-(K=A[J])&32767}if(R){F[q++]=268435456|h[Q]<<18|l[R];var it=31&h[Q],at=31&l[R];O+=e[it]+i[at],++I[257+it],++S[at],B=j+Q,++L}else F[q++]=a[j],++I[a[j]]}}for(j=Math.max(j,B);j<v;++j)F[q++]=a[j],++I[a[j]];p=C(a,g,w,F,I,S,O,q,G,j-G,p),w||(c.r=7&p|g[p/8|0]<<3,p-=7,c.h=_,c.p=A,c.i=j,c.w=B)}else{for(j=c.w||0;j<v+w;j+=65535){var st=j+65535;st>=v&&(g[p/8|0]=w,st=v),p=k(g,p+1,a.subarray(j,st))}c.i=v}return b(d,0,f+m(p)+u)}(a,null==s.level?6:s.level,null==s.mem?Math.ceil(1.5*Math.max(8,Math.min(13,Math.log(a.length)))):12+s.mem,o,f,u)},O=function(t,n,r){for(;r;++n)t[n]=r,r>>>=8},j=function(){function n(n,r){if("function"==typeof n&&(r=n,n={}),this.ondata=r,this.o=n||{},this.s={l:0,i:32768,w:32768,z:32768},this.b=new t(98304),this.o.dictionary){var e=this.o.dictionary.subarray(-32768);this.b.set(e,32768-e.length),this.s.i=32768-e.length}}return n.prototype.p=function(t,n){this.ondata(L(t,this.o,0,0,this.s),n)},n.prototype.push=function(n,r){this.ondata||E(5),this.s.l&&E(4);var e=n.length+this.s.z;if(e>this.b.length){if(e>2*this.b.length-32768){var i=new t(-32768&e);i.set(this.b.subarray(0,this.s.z)),this.b=i}var a=this.b.length-this.s.z;a&&(this.b.set(n.subarray(0,a),this.s.z),this.s.z=this.b.length,this.p(this.b,!1)),this.b.set(this.b.subarray(-32768)),this.b.set(n.subarray(a),32768),this.s.z=n.length-a+32768,this.s.i=32766,this.s.w=32768}else this.b.set(n,this.s.z),this.s.z+=n.length;this.s.l=1&r,(this.s.z>this.s.w+8191||r)&&(this.p(this.b,r||!1),this.s.w=this.s.i,this.s.i-=2)},n}();function q(t,n){n||(n={});var r=function(){var t=-1;return{p:function(n){for(var r=t,e=0;e<n.length;++e)r=I[255&r^n[e]]^r>>>8;t=r},d:function(){return~t}}}(),e=t.length;r.p(t);var i,a=L(t,n,10+((i=n).filename?i.filename.length+1:0),8),s=a.length;return function(t,n){var r=n.filename;if(t[0]=31,t[1]=139,t[2]=8,t[8]=n.level<2?4:9==n.level?2:0,t[9]=3,0!=n.mtime&&O(t,4,Math.floor(new Date(n.mtime||Date.now())/1e3)),r){t[3]=8;for(var e=0;e<=r.length;++e)t[e+10]=r.charCodeAt(e)}}(a,n),O(a,s-8,r.d()),O(a,s-4,e),a}var B=function(){function t(t,n){this.c=S(),this.v=1,j.call(this,t,n)}return t.prototype.push=function(t,n){this.c.p(t),j.prototype.push.call(this,t,n)},t.prototype.p=function(t,n){var r=L(t,this.o,this.v&&(this.o.dictionary?6:2),n&&4,this.s);this.v&&(function(t,n){var r=n.level,e=0==r?0:r<6?1:9==r?3:2;if(t[0]=120,t[1]=e<<6|(n.dictionary&&32),t[1]|=31-(t[0]<<8|t[1])%31,n.dictionary){var i=S();i.p(n.dictionary),O(t,2,i.d())}}(r,this.o),this.v=0),n&&O(r,r.length-4,this.c.d()),this.ondata(r,n)},t}(),G="undefined"!=typeof TextEncoder&&new TextEncoder,H="undefined"!=typeof TextDecoder&&new TextDecoder;try{H.decode(F,{stream:!0})}catch(t){}var J=function(){function t(t){this.ondata=t}return t.prototype.push=function(t,n){this.ondata||E(5),this.d&&E(4),this.ondata(K(t),this.d=n||!1)},t}();function K(n,r){if(r){for(var e=new t(n.length),i=0;i<n.length;++i)e[i]=n.charCodeAt(i);return e}if(G)return G.encode(n);var a=n.length,s=new t(n.length+(n.length>>1)),o=0,f=function(t){s[o++]=t};for(i=0;i<a;++i){if(o+5>s.length){var h=new t(o+8+(a-i<<1));h.set(s),s=h}var l=n.charCodeAt(i);l<128||r?f(l):l<2048?(f(192|l>>6),f(128|63&l)):l>55295&&l<57344?(f(240|(l=65536+(1047552&l)|1023&n.charCodeAt(++i))>>18),f(128|l>>12&63),f(128|l>>6&63),f(128|63&l)):(f(224|l>>12),f(128|l>>6&63),f(128|63&l))}return b(s,0,o)}const N=new class{constructor(){this._init()}clear(){this._init()}addEvent(t){if(!t)throw new Error("Adding invalid event");const n=this._hasEvents?",":"";this.stream.push(n+t),this._hasEvents=!0}finish(){this.stream.push("]",!0);const t=function(t){let n=0;for(let r=0,e=t.length;r<e;r++)n+=t[r].length;const r=new Uint8Array(n);for(let n=0,e=0,i=t.length;n<i;n++){const i=t[n];r.set(i,e),e+=i.length}return r}(this._deflatedData);return this._init(),t}_init(){this._hasEvents=!1,this._deflatedData=[],this.deflate=new B,this.deflate.ondata=(t,n)=>{this._deflatedData.push(t)},this.stream=new J(((t,n)=>{this.deflate.push(t,n)})),this.stream.push("[")}},P={clear:()=>{N.clear()},addEvent:t=>N.addEvent(t),finish:()=>N.finish(),compress:t=>function(t){return q(K(t))}(t)};addEventListener("message",(function(t){const n=t.data.method,r=t.data.id,e=t.data.arg;if(n in P&&"function"==typeof P[n])try{const t=P[n](e);postMessage({id:r,method:n,success:!0,response:t})}catch(t){postMessage({id:r,method:n,success:!1,response:t.message}),console.error(t)}})),postMessage({id:void 0,method:"init",success:!0,response:void 0});';
function zK() {
  const Y = new Blob([HK]);
  return URL.createObjectURL(Y);
}
function mn(Y, X) {
  ar && (xe.info(Y), X && c8(Y));
}
function Ua(Y, X) {
  ar && (xe.info(Y), X && setTimeout(() => {
    c8(Y);
  }, 0));
}
function c8(Y) {
  ho(
    {
      category: "console",
      data: {
        logger: "replay"
      },
      level: "info",
      message: Y
    },
    { level: "info" }
  );
}
class Sb extends Error {
  constructor() {
    super(`Event buffer exceeded maximum size of ${xb}.`);
  }
}
let u8$1 = class {
  /** All the events that are buffered to be sent. */
  /** @inheritdoc */
  constructor() {
    this.events = [], this._totalSize = 0, this.hasCheckout = !1;
  }
  /** @inheritdoc */
  get hasEvents() {
    return this.events.length > 0;
  }
  /** @inheritdoc */
  get type() {
    return "sync";
  }
  /** @inheritdoc */
  destroy() {
    this.events = [];
  }
  /** @inheritdoc */
  async addEvent(Y) {
    const X = JSON.stringify(Y).length;
    if (this._totalSize += X, this._totalSize > xb)
      throw new Sb();
    this.events.push(Y);
  }
  /** @inheritdoc */
  finish() {
    return new Promise((Y) => {
      const X = this.events;
      this.clear(), Y(JSON.stringify(X));
    });
  }
  /** @inheritdoc */
  clear() {
    this.events = [], this._totalSize = 0, this.hasCheckout = !1;
  }
  /** @inheritdoc */
  getEarliestTimestamp() {
    const Y = this.events.map((X) => X.timestamp).sort()[0];
    return Y ? Ab(Y) : null;
  }
};
class qK {
  constructor(X) {
    this._worker = X, this._id = 0;
  }
  /**
   * Ensure the worker is ready (or not).
   * This will either resolve when the worker is ready, or reject if an error occured.
   */
  ensureReady() {
    return this._ensureReadyPromise ? this._ensureReadyPromise : (this._ensureReadyPromise = new Promise((X, ee) => {
      this._worker.addEventListener(
        "message",
        ({ data: te }) => {
          te.success ? X() : ee();
        },
        { once: !0 }
      ), this._worker.addEventListener(
        "error",
        (te) => {
          ee(te);
        },
        { once: !0 }
      );
    }), this._ensureReadyPromise);
  }
  /**
   * Destroy the worker.
   */
  destroy() {
    mn("[Replay] Destroying compression worker"), this._worker.terminate();
  }
  /**
   * Post message to worker and wait for response before resolving promise.
   */
  postMessage(X, ee) {
    const te = this._getAndIncrementId();
    return new Promise((ne, ie) => {
      const oe = ({ data: se }) => {
        const ae = se;
        if (ae.method === X && ae.id === te) {
          if (this._worker.removeEventListener("message", oe), !ae.success) {
            ar && xe.error("[Replay]", ae.response), ie(new Error("Error in compression worker"));
            return;
          }
          ne(ae.response);
        }
      };
      this._worker.addEventListener("message", oe), this._worker.postMessage({ id: te, method: X, arg: ee });
    });
  }
  /** Get the current ID and increment it for the next call. */
  _getAndIncrementId() {
    return this._id++;
  }
}
class GK {
  /** @inheritdoc */
  constructor(X) {
    this._worker = new qK(X), this._earliestTimestamp = null, this._totalSize = 0, this.hasCheckout = !1;
  }
  /** @inheritdoc */
  get hasEvents() {
    return !!this._earliestTimestamp;
  }
  /** @inheritdoc */
  get type() {
    return "worker";
  }
  /**
   * Ensure the worker is ready (or not).
   * This will either resolve when the worker is ready, or reject if an error occured.
   */
  ensureReady() {
    return this._worker.ensureReady();
  }
  /**
   * Destroy the event buffer.
   */
  destroy() {
    this._worker.destroy();
  }
  /**
   * Add an event to the event buffer.
   *
   * Returns true if event was successfuly received and processed by worker.
   */
  addEvent(X) {
    const ee = Ab(X.timestamp);
    (!this._earliestTimestamp || ee < this._earliestTimestamp) && (this._earliestTimestamp = ee);
    const te = JSON.stringify(X);
    return this._totalSize += te.length, this._totalSize > xb ? Promise.reject(new Sb()) : this._sendEventToWorker(te);
  }
  /**
   * Finish the event buffer and return the compressed data.
   */
  finish() {
    return this._finishRequest();
  }
  /** @inheritdoc */
  clear() {
    this._earliestTimestamp = null, this._totalSize = 0, this.hasCheckout = !1, this._worker.postMessage("clear").then(null, (X) => {
      ar && xe.warn('[Replay] Sending "clear" message to worker failed', X);
    });
  }
  /** @inheritdoc */
  getEarliestTimestamp() {
    return this._earliestTimestamp;
  }
  /**
   * Send the event to the worker.
   */
  _sendEventToWorker(X) {
    return this._worker.postMessage("addEvent", X);
  }
  /**
   * Finish the request and return the compressed data from the worker.
   */
  async _finishRequest() {
    const X = await this._worker.postMessage("finish");
    return this._earliestTimestamp = null, this._totalSize = 0, X;
  }
}
class VK {
  constructor(X) {
    this._fallback = new u8$1(), this._compression = new GK(X), this._used = this._fallback, this._ensureWorkerIsLoadedPromise = this._ensureWorkerIsLoaded();
  }
  /** @inheritdoc */
  get type() {
    return this._used.type;
  }
  /** @inheritDoc */
  get hasEvents() {
    return this._used.hasEvents;
  }
  /** @inheritdoc */
  get hasCheckout() {
    return this._used.hasCheckout;
  }
  /** @inheritdoc */
  set hasCheckout(X) {
    this._used.hasCheckout = X;
  }
  /** @inheritDoc */
  destroy() {
    this._fallback.destroy(), this._compression.destroy();
  }
  /** @inheritdoc */
  clear() {
    return this._used.clear();
  }
  /** @inheritdoc */
  getEarliestTimestamp() {
    return this._used.getEarliestTimestamp();
  }
  /**
   * Add an event to the event buffer.
   *
   * Returns true if event was successfully added.
   */
  addEvent(X) {
    return this._used.addEvent(X);
  }
  /** @inheritDoc */
  async finish() {
    return await this.ensureWorkerIsLoaded(), this._used.finish();
  }
  /** Ensure the worker has loaded. */
  ensureWorkerIsLoaded() {
    return this._ensureWorkerIsLoadedPromise;
  }
  /** Actually check if the worker has been loaded. */
  async _ensureWorkerIsLoaded() {
    try {
      await this._compression.ensureReady();
    } catch {
      mn("[Replay] Failed to load the compression worker, falling back to simple buffer");
      return;
    }
    await this._switchToCompressionWorker();
  }
  /** Switch the used buffer to the compression worker. */
  async _switchToCompressionWorker() {
    const { events: X, hasCheckout: ee } = this._fallback, te = [];
    for (const ne of X)
      te.push(this._compression.addEvent(ne));
    this._compression.hasCheckout = ee, this._used = this._compression;
    try {
      await Promise.all(te);
    } catch (ne) {
      ar && xe.warn("[Replay] Failed to add events when switching buffers.", ne);
    }
  }
}
function WK({
  useCompression: Y,
  workerUrl: X
}) {
  if (Y && // eslint-disable-next-line no-restricted-globals
  window.Worker) {
    const ee = KK(X);
    if (ee)
      return ee;
  }
  return mn("[Replay] Using simple buffer"), new u8$1();
}
function KK(Y) {
  try {
    const X = Y || JK();
    if (!X)
      return;
    mn(`[Replay] Using compression worker${Y ? ` from ${Y}` : ""}`);
    const ee = new Worker(X);
    return new VK(ee);
  } catch {
    mn("[Replay] Failed to create compression worker");
  }
}
function JK() {
  return typeof __SENTRY_EXCLUDE_REPLAY_WORKER__ > "u" || !__SENTRY_EXCLUDE_REPLAY_WORKER__ ? zK() : "";
}
function Tb() {
  try {
    return "sessionStorage" in fr && !!fr.sessionStorage;
  } catch {
    return !1;
  }
}
function YK(Y) {
  XK(), Y.session = void 0;
}
function XK() {
  if (Tb())
    try {
      fr.sessionStorage.removeItem(yb);
    } catch {
    }
}
function f8(Y) {
  return Y === void 0 ? !1 : Math.random() < Y;
}
function l8(Y) {
  const X = Date.now(), ee = Y.id || Tr(), te = Y.started || X, ne = Y.lastActivity || X, ie = Y.segmentId || 0, oe = Y.sampled, se = Y.previousSessionId;
  return {
    id: ee,
    started: te,
    lastActivity: ne,
    segmentId: ie,
    sampled: oe,
    previousSessionId: se
  };
}
function Ib(Y) {
  if (Tb())
    try {
      fr.sessionStorage.setItem(yb, JSON.stringify(Y));
    } catch {
    }
}
function ZK(Y, X) {
  return f8(Y) ? "session" : X ? "buffer" : !1;
}
function f2({ sessionSampleRate: Y, allowBuffering: X, stickySession: ee = !1 }, { previousSessionId: te } = {}) {
  const ne = ZK(Y, X), ie = l8({
    sampled: ne,
    previousSessionId: te
  });
  return ee && Ib(ie), ie;
}
function QK(Y) {
  if (!Tb())
    return null;
  try {
    const X = fr.sessionStorage.getItem(yb);
    if (!X)
      return null;
    const ee = JSON.parse(X);
    return Ua("[Replay] Loading existing session", Y), l8(ee);
  } catch {
    return null;
  }
}
function Yg(Y, X, ee = +/* @__PURE__ */ new Date()) {
  return Y === null || X === void 0 || X < 0 ? !0 : X === 0 ? !1 : Y + X <= ee;
}
function d8(Y, {
  maxReplayDuration: X,
  sessionIdleExpire: ee,
  targetTime: te = Date.now()
}) {
  return (
    // First, check that maximum session length has not been exceeded
    Yg(Y.started, X, te) || // check that the idle timeout has not been exceeded (i.e. user has
    // performed an action within the last `sessionIdleExpire` ms)
    Yg(Y.lastActivity, ee, te)
  );
}
function h8(Y, { sessionIdleExpire: X, maxReplayDuration: ee }) {
  return !(!d8(Y, { sessionIdleExpire: X, maxReplayDuration: ee }) || Y.sampled === "buffer" && Y.segmentId === 0);
}
function Cp({
  traceInternals: Y,
  sessionIdleExpire: X,
  maxReplayDuration: ee,
  previousSessionId: te
}, ne) {
  const ie = ne.stickySession && QK(Y);
  return ie ? h8(ie, { sessionIdleExpire: X, maxReplayDuration: ee }) ? (Ua("[Replay] Session in sessionStorage is expired, creating new one..."), f2(ne, { previousSessionId: ie.id })) : ie : (Ua("[Replay] Creating new session", Y), f2(ne, { previousSessionId: te }));
}
function eJ(Y) {
  return Y.type === Pt.Custom;
}
function Rb(Y, X, ee) {
  return g8(Y, X) ? (p8(Y, X, ee), !0) : !1;
}
function tJ(Y, X, ee) {
  return g8(Y, X) ? p8(Y, X, ee) : Promise.resolve(null);
}
async function p8(Y, X, ee) {
  if (!Y.eventBuffer)
    return null;
  try {
    ee && Y.recordingMode === "buffer" && Y.eventBuffer.clear(), ee && (Y.eventBuffer.hasCheckout = !0);
    const te = Y.getOptions(), ne = rJ(X, te.beforeAddRecordingEvent);
    return ne ? await Y.eventBuffer.addEvent(ne) : void 0;
  } catch (te) {
    const ne = te && te instanceof Sb ? "addEventSizeExceeded" : "addEvent";
    ar && xe.error(te), await Y.stop({ reason: ne });
    const ie = cr();
    ie && ie.recordDroppedEvent("internal_sdk_error", "replay");
  }
}
function g8(Y, X) {
  if (!Y.eventBuffer || Y.isPaused() || !Y.isEnabled())
    return !1;
  const ee = Ab(X.timestamp);
  return ee + Y.timeouts.sessionIdlePause < Date.now() ? !1 : ee > Y.getContext().initialTimestamp + Y.getOptions().maxReplayDuration ? (mn(
    `[Replay] Skipping event with timestamp ${ee} because it is after maxReplayDuration`,
    Y.getOptions()._experiments.traceInternals
  ), !1) : !0;
}
function rJ(Y, X) {
  try {
    if (typeof X == "function" && eJ(Y))
      return X(Y);
  } catch (ee) {
    return ar && xe.error("[Replay] An error occured in the `beforeAddRecordingEvent` callback, skipping the event...", ee), null;
  }
  return Y;
}
function Cb(Y) {
  return !Y.type;
}
function Xg(Y) {
  return Y.type === "transaction";
}
function nJ(Y) {
  return Y.type === "replay_event";
}
function l2(Y) {
  return Y.type === "feedback";
}
function m8(Y) {
  const X = oJ();
  return (ee, te) => {
    if (!Y.isEnabled() || !Cb(ee) && !Xg(ee))
      return;
    const ne = te && te.statusCode;
    if (!(X && (!ne || ne < 200 || ne >= 300))) {
      if (Xg(ee)) {
        iJ(Y, ee);
        return;
      }
      sJ(Y, ee);
    }
  };
}
function iJ(Y, X) {
  const ee = Y.getContext();
  X.contexts && X.contexts.trace && X.contexts.trace.trace_id && ee.traceIds.size < 100 && ee.traceIds.add(X.contexts.trace.trace_id);
}
function sJ(Y, X) {
  const ee = Y.getContext();
  if (X.event_id && ee.errorIds.size < 100 && ee.errorIds.add(X.event_id), Y.recordingMode !== "buffer" || !X.tags || !X.tags.replayId)
    return;
  const { beforeErrorSampling: te } = Y.getOptions();
  typeof te == "function" && !te(X) || setTimeout(() => {
    Y.sendBufferedReplayOrFlush();
  });
}
function oJ() {
  const Y = cr();
  if (!Y)
    return !1;
  const X = Y.getTransport();
  return X && X.send.__sentry__baseTransport__ || !1;
}
function aJ(Y) {
  return (X) => {
    !Y.isEnabled() || !Cb(X) || cJ(Y, X);
  };
}
function cJ(Y, X) {
  const ee = X.exception && X.exception.values && X.exception.values[0].value;
  if (typeof ee == "string" && // Only matches errors in production builds of react-dom
  // Example https://reactjs.org/docs/error-decoder.html?invariant=423
  (ee.match(/reactjs\.org\/docs\/error-decoder\.html\?invariant=(418|419|422|423|425)/) || // Development builds of react-dom
  // Error 1: Hydration failed because the initial UI does not match what was rendered on the server.
  // Error 2: Text content does not match server-rendered HTML. Warning: Text content did not match.
  ee.match(/(does not match server-rendered HTML|Hydration failed because)/i))) {
    const te = Gi({
      category: "replay.hydrate-error"
    });
    Lf(Y, te);
  }
}
function uJ(Y, X) {
  return Y.type || !Y.exception || !Y.exception.values || !Y.exception.values.length ? !1 : !!(X.originalException && X.originalException.__rrweb__);
}
function fJ(Y, X) {
  Y.triggerUserActivity(), Y.addUpdate(() => X.timestamp ? (Y.throttledAddEvent({
    type: Pt.Custom,
    timestamp: X.timestamp * 1e3,
    data: {
      tag: "breadcrumb",
      payload: {
        timestamp: X.timestamp,
        type: "default",
        category: "sentry.feedback",
        data: {
          feedbackId: X.event_id
        }
      }
    }
  }), !1) : !0);
}
function lJ(Y, X) {
  return Y.recordingMode !== "buffer" || X.message === bb || !X.exception || X.type ? !1 : f8(Y.getOptions().errorSampleRate);
}
function dJ(Y, X = !1) {
  const ee = X ? m8(Y) : void 0;
  return Object.assign(
    (te, ne) => Y.isEnabled() ? nJ(te) ? (delete te.breadcrumbs, te) : !Cb(te) && !Xg(te) && !l2(te) || !Y.checkAndHandleExpiredSession() ? te : l2(te) ? (Y.flush(), te.contexts.feedback.replay_id = Y.getSessionId(), fJ(Y, te), te) : uJ(te, ne) && !Y.getOptions()._experiments.captureExceptions ? (ar && xe.log("[Replay] Ignoring error from rrweb internals", te), null) : ((lJ(Y, te) || Y.recordingMode === "session") && (te.tags = { ...te.tags, replayId: Y.getSessionId() }), ee && ee(te, { statusCode: 200 }), te) : te,
    { id: "Replay" }
  );
}
function U0(Y, X) {
  return X.map(({ type: ee, start: te, end: ne, name: ie, data: oe }) => {
    const se = Y.throttledAddEvent({
      type: Pt.Custom,
      timestamp: te,
      data: {
        tag: "performanceSpan",
        payload: {
          op: ee,
          description: ie,
          startTimestamp: te,
          endTimestamp: ne,
          data: oe
        }
      }
    });
    return typeof se == "string" ? Promise.resolve(null) : se;
  });
}
function hJ(Y) {
  const { from: X, to: ee } = Y, te = Date.now() / 1e3;
  return {
    type: "navigation.push",
    start: te,
    end: te,
    name: ee,
    data: {
      previous: X
    }
  };
}
function pJ(Y) {
  return (X) => {
    if (!Y.isEnabled())
      return;
    const ee = hJ(X);
    ee !== null && (Y.getContext().urls.push(ee.name), Y.triggerUserActivity(), Y.addUpdate(() => (U0(Y, [ee]), !1)));
  };
}
function gJ(Y, X) {
  return ar && Y.getOptions()._experiments.traceInternals ? !1 : Rq(X, cr());
}
function j0(Y, X) {
  Y.isEnabled() && X !== null && (gJ(Y, X.name) || Y.addUpdate(() => (U0(Y, [X]), !0)));
}
function mJ(Y) {
  const { startTimestamp: X, endTimestamp: ee, fetchData: te, response: ne } = Y;
  if (!ee)
    return null;
  const { method: ie, url: oe } = te;
  return {
    type: "resource.fetch",
    start: X / 1e3,
    end: ee / 1e3,
    name: oe,
    data: {
      method: ie,
      statusCode: ne ? ne.status : void 0
    }
  };
}
function yJ(Y) {
  return (X) => {
    if (!Y.isEnabled())
      return;
    const ee = mJ(X);
    j0(Y, ee);
  };
}
function bJ(Y) {
  const { startTimestamp: X, endTimestamp: ee, xhr: te } = Y, ne = te[eo];
  if (!X || !ee || !ne)
    return null;
  const { method: ie, url: oe, status_code: se } = ne;
  return oe === void 0 ? null : {
    type: "resource.xhr",
    name: oe,
    start: X / 1e3,
    end: ee / 1e3,
    data: {
      method: ie,
      statusCode: se
    }
  };
}
function xJ(Y) {
  return (X) => {
    if (!Y.isEnabled())
      return;
    const ee = bJ(X);
    j0(Y, ee);
  };
}
function H0(Y, X) {
  if (Y)
    try {
      if (typeof Y == "string")
        return X.encode(Y).length;
      if (Y instanceof URLSearchParams)
        return X.encode(Y.toString()).length;
      if (Y instanceof FormData) {
        const ee = w8(Y);
        return X.encode(ee).length;
      }
      if (Y instanceof Blob)
        return Y.size;
      if (Y instanceof ArrayBuffer)
        return Y.byteLength;
    } catch {
    }
}
function y8(Y) {
  if (!Y)
    return;
  const X = parseInt(Y, 10);
  return isNaN(X) ? void 0 : X;
}
function b8(Y) {
  try {
    if (typeof Y == "string")
      return [Y];
    if (Y instanceof URLSearchParams)
      return [Y.toString()];
    if (Y instanceof FormData)
      return [w8(Y)];
    if (!Y)
      return [void 0];
  } catch {
    return ar && xe.warn("[Replay] Failed to serialize body", Y), [void 0, "BODY_PARSE_ERROR"];
  }
  return ar && xe.info("[Replay] Skipping network body because of body type", Y), [void 0, "UNPARSEABLE_BODY_TYPE"];
}
function gd(Y, X) {
  if (!Y)
    return {
      headers: {},
      size: void 0,
      _meta: {
        warnings: [X]
      }
    };
  const ee = { ...Y._meta }, te = ee.warnings || [];
  return ee.warnings = [...te, X], Y._meta = ee, Y;
}
function x8(Y, X) {
  if (!X)
    return null;
  const { startTimestamp: ee, endTimestamp: te, url: ne, method: ie, statusCode: oe, request: se, response: ae } = X;
  return {
    type: Y,
    start: ee / 1e3,
    end: te / 1e3,
    name: ne,
    data: xn({
      method: ie,
      statusCode: oe,
      request: se,
      response: ae
    })
  };
}
function nf(Y) {
  return {
    headers: {},
    size: Y,
    _meta: {
      warnings: ["URL_SKIPPED"]
    }
  };
}
function so(Y, X, ee) {
  if (!X && Object.keys(Y).length === 0)
    return;
  if (!X)
    return {
      headers: Y
    };
  if (!ee)
    return {
      headers: Y,
      size: X
    };
  const te = {
    headers: Y,
    size: X
  }, { body: ne, warnings: ie } = wJ(ee);
  return te.body = ne, ie && ie.length > 0 && (te._meta = {
    warnings: ie
  }), te;
}
function Zg(Y, X) {
  return Object.keys(Y).reduce((ee, te) => {
    const ne = te.toLowerCase();
    return X.includes(ne) && Y[te] && (ee[ne] = Y[te]), ee;
  }, {});
}
function w8(Y) {
  return new URLSearchParams(Y).toString();
}
function wJ(Y) {
  if (!Y || typeof Y != "string")
    return {
      body: Y
    };
  const X = Y.length > Yv, ee = vJ(Y);
  if (X) {
    const te = Y.slice(0, Yv);
    return ee ? {
      body: te,
      warnings: ["MAYBE_JSON_TRUNCATED"]
    } : {
      body: `${te}`,
      warnings: ["TEXT_TRUNCATED"]
    };
  }
  if (ee)
    try {
      return {
        body: JSON.parse(Y)
      };
    } catch {
    }
  return {
    body: Y
  };
}
function vJ(Y) {
  const X = Y[0], ee = Y[Y.length - 1];
  return X === "[" && ee === "]" || X === "{" && ee === "}";
}
function md(Y, X) {
  const ee = EJ(Y);
  return Nc(ee, X);
}
function EJ(Y, X = fr.document.baseURI) {
  if (Y.startsWith("http://") || Y.startsWith("https://") || Y.startsWith(fr.location.origin))
    return Y;
  const ee = new URL(Y, X);
  if (ee.origin !== new URL(X).origin)
    return Y;
  const te = ee.href;
  return !Y.endsWith("/") && te.endsWith("/") ? te.slice(0, -1) : te;
}
async function _J(Y, X, ee) {
  try {
    const te = await SJ(Y, X, ee), ne = x8("resource.fetch", te);
    j0(ee.replay, ne);
  } catch (te) {
    ar && xe.error("[Replay] Failed to capture fetch breadcrumb", te);
  }
}
function AJ(Y, X, ee) {
  const { input: te, response: ne } = X, ie = te ? v8(te) : void 0, oe = H0(ie, ee.textEncoder), se = ne ? y8(ne.headers.get("content-length")) : void 0;
  oe !== void 0 && (Y.data.request_body_size = oe), se !== void 0 && (Y.data.response_body_size = se);
}
async function SJ(Y, X, ee) {
  const te = Date.now(), { startTimestamp: ne = te, endTimestamp: ie = te } = X, {
    url: oe,
    method: se,
    status_code: ae = 0,
    request_body_size: ue,
    response_body_size: le
  } = Y.data, he = md(oe, ee.networkDetailAllowUrls) && !md(oe, ee.networkDetailDenyUrls), me = he ? TJ(ee, X.input, ue) : nf(ue), ye = await IJ(he, ee, X.response, le);
  return {
    startTimestamp: ne,
    endTimestamp: ie,
    url: oe,
    method: se,
    statusCode: ae,
    request: me,
    response: ye
  };
}
function TJ({ networkCaptureBodies: Y, networkRequestHeaders: X }, ee, te) {
  const ne = ee ? PJ(ee, X) : {};
  if (!Y)
    return so(ne, te, void 0);
  const ie = v8(ee), [oe, se] = b8(ie), ae = so(ne, te, oe);
  return se ? gd(ae, se) : ae;
}
async function IJ(Y, {
  networkCaptureBodies: X,
  textEncoder: ee,
  networkResponseHeaders: te
}, ne, ie) {
  if (!Y && ie !== void 0)
    return nf(ie);
  const oe = ne ? E8(ne.headers, te) : {};
  if (!ne || !X && ie !== void 0)
    return so(oe, ie, void 0);
  const [se, ae] = await CJ(ne), ue = RJ(se, {
    networkCaptureBodies: X,
    textEncoder: ee,
    responseBodySize: ie,
    captureDetails: Y,
    headers: oe
  });
  return ae ? gd(ue, ae) : ue;
}
function RJ(Y, {
  networkCaptureBodies: X,
  textEncoder: ee,
  responseBodySize: te,
  captureDetails: ne,
  headers: ie
}) {
  try {
    const oe = Y && Y.length && te === void 0 ? H0(Y, ee) : te;
    return ne ? X ? so(ie, oe, Y) : so(ie, oe, void 0) : nf(oe);
  } catch (oe) {
    return ar && xe.warn("[Replay] Failed to serialize response body", oe), so(ie, te, void 0);
  }
}
async function CJ(Y) {
  const X = OJ(Y);
  if (!X)
    return [void 0, "BODY_PARSE_ERROR"];
  try {
    return [await BJ(X)];
  } catch (ee) {
    return ar && xe.warn("[Replay] Failed to get text body from response", ee), [void 0, "BODY_PARSE_ERROR"];
  }
}
function v8(Y = []) {
  if (!(Y.length !== 2 || typeof Y[1] != "object"))
    return Y[1].body;
}
function E8(Y, X) {
  const ee = {};
  return X.forEach((te) => {
    Y.get(te) && (ee[te] = Y.get(te));
  }), ee;
}
function PJ(Y, X) {
  return Y.length === 1 && typeof Y[0] != "string" ? d2(Y[0], X) : Y.length === 2 ? d2(Y[1], X) : {};
}
function d2(Y, X) {
  if (!Y)
    return {};
  const ee = Y.headers;
  return ee ? ee instanceof Headers ? E8(ee, X) : Array.isArray(ee) ? {} : Zg(ee, X) : {};
}
function OJ(Y) {
  try {
    return Y.clone();
  } catch (X) {
    ar && xe.warn("[Replay] Failed to clone response body", X);
  }
}
function BJ(Y) {
  return new Promise((X, ee) => {
    const te = setTimeout(() => ee(new Error("Timeout while trying to read response body")), 500);
    NJ(Y).then(
      (ne) => X(ne),
      (ne) => ee(ne)
    ).finally(() => clearTimeout(te));
  });
}
async function NJ(Y) {
  return await Y.text();
}
async function kJ(Y, X, ee) {
  try {
    const te = LJ(Y, X, ee), ne = x8("resource.xhr", te);
    j0(ee.replay, ne);
  } catch (te) {
    ar && xe.error("[Replay] Failed to capture xhr breadcrumb", te);
  }
}
function MJ(Y, X, ee) {
  const { xhr: te, input: ne } = X;
  if (!te)
    return;
  const ie = H0(ne, ee.textEncoder), oe = te.getResponseHeader("content-length") ? y8(te.getResponseHeader("content-length")) : UJ(te.response, te.responseType, ee.textEncoder);
  ie !== void 0 && (Y.data.request_body_size = ie), oe !== void 0 && (Y.data.response_body_size = oe);
}
function LJ(Y, X, ee) {
  const te = Date.now(), { startTimestamp: ne = te, endTimestamp: ie = te, input: oe, xhr: se } = X, {
    url: ae,
    method: ue,
    status_code: le = 0,
    request_body_size: he,
    response_body_size: me
  } = Y.data;
  if (!ae)
    return null;
  if (!se || !md(ae, ee.networkDetailAllowUrls) || md(ae, ee.networkDetailDenyUrls)) {
    const tt = nf(he), rt = nf(me);
    return {
      startTimestamp: ne,
      endTimestamp: ie,
      url: ae,
      method: ue,
      statusCode: le,
      request: tt,
      response: rt
    };
  }
  const ye = se[eo], we = ye ? Zg(ye.request_headers, ee.networkRequestHeaders) : {}, Ee = Zg(FJ(se), ee.networkResponseHeaders), [Re, Ue] = ee.networkCaptureBodies ? b8(oe) : [void 0], [Me, De] = ee.networkCaptureBodies ? $J(se) : [void 0], Fe = so(we, he, Re), Ke = so(Ee, me, Me);
  return {
    startTimestamp: ne,
    endTimestamp: ie,
    url: ae,
    method: ue,
    statusCode: le,
    request: Ue ? gd(Fe, Ue) : Fe,
    response: De ? gd(Ke, De) : Ke
  };
}
function FJ(Y) {
  const X = Y.getAllResponseHeaders();
  return X ? X.split(`\r
`).reduce((ee, te) => {
    const [ne, ie] = te.split(": ");
    return ee[ne.toLowerCase()] = ie, ee;
  }, {}) : {};
}
function $J(Y) {
  const X = [];
  try {
    return [Y.responseText];
  } catch (ee) {
    X.push(ee);
  }
  try {
    return DJ(Y.response, Y.responseType);
  } catch (ee) {
    X.push(ee);
  }
  return ar && xe.warn("[Replay] Failed to get xhr response body", ...X), [void 0];
}
function DJ(Y, X) {
  try {
    if (typeof Y == "string")
      return [Y];
    if (Y instanceof Document)
      return [Y.body.outerHTML];
    if (X === "json" && Y && typeof Y == "object")
      return [JSON.stringify(Y)];
    if (!Y)
      return [void 0];
  } catch {
    return ar && xe.warn("[Replay] Failed to serialize body", Y), [void 0, "BODY_PARSE_ERROR"];
  }
  return ar && xe.info("[Replay] Skipping network body because of body type", Y), [void 0, "UNPARSEABLE_BODY_TYPE"];
}
function UJ(Y, X, ee) {
  try {
    const te = X === "json" && Y && typeof Y == "object" ? JSON.stringify(Y) : Y;
    return H0(te, ee);
  } catch {
    return;
  }
}
function jJ(Y) {
  const X = cr();
  try {
    const ee = new TextEncoder(), {
      networkDetailAllowUrls: te,
      networkDetailDenyUrls: ne,
      networkCaptureBodies: ie,
      networkRequestHeaders: oe,
      networkResponseHeaders: se
    } = Y.getOptions(), ae = {
      replay: Y,
      textEncoder: ee,
      networkDetailAllowUrls: te,
      networkDetailDenyUrls: ne,
      networkCaptureBodies: ie,
      networkRequestHeaders: oe,
      networkResponseHeaders: se
    };
    X && X.on ? X.on("beforeAddBreadcrumb", (ue, le) => HJ(ae, ue, le)) : (Qy(yJ(Y)), eb(xJ(Y)));
  } catch {
  }
}
function HJ(Y, X, ee) {
  if (X.data)
    try {
      zJ(X) && GJ(ee) && (MJ(X, ee, Y), kJ(X, ee, Y)), qJ(X) && VJ(ee) && (AJ(X, ee, Y), _J(X, ee, Y));
    } catch {
      ar && xe.warn("Error when enriching network breadcrumb");
    }
}
function zJ(Y) {
  return Y.category === "xhr";
}
function qJ(Y) {
  return Y.category === "fetch";
}
function GJ(Y) {
  return Y && Y.xhr;
}
function VJ(Y) {
  return Y && Y.response;
}
let h2 = null;
function WJ(Y) {
  return !!Y.category;
}
const KJ = (Y) => (X) => {
  if (!Y.isEnabled())
    return;
  const ee = JJ(X);
  ee && Lf(Y, ee);
};
function JJ(Y) {
  const X = Y.getLastBreadcrumb && Y.getLastBreadcrumb();
  return h2 === X || !X || (h2 = X, !WJ(X) || ["fetch", "xhr", "sentry.event", "sentry.transaction"].includes(X.category) || X.category.startsWith("ui.")) ? null : X.category === "console" ? YJ(X) : Gi(X);
}
function YJ(Y) {
  const X = Y.data && Y.data.arguments;
  if (!Array.isArray(X) || X.length === 0)
    return Gi(Y);
  let ee = !1;
  const te = X.map((ne) => {
    if (!ne)
      return ne;
    if (typeof ne == "string")
      return ne.length > fl ? (ee = !0, `${ne.slice(0, fl)}`) : ne;
    if (typeof ne == "object")
      try {
        const ie = ki(ne, 7);
        return JSON.stringify(ie).length > fl ? (ee = !0, `${JSON.stringify(ie, null, 2).slice(0, fl)}`) : ie;
      } catch {
      }
    return ne;
  });
  return Gi({
    ...Y,
    data: {
      ...Y.data,
      arguments: te,
      ...ee ? { _meta: { warnings: ["CONSOLE_ARG_TRUNCATED"] } } : {}
    }
  });
}
function XJ(Y) {
  const X = ai(), ee = cr();
  X.addScopeListener(KJ(Y)), PS(RK(Y)), C0(pJ(Y)), jJ(Y);
  const te = dJ(Y, !p2(ee));
  ee && ee.addEventProcessor ? ee.addEventProcessor(te) : _q(te), p2(ee) && (ee.on("beforeSendEvent", aJ(Y)), ee.on("afterSendEvent", m8(Y)), ee.on("createDsc", (ne) => {
    const ie = Y.getSessionId();
    ie && Y.isEnabled() && Y.recordingMode === "session" && Y.checkAndHandleExpiredSession() && (ne.replay_id = ie);
  }), ee.on("startTransaction", (ne) => {
    Y.lastTransaction = ne;
  }), ee.on("finishTransaction", (ne) => {
    Y.lastTransaction = ne;
  }), ee.on("beforeSendFeedback", (ne, ie) => {
    const oe = Y.getSessionId();
    ie && ie.includeReplay && Y.isEnabled() && oe && ne.contexts && ne.contexts.feedback && (ne.contexts.feedback.replay_id = oe);
  }));
}
function p2(Y) {
  return !!(Y && Y.on);
}
async function ZJ(Y) {
  try {
    return Promise.all(
      U0(Y, [
        // @ts-expect-error memory doesn't exist on type Performance as the API is non-standard (we check that it exists above)
        QJ(fr.performance.memory)
      ])
    );
  } catch {
    return [];
  }
}
function QJ(Y) {
  const { jsHeapSizeLimit: X, totalJSHeapSize: ee, usedJSHeapSize: te } = Y, ne = Date.now() / 1e3;
  return {
    type: "memory",
    name: "memory",
    start: ne,
    end: ne,
    data: {
      memory: {
        jsHeapSizeLimit: X,
        totalJSHeapSize: ee,
        usedJSHeapSize: te
      }
    }
  };
}
function eY(Y, X, ee) {
  let te, ne, ie;
  const oe = ee && ee.maxWait ? Math.max(ee.maxWait, X) : 0;
  function se() {
    return ae(), te = Y(), te;
  }
  function ae() {
    ne !== void 0 && clearTimeout(ne), ie !== void 0 && clearTimeout(ie), ne = ie = void 0;
  }
  function ue() {
    return ne !== void 0 || ie !== void 0 ? se() : te;
  }
  function le() {
    return ne && clearTimeout(ne), ne = setTimeout(se, X), oe && ie === void 0 && (ie = setTimeout(se, oe)), te;
  }
  return le.cancel = ae, le.flush = ue, le;
}
function tY(Y) {
  let X = !1;
  return (ee, te) => {
    if (!Y.checkAndHandleExpiredSession()) {
      ar && xe.warn("[Replay] Received replay event after session expired.");
      return;
    }
    const ne = te || !X;
    X = !0, Y.clickDetector && _K(Y.clickDetector, ee), Y.addUpdate(() => {
      if (Y.recordingMode === "buffer" && ne && Y.setInitialState(), !Rb(Y, ee, ne))
        return !0;
      if (!ne)
        return !1;
      if (nY(Y, ne), Y.session && Y.session.previousSessionId)
        return !0;
      if (Y.recordingMode === "buffer" && Y.session && Y.eventBuffer) {
        const ie = Y.eventBuffer.getEarliestTimestamp();
        ie && (mn(
          `[Replay] Updating session start time to earliest event in buffer to ${new Date(ie)}`,
          Y.getOptions()._experiments.traceInternals
        ), Y.session.started = ie, Y.getOptions().stickySession && Ib(Y.session));
      }
      return Y.recordingMode === "session" && Y.flush(), !0;
    });
  };
}
function rY(Y) {
  const X = Y.getOptions();
  return {
    type: Pt.Custom,
    timestamp: Date.now(),
    data: {
      tag: "options",
      payload: {
        shouldRecordCanvas: Y.isRecordingCanvas(),
        sessionSampleRate: X.sessionSampleRate,
        errorSampleRate: X.errorSampleRate,
        useCompressionOption: X.useCompression,
        blockAllMedia: X.blockAllMedia,
        maskAllText: X.maskAllText,
        maskAllInputs: X.maskAllInputs,
        useCompression: Y.eventBuffer ? Y.eventBuffer.type === "worker" : !1,
        networkDetailHasUrls: X.networkDetailAllowUrls.length > 0,
        networkCaptureBodies: X.networkCaptureBodies,
        networkRequestHasHeaders: X.networkRequestHeaders.length > 0,
        networkResponseHasHeaders: X.networkResponseHeaders.length > 0
      }
    }
  };
}
function nY(Y, X) {
  !X || !Y.session || Y.session.segmentId !== 0 || Rb(Y, rY(Y), !1);
}
function iY(Y, X, ee, te) {
  return ea(
    $S(Y, nb(Y), te, ee),
    [
      [{ type: "replay_event" }, Y],
      [
        {
          type: "replay_recording",
          // If string then we need to encode to UTF8, otherwise will have
          // wrong size. TextEncoder has similar browser support to
          // MutationObserver, although it does not accept IE11.
          length: typeof X == "string" ? new TextEncoder().encode(X).length : X.length
        },
        X
      ]
    ]
  );
}
function sY({
  recordingData: Y,
  headers: X
}) {
  let ee;
  const te = `${JSON.stringify(X)}
`;
  if (typeof Y == "string")
    ee = `${te}${Y}`;
  else {
    const ne = new TextEncoder().encode(te);
    ee = new Uint8Array(ne.length + Y.length), ee.set(ne), ee.set(Y, ne.length);
  }
  return ee;
}
async function oY({
  client: Y,
  scope: X,
  replayId: ee,
  event: te
}) {
  const ne = typeof Y._integrations == "object" && Y._integrations !== null && !Array.isArray(Y._integrations) ? Object.keys(Y._integrations) : void 0, ie = { event_id: ee, integrations: ne };
  Y.emit && Y.emit("preprocessEvent", te, ie);
  const oe = await qS(
    Y.getOptions(),
    te,
    ie,
    X,
    Y,
    xo()
  );
  if (!oe)
    return null;
  oe.platform = oe.platform || "javascript";
  const se = Y.getSdkMetadata && Y.getSdkMetadata(), { name: ae, version: ue } = se && se.sdk || {};
  return oe.sdk = {
    ...oe.sdk,
    name: ae || "sentry.javascript.unknown",
    version: ue || "0.0.0"
  }, oe;
}
async function aY({
  recordingData: Y,
  replayId: X,
  segmentId: ee,
  eventContext: te,
  timestamp: ne,
  session: ie
}) {
  const oe = sY({
    recordingData: Y,
    headers: {
      segment_id: ee
    }
  }), { urls: se, errorIds: ae, traceIds: ue, initialTimestamp: le } = te, he = cr(), me = ai(), ye = he && he.getTransport(), we = he && he.getDsn();
  if (!he || !ye || !we || !ie.sampled)
    return;
  const Ee = {
    type: GV,
    replay_start_timestamp: le / 1e3,
    timestamp: ne / 1e3,
    error_ids: ae,
    trace_ids: ue,
    urls: se,
    replay_id: X,
    segment_id: ee,
    replay_type: ie.sampled
  }, Re = await oY({ scope: me, client: he, replayId: X, event: Ee });
  if (!Re) {
    he.recordDroppedEvent("event_processor", "replay", Ee), mn("An event processor returned `null`, will not send event.");
    return;
  }
  delete Re.sdkProcessingMetadata;
  const Ue = iY(Re, oe, we, he.getOptions().tunnel);
  let Me;
  try {
    Me = await ye.send(Ue);
  } catch (Fe) {
    const Ke = new Error(bb);
    try {
      Ke.cause = Fe;
    } catch {
    }
    throw Ke;
  }
  if (!Me)
    return Me;
  if (typeof Me.statusCode == "number" && (Me.statusCode < 200 || Me.statusCode >= 300))
    throw new _8(Me.statusCode);
  const De = US({}, Me);
  if (DS(De, "replay"))
    throw new A8(De);
  return Me;
}
class _8 extends Error {
  constructor(X) {
    super(`Transport returned status code ${X}`);
  }
}
class A8 extends Error {
  constructor(X) {
    super("Rate limit hit"), this.rateLimits = X;
  }
}
async function S8(Y, X = {
  count: 0,
  interval: XV
}) {
  const { recordingData: ee, options: te } = Y;
  if (ee.length)
    try {
      return await aY(Y), !0;
    } catch (ne) {
      if (ne instanceof _8 || ne instanceof A8)
        throw ne;
      if (Oz("Replays", {
        _retryCount: X.count
      }), ar && te._experiments && te._experiments.captureExceptions && ab(ne), X.count >= ZV) {
        const ie = new Error(`${bb} - max retries exceeded`);
        try {
          ie.cause = ne;
        } catch {
        }
        throw ie;
      }
      return X.interval *= ++X.count, new Promise((ie, oe) => {
        setTimeout(async () => {
          try {
            await S8(Y, X), ie(!0);
          } catch (se) {
            oe(se);
          }
        }, X.interval);
      });
    }
}
const T8 = "__THROTTLED", cY = "__SKIPPED";
function uY(Y, X, ee) {
  const te = /* @__PURE__ */ new Map(), ne = (se) => {
    const ae = se - ee;
    te.forEach((ue, le) => {
      le < ae && te.delete(le);
    });
  }, ie = () => [...te.values()].reduce((se, ae) => se + ae, 0);
  let oe = !1;
  return (...se) => {
    const ae = Math.floor(Date.now() / 1e3);
    if (ne(ae), ie() >= X) {
      const le = oe;
      return oe = !0, le ? cY : T8;
    }
    oe = !1;
    const ue = te.get(ae) || 0;
    return te.set(ae, ue + 1), Y(...se);
  };
}
class Ks {
  /**
   * Recording can happen in one of three modes:
   *   - session: Record the whole session, sending it continuously
   *   - buffer: Always keep the last 60s of recording, requires:
   *     - having replaysOnErrorSampleRate > 0 to capture replay when an error occurs
   *     - or calling `flush()` to send the replay
   */
  /**
   * The current or last active transcation.
   * This is only available when performance is enabled.
   */
  /**
   * These are here so we can overwrite them in tests etc.
   * @hidden
   */
  /**
   * Options to pass to `rrweb.record()`
   */
  /**
   * Timestamp of the last user activity. This lives across sessions.
   */
  /**
   * Is the integration currently active?
   */
  /**
   * Paused is a state where:
   * - DOM Recording is not listening at all
   * - Nothing will be added to event buffer (e.g. core SDK events)
   */
  /**
   * Have we attached listeners to the core SDK?
   * Note we have to track this as there is no way to remove instrumentation handlers.
   */
  /**
   * Function to stop recording
   */
  /**
   * Internal use for canvas recording options
   */
  constructor({
    options: X,
    recordingOptions: ee
  }) {
    Ks.prototype.__init.call(this), Ks.prototype.__init2.call(this), Ks.prototype.__init3.call(this), Ks.prototype.__init4.call(this), Ks.prototype.__init5.call(this), Ks.prototype.__init6.call(this), this.eventBuffer = null, this.performanceEntries = [], this.replayPerformanceEntries = [], this.recordingMode = "session", this.timeouts = {
      sessionIdlePause: VV,
      sessionIdleExpire: WV
    }, this._lastActivity = Date.now(), this._isEnabled = !1, this._isPaused = !1, this._hasInitializedCoreListeners = !1, this._context = {
      errorIds: /* @__PURE__ */ new Set(),
      traceIds: /* @__PURE__ */ new Set(),
      urls: [],
      initialTimestamp: Date.now(),
      initialUrl: ""
    }, this._recordingOptions = ee, this._options = X, this._debouncedFlush = eY(() => this._flush(), this._options.flushMinDelay, {
      maxWait: this._options.flushMaxDelay
    }), this._throttledAddEvent = uY(
      (oe, se) => tJ(this, oe, se),
      // Max 300 events...
      300,
      // ... per 5s
      5
    );
    const { slowClickTimeout: te, slowClickIgnoreSelectors: ne } = this.getOptions(), ie = te ? {
      threshold: Math.min(QV, te),
      timeout: te,
      scrollTimeout: eW,
      ignoreSelector: ne ? ne.join(",") : ""
    } : void 0;
    ie && (this.clickDetector = new xK(this, ie));
  }
  /** Get the event context. */
  getContext() {
    return this._context;
  }
  /** If recording is currently enabled. */
  isEnabled() {
    return this._isEnabled;
  }
  /** If recording is currently paused. */
  isPaused() {
    return this._isPaused;
  }
  /**
   * Determine if canvas recording is enabled
   */
  isRecordingCanvas() {
    return !!this._canvas;
  }
  /** Get the replay integration options. */
  getOptions() {
    return this._options;
  }
  /**
   * Initializes the plugin based on sampling configuration. Should not be
   * called outside of constructor.
   */
  initializeSampling(X) {
    const { errorSampleRate: ee, sessionSampleRate: te } = this._options;
    if (!(ee <= 0 && te <= 0)) {
      if (this._initializeSessionForSampling(X), !this.session) {
        this._handleException(new Error("Unable to initialize and create session"));
        return;
      }
      this.session.sampled !== !1 && (this.recordingMode = this.session.sampled === "buffer" && this.session.segmentId === 0 ? "buffer" : "session", Ua(
        `[Replay] Starting replay in ${this.recordingMode} mode`,
        this._options._experiments.traceInternals
      ), this._initializeRecording());
    }
  }
  /**
   * Start a replay regardless of sampling rate. Calling this will always
   * create a new session. Will throw an error if replay is already in progress.
   *
   * Creates or loads a session, attaches listeners to varying events (DOM,
   * _performanceObserver, Recording, Sentry SDK, etc)
   */
  start() {
    if (this._isEnabled && this.recordingMode === "session")
      throw new Error("Replay recording is already in progress");
    if (this._isEnabled && this.recordingMode === "buffer")
      throw new Error("Replay buffering is in progress, call `flush()` to save the replay");
    Ua("[Replay] Starting replay in session mode", this._options._experiments.traceInternals);
    const X = Cp(
      {
        maxReplayDuration: this._options.maxReplayDuration,
        sessionIdleExpire: this.timeouts.sessionIdleExpire,
        traceInternals: this._options._experiments.traceInternals
      },
      {
        stickySession: this._options.stickySession,
        // This is intentional: create a new session-based replay when calling `start()`
        sessionSampleRate: 1,
        allowBuffering: !1
      }
    );
    this.session = X, this._initializeRecording();
  }
  /**
   * Start replay buffering. Buffers until `flush()` is called or, if
   * `replaysOnErrorSampleRate` > 0, an error occurs.
   */
  startBuffering() {
    if (this._isEnabled)
      throw new Error("Replay recording is already in progress");
    Ua("[Replay] Starting replay in buffer mode", this._options._experiments.traceInternals);
    const X = Cp(
      {
        sessionIdleExpire: this.timeouts.sessionIdleExpire,
        maxReplayDuration: this._options.maxReplayDuration,
        traceInternals: this._options._experiments.traceInternals
      },
      {
        stickySession: this._options.stickySession,
        sessionSampleRate: 0,
        allowBuffering: !0
      }
    );
    this.session = X, this.recordingMode = "buffer", this._initializeRecording();
  }
  /**
   * Start recording.
   *
   * Note that this will cause a new DOM checkout
   */
  startRecording() {
    try {
      const X = this._canvas;
      this._stopRecording = io({
        ...this._recordingOptions,
        // When running in error sampling mode, we need to overwrite `checkoutEveryNms`
        // Without this, it would record forever, until an error happens, which we don't want
        // instead, we'll always keep the last 60 seconds of replay before an error happened
        ...this.recordingMode === "buffer" && { checkoutEveryNms: YV },
        emit: tY(this),
        onMutation: this._onMutationHandler,
        ...X ? {
          recordCanvas: X.recordCanvas,
          getCanvasManager: X.getCanvasManager,
          sampling: X.sampling,
          dataURLOptions: X.dataURLOptions
        } : {}
      });
    } catch (X) {
      this._handleException(X);
    }
  }
  /**
   * Stops the recording, if it was running.
   *
   * Returns true if it was previously stopped, or is now stopped,
   * otherwise false.
   */
  stopRecording() {
    try {
      return this._stopRecording && (this._stopRecording(), this._stopRecording = void 0), !0;
    } catch (X) {
      return this._handleException(X), !1;
    }
  }
  /**
   * Currently, this needs to be manually called (e.g. for tests). Sentry SDK
   * does not support a teardown
   */
  async stop({ forceFlush: X = !1, reason: ee } = {}) {
    if (this._isEnabled) {
      this._isEnabled = !1;
      try {
        mn(
          `[Replay] Stopping Replay${ee ? ` triggered by ${ee}` : ""}`,
          this._options._experiments.traceInternals
        ), this._removeListeners(), this.stopRecording(), this._debouncedFlush.cancel(), X && await this._flush({ force: !0 }), this.eventBuffer && this.eventBuffer.destroy(), this.eventBuffer = null, YK(this);
      } catch (te) {
        this._handleException(te);
      }
    }
  }
  /**
   * Pause some replay functionality. See comments for `_isPaused`.
   * This differs from stop as this only stops DOM recording, it is
   * not as thorough of a shutdown as `stop()`.
   */
  pause() {
    this._isPaused || (this._isPaused = !0, this.stopRecording(), mn("[Replay] Pausing replay", this._options._experiments.traceInternals));
  }
  /**
   * Resumes recording, see notes for `pause().
   *
   * Note that calling `startRecording()` here will cause a
   * new DOM checkout.`
   */
  resume() {
    !this._isPaused || !this._checkSession() || (this._isPaused = !1, this.startRecording(), mn("[Replay] Resuming replay", this._options._experiments.traceInternals));
  }
  /**
   * If not in "session" recording mode, flush event buffer which will create a new replay.
   * Unless `continueRecording` is false, the replay will continue to record and
   * behave as a "session"-based replay.
   *
   * Otherwise, queue up a flush.
   */
  async sendBufferedReplayOrFlush({ continueRecording: X = !0 } = {}) {
    if (this.recordingMode === "session")
      return this.flushImmediate();
    const ee = Date.now();
    mn("[Replay] Converting buffer to session", this._options._experiments.traceInternals), await this.flushImmediate();
    const te = this.stopRecording();
    !X || !te || this.recordingMode !== "session" && (this.recordingMode = "session", this.session && (this._updateUserActivity(ee), this._updateSessionActivity(ee), this._maybeSaveSession()), this.startRecording());
  }
  /**
   * We want to batch uploads of replay events. Save events only if
   * `<flushMinDelay>` milliseconds have elapsed since the last event
   * *OR* if `<flushMaxDelay>` milliseconds have elapsed.
   *
   * Accepts a callback to perform side-effects and returns true to stop batch
   * processing and hand back control to caller.
   */
  addUpdate(X) {
    const ee = X();
    this.recordingMode !== "buffer" && ee !== !0 && this._debouncedFlush();
  }
  /**
   * Updates the user activity timestamp and resumes recording. This should be
   * called in an event handler for a user action that we consider as the user
   * being "active" (e.g. a mouse click).
   */
  triggerUserActivity() {
    if (this._updateUserActivity(), !this._stopRecording) {
      if (!this._checkSession())
        return;
      this.resume();
      return;
    }
    this.checkAndHandleExpiredSession(), this._updateSessionActivity();
  }
  /**
   * Updates the user activity timestamp *without* resuming
   * recording. Some user events (e.g. keydown) can be create
   * low-value replays that only contain the keypress as a
   * breadcrumb. Instead this would require other events to
   * create a new replay after a session has expired.
   */
  updateUserActivity() {
    this._updateUserActivity(), this._updateSessionActivity();
  }
  /**
   * Only flush if `this.recordingMode === 'session'`
   */
  conditionalFlush() {
    return this.recordingMode === "buffer" ? Promise.resolve() : this.flushImmediate();
  }
  /**
   * Flush using debounce flush
   */
  flush() {
    return this._debouncedFlush();
  }
  /**
   * Always flush via `_debouncedFlush` so that we do not have flushes triggered
   * from calling both `flush` and `_debouncedFlush`. Otherwise, there could be
   * cases of mulitple flushes happening closely together.
   */
  flushImmediate() {
    return this._debouncedFlush(), this._debouncedFlush.flush();
  }
  /**
   * Cancels queued up flushes.
   */
  cancelFlush() {
    this._debouncedFlush.cancel();
  }
  /** Get the current sesion (=replay) ID */
  getSessionId() {
    return this.session && this.session.id;
  }
  /**
   * Checks if recording should be stopped due to user inactivity. Otherwise
   * check if session is expired and create a new session if so. Triggers a new
   * full snapshot on new session.
   *
   * Returns true if session is not expired, false otherwise.
   * @hidden
   */
  checkAndHandleExpiredSession() {
    if (this._lastActivity && Yg(this._lastActivity, this.timeouts.sessionIdlePause) && this.session && this.session.sampled === "session") {
      this.pause();
      return;
    }
    return !!this._checkSession();
  }
  /**
   * Capture some initial state that can change throughout the lifespan of the
   * replay. This is required because otherwise they would be captured at the
   * first flush.
   */
  setInitialState() {
    const X = `${fr.location.pathname}${fr.location.hash}${fr.location.search}`, ee = `${fr.location.origin}${X}`;
    this.performanceEntries = [], this.replayPerformanceEntries = [], this._clearContext(), this._context.initialUrl = ee, this._context.initialTimestamp = Date.now(), this._context.urls.push(ee);
  }
  /**
   * Add a breadcrumb event, that may be throttled.
   * If it was throttled, we add a custom breadcrumb to indicate that.
   */
  throttledAddEvent(X, ee) {
    const te = this._throttledAddEvent(X, ee);
    if (te === T8) {
      const ne = Gi({
        category: "replay.throttled"
      });
      this.addUpdate(() => !Rb(this, {
        type: hK,
        timestamp: ne.timestamp || 0,
        data: {
          tag: "breadcrumb",
          payload: ne,
          metric: !0
        }
      }));
    }
    return te;
  }
  /**
   * This will get the parametrized route name of the current page.
   * This is only available if performance is enabled, and if an instrumented router is used.
   */
  getCurrentRoute() {
    const X = this.lastTransaction || ai().getTransaction(), ee = (X && rn(X).data || {})[Po];
    if (!(!X || !ee || !["route", "custom"].includes(ee)))
      return rn(X).description;
  }
  /**
   * Initialize and start all listeners to varying events (DOM,
   * Performance Observer, Recording, Sentry SDK, etc)
   */
  _initializeRecording() {
    this.setInitialState(), this._updateSessionActivity(), this.eventBuffer = WK({
      useCompression: this._options.useCompression,
      workerUrl: this._options.workerUrl
    }), this._removeListeners(), this._addListeners(), this._isEnabled = !0, this._isPaused = !1, this.startRecording();
  }
  /** A wrapper to conditionally capture exceptions. */
  _handleException(X) {
    ar && xe.error("[Replay]", X), ar && this._options._experiments && this._options._experiments.captureExceptions && ab(X);
  }
  /**
   * Loads (or refreshes) the current session.
   */
  _initializeSessionForSampling(X) {
    const ee = this._options.errorSampleRate > 0, te = Cp(
      {
        sessionIdleExpire: this.timeouts.sessionIdleExpire,
        maxReplayDuration: this._options.maxReplayDuration,
        traceInternals: this._options._experiments.traceInternals,
        previousSessionId: X
      },
      {
        stickySession: this._options.stickySession,
        sessionSampleRate: this._options.sessionSampleRate,
        allowBuffering: ee
      }
    );
    this.session = te;
  }
  /**
   * Checks and potentially refreshes the current session.
   * Returns false if session is not recorded.
   */
  _checkSession() {
    if (!this.session)
      return !1;
    const X = this.session;
    return h8(X, {
      sessionIdleExpire: this.timeouts.sessionIdleExpire,
      maxReplayDuration: this._options.maxReplayDuration
    }) ? (this._refreshSession(X), !1) : !0;
  }
  /**
   * Refresh a session with a new one.
   * This stops the current session (without forcing a flush, as that would never work since we are expired),
   * and then does a new sampling based on the refreshed session.
   */
  async _refreshSession(X) {
    this._isEnabled && (await this.stop({ reason: "refresh session" }), this.initializeSampling(X.id));
  }
  /**
   * Adds listeners to record events for the replay
   */
  _addListeners() {
    try {
      fr.document.addEventListener("visibilitychange", this._handleVisibilityChange), fr.addEventListener("blur", this._handleWindowBlur), fr.addEventListener("focus", this._handleWindowFocus), fr.addEventListener("keydown", this._handleKeyboardEvent), this.clickDetector && this.clickDetector.addListeners(), this._hasInitializedCoreListeners || (XJ(this), this._hasInitializedCoreListeners = !0);
    } catch (X) {
      this._handleException(X);
    }
    this._performanceCleanupCallback = jK(this);
  }
  /**
   * Cleans up listeners that were created in `_addListeners`
   */
  _removeListeners() {
    try {
      fr.document.removeEventListener("visibilitychange", this._handleVisibilityChange), fr.removeEventListener("blur", this._handleWindowBlur), fr.removeEventListener("focus", this._handleWindowFocus), fr.removeEventListener("keydown", this._handleKeyboardEvent), this.clickDetector && this.clickDetector.removeListeners(), this._performanceCleanupCallback && this._performanceCleanupCallback();
    } catch (X) {
      this._handleException(X);
    }
  }
  /**
   * Handle when visibility of the page content changes. Opening a new tab will
   * cause the state to change to hidden because of content of current page will
   * be hidden. Likewise, moving a different window to cover the contents of the
   * page will also trigger a change to a hidden state.
   */
  __init() {
    this._handleVisibilityChange = () => {
      fr.document.visibilityState === "visible" ? this._doChangeToForegroundTasks() : this._doChangeToBackgroundTasks();
    };
  }
  /**
   * Handle when page is blurred
   */
  __init2() {
    this._handleWindowBlur = () => {
      const X = Gi({
        category: "ui.blur"
      });
      this._doChangeToBackgroundTasks(X);
    };
  }
  /**
   * Handle when page is focused
   */
  __init3() {
    this._handleWindowFocus = () => {
      const X = Gi({
        category: "ui.focus"
      });
      this._doChangeToForegroundTasks(X);
    };
  }
  /** Ensure page remains active when a key is pressed. */
  __init4() {
    this._handleKeyboardEvent = (X) => {
      BK(this, X);
    };
  }
  /**
   * Tasks to run when we consider a page to be hidden (via blurring and/or visibility)
   */
  _doChangeToBackgroundTasks(X) {
    !this.session || d8(this.session, {
      maxReplayDuration: this._options.maxReplayDuration,
      sessionIdleExpire: this.timeouts.sessionIdleExpire
    }) || (X && this._createCustomBreadcrumb(X), this.conditionalFlush());
  }
  /**
   * Tasks to run when we consider a page to be visible (via focus and/or visibility)
   */
  _doChangeToForegroundTasks(X) {
    if (this.session) {
      if (!this.checkAndHandleExpiredSession()) {
        mn("[Replay] Document has become active, but session has expired");
        return;
      }
      X && this._createCustomBreadcrumb(X);
    }
  }
  /**
   * Update user activity (across session lifespans)
   */
  _updateUserActivity(X = Date.now()) {
    this._lastActivity = X;
  }
  /**
   * Updates the session's last activity timestamp
   */
  _updateSessionActivity(X = Date.now()) {
    this.session && (this.session.lastActivity = X, this._maybeSaveSession());
  }
  /**
   * Helper to create (and buffer) a replay breadcrumb from a core SDK breadcrumb
   */
  _createCustomBreadcrumb(X) {
    this.addUpdate(() => {
      this.throttledAddEvent({
        type: Pt.Custom,
        timestamp: X.timestamp || 0,
        data: {
          tag: "breadcrumb",
          payload: X
        }
      });
    });
  }
  /**
   * Observed performance events are added to `this.performanceEntries`. These
   * are included in the replay event before it is finished and sent to Sentry.
   */
  _addPerformanceEntries() {
    const X = MK(this.performanceEntries).concat(this.replayPerformanceEntries);
    return this.performanceEntries = [], this.replayPerformanceEntries = [], Promise.all(U0(this, X));
  }
  /**
   * Clear _context
   */
  _clearContext() {
    this._context.errorIds.clear(), this._context.traceIds.clear(), this._context.urls = [];
  }
  /** Update the initial timestamp based on the buffer content. */
  _updateInitialTimestampFromEventBuffer() {
    const { session: X, eventBuffer: ee } = this;
    if (!X || !ee || X.segmentId)
      return;
    const te = ee.getEarliestTimestamp();
    te && te < this._context.initialTimestamp && (this._context.initialTimestamp = te);
  }
  /**
   * Return and clear _context
   */
  _popEventContext() {
    const X = {
      initialTimestamp: this._context.initialTimestamp,
      initialUrl: this._context.initialUrl,
      errorIds: Array.from(this._context.errorIds),
      traceIds: Array.from(this._context.traceIds),
      urls: this._context.urls
    };
    return this._clearContext(), X;
  }
  /**
   * Flushes replay event buffer to Sentry.
   *
   * Performance events are only added right before flushing - this is
   * due to the buffered performance observer events.
   *
   * Should never be called directly, only by `flush`
   */
  async _runFlush() {
    const X = this.getSessionId();
    if (!this.session || !this.eventBuffer || !X) {
      ar && xe.error("[Replay] No session or eventBuffer found to flush.");
      return;
    }
    if (await this._addPerformanceEntries(), !(!this.eventBuffer || !this.eventBuffer.hasEvents) && (await ZJ(this), !!this.eventBuffer && X === this.getSessionId()))
      try {
        this._updateInitialTimestampFromEventBuffer();
        const ee = Date.now();
        if (ee - this._context.initialTimestamp > this._options.maxReplayDuration + 3e4)
          throw new Error("Session is too long, not sending replay");
        const te = this._popEventContext(), ne = this.session.segmentId++;
        this._maybeSaveSession();
        const ie = await this.eventBuffer.finish();
        await S8({
          replayId: X,
          recordingData: ie,
          segmentId: ne,
          eventContext: te,
          session: this.session,
          options: this.getOptions(),
          timestamp: ee
        });
      } catch (ee) {
        this._handleException(ee), this.stop({ reason: "sendReplay" });
        const te = cr();
        te && te.recordDroppedEvent("send_error", "replay");
      }
  }
  /**
   * Flush recording data to Sentry. Creates a lock so that only a single flush
   * can be active at a time. Do not call this directly.
   */
  __init5() {
    this._flush = async ({
      force: X = !1
    } = {}) => {
      if (!this._isEnabled && !X)
        return;
      if (!this.checkAndHandleExpiredSession()) {
        ar && xe.error("[Replay] Attempting to finish replay event after session expired.");
        return;
      }
      if (!this.session)
        return;
      const ee = this.session.started, te = Date.now() - ee;
      this._debouncedFlush.cancel();
      const ne = te < this._options.minReplayDuration, ie = te > this._options.maxReplayDuration + 5e3;
      if (ne || ie) {
        mn(
          `[Replay] Session duration (${Math.floor(te / 1e3)}s) is too ${ne ? "short" : "long"}, not sending replay.`,
          this._options._experiments.traceInternals
        ), ne && this._debouncedFlush();
        return;
      }
      const oe = this.eventBuffer;
      if (oe && this.session.segmentId === 0 && !oe.hasCheckout && mn("[Replay] Flushing initial segment without checkout.", this._options._experiments.traceInternals), !this._flushLock) {
        this._flushLock = this._runFlush(), await this._flushLock, this._flushLock = void 0;
        return;
      }
      try {
        await this._flushLock;
      } catch (se) {
        ar && xe.error(se);
      } finally {
        this._debouncedFlush();
      }
    };
  }
  /** Save the session, if it is sticky */
  _maybeSaveSession() {
    this.session && this._options.stickySession && Ib(this.session);
  }
  /** Handler for rrweb.record.onMutation */
  __init6() {
    this._onMutationHandler = (X) => {
      const ee = X.length, te = this._options.mutationLimit, ne = this._options.mutationBreadcrumbLimit, ie = te && ee > te;
      if (ee > ne || ie) {
        const oe = Gi({
          category: "replay.mutations",
          data: {
            count: ee,
            limit: ie
          }
        });
        this._createCustomBreadcrumb(oe);
      }
      return ie ? (this.stop({ reason: "mutationLimit", forceFlush: this.recordingMode === "session" }), !1) : !0;
    };
  }
}
function ru(Y, X, ee, te) {
  const ne = typeof te == "string" ? te.split(",") : [], ie = [
    ...Y,
    // @deprecated
    ...ne,
    // sentry defaults
    ...X
  ];
  return typeof ee < "u" && (typeof ee == "string" && ie.push(`.${ee}`), qo(() => {
    console.warn(
      "[Replay] You are using a deprecated configuration item for privacy. Read the documentation on how to use the new privacy configuration."
    );
  })), ie.join(",");
}
function fY({
  mask: Y,
  unmask: X,
  block: ee,
  unblock: te,
  ignore: ne,
  // eslint-disable-next-line deprecation/deprecation
  blockClass: ie,
  // eslint-disable-next-line deprecation/deprecation
  blockSelector: oe,
  // eslint-disable-next-line deprecation/deprecation
  maskTextClass: se,
  // eslint-disable-next-line deprecation/deprecation
  maskTextSelector: ae,
  // eslint-disable-next-line deprecation/deprecation
  ignoreClass: ue
}) {
  const le = ['base[href="/"]'], he = ru(Y, [".sentry-mask", "[data-sentry-mask]"], se, ae), me = ru(X, [".sentry-unmask", "[data-sentry-unmask]"]), ye = {
    // We are making the decision to make text and input selectors the same
    maskTextSelector: he,
    unmaskTextSelector: me,
    blockSelector: ru(
      ee,
      [".sentry-block", "[data-sentry-block]", ...le],
      ie,
      oe
    ),
    unblockSelector: ru(te, [".sentry-unblock", "[data-sentry-unblock]"]),
    ignoreSelector: ru(ne, [".sentry-ignore", "[data-sentry-ignore]", 'input[type="file"]'], ue)
  };
  return ie instanceof RegExp && (ye.blockClass = ie), se instanceof RegExp && (ye.maskTextClass = se), ye;
}
function lY({
  el: Y,
  key: X,
  maskAttributes: ee,
  maskAllText: te,
  privacyOptions: ne,
  value: ie
}) {
  return !te || ne.unmaskTextSelector && Y.matches(ne.unmaskTextSelector) ? ie : ee.includes(X) || // Need to mask `value` attribute for `<input>` if it's a button-like
  // type
  X === "value" && Y.tagName === "INPUT" && ["submit", "button"].includes(Y.getAttribute("type") || "") ? ie.replace(/[\S]/g, "*") : ie;
}
const g2 = 'img,image,svg,video,object,picture,embed,map,audio,link[rel="icon"],link[rel="apple-touch-icon"]', dY = ["content-length", "content-type", "accept"];
let m2 = !1;
class z0 {
  /**
   * @inheritDoc
   */
  static __initStatic() {
    this.id = "Replay";
  }
  /**
   * @inheritDoc
   */
  /**
   * Options to pass to `rrweb.record()`
   */
  /**
   * Initial options passed to the replay integration, merged with default values.
   * Note: `sessionSampleRate` and `errorSampleRate` are not required here, as they
   * can only be finally set when setupOnce() is called.
   *
   * @private
   */
  constructor({
    flushMinDelay: X = KV,
    flushMaxDelay: ee = JV,
    minReplayDuration: te = tW,
    maxReplayDuration: ne = Xv,
    stickySession: ie = !0,
    useCompression: oe = !0,
    workerUrl: se,
    _experiments: ae = {},
    sessionSampleRate: ue,
    errorSampleRate: le,
    maskAllText: he = !0,
    maskAllInputs: me = !0,
    blockAllMedia: ye = !0,
    mutationBreadcrumbLimit: we = 750,
    mutationLimit: Ee = 1e4,
    slowClickTimeout: Re = 7e3,
    slowClickIgnoreSelectors: Ue = [],
    networkDetailAllowUrls: Me = [],
    networkDetailDenyUrls: De = [],
    networkCaptureBodies: Fe = !0,
    networkRequestHeaders: Ke = [],
    networkResponseHeaders: tt = [],
    mask: rt = [],
    maskAttributes: it = ["title", "placeholder"],
    unmask: _t = [],
    block: Dt = [],
    unblock: je = [],
    ignore: ze = [],
    maskFn: fe,
    beforeAddRecordingEvent: de,
    beforeErrorSampling: be,
    // eslint-disable-next-line deprecation/deprecation
    blockClass: Te,
    // eslint-disable-next-line deprecation/deprecation
    blockSelector: Ce,
    // eslint-disable-next-line deprecation/deprecation
    maskInputOptions: Pe,
    // eslint-disable-next-line deprecation/deprecation
    maskTextClass: Se,
    // eslint-disable-next-line deprecation/deprecation
    maskTextSelector: ke,
    // eslint-disable-next-line deprecation/deprecation
    ignoreClass: ge
  } = {}) {
    this.name = z0.id;
    const Ae = fY({
      mask: rt,
      unmask: _t,
      block: Dt,
      unblock: je,
      ignore: ze,
      blockClass: Te,
      blockSelector: Ce,
      maskTextClass: Se,
      maskTextSelector: ke,
      ignoreClass: ge
    });
    if (this._recordingOptions = {
      maskAllInputs: me,
      maskAllText: he,
      maskInputOptions: { ...Pe || {}, password: !0 },
      maskTextFn: fe,
      maskInputFn: fe,
      maskAttributeFn: (Ge, Xe, $e) => lY({
        maskAttributes: it,
        maskAllText: he,
        privacyOptions: Ae,
        key: Ge,
        value: Xe,
        el: $e
      }),
      ...Ae,
      // Our defaults
      slimDOMOptions: "all",
      inlineStylesheet: !0,
      // Disable inline images as it will increase segment/replay size
      inlineImages: !1,
      // collect fonts, but be aware that `sentry.io` needs to be an allowed
      // origin for playback
      collectFonts: !0,
      errorHandler: (Ge) => {
        try {
          Ge.__rrweb__ = !0;
        } catch {
        }
      }
    }, this._initialOptions = {
      flushMinDelay: X,
      flushMaxDelay: ee,
      minReplayDuration: Math.min(te, rW),
      maxReplayDuration: Math.min(ne, Xv),
      stickySession: ie,
      sessionSampleRate: ue,
      errorSampleRate: le,
      useCompression: oe,
      workerUrl: se,
      blockAllMedia: ye,
      maskAllInputs: me,
      maskAllText: he,
      mutationBreadcrumbLimit: we,
      mutationLimit: Ee,
      slowClickTimeout: Re,
      slowClickIgnoreSelectors: Ue,
      networkDetailAllowUrls: Me,
      networkDetailDenyUrls: De,
      networkCaptureBodies: Fe,
      networkRequestHeaders: y2(Ke),
      networkResponseHeaders: y2(tt),
      beforeAddRecordingEvent: de,
      beforeErrorSampling: be,
      _experiments: ae
    }, typeof ue == "number" && (console.warn(
      `[Replay] You are passing \`sessionSampleRate\` to the Replay integration.
This option is deprecated and will be removed soon.
Instead, configure \`replaysSessionSampleRate\` directly in the SDK init options, e.g.:
Sentry.init({ replaysSessionSampleRate: ${ue} })`
    ), this._initialOptions.sessionSampleRate = ue), typeof le == "number" && (console.warn(
      `[Replay] You are passing \`errorSampleRate\` to the Replay integration.
This option is deprecated and will be removed soon.
Instead, configure \`replaysOnErrorSampleRate\` directly in the SDK init options, e.g.:
Sentry.init({ replaysOnErrorSampleRate: ${le} })`
    ), this._initialOptions.errorSampleRate = le), this._initialOptions.blockAllMedia && (this._recordingOptions.blockSelector = this._recordingOptions.blockSelector ? `${this._recordingOptions.blockSelector},${g2}` : g2), this._isInitialized && vv())
      throw new Error("Multiple Sentry Session Replay instances are not supported");
    this._isInitialized = !0;
  }
  /** If replay has already been initialized */
  get _isInitialized() {
    return m2;
  }
  /** Update _isInitialized */
  set _isInitialized(X) {
    m2 = X;
  }
  /**
   * Setup and initialize replay container
   */
  setupOnce() {
    vv() && (this._setup(), setTimeout(() => this._initialize()));
  }
  /**
   * Start a replay regardless of sampling rate. Calling this will always
   * create a new session. Will throw an error if replay is already in progress.
   *
   * Creates or loads a session, attaches listeners to varying events (DOM,
   * PerformanceObserver, Recording, Sentry SDK, etc)
   */
  start() {
    this._replay && this._replay.start();
  }
  /**
   * Start replay buffering. Buffers until `flush()` is called or, if
   * `replaysOnErrorSampleRate` > 0, until an error occurs.
   */
  startBuffering() {
    this._replay && this._replay.startBuffering();
  }
  /**
   * Currently, this needs to be manually called (e.g. for tests). Sentry SDK
   * does not support a teardown
   */
  stop() {
    return this._replay ? this._replay.stop({ forceFlush: this._replay.recordingMode === "session" }) : Promise.resolve();
  }
  /**
   * If not in "session" recording mode, flush event buffer which will create a new replay.
   * Unless `continueRecording` is false, the replay will continue to record and
   * behave as a "session"-based replay.
   *
   * Otherwise, queue up a flush.
   */
  flush(X) {
    return !this._replay || !this._replay.isEnabled() ? Promise.resolve() : this._replay.sendBufferedReplayOrFlush(X);
  }
  /**
   * Get the current session ID.
   */
  getReplayId() {
    if (!(!this._replay || !this._replay.isEnabled()))
      return this._replay.getSessionId();
  }
  /**
   * Initializes replay.
   */
  _initialize() {
    this._replay && (this._maybeLoadFromReplayCanvasIntegration(), this._replay.initializeSampling());
  }
  /** Setup the integration. */
  _setup() {
    const X = hY(this._initialOptions);
    this._replay = new Ks({
      options: X,
      recordingOptions: this._recordingOptions
    });
  }
  /** Get canvas options from ReplayCanvas integration, if it is also added. */
  _maybeLoadFromReplayCanvasIntegration() {
    try {
      const X = cr().getIntegrationByName("ReplayCanvas");
      if (!X)
        return;
      this._replay._canvas = X.getOptions();
    } catch {
    }
  }
}
z0.__initStatic();
function hY(Y) {
  const X = cr(), ee = X && X.getOptions(), te = { sessionSampleRate: 0, errorSampleRate: 0, ...xn(Y) };
  return ee ? (Y.sessionSampleRate == null && // TODO remove once deprecated rates are removed
  Y.errorSampleRate == null && // TODO remove once deprecated rates are removed
  ee.replaysSessionSampleRate == null && ee.replaysOnErrorSampleRate == null && qo(() => {
    console.warn(
      "Replay is disabled because neither `replaysSessionSampleRate` nor `replaysOnErrorSampleRate` are set."
    );
  }), typeof ee.replaysSessionSampleRate == "number" && (te.sessionSampleRate = ee.replaysSessionSampleRate), typeof ee.replaysOnErrorSampleRate == "number" && (te.errorSampleRate = ee.replaysOnErrorSampleRate), te) : (qo(() => {
    console.warn("SDK client is not available.");
  }), te);
}
function y2(Y) {
  return [...dY, ...Y.map((X) => X.toLowerCase())];
}
class pY extends mS {
  /**
   * Constructs a new instance of the Tria class.
   * @param apiUrl - The URL of the API.
   */
  constructor({
    baseUrl: X,
    walletType: ee,
    sentryDns: te,
    environment: ne,
    config: ie
  }) {
    super(ie, X, ee), this.apiUrl = X, this.walletService = new U2(this.apiUrl), this.userService = new j2(this.apiUrl), this.environment = ne || "mainnet", te && (console.log("sentryDns", te), zV({
      dsn: te,
      release: "tria-sdk/web",
      integrations: [new NG(), new z0()],
      tracesSampleRate: 1,
      tracePropagationTargets: [
        "localhost",
        /^https:\/\/yourserver\.io\/api/
      ],
      replaysSessionSampleRate: 0.1,
      replaysOnErrorSampleRate: 1
    }));
  }
  async getSigner(X, ee) {
    const te = this.chains[X];
    let ne, ie, oe;
    return this.walletType.embedded || ({ signer: ne } = await te.getSigner(), oe = await ne.getAddress(), ie = null), { signer: ne, chainInstance: te, triaName: ie, address: oe };
  }
  /**
   * @param triaName triaName
   * @param chainName chainName
   */
  async resolveTriaName(X, ee) {
    return (await this.walletService.resolveTriaName(
      { chainName: ee, lookUpTriaName: X },
      this.environment
    )).address;
  }
  /**
   * For message passing between windows and iframes
   * @param windowTo
   * @param message
   */
  postMessage(X, ee = !1) {
    var te, ne;
    try {
      if (console.log("postMessage", X), console.log({ sameOrigin: ee }), ee) {
        new BroadcastChannel("Tria Auth Channel").postMessage(JSON.stringify(X)), (te = window == null ? void 0 : window.opener) != null && te.postMessage && window.opener.postMessage(JSON.stringify(X), "*");
        return;
      }
      (ne = window == null ? void 0 : window.opener) != null && ne.postMessage ? window.opener.postMessage(JSON.stringify(X), "*") : window != null && window.parent && window.parent.postMessage(JSON.stringify(X), document.referrer);
    } catch (ie) {
      console.error(ie);
    }
  }
}
const yd = (Y) => bT(Y);
class bY extends pY {
  constructor({
    config: X,
    baseUrl: ee,
    walletType: te,
    selectedChainName: ne,
    environment: ie = "mainnet"
  }) {
    if (super({ config: X, baseUrl: ee, walletType: te, selectedChainName: ne, environment: ie }), ne && Kn(ne))
      this.selectedChainName = ne;
    else
      throw Error("Chain not supported yet!");
  }
  async signMessage(X, ee) {
    const te = this.selectedChainName || ee;
    try {
      const { signer: ne, chainInstance: ie } = await this.getSigner(te), oe = await ie.signMessage(ne, X);
      return oe ? { success: !0, data: oe } : { success: !1, message: "Error signing message" };
    } catch (ne) {
      return console.error(ne), { success: !1, message: "Error signing message!", error: ne };
    }
  }
  async send(X, ee) {
    var te;
    if (console.log({ payload: X }), X.amount <= 0)
      return { success: !1, message: "Invalid amount" };
    const ne = this.selectedChainName || ee, {
      signer: ie,
      chainInstance: oe,
      triaName: se,
      address: ae
    } = await this.getSigner(ne);
    if (console.log({ signer: ie }), Kn(ne)) {
      const { recipientTriaName: ue } = X;
      let le;
      !ue.includes("@tria") && yd(ue) ? le = ku(X.recipientTriaName) : le = await this.resolveTriaName(
        X.recipientTriaName,
        ne
      );
      const he = {
        signer: ie,
        // half shard // hex string
        recipientAddress: le,
        fromAddress: ae,
        amount: X.amount,
        tokenAddress: X.tokenAddress
      }, me = await oe.send(he);
      return me.success && (te = this.walletType) != null && te.embedded && this.userService.addUserActivity(
        se || X.fromTriaName,
        ue
      ), me;
    } else
      return { success: !1, message: "Chain not supported." };
  }
  async approve(X, ee) {
    const { amount: te, tokenAddress: ne, spender: ie } = X;
    if (te <= 0)
      return { success: !1, message: "Invalid amount" };
    const oe = this.selectedChainName || ee, {
      signer: se,
      chainInstance: ae,
      address: ue
    } = await this.getSigner(oe);
    return await (ae == null ? void 0 : ae.approve({
      signer: se,
      fromAddress: ue,
      tokenAddress: ne,
      amount: te,
      spender: ie
    }));
  }
  async swap(X, ee) {
    if (X.fromAmount <= 0)
      return { success: !1, message: "Invalid amount" };
    const te = this.selectedChainName || ee, {
      signer: ne,
      chainInstance: ie,
      address: oe
    } = await this.getSigner(te), se = {
      signer: ne,
      // privateKey shard
      fromAddress: oe,
      fromTokenAddress: X.fromTokenAddress,
      toTokenAddress: X.toTokenAddress,
      amount: X.fromAmount,
      slippage: X.slippage || 1
      // default 1%
    };
    return await (ie == null ? void 0 : ie.swap(se));
  }
  async sendNFT(X, ee, te) {
    if (ee.amount <= 0)
      return { success: !1, message: "Invalid amount" };
    const ne = this.selectedChainName || te, {
      signer: ie,
      chainInstance: oe,
      address: se
    } = await this.getSigner(ne);
    if (console.log({ signer: ie }), Kn(ne)) {
      let ae;
      return !X.includes("@tria") && yd(X) ? ae = ku(X) : ae = await this.resolveTriaName(X, ne), await (oe == null ? void 0 : oe.sendNFT(
        ie,
        se,
        ae,
        ee
      ));
    } else
      return { success: !1, message: "Chain not supported." };
  }
  /**
   * Bali beta specific
   *
   */
  async burnNFT(X, ee) {
    if (X.amount <= 0)
      return { success: !1, message: "Invalid amount" };
    const te = this.selectedChainName || ee, { signer: ne, chainInstance: ie } = await this.getSigner(te);
    return Kn(te) ? await (ie == null ? void 0 : ie.burnNFT(ne, X)) : { success: !1, message: "Chain not supported." };
  }
  /**
   * Interact with any external contract
   * @param contractDetails
   * @param chainName
   * @returns
   */
  async callContract(X, ee) {
    const te = this.selectedChainName || ee;
    let { enableTriaName: ne, args: ie } = X;
    if (ne)
      for (let ae = 0; ae < ie.length; ae++)
        z4(ie[ae]) && (ie[ae] = await this.resolveTriaName(ie[ae], te));
    const { signer: oe, chainInstance: se } = await this.getSigner(te);
    return console.log({ signer: oe }), Kn(te) ? await (se == null ? void 0 : se.callContract(X, oe)) : { success: !1, message: "Chain not supported." };
  }
  async readContract(X, ee) {
    const te = this.selectedChainName || ee, ne = this.chains[te];
    return Kn(te) ? await (ne == null ? void 0 : ne.readContract(X)) : { success: !1, message: "Chain not supported." };
  }
  /**
   * Decrypt data with private key.
   * @param encryptedData
   * @param chainName
   * @returns
   */
  async decrypt(X, ee) {
    const te = this.selectedChainName || ee, { signer: ne, chainInstance: ie, address: oe } = await this.getSigner(te);
    return Kn(te) ? await (ie == null ? void 0 : ie.decrypt(ne, X, oe)) : { success: !1, message: "Chain not supported." };
  }
  async encrypt(X, ee = "x25519-xsalsa20-poly1305", te) {
    const ne = this.selectedChainName || te, { signer: ie, chainInstance: oe, address: se } = await this.getSigner(ne);
    return Kn(ne) ? await (oe == null ? void 0 : oe.encrypt(ie, X, se, ee)) : { success: !1, message: "Chain not supported." };
  }
}
const PACKET_TYPES = /* @__PURE__ */ Object.create(null);
PACKET_TYPES.open = "0";
PACKET_TYPES.close = "1";
PACKET_TYPES.ping = "2";
PACKET_TYPES.pong = "3";
PACKET_TYPES.message = "4";
PACKET_TYPES.upgrade = "5";
PACKET_TYPES.noop = "6";
const PACKET_TYPES_REVERSE = /* @__PURE__ */ Object.create(null);
Object.keys(PACKET_TYPES).forEach((Y) => {
  PACKET_TYPES_REVERSE[PACKET_TYPES[Y]] = Y;
});
const ERROR_PACKET = { type: "error", data: "parser error" }, withNativeBlob$1 = typeof Blob == "function" || typeof Blob < "u" && Object.prototype.toString.call(Blob) === "[object BlobConstructor]", withNativeArrayBuffer$2 = typeof ArrayBuffer == "function", isView$1 = (Y) => typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(Y) : Y && Y.buffer instanceof ArrayBuffer, encodePacket = ({ type: Y, data: X }, ee, te) => withNativeBlob$1 && X instanceof Blob ? ee ? te(X) : encodeBlobAsBase64(X, te) : withNativeArrayBuffer$2 && (X instanceof ArrayBuffer || isView$1(X)) ? ee ? te(X) : encodeBlobAsBase64(new Blob([X]), te) : te(PACKET_TYPES[Y] + (X || "")), encodeBlobAsBase64 = (Y, X) => {
  const ee = new FileReader();
  return ee.onload = function() {
    const te = ee.result.split(",")[1];
    X("b" + (te || ""));
  }, ee.readAsDataURL(Y);
};
function toArray$1(Y) {
  return Y instanceof Uint8Array ? Y : Y instanceof ArrayBuffer ? new Uint8Array(Y) : new Uint8Array(Y.buffer, Y.byteOffset, Y.byteLength);
}
let TEXT_ENCODER;
function encodePacketToBinary(Y, X) {
  if (withNativeBlob$1 && Y.data instanceof Blob)
    return Y.data.arrayBuffer().then(toArray$1).then(X);
  if (withNativeArrayBuffer$2 && (Y.data instanceof ArrayBuffer || isView$1(Y.data)))
    return X(toArray$1(Y.data));
  encodePacket(Y, !1, (ee) => {
    TEXT_ENCODER || (TEXT_ENCODER = new TextEncoder()), X(TEXT_ENCODER.encode(ee));
  });
}
const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", lookup$2 = typeof Uint8Array > "u" ? [] : new Uint8Array(256);
for (let Y = 0; Y < chars.length; Y++)
  lookup$2[chars.charCodeAt(Y)] = Y;
const decode$4 = (Y) => {
  let X = Y.length * 0.75, ee = Y.length, te, ne = 0, ie, oe, se, ae;
  Y[Y.length - 1] === "=" && (X--, Y[Y.length - 2] === "=" && X--);
  const ue = new ArrayBuffer(X), le = new Uint8Array(ue);
  for (te = 0; te < ee; te += 4)
    ie = lookup$2[Y.charCodeAt(te)], oe = lookup$2[Y.charCodeAt(te + 1)], se = lookup$2[Y.charCodeAt(te + 2)], ae = lookup$2[Y.charCodeAt(te + 3)], le[ne++] = ie << 2 | oe >> 4, le[ne++] = (oe & 15) << 4 | se >> 2, le[ne++] = (se & 3) << 6 | ae & 63;
  return ue;
}, withNativeArrayBuffer$1 = typeof ArrayBuffer == "function", decodePacket = (Y, X) => {
  if (typeof Y != "string")
    return {
      type: "message",
      data: mapBinary(Y, X)
    };
  const ee = Y.charAt(0);
  return ee === "b" ? {
    type: "message",
    data: decodeBase64Packet(Y.substring(1), X)
  } : PACKET_TYPES_REVERSE[ee] ? Y.length > 1 ? {
    type: PACKET_TYPES_REVERSE[ee],
    data: Y.substring(1)
  } : {
    type: PACKET_TYPES_REVERSE[ee]
  } : ERROR_PACKET;
}, decodeBase64Packet = (Y, X) => {
  if (withNativeArrayBuffer$1) {
    const ee = decode$4(Y);
    return mapBinary(ee, X);
  } else
    return { base64: !0, data: Y };
}, mapBinary = (Y, X) => {
  switch (X) {
    case "blob":
      return Y instanceof Blob ? Y : new Blob([Y]);
    case "arraybuffer":
    default:
      return Y instanceof ArrayBuffer ? Y : Y.buffer;
  }
}, SEPARATOR = "", encodePayload = (Y, X) => {
  const ee = Y.length, te = new Array(ee);
  let ne = 0;
  Y.forEach((ie, oe) => {
    encodePacket(ie, !1, (se) => {
      te[oe] = se, ++ne === ee && X(te.join(SEPARATOR));
    });
  });
}, decodePayload = (Y, X) => {
  const ee = Y.split(SEPARATOR), te = [];
  for (let ne = 0; ne < ee.length; ne++) {
    const ie = decodePacket(ee[ne], X);
    if (te.push(ie), ie.type === "error")
      break;
  }
  return te;
};
function createPacketEncoderStream() {
  return new TransformStream({
    transform(Y, X) {
      encodePacketToBinary(Y, (ee) => {
        const te = ee.length;
        let ne;
        if (te < 126)
          ne = new Uint8Array(1), new DataView(ne.buffer).setUint8(0, te);
        else if (te < 65536) {
          ne = new Uint8Array(3);
          const ie = new DataView(ne.buffer);
          ie.setUint8(0, 126), ie.setUint16(1, te);
        } else {
          ne = new Uint8Array(9);
          const ie = new DataView(ne.buffer);
          ie.setUint8(0, 127), ie.setBigUint64(1, BigInt(te));
        }
        Y.data && typeof Y.data != "string" && (ne[0] |= 128), X.enqueue(ne), X.enqueue(ee);
      });
    }
  });
}
let TEXT_DECODER;
function totalLength(Y) {
  return Y.reduce((X, ee) => X + ee.length, 0);
}
function concatChunks(Y, X) {
  if (Y[0].length === X)
    return Y.shift();
  const ee = new Uint8Array(X);
  let te = 0;
  for (let ne = 0; ne < X; ne++)
    ee[ne] = Y[0][te++], te === Y[0].length && (Y.shift(), te = 0);
  return Y.length && te < Y[0].length && (Y[0] = Y[0].slice(te)), ee;
}
function createPacketDecoderStream(Y, X) {
  TEXT_DECODER || (TEXT_DECODER = new TextDecoder());
  const ee = [];
  let te = 0, ne = -1, ie = !1;
  return new TransformStream({
    transform(oe, se) {
      for (ee.push(oe); ; ) {
        if (te === 0) {
          if (totalLength(ee) < 1)
            break;
          const ae = concatChunks(ee, 1);
          ie = (ae[0] & 128) === 128, ne = ae[0] & 127, ne < 126 ? te = 3 : ne === 126 ? te = 1 : te = 2;
        } else if (te === 1) {
          if (totalLength(ee) < 2)
            break;
          const ae = concatChunks(ee, 2);
          ne = new DataView(ae.buffer, ae.byteOffset, ae.length).getUint16(0), te = 3;
        } else if (te === 2) {
          if (totalLength(ee) < 8)
            break;
          const ae = concatChunks(ee, 8), ue = new DataView(ae.buffer, ae.byteOffset, ae.length), le = ue.getUint32(0);
          if (le > Math.pow(2, 21) - 1) {
            se.enqueue(ERROR_PACKET);
            break;
          }
          ne = le * Math.pow(2, 32) + ue.getUint32(4), te = 3;
        } else {
          if (totalLength(ee) < ne)
            break;
          const ae = concatChunks(ee, ne);
          se.enqueue(decodePacket(ie ? ae : TEXT_DECODER.decode(ae), X)), te = 0;
        }
        if (ne === 0 || ne > Y) {
          se.enqueue(ERROR_PACKET);
          break;
        }
      }
    }
  });
}
const protocol$1 = 4;
function Emitter(Y) {
  if (Y)
    return mixin(Y);
}
function mixin(Y) {
  for (var X in Emitter.prototype)
    Y[X] = Emitter.prototype[X];
  return Y;
}
Emitter.prototype.on = Emitter.prototype.addEventListener = function(Y, X) {
  return this._callbacks = this._callbacks || {}, (this._callbacks["$" + Y] = this._callbacks["$" + Y] || []).push(X), this;
};
Emitter.prototype.once = function(Y, X) {
  function ee() {
    this.off(Y, ee), X.apply(this, arguments);
  }
  return ee.fn = X, this.on(Y, ee), this;
};
Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function(Y, X) {
  if (this._callbacks = this._callbacks || {}, arguments.length == 0)
    return this._callbacks = {}, this;
  var ee = this._callbacks["$" + Y];
  if (!ee)
    return this;
  if (arguments.length == 1)
    return delete this._callbacks["$" + Y], this;
  for (var te, ne = 0; ne < ee.length; ne++)
    if (te = ee[ne], te === X || te.fn === X) {
      ee.splice(ne, 1);
      break;
    }
  return ee.length === 0 && delete this._callbacks["$" + Y], this;
};
Emitter.prototype.emit = function(Y) {
  this._callbacks = this._callbacks || {};
  for (var X = new Array(arguments.length - 1), ee = this._callbacks["$" + Y], te = 1; te < arguments.length; te++)
    X[te - 1] = arguments[te];
  if (ee) {
    ee = ee.slice(0);
    for (var te = 0, ne = ee.length; te < ne; ++te)
      ee[te].apply(this, X);
  }
  return this;
};
Emitter.prototype.emitReserved = Emitter.prototype.emit;
Emitter.prototype.listeners = function(Y) {
  return this._callbacks = this._callbacks || {}, this._callbacks["$" + Y] || [];
};
Emitter.prototype.hasListeners = function(Y) {
  return !!this.listeners(Y).length;
};
const globalThisShim = typeof self < "u" ? self : typeof window < "u" ? window : Function("return this")();
function pick(Y, ...X) {
  return X.reduce((ee, te) => (Y.hasOwnProperty(te) && (ee[te] = Y[te]), ee), {});
}
const NATIVE_SET_TIMEOUT = globalThisShim.setTimeout, NATIVE_CLEAR_TIMEOUT = globalThisShim.clearTimeout;
function installTimerFunctions(Y, X) {
  X.useNativeTimers ? (Y.setTimeoutFn = NATIVE_SET_TIMEOUT.bind(globalThisShim), Y.clearTimeoutFn = NATIVE_CLEAR_TIMEOUT.bind(globalThisShim)) : (Y.setTimeoutFn = globalThisShim.setTimeout.bind(globalThisShim), Y.clearTimeoutFn = globalThisShim.clearTimeout.bind(globalThisShim));
}
const BASE64_OVERHEAD = 1.33;
function byteLength$1(Y) {
  return typeof Y == "string" ? utf8Length(Y) : Math.ceil((Y.byteLength || Y.size) * BASE64_OVERHEAD);
}
function utf8Length(Y) {
  let X = 0, ee = 0;
  for (let te = 0, ne = Y.length; te < ne; te++)
    X = Y.charCodeAt(te), X < 128 ? ee += 1 : X < 2048 ? ee += 2 : X < 55296 || X >= 57344 ? ee += 3 : (te++, ee += 4);
  return ee;
}
function encode$4(Y) {
  let X = "";
  for (let ee in Y)
    Y.hasOwnProperty(ee) && (X.length && (X += "&"), X += encodeURIComponent(ee) + "=" + encodeURIComponent(Y[ee]));
  return X;
}
function decode$3(Y) {
  let X = {}, ee = Y.split("&");
  for (let te = 0, ne = ee.length; te < ne; te++) {
    let ie = ee[te].split("=");
    X[decodeURIComponent(ie[0])] = decodeURIComponent(ie[1]);
  }
  return X;
}
class TransportError extends Error {
  constructor(X, ee, te) {
    super(X), this.description = ee, this.context = te, this.type = "TransportError";
  }
}
class Transport extends Emitter {
  /**
   * Transport abstract constructor.
   *
   * @param {Object} opts - options
   * @protected
   */
  constructor(X) {
    super(), this.writable = !1, installTimerFunctions(this, X), this.opts = X, this.query = X.query, this.socket = X.socket;
  }
  /**
   * Emits an error.
   *
   * @param {String} reason
   * @param description
   * @param context - the error context
   * @return {Transport} for chaining
   * @protected
   */
  onError(X, ee, te) {
    return super.emitReserved("error", new TransportError(X, ee, te)), this;
  }
  /**
   * Opens the transport.
   */
  open() {
    return this.readyState = "opening", this.doOpen(), this;
  }
  /**
   * Closes the transport.
   */
  close() {
    return (this.readyState === "opening" || this.readyState === "open") && (this.doClose(), this.onClose()), this;
  }
  /**
   * Sends multiple packets.
   *
   * @param {Array} packets
   */
  send(X) {
    this.readyState === "open" && this.write(X);
  }
  /**
   * Called upon open
   *
   * @protected
   */
  onOpen() {
    this.readyState = "open", this.writable = !0, super.emitReserved("open");
  }
  /**
   * Called with data.
   *
   * @param {String} data
   * @protected
   */
  onData(X) {
    const ee = decodePacket(X, this.socket.binaryType);
    this.onPacket(ee);
  }
  /**
   * Called with a decoded packet.
   *
   * @protected
   */
  onPacket(X) {
    super.emitReserved("packet", X);
  }
  /**
   * Called upon close.
   *
   * @protected
   */
  onClose(X) {
    this.readyState = "closed", super.emitReserved("close", X);
  }
  /**
   * Pauses the transport, in order not to lose packets during an upgrade.
   *
   * @param onPause
   */
  pause(X) {
  }
  createUri(X, ee = {}) {
    return X + "://" + this._hostname() + this._port() + this.opts.path + this._query(ee);
  }
  _hostname() {
    const X = this.opts.hostname;
    return X.indexOf(":") === -1 ? X : "[" + X + "]";
  }
  _port() {
    return this.opts.port && (this.opts.secure && +(this.opts.port !== 443) || !this.opts.secure && Number(this.opts.port) !== 80) ? ":" + this.opts.port : "";
  }
  _query(X) {
    const ee = encode$4(X);
    return ee.length ? "?" + ee : "";
  }
}
const alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split(""), length = 64, map = {};
let seed = 0, i$2 = 0, prev;
function encode$3(Y) {
  let X = "";
  do
    X = alphabet[Y % length] + X, Y = Math.floor(Y / length);
  while (Y > 0);
  return X;
}
function yeast() {
  const Y = encode$3(+/* @__PURE__ */ new Date());
  return Y !== prev ? (seed = 0, prev = Y) : Y + "." + encode$3(seed++);
}
for (; i$2 < length; i$2++)
  map[alphabet[i$2]] = i$2;
let value = !1;
try {
  value = typeof XMLHttpRequest < "u" && "withCredentials" in new XMLHttpRequest();
} catch {
}
const hasCORS = value;
function XHR(Y) {
  const X = Y.xdomain;
  try {
    if (typeof XMLHttpRequest < "u" && (!X || hasCORS))
      return new XMLHttpRequest();
  } catch {
  }
  if (!X)
    try {
      return new globalThisShim[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP");
    } catch {
    }
}
function empty() {
}
const hasXHR2 = function() {
  return new XHR({
    xdomain: !1
  }).responseType != null;
}();
class Polling extends Transport {
  /**
   * XHR Polling constructor.
   *
   * @param {Object} opts
   * @package
   */
  constructor(X) {
    if (super(X), this.polling = !1, typeof location < "u") {
      const te = location.protocol === "https:";
      let ne = location.port;
      ne || (ne = te ? "443" : "80"), this.xd = typeof location < "u" && X.hostname !== location.hostname || ne !== X.port;
    }
    const ee = X && X.forceBase64;
    this.supportsBinary = hasXHR2 && !ee, this.opts.withCredentials && (this.cookieJar = void 0);
  }
  get name() {
    return "polling";
  }
  /**
   * Opens the socket (triggers polling). We write a PING message to determine
   * when the transport is open.
   *
   * @protected
   */
  doOpen() {
    this.poll();
  }
  /**
   * Pauses polling.
   *
   * @param {Function} onPause - callback upon buffers are flushed and transport is paused
   * @package
   */
  pause(X) {
    this.readyState = "pausing";
    const ee = () => {
      this.readyState = "paused", X();
    };
    if (this.polling || !this.writable) {
      let te = 0;
      this.polling && (te++, this.once("pollComplete", function() {
        --te || ee();
      })), this.writable || (te++, this.once("drain", function() {
        --te || ee();
      }));
    } else
      ee();
  }
  /**
   * Starts polling cycle.
   *
   * @private
   */
  poll() {
    this.polling = !0, this.doPoll(), this.emitReserved("poll");
  }
  /**
   * Overloads onData to detect payloads.
   *
   * @protected
   */
  onData(X) {
    const ee = (te) => {
      if (this.readyState === "opening" && te.type === "open" && this.onOpen(), te.type === "close")
        return this.onClose({ description: "transport closed by the server" }), !1;
      this.onPacket(te);
    };
    decodePayload(X, this.socket.binaryType).forEach(ee), this.readyState !== "closed" && (this.polling = !1, this.emitReserved("pollComplete"), this.readyState === "open" && this.poll());
  }
  /**
   * For polling, send a close packet.
   *
   * @protected
   */
  doClose() {
    const X = () => {
      this.write([{ type: "close" }]);
    };
    this.readyState === "open" ? X() : this.once("open", X);
  }
  /**
   * Writes a packets payload.
   *
   * @param {Array} packets - data packets
   * @protected
   */
  write(X) {
    this.writable = !1, encodePayload(X, (ee) => {
      this.doWrite(ee, () => {
        this.writable = !0, this.emitReserved("drain");
      });
    });
  }
  /**
   * Generates uri for connection.
   *
   * @private
   */
  uri() {
    const X = this.opts.secure ? "https" : "http", ee = this.query || {};
    return this.opts.timestampRequests !== !1 && (ee[this.opts.timestampParam] = yeast()), !this.supportsBinary && !ee.sid && (ee.b64 = 1), this.createUri(X, ee);
  }
  /**
   * Creates a request.
   *
   * @param {String} method
   * @private
   */
  request(X = {}) {
    return Object.assign(X, { xd: this.xd, cookieJar: this.cookieJar }, this.opts), new Request$1(this.uri(), X);
  }
  /**
   * Sends data.
   *
   * @param {String} data to send.
   * @param {Function} called upon flush.
   * @private
   */
  doWrite(X, ee) {
    const te = this.request({
      method: "POST",
      data: X
    });
    te.on("success", ee), te.on("error", (ne, ie) => {
      this.onError("xhr post error", ne, ie);
    });
  }
  /**
   * Starts a poll cycle.
   *
   * @private
   */
  doPoll() {
    const X = this.request();
    X.on("data", this.onData.bind(this)), X.on("error", (ee, te) => {
      this.onError("xhr poll error", ee, te);
    }), this.pollXhr = X;
  }
}
let Request$1 = class QX extends Emitter {
  /**
   * Request constructor
   *
   * @param {Object} options
   * @package
   */
  constructor(X, ee) {
    super(), installTimerFunctions(this, ee), this.opts = ee, this.method = ee.method || "GET", this.uri = X, this.data = ee.data !== void 0 ? ee.data : null, this.create();
  }
  /**
   * Creates the XHR object and sends the request.
   *
   * @private
   */
  create() {
    var X;
    const ee = pick(this.opts, "agent", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "autoUnref");
    ee.xdomain = !!this.opts.xd;
    const te = this.xhr = new XHR(ee);
    try {
      te.open(this.method, this.uri, !0);
      try {
        if (this.opts.extraHeaders) {
          te.setDisableHeaderCheck && te.setDisableHeaderCheck(!0);
          for (let ne in this.opts.extraHeaders)
            this.opts.extraHeaders.hasOwnProperty(ne) && te.setRequestHeader(ne, this.opts.extraHeaders[ne]);
        }
      } catch {
      }
      if (this.method === "POST")
        try {
          te.setRequestHeader("Content-type", "text/plain;charset=UTF-8");
        } catch {
        }
      try {
        te.setRequestHeader("Accept", "*/*");
      } catch {
      }
      (X = this.opts.cookieJar) === null || X === void 0 || X.addCookies(te), "withCredentials" in te && (te.withCredentials = this.opts.withCredentials), this.opts.requestTimeout && (te.timeout = this.opts.requestTimeout), te.onreadystatechange = () => {
        var ne;
        te.readyState === 3 && ((ne = this.opts.cookieJar) === null || ne === void 0 || ne.parseCookies(te)), te.readyState === 4 && (te.status === 200 || te.status === 1223 ? this.onLoad() : this.setTimeoutFn(() => {
          this.onError(typeof te.status == "number" ? te.status : 0);
        }, 0));
      }, te.send(this.data);
    } catch (ne) {
      this.setTimeoutFn(() => {
        this.onError(ne);
      }, 0);
      return;
    }
    typeof document < "u" && (this.index = QX.requestsCount++, QX.requests[this.index] = this);
  }
  /**
   * Called upon error.
   *
   * @private
   */
  onError(X) {
    this.emitReserved("error", X, this.xhr), this.cleanup(!0);
  }
  /**
   * Cleans up house.
   *
   * @private
   */
  cleanup(X) {
    if (!(typeof this.xhr > "u" || this.xhr === null)) {
      if (this.xhr.onreadystatechange = empty, X)
        try {
          this.xhr.abort();
        } catch {
        }
      typeof document < "u" && delete QX.requests[this.index], this.xhr = null;
    }
  }
  /**
   * Called upon load.
   *
   * @private
   */
  onLoad() {
    const X = this.xhr.responseText;
    X !== null && (this.emitReserved("data", X), this.emitReserved("success"), this.cleanup());
  }
  /**
   * Aborts the request.
   *
   * @package
   */
  abort() {
    this.cleanup();
  }
};
Request$1.requestsCount = 0;
Request$1.requests = {};
if (typeof document < "u") {
  if (typeof attachEvent == "function")
    attachEvent("onunload", unloadHandler);
  else if (typeof addEventListener == "function") {
    const Y = "onpagehide" in globalThisShim ? "pagehide" : "unload";
    addEventListener(Y, unloadHandler, !1);
  }
}
function unloadHandler() {
  for (let Y in Request$1.requests)
    Request$1.requests.hasOwnProperty(Y) && Request$1.requests[Y].abort();
}
const nextTick = typeof Promise == "function" && typeof Promise.resolve == "function" ? (Y) => Promise.resolve().then(Y) : (Y, X) => X(Y, 0), WebSocket = globalThisShim.WebSocket || globalThisShim.MozWebSocket, usingBrowserWebSocket = !0, defaultBinaryType = "arraybuffer", isReactNative = typeof navigator < "u" && typeof navigator.product == "string" && navigator.product.toLowerCase() === "reactnative";
class WS extends Transport {
  /**
   * WebSocket transport constructor.
   *
   * @param {Object} opts - connection options
   * @protected
   */
  constructor(X) {
    super(X), this.supportsBinary = !X.forceBase64;
  }
  get name() {
    return "websocket";
  }
  doOpen() {
    if (!this.check())
      return;
    const X = this.uri(), ee = this.opts.protocols, te = isReactNative ? {} : pick(this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity");
    this.opts.extraHeaders && (te.headers = this.opts.extraHeaders);
    try {
      this.ws = usingBrowserWebSocket && !isReactNative ? ee ? new WebSocket(X, ee) : new WebSocket(X) : new WebSocket(X, ee, te);
    } catch (ne) {
      return this.emitReserved("error", ne);
    }
    this.ws.binaryType = this.socket.binaryType, this.addEventListeners();
  }
  /**
   * Adds event listeners to the socket
   *
   * @private
   */
  addEventListeners() {
    this.ws.onopen = () => {
      this.opts.autoUnref && this.ws._socket.unref(), this.onOpen();
    }, this.ws.onclose = (X) => this.onClose({
      description: "websocket connection closed",
      context: X
    }), this.ws.onmessage = (X) => this.onData(X.data), this.ws.onerror = (X) => this.onError("websocket error", X);
  }
  write(X) {
    this.writable = !1;
    for (let ee = 0; ee < X.length; ee++) {
      const te = X[ee], ne = ee === X.length - 1;
      encodePacket(te, this.supportsBinary, (ie) => {
        try {
          usingBrowserWebSocket && this.ws.send(ie);
        } catch {
        }
        ne && nextTick(() => {
          this.writable = !0, this.emitReserved("drain");
        }, this.setTimeoutFn);
      });
    }
  }
  doClose() {
    typeof this.ws < "u" && (this.ws.close(), this.ws = null);
  }
  /**
   * Generates uri for connection.
   *
   * @private
   */
  uri() {
    const X = this.opts.secure ? "wss" : "ws", ee = this.query || {};
    return this.opts.timestampRequests && (ee[this.opts.timestampParam] = yeast()), this.supportsBinary || (ee.b64 = 1), this.createUri(X, ee);
  }
  /**
   * Feature detection for WebSocket.
   *
   * @return {Boolean} whether this transport is available.
   * @private
   */
  check() {
    return !!WebSocket;
  }
}
class WT extends Transport {
  get name() {
    return "webtransport";
  }
  doOpen() {
    typeof WebTransport == "function" && (this.transport = new WebTransport(this.createUri("https"), this.opts.transportOptions[this.name]), this.transport.closed.then(() => {
      this.onClose();
    }).catch((X) => {
      this.onError("webtransport error", X);
    }), this.transport.ready.then(() => {
      this.transport.createBidirectionalStream().then((X) => {
        const ee = createPacketDecoderStream(Number.MAX_SAFE_INTEGER, this.socket.binaryType), te = X.readable.pipeThrough(ee).getReader(), ne = createPacketEncoderStream();
        ne.readable.pipeTo(X.writable), this.writer = ne.writable.getWriter();
        const ie = () => {
          te.read().then(({ done: se, value: ae }) => {
            se || (this.onPacket(ae), ie());
          }).catch((se) => {
          });
        };
        ie();
        const oe = { type: "open" };
        this.query.sid && (oe.data = `{"sid":"${this.query.sid}"}`), this.writer.write(oe).then(() => this.onOpen());
      });
    }));
  }
  write(X) {
    this.writable = !1;
    for (let ee = 0; ee < X.length; ee++) {
      const te = X[ee], ne = ee === X.length - 1;
      this.writer.write(te).then(() => {
        ne && nextTick(() => {
          this.writable = !0, this.emitReserved("drain");
        }, this.setTimeoutFn);
      });
    }
  }
  doClose() {
    var X;
    (X = this.transport) === null || X === void 0 || X.close();
  }
}
const transports = {
  websocket: WS,
  webtransport: WT,
  polling: Polling
}, re = /^(?:(?![^:@\/?#]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@\/?#]*)(?::([^:@\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/, parts = [
  "source",
  "protocol",
  "authority",
  "userInfo",
  "user",
  "password",
  "host",
  "port",
  "relative",
  "path",
  "directory",
  "file",
  "query",
  "anchor"
];
function parse$2(Y) {
  if (Y.length > 2e3)
    throw "URI too long";
  const X = Y, ee = Y.indexOf("["), te = Y.indexOf("]");
  ee != -1 && te != -1 && (Y = Y.substring(0, ee) + Y.substring(ee, te).replace(/:/g, ";") + Y.substring(te, Y.length));
  let ne = re.exec(Y || ""), ie = {}, oe = 14;
  for (; oe--; )
    ie[parts[oe]] = ne[oe] || "";
  return ee != -1 && te != -1 && (ie.source = X, ie.host = ie.host.substring(1, ie.host.length - 1).replace(/;/g, ":"), ie.authority = ie.authority.replace("[", "").replace("]", "").replace(/;/g, ":"), ie.ipv6uri = !0), ie.pathNames = pathNames(ie, ie.path), ie.queryKey = queryKey(ie, ie.query), ie;
}
function pathNames(Y, X) {
  const ee = /\/{2,9}/g, te = X.replace(ee, "/").split("/");
  return (X.slice(0, 1) == "/" || X.length === 0) && te.splice(0, 1), X.slice(-1) == "/" && te.splice(te.length - 1, 1), te;
}
function queryKey(Y, X) {
  const ee = {};
  return X.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function(te, ne, ie) {
    ne && (ee[ne] = ie);
  }), ee;
}
let Socket$1 = class YX extends Emitter {
  /**
   * Socket constructor.
   *
   * @param {String|Object} uri - uri or options
   * @param {Object} opts - options
   */
  constructor(X, ee = {}) {
    super(), this.binaryType = defaultBinaryType, this.writeBuffer = [], X && typeof X == "object" && (ee = X, X = null), X ? (X = parse$2(X), ee.hostname = X.host, ee.secure = X.protocol === "https" || X.protocol === "wss", ee.port = X.port, X.query && (ee.query = X.query)) : ee.host && (ee.hostname = parse$2(ee.host).host), installTimerFunctions(this, ee), this.secure = ee.secure != null ? ee.secure : typeof location < "u" && location.protocol === "https:", ee.hostname && !ee.port && (ee.port = this.secure ? "443" : "80"), this.hostname = ee.hostname || (typeof location < "u" ? location.hostname : "localhost"), this.port = ee.port || (typeof location < "u" && location.port ? location.port : this.secure ? "443" : "80"), this.transports = ee.transports || [
      "polling",
      "websocket",
      "webtransport"
    ], this.writeBuffer = [], this.prevBufferLen = 0, this.opts = Object.assign({
      path: "/engine.io",
      agent: !1,
      withCredentials: !1,
      upgrade: !0,
      timestampParam: "t",
      rememberUpgrade: !1,
      addTrailingSlash: !0,
      rejectUnauthorized: !0,
      perMessageDeflate: {
        threshold: 1024
      },
      transportOptions: {},
      closeOnBeforeunload: !1
    }, ee), this.opts.path = this.opts.path.replace(/\/$/, "") + (this.opts.addTrailingSlash ? "/" : ""), typeof this.opts.query == "string" && (this.opts.query = decode$3(this.opts.query)), this.id = null, this.upgrades = null, this.pingInterval = null, this.pingTimeout = null, this.pingTimeoutTimer = null, typeof addEventListener == "function" && (this.opts.closeOnBeforeunload && (this.beforeunloadEventListener = () => {
      this.transport && (this.transport.removeAllListeners(), this.transport.close());
    }, addEventListener("beforeunload", this.beforeunloadEventListener, !1)), this.hostname !== "localhost" && (this.offlineEventListener = () => {
      this.onClose("transport close", {
        description: "network connection lost"
      });
    }, addEventListener("offline", this.offlineEventListener, !1))), this.open();
  }
  /**
   * Creates transport of the given type.
   *
   * @param {String} name - transport name
   * @return {Transport}
   * @private
   */
  createTransport(X) {
    const ee = Object.assign({}, this.opts.query);
    ee.EIO = protocol$1, ee.transport = X, this.id && (ee.sid = this.id);
    const te = Object.assign({}, this.opts, {
      query: ee,
      socket: this,
      hostname: this.hostname,
      secure: this.secure,
      port: this.port
    }, this.opts.transportOptions[X]);
    return new transports[X](te);
  }
  /**
   * Initializes transport to use and starts probe.
   *
   * @private
   */
  open() {
    let X;
    if (this.opts.rememberUpgrade && YX.priorWebsocketSuccess && this.transports.indexOf("websocket") !== -1)
      X = "websocket";
    else if (this.transports.length === 0) {
      this.setTimeoutFn(() => {
        this.emitReserved("error", "No transports available");
      }, 0);
      return;
    } else
      X = this.transports[0];
    this.readyState = "opening";
    try {
      X = this.createTransport(X);
    } catch {
      this.transports.shift(), this.open();
      return;
    }
    X.open(), this.setTransport(X);
  }
  /**
   * Sets the current transport. Disables the existing one (if any).
   *
   * @private
   */
  setTransport(X) {
    this.transport && this.transport.removeAllListeners(), this.transport = X, X.on("drain", this.onDrain.bind(this)).on("packet", this.onPacket.bind(this)).on("error", this.onError.bind(this)).on("close", (ee) => this.onClose("transport close", ee));
  }
  /**
   * Probes a transport.
   *
   * @param {String} name - transport name
   * @private
   */
  probe(X) {
    let ee = this.createTransport(X), te = !1;
    YX.priorWebsocketSuccess = !1;
    const ne = () => {
      te || (ee.send([{ type: "ping", data: "probe" }]), ee.once("packet", (he) => {
        if (!te)
          if (he.type === "pong" && he.data === "probe") {
            if (this.upgrading = !0, this.emitReserved("upgrading", ee), !ee)
              return;
            YX.priorWebsocketSuccess = ee.name === "websocket", this.transport.pause(() => {
              te || this.readyState !== "closed" && (le(), this.setTransport(ee), ee.send([{ type: "upgrade" }]), this.emitReserved("upgrade", ee), ee = null, this.upgrading = !1, this.flush());
            });
          } else {
            const me = new Error("probe error");
            me.transport = ee.name, this.emitReserved("upgradeError", me);
          }
      }));
    };
    function ie() {
      te || (te = !0, le(), ee.close(), ee = null);
    }
    const oe = (he) => {
      const me = new Error("probe error: " + he);
      me.transport = ee.name, ie(), this.emitReserved("upgradeError", me);
    };
    function se() {
      oe("transport closed");
    }
    function ae() {
      oe("socket closed");
    }
    function ue(he) {
      ee && he.name !== ee.name && ie();
    }
    const le = () => {
      ee.removeListener("open", ne), ee.removeListener("error", oe), ee.removeListener("close", se), this.off("close", ae), this.off("upgrading", ue);
    };
    ee.once("open", ne), ee.once("error", oe), ee.once("close", se), this.once("close", ae), this.once("upgrading", ue), this.upgrades.indexOf("webtransport") !== -1 && X !== "webtransport" ? this.setTimeoutFn(() => {
      te || ee.open();
    }, 200) : ee.open();
  }
  /**
   * Called when connection is deemed open.
   *
   * @private
   */
  onOpen() {
    if (this.readyState = "open", YX.priorWebsocketSuccess = this.transport.name === "websocket", this.emitReserved("open"), this.flush(), this.readyState === "open" && this.opts.upgrade) {
      let X = 0;
      const ee = this.upgrades.length;
      for (; X < ee; X++)
        this.probe(this.upgrades[X]);
    }
  }
  /**
   * Handles a packet.
   *
   * @private
   */
  onPacket(X) {
    if (this.readyState === "opening" || this.readyState === "open" || this.readyState === "closing")
      switch (this.emitReserved("packet", X), this.emitReserved("heartbeat"), this.resetPingTimeout(), X.type) {
        case "open":
          this.onHandshake(JSON.parse(X.data));
          break;
        case "ping":
          this.sendPacket("pong"), this.emitReserved("ping"), this.emitReserved("pong");
          break;
        case "error":
          const ee = new Error("server error");
          ee.code = X.data, this.onError(ee);
          break;
        case "message":
          this.emitReserved("data", X.data), this.emitReserved("message", X.data);
          break;
      }
  }
  /**
   * Called upon handshake completion.
   *
   * @param {Object} data - handshake obj
   * @private
   */
  onHandshake(X) {
    this.emitReserved("handshake", X), this.id = X.sid, this.transport.query.sid = X.sid, this.upgrades = this.filterUpgrades(X.upgrades), this.pingInterval = X.pingInterval, this.pingTimeout = X.pingTimeout, this.maxPayload = X.maxPayload, this.onOpen(), this.readyState !== "closed" && this.resetPingTimeout();
  }
  /**
   * Sets and resets ping timeout timer based on server pings.
   *
   * @private
   */
  resetPingTimeout() {
    this.clearTimeoutFn(this.pingTimeoutTimer), this.pingTimeoutTimer = this.setTimeoutFn(() => {
      this.onClose("ping timeout");
    }, this.pingInterval + this.pingTimeout), this.opts.autoUnref && this.pingTimeoutTimer.unref();
  }
  /**
   * Called on `drain` event
   *
   * @private
   */
  onDrain() {
    this.writeBuffer.splice(0, this.prevBufferLen), this.prevBufferLen = 0, this.writeBuffer.length === 0 ? this.emitReserved("drain") : this.flush();
  }
  /**
   * Flush write buffers.
   *
   * @private
   */
  flush() {
    if (this.readyState !== "closed" && this.transport.writable && !this.upgrading && this.writeBuffer.length) {
      const X = this.getWritablePackets();
      this.transport.send(X), this.prevBufferLen = X.length, this.emitReserved("flush");
    }
  }
  /**
   * Ensure the encoded size of the writeBuffer is below the maxPayload value sent by the server (only for HTTP
   * long-polling)
   *
   * @private
   */
  getWritablePackets() {
    if (!(this.maxPayload && this.transport.name === "polling" && this.writeBuffer.length > 1))
      return this.writeBuffer;
    let X = 1;
    for (let ee = 0; ee < this.writeBuffer.length; ee++) {
      const te = this.writeBuffer[ee].data;
      if (te && (X += byteLength$1(te)), ee > 0 && X > this.maxPayload)
        return this.writeBuffer.slice(0, ee);
      X += 2;
    }
    return this.writeBuffer;
  }
  /**
   * Sends a message.
   *
   * @param {String} msg - message.
   * @param {Object} options.
   * @param {Function} callback function.
   * @return {Socket} for chaining.
   */
  write(X, ee, te) {
    return this.sendPacket("message", X, ee, te), this;
  }
  send(X, ee, te) {
    return this.sendPacket("message", X, ee, te), this;
  }
  /**
   * Sends a packet.
   *
   * @param {String} type: packet type.
   * @param {String} data.
   * @param {Object} options.
   * @param {Function} fn - callback function.
   * @private
   */
  sendPacket(X, ee, te, ne) {
    if (typeof ee == "function" && (ne = ee, ee = void 0), typeof te == "function" && (ne = te, te = null), this.readyState === "closing" || this.readyState === "closed")
      return;
    te = te || {}, te.compress = te.compress !== !1;
    const ie = {
      type: X,
      data: ee,
      options: te
    };
    this.emitReserved("packetCreate", ie), this.writeBuffer.push(ie), ne && this.once("flush", ne), this.flush();
  }
  /**
   * Closes the connection.
   */
  close() {
    const X = () => {
      this.onClose("forced close"), this.transport.close();
    }, ee = () => {
      this.off("upgrade", ee), this.off("upgradeError", ee), X();
    }, te = () => {
      this.once("upgrade", ee), this.once("upgradeError", ee);
    };
    return (this.readyState === "opening" || this.readyState === "open") && (this.readyState = "closing", this.writeBuffer.length ? this.once("drain", () => {
      this.upgrading ? te() : X();
    }) : this.upgrading ? te() : X()), this;
  }
  /**
   * Called upon transport error
   *
   * @private
   */
  onError(X) {
    YX.priorWebsocketSuccess = !1, this.emitReserved("error", X), this.onClose("transport error", X);
  }
  /**
   * Called upon transport close.
   *
   * @private
   */
  onClose(X, ee) {
    (this.readyState === "opening" || this.readyState === "open" || this.readyState === "closing") && (this.clearTimeoutFn(this.pingTimeoutTimer), this.transport.removeAllListeners("close"), this.transport.close(), this.transport.removeAllListeners(), typeof removeEventListener == "function" && (removeEventListener("beforeunload", this.beforeunloadEventListener, !1), removeEventListener("offline", this.offlineEventListener, !1)), this.readyState = "closed", this.id = null, this.emitReserved("close", X, ee), this.writeBuffer = [], this.prevBufferLen = 0);
  }
  /**
   * Filters upgrades, returning only those matching client transports.
   *
   * @param {Array} upgrades - server upgrades
   * @private
   */
  filterUpgrades(X) {
    const ee = [];
    let te = 0;
    const ne = X.length;
    for (; te < ne; te++)
      ~this.transports.indexOf(X[te]) && ee.push(X[te]);
    return ee;
  }
};
Socket$1.protocol = protocol$1;
function url(Y, X = "", ee) {
  let te = Y;
  ee = ee || typeof location < "u" && location, Y == null && (Y = ee.protocol + "//" + ee.host), typeof Y == "string" && (Y.charAt(0) === "/" && (Y.charAt(1) === "/" ? Y = ee.protocol + Y : Y = ee.host + Y), /^(https?|wss?):\/\//.test(Y) || (typeof ee < "u" ? Y = ee.protocol + "//" + Y : Y = "https://" + Y), te = parse$2(Y)), te.port || (/^(http|ws)$/.test(te.protocol) ? te.port = "80" : /^(http|ws)s$/.test(te.protocol) && (te.port = "443")), te.path = te.path || "/";
  const ne = te.host.indexOf(":") !== -1 ? "[" + te.host + "]" : te.host;
  return te.id = te.protocol + "://" + ne + ":" + te.port + X, te.href = te.protocol + "://" + ne + (ee && ee.port === te.port ? "" : ":" + te.port), te;
}
const withNativeArrayBuffer = typeof ArrayBuffer == "function", isView = (Y) => typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(Y) : Y.buffer instanceof ArrayBuffer, toString = Object.prototype.toString, withNativeBlob = typeof Blob == "function" || typeof Blob < "u" && toString.call(Blob) === "[object BlobConstructor]", withNativeFile = typeof File == "function" || typeof File < "u" && toString.call(File) === "[object FileConstructor]";
function isBinary(Y) {
  return withNativeArrayBuffer && (Y instanceof ArrayBuffer || isView(Y)) || withNativeBlob && Y instanceof Blob || withNativeFile && Y instanceof File;
}
function hasBinary(Y, X) {
  if (!Y || typeof Y != "object")
    return !1;
  if (Array.isArray(Y)) {
    for (let ee = 0, te = Y.length; ee < te; ee++)
      if (hasBinary(Y[ee]))
        return !0;
    return !1;
  }
  if (isBinary(Y))
    return !0;
  if (Y.toJSON && typeof Y.toJSON == "function" && arguments.length === 1)
    return hasBinary(Y.toJSON(), !0);
  for (const ee in Y)
    if (Object.prototype.hasOwnProperty.call(Y, ee) && hasBinary(Y[ee]))
      return !0;
  return !1;
}
function deconstructPacket(Y) {
  const X = [], ee = Y.data, te = Y;
  return te.data = _deconstructPacket(ee, X), te.attachments = X.length, { packet: te, buffers: X };
}
function _deconstructPacket(Y, X) {
  if (!Y)
    return Y;
  if (isBinary(Y)) {
    const ee = { _placeholder: !0, num: X.length };
    return X.push(Y), ee;
  } else if (Array.isArray(Y)) {
    const ee = new Array(Y.length);
    for (let te = 0; te < Y.length; te++)
      ee[te] = _deconstructPacket(Y[te], X);
    return ee;
  } else if (typeof Y == "object" && !(Y instanceof Date)) {
    const ee = {};
    for (const te in Y)
      Object.prototype.hasOwnProperty.call(Y, te) && (ee[te] = _deconstructPacket(Y[te], X));
    return ee;
  }
  return Y;
}
function reconstructPacket(Y, X) {
  return Y.data = _reconstructPacket(Y.data, X), delete Y.attachments, Y;
}
function _reconstructPacket(Y, X) {
  if (!Y)
    return Y;
  if (Y && Y._placeholder === !0) {
    if (typeof Y.num == "number" && Y.num >= 0 && Y.num < X.length)
      return X[Y.num];
    throw new Error("illegal attachments");
  } else if (Array.isArray(Y))
    for (let ee = 0; ee < Y.length; ee++)
      Y[ee] = _reconstructPacket(Y[ee], X);
  else if (typeof Y == "object")
    for (const ee in Y)
      Object.prototype.hasOwnProperty.call(Y, ee) && (Y[ee] = _reconstructPacket(Y[ee], X));
  return Y;
}
const RESERVED_EVENTS$1 = [
  "connect",
  "connect_error",
  "disconnect",
  "disconnecting",
  "newListener",
  "removeListener"
  // used by the Node.js EventEmitter
], protocol = 5;
var PacketType;
(function(Y) {
  Y[Y.CONNECT = 0] = "CONNECT", Y[Y.DISCONNECT = 1] = "DISCONNECT", Y[Y.EVENT = 2] = "EVENT", Y[Y.ACK = 3] = "ACK", Y[Y.CONNECT_ERROR = 4] = "CONNECT_ERROR", Y[Y.BINARY_EVENT = 5] = "BINARY_EVENT", Y[Y.BINARY_ACK = 6] = "BINARY_ACK";
})(PacketType || (PacketType = {}));
class Encoder {
  /**
   * Encoder constructor
   *
   * @param {function} replacer - custom replacer to pass down to JSON.parse
   */
  constructor(X) {
    this.replacer = X;
  }
  /**
   * Encode a packet as a single string if non-binary, or as a
   * buffer sequence, depending on packet type.
   *
   * @param {Object} obj - packet object
   */
  encode(X) {
    return (X.type === PacketType.EVENT || X.type === PacketType.ACK) && hasBinary(X) ? this.encodeAsBinary({
      type: X.type === PacketType.EVENT ? PacketType.BINARY_EVENT : PacketType.BINARY_ACK,
      nsp: X.nsp,
      data: X.data,
      id: X.id
    }) : [this.encodeAsString(X)];
  }
  /**
   * Encode packet as string.
   */
  encodeAsString(X) {
    let ee = "" + X.type;
    return (X.type === PacketType.BINARY_EVENT || X.type === PacketType.BINARY_ACK) && (ee += X.attachments + "-"), X.nsp && X.nsp !== "/" && (ee += X.nsp + ","), X.id != null && (ee += X.id), X.data != null && (ee += JSON.stringify(X.data, this.replacer)), ee;
  }
  /**
   * Encode packet as 'buffer sequence' by removing blobs, and
   * deconstructing packet into object with placeholders and
   * a list of buffers.
   */
  encodeAsBinary(X) {
    const ee = deconstructPacket(X), te = this.encodeAsString(ee.packet), ne = ee.buffers;
    return ne.unshift(te), ne;
  }
}
function isObject$1(Y) {
  return Object.prototype.toString.call(Y) === "[object Object]";
}
class Decoder extends Emitter {
  /**
   * Decoder constructor
   *
   * @param {function} reviver - custom reviver to pass down to JSON.stringify
   */
  constructor(X) {
    super(), this.reviver = X;
  }
  /**
   * Decodes an encoded packet string into packet JSON.
   *
   * @param {String} obj - encoded packet
   */
  add(X) {
    let ee;
    if (typeof X == "string") {
      if (this.reconstructor)
        throw new Error("got plaintext data when reconstructing a packet");
      ee = this.decodeString(X);
      const te = ee.type === PacketType.BINARY_EVENT;
      te || ee.type === PacketType.BINARY_ACK ? (ee.type = te ? PacketType.EVENT : PacketType.ACK, this.reconstructor = new BinaryReconstructor(ee), ee.attachments === 0 && super.emitReserved("decoded", ee)) : super.emitReserved("decoded", ee);
    } else if (isBinary(X) || X.base64)
      if (this.reconstructor)
        ee = this.reconstructor.takeBinaryData(X), ee && (this.reconstructor = null, super.emitReserved("decoded", ee));
      else
        throw new Error("got binary data when not reconstructing a packet");
    else
      throw new Error("Unknown type: " + X);
  }
  /**
   * Decode a packet String (JSON data)
   *
   * @param {String} str
   * @return {Object} packet
   */
  decodeString(X) {
    let ee = 0;
    const te = {
      type: Number(X.charAt(0))
    };
    if (PacketType[te.type] === void 0)
      throw new Error("unknown packet type " + te.type);
    if (te.type === PacketType.BINARY_EVENT || te.type === PacketType.BINARY_ACK) {
      const ie = ee + 1;
      for (; X.charAt(++ee) !== "-" && ee != X.length; )
        ;
      const oe = X.substring(ie, ee);
      if (oe != Number(oe) || X.charAt(ee) !== "-")
        throw new Error("Illegal attachments");
      te.attachments = Number(oe);
    }
    if (X.charAt(ee + 1) === "/") {
      const ie = ee + 1;
      for (; ++ee && !(X.charAt(ee) === "," || ee === X.length); )
        ;
      te.nsp = X.substring(ie, ee);
    } else
      te.nsp = "/";
    const ne = X.charAt(ee + 1);
    if (ne !== "" && Number(ne) == ne) {
      const ie = ee + 1;
      for (; ++ee; ) {
        const oe = X.charAt(ee);
        if (oe == null || Number(oe) != oe) {
          --ee;
          break;
        }
        if (ee === X.length)
          break;
      }
      te.id = Number(X.substring(ie, ee + 1));
    }
    if (X.charAt(++ee)) {
      const ie = this.tryParse(X.substr(ee));
      if (Decoder.isPayloadValid(te.type, ie))
        te.data = ie;
      else
        throw new Error("invalid payload");
    }
    return te;
  }
  tryParse(X) {
    try {
      return JSON.parse(X, this.reviver);
    } catch {
      return !1;
    }
  }
  static isPayloadValid(X, ee) {
    switch (X) {
      case PacketType.CONNECT:
        return isObject$1(ee);
      case PacketType.DISCONNECT:
        return ee === void 0;
      case PacketType.CONNECT_ERROR:
        return typeof ee == "string" || isObject$1(ee);
      case PacketType.EVENT:
      case PacketType.BINARY_EVENT:
        return Array.isArray(ee) && (typeof ee[0] == "number" || typeof ee[0] == "string" && RESERVED_EVENTS$1.indexOf(ee[0]) === -1);
      case PacketType.ACK:
      case PacketType.BINARY_ACK:
        return Array.isArray(ee);
    }
  }
  /**
   * Deallocates a parser's resources
   */
  destroy() {
    this.reconstructor && (this.reconstructor.finishedReconstruction(), this.reconstructor = null);
  }
}
class BinaryReconstructor {
  constructor(X) {
    this.packet = X, this.buffers = [], this.reconPack = X;
  }
  /**
   * Method to be called when binary data received from connection
   * after a BINARY_EVENT packet.
   *
   * @param {Buffer | ArrayBuffer} binData - the raw binary data received
   * @return {null | Object} returns null if more binary data is expected or
   *   a reconstructed packet object if all buffers have been received.
   */
  takeBinaryData(X) {
    if (this.buffers.push(X), this.buffers.length === this.reconPack.attachments) {
      const ee = reconstructPacket(this.reconPack, this.buffers);
      return this.finishedReconstruction(), ee;
    }
    return null;
  }
  /**
   * Cleans up binary packet reconstruction variables.
   */
  finishedReconstruction() {
    this.reconPack = null, this.buffers = [];
  }
}
const parser = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Decoder,
  Encoder,
  get PacketType() {
    return PacketType;
  },
  protocol
}, Symbol.toStringTag, { value: "Module" }));
function on(Y, X, ee) {
  return Y.on(X, ee), function() {
    Y.off(X, ee);
  };
}
const RESERVED_EVENTS = Object.freeze({
  connect: 1,
  connect_error: 1,
  disconnect: 1,
  disconnecting: 1,
  // EventEmitter reserved events: https://nodejs.org/api/events.html#events_event_newlistener
  newListener: 1,
  removeListener: 1
});
class Socket extends Emitter {
  /**
   * `Socket` constructor.
   */
  constructor(X, ee, te) {
    super(), this.connected = !1, this.recovered = !1, this.receiveBuffer = [], this.sendBuffer = [], this._queue = [], this._queueSeq = 0, this.ids = 0, this.acks = {}, this.flags = {}, this.io = X, this.nsp = ee, te && te.auth && (this.auth = te.auth), this._opts = Object.assign({}, te), this.io._autoConnect && this.open();
  }
  /**
   * Whether the socket is currently disconnected
   *
   * @example
   * const socket = io();
   *
   * socket.on("connect", () => {
   *   console.log(socket.disconnected); // false
   * });
   *
   * socket.on("disconnect", () => {
   *   console.log(socket.disconnected); // true
   * });
   */
  get disconnected() {
    return !this.connected;
  }
  /**
   * Subscribe to open, close and packet events
   *
   * @private
   */
  subEvents() {
    if (this.subs)
      return;
    const X = this.io;
    this.subs = [
      on(X, "open", this.onopen.bind(this)),
      on(X, "packet", this.onpacket.bind(this)),
      on(X, "error", this.onerror.bind(this)),
      on(X, "close", this.onclose.bind(this))
    ];
  }
  /**
   * Whether the Socket will try to reconnect when its Manager connects or reconnects.
   *
   * @example
   * const socket = io();
   *
   * console.log(socket.active); // true
   *
   * socket.on("disconnect", (reason) => {
   *   if (reason === "io server disconnect") {
   *     // the disconnection was initiated by the server, you need to manually reconnect
   *     console.log(socket.active); // false
   *   }
   *   // else the socket will automatically try to reconnect
   *   console.log(socket.active); // true
   * });
   */
  get active() {
    return !!this.subs;
  }
  /**
   * "Opens" the socket.
   *
   * @example
   * const socket = io({
   *   autoConnect: false
   * });
   *
   * socket.connect();
   */
  connect() {
    return this.connected ? this : (this.subEvents(), this.io._reconnecting || this.io.open(), this.io._readyState === "open" && this.onopen(), this);
  }
  /**
   * Alias for {@link connect()}.
   */
  open() {
    return this.connect();
  }
  /**
   * Sends a `message` event.
   *
   * This method mimics the WebSocket.send() method.
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send
   *
   * @example
   * socket.send("hello");
   *
   * // this is equivalent to
   * socket.emit("message", "hello");
   *
   * @return self
   */
  send(...X) {
    return X.unshift("message"), this.emit.apply(this, X), this;
  }
  /**
   * Override `emit`.
   * If the event is in `events`, it's emitted normally.
   *
   * @example
   * socket.emit("hello", "world");
   *
   * // all serializable datastructures are supported (no need to call JSON.stringify)
   * socket.emit("hello", 1, "2", { 3: ["4"], 5: Uint8Array.from([6]) });
   *
   * // with an acknowledgement from the server
   * socket.emit("hello", "world", (val) => {
   *   // ...
   * });
   *
   * @return self
   */
  emit(X, ...ee) {
    if (RESERVED_EVENTS.hasOwnProperty(X))
      throw new Error('"' + X.toString() + '" is a reserved event name');
    if (ee.unshift(X), this._opts.retries && !this.flags.fromQueue && !this.flags.volatile)
      return this._addToQueue(ee), this;
    const te = {
      type: PacketType.EVENT,
      data: ee
    };
    if (te.options = {}, te.options.compress = this.flags.compress !== !1, typeof ee[ee.length - 1] == "function") {
      const ie = this.ids++, oe = ee.pop();
      this._registerAckCallback(ie, oe), te.id = ie;
    }
    const ne = this.io.engine && this.io.engine.transport && this.io.engine.transport.writable;
    return this.flags.volatile && (!ne || !this.connected) || (this.connected ? (this.notifyOutgoingListeners(te), this.packet(te)) : this.sendBuffer.push(te)), this.flags = {}, this;
  }
  /**
   * @private
   */
  _registerAckCallback(X, ee) {
    var te;
    const ne = (te = this.flags.timeout) !== null && te !== void 0 ? te : this._opts.ackTimeout;
    if (ne === void 0) {
      this.acks[X] = ee;
      return;
    }
    const ie = this.io.setTimeoutFn(() => {
      delete this.acks[X];
      for (let oe = 0; oe < this.sendBuffer.length; oe++)
        this.sendBuffer[oe].id === X && this.sendBuffer.splice(oe, 1);
      ee.call(this, new Error("operation has timed out"));
    }, ne);
    this.acks[X] = (...oe) => {
      this.io.clearTimeoutFn(ie), ee.apply(this, [null, ...oe]);
    };
  }
  /**
   * Emits an event and waits for an acknowledgement
   *
   * @example
   * // without timeout
   * const response = await socket.emitWithAck("hello", "world");
   *
   * // with a specific timeout
   * try {
   *   const response = await socket.timeout(1000).emitWithAck("hello", "world");
   * } catch (err) {
   *   // the server did not acknowledge the event in the given delay
   * }
   *
   * @return a Promise that will be fulfilled when the server acknowledges the event
   */
  emitWithAck(X, ...ee) {
    const te = this.flags.timeout !== void 0 || this._opts.ackTimeout !== void 0;
    return new Promise((ne, ie) => {
      ee.push((oe, se) => te ? oe ? ie(oe) : ne(se) : ne(oe)), this.emit(X, ...ee);
    });
  }
  /**
   * Add the packet to the queue.
   * @param args
   * @private
   */
  _addToQueue(X) {
    let ee;
    typeof X[X.length - 1] == "function" && (ee = X.pop());
    const te = {
      id: this._queueSeq++,
      tryCount: 0,
      pending: !1,
      args: X,
      flags: Object.assign({ fromQueue: !0 }, this.flags)
    };
    X.push((ne, ...ie) => te !== this._queue[0] ? void 0 : (ne !== null ? te.tryCount > this._opts.retries && (this._queue.shift(), ee && ee(ne)) : (this._queue.shift(), ee && ee(null, ...ie)), te.pending = !1, this._drainQueue())), this._queue.push(te), this._drainQueue();
  }
  /**
   * Send the first packet of the queue, and wait for an acknowledgement from the server.
   * @param force - whether to resend a packet that has not been acknowledged yet
   *
   * @private
   */
  _drainQueue(X = !1) {
    if (!this.connected || this._queue.length === 0)
      return;
    const ee = this._queue[0];
    ee.pending && !X || (ee.pending = !0, ee.tryCount++, this.flags = ee.flags, this.emit.apply(this, ee.args));
  }
  /**
   * Sends a packet.
   *
   * @param packet
   * @private
   */
  packet(X) {
    X.nsp = this.nsp, this.io._packet(X);
  }
  /**
   * Called upon engine `open`.
   *
   * @private
   */
  onopen() {
    typeof this.auth == "function" ? this.auth((X) => {
      this._sendConnectPacket(X);
    }) : this._sendConnectPacket(this.auth);
  }
  /**
   * Sends a CONNECT packet to initiate the Socket.IO session.
   *
   * @param data
   * @private
   */
  _sendConnectPacket(X) {
    this.packet({
      type: PacketType.CONNECT,
      data: this._pid ? Object.assign({ pid: this._pid, offset: this._lastOffset }, X) : X
    });
  }
  /**
   * Called upon engine or manager `error`.
   *
   * @param err
   * @private
   */
  onerror(X) {
    this.connected || this.emitReserved("connect_error", X);
  }
  /**
   * Called upon engine `close`.
   *
   * @param reason
   * @param description
   * @private
   */
  onclose(X, ee) {
    this.connected = !1, delete this.id, this.emitReserved("disconnect", X, ee);
  }
  /**
   * Called with socket packet.
   *
   * @param packet
   * @private
   */
  onpacket(X) {
    if (X.nsp === this.nsp)
      switch (X.type) {
        case PacketType.CONNECT:
          X.data && X.data.sid ? this.onconnect(X.data.sid, X.data.pid) : this.emitReserved("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));
          break;
        case PacketType.EVENT:
        case PacketType.BINARY_EVENT:
          this.onevent(X);
          break;
        case PacketType.ACK:
        case PacketType.BINARY_ACK:
          this.onack(X);
          break;
        case PacketType.DISCONNECT:
          this.ondisconnect();
          break;
        case PacketType.CONNECT_ERROR:
          this.destroy();
          const ee = new Error(X.data.message);
          ee.data = X.data.data, this.emitReserved("connect_error", ee);
          break;
      }
  }
  /**
   * Called upon a server event.
   *
   * @param packet
   * @private
   */
  onevent(X) {
    const ee = X.data || [];
    X.id != null && ee.push(this.ack(X.id)), this.connected ? this.emitEvent(ee) : this.receiveBuffer.push(Object.freeze(ee));
  }
  emitEvent(X) {
    if (this._anyListeners && this._anyListeners.length) {
      const ee = this._anyListeners.slice();
      for (const te of ee)
        te.apply(this, X);
    }
    super.emit.apply(this, X), this._pid && X.length && typeof X[X.length - 1] == "string" && (this._lastOffset = X[X.length - 1]);
  }
  /**
   * Produces an ack callback to emit with an event.
   *
   * @private
   */
  ack(X) {
    const ee = this;
    let te = !1;
    return function(...ne) {
      te || (te = !0, ee.packet({
        type: PacketType.ACK,
        id: X,
        data: ne
      }));
    };
  }
  /**
   * Called upon a server acknowlegement.
   *
   * @param packet
   * @private
   */
  onack(X) {
    const ee = this.acks[X.id];
    typeof ee == "function" && (ee.apply(this, X.data), delete this.acks[X.id]);
  }
  /**
   * Called upon server connect.
   *
   * @private
   */
  onconnect(X, ee) {
    this.id = X, this.recovered = ee && this._pid === ee, this._pid = ee, this.connected = !0, this.emitBuffered(), this.emitReserved("connect"), this._drainQueue(!0);
  }
  /**
   * Emit buffered events (received and emitted).
   *
   * @private
   */
  emitBuffered() {
    this.receiveBuffer.forEach((X) => this.emitEvent(X)), this.receiveBuffer = [], this.sendBuffer.forEach((X) => {
      this.notifyOutgoingListeners(X), this.packet(X);
    }), this.sendBuffer = [];
  }
  /**
   * Called upon server disconnect.
   *
   * @private
   */
  ondisconnect() {
    this.destroy(), this.onclose("io server disconnect");
  }
  /**
   * Called upon forced client/server side disconnections,
   * this method ensures the manager stops tracking us and
   * that reconnections don't get triggered for this.
   *
   * @private
   */
  destroy() {
    this.subs && (this.subs.forEach((X) => X()), this.subs = void 0), this.io._destroy(this);
  }
  /**
   * Disconnects the socket manually. In that case, the socket will not try to reconnect.
   *
   * If this is the last active Socket instance of the {@link Manager}, the low-level connection will be closed.
   *
   * @example
   * const socket = io();
   *
   * socket.on("disconnect", (reason) => {
   *   // console.log(reason); prints "io client disconnect"
   * });
   *
   * socket.disconnect();
   *
   * @return self
   */
  disconnect() {
    return this.connected && this.packet({ type: PacketType.DISCONNECT }), this.destroy(), this.connected && this.onclose("io client disconnect"), this;
  }
  /**
   * Alias for {@link disconnect()}.
   *
   * @return self
   */
  close() {
    return this.disconnect();
  }
  /**
   * Sets the compress flag.
   *
   * @example
   * socket.compress(false).emit("hello");
   *
   * @param compress - if `true`, compresses the sending data
   * @return self
   */
  compress(X) {
    return this.flags.compress = X, this;
  }
  /**
   * Sets a modifier for a subsequent event emission that the event message will be dropped when this socket is not
   * ready to send messages.
   *
   * @example
   * socket.volatile.emit("hello"); // the server may or may not receive it
   *
   * @returns self
   */
  get volatile() {
    return this.flags.volatile = !0, this;
  }
  /**
   * Sets a modifier for a subsequent event emission that the callback will be called with an error when the
   * given number of milliseconds have elapsed without an acknowledgement from the server:
   *
   * @example
   * socket.timeout(5000).emit("my-event", (err) => {
   *   if (err) {
   *     // the server did not acknowledge the event in the given delay
   *   }
   * });
   *
   * @returns self
   */
  timeout(X) {
    return this.flags.timeout = X, this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback.
   *
   * @example
   * socket.onAny((event, ...args) => {
   *   console.log(`got ${event}`);
   * });
   *
   * @param listener
   */
  onAny(X) {
    return this._anyListeners = this._anyListeners || [], this._anyListeners.push(X), this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback. The listener is added to the beginning of the listeners array.
   *
   * @example
   * socket.prependAny((event, ...args) => {
   *   console.log(`got event ${event}`);
   * });
   *
   * @param listener
   */
  prependAny(X) {
    return this._anyListeners = this._anyListeners || [], this._anyListeners.unshift(X), this;
  }
  /**
   * Removes the listener that will be fired when any event is emitted.
   *
   * @example
   * const catchAllListener = (event, ...args) => {
   *   console.log(`got event ${event}`);
   * }
   *
   * socket.onAny(catchAllListener);
   *
   * // remove a specific listener
   * socket.offAny(catchAllListener);
   *
   * // or remove all listeners
   * socket.offAny();
   *
   * @param listener
   */
  offAny(X) {
    if (!this._anyListeners)
      return this;
    if (X) {
      const ee = this._anyListeners;
      for (let te = 0; te < ee.length; te++)
        if (X === ee[te])
          return ee.splice(te, 1), this;
    } else
      this._anyListeners = [];
    return this;
  }
  /**
   * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
   * e.g. to remove listeners.
   */
  listenersAny() {
    return this._anyListeners || [];
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback.
   *
   * Note: acknowledgements sent to the server are not included.
   *
   * @example
   * socket.onAnyOutgoing((event, ...args) => {
   *   console.log(`sent event ${event}`);
   * });
   *
   * @param listener
   */
  onAnyOutgoing(X) {
    return this._anyOutgoingListeners = this._anyOutgoingListeners || [], this._anyOutgoingListeners.push(X), this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback. The listener is added to the beginning of the listeners array.
   *
   * Note: acknowledgements sent to the server are not included.
   *
   * @example
   * socket.prependAnyOutgoing((event, ...args) => {
   *   console.log(`sent event ${event}`);
   * });
   *
   * @param listener
   */
  prependAnyOutgoing(X) {
    return this._anyOutgoingListeners = this._anyOutgoingListeners || [], this._anyOutgoingListeners.unshift(X), this;
  }
  /**
   * Removes the listener that will be fired when any event is emitted.
   *
   * @example
   * const catchAllListener = (event, ...args) => {
   *   console.log(`sent event ${event}`);
   * }
   *
   * socket.onAnyOutgoing(catchAllListener);
   *
   * // remove a specific listener
   * socket.offAnyOutgoing(catchAllListener);
   *
   * // or remove all listeners
   * socket.offAnyOutgoing();
   *
   * @param [listener] - the catch-all listener (optional)
   */
  offAnyOutgoing(X) {
    if (!this._anyOutgoingListeners)
      return this;
    if (X) {
      const ee = this._anyOutgoingListeners;
      for (let te = 0; te < ee.length; te++)
        if (X === ee[te])
          return ee.splice(te, 1), this;
    } else
      this._anyOutgoingListeners = [];
    return this;
  }
  /**
   * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
   * e.g. to remove listeners.
   */
  listenersAnyOutgoing() {
    return this._anyOutgoingListeners || [];
  }
  /**
   * Notify the listeners for each packet sent
   *
   * @param packet
   *
   * @private
   */
  notifyOutgoingListeners(X) {
    if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {
      const ee = this._anyOutgoingListeners.slice();
      for (const te of ee)
        te.apply(this, X.data);
    }
  }
}
function Backoff(Y) {
  Y = Y || {}, this.ms = Y.min || 100, this.max = Y.max || 1e4, this.factor = Y.factor || 2, this.jitter = Y.jitter > 0 && Y.jitter <= 1 ? Y.jitter : 0, this.attempts = 0;
}
Backoff.prototype.duration = function() {
  var Y = this.ms * Math.pow(this.factor, this.attempts++);
  if (this.jitter) {
    var X = Math.random(), ee = Math.floor(X * this.jitter * Y);
    Y = Math.floor(X * 10) & 1 ? Y + ee : Y - ee;
  }
  return Math.min(Y, this.max) | 0;
};
Backoff.prototype.reset = function() {
  this.attempts = 0;
};
Backoff.prototype.setMin = function(Y) {
  this.ms = Y;
};
Backoff.prototype.setMax = function(Y) {
  this.max = Y;
};
Backoff.prototype.setJitter = function(Y) {
  this.jitter = Y;
};
class Manager extends Emitter {
  constructor(X, ee) {
    var te;
    super(), this.nsps = {}, this.subs = [], X && typeof X == "object" && (ee = X, X = void 0), ee = ee || {}, ee.path = ee.path || "/socket.io", this.opts = ee, installTimerFunctions(this, ee), this.reconnection(ee.reconnection !== !1), this.reconnectionAttempts(ee.reconnectionAttempts || 1 / 0), this.reconnectionDelay(ee.reconnectionDelay || 1e3), this.reconnectionDelayMax(ee.reconnectionDelayMax || 5e3), this.randomizationFactor((te = ee.randomizationFactor) !== null && te !== void 0 ? te : 0.5), this.backoff = new Backoff({
      min: this.reconnectionDelay(),
      max: this.reconnectionDelayMax(),
      jitter: this.randomizationFactor()
    }), this.timeout(ee.timeout == null ? 2e4 : ee.timeout), this._readyState = "closed", this.uri = X;
    const ne = ee.parser || parser;
    this.encoder = new ne.Encoder(), this.decoder = new ne.Decoder(), this._autoConnect = ee.autoConnect !== !1, this._autoConnect && this.open();
  }
  reconnection(X) {
    return arguments.length ? (this._reconnection = !!X, this) : this._reconnection;
  }
  reconnectionAttempts(X) {
    return X === void 0 ? this._reconnectionAttempts : (this._reconnectionAttempts = X, this);
  }
  reconnectionDelay(X) {
    var ee;
    return X === void 0 ? this._reconnectionDelay : (this._reconnectionDelay = X, (ee = this.backoff) === null || ee === void 0 || ee.setMin(X), this);
  }
  randomizationFactor(X) {
    var ee;
    return X === void 0 ? this._randomizationFactor : (this._randomizationFactor = X, (ee = this.backoff) === null || ee === void 0 || ee.setJitter(X), this);
  }
  reconnectionDelayMax(X) {
    var ee;
    return X === void 0 ? this._reconnectionDelayMax : (this._reconnectionDelayMax = X, (ee = this.backoff) === null || ee === void 0 || ee.setMax(X), this);
  }
  timeout(X) {
    return arguments.length ? (this._timeout = X, this) : this._timeout;
  }
  /**
   * Starts trying to reconnect if reconnection is enabled and we have not
   * started reconnecting yet
   *
   * @private
   */
  maybeReconnectOnOpen() {
    !this._reconnecting && this._reconnection && this.backoff.attempts === 0 && this.reconnect();
  }
  /**
   * Sets the current transport `socket`.
   *
   * @param {Function} fn - optional, callback
   * @return self
   * @public
   */
  open(X) {
    if (~this._readyState.indexOf("open"))
      return this;
    this.engine = new Socket$1(this.uri, this.opts);
    const ee = this.engine, te = this;
    this._readyState = "opening", this.skipReconnect = !1;
    const ne = on(ee, "open", function() {
      te.onopen(), X && X();
    }), ie = (se) => {
      this.cleanup(), this._readyState = "closed", this.emitReserved("error", se), X ? X(se) : this.maybeReconnectOnOpen();
    }, oe = on(ee, "error", ie);
    if (this._timeout !== !1) {
      const se = this._timeout, ae = this.setTimeoutFn(() => {
        ne(), ie(new Error("timeout")), ee.close();
      }, se);
      this.opts.autoUnref && ae.unref(), this.subs.push(() => {
        this.clearTimeoutFn(ae);
      });
    }
    return this.subs.push(ne), this.subs.push(oe), this;
  }
  /**
   * Alias for open()
   *
   * @return self
   * @public
   */
  connect(X) {
    return this.open(X);
  }
  /**
   * Called upon transport open.
   *
   * @private
   */
  onopen() {
    this.cleanup(), this._readyState = "open", this.emitReserved("open");
    const X = this.engine;
    this.subs.push(on(X, "ping", this.onping.bind(this)), on(X, "data", this.ondata.bind(this)), on(X, "error", this.onerror.bind(this)), on(X, "close", this.onclose.bind(this)), on(this.decoder, "decoded", this.ondecoded.bind(this)));
  }
  /**
   * Called upon a ping.
   *
   * @private
   */
  onping() {
    this.emitReserved("ping");
  }
  /**
   * Called with data.
   *
   * @private
   */
  ondata(X) {
    try {
      this.decoder.add(X);
    } catch (ee) {
      this.onclose("parse error", ee);
    }
  }
  /**
   * Called when parser fully decodes a packet.
   *
   * @private
   */
  ondecoded(X) {
    nextTick(() => {
      this.emitReserved("packet", X);
    }, this.setTimeoutFn);
  }
  /**
   * Called upon socket error.
   *
   * @private
   */
  onerror(X) {
    this.emitReserved("error", X);
  }
  /**
   * Creates a new socket for the given `nsp`.
   *
   * @return {Socket}
   * @public
   */
  socket(X, ee) {
    let te = this.nsps[X];
    return te ? this._autoConnect && !te.active && te.connect() : (te = new Socket(this, X, ee), this.nsps[X] = te), te;
  }
  /**
   * Called upon a socket close.
   *
   * @param socket
   * @private
   */
  _destroy(X) {
    const ee = Object.keys(this.nsps);
    for (const te of ee)
      if (this.nsps[te].active)
        return;
    this._close();
  }
  /**
   * Writes a packet.
   *
   * @param packet
   * @private
   */
  _packet(X) {
    const ee = this.encoder.encode(X);
    for (let te = 0; te < ee.length; te++)
      this.engine.write(ee[te], X.options);
  }
  /**
   * Clean up transport subscriptions and packet buffer.
   *
   * @private
   */
  cleanup() {
    this.subs.forEach((X) => X()), this.subs.length = 0, this.decoder.destroy();
  }
  /**
   * Close the current socket.
   *
   * @private
   */
  _close() {
    this.skipReconnect = !0, this._reconnecting = !1, this.onclose("forced close"), this.engine && this.engine.close();
  }
  /**
   * Alias for close()
   *
   * @private
   */
  disconnect() {
    return this._close();
  }
  /**
   * Called upon engine close.
   *
   * @private
   */
  onclose(X, ee) {
    this.cleanup(), this.backoff.reset(), this._readyState = "closed", this.emitReserved("close", X, ee), this._reconnection && !this.skipReconnect && this.reconnect();
  }
  /**
   * Attempt a reconnection.
   *
   * @private
   */
  reconnect() {
    if (this._reconnecting || this.skipReconnect)
      return this;
    const X = this;
    if (this.backoff.attempts >= this._reconnectionAttempts)
      this.backoff.reset(), this.emitReserved("reconnect_failed"), this._reconnecting = !1;
    else {
      const ee = this.backoff.duration();
      this._reconnecting = !0;
      const te = this.setTimeoutFn(() => {
        X.skipReconnect || (this.emitReserved("reconnect_attempt", X.backoff.attempts), !X.skipReconnect && X.open((ne) => {
          ne ? (X._reconnecting = !1, X.reconnect(), this.emitReserved("reconnect_error", ne)) : X.onreconnect();
        }));
      }, ee);
      this.opts.autoUnref && te.unref(), this.subs.push(() => {
        this.clearTimeoutFn(te);
      });
    }
  }
  /**
   * Called upon successful reconnect.
   *
   * @private
   */
  onreconnect() {
    const X = this.backoff.attempts;
    this._reconnecting = !1, this.backoff.reset(), this.emitReserved("reconnect", X);
  }
}
const cache$1 = {};
function lookup$1(Y, X) {
  typeof Y == "object" && (X = Y, Y = void 0), X = X || {};
  const ee = url(Y, X.path || "/socket.io"), te = ee.source, ne = ee.id, ie = ee.path, oe = cache$1[ne] && ie in cache$1[ne].nsps, se = X.forceNew || X["force new connection"] || X.multiplex === !1 || oe;
  let ae;
  return se ? ae = new Manager(te, X) : (cache$1[ne] || (cache$1[ne] = new Manager(te, X)), ae = cache$1[ne]), ee.query && !X.query && (X.query = ee.queryKey), ae.socket(ee.path, X);
}
Object.assign(lookup$1, {
  Manager,
  Socket,
  io: lookup$1,
  connect: lookup$1
});
const socketUrl = {
  prod: "wss://prod.tria.so",
  staging: "wss://staging.tria.so",
  dev: "wss://dev.tria.so"
}, socket = lookup$1(socketUrl.prod), apiUrl = {
  mainnet: "https://prod.tria.so",
  "mainnet-staging": "https://staging.tria.so",
  testnet: "https://staging.tria.so"
}, signMessage = async (Y, X, ee = triaAuthUrl, te = "mainnet", ne, ie) => {
  if (wagmiConnected(Y))
    return await new bY({
      config: Y,
      baseUrl: apiUrl[te],
      walletType: { embedded: !1 },
      selectedChainName: X.chainName,
      environment: te
    }).signMessage(X.message);
  if (triaConnected()) {
    const oe = createEncodedData({
      ...X,
      ...ie,
      aa: ne
    }), se = `${ee}/signMessage/${oe}`;
    return createIframe(se, "sdkSign"), new Promise((ae, ue) => {
      const le = (he) => {
        var me;
        if (he.origin !== ee)
          return;
        let ye;
        try {
          ye = JSON.parse(he.data);
        } catch {
          ye = he.data;
        }
        (ye == null ? void 0 : ye.type) === "closeIframe" && (ye == null ? void 0 : ye.callFrom) === "sign" && ((me = document.getElementById("sdkSign")) == null || me.remove(), window.removeEventListener("message", le), ae(ye == null ? void 0 : ye.data));
      };
      window.addEventListener("message", le);
    });
  } else
    return { success: !1, message: "Metamask and Tria not connected!" };
};
var bn$2 = { exports: {} };
const __viteBrowserExternal = {}, __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: __viteBrowserExternal
}, Symbol.toStringTag, { value: "Module" })), require$$0$4 = /* @__PURE__ */ getAugmentedNamespace$1(__viteBrowserExternal$1);
(function(Y) {
  (function(X, ee) {
    function te(fe, de) {
      if (!fe)
        throw new Error(de || "Assertion failed");
    }
    function ne(fe, de) {
      fe.super_ = de;
      var be = function() {
      };
      be.prototype = de.prototype, fe.prototype = new be(), fe.prototype.constructor = fe;
    }
    function ie(fe, de, be) {
      if (ie.isBN(fe))
        return fe;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, fe !== null && ((de === "le" || de === "be") && (be = de, de = 10), this._init(fe || 0, de || 10, be || "be"));
    }
    typeof X == "object" ? X.exports = ie : ee.BN = ie, ie.BN = ie, ie.wordSize = 26;
    var oe;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? oe = window.Buffer : oe = require$$0$4.Buffer;
    } catch {
    }
    ie.isBN = function(fe) {
      return fe instanceof ie ? !0 : fe !== null && typeof fe == "object" && fe.constructor.wordSize === ie.wordSize && Array.isArray(fe.words);
    }, ie.max = function(fe, de) {
      return fe.cmp(de) > 0 ? fe : de;
    }, ie.min = function(fe, de) {
      return fe.cmp(de) < 0 ? fe : de;
    }, ie.prototype._init = function(fe, de, be) {
      if (typeof fe == "number")
        return this._initNumber(fe, de, be);
      if (typeof fe == "object")
        return this._initArray(fe, de, be);
      de === "hex" && (de = 16), te(de === (de | 0) && de >= 2 && de <= 36), fe = fe.toString().replace(/\s+/g, "");
      var Te = 0;
      fe[0] === "-" && (Te++, this.negative = 1), Te < fe.length && (de === 16 ? this._parseHex(fe, Te, be) : (this._parseBase(fe, de, Te), be === "le" && this._initArray(this.toArray(), de, be)));
    }, ie.prototype._initNumber = function(fe, de, be) {
      fe < 0 && (this.negative = 1, fe = -fe), fe < 67108864 ? (this.words = [fe & 67108863], this.length = 1) : fe < 4503599627370496 ? (this.words = [
        fe & 67108863,
        fe / 67108864 & 67108863
      ], this.length = 2) : (te(fe < 9007199254740992), this.words = [
        fe & 67108863,
        fe / 67108864 & 67108863,
        1
      ], this.length = 3), be === "le" && this._initArray(this.toArray(), de, be);
    }, ie.prototype._initArray = function(fe, de, be) {
      if (te(typeof fe.length == "number"), fe.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(fe.length / 3), this.words = new Array(this.length);
      for (var Te = 0; Te < this.length; Te++)
        this.words[Te] = 0;
      var Ce, Pe, Se = 0;
      if (be === "be")
        for (Te = fe.length - 1, Ce = 0; Te >= 0; Te -= 3)
          Pe = fe[Te] | fe[Te - 1] << 8 | fe[Te - 2] << 16, this.words[Ce] |= Pe << Se & 67108863, this.words[Ce + 1] = Pe >>> 26 - Se & 67108863, Se += 24, Se >= 26 && (Se -= 26, Ce++);
      else if (be === "le")
        for (Te = 0, Ce = 0; Te < fe.length; Te += 3)
          Pe = fe[Te] | fe[Te + 1] << 8 | fe[Te + 2] << 16, this.words[Ce] |= Pe << Se & 67108863, this.words[Ce + 1] = Pe >>> 26 - Se & 67108863, Se += 24, Se >= 26 && (Se -= 26, Ce++);
      return this._strip();
    };
    function se(fe, de) {
      var be = fe.charCodeAt(de);
      if (be >= 48 && be <= 57)
        return be - 48;
      if (be >= 65 && be <= 70)
        return be - 55;
      if (be >= 97 && be <= 102)
        return be - 87;
      te(!1, "Invalid character in " + fe);
    }
    function ae(fe, de, be) {
      var Te = se(fe, be);
      return be - 1 >= de && (Te |= se(fe, be - 1) << 4), Te;
    }
    ie.prototype._parseHex = function(fe, de, be) {
      this.length = Math.ceil((fe.length - de) / 6), this.words = new Array(this.length);
      for (var Te = 0; Te < this.length; Te++)
        this.words[Te] = 0;
      var Ce = 0, Pe = 0, Se;
      if (be === "be")
        for (Te = fe.length - 1; Te >= de; Te -= 2)
          Se = ae(fe, de, Te) << Ce, this.words[Pe] |= Se & 67108863, Ce >= 18 ? (Ce -= 18, Pe += 1, this.words[Pe] |= Se >>> 26) : Ce += 8;
      else {
        var ke = fe.length - de;
        for (Te = ke % 2 === 0 ? de + 1 : de; Te < fe.length; Te += 2)
          Se = ae(fe, de, Te) << Ce, this.words[Pe] |= Se & 67108863, Ce >= 18 ? (Ce -= 18, Pe += 1, this.words[Pe] |= Se >>> 26) : Ce += 8;
      }
      this._strip();
    };
    function ue(fe, de, be, Te) {
      for (var Ce = 0, Pe = 0, Se = Math.min(fe.length, be), ke = de; ke < Se; ke++) {
        var ge = fe.charCodeAt(ke) - 48;
        Ce *= Te, ge >= 49 ? Pe = ge - 49 + 10 : ge >= 17 ? Pe = ge - 17 + 10 : Pe = ge, te(ge >= 0 && Pe < Te, "Invalid character"), Ce += Pe;
      }
      return Ce;
    }
    ie.prototype._parseBase = function(fe, de, be) {
      this.words = [0], this.length = 1;
      for (var Te = 0, Ce = 1; Ce <= 67108863; Ce *= de)
        Te++;
      Te--, Ce = Ce / de | 0;
      for (var Pe = fe.length - be, Se = Pe % Te, ke = Math.min(Pe, Pe - Se) + be, ge = 0, Ae = be; Ae < ke; Ae += Te)
        ge = ue(fe, Ae, Ae + Te, de), this.imuln(Ce), this.words[0] + ge < 67108864 ? this.words[0] += ge : this._iaddn(ge);
      if (Se !== 0) {
        var Ge = 1;
        for (ge = ue(fe, Ae, fe.length, de), Ae = 0; Ae < Se; Ae++)
          Ge *= de;
        this.imuln(Ge), this.words[0] + ge < 67108864 ? this.words[0] += ge : this._iaddn(ge);
      }
      this._strip();
    }, ie.prototype.copy = function(fe) {
      fe.words = new Array(this.length);
      for (var de = 0; de < this.length; de++)
        fe.words[de] = this.words[de];
      fe.length = this.length, fe.negative = this.negative, fe.red = this.red;
    };
    function le(fe, de) {
      fe.words = de.words, fe.length = de.length, fe.negative = de.negative, fe.red = de.red;
    }
    if (ie.prototype._move = function(fe) {
      le(fe, this);
    }, ie.prototype.clone = function() {
      var fe = new ie(null);
      return this.copy(fe), fe;
    }, ie.prototype._expand = function(fe) {
      for (; this.length < fe; )
        this.words[this.length++] = 0;
      return this;
    }, ie.prototype._strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, ie.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, typeof Symbol < "u" && typeof Symbol.for == "function")
      try {
        ie.prototype[Symbol.for("nodejs.util.inspect.custom")] = he;
      } catch {
        ie.prototype.inspect = he;
      }
    else
      ie.prototype.inspect = he;
    function he() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    }
    var me = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], ye = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], we = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    ie.prototype.toString = function(fe, de) {
      fe = fe || 10, de = de | 0 || 1;
      var be;
      if (fe === 16 || fe === "hex") {
        be = "";
        for (var Te = 0, Ce = 0, Pe = 0; Pe < this.length; Pe++) {
          var Se = this.words[Pe], ke = ((Se << Te | Ce) & 16777215).toString(16);
          Ce = Se >>> 24 - Te & 16777215, Te += 2, Te >= 26 && (Te -= 26, Pe--), Ce !== 0 || Pe !== this.length - 1 ? be = me[6 - ke.length] + ke + be : be = ke + be;
        }
        for (Ce !== 0 && (be = Ce.toString(16) + be); be.length % de !== 0; )
          be = "0" + be;
        return this.negative !== 0 && (be = "-" + be), be;
      }
      if (fe === (fe | 0) && fe >= 2 && fe <= 36) {
        var ge = ye[fe], Ae = we[fe];
        be = "";
        var Ge = this.clone();
        for (Ge.negative = 0; !Ge.isZero(); ) {
          var Xe = Ge.modrn(Ae).toString(fe);
          Ge = Ge.idivn(Ae), Ge.isZero() ? be = Xe + be : be = me[ge - Xe.length] + Xe + be;
        }
        for (this.isZero() && (be = "0" + be); be.length % de !== 0; )
          be = "0" + be;
        return this.negative !== 0 && (be = "-" + be), be;
      }
      te(!1, "Base should be between 2 and 36");
    }, ie.prototype.toNumber = function() {
      var fe = this.words[0];
      return this.length === 2 ? fe += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? fe += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && te(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -fe : fe;
    }, ie.prototype.toJSON = function() {
      return this.toString(16, 2);
    }, oe && (ie.prototype.toBuffer = function(fe, de) {
      return this.toArrayLike(oe, fe, de);
    }), ie.prototype.toArray = function(fe, de) {
      return this.toArrayLike(Array, fe, de);
    };
    var Ee = function(fe, de) {
      return fe.allocUnsafe ? fe.allocUnsafe(de) : new fe(de);
    };
    ie.prototype.toArrayLike = function(fe, de, be) {
      this._strip();
      var Te = this.byteLength(), Ce = be || Math.max(1, Te);
      te(Te <= Ce, "byte array longer than desired length"), te(Ce > 0, "Requested array length <= 0");
      var Pe = Ee(fe, Ce), Se = de === "le" ? "LE" : "BE";
      return this["_toArrayLike" + Se](Pe, Te), Pe;
    }, ie.prototype._toArrayLikeLE = function(fe, de) {
      for (var be = 0, Te = 0, Ce = 0, Pe = 0; Ce < this.length; Ce++) {
        var Se = this.words[Ce] << Pe | Te;
        fe[be++] = Se & 255, be < fe.length && (fe[be++] = Se >> 8 & 255), be < fe.length && (fe[be++] = Se >> 16 & 255), Pe === 6 ? (be < fe.length && (fe[be++] = Se >> 24 & 255), Te = 0, Pe = 0) : (Te = Se >>> 24, Pe += 2);
      }
      if (be < fe.length)
        for (fe[be++] = Te; be < fe.length; )
          fe[be++] = 0;
    }, ie.prototype._toArrayLikeBE = function(fe, de) {
      for (var be = fe.length - 1, Te = 0, Ce = 0, Pe = 0; Ce < this.length; Ce++) {
        var Se = this.words[Ce] << Pe | Te;
        fe[be--] = Se & 255, be >= 0 && (fe[be--] = Se >> 8 & 255), be >= 0 && (fe[be--] = Se >> 16 & 255), Pe === 6 ? (be >= 0 && (fe[be--] = Se >> 24 & 255), Te = 0, Pe = 0) : (Te = Se >>> 24, Pe += 2);
      }
      if (be >= 0)
        for (fe[be--] = Te; be >= 0; )
          fe[be--] = 0;
    }, Math.clz32 ? ie.prototype._countBits = function(fe) {
      return 32 - Math.clz32(fe);
    } : ie.prototype._countBits = function(fe) {
      var de = fe, be = 0;
      return de >= 4096 && (be += 13, de >>>= 13), de >= 64 && (be += 7, de >>>= 7), de >= 8 && (be += 4, de >>>= 4), de >= 2 && (be += 2, de >>>= 2), be + de;
    }, ie.prototype._zeroBits = function(fe) {
      if (fe === 0)
        return 26;
      var de = fe, be = 0;
      return de & 8191 || (be += 13, de >>>= 13), de & 127 || (be += 7, de >>>= 7), de & 15 || (be += 4, de >>>= 4), de & 3 || (be += 2, de >>>= 2), de & 1 || be++, be;
    }, ie.prototype.bitLength = function() {
      var fe = this.words[this.length - 1], de = this._countBits(fe);
      return (this.length - 1) * 26 + de;
    };
    function Re(fe) {
      for (var de = new Array(fe.bitLength()), be = 0; be < de.length; be++) {
        var Te = be / 26 | 0, Ce = be % 26;
        de[be] = fe.words[Te] >>> Ce & 1;
      }
      return de;
    }
    ie.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var fe = 0, de = 0; de < this.length; de++) {
        var be = this._zeroBits(this.words[de]);
        if (fe += be, be !== 26)
          break;
      }
      return fe;
    }, ie.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, ie.prototype.toTwos = function(fe) {
      return this.negative !== 0 ? this.abs().inotn(fe).iaddn(1) : this.clone();
    }, ie.prototype.fromTwos = function(fe) {
      return this.testn(fe - 1) ? this.notn(fe).iaddn(1).ineg() : this.clone();
    }, ie.prototype.isNeg = function() {
      return this.negative !== 0;
    }, ie.prototype.neg = function() {
      return this.clone().ineg();
    }, ie.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, ie.prototype.iuor = function(fe) {
      for (; this.length < fe.length; )
        this.words[this.length++] = 0;
      for (var de = 0; de < fe.length; de++)
        this.words[de] = this.words[de] | fe.words[de];
      return this._strip();
    }, ie.prototype.ior = function(fe) {
      return te((this.negative | fe.negative) === 0), this.iuor(fe);
    }, ie.prototype.or = function(fe) {
      return this.length > fe.length ? this.clone().ior(fe) : fe.clone().ior(this);
    }, ie.prototype.uor = function(fe) {
      return this.length > fe.length ? this.clone().iuor(fe) : fe.clone().iuor(this);
    }, ie.prototype.iuand = function(fe) {
      var de;
      this.length > fe.length ? de = fe : de = this;
      for (var be = 0; be < de.length; be++)
        this.words[be] = this.words[be] & fe.words[be];
      return this.length = de.length, this._strip();
    }, ie.prototype.iand = function(fe) {
      return te((this.negative | fe.negative) === 0), this.iuand(fe);
    }, ie.prototype.and = function(fe) {
      return this.length > fe.length ? this.clone().iand(fe) : fe.clone().iand(this);
    }, ie.prototype.uand = function(fe) {
      return this.length > fe.length ? this.clone().iuand(fe) : fe.clone().iuand(this);
    }, ie.prototype.iuxor = function(fe) {
      var de, be;
      this.length > fe.length ? (de = this, be = fe) : (de = fe, be = this);
      for (var Te = 0; Te < be.length; Te++)
        this.words[Te] = de.words[Te] ^ be.words[Te];
      if (this !== de)
        for (; Te < de.length; Te++)
          this.words[Te] = de.words[Te];
      return this.length = de.length, this._strip();
    }, ie.prototype.ixor = function(fe) {
      return te((this.negative | fe.negative) === 0), this.iuxor(fe);
    }, ie.prototype.xor = function(fe) {
      return this.length > fe.length ? this.clone().ixor(fe) : fe.clone().ixor(this);
    }, ie.prototype.uxor = function(fe) {
      return this.length > fe.length ? this.clone().iuxor(fe) : fe.clone().iuxor(this);
    }, ie.prototype.inotn = function(fe) {
      te(typeof fe == "number" && fe >= 0);
      var de = Math.ceil(fe / 26) | 0, be = fe % 26;
      this._expand(de), be > 0 && de--;
      for (var Te = 0; Te < de; Te++)
        this.words[Te] = ~this.words[Te] & 67108863;
      return be > 0 && (this.words[Te] = ~this.words[Te] & 67108863 >> 26 - be), this._strip();
    }, ie.prototype.notn = function(fe) {
      return this.clone().inotn(fe);
    }, ie.prototype.setn = function(fe, de) {
      te(typeof fe == "number" && fe >= 0);
      var be = fe / 26 | 0, Te = fe % 26;
      return this._expand(be + 1), de ? this.words[be] = this.words[be] | 1 << Te : this.words[be] = this.words[be] & ~(1 << Te), this._strip();
    }, ie.prototype.iadd = function(fe) {
      var de;
      if (this.negative !== 0 && fe.negative === 0)
        return this.negative = 0, de = this.isub(fe), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && fe.negative !== 0)
        return fe.negative = 0, de = this.isub(fe), fe.negative = 1, de._normSign();
      var be, Te;
      this.length > fe.length ? (be = this, Te = fe) : (be = fe, Te = this);
      for (var Ce = 0, Pe = 0; Pe < Te.length; Pe++)
        de = (be.words[Pe] | 0) + (Te.words[Pe] | 0) + Ce, this.words[Pe] = de & 67108863, Ce = de >>> 26;
      for (; Ce !== 0 && Pe < be.length; Pe++)
        de = (be.words[Pe] | 0) + Ce, this.words[Pe] = de & 67108863, Ce = de >>> 26;
      if (this.length = be.length, Ce !== 0)
        this.words[this.length] = Ce, this.length++;
      else if (be !== this)
        for (; Pe < be.length; Pe++)
          this.words[Pe] = be.words[Pe];
      return this;
    }, ie.prototype.add = function(fe) {
      var de;
      return fe.negative !== 0 && this.negative === 0 ? (fe.negative = 0, de = this.sub(fe), fe.negative ^= 1, de) : fe.negative === 0 && this.negative !== 0 ? (this.negative = 0, de = fe.sub(this), this.negative = 1, de) : this.length > fe.length ? this.clone().iadd(fe) : fe.clone().iadd(this);
    }, ie.prototype.isub = function(fe) {
      if (fe.negative !== 0) {
        fe.negative = 0;
        var de = this.iadd(fe);
        return fe.negative = 1, de._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(fe), this.negative = 1, this._normSign();
      var be = this.cmp(fe);
      if (be === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var Te, Ce;
      be > 0 ? (Te = this, Ce = fe) : (Te = fe, Ce = this);
      for (var Pe = 0, Se = 0; Se < Ce.length; Se++)
        de = (Te.words[Se] | 0) - (Ce.words[Se] | 0) + Pe, Pe = de >> 26, this.words[Se] = de & 67108863;
      for (; Pe !== 0 && Se < Te.length; Se++)
        de = (Te.words[Se] | 0) + Pe, Pe = de >> 26, this.words[Se] = de & 67108863;
      if (Pe === 0 && Se < Te.length && Te !== this)
        for (; Se < Te.length; Se++)
          this.words[Se] = Te.words[Se];
      return this.length = Math.max(this.length, Se), Te !== this && (this.negative = 1), this._strip();
    }, ie.prototype.sub = function(fe) {
      return this.clone().isub(fe);
    };
    function Ue(fe, de, be) {
      be.negative = de.negative ^ fe.negative;
      var Te = fe.length + de.length | 0;
      be.length = Te, Te = Te - 1 | 0;
      var Ce = fe.words[0] | 0, Pe = de.words[0] | 0, Se = Ce * Pe, ke = Se & 67108863, ge = Se / 67108864 | 0;
      be.words[0] = ke;
      for (var Ae = 1; Ae < Te; Ae++) {
        for (var Ge = ge >>> 26, Xe = ge & 67108863, $e = Math.min(Ae, de.length - 1), Ze = Math.max(0, Ae - fe.length + 1); Ze <= $e; Ze++) {
          var ot = Ae - Ze | 0;
          Ce = fe.words[ot] | 0, Pe = de.words[Ze] | 0, Se = Ce * Pe + Xe, Ge += Se / 67108864 | 0, Xe = Se & 67108863;
        }
        be.words[Ae] = Xe | 0, ge = Ge | 0;
      }
      return ge !== 0 ? be.words[Ae] = ge | 0 : be.length--, be._strip();
    }
    var Me = function(fe, de, be) {
      var Te = fe.words, Ce = de.words, Pe = be.words, Se = 0, ke, ge, Ae, Ge = Te[0] | 0, Xe = Ge & 8191, $e = Ge >>> 13, Ze = Te[1] | 0, ot = Ze & 8191, ct = Ze >>> 13, At = Te[2] | 0, Tt = At & 8191, dt = At >>> 13, vt = Te[3] | 0, Ut = vt & 8191, It = vt >>> 13, Er = Te[4] | 0, Fr = Er & 8191, an = Er >>> 13, wX = Te[5] | 0, Ct = wX & 8191, w_ = wX >>> 13, hX = Te[6] | 0, oX = hX & 8191, Nn = hX >>> 13, SX = Te[7] | 0, sX = SX & 8191, nX = SX >>> 13, Ye = Te[8] | 0, lt = Ye & 8191, pt = Ye >>> 13, He = Te[9] | 0, Je = He & 8191, st = He >>> 13, gt = Ce[0] | 0, kt = gt & 8191, Vt = gt >>> 13, Lr = Ce[1] | 0, Ci = Lr & 8191, Qr = Lr >>> 13, xX = Ce[2] | 0, lX = xX & 8191, rX = xX >>> 13, FX = Ce[3] | 0, BX = FX & 8191, cX = FX >>> 13, MX = Ce[4] | 0, EX = MX & 8191, yX = MX >>> 13, jX = Ce[5] | 0, AX = jX & 8191, vX = jX >>> 13, PX = Ce[6] | 0, kX = PX & 8191, qe = PX >>> 13, Qe = Ce[7] | 0, Ve = Qe & 8191, Ie = Qe >>> 13, nt = Ce[8] | 0, Et = nt & 8191, xt = nt >>> 13, Jt = Ce[9] | 0, Yt = Jt & 8191, _r = Jt >>> 13;
      be.negative = fe.negative ^ de.negative, be.length = 19, ke = Math.imul(Xe, kt), ge = Math.imul(Xe, Vt), ge = ge + Math.imul($e, kt) | 0, Ae = Math.imul($e, Vt);
      var cn = (Se + ke | 0) + ((ge & 8191) << 13) | 0;
      Se = (Ae + (ge >>> 13) | 0) + (cn >>> 26) | 0, cn &= 67108863, ke = Math.imul(ot, kt), ge = Math.imul(ot, Vt), ge = ge + Math.imul(ct, kt) | 0, Ae = Math.imul(ct, Vt), ke = ke + Math.imul(Xe, Ci) | 0, ge = ge + Math.imul(Xe, Qr) | 0, ge = ge + Math.imul($e, Ci) | 0, Ae = Ae + Math.imul($e, Qr) | 0;
      var _X = (Se + ke | 0) + ((ge & 8191) << 13) | 0;
      Se = (Ae + (ge >>> 13) | 0) + (_X >>> 26) | 0, _X &= 67108863, ke = Math.imul(Tt, kt), ge = Math.imul(Tt, Vt), ge = ge + Math.imul(dt, kt) | 0, Ae = Math.imul(dt, Vt), ke = ke + Math.imul(ot, Ci) | 0, ge = ge + Math.imul(ot, Qr) | 0, ge = ge + Math.imul(ct, Ci) | 0, Ae = Ae + Math.imul(ct, Qr) | 0, ke = ke + Math.imul(Xe, lX) | 0, ge = ge + Math.imul(Xe, rX) | 0, ge = ge + Math.imul($e, lX) | 0, Ae = Ae + Math.imul($e, rX) | 0;
      var un = (Se + ke | 0) + ((ge & 8191) << 13) | 0;
      Se = (Ae + (ge >>> 13) | 0) + (un >>> 26) | 0, un &= 67108863, ke = Math.imul(Ut, kt), ge = Math.imul(Ut, Vt), ge = ge + Math.imul(It, kt) | 0, Ae = Math.imul(It, Vt), ke = ke + Math.imul(Tt, Ci) | 0, ge = ge + Math.imul(Tt, Qr) | 0, ge = ge + Math.imul(dt, Ci) | 0, Ae = Ae + Math.imul(dt, Qr) | 0, ke = ke + Math.imul(ot, lX) | 0, ge = ge + Math.imul(ot, rX) | 0, ge = ge + Math.imul(ct, lX) | 0, Ae = Ae + Math.imul(ct, rX) | 0, ke = ke + Math.imul(Xe, BX) | 0, ge = ge + Math.imul(Xe, cX) | 0, ge = ge + Math.imul($e, BX) | 0, Ae = Ae + Math.imul($e, cX) | 0;
      var aX = (Se + ke | 0) + ((ge & 8191) << 13) | 0;
      Se = (Ae + (ge >>> 13) | 0) + (aX >>> 26) | 0, aX &= 67108863, ke = Math.imul(Fr, kt), ge = Math.imul(Fr, Vt), ge = ge + Math.imul(an, kt) | 0, Ae = Math.imul(an, Vt), ke = ke + Math.imul(Ut, Ci) | 0, ge = ge + Math.imul(Ut, Qr) | 0, ge = ge + Math.imul(It, Ci) | 0, Ae = Ae + Math.imul(It, Qr) | 0, ke = ke + Math.imul(Tt, lX) | 0, ge = ge + Math.imul(Tt, rX) | 0, ge = ge + Math.imul(dt, lX) | 0, Ae = Ae + Math.imul(dt, rX) | 0, ke = ke + Math.imul(ot, BX) | 0, ge = ge + Math.imul(ot, cX) | 0, ge = ge + Math.imul(ct, BX) | 0, Ae = Ae + Math.imul(ct, cX) | 0, ke = ke + Math.imul(Xe, EX) | 0, ge = ge + Math.imul(Xe, yX) | 0, ge = ge + Math.imul($e, EX) | 0, Ae = Ae + Math.imul($e, yX) | 0;
      var uX = (Se + ke | 0) + ((ge & 8191) << 13) | 0;
      Se = (Ae + (ge >>> 13) | 0) + (uX >>> 26) | 0, uX &= 67108863, ke = Math.imul(Ct, kt), ge = Math.imul(Ct, Vt), ge = ge + Math.imul(w_, kt) | 0, Ae = Math.imul(w_, Vt), ke = ke + Math.imul(Fr, Ci) | 0, ge = ge + Math.imul(Fr, Qr) | 0, ge = ge + Math.imul(an, Ci) | 0, Ae = Ae + Math.imul(an, Qr) | 0, ke = ke + Math.imul(Ut, lX) | 0, ge = ge + Math.imul(Ut, rX) | 0, ge = ge + Math.imul(It, lX) | 0, Ae = Ae + Math.imul(It, rX) | 0, ke = ke + Math.imul(Tt, BX) | 0, ge = ge + Math.imul(Tt, cX) | 0, ge = ge + Math.imul(dt, BX) | 0, Ae = Ae + Math.imul(dt, cX) | 0, ke = ke + Math.imul(ot, EX) | 0, ge = ge + Math.imul(ot, yX) | 0, ge = ge + Math.imul(ct, EX) | 0, Ae = Ae + Math.imul(ct, yX) | 0, ke = ke + Math.imul(Xe, AX) | 0, ge = ge + Math.imul(Xe, vX) | 0, ge = ge + Math.imul($e, AX) | 0, Ae = Ae + Math.imul($e, vX) | 0;
      var fX = (Se + ke | 0) + ((ge & 8191) << 13) | 0;
      Se = (Ae + (ge >>> 13) | 0) + (fX >>> 26) | 0, fX &= 67108863, ke = Math.imul(oX, kt), ge = Math.imul(oX, Vt), ge = ge + Math.imul(Nn, kt) | 0, Ae = Math.imul(Nn, Vt), ke = ke + Math.imul(Ct, Ci) | 0, ge = ge + Math.imul(Ct, Qr) | 0, ge = ge + Math.imul(w_, Ci) | 0, Ae = Ae + Math.imul(w_, Qr) | 0, ke = ke + Math.imul(Fr, lX) | 0, ge = ge + Math.imul(Fr, rX) | 0, ge = ge + Math.imul(an, lX) | 0, Ae = Ae + Math.imul(an, rX) | 0, ke = ke + Math.imul(Ut, BX) | 0, ge = ge + Math.imul(Ut, cX) | 0, ge = ge + Math.imul(It, BX) | 0, Ae = Ae + Math.imul(It, cX) | 0, ke = ke + Math.imul(Tt, EX) | 0, ge = ge + Math.imul(Tt, yX) | 0, ge = ge + Math.imul(dt, EX) | 0, Ae = Ae + Math.imul(dt, yX) | 0, ke = ke + Math.imul(ot, AX) | 0, ge = ge + Math.imul(ot, vX) | 0, ge = ge + Math.imul(ct, AX) | 0, Ae = Ae + Math.imul(ct, vX) | 0, ke = ke + Math.imul(Xe, kX) | 0, ge = ge + Math.imul(Xe, qe) | 0, ge = ge + Math.imul($e, kX) | 0, Ae = Ae + Math.imul($e, qe) | 0;
      var bX = (Se + ke | 0) + ((ge & 8191) << 13) | 0;
      Se = (Ae + (ge >>> 13) | 0) + (bX >>> 26) | 0, bX &= 67108863, ke = Math.imul(sX, kt), ge = Math.imul(sX, Vt), ge = ge + Math.imul(nX, kt) | 0, Ae = Math.imul(nX, Vt), ke = ke + Math.imul(oX, Ci) | 0, ge = ge + Math.imul(oX, Qr) | 0, ge = ge + Math.imul(Nn, Ci) | 0, Ae = Ae + Math.imul(Nn, Qr) | 0, ke = ke + Math.imul(Ct, lX) | 0, ge = ge + Math.imul(Ct, rX) | 0, ge = ge + Math.imul(w_, lX) | 0, Ae = Ae + Math.imul(w_, rX) | 0, ke = ke + Math.imul(Fr, BX) | 0, ge = ge + Math.imul(Fr, cX) | 0, ge = ge + Math.imul(an, BX) | 0, Ae = Ae + Math.imul(an, cX) | 0, ke = ke + Math.imul(Ut, EX) | 0, ge = ge + Math.imul(Ut, yX) | 0, ge = ge + Math.imul(It, EX) | 0, Ae = Ae + Math.imul(It, yX) | 0, ke = ke + Math.imul(Tt, AX) | 0, ge = ge + Math.imul(Tt, vX) | 0, ge = ge + Math.imul(dt, AX) | 0, Ae = Ae + Math.imul(dt, vX) | 0, ke = ke + Math.imul(ot, kX) | 0, ge = ge + Math.imul(ot, qe) | 0, ge = ge + Math.imul(ct, kX) | 0, Ae = Ae + Math.imul(ct, qe) | 0, ke = ke + Math.imul(Xe, Ve) | 0, ge = ge + Math.imul(Xe, Ie) | 0, ge = ge + Math.imul($e, Ve) | 0, Ae = Ae + Math.imul($e, Ie) | 0;
      var dX = (Se + ke | 0) + ((ge & 8191) << 13) | 0;
      Se = (Ae + (ge >>> 13) | 0) + (dX >>> 26) | 0, dX &= 67108863, ke = Math.imul(lt, kt), ge = Math.imul(lt, Vt), ge = ge + Math.imul(pt, kt) | 0, Ae = Math.imul(pt, Vt), ke = ke + Math.imul(sX, Ci) | 0, ge = ge + Math.imul(sX, Qr) | 0, ge = ge + Math.imul(nX, Ci) | 0, Ae = Ae + Math.imul(nX, Qr) | 0, ke = ke + Math.imul(oX, lX) | 0, ge = ge + Math.imul(oX, rX) | 0, ge = ge + Math.imul(Nn, lX) | 0, Ae = Ae + Math.imul(Nn, rX) | 0, ke = ke + Math.imul(Ct, BX) | 0, ge = ge + Math.imul(Ct, cX) | 0, ge = ge + Math.imul(w_, BX) | 0, Ae = Ae + Math.imul(w_, cX) | 0, ke = ke + Math.imul(Fr, EX) | 0, ge = ge + Math.imul(Fr, yX) | 0, ge = ge + Math.imul(an, EX) | 0, Ae = Ae + Math.imul(an, yX) | 0, ke = ke + Math.imul(Ut, AX) | 0, ge = ge + Math.imul(Ut, vX) | 0, ge = ge + Math.imul(It, AX) | 0, Ae = Ae + Math.imul(It, vX) | 0, ke = ke + Math.imul(Tt, kX) | 0, ge = ge + Math.imul(Tt, qe) | 0, ge = ge + Math.imul(dt, kX) | 0, Ae = Ae + Math.imul(dt, qe) | 0, ke = ke + Math.imul(ot, Ve) | 0, ge = ge + Math.imul(ot, Ie) | 0, ge = ge + Math.imul(ct, Ve) | 0, Ae = Ae + Math.imul(ct, Ie) | 0, ke = ke + Math.imul(Xe, Et) | 0, ge = ge + Math.imul(Xe, xt) | 0, ge = ge + Math.imul($e, Et) | 0, Ae = Ae + Math.imul($e, xt) | 0;
      var mX = (Se + ke | 0) + ((ge & 8191) << 13) | 0;
      Se = (Ae + (ge >>> 13) | 0) + (mX >>> 26) | 0, mX &= 67108863, ke = Math.imul(Je, kt), ge = Math.imul(Je, Vt), ge = ge + Math.imul(st, kt) | 0, Ae = Math.imul(st, Vt), ke = ke + Math.imul(lt, Ci) | 0, ge = ge + Math.imul(lt, Qr) | 0, ge = ge + Math.imul(pt, Ci) | 0, Ae = Ae + Math.imul(pt, Qr) | 0, ke = ke + Math.imul(sX, lX) | 0, ge = ge + Math.imul(sX, rX) | 0, ge = ge + Math.imul(nX, lX) | 0, Ae = Ae + Math.imul(nX, rX) | 0, ke = ke + Math.imul(oX, BX) | 0, ge = ge + Math.imul(oX, cX) | 0, ge = ge + Math.imul(Nn, BX) | 0, Ae = Ae + Math.imul(Nn, cX) | 0, ke = ke + Math.imul(Ct, EX) | 0, ge = ge + Math.imul(Ct, yX) | 0, ge = ge + Math.imul(w_, EX) | 0, Ae = Ae + Math.imul(w_, yX) | 0, ke = ke + Math.imul(Fr, AX) | 0, ge = ge + Math.imul(Fr, vX) | 0, ge = ge + Math.imul(an, AX) | 0, Ae = Ae + Math.imul(an, vX) | 0, ke = ke + Math.imul(Ut, kX) | 0, ge = ge + Math.imul(Ut, qe) | 0, ge = ge + Math.imul(It, kX) | 0, Ae = Ae + Math.imul(It, qe) | 0, ke = ke + Math.imul(Tt, Ve) | 0, ge = ge + Math.imul(Tt, Ie) | 0, ge = ge + Math.imul(dt, Ve) | 0, Ae = Ae + Math.imul(dt, Ie) | 0, ke = ke + Math.imul(ot, Et) | 0, ge = ge + Math.imul(ot, xt) | 0, ge = ge + Math.imul(ct, Et) | 0, Ae = Ae + Math.imul(ct, xt) | 0, ke = ke + Math.imul(Xe, Yt) | 0, ge = ge + Math.imul(Xe, _r) | 0, ge = ge + Math.imul($e, Yt) | 0, Ae = Ae + Math.imul($e, _r) | 0;
      var pX = (Se + ke | 0) + ((ge & 8191) << 13) | 0;
      Se = (Ae + (ge >>> 13) | 0) + (pX >>> 26) | 0, pX &= 67108863, ke = Math.imul(Je, Ci), ge = Math.imul(Je, Qr), ge = ge + Math.imul(st, Ci) | 0, Ae = Math.imul(st, Qr), ke = ke + Math.imul(lt, lX) | 0, ge = ge + Math.imul(lt, rX) | 0, ge = ge + Math.imul(pt, lX) | 0, Ae = Ae + Math.imul(pt, rX) | 0, ke = ke + Math.imul(sX, BX) | 0, ge = ge + Math.imul(sX, cX) | 0, ge = ge + Math.imul(nX, BX) | 0, Ae = Ae + Math.imul(nX, cX) | 0, ke = ke + Math.imul(oX, EX) | 0, ge = ge + Math.imul(oX, yX) | 0, ge = ge + Math.imul(Nn, EX) | 0, Ae = Ae + Math.imul(Nn, yX) | 0, ke = ke + Math.imul(Ct, AX) | 0, ge = ge + Math.imul(Ct, vX) | 0, ge = ge + Math.imul(w_, AX) | 0, Ae = Ae + Math.imul(w_, vX) | 0, ke = ke + Math.imul(Fr, kX) | 0, ge = ge + Math.imul(Fr, qe) | 0, ge = ge + Math.imul(an, kX) | 0, Ae = Ae + Math.imul(an, qe) | 0, ke = ke + Math.imul(Ut, Ve) | 0, ge = ge + Math.imul(Ut, Ie) | 0, ge = ge + Math.imul(It, Ve) | 0, Ae = Ae + Math.imul(It, Ie) | 0, ke = ke + Math.imul(Tt, Et) | 0, ge = ge + Math.imul(Tt, xt) | 0, ge = ge + Math.imul(dt, Et) | 0, Ae = Ae + Math.imul(dt, xt) | 0, ke = ke + Math.imul(ot, Yt) | 0, ge = ge + Math.imul(ot, _r) | 0, ge = ge + Math.imul(ct, Yt) | 0, Ae = Ae + Math.imul(ct, _r) | 0;
      var G_ = (Se + ke | 0) + ((ge & 8191) << 13) | 0;
      Se = (Ae + (ge >>> 13) | 0) + (G_ >>> 26) | 0, G_ &= 67108863, ke = Math.imul(Je, lX), ge = Math.imul(Je, rX), ge = ge + Math.imul(st, lX) | 0, Ae = Math.imul(st, rX), ke = ke + Math.imul(lt, BX) | 0, ge = ge + Math.imul(lt, cX) | 0, ge = ge + Math.imul(pt, BX) | 0, Ae = Ae + Math.imul(pt, cX) | 0, ke = ke + Math.imul(sX, EX) | 0, ge = ge + Math.imul(sX, yX) | 0, ge = ge + Math.imul(nX, EX) | 0, Ae = Ae + Math.imul(nX, yX) | 0, ke = ke + Math.imul(oX, AX) | 0, ge = ge + Math.imul(oX, vX) | 0, ge = ge + Math.imul(Nn, AX) | 0, Ae = Ae + Math.imul(Nn, vX) | 0, ke = ke + Math.imul(Ct, kX) | 0, ge = ge + Math.imul(Ct, qe) | 0, ge = ge + Math.imul(w_, kX) | 0, Ae = Ae + Math.imul(w_, qe) | 0, ke = ke + Math.imul(Fr, Ve) | 0, ge = ge + Math.imul(Fr, Ie) | 0, ge = ge + Math.imul(an, Ve) | 0, Ae = Ae + Math.imul(an, Ie) | 0, ke = ke + Math.imul(Ut, Et) | 0, ge = ge + Math.imul(Ut, xt) | 0, ge = ge + Math.imul(It, Et) | 0, Ae = Ae + Math.imul(It, xt) | 0, ke = ke + Math.imul(Tt, Yt) | 0, ge = ge + Math.imul(Tt, _r) | 0, ge = ge + Math.imul(dt, Yt) | 0, Ae = Ae + Math.imul(dt, _r) | 0;
      var iX = (Se + ke | 0) + ((ge & 8191) << 13) | 0;
      Se = (Ae + (ge >>> 13) | 0) + (iX >>> 26) | 0, iX &= 67108863, ke = Math.imul(Je, BX), ge = Math.imul(Je, cX), ge = ge + Math.imul(st, BX) | 0, Ae = Math.imul(st, cX), ke = ke + Math.imul(lt, EX) | 0, ge = ge + Math.imul(lt, yX) | 0, ge = ge + Math.imul(pt, EX) | 0, Ae = Ae + Math.imul(pt, yX) | 0, ke = ke + Math.imul(sX, AX) | 0, ge = ge + Math.imul(sX, vX) | 0, ge = ge + Math.imul(nX, AX) | 0, Ae = Ae + Math.imul(nX, vX) | 0, ke = ke + Math.imul(oX, kX) | 0, ge = ge + Math.imul(oX, qe) | 0, ge = ge + Math.imul(Nn, kX) | 0, Ae = Ae + Math.imul(Nn, qe) | 0, ke = ke + Math.imul(Ct, Ve) | 0, ge = ge + Math.imul(Ct, Ie) | 0, ge = ge + Math.imul(w_, Ve) | 0, Ae = Ae + Math.imul(w_, Ie) | 0, ke = ke + Math.imul(Fr, Et) | 0, ge = ge + Math.imul(Fr, xt) | 0, ge = ge + Math.imul(an, Et) | 0, Ae = Ae + Math.imul(an, xt) | 0, ke = ke + Math.imul(Ut, Yt) | 0, ge = ge + Math.imul(Ut, _r) | 0, ge = ge + Math.imul(It, Yt) | 0, Ae = Ae + Math.imul(It, _r) | 0;
      var og = (Se + ke | 0) + ((ge & 8191) << 13) | 0;
      Se = (Ae + (ge >>> 13) | 0) + (og >>> 26) | 0, og &= 67108863, ke = Math.imul(Je, EX), ge = Math.imul(Je, yX), ge = ge + Math.imul(st, EX) | 0, Ae = Math.imul(st, yX), ke = ke + Math.imul(lt, AX) | 0, ge = ge + Math.imul(lt, vX) | 0, ge = ge + Math.imul(pt, AX) | 0, Ae = Ae + Math.imul(pt, vX) | 0, ke = ke + Math.imul(sX, kX) | 0, ge = ge + Math.imul(sX, qe) | 0, ge = ge + Math.imul(nX, kX) | 0, Ae = Ae + Math.imul(nX, qe) | 0, ke = ke + Math.imul(oX, Ve) | 0, ge = ge + Math.imul(oX, Ie) | 0, ge = ge + Math.imul(Nn, Ve) | 0, Ae = Ae + Math.imul(Nn, Ie) | 0, ke = ke + Math.imul(Ct, Et) | 0, ge = ge + Math.imul(Ct, xt) | 0, ge = ge + Math.imul(w_, Et) | 0, Ae = Ae + Math.imul(w_, xt) | 0, ke = ke + Math.imul(Fr, Yt) | 0, ge = ge + Math.imul(Fr, _r) | 0, ge = ge + Math.imul(an, Yt) | 0, Ae = Ae + Math.imul(an, _r) | 0;
      var eX = (Se + ke | 0) + ((ge & 8191) << 13) | 0;
      Se = (Ae + (ge >>> 13) | 0) + (eX >>> 26) | 0, eX &= 67108863, ke = Math.imul(Je, AX), ge = Math.imul(Je, vX), ge = ge + Math.imul(st, AX) | 0, Ae = Math.imul(st, vX), ke = ke + Math.imul(lt, kX) | 0, ge = ge + Math.imul(lt, qe) | 0, ge = ge + Math.imul(pt, kX) | 0, Ae = Ae + Math.imul(pt, qe) | 0, ke = ke + Math.imul(sX, Ve) | 0, ge = ge + Math.imul(sX, Ie) | 0, ge = ge + Math.imul(nX, Ve) | 0, Ae = Ae + Math.imul(nX, Ie) | 0, ke = ke + Math.imul(oX, Et) | 0, ge = ge + Math.imul(oX, xt) | 0, ge = ge + Math.imul(Nn, Et) | 0, Ae = Ae + Math.imul(Nn, xt) | 0, ke = ke + Math.imul(Ct, Yt) | 0, ge = ge + Math.imul(Ct, _r) | 0, ge = ge + Math.imul(w_, Yt) | 0, Ae = Ae + Math.imul(w_, _r) | 0;
      var tX = (Se + ke | 0) + ((ge & 8191) << 13) | 0;
      Se = (Ae + (ge >>> 13) | 0) + (tX >>> 26) | 0, tX &= 67108863, ke = Math.imul(Je, kX), ge = Math.imul(Je, qe), ge = ge + Math.imul(st, kX) | 0, Ae = Math.imul(st, qe), ke = ke + Math.imul(lt, Ve) | 0, ge = ge + Math.imul(lt, Ie) | 0, ge = ge + Math.imul(pt, Ve) | 0, Ae = Ae + Math.imul(pt, Ie) | 0, ke = ke + Math.imul(sX, Et) | 0, ge = ge + Math.imul(sX, xt) | 0, ge = ge + Math.imul(nX, Et) | 0, Ae = Ae + Math.imul(nX, xt) | 0, ke = ke + Math.imul(oX, Yt) | 0, ge = ge + Math.imul(oX, _r) | 0, ge = ge + Math.imul(Nn, Yt) | 0, Ae = Ae + Math.imul(Nn, _r) | 0;
      var An = (Se + ke | 0) + ((ge & 8191) << 13) | 0;
      Se = (Ae + (ge >>> 13) | 0) + (An >>> 26) | 0, An &= 67108863, ke = Math.imul(Je, Ve), ge = Math.imul(Je, Ie), ge = ge + Math.imul(st, Ve) | 0, Ae = Math.imul(st, Ie), ke = ke + Math.imul(lt, Et) | 0, ge = ge + Math.imul(lt, xt) | 0, ge = ge + Math.imul(pt, Et) | 0, Ae = Ae + Math.imul(pt, xt) | 0, ke = ke + Math.imul(sX, Yt) | 0, ge = ge + Math.imul(sX, _r) | 0, ge = ge + Math.imul(nX, Yt) | 0, Ae = Ae + Math.imul(nX, _r) | 0;
      var Gt = (Se + ke | 0) + ((ge & 8191) << 13) | 0;
      Se = (Ae + (ge >>> 13) | 0) + (Gt >>> 26) | 0, Gt &= 67108863, ke = Math.imul(Je, Et), ge = Math.imul(Je, xt), ge = ge + Math.imul(st, Et) | 0, Ae = Math.imul(st, xt), ke = ke + Math.imul(lt, Yt) | 0, ge = ge + Math.imul(lt, _r) | 0, ge = ge + Math.imul(pt, Yt) | 0, Ae = Ae + Math.imul(pt, _r) | 0;
      var Wt = (Se + ke | 0) + ((ge & 8191) << 13) | 0;
      Se = (Ae + (ge >>> 13) | 0) + (Wt >>> 26) | 0, Wt &= 67108863, ke = Math.imul(Je, Yt), ge = Math.imul(Je, _r), ge = ge + Math.imul(st, Yt) | 0, Ae = Math.imul(st, _r);
      var vr = (Se + ke | 0) + ((ge & 8191) << 13) | 0;
      return Se = (Ae + (ge >>> 13) | 0) + (vr >>> 26) | 0, vr &= 67108863, Pe[0] = cn, Pe[1] = _X, Pe[2] = un, Pe[3] = aX, Pe[4] = uX, Pe[5] = fX, Pe[6] = bX, Pe[7] = dX, Pe[8] = mX, Pe[9] = pX, Pe[10] = G_, Pe[11] = iX, Pe[12] = og, Pe[13] = eX, Pe[14] = tX, Pe[15] = An, Pe[16] = Gt, Pe[17] = Wt, Pe[18] = vr, Se !== 0 && (Pe[19] = Se, be.length++), be;
    };
    Math.imul || (Me = Ue);
    function De(fe, de, be) {
      be.negative = de.negative ^ fe.negative, be.length = fe.length + de.length;
      for (var Te = 0, Ce = 0, Pe = 0; Pe < be.length - 1; Pe++) {
        var Se = Ce;
        Ce = 0;
        for (var ke = Te & 67108863, ge = Math.min(Pe, de.length - 1), Ae = Math.max(0, Pe - fe.length + 1); Ae <= ge; Ae++) {
          var Ge = Pe - Ae, Xe = fe.words[Ge] | 0, $e = de.words[Ae] | 0, Ze = Xe * $e, ot = Ze & 67108863;
          Se = Se + (Ze / 67108864 | 0) | 0, ot = ot + ke | 0, ke = ot & 67108863, Se = Se + (ot >>> 26) | 0, Ce += Se >>> 26, Se &= 67108863;
        }
        be.words[Pe] = ke, Te = Se, Se = Ce;
      }
      return Te !== 0 ? be.words[Pe] = Te : be.length--, be._strip();
    }
    function Fe(fe, de, be) {
      return De(fe, de, be);
    }
    ie.prototype.mulTo = function(fe, de) {
      var be, Te = this.length + fe.length;
      return this.length === 10 && fe.length === 10 ? be = Me(this, fe, de) : Te < 63 ? be = Ue(this, fe, de) : Te < 1024 ? be = De(this, fe, de) : be = Fe(this, fe, de), be;
    }, ie.prototype.mul = function(fe) {
      var de = new ie(null);
      return de.words = new Array(this.length + fe.length), this.mulTo(fe, de);
    }, ie.prototype.mulf = function(fe) {
      var de = new ie(null);
      return de.words = new Array(this.length + fe.length), Fe(this, fe, de);
    }, ie.prototype.imul = function(fe) {
      return this.clone().mulTo(fe, this);
    }, ie.prototype.imuln = function(fe) {
      var de = fe < 0;
      de && (fe = -fe), te(typeof fe == "number"), te(fe < 67108864);
      for (var be = 0, Te = 0; Te < this.length; Te++) {
        var Ce = (this.words[Te] | 0) * fe, Pe = (Ce & 67108863) + (be & 67108863);
        be >>= 26, be += Ce / 67108864 | 0, be += Pe >>> 26, this.words[Te] = Pe & 67108863;
      }
      return be !== 0 && (this.words[Te] = be, this.length++), de ? this.ineg() : this;
    }, ie.prototype.muln = function(fe) {
      return this.clone().imuln(fe);
    }, ie.prototype.sqr = function() {
      return this.mul(this);
    }, ie.prototype.isqr = function() {
      return this.imul(this.clone());
    }, ie.prototype.pow = function(fe) {
      var de = Re(fe);
      if (de.length === 0)
        return new ie(1);
      for (var be = this, Te = 0; Te < de.length && de[Te] === 0; Te++, be = be.sqr())
        ;
      if (++Te < de.length)
        for (var Ce = be.sqr(); Te < de.length; Te++, Ce = Ce.sqr())
          de[Te] !== 0 && (be = be.mul(Ce));
      return be;
    }, ie.prototype.iushln = function(fe) {
      te(typeof fe == "number" && fe >= 0);
      var de = fe % 26, be = (fe - de) / 26, Te = 67108863 >>> 26 - de << 26 - de, Ce;
      if (de !== 0) {
        var Pe = 0;
        for (Ce = 0; Ce < this.length; Ce++) {
          var Se = this.words[Ce] & Te, ke = (this.words[Ce] | 0) - Se << de;
          this.words[Ce] = ke | Pe, Pe = Se >>> 26 - de;
        }
        Pe && (this.words[Ce] = Pe, this.length++);
      }
      if (be !== 0) {
        for (Ce = this.length - 1; Ce >= 0; Ce--)
          this.words[Ce + be] = this.words[Ce];
        for (Ce = 0; Ce < be; Ce++)
          this.words[Ce] = 0;
        this.length += be;
      }
      return this._strip();
    }, ie.prototype.ishln = function(fe) {
      return te(this.negative === 0), this.iushln(fe);
    }, ie.prototype.iushrn = function(fe, de, be) {
      te(typeof fe == "number" && fe >= 0);
      var Te;
      de ? Te = (de - de % 26) / 26 : Te = 0;
      var Ce = fe % 26, Pe = Math.min((fe - Ce) / 26, this.length), Se = 67108863 ^ 67108863 >>> Ce << Ce, ke = be;
      if (Te -= Pe, Te = Math.max(0, Te), ke) {
        for (var ge = 0; ge < Pe; ge++)
          ke.words[ge] = this.words[ge];
        ke.length = Pe;
      }
      if (Pe !== 0)
        if (this.length > Pe)
          for (this.length -= Pe, ge = 0; ge < this.length; ge++)
            this.words[ge] = this.words[ge + Pe];
        else
          this.words[0] = 0, this.length = 1;
      var Ae = 0;
      for (ge = this.length - 1; ge >= 0 && (Ae !== 0 || ge >= Te); ge--) {
        var Ge = this.words[ge] | 0;
        this.words[ge] = Ae << 26 - Ce | Ge >>> Ce, Ae = Ge & Se;
      }
      return ke && Ae !== 0 && (ke.words[ke.length++] = Ae), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
    }, ie.prototype.ishrn = function(fe, de, be) {
      return te(this.negative === 0), this.iushrn(fe, de, be);
    }, ie.prototype.shln = function(fe) {
      return this.clone().ishln(fe);
    }, ie.prototype.ushln = function(fe) {
      return this.clone().iushln(fe);
    }, ie.prototype.shrn = function(fe) {
      return this.clone().ishrn(fe);
    }, ie.prototype.ushrn = function(fe) {
      return this.clone().iushrn(fe);
    }, ie.prototype.testn = function(fe) {
      te(typeof fe == "number" && fe >= 0);
      var de = fe % 26, be = (fe - de) / 26, Te = 1 << de;
      if (this.length <= be)
        return !1;
      var Ce = this.words[be];
      return !!(Ce & Te);
    }, ie.prototype.imaskn = function(fe) {
      te(typeof fe == "number" && fe >= 0);
      var de = fe % 26, be = (fe - de) / 26;
      if (te(this.negative === 0, "imaskn works only with positive numbers"), this.length <= be)
        return this;
      if (de !== 0 && be++, this.length = Math.min(be, this.length), de !== 0) {
        var Te = 67108863 ^ 67108863 >>> de << de;
        this.words[this.length - 1] &= Te;
      }
      return this._strip();
    }, ie.prototype.maskn = function(fe) {
      return this.clone().imaskn(fe);
    }, ie.prototype.iaddn = function(fe) {
      return te(typeof fe == "number"), te(fe < 67108864), fe < 0 ? this.isubn(-fe) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= fe ? (this.words[0] = fe - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(fe), this.negative = 1, this) : this._iaddn(fe);
    }, ie.prototype._iaddn = function(fe) {
      this.words[0] += fe;
      for (var de = 0; de < this.length && this.words[de] >= 67108864; de++)
        this.words[de] -= 67108864, de === this.length - 1 ? this.words[de + 1] = 1 : this.words[de + 1]++;
      return this.length = Math.max(this.length, de + 1), this;
    }, ie.prototype.isubn = function(fe) {
      if (te(typeof fe == "number"), te(fe < 67108864), fe < 0)
        return this.iaddn(-fe);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(fe), this.negative = 1, this;
      if (this.words[0] -= fe, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var de = 0; de < this.length && this.words[de] < 0; de++)
          this.words[de] += 67108864, this.words[de + 1] -= 1;
      return this._strip();
    }, ie.prototype.addn = function(fe) {
      return this.clone().iaddn(fe);
    }, ie.prototype.subn = function(fe) {
      return this.clone().isubn(fe);
    }, ie.prototype.iabs = function() {
      return this.negative = 0, this;
    }, ie.prototype.abs = function() {
      return this.clone().iabs();
    }, ie.prototype._ishlnsubmul = function(fe, de, be) {
      var Te = fe.length + be, Ce;
      this._expand(Te);
      var Pe, Se = 0;
      for (Ce = 0; Ce < fe.length; Ce++) {
        Pe = (this.words[Ce + be] | 0) + Se;
        var ke = (fe.words[Ce] | 0) * de;
        Pe -= ke & 67108863, Se = (Pe >> 26) - (ke / 67108864 | 0), this.words[Ce + be] = Pe & 67108863;
      }
      for (; Ce < this.length - be; Ce++)
        Pe = (this.words[Ce + be] | 0) + Se, Se = Pe >> 26, this.words[Ce + be] = Pe & 67108863;
      if (Se === 0)
        return this._strip();
      for (te(Se === -1), Se = 0, Ce = 0; Ce < this.length; Ce++)
        Pe = -(this.words[Ce] | 0) + Se, Se = Pe >> 26, this.words[Ce] = Pe & 67108863;
      return this.negative = 1, this._strip();
    }, ie.prototype._wordDiv = function(fe, de) {
      var be = this.length - fe.length, Te = this.clone(), Ce = fe, Pe = Ce.words[Ce.length - 1] | 0, Se = this._countBits(Pe);
      be = 26 - Se, be !== 0 && (Ce = Ce.ushln(be), Te.iushln(be), Pe = Ce.words[Ce.length - 1] | 0);
      var ke = Te.length - Ce.length, ge;
      if (de !== "mod") {
        ge = new ie(null), ge.length = ke + 1, ge.words = new Array(ge.length);
        for (var Ae = 0; Ae < ge.length; Ae++)
          ge.words[Ae] = 0;
      }
      var Ge = Te.clone()._ishlnsubmul(Ce, 1, ke);
      Ge.negative === 0 && (Te = Ge, ge && (ge.words[ke] = 1));
      for (var Xe = ke - 1; Xe >= 0; Xe--) {
        var $e = (Te.words[Ce.length + Xe] | 0) * 67108864 + (Te.words[Ce.length + Xe - 1] | 0);
        for ($e = Math.min($e / Pe | 0, 67108863), Te._ishlnsubmul(Ce, $e, Xe); Te.negative !== 0; )
          $e--, Te.negative = 0, Te._ishlnsubmul(Ce, 1, Xe), Te.isZero() || (Te.negative ^= 1);
        ge && (ge.words[Xe] = $e);
      }
      return ge && ge._strip(), Te._strip(), de !== "div" && be !== 0 && Te.iushrn(be), {
        div: ge || null,
        mod: Te
      };
    }, ie.prototype.divmod = function(fe, de, be) {
      if (te(!fe.isZero()), this.isZero())
        return {
          div: new ie(0),
          mod: new ie(0)
        };
      var Te, Ce, Pe;
      return this.negative !== 0 && fe.negative === 0 ? (Pe = this.neg().divmod(fe, de), de !== "mod" && (Te = Pe.div.neg()), de !== "div" && (Ce = Pe.mod.neg(), be && Ce.negative !== 0 && Ce.iadd(fe)), {
        div: Te,
        mod: Ce
      }) : this.negative === 0 && fe.negative !== 0 ? (Pe = this.divmod(fe.neg(), de), de !== "mod" && (Te = Pe.div.neg()), {
        div: Te,
        mod: Pe.mod
      }) : this.negative & fe.negative ? (Pe = this.neg().divmod(fe.neg(), de), de !== "div" && (Ce = Pe.mod.neg(), be && Ce.negative !== 0 && Ce.isub(fe)), {
        div: Pe.div,
        mod: Ce
      }) : fe.length > this.length || this.cmp(fe) < 0 ? {
        div: new ie(0),
        mod: this
      } : fe.length === 1 ? de === "div" ? {
        div: this.divn(fe.words[0]),
        mod: null
      } : de === "mod" ? {
        div: null,
        mod: new ie(this.modrn(fe.words[0]))
      } : {
        div: this.divn(fe.words[0]),
        mod: new ie(this.modrn(fe.words[0]))
      } : this._wordDiv(fe, de);
    }, ie.prototype.div = function(fe) {
      return this.divmod(fe, "div", !1).div;
    }, ie.prototype.mod = function(fe) {
      return this.divmod(fe, "mod", !1).mod;
    }, ie.prototype.umod = function(fe) {
      return this.divmod(fe, "mod", !0).mod;
    }, ie.prototype.divRound = function(fe) {
      var de = this.divmod(fe);
      if (de.mod.isZero())
        return de.div;
      var be = de.div.negative !== 0 ? de.mod.isub(fe) : de.mod, Te = fe.ushrn(1), Ce = fe.andln(1), Pe = be.cmp(Te);
      return Pe < 0 || Ce === 1 && Pe === 0 ? de.div : de.div.negative !== 0 ? de.div.isubn(1) : de.div.iaddn(1);
    }, ie.prototype.modrn = function(fe) {
      var de = fe < 0;
      de && (fe = -fe), te(fe <= 67108863);
      for (var be = (1 << 26) % fe, Te = 0, Ce = this.length - 1; Ce >= 0; Ce--)
        Te = (be * Te + (this.words[Ce] | 0)) % fe;
      return de ? -Te : Te;
    }, ie.prototype.modn = function(fe) {
      return this.modrn(fe);
    }, ie.prototype.idivn = function(fe) {
      var de = fe < 0;
      de && (fe = -fe), te(fe <= 67108863);
      for (var be = 0, Te = this.length - 1; Te >= 0; Te--) {
        var Ce = (this.words[Te] | 0) + be * 67108864;
        this.words[Te] = Ce / fe | 0, be = Ce % fe;
      }
      return this._strip(), de ? this.ineg() : this;
    }, ie.prototype.divn = function(fe) {
      return this.clone().idivn(fe);
    }, ie.prototype.egcd = function(fe) {
      te(fe.negative === 0), te(!fe.isZero());
      var de = this, be = fe.clone();
      de.negative !== 0 ? de = de.umod(fe) : de = de.clone();
      for (var Te = new ie(1), Ce = new ie(0), Pe = new ie(0), Se = new ie(1), ke = 0; de.isEven() && be.isEven(); )
        de.iushrn(1), be.iushrn(1), ++ke;
      for (var ge = be.clone(), Ae = de.clone(); !de.isZero(); ) {
        for (var Ge = 0, Xe = 1; !(de.words[0] & Xe) && Ge < 26; ++Ge, Xe <<= 1)
          ;
        if (Ge > 0)
          for (de.iushrn(Ge); Ge-- > 0; )
            (Te.isOdd() || Ce.isOdd()) && (Te.iadd(ge), Ce.isub(Ae)), Te.iushrn(1), Ce.iushrn(1);
        for (var $e = 0, Ze = 1; !(be.words[0] & Ze) && $e < 26; ++$e, Ze <<= 1)
          ;
        if ($e > 0)
          for (be.iushrn($e); $e-- > 0; )
            (Pe.isOdd() || Se.isOdd()) && (Pe.iadd(ge), Se.isub(Ae)), Pe.iushrn(1), Se.iushrn(1);
        de.cmp(be) >= 0 ? (de.isub(be), Te.isub(Pe), Ce.isub(Se)) : (be.isub(de), Pe.isub(Te), Se.isub(Ce));
      }
      return {
        a: Pe,
        b: Se,
        gcd: be.iushln(ke)
      };
    }, ie.prototype._invmp = function(fe) {
      te(fe.negative === 0), te(!fe.isZero());
      var de = this, be = fe.clone();
      de.negative !== 0 ? de = de.umod(fe) : de = de.clone();
      for (var Te = new ie(1), Ce = new ie(0), Pe = be.clone(); de.cmpn(1) > 0 && be.cmpn(1) > 0; ) {
        for (var Se = 0, ke = 1; !(de.words[0] & ke) && Se < 26; ++Se, ke <<= 1)
          ;
        if (Se > 0)
          for (de.iushrn(Se); Se-- > 0; )
            Te.isOdd() && Te.iadd(Pe), Te.iushrn(1);
        for (var ge = 0, Ae = 1; !(be.words[0] & Ae) && ge < 26; ++ge, Ae <<= 1)
          ;
        if (ge > 0)
          for (be.iushrn(ge); ge-- > 0; )
            Ce.isOdd() && Ce.iadd(Pe), Ce.iushrn(1);
        de.cmp(be) >= 0 ? (de.isub(be), Te.isub(Ce)) : (be.isub(de), Ce.isub(Te));
      }
      var Ge;
      return de.cmpn(1) === 0 ? Ge = Te : Ge = Ce, Ge.cmpn(0) < 0 && Ge.iadd(fe), Ge;
    }, ie.prototype.gcd = function(fe) {
      if (this.isZero())
        return fe.abs();
      if (fe.isZero())
        return this.abs();
      var de = this.clone(), be = fe.clone();
      de.negative = 0, be.negative = 0;
      for (var Te = 0; de.isEven() && be.isEven(); Te++)
        de.iushrn(1), be.iushrn(1);
      do {
        for (; de.isEven(); )
          de.iushrn(1);
        for (; be.isEven(); )
          be.iushrn(1);
        var Ce = de.cmp(be);
        if (Ce < 0) {
          var Pe = de;
          de = be, be = Pe;
        } else if (Ce === 0 || be.cmpn(1) === 0)
          break;
        de.isub(be);
      } while (!0);
      return be.iushln(Te);
    }, ie.prototype.invm = function(fe) {
      return this.egcd(fe).a.umod(fe);
    }, ie.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, ie.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, ie.prototype.andln = function(fe) {
      return this.words[0] & fe;
    }, ie.prototype.bincn = function(fe) {
      te(typeof fe == "number");
      var de = fe % 26, be = (fe - de) / 26, Te = 1 << de;
      if (this.length <= be)
        return this._expand(be + 1), this.words[be] |= Te, this;
      for (var Ce = Te, Pe = be; Ce !== 0 && Pe < this.length; Pe++) {
        var Se = this.words[Pe] | 0;
        Se += Ce, Ce = Se >>> 26, Se &= 67108863, this.words[Pe] = Se;
      }
      return Ce !== 0 && (this.words[Pe] = Ce, this.length++), this;
    }, ie.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, ie.prototype.cmpn = function(fe) {
      var de = fe < 0;
      if (this.negative !== 0 && !de)
        return -1;
      if (this.negative === 0 && de)
        return 1;
      this._strip();
      var be;
      if (this.length > 1)
        be = 1;
      else {
        de && (fe = -fe), te(fe <= 67108863, "Number is too big");
        var Te = this.words[0] | 0;
        be = Te === fe ? 0 : Te < fe ? -1 : 1;
      }
      return this.negative !== 0 ? -be | 0 : be;
    }, ie.prototype.cmp = function(fe) {
      if (this.negative !== 0 && fe.negative === 0)
        return -1;
      if (this.negative === 0 && fe.negative !== 0)
        return 1;
      var de = this.ucmp(fe);
      return this.negative !== 0 ? -de | 0 : de;
    }, ie.prototype.ucmp = function(fe) {
      if (this.length > fe.length)
        return 1;
      if (this.length < fe.length)
        return -1;
      for (var de = 0, be = this.length - 1; be >= 0; be--) {
        var Te = this.words[be] | 0, Ce = fe.words[be] | 0;
        if (Te !== Ce) {
          Te < Ce ? de = -1 : Te > Ce && (de = 1);
          break;
        }
      }
      return de;
    }, ie.prototype.gtn = function(fe) {
      return this.cmpn(fe) === 1;
    }, ie.prototype.gt = function(fe) {
      return this.cmp(fe) === 1;
    }, ie.prototype.gten = function(fe) {
      return this.cmpn(fe) >= 0;
    }, ie.prototype.gte = function(fe) {
      return this.cmp(fe) >= 0;
    }, ie.prototype.ltn = function(fe) {
      return this.cmpn(fe) === -1;
    }, ie.prototype.lt = function(fe) {
      return this.cmp(fe) === -1;
    }, ie.prototype.lten = function(fe) {
      return this.cmpn(fe) <= 0;
    }, ie.prototype.lte = function(fe) {
      return this.cmp(fe) <= 0;
    }, ie.prototype.eqn = function(fe) {
      return this.cmpn(fe) === 0;
    }, ie.prototype.eq = function(fe) {
      return this.cmp(fe) === 0;
    }, ie.red = function(fe) {
      return new je(fe);
    }, ie.prototype.toRed = function(fe) {
      return te(!this.red, "Already a number in reduction context"), te(this.negative === 0, "red works only with positives"), fe.convertTo(this)._forceRed(fe);
    }, ie.prototype.fromRed = function() {
      return te(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, ie.prototype._forceRed = function(fe) {
      return this.red = fe, this;
    }, ie.prototype.forceRed = function(fe) {
      return te(!this.red, "Already a number in reduction context"), this._forceRed(fe);
    }, ie.prototype.redAdd = function(fe) {
      return te(this.red, "redAdd works only with red numbers"), this.red.add(this, fe);
    }, ie.prototype.redIAdd = function(fe) {
      return te(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, fe);
    }, ie.prototype.redSub = function(fe) {
      return te(this.red, "redSub works only with red numbers"), this.red.sub(this, fe);
    }, ie.prototype.redISub = function(fe) {
      return te(this.red, "redISub works only with red numbers"), this.red.isub(this, fe);
    }, ie.prototype.redShl = function(fe) {
      return te(this.red, "redShl works only with red numbers"), this.red.shl(this, fe);
    }, ie.prototype.redMul = function(fe) {
      return te(this.red, "redMul works only with red numbers"), this.red._verify2(this, fe), this.red.mul(this, fe);
    }, ie.prototype.redIMul = function(fe) {
      return te(this.red, "redMul works only with red numbers"), this.red._verify2(this, fe), this.red.imul(this, fe);
    }, ie.prototype.redSqr = function() {
      return te(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, ie.prototype.redISqr = function() {
      return te(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, ie.prototype.redSqrt = function() {
      return te(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, ie.prototype.redInvm = function() {
      return te(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, ie.prototype.redNeg = function() {
      return te(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, ie.prototype.redPow = function(fe) {
      return te(this.red && !fe.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, fe);
    };
    var Ke = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function tt(fe, de) {
      this.name = fe, this.p = new ie(de, 16), this.n = this.p.bitLength(), this.k = new ie(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    tt.prototype._tmp = function() {
      var fe = new ie(null);
      return fe.words = new Array(Math.ceil(this.n / 13)), fe;
    }, tt.prototype.ireduce = function(fe) {
      var de = fe, be;
      do
        this.split(de, this.tmp), de = this.imulK(de), de = de.iadd(this.tmp), be = de.bitLength();
      while (be > this.n);
      var Te = be < this.n ? -1 : de.ucmp(this.p);
      return Te === 0 ? (de.words[0] = 0, de.length = 1) : Te > 0 ? de.isub(this.p) : de.strip !== void 0 ? de.strip() : de._strip(), de;
    }, tt.prototype.split = function(fe, de) {
      fe.iushrn(this.n, 0, de);
    }, tt.prototype.imulK = function(fe) {
      return fe.imul(this.k);
    };
    function rt() {
      tt.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    ne(rt, tt), rt.prototype.split = function(fe, de) {
      for (var be = 4194303, Te = Math.min(fe.length, 9), Ce = 0; Ce < Te; Ce++)
        de.words[Ce] = fe.words[Ce];
      if (de.length = Te, fe.length <= 9) {
        fe.words[0] = 0, fe.length = 1;
        return;
      }
      var Pe = fe.words[9];
      for (de.words[de.length++] = Pe & be, Ce = 10; Ce < fe.length; Ce++) {
        var Se = fe.words[Ce] | 0;
        fe.words[Ce - 10] = (Se & be) << 4 | Pe >>> 22, Pe = Se;
      }
      Pe >>>= 22, fe.words[Ce - 10] = Pe, Pe === 0 && fe.length > 10 ? fe.length -= 10 : fe.length -= 9;
    }, rt.prototype.imulK = function(fe) {
      fe.words[fe.length] = 0, fe.words[fe.length + 1] = 0, fe.length += 2;
      for (var de = 0, be = 0; be < fe.length; be++) {
        var Te = fe.words[be] | 0;
        de += Te * 977, fe.words[be] = de & 67108863, de = Te * 64 + (de / 67108864 | 0);
      }
      return fe.words[fe.length - 1] === 0 && (fe.length--, fe.words[fe.length - 1] === 0 && fe.length--), fe;
    };
    function it() {
      tt.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    ne(it, tt);
    function _t() {
      tt.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    ne(_t, tt);
    function Dt() {
      tt.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    ne(Dt, tt), Dt.prototype.imulK = function(fe) {
      for (var de = 0, be = 0; be < fe.length; be++) {
        var Te = (fe.words[be] | 0) * 19 + de, Ce = Te & 67108863;
        Te >>>= 26, fe.words[be] = Ce, de = Te;
      }
      return de !== 0 && (fe.words[fe.length++] = de), fe;
    }, ie._prime = function(fe) {
      if (Ke[fe])
        return Ke[fe];
      var de;
      if (fe === "k256")
        de = new rt();
      else if (fe === "p224")
        de = new it();
      else if (fe === "p192")
        de = new _t();
      else if (fe === "p25519")
        de = new Dt();
      else
        throw new Error("Unknown prime " + fe);
      return Ke[fe] = de, de;
    };
    function je(fe) {
      if (typeof fe == "string") {
        var de = ie._prime(fe);
        this.m = de.p, this.prime = de;
      } else
        te(fe.gtn(1), "modulus must be greater than 1"), this.m = fe, this.prime = null;
    }
    je.prototype._verify1 = function(fe) {
      te(fe.negative === 0, "red works only with positives"), te(fe.red, "red works only with red numbers");
    }, je.prototype._verify2 = function(fe, de) {
      te((fe.negative | de.negative) === 0, "red works only with positives"), te(
        fe.red && fe.red === de.red,
        "red works only with red numbers"
      );
    }, je.prototype.imod = function(fe) {
      return this.prime ? this.prime.ireduce(fe)._forceRed(this) : (le(fe, fe.umod(this.m)._forceRed(this)), fe);
    }, je.prototype.neg = function(fe) {
      return fe.isZero() ? fe.clone() : this.m.sub(fe)._forceRed(this);
    }, je.prototype.add = function(fe, de) {
      this._verify2(fe, de);
      var be = fe.add(de);
      return be.cmp(this.m) >= 0 && be.isub(this.m), be._forceRed(this);
    }, je.prototype.iadd = function(fe, de) {
      this._verify2(fe, de);
      var be = fe.iadd(de);
      return be.cmp(this.m) >= 0 && be.isub(this.m), be;
    }, je.prototype.sub = function(fe, de) {
      this._verify2(fe, de);
      var be = fe.sub(de);
      return be.cmpn(0) < 0 && be.iadd(this.m), be._forceRed(this);
    }, je.prototype.isub = function(fe, de) {
      this._verify2(fe, de);
      var be = fe.isub(de);
      return be.cmpn(0) < 0 && be.iadd(this.m), be;
    }, je.prototype.shl = function(fe, de) {
      return this._verify1(fe), this.imod(fe.ushln(de));
    }, je.prototype.imul = function(fe, de) {
      return this._verify2(fe, de), this.imod(fe.imul(de));
    }, je.prototype.mul = function(fe, de) {
      return this._verify2(fe, de), this.imod(fe.mul(de));
    }, je.prototype.isqr = function(fe) {
      return this.imul(fe, fe.clone());
    }, je.prototype.sqr = function(fe) {
      return this.mul(fe, fe);
    }, je.prototype.sqrt = function(fe) {
      if (fe.isZero())
        return fe.clone();
      var de = this.m.andln(3);
      if (te(de % 2 === 1), de === 3) {
        var be = this.m.add(new ie(1)).iushrn(2);
        return this.pow(fe, be);
      }
      for (var Te = this.m.subn(1), Ce = 0; !Te.isZero() && Te.andln(1) === 0; )
        Ce++, Te.iushrn(1);
      te(!Te.isZero());
      var Pe = new ie(1).toRed(this), Se = Pe.redNeg(), ke = this.m.subn(1).iushrn(1), ge = this.m.bitLength();
      for (ge = new ie(2 * ge * ge).toRed(this); this.pow(ge, ke).cmp(Se) !== 0; )
        ge.redIAdd(Se);
      for (var Ae = this.pow(ge, Te), Ge = this.pow(fe, Te.addn(1).iushrn(1)), Xe = this.pow(fe, Te), $e = Ce; Xe.cmp(Pe) !== 0; ) {
        for (var Ze = Xe, ot = 0; Ze.cmp(Pe) !== 0; ot++)
          Ze = Ze.redSqr();
        te(ot < $e);
        var ct = this.pow(Ae, new ie(1).iushln($e - ot - 1));
        Ge = Ge.redMul(ct), Ae = ct.redSqr(), Xe = Xe.redMul(Ae), $e = ot;
      }
      return Ge;
    }, je.prototype.invm = function(fe) {
      var de = fe._invmp(this.m);
      return de.negative !== 0 ? (de.negative = 0, this.imod(de).redNeg()) : this.imod(de);
    }, je.prototype.pow = function(fe, de) {
      if (de.isZero())
        return new ie(1).toRed(this);
      if (de.cmpn(1) === 0)
        return fe.clone();
      var be = 4, Te = new Array(1 << be);
      Te[0] = new ie(1).toRed(this), Te[1] = fe;
      for (var Ce = 2; Ce < Te.length; Ce++)
        Te[Ce] = this.mul(Te[Ce - 1], fe);
      var Pe = Te[0], Se = 0, ke = 0, ge = de.bitLength() % 26;
      for (ge === 0 && (ge = 26), Ce = de.length - 1; Ce >= 0; Ce--) {
        for (var Ae = de.words[Ce], Ge = ge - 1; Ge >= 0; Ge--) {
          var Xe = Ae >> Ge & 1;
          if (Pe !== Te[0] && (Pe = this.sqr(Pe)), Xe === 0 && Se === 0) {
            ke = 0;
            continue;
          }
          Se <<= 1, Se |= Xe, ke++, !(ke !== be && (Ce !== 0 || Ge !== 0)) && (Pe = this.mul(Pe, Te[Se]), ke = 0, Se = 0);
        }
        ge = 26;
      }
      return Pe;
    }, je.prototype.convertTo = function(fe) {
      var de = fe.umod(this.m);
      return de === fe ? de.clone() : de;
    }, je.prototype.convertFrom = function(fe) {
      var de = fe.clone();
      return de.red = null, de;
    }, ie.mont = function(fe) {
      return new ze(fe);
    };
    function ze(fe) {
      je.call(this, fe), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new ie(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    ne(ze, je), ze.prototype.convertTo = function(fe) {
      return this.imod(fe.ushln(this.shift));
    }, ze.prototype.convertFrom = function(fe) {
      var de = this.imod(fe.mul(this.rinv));
      return de.red = null, de;
    }, ze.prototype.imul = function(fe, de) {
      if (fe.isZero() || de.isZero())
        return fe.words[0] = 0, fe.length = 1, fe;
      var be = fe.imul(de), Te = be.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), Ce = be.isub(Te).iushrn(this.shift), Pe = Ce;
      return Ce.cmp(this.m) >= 0 ? Pe = Ce.isub(this.m) : Ce.cmpn(0) < 0 && (Pe = Ce.iadd(this.m)), Pe._forceRed(this);
    }, ze.prototype.mul = function(fe, de) {
      if (fe.isZero() || de.isZero())
        return new ie(0)._forceRed(this);
      var be = fe.mul(de), Te = be.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), Ce = be.isub(Te).iushrn(this.shift), Pe = Ce;
      return Ce.cmp(this.m) >= 0 ? Pe = Ce.isub(this.m) : Ce.cmpn(0) < 0 && (Pe = Ce.iadd(this.m)), Pe._forceRed(this);
    }, ze.prototype.invm = function(fe) {
      var de = this.imod(fe._invmp(this.m).mul(this.r2));
      return de._forceRed(this);
    };
  })(Y, commonjsGlobal$1);
})(bn$2);
var bnExports$1 = bn$2.exports;
const BN$2 = /* @__PURE__ */ getDefaultExportFromCjs$3(bnExports$1), version$i = "logger/5.7.0";
let _permanentCensorErrors = !1, _censorErrors = !1;
const LogLevels = { debug: 1, default: 2, info: 2, warning: 3, error: 4, off: 5 };
let _logLevel = LogLevels.default, _globalLogger = null;
function _checkNormalize() {
  try {
    const Y = [];
    if (["NFD", "NFC", "NFKD", "NFKC"].forEach((X) => {
      try {
        if ("test".normalize(X) !== "test")
          throw new Error("bad normalize");
      } catch {
        Y.push(X);
      }
    }), Y.length)
      throw new Error("missing " + Y.join(", "));
    if ("".normalize("NFD") !== "e")
      throw new Error("broken implementation");
  } catch (Y) {
    return Y.message;
  }
  return null;
}
const _normalizeError = _checkNormalize();
var LogLevel;
(function(Y) {
  Y.DEBUG = "DEBUG", Y.INFO = "INFO", Y.WARNING = "WARNING", Y.ERROR = "ERROR", Y.OFF = "OFF";
})(LogLevel || (LogLevel = {}));
var ErrorCode;
(function(Y) {
  Y.UNKNOWN_ERROR = "UNKNOWN_ERROR", Y.NOT_IMPLEMENTED = "NOT_IMPLEMENTED", Y.UNSUPPORTED_OPERATION = "UNSUPPORTED_OPERATION", Y.NETWORK_ERROR = "NETWORK_ERROR", Y.SERVER_ERROR = "SERVER_ERROR", Y.TIMEOUT = "TIMEOUT", Y.BUFFER_OVERRUN = "BUFFER_OVERRUN", Y.NUMERIC_FAULT = "NUMERIC_FAULT", Y.MISSING_NEW = "MISSING_NEW", Y.INVALID_ARGUMENT = "INVALID_ARGUMENT", Y.MISSING_ARGUMENT = "MISSING_ARGUMENT", Y.UNEXPECTED_ARGUMENT = "UNEXPECTED_ARGUMENT", Y.CALL_EXCEPTION = "CALL_EXCEPTION", Y.INSUFFICIENT_FUNDS = "INSUFFICIENT_FUNDS", Y.NONCE_EXPIRED = "NONCE_EXPIRED", Y.REPLACEMENT_UNDERPRICED = "REPLACEMENT_UNDERPRICED", Y.UNPREDICTABLE_GAS_LIMIT = "UNPREDICTABLE_GAS_LIMIT", Y.TRANSACTION_REPLACED = "TRANSACTION_REPLACED", Y.ACTION_REJECTED = "ACTION_REJECTED";
})(ErrorCode || (ErrorCode = {}));
const HEX = "0123456789abcdef";
class Logger {
  constructor(X) {
    Object.defineProperty(this, "version", {
      enumerable: !0,
      value: X,
      writable: !1
    });
  }
  _log(X, ee) {
    const te = X.toLowerCase();
    LogLevels[te] == null && this.throwArgumentError("invalid log level name", "logLevel", X), !(_logLevel > LogLevels[te]) && console.log.apply(console, ee);
  }
  debug(...X) {
    this._log(Logger.levels.DEBUG, X);
  }
  info(...X) {
    this._log(Logger.levels.INFO, X);
  }
  warn(...X) {
    this._log(Logger.levels.WARNING, X);
  }
  makeError(X, ee, te) {
    if (_censorErrors)
      return this.makeError("censored error", ee, {});
    ee || (ee = Logger.errors.UNKNOWN_ERROR), te || (te = {});
    const ne = [];
    Object.keys(te).forEach((ae) => {
      const ue = te[ae];
      try {
        if (ue instanceof Uint8Array) {
          let le = "";
          for (let he = 0; he < ue.length; he++)
            le += HEX[ue[he] >> 4], le += HEX[ue[he] & 15];
          ne.push(ae + "=Uint8Array(0x" + le + ")");
        } else
          ne.push(ae + "=" + JSON.stringify(ue));
      } catch {
        ne.push(ae + "=" + JSON.stringify(te[ae].toString()));
      }
    }), ne.push(`code=${ee}`), ne.push(`version=${this.version}`);
    const ie = X;
    let oe = "";
    switch (ee) {
      case ErrorCode.NUMERIC_FAULT: {
        oe = "NUMERIC_FAULT";
        const ae = X;
        switch (ae) {
          case "overflow":
          case "underflow":
          case "division-by-zero":
            oe += "-" + ae;
            break;
          case "negative-power":
          case "negative-width":
            oe += "-unsupported";
            break;
          case "unbound-bitwise-result":
            oe += "-unbound-result";
            break;
        }
        break;
      }
      case ErrorCode.CALL_EXCEPTION:
      case ErrorCode.INSUFFICIENT_FUNDS:
      case ErrorCode.MISSING_NEW:
      case ErrorCode.NONCE_EXPIRED:
      case ErrorCode.REPLACEMENT_UNDERPRICED:
      case ErrorCode.TRANSACTION_REPLACED:
      case ErrorCode.UNPREDICTABLE_GAS_LIMIT:
        oe = ee;
        break;
    }
    oe && (X += " [ See: https://links.ethers.org/v5-errors-" + oe + " ]"), ne.length && (X += " (" + ne.join(", ") + ")");
    const se = new Error(X);
    return se.reason = ie, se.code = ee, Object.keys(te).forEach(function(ae) {
      se[ae] = te[ae];
    }), se;
  }
  throwError(X, ee, te) {
    throw this.makeError(X, ee, te);
  }
  throwArgumentError(X, ee, te) {
    return this.throwError(X, Logger.errors.INVALID_ARGUMENT, {
      argument: ee,
      value: te
    });
  }
  assert(X, ee, te, ne) {
    X || this.throwError(ee, te, ne);
  }
  assertArgument(X, ee, te, ne) {
    X || this.throwArgumentError(ee, te, ne);
  }
  checkNormalize(X) {
    _normalizeError && this.throwError("platform missing String.prototype.normalize", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "String.prototype.normalize",
      form: _normalizeError
    });
  }
  checkSafeUint53(X, ee) {
    typeof X == "number" && (ee == null && (ee = "value not safe"), (X < 0 || X >= 9007199254740991) && this.throwError(ee, Logger.errors.NUMERIC_FAULT, {
      operation: "checkSafeInteger",
      fault: "out-of-safe-range",
      value: X
    }), X % 1 && this.throwError(ee, Logger.errors.NUMERIC_FAULT, {
      operation: "checkSafeInteger",
      fault: "non-integer",
      value: X
    }));
  }
  checkArgumentCount(X, ee, te) {
    te ? te = ": " + te : te = "", X < ee && this.throwError("missing argument" + te, Logger.errors.MISSING_ARGUMENT, {
      count: X,
      expectedCount: ee
    }), X > ee && this.throwError("too many arguments" + te, Logger.errors.UNEXPECTED_ARGUMENT, {
      count: X,
      expectedCount: ee
    });
  }
  checkNew(X, ee) {
    (X === Object || X == null) && this.throwError("missing new", Logger.errors.MISSING_NEW, { name: ee.name });
  }
  checkAbstract(X, ee) {
    X === ee ? this.throwError("cannot instantiate abstract class " + JSON.stringify(ee.name) + " directly; use a sub-class", Logger.errors.UNSUPPORTED_OPERATION, { name: X.name, operation: "new" }) : (X === Object || X == null) && this.throwError("missing new", Logger.errors.MISSING_NEW, { name: ee.name });
  }
  static globalLogger() {
    return _globalLogger || (_globalLogger = new Logger(version$i)), _globalLogger;
  }
  static setCensorship(X, ee) {
    if (!X && ee && this.globalLogger().throwError("cannot permanently disable censorship", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "setCensorship"
    }), _permanentCensorErrors) {
      if (!X)
        return;
      this.globalLogger().throwError("error censorship permanent", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    _censorErrors = !!X, _permanentCensorErrors = !!ee;
  }
  static setLogLevel(X) {
    const ee = LogLevels[X.toLowerCase()];
    if (ee == null) {
      Logger.globalLogger().warn("invalid log level - " + X);
      return;
    }
    _logLevel = ee;
  }
  static from(X) {
    return new Logger(X);
  }
}
Logger.errors = ErrorCode;
Logger.levels = LogLevel;
const version$h = "bytes/5.7.0", logger$m = new Logger(version$h);
function isHexable(Y) {
  return !!Y.toHexString;
}
function addSlice(Y) {
  return Y.slice || (Y.slice = function() {
    const X = Array.prototype.slice.call(arguments);
    return addSlice(new Uint8Array(Array.prototype.slice.apply(Y, X)));
  }), Y;
}
function isBytesLike(Y) {
  return isHexString(Y) && !(Y.length % 2) || isBytes$4(Y);
}
function isInteger(Y) {
  return typeof Y == "number" && Y == Y && Y % 1 === 0;
}
function isBytes$4(Y) {
  if (Y == null)
    return !1;
  if (Y.constructor === Uint8Array)
    return !0;
  if (typeof Y == "string" || !isInteger(Y.length) || Y.length < 0)
    return !1;
  for (let X = 0; X < Y.length; X++) {
    const ee = Y[X];
    if (!isInteger(ee) || ee < 0 || ee >= 256)
      return !1;
  }
  return !0;
}
function arrayify(Y, X) {
  if (X || (X = {}), typeof Y == "number") {
    logger$m.checkSafeUint53(Y, "invalid arrayify value");
    const ee = [];
    for (; Y; )
      ee.unshift(Y & 255), Y = parseInt(String(Y / 256));
    return ee.length === 0 && ee.push(0), addSlice(new Uint8Array(ee));
  }
  if (X.allowMissingPrefix && typeof Y == "string" && Y.substring(0, 2) !== "0x" && (Y = "0x" + Y), isHexable(Y) && (Y = Y.toHexString()), isHexString(Y)) {
    let ee = Y.substring(2);
    ee.length % 2 && (X.hexPad === "left" ? ee = "0" + ee : X.hexPad === "right" ? ee += "0" : logger$m.throwArgumentError("hex data is odd-length", "value", Y));
    const te = [];
    for (let ne = 0; ne < ee.length; ne += 2)
      te.push(parseInt(ee.substring(ne, ne + 2), 16));
    return addSlice(new Uint8Array(te));
  }
  return isBytes$4(Y) ? addSlice(new Uint8Array(Y)) : logger$m.throwArgumentError("invalid arrayify value", "value", Y);
}
function concat(Y) {
  const X = Y.map((ne) => arrayify(ne)), ee = X.reduce((ne, ie) => ne + ie.length, 0), te = new Uint8Array(ee);
  return X.reduce((ne, ie) => (te.set(ie, ne), ne + ie.length), 0), addSlice(te);
}
function stripZeros(Y) {
  let X = arrayify(Y);
  if (X.length === 0)
    return X;
  let ee = 0;
  for (; ee < X.length && X[ee] === 0; )
    ee++;
  return ee && (X = X.slice(ee)), X;
}
function zeroPad(Y, X) {
  Y = arrayify(Y), Y.length > X && logger$m.throwArgumentError("value out of range", "value", arguments[0]);
  const ee = new Uint8Array(X);
  return ee.set(Y, X - Y.length), addSlice(ee);
}
function isHexString(Y, X) {
  return !(typeof Y != "string" || !Y.match(/^0x[0-9A-Fa-f]*$/) || X && Y.length !== 2 + 2 * X);
}
const HexCharacters = "0123456789abcdef";
function hexlify(Y, X) {
  if (X || (X = {}), typeof Y == "number") {
    logger$m.checkSafeUint53(Y, "invalid hexlify value");
    let ee = "";
    for (; Y; )
      ee = HexCharacters[Y & 15] + ee, Y = Math.floor(Y / 16);
    return ee.length ? (ee.length % 2 && (ee = "0" + ee), "0x" + ee) : "0x00";
  }
  if (typeof Y == "bigint")
    return Y = Y.toString(16), Y.length % 2 ? "0x0" + Y : "0x" + Y;
  if (X.allowMissingPrefix && typeof Y == "string" && Y.substring(0, 2) !== "0x" && (Y = "0x" + Y), isHexable(Y))
    return Y.toHexString();
  if (isHexString(Y))
    return Y.length % 2 && (X.hexPad === "left" ? Y = "0x0" + Y.substring(2) : X.hexPad === "right" ? Y += "0" : logger$m.throwArgumentError("hex data is odd-length", "value", Y)), Y.toLowerCase();
  if (isBytes$4(Y)) {
    let ee = "0x";
    for (let te = 0; te < Y.length; te++) {
      let ne = Y[te];
      ee += HexCharacters[(ne & 240) >> 4] + HexCharacters[ne & 15];
    }
    return ee;
  }
  return logger$m.throwArgumentError("invalid hexlify value", "value", Y);
}
function hexDataLength(Y) {
  if (typeof Y != "string")
    Y = hexlify(Y);
  else if (!isHexString(Y) || Y.length % 2)
    return null;
  return (Y.length - 2) / 2;
}
function hexDataSlice(Y, X, ee) {
  return typeof Y != "string" ? Y = hexlify(Y) : (!isHexString(Y) || Y.length % 2) && logger$m.throwArgumentError("invalid hexData", "value", Y), X = 2 + 2 * X, ee != null ? "0x" + Y.substring(X, 2 + 2 * ee) : "0x" + Y.substring(X);
}
function hexConcat(Y) {
  let X = "0x";
  return Y.forEach((ee) => {
    X += hexlify(ee).substring(2);
  }), X;
}
function hexValue(Y) {
  const X = hexStripZeros(hexlify(Y, { hexPad: "left" }));
  return X === "0x" ? "0x0" : X;
}
function hexStripZeros(Y) {
  typeof Y != "string" && (Y = hexlify(Y)), isHexString(Y) || logger$m.throwArgumentError("invalid hex string", "value", Y), Y = Y.substring(2);
  let X = 0;
  for (; X < Y.length && Y[X] === "0"; )
    X++;
  return "0x" + Y.substring(X);
}
function hexZeroPad(Y, X) {
  for (typeof Y != "string" ? Y = hexlify(Y) : isHexString(Y) || logger$m.throwArgumentError("invalid hex string", "value", Y), Y.length > 2 * X + 2 && logger$m.throwArgumentError("value out of range", "value", arguments[1]); Y.length < 2 * X + 2; )
    Y = "0x0" + Y.substring(2);
  return Y;
}
function splitSignature(Y) {
  const X = {
    r: "0x",
    s: "0x",
    _vs: "0x",
    recoveryParam: 0,
    v: 0,
    yParityAndS: "0x",
    compact: "0x"
  };
  if (isBytesLike(Y)) {
    let ee = arrayify(Y);
    ee.length === 64 ? (X.v = 27 + (ee[32] >> 7), ee[32] &= 127, X.r = hexlify(ee.slice(0, 32)), X.s = hexlify(ee.slice(32, 64))) : ee.length === 65 ? (X.r = hexlify(ee.slice(0, 32)), X.s = hexlify(ee.slice(32, 64)), X.v = ee[64]) : logger$m.throwArgumentError("invalid signature string", "signature", Y), X.v < 27 && (X.v === 0 || X.v === 1 ? X.v += 27 : logger$m.throwArgumentError("signature invalid v byte", "signature", Y)), X.recoveryParam = 1 - X.v % 2, X.recoveryParam && (ee[32] |= 128), X._vs = hexlify(ee.slice(32, 64));
  } else {
    if (X.r = Y.r, X.s = Y.s, X.v = Y.v, X.recoveryParam = Y.recoveryParam, X._vs = Y._vs, X._vs != null) {
      const ne = zeroPad(arrayify(X._vs), 32);
      X._vs = hexlify(ne);
      const ie = ne[0] >= 128 ? 1 : 0;
      X.recoveryParam == null ? X.recoveryParam = ie : X.recoveryParam !== ie && logger$m.throwArgumentError("signature recoveryParam mismatch _vs", "signature", Y), ne[0] &= 127;
      const oe = hexlify(ne);
      X.s == null ? X.s = oe : X.s !== oe && logger$m.throwArgumentError("signature v mismatch _vs", "signature", Y);
    }
    if (X.recoveryParam == null)
      X.v == null ? logger$m.throwArgumentError("signature missing v and recoveryParam", "signature", Y) : X.v === 0 || X.v === 1 ? X.recoveryParam = X.v : X.recoveryParam = 1 - X.v % 2;
    else if (X.v == null)
      X.v = 27 + X.recoveryParam;
    else {
      const ne = X.v === 0 || X.v === 1 ? X.v : 1 - X.v % 2;
      X.recoveryParam !== ne && logger$m.throwArgumentError("signature recoveryParam mismatch v", "signature", Y);
    }
    X.r == null || !isHexString(X.r) ? logger$m.throwArgumentError("signature missing or invalid r", "signature", Y) : X.r = hexZeroPad(X.r, 32), X.s == null || !isHexString(X.s) ? logger$m.throwArgumentError("signature missing or invalid s", "signature", Y) : X.s = hexZeroPad(X.s, 32);
    const ee = arrayify(X.s);
    ee[0] >= 128 && logger$m.throwArgumentError("signature s out of range", "signature", Y), X.recoveryParam && (ee[0] |= 128);
    const te = hexlify(ee);
    X._vs && (isHexString(X._vs) || logger$m.throwArgumentError("signature invalid _vs", "signature", Y), X._vs = hexZeroPad(X._vs, 32)), X._vs == null ? X._vs = te : X._vs !== te && logger$m.throwArgumentError("signature _vs mismatch v and s", "signature", Y);
  }
  return X.yParityAndS = X._vs, X.compact = X.r + X.yParityAndS.substring(2), X;
}
const version$g = "bignumber/5.7.0";
var BN$1 = BN$2.BN;
const logger$l = new Logger(version$g), _constructorGuard$2 = {}, MAX_SAFE = 9007199254740991;
let _warnedToStringRadix = !1;
class BigNumber {
  constructor(X, ee) {
    X !== _constructorGuard$2 && logger$l.throwError("cannot call constructor directly; use BigNumber.from", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "new (BigNumber)"
    }), this._hex = ee, this._isBigNumber = !0, Object.freeze(this);
  }
  fromTwos(X) {
    return toBigNumber(toBN(this).fromTwos(X));
  }
  toTwos(X) {
    return toBigNumber(toBN(this).toTwos(X));
  }
  abs() {
    return this._hex[0] === "-" ? BigNumber.from(this._hex.substring(1)) : this;
  }
  add(X) {
    return toBigNumber(toBN(this).add(toBN(X)));
  }
  sub(X) {
    return toBigNumber(toBN(this).sub(toBN(X)));
  }
  div(X) {
    return BigNumber.from(X).isZero() && throwFault("division-by-zero", "div"), toBigNumber(toBN(this).div(toBN(X)));
  }
  mul(X) {
    return toBigNumber(toBN(this).mul(toBN(X)));
  }
  mod(X) {
    const ee = toBN(X);
    return ee.isNeg() && throwFault("division-by-zero", "mod"), toBigNumber(toBN(this).umod(ee));
  }
  pow(X) {
    const ee = toBN(X);
    return ee.isNeg() && throwFault("negative-power", "pow"), toBigNumber(toBN(this).pow(ee));
  }
  and(X) {
    const ee = toBN(X);
    return (this.isNegative() || ee.isNeg()) && throwFault("unbound-bitwise-result", "and"), toBigNumber(toBN(this).and(ee));
  }
  or(X) {
    const ee = toBN(X);
    return (this.isNegative() || ee.isNeg()) && throwFault("unbound-bitwise-result", "or"), toBigNumber(toBN(this).or(ee));
  }
  xor(X) {
    const ee = toBN(X);
    return (this.isNegative() || ee.isNeg()) && throwFault("unbound-bitwise-result", "xor"), toBigNumber(toBN(this).xor(ee));
  }
  mask(X) {
    return (this.isNegative() || X < 0) && throwFault("negative-width", "mask"), toBigNumber(toBN(this).maskn(X));
  }
  shl(X) {
    return (this.isNegative() || X < 0) && throwFault("negative-width", "shl"), toBigNumber(toBN(this).shln(X));
  }
  shr(X) {
    return (this.isNegative() || X < 0) && throwFault("negative-width", "shr"), toBigNumber(toBN(this).shrn(X));
  }
  eq(X) {
    return toBN(this).eq(toBN(X));
  }
  lt(X) {
    return toBN(this).lt(toBN(X));
  }
  lte(X) {
    return toBN(this).lte(toBN(X));
  }
  gt(X) {
    return toBN(this).gt(toBN(X));
  }
  gte(X) {
    return toBN(this).gte(toBN(X));
  }
  isNegative() {
    return this._hex[0] === "-";
  }
  isZero() {
    return toBN(this).isZero();
  }
  toNumber() {
    try {
      return toBN(this).toNumber();
    } catch {
      throwFault("overflow", "toNumber", this.toString());
    }
    return null;
  }
  toBigInt() {
    try {
      return BigInt(this.toString());
    } catch {
    }
    return logger$l.throwError("this platform does not support BigInt", Logger.errors.UNSUPPORTED_OPERATION, {
      value: this.toString()
    });
  }
  toString() {
    return arguments.length > 0 && (arguments[0] === 10 ? _warnedToStringRadix || (_warnedToStringRadix = !0, logger$l.warn("BigNumber.toString does not accept any parameters; base-10 is assumed")) : arguments[0] === 16 ? logger$l.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()", Logger.errors.UNEXPECTED_ARGUMENT, {}) : logger$l.throwError("BigNumber.toString does not accept parameters", Logger.errors.UNEXPECTED_ARGUMENT, {})), toBN(this).toString(10);
  }
  toHexString() {
    return this._hex;
  }
  toJSON(X) {
    return { type: "BigNumber", hex: this.toHexString() };
  }
  static from(X) {
    if (X instanceof BigNumber)
      return X;
    if (typeof X == "string")
      return X.match(/^-?0x[0-9a-f]+$/i) ? new BigNumber(_constructorGuard$2, toHex$1(X)) : X.match(/^-?[0-9]+$/) ? new BigNumber(_constructorGuard$2, toHex$1(new BN$1(X))) : logger$l.throwArgumentError("invalid BigNumber string", "value", X);
    if (typeof X == "number")
      return X % 1 && throwFault("underflow", "BigNumber.from", X), (X >= MAX_SAFE || X <= -MAX_SAFE) && throwFault("overflow", "BigNumber.from", X), BigNumber.from(String(X));
    const ee = X;
    if (typeof ee == "bigint")
      return BigNumber.from(ee.toString());
    if (isBytes$4(ee))
      return BigNumber.from(hexlify(ee));
    if (ee)
      if (ee.toHexString) {
        const te = ee.toHexString();
        if (typeof te == "string")
          return BigNumber.from(te);
      } else {
        let te = ee._hex;
        if (te == null && ee.type === "BigNumber" && (te = ee.hex), typeof te == "string" && (isHexString(te) || te[0] === "-" && isHexString(te.substring(1))))
          return BigNumber.from(te);
      }
    return logger$l.throwArgumentError("invalid BigNumber value", "value", X);
  }
  static isBigNumber(X) {
    return !!(X && X._isBigNumber);
  }
}
function toHex$1(Y) {
  if (typeof Y != "string")
    return toHex$1(Y.toString(16));
  if (Y[0] === "-")
    return Y = Y.substring(1), Y[0] === "-" && logger$l.throwArgumentError("invalid hex", "value", Y), Y = toHex$1(Y), Y === "0x00" ? Y : "-" + Y;
  if (Y.substring(0, 2) !== "0x" && (Y = "0x" + Y), Y === "0x")
    return "0x00";
  for (Y.length % 2 && (Y = "0x0" + Y.substring(2)); Y.length > 4 && Y.substring(0, 4) === "0x00"; )
    Y = "0x" + Y.substring(4);
  return Y;
}
function toBigNumber(Y) {
  return BigNumber.from(toHex$1(Y));
}
function toBN(Y) {
  const X = BigNumber.from(Y).toHexString();
  return X[0] === "-" ? new BN$1("-" + X.substring(3), 16) : new BN$1(X.substring(2), 16);
}
function throwFault(Y, X, ee) {
  const te = { fault: Y, operation: X };
  return ee != null && (te.value = ee), logger$l.throwError(Y, Logger.errors.NUMERIC_FAULT, te);
}
function _base36To16(Y) {
  return new BN$1(Y, 36).toString(16);
}
const version$f = "properties/5.7.0";
var __awaiter$8 = function(Y, X, ee, te) {
  function ne(ie) {
    return ie instanceof ee ? ie : new ee(function(oe) {
      oe(ie);
    });
  }
  return new (ee || (ee = Promise))(function(ie, oe) {
    function se(le) {
      try {
        ue(te.next(le));
      } catch (he) {
        oe(he);
      }
    }
    function ae(le) {
      try {
        ue(te.throw(le));
      } catch (he) {
        oe(he);
      }
    }
    function ue(le) {
      le.done ? ie(le.value) : ne(le.value).then(se, ae);
    }
    ue((te = te.apply(Y, X || [])).next());
  });
};
const logger$k = new Logger(version$f);
function defineReadOnly(Y, X, ee) {
  Object.defineProperty(Y, X, {
    enumerable: !0,
    value: ee,
    writable: !1
  });
}
function getStatic(Y, X) {
  for (let ee = 0; ee < 32; ee++) {
    if (Y[X])
      return Y[X];
    if (!Y.prototype || typeof Y.prototype != "object")
      break;
    Y = Object.getPrototypeOf(Y.prototype).constructor;
  }
  return null;
}
function resolveProperties(Y) {
  return __awaiter$8(this, void 0, void 0, function* () {
    const X = Object.keys(Y).map((ee) => {
      const te = Y[ee];
      return Promise.resolve(te).then((ne) => ({ key: ee, value: ne }));
    });
    return (yield Promise.all(X)).reduce((ee, te) => (ee[te.key] = te.value, ee), {});
  });
}
function checkProperties(Y, X) {
  (!Y || typeof Y != "object") && logger$k.throwArgumentError("invalid object", "object", Y), Object.keys(Y).forEach((ee) => {
    X[ee] || logger$k.throwArgumentError("invalid object key - " + ee, "transaction:" + ee, Y);
  });
}
function shallowCopy(Y) {
  const X = {};
  for (const ee in Y)
    X[ee] = Y[ee];
  return X;
}
const opaque = { bigint: !0, boolean: !0, function: !0, number: !0, string: !0 };
function _isFrozen(Y) {
  if (Y == null || opaque[typeof Y])
    return !0;
  if (Array.isArray(Y) || typeof Y == "object") {
    if (!Object.isFrozen(Y))
      return !1;
    const X = Object.keys(Y);
    for (let ee = 0; ee < X.length; ee++) {
      let te = null;
      try {
        te = Y[X[ee]];
      } catch {
        continue;
      }
      if (!_isFrozen(te))
        return !1;
    }
    return !0;
  }
  return logger$k.throwArgumentError(`Cannot deepCopy ${typeof Y}`, "object", Y);
}
function _deepCopy(Y) {
  if (_isFrozen(Y))
    return Y;
  if (Array.isArray(Y))
    return Object.freeze(Y.map((X) => deepCopy(X)));
  if (typeof Y == "object") {
    const X = {};
    for (const ee in Y) {
      const te = Y[ee];
      te !== void 0 && defineReadOnly(X, ee, deepCopy(te));
    }
    return X;
  }
  return logger$k.throwArgumentError(`Cannot deepCopy ${typeof Y}`, "object", Y);
}
function deepCopy(Y) {
  return _deepCopy(Y);
}
class Description {
  constructor(X) {
    for (const ee in X)
      this[ee] = deepCopy(X[ee]);
  }
}
const version$e = "abi/5.7.0", logger$j = new Logger(version$e), _constructorGuard$1 = {};
let ModifiersBytes = { calldata: !0, memory: !0, storage: !0 }, ModifiersNest = { calldata: !0, memory: !0 };
function checkModifier(Y, X) {
  if (Y === "bytes" || Y === "string") {
    if (ModifiersBytes[X])
      return !0;
  } else if (Y === "address") {
    if (X === "payable")
      return !0;
  } else if ((Y.indexOf("[") >= 0 || Y === "tuple") && ModifiersNest[X])
    return !0;
  return (ModifiersBytes[X] || X === "payable") && logger$j.throwArgumentError("invalid modifier", "name", X), !1;
}
function parseParamType(Y, X) {
  let ee = Y;
  function te(se) {
    logger$j.throwArgumentError(`unexpected character at position ${se}`, "param", Y);
  }
  Y = Y.replace(/\s/g, " ");
  function ne(se) {
    let ae = { type: "", name: "", parent: se, state: { allowType: !0 } };
    return X && (ae.indexed = !1), ae;
  }
  let ie = { type: "", name: "", state: { allowType: !0 } }, oe = ie;
  for (let se = 0; se < Y.length; se++) {
    let ae = Y[se];
    switch (ae) {
      case "(":
        oe.state.allowType && oe.type === "" ? oe.type = "tuple" : oe.state.allowParams || te(se), oe.state.allowType = !1, oe.type = verifyType(oe.type), oe.components = [ne(oe)], oe = oe.components[0];
        break;
      case ")":
        delete oe.state, oe.name === "indexed" && (X || te(se), oe.indexed = !0, oe.name = ""), checkModifier(oe.type, oe.name) && (oe.name = ""), oe.type = verifyType(oe.type);
        let ue = oe;
        oe = oe.parent, oe || te(se), delete ue.parent, oe.state.allowParams = !1, oe.state.allowName = !0, oe.state.allowArray = !0;
        break;
      case ",":
        delete oe.state, oe.name === "indexed" && (X || te(se), oe.indexed = !0, oe.name = ""), checkModifier(oe.type, oe.name) && (oe.name = ""), oe.type = verifyType(oe.type);
        let le = ne(oe.parent);
        oe.parent.components.push(le), delete oe.parent, oe = le;
        break;
      case " ":
        oe.state.allowType && oe.type !== "" && (oe.type = verifyType(oe.type), delete oe.state.allowType, oe.state.allowName = !0, oe.state.allowParams = !0), oe.state.allowName && oe.name !== "" && (oe.name === "indexed" ? (X || te(se), oe.indexed && te(se), oe.indexed = !0, oe.name = "") : checkModifier(oe.type, oe.name) ? oe.name = "" : oe.state.allowName = !1);
        break;
      case "[":
        oe.state.allowArray || te(se), oe.type += ae, oe.state.allowArray = !1, oe.state.allowName = !1, oe.state.readArray = !0;
        break;
      case "]":
        oe.state.readArray || te(se), oe.type += ae, oe.state.readArray = !1, oe.state.allowArray = !0, oe.state.allowName = !0;
        break;
      default:
        oe.state.allowType ? (oe.type += ae, oe.state.allowParams = !0, oe.state.allowArray = !0) : oe.state.allowName ? (oe.name += ae, delete oe.state.allowArray) : oe.state.readArray ? oe.type += ae : te(se);
    }
  }
  return oe.parent && logger$j.throwArgumentError("unexpected eof", "param", Y), delete ie.state, oe.name === "indexed" ? (X || te(ee.length - 7), oe.indexed && te(ee.length - 7), oe.indexed = !0, oe.name = "") : checkModifier(oe.type, oe.name) && (oe.name = ""), ie.type = verifyType(ie.type), ie;
}
function populate(Y, X) {
  for (let ee in X)
    defineReadOnly(Y, ee, X[ee]);
}
const FormatTypes = Object.freeze({
  // Bare formatting, as is needed for computing a sighash of an event or function
  sighash: "sighash",
  // Human-Readable with Minimal spacing and without names (compact human-readable)
  minimal: "minimal",
  // Human-Readable with nice spacing, including all names
  full: "full",
  // JSON-format a la Solidity
  json: "json"
}), paramTypeArray = new RegExp(/^(.*)\[([0-9]*)\]$/);
class ParamType {
  constructor(X, ee) {
    X !== _constructorGuard$1 && logger$j.throwError("use fromString", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "new ParamType()"
    }), populate(this, ee);
    let te = this.type.match(paramTypeArray);
    te ? populate(this, {
      arrayLength: parseInt(te[2] || "-1"),
      arrayChildren: ParamType.fromObject({
        type: te[1],
        components: this.components
      }),
      baseType: "array"
    }) : populate(this, {
      arrayLength: null,
      arrayChildren: null,
      baseType: this.components != null ? "tuple" : this.type
    }), this._isParamType = !0, Object.freeze(this);
  }
  // Format the parameter fragment
  //   - sighash: "(uint256,address)"
  //   - minimal: "tuple(uint256,address) indexed"
  //   - full:    "tuple(uint256 foo, address bar) indexed baz"
  format(X) {
    if (X || (X = FormatTypes.sighash), FormatTypes[X] || logger$j.throwArgumentError("invalid format type", "format", X), X === FormatTypes.json) {
      let te = {
        type: this.baseType === "tuple" ? "tuple" : this.type,
        name: this.name || void 0
      };
      return typeof this.indexed == "boolean" && (te.indexed = this.indexed), this.components && (te.components = this.components.map((ne) => JSON.parse(ne.format(X)))), JSON.stringify(te);
    }
    let ee = "";
    return this.baseType === "array" ? (ee += this.arrayChildren.format(X), ee += "[" + (this.arrayLength < 0 ? "" : String(this.arrayLength)) + "]") : this.baseType === "tuple" ? (X !== FormatTypes.sighash && (ee += this.type), ee += "(" + this.components.map((te) => te.format(X)).join(X === FormatTypes.full ? ", " : ",") + ")") : ee += this.type, X !== FormatTypes.sighash && (this.indexed === !0 && (ee += " indexed"), X === FormatTypes.full && this.name && (ee += " " + this.name)), ee;
  }
  static from(X, ee) {
    return typeof X == "string" ? ParamType.fromString(X, ee) : ParamType.fromObject(X);
  }
  static fromObject(X) {
    return ParamType.isParamType(X) ? X : new ParamType(_constructorGuard$1, {
      name: X.name || null,
      type: verifyType(X.type),
      indexed: X.indexed == null ? null : !!X.indexed,
      components: X.components ? X.components.map(ParamType.fromObject) : null
    });
  }
  static fromString(X, ee) {
    function te(ne) {
      return ParamType.fromObject({
        name: ne.name,
        type: ne.type,
        indexed: ne.indexed,
        components: ne.components
      });
    }
    return te(parseParamType(X, !!ee));
  }
  static isParamType(X) {
    return !!(X != null && X._isParamType);
  }
}
function parseParams(Y, X) {
  return splitNesting(Y).map((ee) => ParamType.fromString(ee, X));
}
class Fragment {
  constructor(X, ee) {
    X !== _constructorGuard$1 && logger$j.throwError("use a static from method", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "new Fragment()"
    }), populate(this, ee), this._isFragment = !0, Object.freeze(this);
  }
  static from(X) {
    return Fragment.isFragment(X) ? X : typeof X == "string" ? Fragment.fromString(X) : Fragment.fromObject(X);
  }
  static fromObject(X) {
    if (Fragment.isFragment(X))
      return X;
    switch (X.type) {
      case "function":
        return FunctionFragment.fromObject(X);
      case "event":
        return EventFragment.fromObject(X);
      case "constructor":
        return ConstructorFragment.fromObject(X);
      case "error":
        return ErrorFragment.fromObject(X);
      case "fallback":
      case "receive":
        return null;
    }
    return logger$j.throwArgumentError("invalid fragment object", "value", X);
  }
  static fromString(X) {
    return X = X.replace(/\s/g, " "), X = X.replace(/\(/g, " (").replace(/\)/g, ") ").replace(/\s+/g, " "), X = X.trim(), X.split(" ")[0] === "event" ? EventFragment.fromString(X.substring(5).trim()) : X.split(" ")[0] === "function" ? FunctionFragment.fromString(X.substring(8).trim()) : X.split("(")[0].trim() === "constructor" ? ConstructorFragment.fromString(X.trim()) : X.split(" ")[0] === "error" ? ErrorFragment.fromString(X.substring(5).trim()) : logger$j.throwArgumentError("unsupported fragment", "value", X);
  }
  static isFragment(X) {
    return !!(X && X._isFragment);
  }
}
class EventFragment extends Fragment {
  format(X) {
    if (X || (X = FormatTypes.sighash), FormatTypes[X] || logger$j.throwArgumentError("invalid format type", "format", X), X === FormatTypes.json)
      return JSON.stringify({
        type: "event",
        anonymous: this.anonymous,
        name: this.name,
        inputs: this.inputs.map((te) => JSON.parse(te.format(X)))
      });
    let ee = "";
    return X !== FormatTypes.sighash && (ee += "event "), ee += this.name + "(" + this.inputs.map((te) => te.format(X)).join(X === FormatTypes.full ? ", " : ",") + ") ", X !== FormatTypes.sighash && this.anonymous && (ee += "anonymous "), ee.trim();
  }
  static from(X) {
    return typeof X == "string" ? EventFragment.fromString(X) : EventFragment.fromObject(X);
  }
  static fromObject(X) {
    if (EventFragment.isEventFragment(X))
      return X;
    X.type !== "event" && logger$j.throwArgumentError("invalid event object", "value", X);
    const ee = {
      name: verifyIdentifier(X.name),
      anonymous: X.anonymous,
      inputs: X.inputs ? X.inputs.map(ParamType.fromObject) : [],
      type: "event"
    };
    return new EventFragment(_constructorGuard$1, ee);
  }
  static fromString(X) {
    let ee = X.match(regexParen);
    ee || logger$j.throwArgumentError("invalid event string", "value", X);
    let te = !1;
    return ee[3].split(" ").forEach((ne) => {
      switch (ne.trim()) {
        case "anonymous":
          te = !0;
          break;
        case "":
          break;
        default:
          logger$j.warn("unknown modifier: " + ne);
      }
    }), EventFragment.fromObject({
      name: ee[1].trim(),
      anonymous: te,
      inputs: parseParams(ee[2], !0),
      type: "event"
    });
  }
  static isEventFragment(X) {
    return X && X._isFragment && X.type === "event";
  }
}
function parseGas(Y, X) {
  X.gas = null;
  let ee = Y.split("@");
  return ee.length !== 1 ? (ee.length > 2 && logger$j.throwArgumentError("invalid human-readable ABI signature", "value", Y), ee[1].match(/^[0-9]+$/) || logger$j.throwArgumentError("invalid human-readable ABI signature gas", "value", Y), X.gas = BigNumber.from(ee[1]), ee[0]) : Y;
}
function parseModifiers(Y, X) {
  X.constant = !1, X.payable = !1, X.stateMutability = "nonpayable", Y.split(" ").forEach((ee) => {
    switch (ee.trim()) {
      case "constant":
        X.constant = !0;
        break;
      case "payable":
        X.payable = !0, X.stateMutability = "payable";
        break;
      case "nonpayable":
        X.payable = !1, X.stateMutability = "nonpayable";
        break;
      case "pure":
        X.constant = !0, X.stateMutability = "pure";
        break;
      case "view":
        X.constant = !0, X.stateMutability = "view";
        break;
      case "external":
      case "public":
      case "":
        break;
      default:
        console.log("unknown modifier: " + ee);
    }
  });
}
function verifyState(Y) {
  let X = {
    constant: !1,
    payable: !0,
    stateMutability: "payable"
  };
  return Y.stateMutability != null ? (X.stateMutability = Y.stateMutability, X.constant = X.stateMutability === "view" || X.stateMutability === "pure", Y.constant != null && !!Y.constant !== X.constant && logger$j.throwArgumentError("cannot have constant function with mutability " + X.stateMutability, "value", Y), X.payable = X.stateMutability === "payable", Y.payable != null && !!Y.payable !== X.payable && logger$j.throwArgumentError("cannot have payable function with mutability " + X.stateMutability, "value", Y)) : Y.payable != null ? (X.payable = !!Y.payable, Y.constant == null && !X.payable && Y.type !== "constructor" && logger$j.throwArgumentError("unable to determine stateMutability", "value", Y), X.constant = !!Y.constant, X.constant ? X.stateMutability = "view" : X.stateMutability = X.payable ? "payable" : "nonpayable", X.payable && X.constant && logger$j.throwArgumentError("cannot have constant payable function", "value", Y)) : Y.constant != null ? (X.constant = !!Y.constant, X.payable = !X.constant, X.stateMutability = X.constant ? "view" : "payable") : Y.type !== "constructor" && logger$j.throwArgumentError("unable to determine stateMutability", "value", Y), X;
}
class ConstructorFragment extends Fragment {
  format(X) {
    if (X || (X = FormatTypes.sighash), FormatTypes[X] || logger$j.throwArgumentError("invalid format type", "format", X), X === FormatTypes.json)
      return JSON.stringify({
        type: "constructor",
        stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
        payable: this.payable,
        gas: this.gas ? this.gas.toNumber() : void 0,
        inputs: this.inputs.map((te) => JSON.parse(te.format(X)))
      });
    X === FormatTypes.sighash && logger$j.throwError("cannot format a constructor for sighash", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "format(sighash)"
    });
    let ee = "constructor(" + this.inputs.map((te) => te.format(X)).join(X === FormatTypes.full ? ", " : ",") + ") ";
    return this.stateMutability && this.stateMutability !== "nonpayable" && (ee += this.stateMutability + " "), ee.trim();
  }
  static from(X) {
    return typeof X == "string" ? ConstructorFragment.fromString(X) : ConstructorFragment.fromObject(X);
  }
  static fromObject(X) {
    if (ConstructorFragment.isConstructorFragment(X))
      return X;
    X.type !== "constructor" && logger$j.throwArgumentError("invalid constructor object", "value", X);
    let ee = verifyState(X);
    ee.constant && logger$j.throwArgumentError("constructor cannot be constant", "value", X);
    const te = {
      name: null,
      type: X.type,
      inputs: X.inputs ? X.inputs.map(ParamType.fromObject) : [],
      payable: ee.payable,
      stateMutability: ee.stateMutability,
      gas: X.gas ? BigNumber.from(X.gas) : null
    };
    return new ConstructorFragment(_constructorGuard$1, te);
  }
  static fromString(X) {
    let ee = { type: "constructor" };
    X = parseGas(X, ee);
    let te = X.match(regexParen);
    return (!te || te[1].trim() !== "constructor") && logger$j.throwArgumentError("invalid constructor string", "value", X), ee.inputs = parseParams(te[2].trim(), !1), parseModifiers(te[3].trim(), ee), ConstructorFragment.fromObject(ee);
  }
  static isConstructorFragment(X) {
    return X && X._isFragment && X.type === "constructor";
  }
}
class FunctionFragment extends ConstructorFragment {
  format(X) {
    if (X || (X = FormatTypes.sighash), FormatTypes[X] || logger$j.throwArgumentError("invalid format type", "format", X), X === FormatTypes.json)
      return JSON.stringify({
        type: "function",
        name: this.name,
        constant: this.constant,
        stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
        payable: this.payable,
        gas: this.gas ? this.gas.toNumber() : void 0,
        inputs: this.inputs.map((te) => JSON.parse(te.format(X))),
        outputs: this.outputs.map((te) => JSON.parse(te.format(X)))
      });
    let ee = "";
    return X !== FormatTypes.sighash && (ee += "function "), ee += this.name + "(" + this.inputs.map((te) => te.format(X)).join(X === FormatTypes.full ? ", " : ",") + ") ", X !== FormatTypes.sighash && (this.stateMutability ? this.stateMutability !== "nonpayable" && (ee += this.stateMutability + " ") : this.constant && (ee += "view "), this.outputs && this.outputs.length && (ee += "returns (" + this.outputs.map((te) => te.format(X)).join(", ") + ") "), this.gas != null && (ee += "@" + this.gas.toString() + " ")), ee.trim();
  }
  static from(X) {
    return typeof X == "string" ? FunctionFragment.fromString(X) : FunctionFragment.fromObject(X);
  }
  static fromObject(X) {
    if (FunctionFragment.isFunctionFragment(X))
      return X;
    X.type !== "function" && logger$j.throwArgumentError("invalid function object", "value", X);
    let ee = verifyState(X);
    const te = {
      type: X.type,
      name: verifyIdentifier(X.name),
      constant: ee.constant,
      inputs: X.inputs ? X.inputs.map(ParamType.fromObject) : [],
      outputs: X.outputs ? X.outputs.map(ParamType.fromObject) : [],
      payable: ee.payable,
      stateMutability: ee.stateMutability,
      gas: X.gas ? BigNumber.from(X.gas) : null
    };
    return new FunctionFragment(_constructorGuard$1, te);
  }
  static fromString(X) {
    let ee = { type: "function" };
    X = parseGas(X, ee);
    let te = X.split(" returns ");
    te.length > 2 && logger$j.throwArgumentError("invalid function string", "value", X);
    let ne = te[0].match(regexParen);
    if (ne || logger$j.throwArgumentError("invalid function signature", "value", X), ee.name = ne[1].trim(), ee.name && verifyIdentifier(ee.name), ee.inputs = parseParams(ne[2], !1), parseModifiers(ne[3].trim(), ee), te.length > 1) {
      let ie = te[1].match(regexParen);
      (ie[1].trim() != "" || ie[3].trim() != "") && logger$j.throwArgumentError("unexpected tokens", "value", X), ee.outputs = parseParams(ie[2], !1);
    } else
      ee.outputs = [];
    return FunctionFragment.fromObject(ee);
  }
  static isFunctionFragment(X) {
    return X && X._isFragment && X.type === "function";
  }
}
function checkForbidden(Y) {
  const X = Y.format();
  return (X === "Error(string)" || X === "Panic(uint256)") && logger$j.throwArgumentError(`cannot specify user defined ${X} error`, "fragment", Y), Y;
}
class ErrorFragment extends Fragment {
  format(X) {
    if (X || (X = FormatTypes.sighash), FormatTypes[X] || logger$j.throwArgumentError("invalid format type", "format", X), X === FormatTypes.json)
      return JSON.stringify({
        type: "error",
        name: this.name,
        inputs: this.inputs.map((te) => JSON.parse(te.format(X)))
      });
    let ee = "";
    return X !== FormatTypes.sighash && (ee += "error "), ee += this.name + "(" + this.inputs.map((te) => te.format(X)).join(X === FormatTypes.full ? ", " : ",") + ") ", ee.trim();
  }
  static from(X) {
    return typeof X == "string" ? ErrorFragment.fromString(X) : ErrorFragment.fromObject(X);
  }
  static fromObject(X) {
    if (ErrorFragment.isErrorFragment(X))
      return X;
    X.type !== "error" && logger$j.throwArgumentError("invalid error object", "value", X);
    const ee = {
      type: X.type,
      name: verifyIdentifier(X.name),
      inputs: X.inputs ? X.inputs.map(ParamType.fromObject) : []
    };
    return checkForbidden(new ErrorFragment(_constructorGuard$1, ee));
  }
  static fromString(X) {
    let ee = { type: "error" }, te = X.match(regexParen);
    return te || logger$j.throwArgumentError("invalid error signature", "value", X), ee.name = te[1].trim(), ee.name && verifyIdentifier(ee.name), ee.inputs = parseParams(te[2], !1), checkForbidden(ErrorFragment.fromObject(ee));
  }
  static isErrorFragment(X) {
    return X && X._isFragment && X.type === "error";
  }
}
function verifyType(Y) {
  return Y.match(/^uint($|[^1-9])/) ? Y = "uint256" + Y.substring(4) : Y.match(/^int($|[^1-9])/) && (Y = "int256" + Y.substring(3)), Y;
}
const regexIdentifier = new RegExp("^[a-zA-Z$_][a-zA-Z0-9$_]*$");
function verifyIdentifier(Y) {
  return (!Y || !Y.match(regexIdentifier)) && logger$j.throwArgumentError(`invalid identifier "${Y}"`, "value", Y), Y;
}
const regexParen = new RegExp("^([^)(]*)\\((.*)\\)([^)(]*)$");
function splitNesting(Y) {
  Y = Y.trim();
  let X = [], ee = "", te = 0;
  for (let ne = 0; ne < Y.length; ne++) {
    let ie = Y[ne];
    ie === "," && te === 0 ? (X.push(ee), ee = "") : (ee += ie, ie === "(" ? te++ : ie === ")" && (te--, te === -1 && logger$j.throwArgumentError("unbalanced parenthesis", "value", Y)));
  }
  return ee && X.push(ee), X;
}
const logger$i = new Logger(version$e);
function checkResultErrors(Y) {
  const X = [], ee = function(te, ne) {
    if (Array.isArray(ne))
      for (let ie in ne) {
        const oe = te.slice();
        oe.push(ie);
        try {
          ee(oe, ne[ie]);
        } catch (se) {
          X.push({ path: oe, error: se });
        }
      }
  };
  return ee([], Y), X;
}
class Coder {
  constructor(X, ee, te, ne) {
    this.name = X, this.type = ee, this.localName = te, this.dynamic = ne;
  }
  _throwError(X, ee) {
    logger$i.throwArgumentError(X, this.localName, ee);
  }
}
class Writer {
  constructor(X) {
    defineReadOnly(this, "wordSize", X || 32), this._data = [], this._dataLength = 0, this._padding = new Uint8Array(X);
  }
  get data() {
    return hexConcat(this._data);
  }
  get length() {
    return this._dataLength;
  }
  _writeData(X) {
    return this._data.push(X), this._dataLength += X.length, X.length;
  }
  appendWriter(X) {
    return this._writeData(concat(X._data));
  }
  // Arrayish items; padded on the right to wordSize
  writeBytes(X) {
    let ee = arrayify(X);
    const te = ee.length % this.wordSize;
    return te && (ee = concat([ee, this._padding.slice(te)])), this._writeData(ee);
  }
  _getValue(X) {
    let ee = arrayify(BigNumber.from(X));
    return ee.length > this.wordSize && logger$i.throwError("value out-of-bounds", Logger.errors.BUFFER_OVERRUN, {
      length: this.wordSize,
      offset: ee.length
    }), ee.length % this.wordSize && (ee = concat([this._padding.slice(ee.length % this.wordSize), ee])), ee;
  }
  // BigNumberish items; padded on the left to wordSize
  writeValue(X) {
    return this._writeData(this._getValue(X));
  }
  writeUpdatableValue() {
    const X = this._data.length;
    return this._data.push(this._padding), this._dataLength += this.wordSize, (ee) => {
      this._data[X] = this._getValue(ee);
    };
  }
}
class Reader {
  constructor(X, ee, te, ne) {
    defineReadOnly(this, "_data", arrayify(X)), defineReadOnly(this, "wordSize", ee || 32), defineReadOnly(this, "_coerceFunc", te), defineReadOnly(this, "allowLoose", ne), this._offset = 0;
  }
  get data() {
    return hexlify(this._data);
  }
  get consumed() {
    return this._offset;
  }
  // The default Coerce function
  static coerce(X, ee) {
    let te = X.match("^u?int([0-9]+)$");
    return te && parseInt(te[1]) <= 48 && (ee = ee.toNumber()), ee;
  }
  coerce(X, ee) {
    return this._coerceFunc ? this._coerceFunc(X, ee) : Reader.coerce(X, ee);
  }
  _peekBytes(X, ee, te) {
    let ne = Math.ceil(ee / this.wordSize) * this.wordSize;
    return this._offset + ne > this._data.length && (this.allowLoose && te && this._offset + ee <= this._data.length ? ne = ee : logger$i.throwError("data out-of-bounds", Logger.errors.BUFFER_OVERRUN, {
      length: this._data.length,
      offset: this._offset + ne
    })), this._data.slice(this._offset, this._offset + ne);
  }
  subReader(X) {
    return new Reader(this._data.slice(this._offset + X), this.wordSize, this._coerceFunc, this.allowLoose);
  }
  readBytes(X, ee) {
    let te = this._peekBytes(0, X, !!ee);
    return this._offset += te.length, te.slice(0, X);
  }
  readValue() {
    return BigNumber.from(this.readBytes(this.wordSize));
  }
}
var sha3$1 = { exports: {} };
/**
 * [js-sha3]{@link https://github.com/emn178/js-sha3}
 *
 * @version 0.8.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2015-2018
 * @license MIT
 */
(function(Y) {
  (function() {
    var X = "input is invalid type", ee = "finalize already called", te = typeof window == "object", ne = te ? window : {};
    ne.JS_SHA3_NO_WINDOW && (te = !1);
    var ie = !te && typeof self == "object", oe = !ne.JS_SHA3_NO_NODE_JS && typeof process == "object" && process.versions && process.versions.node;
    oe ? ne = commonjsGlobal$1 : ie && (ne = self);
    var se = !ne.JS_SHA3_NO_COMMON_JS && !0 && Y.exports, ae = !ne.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer < "u", ue = "0123456789abcdef".split(""), le = [31, 7936, 2031616, 520093696], he = [4, 1024, 262144, 67108864], me = [1, 256, 65536, 16777216], ye = [6, 1536, 393216, 100663296], we = [0, 8, 16, 24], Ee = [
      1,
      0,
      32898,
      0,
      32906,
      2147483648,
      2147516416,
      2147483648,
      32907,
      0,
      2147483649,
      0,
      2147516545,
      2147483648,
      32777,
      2147483648,
      138,
      0,
      136,
      0,
      2147516425,
      0,
      2147483658,
      0,
      2147516555,
      0,
      139,
      2147483648,
      32905,
      2147483648,
      32771,
      2147483648,
      32770,
      2147483648,
      128,
      2147483648,
      32778,
      0,
      2147483658,
      2147483648,
      2147516545,
      2147483648,
      32896,
      2147483648,
      2147483649,
      0,
      2147516424,
      2147483648
    ], Re = [224, 256, 384, 512], Ue = [128, 256], Me = ["hex", "buffer", "arrayBuffer", "array", "digest"], De = {
      128: 168,
      256: 136
    };
    (ne.JS_SHA3_NO_NODE_JS || !Array.isArray) && (Array.isArray = function($e) {
      return Object.prototype.toString.call($e) === "[object Array]";
    }), ae && (ne.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView) && (ArrayBuffer.isView = function($e) {
      return typeof $e == "object" && $e.buffer && $e.buffer.constructor === ArrayBuffer;
    });
    for (var Fe = function($e, Ze, ot) {
      return function(ct) {
        return new Ae($e, Ze, $e).update(ct)[ot]();
      };
    }, Ke = function($e, Ze, ot) {
      return function(ct, At) {
        return new Ae($e, Ze, At).update(ct)[ot]();
      };
    }, tt = function($e, Ze, ot) {
      return function(ct, At, Tt, dt) {
        return de["cshake" + $e].update(ct, At, Tt, dt)[ot]();
      };
    }, rt = function($e, Ze, ot) {
      return function(ct, At, Tt, dt) {
        return de["kmac" + $e].update(ct, At, Tt, dt)[ot]();
      };
    }, it = function($e, Ze, ot, ct) {
      for (var At = 0; At < Me.length; ++At) {
        var Tt = Me[At];
        $e[Tt] = Ze(ot, ct, Tt);
      }
      return $e;
    }, _t = function($e, Ze) {
      var ot = Fe($e, Ze, "hex");
      return ot.create = function() {
        return new Ae($e, Ze, $e);
      }, ot.update = function(ct) {
        return ot.create().update(ct);
      }, it(ot, Fe, $e, Ze);
    }, Dt = function($e, Ze) {
      var ot = Ke($e, Ze, "hex");
      return ot.create = function(ct) {
        return new Ae($e, Ze, ct);
      }, ot.update = function(ct, At) {
        return ot.create(At).update(ct);
      }, it(ot, Ke, $e, Ze);
    }, je = function($e, Ze) {
      var ot = De[$e], ct = tt($e, Ze, "hex");
      return ct.create = function(At, Tt, dt) {
        return !Tt && !dt ? de["shake" + $e].create(At) : new Ae($e, Ze, At).bytepad([Tt, dt], ot);
      }, ct.update = function(At, Tt, dt, vt) {
        return ct.create(Tt, dt, vt).update(At);
      }, it(ct, tt, $e, Ze);
    }, ze = function($e, Ze) {
      var ot = De[$e], ct = rt($e, Ze, "hex");
      return ct.create = function(At, Tt, dt) {
        return new Ge($e, Ze, Tt).bytepad(["KMAC", dt], ot).bytepad([At], ot);
      }, ct.update = function(At, Tt, dt, vt) {
        return ct.create(At, dt, vt).update(Tt);
      }, it(ct, rt, $e, Ze);
    }, fe = [
      { name: "keccak", padding: me, bits: Re, createMethod: _t },
      { name: "sha3", padding: ye, bits: Re, createMethod: _t },
      { name: "shake", padding: le, bits: Ue, createMethod: Dt },
      { name: "cshake", padding: he, bits: Ue, createMethod: je },
      { name: "kmac", padding: he, bits: Ue, createMethod: ze }
    ], de = {}, be = [], Te = 0; Te < fe.length; ++Te)
      for (var Ce = fe[Te], Pe = Ce.bits, Se = 0; Se < Pe.length; ++Se) {
        var ke = Ce.name + "_" + Pe[Se];
        if (be.push(ke), de[ke] = Ce.createMethod(Pe[Se], Ce.padding), Ce.name !== "sha3") {
          var ge = Ce.name + Pe[Se];
          be.push(ge), de[ge] = de[ke];
        }
      }
    function Ae($e, Ze, ot) {
      this.blocks = [], this.s = [], this.padding = Ze, this.outputBits = ot, this.reset = !0, this.finalized = !1, this.block = 0, this.start = 0, this.blockCount = 1600 - ($e << 1) >> 5, this.byteCount = this.blockCount << 2, this.outputBlocks = ot >> 5, this.extraBytes = (ot & 31) >> 3;
      for (var ct = 0; ct < 50; ++ct)
        this.s[ct] = 0;
    }
    Ae.prototype.update = function($e) {
      if (this.finalized)
        throw new Error(ee);
      var Ze, ot = typeof $e;
      if (ot !== "string") {
        if (ot === "object") {
          if ($e === null)
            throw new Error(X);
          if (ae && $e.constructor === ArrayBuffer)
            $e = new Uint8Array($e);
          else if (!Array.isArray($e) && (!ae || !ArrayBuffer.isView($e)))
            throw new Error(X);
        } else
          throw new Error(X);
        Ze = !0;
      }
      for (var ct = this.blocks, At = this.byteCount, Tt = $e.length, dt = this.blockCount, vt = 0, Ut = this.s, It, Er; vt < Tt; ) {
        if (this.reset)
          for (this.reset = !1, ct[0] = this.block, It = 1; It < dt + 1; ++It)
            ct[It] = 0;
        if (Ze)
          for (It = this.start; vt < Tt && It < At; ++vt)
            ct[It >> 2] |= $e[vt] << we[It++ & 3];
        else
          for (It = this.start; vt < Tt && It < At; ++vt)
            Er = $e.charCodeAt(vt), Er < 128 ? ct[It >> 2] |= Er << we[It++ & 3] : Er < 2048 ? (ct[It >> 2] |= (192 | Er >> 6) << we[It++ & 3], ct[It >> 2] |= (128 | Er & 63) << we[It++ & 3]) : Er < 55296 || Er >= 57344 ? (ct[It >> 2] |= (224 | Er >> 12) << we[It++ & 3], ct[It >> 2] |= (128 | Er >> 6 & 63) << we[It++ & 3], ct[It >> 2] |= (128 | Er & 63) << we[It++ & 3]) : (Er = 65536 + ((Er & 1023) << 10 | $e.charCodeAt(++vt) & 1023), ct[It >> 2] |= (240 | Er >> 18) << we[It++ & 3], ct[It >> 2] |= (128 | Er >> 12 & 63) << we[It++ & 3], ct[It >> 2] |= (128 | Er >> 6 & 63) << we[It++ & 3], ct[It >> 2] |= (128 | Er & 63) << we[It++ & 3]);
        if (this.lastByteIndex = It, It >= At) {
          for (this.start = It - At, this.block = ct[dt], It = 0; It < dt; ++It)
            Ut[It] ^= ct[It];
          Xe(Ut), this.reset = !0;
        } else
          this.start = It;
      }
      return this;
    }, Ae.prototype.encode = function($e, Ze) {
      var ot = $e & 255, ct = 1, At = [ot];
      for ($e = $e >> 8, ot = $e & 255; ot > 0; )
        At.unshift(ot), $e = $e >> 8, ot = $e & 255, ++ct;
      return Ze ? At.push(ct) : At.unshift(ct), this.update(At), At.length;
    }, Ae.prototype.encodeString = function($e) {
      var Ze, ot = typeof $e;
      if (ot !== "string") {
        if (ot === "object") {
          if ($e === null)
            throw new Error(X);
          if (ae && $e.constructor === ArrayBuffer)
            $e = new Uint8Array($e);
          else if (!Array.isArray($e) && (!ae || !ArrayBuffer.isView($e)))
            throw new Error(X);
        } else
          throw new Error(X);
        Ze = !0;
      }
      var ct = 0, At = $e.length;
      if (Ze)
        ct = At;
      else
        for (var Tt = 0; Tt < $e.length; ++Tt) {
          var dt = $e.charCodeAt(Tt);
          dt < 128 ? ct += 1 : dt < 2048 ? ct += 2 : dt < 55296 || dt >= 57344 ? ct += 3 : (dt = 65536 + ((dt & 1023) << 10 | $e.charCodeAt(++Tt) & 1023), ct += 4);
        }
      return ct += this.encode(ct * 8), this.update($e), ct;
    }, Ae.prototype.bytepad = function($e, Ze) {
      for (var ot = this.encode(Ze), ct = 0; ct < $e.length; ++ct)
        ot += this.encodeString($e[ct]);
      var At = Ze - ot % Ze, Tt = [];
      return Tt.length = At, this.update(Tt), this;
    }, Ae.prototype.finalize = function() {
      if (!this.finalized) {
        this.finalized = !0;
        var $e = this.blocks, Ze = this.lastByteIndex, ot = this.blockCount, ct = this.s;
        if ($e[Ze >> 2] |= this.padding[Ze & 3], this.lastByteIndex === this.byteCount)
          for ($e[0] = $e[ot], Ze = 1; Ze < ot + 1; ++Ze)
            $e[Ze] = 0;
        for ($e[ot - 1] |= 2147483648, Ze = 0; Ze < ot; ++Ze)
          ct[Ze] ^= $e[Ze];
        Xe(ct);
      }
    }, Ae.prototype.toString = Ae.prototype.hex = function() {
      this.finalize();
      for (var $e = this.blockCount, Ze = this.s, ot = this.outputBlocks, ct = this.extraBytes, At = 0, Tt = 0, dt = "", vt; Tt < ot; ) {
        for (At = 0; At < $e && Tt < ot; ++At, ++Tt)
          vt = Ze[At], dt += ue[vt >> 4 & 15] + ue[vt & 15] + ue[vt >> 12 & 15] + ue[vt >> 8 & 15] + ue[vt >> 20 & 15] + ue[vt >> 16 & 15] + ue[vt >> 28 & 15] + ue[vt >> 24 & 15];
        Tt % $e === 0 && (Xe(Ze), At = 0);
      }
      return ct && (vt = Ze[At], dt += ue[vt >> 4 & 15] + ue[vt & 15], ct > 1 && (dt += ue[vt >> 12 & 15] + ue[vt >> 8 & 15]), ct > 2 && (dt += ue[vt >> 20 & 15] + ue[vt >> 16 & 15])), dt;
    }, Ae.prototype.arrayBuffer = function() {
      this.finalize();
      var $e = this.blockCount, Ze = this.s, ot = this.outputBlocks, ct = this.extraBytes, At = 0, Tt = 0, dt = this.outputBits >> 3, vt;
      ct ? vt = new ArrayBuffer(ot + 1 << 2) : vt = new ArrayBuffer(dt);
      for (var Ut = new Uint32Array(vt); Tt < ot; ) {
        for (At = 0; At < $e && Tt < ot; ++At, ++Tt)
          Ut[Tt] = Ze[At];
        Tt % $e === 0 && Xe(Ze);
      }
      return ct && (Ut[At] = Ze[At], vt = vt.slice(0, dt)), vt;
    }, Ae.prototype.buffer = Ae.prototype.arrayBuffer, Ae.prototype.digest = Ae.prototype.array = function() {
      this.finalize();
      for (var $e = this.blockCount, Ze = this.s, ot = this.outputBlocks, ct = this.extraBytes, At = 0, Tt = 0, dt = [], vt, Ut; Tt < ot; ) {
        for (At = 0; At < $e && Tt < ot; ++At, ++Tt)
          vt = Tt << 2, Ut = Ze[At], dt[vt] = Ut & 255, dt[vt + 1] = Ut >> 8 & 255, dt[vt + 2] = Ut >> 16 & 255, dt[vt + 3] = Ut >> 24 & 255;
        Tt % $e === 0 && Xe(Ze);
      }
      return ct && (vt = Tt << 2, Ut = Ze[At], dt[vt] = Ut & 255, ct > 1 && (dt[vt + 1] = Ut >> 8 & 255), ct > 2 && (dt[vt + 2] = Ut >> 16 & 255)), dt;
    };
    function Ge($e, Ze, ot) {
      Ae.call(this, $e, Ze, ot);
    }
    Ge.prototype = new Ae(), Ge.prototype.finalize = function() {
      return this.encode(this.outputBits, !0), Ae.prototype.finalize.call(this);
    };
    var Xe = function($e) {
      var Ze, ot, ct, At, Tt, dt, vt, Ut, It, Er, Fr, an, wX, Ct, w_, hX, oX, Nn, SX, sX, nX, Ye, lt, pt, He, Je, st, gt, kt, Vt, Lr, Ci, Qr, xX, lX, rX, FX, BX, cX, MX, EX, yX, jX, AX, vX, PX, kX, qe, Qe, Ve, Ie, nt, Et, xt, Jt, Yt, _r, cn, _X, un, aX, uX, fX;
      for (ct = 0; ct < 48; ct += 2)
        At = $e[0] ^ $e[10] ^ $e[20] ^ $e[30] ^ $e[40], Tt = $e[1] ^ $e[11] ^ $e[21] ^ $e[31] ^ $e[41], dt = $e[2] ^ $e[12] ^ $e[22] ^ $e[32] ^ $e[42], vt = $e[3] ^ $e[13] ^ $e[23] ^ $e[33] ^ $e[43], Ut = $e[4] ^ $e[14] ^ $e[24] ^ $e[34] ^ $e[44], It = $e[5] ^ $e[15] ^ $e[25] ^ $e[35] ^ $e[45], Er = $e[6] ^ $e[16] ^ $e[26] ^ $e[36] ^ $e[46], Fr = $e[7] ^ $e[17] ^ $e[27] ^ $e[37] ^ $e[47], an = $e[8] ^ $e[18] ^ $e[28] ^ $e[38] ^ $e[48], wX = $e[9] ^ $e[19] ^ $e[29] ^ $e[39] ^ $e[49], Ze = an ^ (dt << 1 | vt >>> 31), ot = wX ^ (vt << 1 | dt >>> 31), $e[0] ^= Ze, $e[1] ^= ot, $e[10] ^= Ze, $e[11] ^= ot, $e[20] ^= Ze, $e[21] ^= ot, $e[30] ^= Ze, $e[31] ^= ot, $e[40] ^= Ze, $e[41] ^= ot, Ze = At ^ (Ut << 1 | It >>> 31), ot = Tt ^ (It << 1 | Ut >>> 31), $e[2] ^= Ze, $e[3] ^= ot, $e[12] ^= Ze, $e[13] ^= ot, $e[22] ^= Ze, $e[23] ^= ot, $e[32] ^= Ze, $e[33] ^= ot, $e[42] ^= Ze, $e[43] ^= ot, Ze = dt ^ (Er << 1 | Fr >>> 31), ot = vt ^ (Fr << 1 | Er >>> 31), $e[4] ^= Ze, $e[5] ^= ot, $e[14] ^= Ze, $e[15] ^= ot, $e[24] ^= Ze, $e[25] ^= ot, $e[34] ^= Ze, $e[35] ^= ot, $e[44] ^= Ze, $e[45] ^= ot, Ze = Ut ^ (an << 1 | wX >>> 31), ot = It ^ (wX << 1 | an >>> 31), $e[6] ^= Ze, $e[7] ^= ot, $e[16] ^= Ze, $e[17] ^= ot, $e[26] ^= Ze, $e[27] ^= ot, $e[36] ^= Ze, $e[37] ^= ot, $e[46] ^= Ze, $e[47] ^= ot, Ze = Er ^ (At << 1 | Tt >>> 31), ot = Fr ^ (Tt << 1 | At >>> 31), $e[8] ^= Ze, $e[9] ^= ot, $e[18] ^= Ze, $e[19] ^= ot, $e[28] ^= Ze, $e[29] ^= ot, $e[38] ^= Ze, $e[39] ^= ot, $e[48] ^= Ze, $e[49] ^= ot, Ct = $e[0], w_ = $e[1], PX = $e[11] << 4 | $e[10] >>> 28, kX = $e[10] << 4 | $e[11] >>> 28, gt = $e[20] << 3 | $e[21] >>> 29, kt = $e[21] << 3 | $e[20] >>> 29, un = $e[31] << 9 | $e[30] >>> 23, aX = $e[30] << 9 | $e[31] >>> 23, yX = $e[40] << 18 | $e[41] >>> 14, jX = $e[41] << 18 | $e[40] >>> 14, xX = $e[2] << 1 | $e[3] >>> 31, lX = $e[3] << 1 | $e[2] >>> 31, hX = $e[13] << 12 | $e[12] >>> 20, oX = $e[12] << 12 | $e[13] >>> 20, qe = $e[22] << 10 | $e[23] >>> 22, Qe = $e[23] << 10 | $e[22] >>> 22, Vt = $e[33] << 13 | $e[32] >>> 19, Lr = $e[32] << 13 | $e[33] >>> 19, uX = $e[42] << 2 | $e[43] >>> 30, fX = $e[43] << 2 | $e[42] >>> 30, xt = $e[5] << 30 | $e[4] >>> 2, Jt = $e[4] << 30 | $e[5] >>> 2, rX = $e[14] << 6 | $e[15] >>> 26, FX = $e[15] << 6 | $e[14] >>> 26, Nn = $e[25] << 11 | $e[24] >>> 21, SX = $e[24] << 11 | $e[25] >>> 21, Ve = $e[34] << 15 | $e[35] >>> 17, Ie = $e[35] << 15 | $e[34] >>> 17, Ci = $e[45] << 29 | $e[44] >>> 3, Qr = $e[44] << 29 | $e[45] >>> 3, pt = $e[6] << 28 | $e[7] >>> 4, He = $e[7] << 28 | $e[6] >>> 4, Yt = $e[17] << 23 | $e[16] >>> 9, _r = $e[16] << 23 | $e[17] >>> 9, BX = $e[26] << 25 | $e[27] >>> 7, cX = $e[27] << 25 | $e[26] >>> 7, sX = $e[36] << 21 | $e[37] >>> 11, nX = $e[37] << 21 | $e[36] >>> 11, nt = $e[47] << 24 | $e[46] >>> 8, Et = $e[46] << 24 | $e[47] >>> 8, AX = $e[8] << 27 | $e[9] >>> 5, vX = $e[9] << 27 | $e[8] >>> 5, Je = $e[18] << 20 | $e[19] >>> 12, st = $e[19] << 20 | $e[18] >>> 12, cn = $e[29] << 7 | $e[28] >>> 25, _X = $e[28] << 7 | $e[29] >>> 25, MX = $e[38] << 8 | $e[39] >>> 24, EX = $e[39] << 8 | $e[38] >>> 24, Ye = $e[48] << 14 | $e[49] >>> 18, lt = $e[49] << 14 | $e[48] >>> 18, $e[0] = Ct ^ ~hX & Nn, $e[1] = w_ ^ ~oX & SX, $e[10] = pt ^ ~Je & gt, $e[11] = He ^ ~st & kt, $e[20] = xX ^ ~rX & BX, $e[21] = lX ^ ~FX & cX, $e[30] = AX ^ ~PX & qe, $e[31] = vX ^ ~kX & Qe, $e[40] = xt ^ ~Yt & cn, $e[41] = Jt ^ ~_r & _X, $e[2] = hX ^ ~Nn & sX, $e[3] = oX ^ ~SX & nX, $e[12] = Je ^ ~gt & Vt, $e[13] = st ^ ~kt & Lr, $e[22] = rX ^ ~BX & MX, $e[23] = FX ^ ~cX & EX, $e[32] = PX ^ ~qe & Ve, $e[33] = kX ^ ~Qe & Ie, $e[42] = Yt ^ ~cn & un, $e[43] = _r ^ ~_X & aX, $e[4] = Nn ^ ~sX & Ye, $e[5] = SX ^ ~nX & lt, $e[14] = gt ^ ~Vt & Ci, $e[15] = kt ^ ~Lr & Qr, $e[24] = BX ^ ~MX & yX, $e[25] = cX ^ ~EX & jX, $e[34] = qe ^ ~Ve & nt, $e[35] = Qe ^ ~Ie & Et, $e[44] = cn ^ ~un & uX, $e[45] = _X ^ ~aX & fX, $e[6] = sX ^ ~Ye & Ct, $e[7] = nX ^ ~lt & w_, $e[16] = Vt ^ ~Ci & pt, $e[17] = Lr ^ ~Qr & He, $e[26] = MX ^ ~yX & xX, $e[27] = EX ^ ~jX & lX, $e[36] = Ve ^ ~nt & AX, $e[37] = Ie ^ ~Et & vX, $e[46] = un ^ ~uX & xt, $e[47] = aX ^ ~fX & Jt, $e[8] = Ye ^ ~Ct & hX, $e[9] = lt ^ ~w_ & oX, $e[18] = Ci ^ ~pt & Je, $e[19] = Qr ^ ~He & st, $e[28] = yX ^ ~xX & rX, $e[29] = jX ^ ~lX & FX, $e[38] = nt ^ ~AX & PX, $e[39] = Et ^ ~vX & kX, $e[48] = uX ^ ~xt & Yt, $e[49] = fX ^ ~Jt & _r, $e[0] ^= Ee[ct], $e[1] ^= Ee[ct + 1];
    };
    if (se)
      Y.exports = de;
    else
      for (Te = 0; Te < be.length; ++Te)
        ne[be[Te]] = de[be[Te]];
  })();
})(sha3$1);
var sha3Exports = sha3$1.exports;
const sha3 = /* @__PURE__ */ getDefaultExportFromCjs$3(sha3Exports);
function keccak256(Y) {
  return "0x" + sha3.keccak_256(arrayify(Y));
}
const version$d = "rlp/5.7.0", logger$h = new Logger(version$d);
function arrayifyInteger(Y) {
  const X = [];
  for (; Y; )
    X.unshift(Y & 255), Y >>= 8;
  return X;
}
function unarrayifyInteger(Y, X, ee) {
  let te = 0;
  for (let ne = 0; ne < ee; ne++)
    te = te * 256 + Y[X + ne];
  return te;
}
function _encode(Y) {
  if (Array.isArray(Y)) {
    let te = [];
    if (Y.forEach(function(ie) {
      te = te.concat(_encode(ie));
    }), te.length <= 55)
      return te.unshift(192 + te.length), te;
    const ne = arrayifyInteger(te.length);
    return ne.unshift(247 + ne.length), ne.concat(te);
  }
  isBytesLike(Y) || logger$h.throwArgumentError("RLP object must be BytesLike", "object", Y);
  const X = Array.prototype.slice.call(arrayify(Y));
  if (X.length === 1 && X[0] <= 127)
    return X;
  if (X.length <= 55)
    return X.unshift(128 + X.length), X;
  const ee = arrayifyInteger(X.length);
  return ee.unshift(183 + ee.length), ee.concat(X);
}
function encode$2(Y) {
  return hexlify(_encode(Y));
}
function _decodeChildren(Y, X, ee, te) {
  const ne = [];
  for (; ee < X + 1 + te; ) {
    const ie = _decode(Y, ee);
    ne.push(ie.result), ee += ie.consumed, ee > X + 1 + te && logger$h.throwError("child data too short", Logger.errors.BUFFER_OVERRUN, {});
  }
  return { consumed: 1 + te, result: ne };
}
function _decode(Y, X) {
  if (Y.length === 0 && logger$h.throwError("data too short", Logger.errors.BUFFER_OVERRUN, {}), Y[X] >= 248) {
    const ee = Y[X] - 247;
    X + 1 + ee > Y.length && logger$h.throwError("data short segment too short", Logger.errors.BUFFER_OVERRUN, {});
    const te = unarrayifyInteger(Y, X + 1, ee);
    return X + 1 + ee + te > Y.length && logger$h.throwError("data long segment too short", Logger.errors.BUFFER_OVERRUN, {}), _decodeChildren(Y, X, X + 1 + ee, ee + te);
  } else if (Y[X] >= 192) {
    const ee = Y[X] - 192;
    return X + 1 + ee > Y.length && logger$h.throwError("data array too short", Logger.errors.BUFFER_OVERRUN, {}), _decodeChildren(Y, X, X + 1, ee);
  } else if (Y[X] >= 184) {
    const ee = Y[X] - 183;
    X + 1 + ee > Y.length && logger$h.throwError("data array too short", Logger.errors.BUFFER_OVERRUN, {});
    const te = unarrayifyInteger(Y, X + 1, ee);
    X + 1 + ee + te > Y.length && logger$h.throwError("data array too short", Logger.errors.BUFFER_OVERRUN, {});
    const ne = hexlify(Y.slice(X + 1 + ee, X + 1 + ee + te));
    return { consumed: 1 + ee + te, result: ne };
  } else if (Y[X] >= 128) {
    const ee = Y[X] - 128;
    X + 1 + ee > Y.length && logger$h.throwError("data too short", Logger.errors.BUFFER_OVERRUN, {});
    const te = hexlify(Y.slice(X + 1, X + 1 + ee));
    return { consumed: 1 + ee, result: te };
  }
  return { consumed: 1, result: hexlify(Y[X]) };
}
function decode$2(Y) {
  const X = arrayify(Y), ee = _decode(X, 0);
  return ee.consumed !== X.length && logger$h.throwArgumentError("invalid rlp data", "data", Y), ee.result;
}
const version$c = "address/5.7.0", logger$g = new Logger(version$c);
function getChecksumAddress(Y) {
  isHexString(Y, 20) || logger$g.throwArgumentError("invalid address", "address", Y), Y = Y.toLowerCase();
  const X = Y.substring(2).split(""), ee = new Uint8Array(40);
  for (let ne = 0; ne < 40; ne++)
    ee[ne] = X[ne].charCodeAt(0);
  const te = arrayify(keccak256(ee));
  for (let ne = 0; ne < 40; ne += 2)
    te[ne >> 1] >> 4 >= 8 && (X[ne] = X[ne].toUpperCase()), (te[ne >> 1] & 15) >= 8 && (X[ne + 1] = X[ne + 1].toUpperCase());
  return "0x" + X.join("");
}
const MAX_SAFE_INTEGER = 9007199254740991;
function log10(Y) {
  return Math.log10 ? Math.log10(Y) : Math.log(Y) / Math.LN10;
}
const ibanLookup = {};
for (let Y = 0; Y < 10; Y++)
  ibanLookup[String(Y)] = String(Y);
for (let Y = 0; Y < 26; Y++)
  ibanLookup[String.fromCharCode(65 + Y)] = String(10 + Y);
const safeDigits = Math.floor(log10(MAX_SAFE_INTEGER));
function ibanChecksum(Y) {
  Y = Y.toUpperCase(), Y = Y.substring(4) + Y.substring(0, 2) + "00";
  let X = Y.split("").map((te) => ibanLookup[te]).join("");
  for (; X.length >= safeDigits; ) {
    let te = X.substring(0, safeDigits);
    X = parseInt(te, 10) % 97 + X.substring(te.length);
  }
  let ee = String(98 - parseInt(X, 10) % 97);
  for (; ee.length < 2; )
    ee = "0" + ee;
  return ee;
}
function getAddress(Y) {
  let X = null;
  if (typeof Y != "string" && logger$g.throwArgumentError("invalid address", "address", Y), Y.match(/^(0x)?[0-9a-fA-F]{40}$/))
    Y.substring(0, 2) !== "0x" && (Y = "0x" + Y), X = getChecksumAddress(Y), Y.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && X !== Y && logger$g.throwArgumentError("bad address checksum", "address", Y);
  else if (Y.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
    for (Y.substring(2, 4) !== ibanChecksum(Y) && logger$g.throwArgumentError("bad icap checksum", "address", Y), X = _base36To16(Y.substring(4)); X.length < 40; )
      X = "0" + X;
    X = getChecksumAddress("0x" + X);
  } else
    logger$g.throwArgumentError("invalid address", "address", Y);
  return X;
}
function getContractAddress(Y) {
  let X = null;
  try {
    X = getAddress(Y.from);
  } catch {
    logger$g.throwArgumentError("missing from address", "transaction", Y);
  }
  const ee = stripZeros(arrayify(BigNumber.from(Y.nonce).toHexString()));
  return getAddress(hexDataSlice(keccak256(encode$2([X, ee])), 12));
}
class AddressCoder extends Coder {
  constructor(X) {
    super("address", "address", X, !1);
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000";
  }
  encode(X, ee) {
    try {
      ee = getAddress(ee);
    } catch (te) {
      this._throwError(te.message, ee);
    }
    return X.writeValue(ee);
  }
  decode(X) {
    return getAddress(hexZeroPad(X.readValue().toHexString(), 20));
  }
}
class AnonymousCoder extends Coder {
  constructor(X) {
    super(X.name, X.type, void 0, X.dynamic), this.coder = X;
  }
  defaultValue() {
    return this.coder.defaultValue();
  }
  encode(X, ee) {
    return this.coder.encode(X, ee);
  }
  decode(X) {
    return this.coder.decode(X);
  }
}
const logger$f = new Logger(version$e);
function pack(Y, X, ee) {
  let te = null;
  if (Array.isArray(ee))
    te = ee;
  else if (ee && typeof ee == "object") {
    let ae = {};
    te = X.map((ue) => {
      const le = ue.localName;
      return le || logger$f.throwError("cannot encode object for signature with missing names", Logger.errors.INVALID_ARGUMENT, {
        argument: "values",
        coder: ue,
        value: ee
      }), ae[le] && logger$f.throwError("cannot encode object for signature with duplicate names", Logger.errors.INVALID_ARGUMENT, {
        argument: "values",
        coder: ue,
        value: ee
      }), ae[le] = !0, ee[le];
    });
  } else
    logger$f.throwArgumentError("invalid tuple value", "tuple", ee);
  X.length !== te.length && logger$f.throwArgumentError("types/value length mismatch", "tuple", ee);
  let ne = new Writer(Y.wordSize), ie = new Writer(Y.wordSize), oe = [];
  X.forEach((ae, ue) => {
    let le = te[ue];
    if (ae.dynamic) {
      let he = ie.length;
      ae.encode(ie, le);
      let me = ne.writeUpdatableValue();
      oe.push((ye) => {
        me(ye + he);
      });
    } else
      ae.encode(ne, le);
  }), oe.forEach((ae) => {
    ae(ne.length);
  });
  let se = Y.appendWriter(ne);
  return se += Y.appendWriter(ie), se;
}
function unpack(Y, X) {
  let ee = [], te = Y.subReader(0);
  X.forEach((ie) => {
    let oe = null;
    if (ie.dynamic) {
      let se = Y.readValue(), ae = te.subReader(se.toNumber());
      try {
        oe = ie.decode(ae);
      } catch (ue) {
        if (ue.code === Logger.errors.BUFFER_OVERRUN)
          throw ue;
        oe = ue, oe.baseType = ie.name, oe.name = ie.localName, oe.type = ie.type;
      }
    } else
      try {
        oe = ie.decode(Y);
      } catch (se) {
        if (se.code === Logger.errors.BUFFER_OVERRUN)
          throw se;
        oe = se, oe.baseType = ie.name, oe.name = ie.localName, oe.type = ie.type;
      }
    oe != null && ee.push(oe);
  });
  const ne = X.reduce((ie, oe) => {
    const se = oe.localName;
    return se && (ie[se] || (ie[se] = 0), ie[se]++), ie;
  }, {});
  X.forEach((ie, oe) => {
    let se = ie.localName;
    if (!se || ne[se] !== 1 || (se === "length" && (se = "_length"), ee[se] != null))
      return;
    const ae = ee[oe];
    ae instanceof Error ? Object.defineProperty(ee, se, {
      enumerable: !0,
      get: () => {
        throw ae;
      }
    }) : ee[se] = ae;
  });
  for (let ie = 0; ie < ee.length; ie++) {
    const oe = ee[ie];
    oe instanceof Error && Object.defineProperty(ee, ie, {
      enumerable: !0,
      get: () => {
        throw oe;
      }
    });
  }
  return Object.freeze(ee);
}
class ArrayCoder extends Coder {
  constructor(X, ee, te) {
    const ne = X.type + "[" + (ee >= 0 ? ee : "") + "]", ie = ee === -1 || X.dynamic;
    super("array", ne, te, ie), this.coder = X, this.length = ee;
  }
  defaultValue() {
    const X = this.coder.defaultValue(), ee = [];
    for (let te = 0; te < this.length; te++)
      ee.push(X);
    return ee;
  }
  encode(X, ee) {
    Array.isArray(ee) || this._throwError("expected array value", ee);
    let te = this.length;
    te === -1 && (te = ee.length, X.writeValue(ee.length)), logger$f.checkArgumentCount(ee.length, te, "coder array" + (this.localName ? " " + this.localName : ""));
    let ne = [];
    for (let ie = 0; ie < ee.length; ie++)
      ne.push(this.coder);
    return pack(X, ne, ee);
  }
  decode(X) {
    let ee = this.length;
    ee === -1 && (ee = X.readValue().toNumber(), ee * 32 > X._data.length && logger$f.throwError("insufficient data length", Logger.errors.BUFFER_OVERRUN, {
      length: X._data.length,
      count: ee
    }));
    let te = [];
    for (let ne = 0; ne < ee; ne++)
      te.push(new AnonymousCoder(this.coder));
    return X.coerce(this.name, unpack(X, te));
  }
}
class BooleanCoder extends Coder {
  constructor(X) {
    super("bool", "bool", X, !1);
  }
  defaultValue() {
    return !1;
  }
  encode(X, ee) {
    return X.writeValue(ee ? 1 : 0);
  }
  decode(X) {
    return X.coerce(this.type, !X.readValue().isZero());
  }
}
class DynamicBytesCoder extends Coder {
  constructor(X, ee) {
    super(X, X, ee, !0);
  }
  defaultValue() {
    return "0x";
  }
  encode(X, ee) {
    ee = arrayify(ee);
    let te = X.writeValue(ee.length);
    return te += X.writeBytes(ee), te;
  }
  decode(X) {
    return X.readBytes(X.readValue().toNumber(), !0);
  }
}
class BytesCoder extends DynamicBytesCoder {
  constructor(X) {
    super("bytes", X);
  }
  decode(X) {
    return X.coerce(this.name, hexlify(super.decode(X)));
  }
}
class FixedBytesCoder extends Coder {
  constructor(X, ee) {
    let te = "bytes" + String(X);
    super(te, te, ee, !1), this.size = X;
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(0, 2 + this.size * 2);
  }
  encode(X, ee) {
    let te = arrayify(ee);
    return te.length !== this.size && this._throwError("incorrect data length", ee), X.writeBytes(te);
  }
  decode(X) {
    return X.coerce(this.name, hexlify(X.readBytes(this.size)));
  }
}
class NullCoder extends Coder {
  constructor(X) {
    super("null", "", X, !1);
  }
  defaultValue() {
    return null;
  }
  encode(X, ee) {
    return ee != null && this._throwError("not null", ee), X.writeBytes([]);
  }
  decode(X) {
    return X.readBytes(0), X.coerce(this.name, null);
  }
}
const AddressZero = "0x0000000000000000000000000000000000000000", NegativeOne$1 = /* @__PURE__ */ BigNumber.from(-1), Zero$1 = /* @__PURE__ */ BigNumber.from(0), One$1 = /* @__PURE__ */ BigNumber.from(1), MaxUint256$1 = /* @__PURE__ */ BigNumber.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"), HashZero = "0x0000000000000000000000000000000000000000000000000000000000000000";
class NumberCoder extends Coder {
  constructor(X, ee, te) {
    const ne = (ee ? "int" : "uint") + X * 8;
    super(ne, ne, te, !1), this.size = X, this.signed = ee;
  }
  defaultValue() {
    return 0;
  }
  encode(X, ee) {
    let te = BigNumber.from(ee), ne = MaxUint256$1.mask(X.wordSize * 8);
    if (this.signed) {
      let ie = ne.mask(this.size * 8 - 1);
      (te.gt(ie) || te.lt(ie.add(One$1).mul(NegativeOne$1))) && this._throwError("value out-of-bounds", ee);
    } else
      (te.lt(Zero$1) || te.gt(ne.mask(this.size * 8))) && this._throwError("value out-of-bounds", ee);
    return te = te.toTwos(this.size * 8).mask(this.size * 8), this.signed && (te = te.fromTwos(this.size * 8).toTwos(8 * X.wordSize)), X.writeValue(te);
  }
  decode(X) {
    let ee = X.readValue().mask(this.size * 8);
    return this.signed && (ee = ee.fromTwos(this.size * 8)), X.coerce(this.name, ee);
  }
}
const version$b = "strings/5.7.0", logger$e = new Logger(version$b);
var UnicodeNormalizationForm;
(function(Y) {
  Y.current = "", Y.NFC = "NFC", Y.NFD = "NFD", Y.NFKC = "NFKC", Y.NFKD = "NFKD";
})(UnicodeNormalizationForm || (UnicodeNormalizationForm = {}));
var Utf8ErrorReason;
(function(Y) {
  Y.UNEXPECTED_CONTINUE = "unexpected continuation byte", Y.BAD_PREFIX = "bad codepoint prefix", Y.OVERRUN = "string overrun", Y.MISSING_CONTINUE = "missing continuation byte", Y.OUT_OF_RANGE = "out of UTF-8 range", Y.UTF16_SURROGATE = "UTF-16 surrogate", Y.OVERLONG = "overlong representation";
})(Utf8ErrorReason || (Utf8ErrorReason = {}));
function errorFunc(Y, X, ee, te, ne) {
  return logger$e.throwArgumentError(`invalid codepoint at offset ${X}; ${Y}`, "bytes", ee);
}
function ignoreFunc(Y, X, ee, te, ne) {
  if (Y === Utf8ErrorReason.BAD_PREFIX || Y === Utf8ErrorReason.UNEXPECTED_CONTINUE) {
    let ie = 0;
    for (let oe = X + 1; oe < ee.length && ee[oe] >> 6 === 2; oe++)
      ie++;
    return ie;
  }
  return Y === Utf8ErrorReason.OVERRUN ? ee.length - X - 1 : 0;
}
function replaceFunc(Y, X, ee, te, ne) {
  return Y === Utf8ErrorReason.OVERLONG ? (te.push(ne), 0) : (te.push(65533), ignoreFunc(Y, X, ee));
}
const Utf8ErrorFuncs = Object.freeze({
  error: errorFunc,
  ignore: ignoreFunc,
  replace: replaceFunc
});
function getUtf8CodePoints(Y, X) {
  X == null && (X = Utf8ErrorFuncs.error), Y = arrayify(Y);
  const ee = [];
  let te = 0;
  for (; te < Y.length; ) {
    const ne = Y[te++];
    if (!(ne >> 7)) {
      ee.push(ne);
      continue;
    }
    let ie = null, oe = null;
    if ((ne & 224) === 192)
      ie = 1, oe = 127;
    else if ((ne & 240) === 224)
      ie = 2, oe = 2047;
    else if ((ne & 248) === 240)
      ie = 3, oe = 65535;
    else {
      (ne & 192) === 128 ? te += X(Utf8ErrorReason.UNEXPECTED_CONTINUE, te - 1, Y, ee) : te += X(Utf8ErrorReason.BAD_PREFIX, te - 1, Y, ee);
      continue;
    }
    if (te - 1 + ie >= Y.length) {
      te += X(Utf8ErrorReason.OVERRUN, te - 1, Y, ee);
      continue;
    }
    let se = ne & (1 << 8 - ie - 1) - 1;
    for (let ae = 0; ae < ie; ae++) {
      let ue = Y[te];
      if ((ue & 192) != 128) {
        te += X(Utf8ErrorReason.MISSING_CONTINUE, te, Y, ee), se = null;
        break;
      }
      se = se << 6 | ue & 63, te++;
    }
    if (se !== null) {
      if (se > 1114111) {
        te += X(Utf8ErrorReason.OUT_OF_RANGE, te - 1 - ie, Y, ee, se);
        continue;
      }
      if (se >= 55296 && se <= 57343) {
        te += X(Utf8ErrorReason.UTF16_SURROGATE, te - 1 - ie, Y, ee, se);
        continue;
      }
      if (se <= oe) {
        te += X(Utf8ErrorReason.OVERLONG, te - 1 - ie, Y, ee, se);
        continue;
      }
      ee.push(se);
    }
  }
  return ee;
}
function toUtf8Bytes(Y, X = UnicodeNormalizationForm.current) {
  X != UnicodeNormalizationForm.current && (logger$e.checkNormalize(), Y = Y.normalize(X));
  let ee = [];
  for (let te = 0; te < Y.length; te++) {
    const ne = Y.charCodeAt(te);
    if (ne < 128)
      ee.push(ne);
    else if (ne < 2048)
      ee.push(ne >> 6 | 192), ee.push(ne & 63 | 128);
    else if ((ne & 64512) == 55296) {
      te++;
      const ie = Y.charCodeAt(te);
      if (te >= Y.length || (ie & 64512) !== 56320)
        throw new Error("invalid utf-8 string");
      const oe = 65536 + ((ne & 1023) << 10) + (ie & 1023);
      ee.push(oe >> 18 | 240), ee.push(oe >> 12 & 63 | 128), ee.push(oe >> 6 & 63 | 128), ee.push(oe & 63 | 128);
    } else
      ee.push(ne >> 12 | 224), ee.push(ne >> 6 & 63 | 128), ee.push(ne & 63 | 128);
  }
  return arrayify(ee);
}
function _toUtf8String(Y) {
  return Y.map((X) => X <= 65535 ? String.fromCharCode(X) : (X -= 65536, String.fromCharCode((X >> 10 & 1023) + 55296, (X & 1023) + 56320))).join("");
}
function toUtf8String(Y, X) {
  return _toUtf8String(getUtf8CodePoints(Y, X));
}
function toUtf8CodePoints(Y, X = UnicodeNormalizationForm.current) {
  return getUtf8CodePoints(toUtf8Bytes(Y, X));
}
class StringCoder extends DynamicBytesCoder {
  constructor(X) {
    super("string", X);
  }
  defaultValue() {
    return "";
  }
  encode(X, ee) {
    return super.encode(X, toUtf8Bytes(ee));
  }
  decode(X) {
    return toUtf8String(super.decode(X));
  }
}
class TupleCoder extends Coder {
  constructor(X, ee) {
    let te = !1;
    const ne = [];
    X.forEach((oe) => {
      oe.dynamic && (te = !0), ne.push(oe.type);
    });
    const ie = "tuple(" + ne.join(",") + ")";
    super("tuple", ie, ee, te), this.coders = X;
  }
  defaultValue() {
    const X = [];
    this.coders.forEach((te) => {
      X.push(te.defaultValue());
    });
    const ee = this.coders.reduce((te, ne) => {
      const ie = ne.localName;
      return ie && (te[ie] || (te[ie] = 0), te[ie]++), te;
    }, {});
    return this.coders.forEach((te, ne) => {
      let ie = te.localName;
      !ie || ee[ie] !== 1 || (ie === "length" && (ie = "_length"), X[ie] == null && (X[ie] = X[ne]));
    }), Object.freeze(X);
  }
  encode(X, ee) {
    return pack(X, this.coders, ee);
  }
  decode(X) {
    return X.coerce(this.name, unpack(X, this.coders));
  }
}
const logger$d = new Logger(version$e), paramTypeBytes = new RegExp(/^bytes([0-9]*)$/), paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);
class AbiCoder {
  constructor(X) {
    defineReadOnly(this, "coerceFunc", X || null);
  }
  _getCoder(X) {
    switch (X.baseType) {
      case "address":
        return new AddressCoder(X.name);
      case "bool":
        return new BooleanCoder(X.name);
      case "string":
        return new StringCoder(X.name);
      case "bytes":
        return new BytesCoder(X.name);
      case "array":
        return new ArrayCoder(this._getCoder(X.arrayChildren), X.arrayLength, X.name);
      case "tuple":
        return new TupleCoder((X.components || []).map((te) => this._getCoder(te)), X.name);
      case "":
        return new NullCoder(X.name);
    }
    let ee = X.type.match(paramTypeNumber);
    if (ee) {
      let te = parseInt(ee[2] || "256");
      return (te === 0 || te > 256 || te % 8 !== 0) && logger$d.throwArgumentError("invalid " + ee[1] + " bit length", "param", X), new NumberCoder(te / 8, ee[1] === "int", X.name);
    }
    if (ee = X.type.match(paramTypeBytes), ee) {
      let te = parseInt(ee[1]);
      return (te === 0 || te > 32) && logger$d.throwArgumentError("invalid bytes length", "param", X), new FixedBytesCoder(te, X.name);
    }
    return logger$d.throwArgumentError("invalid type", "type", X.type);
  }
  _getWordSize() {
    return 32;
  }
  _getReader(X, ee) {
    return new Reader(X, this._getWordSize(), this.coerceFunc, ee);
  }
  _getWriter() {
    return new Writer(this._getWordSize());
  }
  getDefaultValue(X) {
    const ee = X.map((te) => this._getCoder(ParamType.from(te)));
    return new TupleCoder(ee, "_").defaultValue();
  }
  encode(X, ee) {
    X.length !== ee.length && logger$d.throwError("types/values length mismatch", Logger.errors.INVALID_ARGUMENT, {
      count: { types: X.length, values: ee.length },
      value: { types: X, values: ee }
    });
    const te = X.map((oe) => this._getCoder(ParamType.from(oe))), ne = new TupleCoder(te, "_"), ie = this._getWriter();
    return ne.encode(ie, ee), ie.data;
  }
  decode(X, ee, te) {
    const ne = X.map((ie) => this._getCoder(ParamType.from(ie)));
    return new TupleCoder(ne, "_").decode(this._getReader(arrayify(ee), te));
  }
}
const defaultAbiCoder = new AbiCoder();
function id(Y) {
  return keccak256(toUtf8Bytes(Y));
}
const version$a = "hash/5.7.0";
function decode$1(Y) {
  Y = atob(Y);
  const X = [];
  for (let ee = 0; ee < Y.length; ee++)
    X.push(Y.charCodeAt(ee));
  return arrayify(X);
}
function encode$1(Y) {
  Y = arrayify(Y);
  let X = "";
  for (let ee = 0; ee < Y.length; ee++)
    X += String.fromCharCode(Y[ee]);
  return btoa(X);
}
function flat(Y, X) {
  X == null && (X = 1);
  const ee = [], te = ee.forEach, ne = function(ie, oe) {
    te.call(ie, function(se) {
      oe > 0 && Array.isArray(se) ? ne(se, oe - 1) : ee.push(se);
    });
  };
  return ne(Y, X), ee;
}
function fromEntries(Y) {
  const X = {};
  for (let ee = 0; ee < Y.length; ee++) {
    const te = Y[ee];
    X[te[0]] = te[1];
  }
  return X;
}
function decode_arithmetic(Y) {
  let X = 0;
  function ee() {
    return Y[X++] << 8 | Y[X++];
  }
  let te = ee(), ne = 1, ie = [0, 1];
  for (let Ke = 1; Ke < te; Ke++)
    ie.push(ne += ee());
  let oe = ee(), se = X;
  X += oe;
  let ae = 0, ue = 0;
  function le() {
    return ae == 0 && (ue = ue << 8 | Y[X++], ae = 8), ue >> --ae & 1;
  }
  const he = 31, me = Math.pow(2, he), ye = me >>> 1, we = ye >> 1, Ee = me - 1;
  let Re = 0;
  for (let Ke = 0; Ke < he; Ke++)
    Re = Re << 1 | le();
  let Ue = [], Me = 0, De = me;
  for (; ; ) {
    let Ke = Math.floor(((Re - Me + 1) * ne - 1) / De), tt = 0, rt = te;
    for (; rt - tt > 1; ) {
      let Dt = tt + rt >>> 1;
      Ke < ie[Dt] ? rt = Dt : tt = Dt;
    }
    if (tt == 0)
      break;
    Ue.push(tt);
    let it = Me + Math.floor(De * ie[tt] / ne), _t = Me + Math.floor(De * ie[tt + 1] / ne) - 1;
    for (; !((it ^ _t) & ye); )
      Re = Re << 1 & Ee | le(), it = it << 1 & Ee, _t = _t << 1 & Ee | 1;
    for (; it & ~_t & we; )
      Re = Re & ye | Re << 1 & Ee >>> 1 | le(), it = it << 1 ^ ye, _t = (_t ^ ye) << 1 | ye | 1;
    Me = it, De = 1 + _t - it;
  }
  let Fe = te - 4;
  return Ue.map((Ke) => {
    switch (Ke - Fe) {
      case 3:
        return Fe + 65792 + (Y[se++] << 16 | Y[se++] << 8 | Y[se++]);
      case 2:
        return Fe + 256 + (Y[se++] << 8 | Y[se++]);
      case 1:
        return Fe + Y[se++];
      default:
        return Ke - 1;
    }
  });
}
function read_payload(Y) {
  let X = 0;
  return () => Y[X++];
}
function read_compressed_payload(Y) {
  return read_payload(decode_arithmetic(Y));
}
function signed(Y) {
  return Y & 1 ? ~Y >> 1 : Y >> 1;
}
function read_counts(Y, X) {
  let ee = Array(Y);
  for (let te = 0; te < Y; te++)
    ee[te] = 1 + X();
  return ee;
}
function read_ascending(Y, X) {
  let ee = Array(Y);
  for (let te = 0, ne = -1; te < Y; te++)
    ee[te] = ne += 1 + X();
  return ee;
}
function read_deltas(Y, X) {
  let ee = Array(Y);
  for (let te = 0, ne = 0; te < Y; te++)
    ee[te] = ne += signed(X());
  return ee;
}
function read_member_array(Y, X) {
  let ee = read_ascending(Y(), Y), te = Y(), ne = read_ascending(te, Y), ie = read_counts(te, Y);
  for (let oe = 0; oe < te; oe++)
    for (let se = 0; se < ie[oe]; se++)
      ee.push(ne[oe] + se);
  return X ? ee.map((oe) => X[oe]) : ee;
}
function read_mapped_map(Y) {
  let X = [];
  for (; ; ) {
    let ee = Y();
    if (ee == 0)
      break;
    X.push(read_linear_table(ee, Y));
  }
  for (; ; ) {
    let ee = Y() - 1;
    if (ee < 0)
      break;
    X.push(read_replacement_table(ee, Y));
  }
  return fromEntries(flat(X));
}
function read_zero_terminated_array(Y) {
  let X = [];
  for (; ; ) {
    let ee = Y();
    if (ee == 0)
      break;
    X.push(ee);
  }
  return X;
}
function read_transposed(Y, X, ee) {
  let te = Array(Y).fill(void 0).map(() => []);
  for (let ne = 0; ne < X; ne++)
    read_deltas(Y, ee).forEach((ie, oe) => te[oe].push(ie));
  return te;
}
function read_linear_table(Y, X) {
  let ee = 1 + X(), te = X(), ne = read_zero_terminated_array(X), ie = read_transposed(ne.length, 1 + Y, X);
  return flat(ie.map((oe, se) => {
    const ae = oe[0], ue = oe.slice(1);
    return Array(ne[se]).fill(void 0).map((le, he) => {
      let me = he * te;
      return [ae + he * ee, ue.map((ye) => ye + me)];
    });
  }));
}
function read_replacement_table(Y, X) {
  let ee = 1 + X();
  return read_transposed(ee, 1 + Y, X).map((te) => [te[0], te.slice(1)]);
}
function read_emoji_trie(Y) {
  let X = read_member_array(Y).sort((te, ne) => te - ne);
  return ee();
  function ee() {
    let te = [];
    for (; ; ) {
      let ue = read_member_array(Y, X);
      if (ue.length == 0)
        break;
      te.push({ set: new Set(ue), node: ee() });
    }
    te.sort((ue, le) => le.set.size - ue.set.size);
    let ne = Y(), ie = ne % 3;
    ne = ne / 3 | 0;
    let oe = !!(ne & 1);
    ne >>= 1;
    let se = ne == 1, ae = ne == 2;
    return { branches: te, valid: ie, fe0f: oe, save: se, check: ae };
  }
}
function getData() {
  return read_compressed_payload(decode$1("AEQF2AO2DEsA2wIrAGsBRABxAN8AZwCcAEwAqgA0AGwAUgByADcATAAVAFYAIQAyACEAKAAYAFgAGwAjABQAMAAmADIAFAAfABQAKwATACoADgAbAA8AHQAYABoAGQAxADgALAAoADwAEwA9ABMAGgARAA4ADwAWABMAFgAIAA8AHgQXBYMA5BHJAS8JtAYoAe4AExozi0UAH21tAaMnBT8CrnIyhrMDhRgDygIBUAEHcoFHUPe8AXBjAewCjgDQR8IICIcEcQLwATXCDgzvHwBmBoHNAqsBdBcUAykgDhAMShskMgo8AY8jqAQfAUAfHw8BDw87MioGlCIPBwZCa4ELatMAAMspJVgsDl8AIhckSg8XAHdvTwBcIQEiDT4OPhUqbyECAEoAS34Aej8Ybx83JgT/Xw8gHxZ/7w8RICxPHA9vBw+Pfw8PHwAPFv+fAsAvCc8vEr8ivwD/EQ8Bol8OEBa/A78hrwAPCU8vESNvvwWfHwNfAVoDHr+ZAAED34YaAdJPAK7PLwSEgDLHAGo1Pz8Pvx9fUwMrpb8O/58VTzAPIBoXIyQJNF8hpwIVAT8YGAUADDNBaX3RAMomJCg9EhUeA29MABsZBTMNJipjOhc19gcIDR8bBwQHEggCWi6DIgLuAQYA+BAFCha3A5XiAEsqM7UFFgFLhAMjFTMYE1Klnw74nRVBG/ASCm0BYRN/BrsU3VoWy+S0vV8LQx+vN8gF2AC2AK5EAWwApgYDKmAAroQ0NDQ0AT+OCg7wAAIHRAbpNgVcBV0APTA5BfbPFgMLzcYL/QqqA82eBALKCjQCjqYCht0/k2+OAsXQAoP3ASTKDgDw6ACKAUYCMpIKJpRaAE4A5womABzZvs0REEKiACIQAd5QdAECAj4Ywg/wGqY2AVgAYADYvAoCGAEubA0gvAY2ALAAbpbvqpyEAGAEpgQAJgAG7gAgAEACmghUFwCqAMpAINQIwC4DthRAAPcycKgApoIdABwBfCisABoATwBqASIAvhnSBP8aH/ECeAKXAq40NjgDBTwFYQU6AXs3oABgAD4XNgmcCY1eCl5tIFZeUqGgyoNHABgAEQAaABNwWQAmABMATPMa3T34ADldyprmM1M2XociUQgLzvwAXT3xABgAEQAaABNwIGFAnADD8AAgAD4BBJWzaCcIAIEBFMAWwKoAAdq9BWAF5wLQpALEtQAKUSGkahR4GnJM+gsAwCgeFAiUAECQ0BQuL8AAIAAAADKeIheclvFqQAAETr4iAMxIARMgAMIoHhQIAn0E0pDQFC4HhznoAAAAIAI2C0/4lvFqQAAETgBJJwYCAy4ABgYAFAA8MBKYEH4eRhTkAjYeFcgACAYAeABsOqyQ5gRwDayqugEgaIIAtgoACgDmEABmBAWGme5OBJJA2m4cDeoAmITWAXwrMgOgAGwBCh6CBXYF1Tzg1wKAAFdiuABRAFwAXQBsAG8AdgBrAHYAbwCEAHEwfxQBVE5TEQADVFhTBwBDANILAqcCzgLTApQCrQL6vAAMAL8APLhNBKkE6glGKTAU4Dr4N2EYEwBCkABKk8rHAbYBmwIoAiU4Ajf/Aq4CowCAANIChzgaNBsCsTgeODcFXrgClQKdAqQBiQGYAqsCsjTsNHsfNPA0ixsAWTWiOAMFPDQSNCk2BDZHNow2TTZUNhk28Jk9VzI3QkEoAoICoQKwAqcAQAAxBV4FXbS9BW47YkIXP1ciUqs05DS/FwABUwJW11e6nHuYZmSh/RAYA8oMKvZ8KASoUAJYWAJ6ILAsAZSoqjpgA0ocBIhmDgDWAAawRDQoAAcuAj5iAHABZiR2AIgiHgCaAU68ACxuHAG0ygM8MiZIAlgBdF4GagJqAPZOHAMuBgoATkYAsABiAHgAMLoGDPj0HpKEBAAOJgAuALggTAHWAeAMEDbd20Uege0ADwAWADkAQgA9OHd+2MUQZBBhBgNNDkxxPxUQArEPqwvqERoM1irQ090ANK4H8ANYB/ADWANYB/AH8ANYB/ADWANYA1gDWBwP8B/YxRBkD00EcgWTBZAE2wiIJk4RhgctCNdUEnQjHEwDSgEBIypJITuYMxAlR0wRTQgIATZHbKx9PQNMMbBU+pCnA9AyVDlxBgMedhKlAC8PeCE1uk6DekxxpQpQT7NX9wBFBgASqwAS5gBJDSgAUCwGPQBI4zTYABNGAE2bAE3KAExdGABKaAbgAFBXAFCOAFBJABI2SWdObALDOq0//QomCZhvwHdTBkIQHCemEPgMNAG2ATwN7kvZBPIGPATKH34ZGg/OlZ0Ipi3eDO4m5C6igFsj9iqEBe5L9TzeC05RaQ9aC2YJ5DpkgU8DIgEOIowK3g06CG4Q9ArKbA3mEUYHOgPWSZsApgcCCxIdNhW2JhFirQsKOXgG/Br3C5AmsBMqev0F1BoiBk4BKhsAANAu6IWxWjJcHU9gBgQLJiPIFKlQIQ0mQLh4SRocBxYlqgKSQ3FKiFE3HpQh9zw+DWcuFFF9B/Y8BhlQC4I8n0asRQ8R0z6OPUkiSkwtBDaALDAnjAnQD4YMunxzAVoJIgmyDHITMhEYN8YIOgcaLpclJxYIIkaWYJsE+KAD9BPSAwwFQAlCBxQDthwuEy8VKgUOgSXYAvQ21i60ApBWgQEYBcwPJh/gEFFH4Q7qCJwCZgOEJewALhUiABginAhEZABgj9lTBi7MCMhqbSN1A2gU6GIRdAeSDlgHqBw0FcAc4nDJXgyGCSiksAlcAXYJmgFgBOQICjVcjKEgQmdUi1kYnCBiQUBd/QIyDGYVoES+h3kCjA9sEhwBNgF0BzoNAgJ4Ee4RbBCWCOyGBTW2M/k6JgRQIYQgEgooA1BszwsoJvoM+WoBpBJjAw00PnfvZ6xgtyUX/gcaMsZBYSHyC5NPzgydGsIYQ1QvGeUHwAP0GvQn60FYBgADpAQUOk4z7wS+C2oIjAlAAEoOpBgH2BhrCnKM0QEyjAG4mgNYkoQCcJAGOAcMAGgMiAV65gAeAqgIpAAGANADWAA6Aq4HngAaAIZCAT4DKDABIuYCkAOUCDLMAZYwAfQqBBzEDBYA+DhuSwLDsgKAa2ajBd5ZAo8CSjYBTiYEBk9IUgOwcuIA3ABMBhTgSAEWrEvMG+REAeBwLADIAPwABjYHBkIBzgH0bgC4AWALMgmjtLYBTuoqAIQAFmwB2AKKAN4ANgCA8gFUAE4FWvoF1AJQSgESMhksWGIBvAMgATQBDgB6BsyOpsoIIARuB9QCEBwV4gLvLwe2AgMi4BPOQsYCvd9WADIXUu5eZwqoCqdeaAC0YTQHMnM9UQAPH6k+yAdy/BZIiQImSwBQ5gBQQzSaNTFWSTYBpwGqKQK38AFtqwBI/wK37gK3rQK3sAK6280C0gK33AK3zxAAUEIAUD9SklKDArekArw5AEQAzAHCO147WTteO1k7XjtZO147WTteO1kDmChYI03AVU0oJqkKbV9GYewMpw3VRMk6ShPcYFJgMxPJLbgUwhXPJVcZPhq9JwYl5VUKDwUt1GYxCC00dhe9AEApaYNCY4ceMQpMHOhTklT5LRwAskujM7ANrRsWREEFSHXuYisWDwojAmSCAmJDXE6wXDchAqH4AmiZAmYKAp+FOBwMAmY8AmYnBG8EgAN/FAN+kzkHOXgYOYM6JCQCbB4CMjc4CwJtyAJtr/CLADRoRiwBaADfAOIASwYHmQyOAP8MwwAOtgJ3MAJ2o0ACeUxEAni7Hl3cRa9G9AJ8QAJ6yQJ9CgJ88UgBSH5kJQAsFklZSlwWGErNAtECAtDNSygDiFADh+dExpEzAvKiXQQDA69Lz0wuJgTQTU1NsAKLQAKK2cIcCB5EaAa4Ao44Ao5dQZiCAo7aAo5deVG1UzYLUtVUhgKT/AKTDQDqAB1VH1WwVdEHLBwplocy4nhnRTw6ApegAu+zWCKpAFomApaQApZ9nQCqWa1aCoJOADwClrYClk9cRVzSApnMApllXMtdCBoCnJw5wzqeApwXAp+cAp65iwAeEDIrEAKd8gKekwC2PmE1YfACntQCoG8BqgKeoCACnk+mY8lkKCYsAiewAiZ/AqD8AqBN2AKmMAKlzwKoAAB+AqfzaH1osgAESmodatICrOQCrK8CrWgCrQMCVx4CVd0CseLYAx9PbJgCsr4OArLpGGzhbWRtSWADJc4Ctl08QG6RAylGArhfArlIFgK5K3hwN3DiAr0aAy2zAzISAr6JcgMDM3ICvhtzI3NQAsPMAsMFc4N0TDZGdOEDPKgDPJsDPcACxX0CxkgCxhGKAshqUgLIRQLJUALJLwJkngLd03h6YniveSZL0QMYpGcDAmH1GfSVJXsMXpNevBICz2wCz20wTFTT9BSgAMeuAs90ASrrA04TfkwGAtwoAtuLAtJQA1JdA1NgAQIDVY2AikABzBfuYUZ2AILPg44C2sgC2d+EEYRKpz0DhqYAMANkD4ZyWvoAVgLfZgLeuXR4AuIw7RUB8zEoAfScAfLTiALr9ALpcXoAAur6AurlAPpIAboC7ooC652Wq5cEAu5AA4XhmHpw4XGiAvMEAGoDjheZlAL3FAORbwOSiAL3mQL52gL4Z5odmqy8OJsfA52EAv77ARwAOp8dn7QDBY4DpmsDptoA0sYDBmuhiaIGCgMMSgFgASACtgNGAJwEgLpoBgC8BGzAEowcggCEDC6kdjoAJAM0C5IKRoABZCgiAIzw3AYBLACkfng9ogigkgNmWAN6AEQCvrkEVqTGAwCsBRbAA+4iQkMCHR072jI2PTbUNsk2RjY5NvA23TZKNiU3EDcZN5I+RTxDRTBCJkK5VBYKFhZfwQCWygU3AJBRHpu+OytgNxa61A40GMsYjsn7BVwFXQVcBV0FaAVdBVwFXQVcBV0FXAVdBVwFXUsaCNyKAK4AAQUHBwKU7oICoW1e7jAEzgPxA+YDwgCkBFDAwADABKzAAOxFLhitA1UFTDeyPkM+bj51QkRCuwTQWWQ8X+0AWBYzsACNA8xwzAGm7EZ/QisoCTAbLDs6fnLfb8H2GccsbgFw13M1HAVkBW/Jxsm9CNRO8E8FDD0FBQw9FkcClOYCoMFegpDfADgcMiA2AJQACB8AsigKAIzIEAJKeBIApY5yPZQIAKQiHb4fvj5BKSRPQrZCOz0oXyxgOywfKAnGbgMClQaCAkILXgdeCD9IIGUgQj5fPoY+dT52Ao5CM0dAX9BTVG9SDzFwWTQAbxBzJF/lOEIQQglCCkKJIAls5AcClQICoKPMODEFxhi6KSAbiyfIRrMjtCgdWCAkPlFBIitCsEJRzAbMAV/OEyQzDg0OAQQEJ36i328/Mk9AybDJsQlq3tDRApUKAkFzXf1d/j9uALYP6hCoFgCTGD8kPsFKQiobrm0+zj0KSD8kPnVCRBwMDyJRTHFgMTJa5rwXQiQ2YfI/JD7BMEJEHGINTw4TOFlIRzwJO0icMQpyPyQ+wzJCRBv6DVgnKB01NgUKj2bwYzMqCoBkznBgEF+zYDIocwRIX+NgHj4HICNfh2C4CwdwFWpTG/lgUhYGAwRfv2Ts8mAaXzVgml/XYIJfuWC4HI1gUF9pYJZgMR6ilQHMAOwLAlDRefC0in4AXAEJA6PjCwc0IamOANMMCAECRQDFNRTZBgd+CwQlRA+r6+gLBDEFBnwUBXgKATIArwAGRAAHA3cDdAN2A3kDdwN9A3oDdQN7A30DfAN4A3oDfQAYEAAlAtYASwMAUAFsAHcKAHcAmgB3AHUAdQB2AHVu8UgAygDAAHcAdQB1AHYAdQALCgB3AAsAmgB3AAsCOwB3AAtu8UgAygDAAHgKAJoAdwB3AHUAdQB2AHUAeAB1AHUAdgB1bvFIAMoAwAALCgCaAHcACwB3AAsCOwB3AAtu8UgAygDAAH4ACwGgALcBpwC6AahdAu0COwLtbvFIAMoAwAALCgCaAu0ACwLtAAsCOwLtAAtu8UgAygDAA24ACwNvAAu0VsQAAzsAABCkjUIpAAsAUIusOggWcgMeBxVsGwL67U/2HlzmWOEeOgALASvuAAseAfpKUpnpGgYJDCIZM6YyARUE9ThqAD5iXQgnAJYJPnOzw0ZAEZxEKsIAkA4DhAHnTAIDxxUDK0lxCQlPYgIvIQVYJQBVqE1GakUAKGYiDToSBA1EtAYAXQJYAIF8GgMHRyAAIAjOe9YncekRAA0KACUrjwE7Ayc6AAYWAqaiKG4McEcqANoN3+Mg9TwCBhIkuCny+JwUQ29L008JluRxu3K+oAdqiHOqFH0AG5SUIfUJ5SxCGfxdipRzqTmT4V5Zb+r1Uo4Vm+NqSSEl2mNvR2JhIa8SpYO6ntdwFXHCWTCK8f2+Hxo7uiG3drDycAuKIMP5bhi06ACnqArH1rz4Rqg//lm6SgJGEVbF9xJHISaR6HxqxSnkw6shDnelHKNEfGUXSJRJ1GcsmtJw25xrZMDK9gXSm1/YMkdX4/6NKYOdtk/NQ3/NnDASjTc3fPjIjW/5sVfVObX2oTDWkr1dF9f3kxBsD3/3aQO8hPfRz+e0uEiJqt1161griu7gz8hDDwtpy+F+BWtefnKHZPAxcZoWbnznhJpy0e842j36bcNzGnIEusgGX0a8ZxsnjcSsPDZ09yZ36fCQbriHeQ72JRMILNl6ePPf2HWoVwgWAm1fb3V2sAY0+B6rAXqSwPBgseVmoqsBTSrm91+XasMYYySI8eeRxH3ZvHkMz3BQ5aJ3iUVbYPNM3/7emRtjlsMgv/9VyTsyt/mK+8fgWeT6SoFaclXqn42dAIsvAarF5vNNWHzKSkKQ/8Hfk5ZWK7r9yliOsooyBjRhfkHP4Q2DkWXQi6FG/9r/IwbmkV5T7JSopHKn1pJwm9tb5Ot0oyN1Z2mPpKXHTxx2nlK08fKk1hEYA8WgVVWL5lgx0iTv+KdojJeU23ZDjmiubXOxVXJKKi2Wjuh2HLZOFLiSC7Tls5SMh4f+Pj6xUSrNjFqLGehRNB8lC0QSLNmkJJx/wSG3MnjE9T1CkPwJI0wH2lfzwETIiVqUxg0dfu5q39Gt+hwdcxkhhNvQ4TyrBceof3Mhs/IxFci1HmHr4FMZgXEEczPiGCx0HRwzAqDq2j9AVm1kwN0mRVLWLylgtoPNapF5cY4Y1wJh/e0BBwZj44YgZrDNqvD/9Hv7GFYdUQeDJuQ3EWI4HaKqavU1XjC/n41kT4L79kqGq0kLhdTZvgP3TA3fS0ozVz+5piZsoOtIvBUFoMKbNcmBL6YxxaUAusHB38XrS8dQMnQwJfUUkpRoGr5AUeWicvBTzyK9g77+yCkf5PAysL7r/JjcZgrbvRpMW9iyaxZvKO6ceZN2EwIxKwVFPuvFuiEPGCoagbMo+SpydLrXqBzNCDGFCrO/rkcwa2xhokQZ5CdZ0AsU3JfSqJ6n5I14YA+P/uAgfhPU84Tlw7cEFfp7AEE8ey4sP12PTt4Cods1GRgDOB5xvyiR5m+Bx8O5nBCNctU8BevfV5A08x6RHd5jcwPTMDSZJOedIZ1cGQ704lxbAzqZOP05ZxaOghzSdvFBHYqomATARyAADK4elP8Ly3IrUZKfWh23Xy20uBUmLS4Pfagu9+oyVa2iPgqRP3F2CTUsvJ7+RYnN8fFZbU/HVvxvcFFDKkiTqV5UBZ3Gz54JAKByi9hkKMZJvuGgcSYXFmw08UyoQyVdfTD1/dMkCHXcTGAKeROgArsvmRrQTLUOXioOHGK2QkjHuoYFgXciZoTJd6Fs5q1QX1G+p/e26hYsEf7QZD1nnIyl/SFkNtYYmmBhpBrxl9WbY0YpHWRuw2Ll/tj9mD8P4snVzJl4F9J+1arVeTb9E5r2ILH04qStjxQNwn3m4YNqxmaNbLAqW2TN6LidwuJRqS+NXbtqxoeDXpxeGWmxzSkWxjkyCkX4NQRme6q5SAcC+M7+9ETfA/EwrzQajKakCwYyeunP6ZFlxU2oMEn1Pz31zeStW74G406ZJFCl1wAXIoUKkWotYEpOuXB1uVNxJ63dpJEqfxBeptwIHNrPz8BllZoIcBoXwgfJ+8VAUnVPvRvexnw0Ma/WiGYuJO5y8QTvEYBigFmhUxY5RqzE8OcywN/8m4UYrlaniJO75XQ6KSo9+tWHlu+hMi0UVdiKQp7NelnoZUzNaIyBPVeOwK6GNp+FfHuPOoyhaWuNvTYFkvxscMQWDh+zeFCFkgwbXftiV23ywJ4+uwRqmg9k3KzwIQpzppt8DBBOMbrqwQM5Gb05sEwdKzMiAqOloaA/lr0KA+1pr0/+HiWoiIjHA/wir2nIuS3PeU/ji3O6ZwoxcR1SZ9FhtLC5S0FIzFhbBWcGVP/KpxOPSiUoAdWUpqKH++6Scz507iCcxYI6rdMBICPJZea7OcmeFw5mObJSiqpjg2UoWNIs+cFhyDSt6geV5qgi3FunmwwDoGSMgerFOZGX1m0dMCYo5XOruxO063dwENK9DbnVM9wYFREzh4vyU1WYYJ/LRRp6oxgjqP/X5a8/4Af6p6NWkQferzBmXme0zY/4nwMJm/wd1tIqSwGz+E3xPEAOoZlJit3XddD7/BT1pllzOx+8bmQtANQ/S6fZexc6qi3W+Q2xcmXTUhuS5mpHQRvcxZUN0S5+PL9lXWUAaRZhEH8hTdAcuNMMCuVNKTEGtSUKNi3O6KhSaTzck8csZ2vWRZ+d7mW8c4IKwXIYd25S/zIftPkwPzufjEvOHWVD1m+FjpDVUTV0DGDuHj6QnaEwLu/dEgdLQOg9E1Sro9XHJ8ykLAwtPu+pxqKDuFexqON1sKQm7rwbE1E68UCfA/erovrTCG+DBSNg0l4goDQvZN6uNlbyLpcZAwj2UclycvLpIZMgv4yRlpb3YuMftozorbcGVHt/VeDV3+Fdf1TP0iuaCsPi2G4XeGhsyF1ubVDxkoJhmniQ0/jSg/eYML9KLfnCFgISWkp91eauR3IQvED0nAPXK+6hPCYs+n3+hCZbiskmVMG2da+0EsZPonUeIY8EbfusQXjsK/eFDaosbPjEfQS0RKG7yj5GG69M7MeO1HmiUYocgygJHL6M1qzUDDwUSmr99V7Sdr2F3JjQAJY+F0yH33Iv3+C9M38eML7gTgmNu/r2bUMiPvpYbZ6v1/IaESirBHNa7mPKn4dEmYg7v/+HQgPN1G79jBQ1+soydfDC2r+h2Bl/KIc5KjMK7OH6nb1jLsNf0EHVe2KBiE51ox636uyG6Lho0t3J34L5QY/ilE3mikaF4HKXG1mG1rCevT1Vv6GavltxoQe/bMrpZvRggnBxSEPEeEzkEdOxTnPXHVjUYdw8JYvjB/o7Eegc3Ma+NUxLLnsK0kJlinPmUHzHGtrk5+CAbVzFOBqpyy3QVUnzTDfC/0XD94/okH+OB+i7g9lolhWIjSnfIb+Eq43ZXOWmwvjyV/qqD+t0e+7mTEM74qP/Ozt8nmC7mRpyu63OB4KnUzFc074SqoyPUAgM+/TJGFo6T44EHnQU4X4z6qannVqgw/U7zCpwcmXV1AubIrvOmkKHazJAR55ePjp5tLBsN8vAqs3NAHdcEHOR2xQ0lsNAFzSUuxFQCFYvXLZJdOj9p4fNq6p0HBGUik2YzaI4xySy91KzhQ0+q1hjxvImRwPRf76tChlRkhRCi74NXZ9qUNeIwP+s5p+3m5nwPdNOHgSLD79n7O9m1n1uDHiMntq4nkYwV5OZ1ENbXxFd4PgrlvavZsyUO4MqYlqqn1O8W/I1dEZq5dXhrbETLaZIbC2Kj/Aa/QM+fqUOHdf0tXAQ1huZ3cmWECWSXy/43j35+Mvq9xws7JKseriZ1pEWKc8qlzNrGPUGcVgOa9cPJYIJsGnJTAUsEcDOEVULO5x0rXBijc1lgXEzQQKhROf8zIV82w8eswc78YX11KYLWQRcgHNJElBxfXr72lS2RBSl07qTKorO2uUDZr3sFhYsvnhLZn0A94KRzJ/7DEGIAhW5ZWFpL8gEwu1aLA9MuWZzNwl8Oze9Y+bX+v9gywRVnoB5I/8kXTXU3141yRLYrIOOz6SOnyHNy4SieqzkBXharjfjqq1q6tklaEbA8Qfm2DaIPs7OTq/nvJBjKfO2H9bH2cCMh1+5gspfycu8f/cuuRmtDjyqZ7uCIMyjdV3a+p3fqmXsRx4C8lujezIFHnQiVTXLXuI1XrwN3+siYYj2HHTvESUx8DlOTXpak9qFRK+L3mgJ1WsD7F4cu1aJoFoYQnu+wGDMOjJM3kiBQWHCcvhJ/HRdxodOQp45YZaOTA22Nb4XKCVxqkbwMYFhzYQYIAnCW8FW14uf98jhUG2zrKhQQ0q0CEq0t5nXyvUyvR8DvD69LU+g3i+HFWQMQ8PqZuHD+sNKAV0+M6EJC0szq7rEr7B5bQ8BcNHzvDMc9eqB5ZCQdTf80Obn4uzjwpYU7SISdtV0QGa9D3Wrh2BDQtpBKxaNFV+/Cy2P/Sv+8s7Ud0Fd74X4+o/TNztWgETUapy+majNQ68Lq3ee0ZO48VEbTZYiH1Co4OlfWef82RWeyUXo7woM03PyapGfikTnQinoNq5z5veLpeMV3HCAMTaZmA1oGLAn7XS3XYsz+XK7VMQsc4XKrmDXOLU/pSXVNUq8dIqTba///3x6LiLS6xs1xuCAYSfcQ3+rQgmu7uvf3THKt5Ooo97TqcbRqxx7EASizaQCBQllG/rYxVapMLgtLbZS64w1MDBMXX+PQpBKNwqUKOf2DDRDUXQf9EhOS0Qj4nTmlA8dzSLz/G1d+Ud8MTy/6ghhdiLpeerGY/UlDOfiuqFsMUU5/UYlP+BAmgRLuNpvrUaLlVkrqDievNVEAwF+4CoM1MZTmjxjJMsKJq+u8Zd7tNCUFy6LiyYXRJQ4VyvEQFFaCGKsxIwQkk7EzZ6LTJq2hUuPhvAW+gQnSG6J+MszC+7QCRHcnqDdyNRJ6T9xyS87A6MDutbzKGvGktpbXqtzWtXb9HsfK2cBMomjN9a4y+TaJLnXxAeX/HWzmf4cR4vALt/P4w4qgKY04ml4ZdLOinFYS6cup3G/1ie4+t1eOnpBNlqGqs75ilzkT4+DsZQxNvaSKJ//6zIbbk/M7LOhFmRc/1R+kBtz7JFGdZm/COotIdvQoXpTqP/1uqEUmCb/QWoGLMwO5ANcHzxdY48IGP5+J+zKOTBFZ4Pid+GTM+Wq12MV/H86xEJptBa6T+p3kgpwLedManBHC2GgNrFpoN2xnrMz9WFWX/8/ygSBkavq2Uv7FdCsLEYLu9LLIvAU0bNRDtzYl+/vXmjpIvuJFYjmI0im6QEYqnIeMsNjXG4vIutIGHijeAG/9EDBozKV5cldkHbLxHh25vT+ZEzbhXlqvpzKJwcEgfNwLAKFeo0/pvEE10XDB+EXRTXtSzJozQKFFAJhMxYkVaCW+E9AL7tMeU8acxidHqzb6lX4691UsDpy/LLRmT+epgW56+5Cw8tB4kMUv6s9lh3eRKbyGs+H/4mQMaYzPTf2OOdokEn+zzgvoD3FqNKk8QqGAXVsqcGdXrT62fSPkR2vROFi68A6se86UxRUk4cajfPyCC4G5wDhD+zNq4jodQ4u4n/m37Lr36n4LIAAsVr02dFi9AiwA81MYs2rm4eDlDNmdMRvEKRHfBwW5DdMNp0jPFZMeARqF/wL4XBfd+EMLBfMzpH5GH6NaW+1vrvMdg+VxDzatk3MXgO3ro3P/DpcC6+Mo4MySJhKJhSR01SGGGp5hPWmrrUgrv3lDnP+HhcI3nt3YqBoVAVTBAQT5iuhTg8nvPtd8ZeYj6w1x6RqGUBrSku7+N1+BaasZvjTk64RoIDlL8brpEcJx3OmY7jLoZsswdtmhfC/G21llXhITOwmvRDDeTTPbyASOa16cF5/A1fZAidJpqju3wYAy9avPR1ya6eNp9K8XYrrtuxlqi+bDKwlfrYdR0RRiKRVTLOH85+ZY7XSmzRpfZBJjaTa81VDcJHpZnZnSQLASGYW9l51ZV/h7eVzTi3Hv6hUsgc/51AqJRTkpbFVLXXszoBL8nBX0u/0jBLT8nH+fJePbrwURT58OY+UieRjd1vs04w0VG5VN2U6MoGZkQzKN/ptz0Q366dxoTGmj7i1NQGHi9GgnquXFYdrCfZBmeb7s0T6yrdlZH5cZuwHFyIJ/kAtGsTg0xH5taAAq44BAk1CPk9KVVbqQzrCUiFdF/6gtlPQ8bHHc1G1W92MXGZ5HEHftyLYs8mbD/9xYRUWkHmlM0zC2ilJlnNgV4bfALpQghxOUoZL7VTqtCHIaQSXm+YUMnpkXybnV+A6xlm2CVy8fn0Xlm2XRa0+zzOa21JWWmixfiPMSCZ7qA4rS93VN3pkpF1s5TonQjisHf7iU9ZGvUPOAKZcR1pbeVf/Ul7OhepGCaId9wOtqo7pJ7yLcBZ0pFkOF28y4zEI/kcUNmutBHaQpBdNM8vjCS6HZRokkeo88TBAjGyG7SR+6vUgTcyK9Imalj0kuxz0wmK+byQU11AiJFk/ya5dNduRClcnU64yGu/ieWSeOos1t3ep+RPIWQ2pyTYVbZltTbsb7NiwSi3AV+8KLWk7LxCnfZUetEM8ThnsSoGH38/nyAwFguJp8FjvlHtcWZuU4hPva0rHfr0UhOOJ/F6vS62FW7KzkmRll2HEc7oUq4fyi5T70Vl7YVIfsPHUCdHesf9Lk7WNVWO75JDkYbMI8TOW8JKVtLY9d6UJRITO8oKo0xS+o99Yy04iniGHAaGj88kEWgwv0OrHdY/nr76DOGNS59hXCGXzTKUvDl9iKpLSWYN1lxIeyywdNpTkhay74w2jFT6NS8qkjo5CxA1yfSYwp6AJIZNKIeEK5PJAW7ORgWgwp0VgzYpqovMrWxbu+DGZ6Lhie1RAqpzm8VUzKJOH3mCzWuTOLsN3VT/dv2eeYe9UjbR8YTBsLz7q60VN1sU51k+um1f8JxD5pPhbhSC8rRaB454tmh6YUWrJI3+GWY0qeWioj/tbkYITOkJaeuGt4JrJvHA+l0Gu7kY7XOaa05alMnRWVCXqFgLIwSY4uF59Ue5SU4QKuc/HamDxbr0x6csCetXGoP7Qn1Bk/J9DsynO/UD6iZ1Hyrz+jit0hDCwi/E9OjgKTbB3ZQKQ/0ZOvevfNHG0NK4Aj3Cp7NpRk07RT1i/S0EL93Ag8GRgKI9CfpajKyK6+Jj/PI1KO5/85VAwz2AwzP8FTBb075IxCXv6T9RVvWT2tUaqxDS92zrGUbWzUYk9mSs82pECH+fkqsDt93VW++4YsR/dHCYcQSYTO/KaBMDj9LSD/J/+z20Kq8XvZUAIHtm9hRPP3ItbuAu2Hm5lkPs92pd7kCxgRs0xOVBnZ13ccdA0aunrwv9SdqElJRC3g+oCu+nXyCgmXUs9yMjTMAIHfxZV+aPKcZeUBWt057Xo85Ks1Ir5gzEHCWqZEhrLZMuF11ziGtFQUds/EESajhagzcKsxamcSZxGth4UII+adPhQkUnx2WyN+4YWR+r3f8MnkyGFuR4zjzxJS8WsQYR5PTyRaD9ixa6Mh741nBHbzfjXHskGDq179xaRNrCIB1z1xRfWfjqw2pHc1zk9xlPpL8sQWAIuETZZhbnmL54rceXVNRvUiKrrqIkeogsl0XXb17ylNb0f4GA9Wd44vffEG8FSZGHEL2fbaTGRcSiCeA8PmA/f6Hz8HCS76fXUHwgwkzSwlI71ekZ7Fapmlk/KC+Hs8hUcw3N2LN5LhkVYyizYFl/uPeVP5lsoJHhhfWvvSWruCUW1ZcJOeuTbrDgywJ/qG07gZJplnTvLcYdNaH0KMYOYMGX+rB4NGPFmQsNaIwlWrfCezxre8zXBrsMT+edVLbLqN1BqB76JH4BvZTqUIMfGwPGEn+EnmTV86fPBaYbFL3DFEhjB45CewkXEAtJxk4/Ms2pPXnaRqdky0HOYdcUcE2zcXq4vaIvW2/v0nHFJH2XXe22ueDmq/18XGtELSq85j9X8q0tcNSSKJIX8FTuJF/Pf8j5PhqG2u+osvsLxYrvvfeVJL+4tkcXcr9JV7v0ERmj/X6fM3NC4j6dS1+9Umr2oPavqiAydTZPLMNRGY23LO9zAVDly7jD+70G5TPPLdhRIl4WxcYjLnM+SNcJ26FOrkrISUtPObIz5Zb3AG612krnpy15RMW+1cQjlnWFI6538qky9axd2oJmHIHP08KyP0ubGO+TQNOYuv2uh17yCIvR8VcStw7o1g0NM60sk+8Tq7YfIBJrtp53GkvzXH7OA0p8/n/u1satf/VJhtR1l8Wa6Gmaug7haSpaCaYQax6ta0mkutlb+eAOSG1aobM81D9A4iS1RRlzBBoVX6tU1S6WE2N9ORY6DfeLRC4l9Rvr5h95XDWB2mR1d4WFudpsgVYwiTwT31ljskD8ZyDOlm5DkGh9N/UB/0AI5Xvb8ZBmai2hQ4BWMqFwYnzxwB26YHSOv9WgY3JXnvoN+2R4rqGVh/LLDMtpFP+SpMGJNWvbIl5SOodbCczW2RKleksPoUeGEzrjtKHVdtZA+kfqO+rVx/iclCqwoopepvJpSTDjT+b9GWylGRF8EDbGlw6eUzmJM95Ovoz+kwLX3c2fTjFeYEsE7vUZm3mqdGJuKh2w9/QGSaqRHs99aScGOdDqkFcACoqdbBoQqqjamhH6Q9ng39JCg3lrGJwd50Qk9ovnqBTr8MME7Ps2wiVfygUmPoUBJJfJWX5Nda0nuncbFkA=="));
}
const r$1 = getData(), VALID = new Set(read_member_array(r$1)), IGNORED = new Set(read_member_array(r$1)), MAPPED = read_mapped_map(r$1), EMOJI_ROOT = read_emoji_trie(r$1), HYPHEN = 45, UNDERSCORE = 95;
function explode_cp(Y) {
  return toUtf8CodePoints(Y);
}
function filter_fe0f(Y) {
  return Y.filter((X) => X != 65039);
}
function ens_normalize_post_check(Y) {
  for (let X of Y.split(".")) {
    let ee = explode_cp(X);
    try {
      for (let te = ee.lastIndexOf(UNDERSCORE) - 1; te >= 0; te--)
        if (ee[te] !== UNDERSCORE)
          throw new Error("underscore only allowed at start");
      if (ee.length >= 4 && ee.every((te) => te < 128) && ee[2] === HYPHEN && ee[3] === HYPHEN)
        throw new Error("invalid label extension");
    } catch (te) {
      throw new Error(`Invalid label "${X}": ${te.message}`);
    }
  }
  return Y;
}
function ens_normalize(Y) {
  return ens_normalize_post_check(normalize$1(Y, filter_fe0f));
}
function normalize$1(Y, X) {
  let ee = explode_cp(Y).reverse(), te = [];
  for (; ee.length; ) {
    let ne = consume_emoji_reversed(ee);
    if (ne) {
      te.push(...X(ne));
      continue;
    }
    let ie = ee.pop();
    if (VALID.has(ie)) {
      te.push(ie);
      continue;
    }
    if (IGNORED.has(ie))
      continue;
    let oe = MAPPED[ie];
    if (oe) {
      te.push(...oe);
      continue;
    }
    throw new Error(`Disallowed codepoint: 0x${ie.toString(16).toUpperCase()}`);
  }
  return ens_normalize_post_check(nfc(String.fromCodePoint(...te)));
}
function nfc(Y) {
  return Y.normalize("NFC");
}
function consume_emoji_reversed(Y, X) {
  var ee;
  let te = EMOJI_ROOT, ne, ie, oe = [], se = Y.length;
  for (X && (X.length = 0); se; ) {
    let ae = Y[--se];
    if (te = (ee = te.branches.find((ue) => ue.set.has(ae))) === null || ee === void 0 ? void 0 : ee.node, !te)
      break;
    if (te.save)
      ie = ae;
    else if (te.check && ae === ie)
      break;
    oe.push(ae), te.fe0f && (oe.push(65039), se > 0 && Y[se - 1] == 65039 && se--), te.valid && (ne = oe.slice(), te.valid == 2 && ne.splice(1, 1), X && X.push(...Y.slice(se).reverse()), Y.length = se);
  }
  return ne;
}
const logger$c = new Logger(version$a), Zeros = new Uint8Array(32);
Zeros.fill(0);
function checkComponent(Y) {
  if (Y.length === 0)
    throw new Error("invalid ENS name; empty component");
  return Y;
}
function ensNameSplit(Y) {
  const X = toUtf8Bytes(ens_normalize(Y)), ee = [];
  if (Y.length === 0)
    return ee;
  let te = 0;
  for (let ne = 0; ne < X.length; ne++)
    X[ne] === 46 && (ee.push(checkComponent(X.slice(te, ne))), te = ne + 1);
  if (te >= X.length)
    throw new Error("invalid ENS name; empty component");
  return ee.push(checkComponent(X.slice(te))), ee;
}
function namehash(Y) {
  typeof Y != "string" && logger$c.throwArgumentError("invalid ENS name; not a string", "name", Y);
  let X = Zeros;
  const ee = ensNameSplit(Y);
  for (; ee.length; )
    X = keccak256(concat([X, keccak256(ee.pop())]));
  return hexlify(X);
}
function dnsEncode(Y) {
  return hexlify(concat(ensNameSplit(Y).map((X) => {
    if (X.length > 63)
      throw new Error("invalid DNS encoded entry; length exceeds 63 bytes");
    const ee = new Uint8Array(X.length + 1);
    return ee.set(X, 1), ee[0] = ee.length - 1, ee;
  }))) + "00";
}
var __awaiter$7 = function(Y, X, ee, te) {
  function ne(ie) {
    return ie instanceof ee ? ie : new ee(function(oe) {
      oe(ie);
    });
  }
  return new (ee || (ee = Promise))(function(ie, oe) {
    function se(le) {
      try {
        ue(te.next(le));
      } catch (he) {
        oe(he);
      }
    }
    function ae(le) {
      try {
        ue(te.throw(le));
      } catch (he) {
        oe(he);
      }
    }
    function ue(le) {
      le.done ? ie(le.value) : ne(le.value).then(se, ae);
    }
    ue((te = te.apply(Y, X || [])).next());
  });
};
const logger$b = new Logger(version$a), padding = new Uint8Array(32);
padding.fill(0);
const NegativeOne = BigNumber.from(-1), Zero = BigNumber.from(0), One = BigNumber.from(1), MaxUint256 = BigNumber.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
function hexPadRight(Y) {
  const X = arrayify(Y), ee = X.length % 32;
  return ee ? hexConcat([X, padding.slice(ee)]) : hexlify(X);
}
const hexTrue = hexZeroPad(One.toHexString(), 32), hexFalse = hexZeroPad(Zero.toHexString(), 32), domainFieldTypes = {
  name: "string",
  version: "string",
  chainId: "uint256",
  verifyingContract: "address",
  salt: "bytes32"
}, domainFieldNames = [
  "name",
  "version",
  "chainId",
  "verifyingContract",
  "salt"
];
function checkString(Y) {
  return function(X) {
    return typeof X != "string" && logger$b.throwArgumentError(`invalid domain value for ${JSON.stringify(Y)}`, `domain.${Y}`, X), X;
  };
}
const domainChecks = {
  name: checkString("name"),
  version: checkString("version"),
  chainId: function(Y) {
    try {
      return BigNumber.from(Y).toString();
    } catch {
    }
    return logger$b.throwArgumentError('invalid domain value for "chainId"', "domain.chainId", Y);
  },
  verifyingContract: function(Y) {
    try {
      return getAddress(Y).toLowerCase();
    } catch {
    }
    return logger$b.throwArgumentError('invalid domain value "verifyingContract"', "domain.verifyingContract", Y);
  },
  salt: function(Y) {
    try {
      const X = arrayify(Y);
      if (X.length !== 32)
        throw new Error("bad length");
      return hexlify(X);
    } catch {
    }
    return logger$b.throwArgumentError('invalid domain value "salt"', "domain.salt", Y);
  }
};
function getBaseEncoder(Y) {
  {
    const X = Y.match(/^(u?)int(\d*)$/);
    if (X) {
      const ee = X[1] === "", te = parseInt(X[2] || "256");
      (te % 8 !== 0 || te > 256 || X[2] && X[2] !== String(te)) && logger$b.throwArgumentError("invalid numeric width", "type", Y);
      const ne = MaxUint256.mask(ee ? te - 1 : te), ie = ee ? ne.add(One).mul(NegativeOne) : Zero;
      return function(oe) {
        const se = BigNumber.from(oe);
        return (se.lt(ie) || se.gt(ne)) && logger$b.throwArgumentError(`value out-of-bounds for ${Y}`, "value", oe), hexZeroPad(se.toTwos(256).toHexString(), 32);
      };
    }
  }
  {
    const X = Y.match(/^bytes(\d+)$/);
    if (X) {
      const ee = parseInt(X[1]);
      return (ee === 0 || ee > 32 || X[1] !== String(ee)) && logger$b.throwArgumentError("invalid bytes width", "type", Y), function(te) {
        return arrayify(te).length !== ee && logger$b.throwArgumentError(`invalid length for ${Y}`, "value", te), hexPadRight(te);
      };
    }
  }
  switch (Y) {
    case "address":
      return function(X) {
        return hexZeroPad(getAddress(X), 32);
      };
    case "bool":
      return function(X) {
        return X ? hexTrue : hexFalse;
      };
    case "bytes":
      return function(X) {
        return keccak256(X);
      };
    case "string":
      return function(X) {
        return id(X);
      };
  }
  return null;
}
function encodeType(Y, X) {
  return `${Y}(${X.map(({ name: ee, type: te }) => te + " " + ee).join(",")})`;
}
class TypedDataEncoder {
  constructor(X) {
    defineReadOnly(this, "types", Object.freeze(deepCopy(X))), defineReadOnly(this, "_encoderCache", {}), defineReadOnly(this, "_types", {});
    const ee = {}, te = {}, ne = {};
    Object.keys(X).forEach((se) => {
      ee[se] = {}, te[se] = [], ne[se] = {};
    });
    for (const se in X) {
      const ae = {};
      X[se].forEach((ue) => {
        ae[ue.name] && logger$b.throwArgumentError(`duplicate variable name ${JSON.stringify(ue.name)} in ${JSON.stringify(se)}`, "types", X), ae[ue.name] = !0;
        const le = ue.type.match(/^([^\x5b]*)(\x5b|$)/)[1];
        le === se && logger$b.throwArgumentError(`circular type reference to ${JSON.stringify(le)}`, "types", X), !getBaseEncoder(le) && (te[le] || logger$b.throwArgumentError(`unknown type ${JSON.stringify(le)}`, "types", X), te[le].push(se), ee[se][le] = !0);
      });
    }
    const ie = Object.keys(te).filter((se) => te[se].length === 0);
    ie.length === 0 ? logger$b.throwArgumentError("missing primary type", "types", X) : ie.length > 1 && logger$b.throwArgumentError(`ambiguous primary types or unused types: ${ie.map((se) => JSON.stringify(se)).join(", ")}`, "types", X), defineReadOnly(this, "primaryType", ie[0]);
    function oe(se, ae) {
      ae[se] && logger$b.throwArgumentError(`circular type reference to ${JSON.stringify(se)}`, "types", X), ae[se] = !0, Object.keys(ee[se]).forEach((ue) => {
        te[ue] && (oe(ue, ae), Object.keys(ae).forEach((le) => {
          ne[le][ue] = !0;
        }));
      }), delete ae[se];
    }
    oe(this.primaryType, {});
    for (const se in ne) {
      const ae = Object.keys(ne[se]);
      ae.sort(), this._types[se] = encodeType(se, X[se]) + ae.map((ue) => encodeType(ue, X[ue])).join("");
    }
  }
  getEncoder(X) {
    let ee = this._encoderCache[X];
    return ee || (ee = this._encoderCache[X] = this._getEncoder(X)), ee;
  }
  _getEncoder(X) {
    {
      const ne = getBaseEncoder(X);
      if (ne)
        return ne;
    }
    const ee = X.match(/^(.*)(\x5b(\d*)\x5d)$/);
    if (ee) {
      const ne = ee[1], ie = this.getEncoder(ne), oe = parseInt(ee[3]);
      return (se) => {
        oe >= 0 && se.length !== oe && logger$b.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", se);
        let ae = se.map(ie);
        return this._types[ne] && (ae = ae.map(keccak256)), keccak256(hexConcat(ae));
      };
    }
    const te = this.types[X];
    if (te) {
      const ne = id(this._types[X]);
      return (ie) => {
        const oe = te.map(({ name: se, type: ae }) => {
          const ue = this.getEncoder(ae)(ie[se]);
          return this._types[ae] ? keccak256(ue) : ue;
        });
        return oe.unshift(ne), hexConcat(oe);
      };
    }
    return logger$b.throwArgumentError(`unknown type: ${X}`, "type", X);
  }
  encodeType(X) {
    const ee = this._types[X];
    return ee || logger$b.throwArgumentError(`unknown type: ${JSON.stringify(X)}`, "name", X), ee;
  }
  encodeData(X, ee) {
    return this.getEncoder(X)(ee);
  }
  hashStruct(X, ee) {
    return keccak256(this.encodeData(X, ee));
  }
  encode(X) {
    return this.encodeData(this.primaryType, X);
  }
  hash(X) {
    return this.hashStruct(this.primaryType, X);
  }
  _visit(X, ee, te) {
    if (getBaseEncoder(X))
      return te(X, ee);
    const ne = X.match(/^(.*)(\x5b(\d*)\x5d)$/);
    if (ne) {
      const oe = ne[1], se = parseInt(ne[3]);
      return se >= 0 && ee.length !== se && logger$b.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", ee), ee.map((ae) => this._visit(oe, ae, te));
    }
    const ie = this.types[X];
    return ie ? ie.reduce((oe, { name: se, type: ae }) => (oe[se] = this._visit(ae, ee[se], te), oe), {}) : logger$b.throwArgumentError(`unknown type: ${X}`, "type", X);
  }
  visit(X, ee) {
    return this._visit(this.primaryType, X, ee);
  }
  static from(X) {
    return new TypedDataEncoder(X);
  }
  static getPrimaryType(X) {
    return TypedDataEncoder.from(X).primaryType;
  }
  static hashStruct(X, ee, te) {
    return TypedDataEncoder.from(ee).hashStruct(X, te);
  }
  static hashDomain(X) {
    const ee = [];
    for (const te in X) {
      const ne = domainFieldTypes[te];
      ne || logger$b.throwArgumentError(`invalid typed-data domain key: ${JSON.stringify(te)}`, "domain", X), ee.push({ name: te, type: ne });
    }
    return ee.sort((te, ne) => domainFieldNames.indexOf(te.name) - domainFieldNames.indexOf(ne.name)), TypedDataEncoder.hashStruct("EIP712Domain", { EIP712Domain: ee }, X);
  }
  static encode(X, ee, te) {
    return hexConcat([
      "0x1901",
      TypedDataEncoder.hashDomain(X),
      TypedDataEncoder.from(ee).hash(te)
    ]);
  }
  static hash(X, ee, te) {
    return keccak256(TypedDataEncoder.encode(X, ee, te));
  }
  // Replaces all address types with ENS names with their looked up address
  static resolveNames(X, ee, te, ne) {
    return __awaiter$7(this, void 0, void 0, function* () {
      X = shallowCopy(X);
      const ie = {};
      X.verifyingContract && !isHexString(X.verifyingContract, 20) && (ie[X.verifyingContract] = "0x");
      const oe = TypedDataEncoder.from(ee);
      oe.visit(te, (se, ae) => (se === "address" && !isHexString(ae, 20) && (ie[ae] = "0x"), ae));
      for (const se in ie)
        ie[se] = yield ne(se);
      return X.verifyingContract && ie[X.verifyingContract] && (X.verifyingContract = ie[X.verifyingContract]), te = oe.visit(te, (se, ae) => se === "address" && ie[ae] ? ie[ae] : ae), { domain: X, value: te };
    });
  }
  static getPayload(X, ee, te) {
    TypedDataEncoder.hashDomain(X);
    const ne = {}, ie = [];
    domainFieldNames.forEach((ae) => {
      const ue = X[ae];
      ue != null && (ne[ae] = domainChecks[ae](ue), ie.push({ name: ae, type: domainFieldTypes[ae] }));
    });
    const oe = TypedDataEncoder.from(ee), se = shallowCopy(ee);
    return se.EIP712Domain ? logger$b.throwArgumentError("types must not contain EIP712Domain type", "types.EIP712Domain", ee) : se.EIP712Domain = ie, oe.encode(te), {
      types: se,
      domain: ne,
      primaryType: oe.primaryType,
      message: oe.visit(te, (ae, ue) => {
        if (ae.match(/^bytes(\d*)/))
          return hexlify(arrayify(ue));
        if (ae.match(/^u?int/))
          return BigNumber.from(ue).toString();
        switch (ae) {
          case "address":
            return ue.toLowerCase();
          case "bool":
            return !!ue;
          case "string":
            return typeof ue != "string" && logger$b.throwArgumentError("invalid string", "value", ue), ue;
        }
        return logger$b.throwArgumentError("unsupported type", "type", ae);
      })
    };
  }
}
const logger$a = new Logger(version$e);
class LogDescription extends Description {
}
class TransactionDescription extends Description {
}
class ErrorDescription extends Description {
}
class Indexed extends Description {
  static isIndexed(X) {
    return !!(X && X._isIndexed);
  }
}
const BuiltinErrors = {
  "0x08c379a0": { signature: "Error(string)", name: "Error", inputs: ["string"], reason: !0 },
  "0x4e487b71": { signature: "Panic(uint256)", name: "Panic", inputs: ["uint256"] }
};
function wrapAccessError(Y, X) {
  const ee = new Error(`deferred error during ABI decoding triggered accessing ${Y}`);
  return ee.error = X, ee;
}
class Interface {
  constructor(X) {
    let ee = [];
    typeof X == "string" ? ee = JSON.parse(X) : ee = X, defineReadOnly(this, "fragments", ee.map((te) => Fragment.from(te)).filter((te) => te != null)), defineReadOnly(this, "_abiCoder", getStatic(new.target, "getAbiCoder")()), defineReadOnly(this, "functions", {}), defineReadOnly(this, "errors", {}), defineReadOnly(this, "events", {}), defineReadOnly(this, "structs", {}), this.fragments.forEach((te) => {
      let ne = null;
      switch (te.type) {
        case "constructor":
          if (this.deploy) {
            logger$a.warn("duplicate definition - constructor");
            return;
          }
          defineReadOnly(this, "deploy", te);
          return;
        case "function":
          ne = this.functions;
          break;
        case "event":
          ne = this.events;
          break;
        case "error":
          ne = this.errors;
          break;
        default:
          return;
      }
      let ie = te.format();
      if (ne[ie]) {
        logger$a.warn("duplicate definition - " + ie);
        return;
      }
      ne[ie] = te;
    }), this.deploy || defineReadOnly(this, "deploy", ConstructorFragment.from({
      payable: !1,
      type: "constructor"
    })), defineReadOnly(this, "_isInterface", !0);
  }
  format(X) {
    X || (X = FormatTypes.full), X === FormatTypes.sighash && logger$a.throwArgumentError("interface does not support formatting sighash", "format", X);
    const ee = this.fragments.map((te) => te.format(X));
    return X === FormatTypes.json ? JSON.stringify(ee.map((te) => JSON.parse(te))) : ee;
  }
  // Sub-classes can override these to handle other blockchains
  static getAbiCoder() {
    return defaultAbiCoder;
  }
  static getAddress(X) {
    return getAddress(X);
  }
  static getSighash(X) {
    return hexDataSlice(id(X.format()), 0, 4);
  }
  static getEventTopic(X) {
    return id(X.format());
  }
  // Find a function definition by any means necessary (unless it is ambiguous)
  getFunction(X) {
    if (isHexString(X)) {
      for (const te in this.functions)
        if (X === this.getSighash(te))
          return this.functions[te];
      logger$a.throwArgumentError("no matching function", "sighash", X);
    }
    if (X.indexOf("(") === -1) {
      const te = X.trim(), ne = Object.keys(this.functions).filter((ie) => ie.split(
        "("
        /* fix:) */
      )[0] === te);
      return ne.length === 0 ? logger$a.throwArgumentError("no matching function", "name", te) : ne.length > 1 && logger$a.throwArgumentError("multiple matching functions", "name", te), this.functions[ne[0]];
    }
    const ee = this.functions[FunctionFragment.fromString(X).format()];
    return ee || logger$a.throwArgumentError("no matching function", "signature", X), ee;
  }
  // Find an event definition by any means necessary (unless it is ambiguous)
  getEvent(X) {
    if (isHexString(X)) {
      const te = X.toLowerCase();
      for (const ne in this.events)
        if (te === this.getEventTopic(ne))
          return this.events[ne];
      logger$a.throwArgumentError("no matching event", "topichash", te);
    }
    if (X.indexOf("(") === -1) {
      const te = X.trim(), ne = Object.keys(this.events).filter((ie) => ie.split(
        "("
        /* fix:) */
      )[0] === te);
      return ne.length === 0 ? logger$a.throwArgumentError("no matching event", "name", te) : ne.length > 1 && logger$a.throwArgumentError("multiple matching events", "name", te), this.events[ne[0]];
    }
    const ee = this.events[EventFragment.fromString(X).format()];
    return ee || logger$a.throwArgumentError("no matching event", "signature", X), ee;
  }
  // Find a function definition by any means necessary (unless it is ambiguous)
  getError(X) {
    if (isHexString(X)) {
      const te = getStatic(this.constructor, "getSighash");
      for (const ne in this.errors) {
        const ie = this.errors[ne];
        if (X === te(ie))
          return this.errors[ne];
      }
      logger$a.throwArgumentError("no matching error", "sighash", X);
    }
    if (X.indexOf("(") === -1) {
      const te = X.trim(), ne = Object.keys(this.errors).filter((ie) => ie.split(
        "("
        /* fix:) */
      )[0] === te);
      return ne.length === 0 ? logger$a.throwArgumentError("no matching error", "name", te) : ne.length > 1 && logger$a.throwArgumentError("multiple matching errors", "name", te), this.errors[ne[0]];
    }
    const ee = this.errors[FunctionFragment.fromString(X).format()];
    return ee || logger$a.throwArgumentError("no matching error", "signature", X), ee;
  }
  // Get the sighash (the bytes4 selector) used by Solidity to identify a function
  getSighash(X) {
    if (typeof X == "string")
      try {
        X = this.getFunction(X);
      } catch (ee) {
        try {
          X = this.getError(X);
        } catch {
          throw ee;
        }
      }
    return getStatic(this.constructor, "getSighash")(X);
  }
  // Get the topic (the bytes32 hash) used by Solidity to identify an event
  getEventTopic(X) {
    return typeof X == "string" && (X = this.getEvent(X)), getStatic(this.constructor, "getEventTopic")(X);
  }
  _decodeParams(X, ee) {
    return this._abiCoder.decode(X, ee);
  }
  _encodeParams(X, ee) {
    return this._abiCoder.encode(X, ee);
  }
  encodeDeploy(X) {
    return this._encodeParams(this.deploy.inputs, X || []);
  }
  decodeErrorResult(X, ee) {
    typeof X == "string" && (X = this.getError(X));
    const te = arrayify(ee);
    return hexlify(te.slice(0, 4)) !== this.getSighash(X) && logger$a.throwArgumentError(`data signature does not match error ${X.name}.`, "data", hexlify(te)), this._decodeParams(X.inputs, te.slice(4));
  }
  encodeErrorResult(X, ee) {
    return typeof X == "string" && (X = this.getError(X)), hexlify(concat([
      this.getSighash(X),
      this._encodeParams(X.inputs, ee || [])
    ]));
  }
  // Decode the data for a function call (e.g. tx.data)
  decodeFunctionData(X, ee) {
    typeof X == "string" && (X = this.getFunction(X));
    const te = arrayify(ee);
    return hexlify(te.slice(0, 4)) !== this.getSighash(X) && logger$a.throwArgumentError(`data signature does not match function ${X.name}.`, "data", hexlify(te)), this._decodeParams(X.inputs, te.slice(4));
  }
  // Encode the data for a function call (e.g. tx.data)
  encodeFunctionData(X, ee) {
    return typeof X == "string" && (X = this.getFunction(X)), hexlify(concat([
      this.getSighash(X),
      this._encodeParams(X.inputs, ee || [])
    ]));
  }
  // Decode the result from a function call (e.g. from eth_call)
  decodeFunctionResult(X, ee) {
    typeof X == "string" && (X = this.getFunction(X));
    let te = arrayify(ee), ne = null, ie = "", oe = null, se = null, ae = null;
    switch (te.length % this._abiCoder._getWordSize()) {
      case 0:
        try {
          return this._abiCoder.decode(X.outputs, te);
        } catch {
        }
        break;
      case 4: {
        const ue = hexlify(te.slice(0, 4)), le = BuiltinErrors[ue];
        if (le)
          oe = this._abiCoder.decode(le.inputs, te.slice(4)), se = le.name, ae = le.signature, le.reason && (ne = oe[0]), se === "Error" ? ie = `; VM Exception while processing transaction: reverted with reason string ${JSON.stringify(oe[0])}` : se === "Panic" && (ie = `; VM Exception while processing transaction: reverted with panic code ${oe[0]}`);
        else
          try {
            const he = this.getError(ue);
            oe = this._abiCoder.decode(he.inputs, te.slice(4)), se = he.name, ae = he.format();
          } catch {
          }
        break;
      }
    }
    return logger$a.throwError("call revert exception" + ie, Logger.errors.CALL_EXCEPTION, {
      method: X.format(),
      data: hexlify(ee),
      errorArgs: oe,
      errorName: se,
      errorSignature: ae,
      reason: ne
    });
  }
  // Encode the result for a function call (e.g. for eth_call)
  encodeFunctionResult(X, ee) {
    return typeof X == "string" && (X = this.getFunction(X)), hexlify(this._abiCoder.encode(X.outputs, ee || []));
  }
  // Create the filter for the event with search criteria (e.g. for eth_filterLog)
  encodeFilterTopics(X, ee) {
    typeof X == "string" && (X = this.getEvent(X)), ee.length > X.inputs.length && logger$a.throwError("too many arguments for " + X.format(), Logger.errors.UNEXPECTED_ARGUMENT, {
      argument: "values",
      value: ee
    });
    let te = [];
    X.anonymous || te.push(this.getEventTopic(X));
    const ne = (ie, oe) => ie.type === "string" ? id(oe) : ie.type === "bytes" ? keccak256(hexlify(oe)) : (ie.type === "bool" && typeof oe == "boolean" && (oe = oe ? "0x01" : "0x00"), ie.type.match(/^u?int/) && (oe = BigNumber.from(oe).toHexString()), ie.type === "address" && this._abiCoder.encode(["address"], [oe]), hexZeroPad(hexlify(oe), 32));
    for (ee.forEach((ie, oe) => {
      let se = X.inputs[oe];
      if (!se.indexed) {
        ie != null && logger$a.throwArgumentError("cannot filter non-indexed parameters; must be null", "contract." + se.name, ie);
        return;
      }
      ie == null ? te.push(null) : se.baseType === "array" || se.baseType === "tuple" ? logger$a.throwArgumentError("filtering with tuples or arrays not supported", "contract." + se.name, ie) : Array.isArray(ie) ? te.push(ie.map((ae) => ne(se, ae))) : te.push(ne(se, ie));
    }); te.length && te[te.length - 1] === null; )
      te.pop();
    return te;
  }
  encodeEventLog(X, ee) {
    typeof X == "string" && (X = this.getEvent(X));
    const te = [], ne = [], ie = [];
    return X.anonymous || te.push(this.getEventTopic(X)), ee.length !== X.inputs.length && logger$a.throwArgumentError("event arguments/values mismatch", "values", ee), X.inputs.forEach((oe, se) => {
      const ae = ee[se];
      if (oe.indexed)
        if (oe.type === "string")
          te.push(id(ae));
        else if (oe.type === "bytes")
          te.push(keccak256(ae));
        else {
          if (oe.baseType === "tuple" || oe.baseType === "array")
            throw new Error("not implemented");
          te.push(this._abiCoder.encode([oe.type], [ae]));
        }
      else
        ne.push(oe), ie.push(ae);
    }), {
      data: this._abiCoder.encode(ne, ie),
      topics: te
    };
  }
  // Decode a filter for the event and the search criteria
  decodeEventLog(X, ee, te) {
    if (typeof X == "string" && (X = this.getEvent(X)), te != null && !X.anonymous) {
      let me = this.getEventTopic(X);
      (!isHexString(te[0], 32) || te[0].toLowerCase() !== me) && logger$a.throwError("fragment/topic mismatch", Logger.errors.INVALID_ARGUMENT, { argument: "topics[0]", expected: me, value: te[0] }), te = te.slice(1);
    }
    let ne = [], ie = [], oe = [];
    X.inputs.forEach((me, ye) => {
      me.indexed ? me.type === "string" || me.type === "bytes" || me.baseType === "tuple" || me.baseType === "array" ? (ne.push(ParamType.fromObject({ type: "bytes32", name: me.name })), oe.push(!0)) : (ne.push(me), oe.push(!1)) : (ie.push(me), oe.push(!1));
    });
    let se = te != null ? this._abiCoder.decode(ne, concat(te)) : null, ae = this._abiCoder.decode(ie, ee, !0), ue = [], le = 0, he = 0;
    X.inputs.forEach((me, ye) => {
      if (me.indexed)
        if (se == null)
          ue[ye] = new Indexed({ _isIndexed: !0, hash: null });
        else if (oe[ye])
          ue[ye] = new Indexed({ _isIndexed: !0, hash: se[he++] });
        else
          try {
            ue[ye] = se[he++];
          } catch (we) {
            ue[ye] = we;
          }
      else
        try {
          ue[ye] = ae[le++];
        } catch (we) {
          ue[ye] = we;
        }
      if (me.name && ue[me.name] == null) {
        const we = ue[ye];
        we instanceof Error ? Object.defineProperty(ue, me.name, {
          enumerable: !0,
          get: () => {
            throw wrapAccessError(`property ${JSON.stringify(me.name)}`, we);
          }
        }) : ue[me.name] = we;
      }
    });
    for (let me = 0; me < ue.length; me++) {
      const ye = ue[me];
      ye instanceof Error && Object.defineProperty(ue, me, {
        enumerable: !0,
        get: () => {
          throw wrapAccessError(`index ${me}`, ye);
        }
      });
    }
    return Object.freeze(ue);
  }
  // Given a transaction, find the matching function fragment (if any) and
  // determine all its properties and call parameters
  parseTransaction(X) {
    let ee = this.getFunction(X.data.substring(0, 10).toLowerCase());
    return ee ? new TransactionDescription({
      args: this._abiCoder.decode(ee.inputs, "0x" + X.data.substring(10)),
      functionFragment: ee,
      name: ee.name,
      signature: ee.format(),
      sighash: this.getSighash(ee),
      value: BigNumber.from(X.value || "0")
    }) : null;
  }
  // @TODO
  //parseCallResult(data: BytesLike): ??
  // Given an event log, find the matching event fragment (if any) and
  // determine all its properties and values
  parseLog(X) {
    let ee = this.getEvent(X.topics[0]);
    return !ee || ee.anonymous ? null : new LogDescription({
      eventFragment: ee,
      name: ee.name,
      signature: ee.format(),
      topic: this.getEventTopic(ee),
      args: this.decodeEventLog(ee, X.data, X.topics)
    });
  }
  parseError(X) {
    const ee = hexlify(X);
    let te = this.getError(ee.substring(0, 10).toLowerCase());
    return te ? new ErrorDescription({
      args: this._abiCoder.decode(te.inputs, "0x" + ee.substring(10)),
      errorFragment: te,
      name: te.name,
      signature: te.format(),
      sighash: this.getSighash(te)
    }) : null;
  }
  /*
  static from(value: Array<Fragment | string | JsonAbi> | string | Interface) {
      if (Interface.isInterface(value)) {
          return value;
      }
      if (typeof(value) === "string") {
          return new Interface(JSON.parse(value));
      }
      return new Interface(value);
  }
  */
  static isInterface(X) {
    return !!(X && X._isInterface);
  }
}
const version$9 = "abstract-provider/5.7.0";
var __awaiter$6 = function(Y, X, ee, te) {
  function ne(ie) {
    return ie instanceof ee ? ie : new ee(function(oe) {
      oe(ie);
    });
  }
  return new (ee || (ee = Promise))(function(ie, oe) {
    function se(le) {
      try {
        ue(te.next(le));
      } catch (he) {
        oe(he);
      }
    }
    function ae(le) {
      try {
        ue(te.throw(le));
      } catch (he) {
        oe(he);
      }
    }
    function ue(le) {
      le.done ? ie(le.value) : ne(le.value).then(se, ae);
    }
    ue((te = te.apply(Y, X || [])).next());
  });
};
const logger$9 = new Logger(version$9);
class ForkEvent extends Description {
  static isForkEvent(X) {
    return !!(X && X._isForkEvent);
  }
}
class Provider {
  constructor() {
    logger$9.checkAbstract(new.target, Provider), defineReadOnly(this, "_isProvider", !0);
  }
  getFeeData() {
    return __awaiter$6(this, void 0, void 0, function* () {
      const { block: X, gasPrice: ee } = yield resolveProperties({
        block: this.getBlock("latest"),
        gasPrice: this.getGasPrice().catch((oe) => null)
      });
      let te = null, ne = null, ie = null;
      return X && X.baseFeePerGas && (te = X.baseFeePerGas, ie = BigNumber.from("1500000000"), ne = X.baseFeePerGas.mul(2).add(ie)), { lastBaseFeePerGas: te, maxFeePerGas: ne, maxPriorityFeePerGas: ie, gasPrice: ee };
    });
  }
  // Alias for "on"
  addListener(X, ee) {
    return this.on(X, ee);
  }
  // Alias for "off"
  removeListener(X, ee) {
    return this.off(X, ee);
  }
  static isProvider(X) {
    return !!(X && X._isProvider);
  }
}
const version$8 = "abstract-signer/5.7.0";
var __awaiter$5 = function(Y, X, ee, te) {
  function ne(ie) {
    return ie instanceof ee ? ie : new ee(function(oe) {
      oe(ie);
    });
  }
  return new (ee || (ee = Promise))(function(ie, oe) {
    function se(le) {
      try {
        ue(te.next(le));
      } catch (he) {
        oe(he);
      }
    }
    function ae(le) {
      try {
        ue(te.throw(le));
      } catch (he) {
        oe(he);
      }
    }
    function ue(le) {
      le.done ? ie(le.value) : ne(le.value).then(se, ae);
    }
    ue((te = te.apply(Y, X || [])).next());
  });
};
const logger$8 = new Logger(version$8), allowedTransactionKeys$1 = [
  "accessList",
  "ccipReadEnabled",
  "chainId",
  "customData",
  "data",
  "from",
  "gasLimit",
  "gasPrice",
  "maxFeePerGas",
  "maxPriorityFeePerGas",
  "nonce",
  "to",
  "type",
  "value"
], forwardErrors = [
  Logger.errors.INSUFFICIENT_FUNDS,
  Logger.errors.NONCE_EXPIRED,
  Logger.errors.REPLACEMENT_UNDERPRICED
];
class Signer {
  ///////////////////
  // Sub-classes MUST call super
  constructor() {
    logger$8.checkAbstract(new.target, Signer), defineReadOnly(this, "_isSigner", !0);
  }
  ///////////////////
  // Sub-classes MAY override these
  getBalance(X) {
    return __awaiter$5(this, void 0, void 0, function* () {
      return this._checkProvider("getBalance"), yield this.provider.getBalance(this.getAddress(), X);
    });
  }
  getTransactionCount(X) {
    return __awaiter$5(this, void 0, void 0, function* () {
      return this._checkProvider("getTransactionCount"), yield this.provider.getTransactionCount(this.getAddress(), X);
    });
  }
  // Populates "from" if unspecified, and estimates the gas for the transaction
  estimateGas(X) {
    return __awaiter$5(this, void 0, void 0, function* () {
      this._checkProvider("estimateGas");
      const ee = yield resolveProperties(this.checkTransaction(X));
      return yield this.provider.estimateGas(ee);
    });
  }
  // Populates "from" if unspecified, and calls with the transaction
  call(X, ee) {
    return __awaiter$5(this, void 0, void 0, function* () {
      this._checkProvider("call");
      const te = yield resolveProperties(this.checkTransaction(X));
      return yield this.provider.call(te, ee);
    });
  }
  // Populates all fields in a transaction, signs it and sends it to the network
  sendTransaction(X) {
    return __awaiter$5(this, void 0, void 0, function* () {
      this._checkProvider("sendTransaction");
      const ee = yield this.populateTransaction(X), te = yield this.signTransaction(ee);
      return yield this.provider.sendTransaction(te);
    });
  }
  getChainId() {
    return __awaiter$5(this, void 0, void 0, function* () {
      return this._checkProvider("getChainId"), (yield this.provider.getNetwork()).chainId;
    });
  }
  getGasPrice() {
    return __awaiter$5(this, void 0, void 0, function* () {
      return this._checkProvider("getGasPrice"), yield this.provider.getGasPrice();
    });
  }
  getFeeData() {
    return __awaiter$5(this, void 0, void 0, function* () {
      return this._checkProvider("getFeeData"), yield this.provider.getFeeData();
    });
  }
  resolveName(X) {
    return __awaiter$5(this, void 0, void 0, function* () {
      return this._checkProvider("resolveName"), yield this.provider.resolveName(X);
    });
  }
  // Checks a transaction does not contain invalid keys and if
  // no "from" is provided, populates it.
  // - does NOT require a provider
  // - adds "from" is not present
  // - returns a COPY (safe to mutate the result)
  // By default called from: (overriding these prevents it)
  //   - call
  //   - estimateGas
  //   - populateTransaction (and therefor sendTransaction)
  checkTransaction(X) {
    for (const te in X)
      allowedTransactionKeys$1.indexOf(te) === -1 && logger$8.throwArgumentError("invalid transaction key: " + te, "transaction", X);
    const ee = shallowCopy(X);
    return ee.from == null ? ee.from = this.getAddress() : ee.from = Promise.all([
      Promise.resolve(ee.from),
      this.getAddress()
    ]).then((te) => (te[0].toLowerCase() !== te[1].toLowerCase() && logger$8.throwArgumentError("from address mismatch", "transaction", X), te[0])), ee;
  }
  // Populates ALL keys for a transaction and checks that "from" matches
  // this Signer. Should be used by sendTransaction but NOT by signTransaction.
  // By default called from: (overriding these prevents it)
  //   - sendTransaction
  //
  // Notes:
  //  - We allow gasPrice for EIP-1559 as long as it matches maxFeePerGas
  populateTransaction(X) {
    return __awaiter$5(this, void 0, void 0, function* () {
      const ee = yield resolveProperties(this.checkTransaction(X));
      ee.to != null && (ee.to = Promise.resolve(ee.to).then((ne) => __awaiter$5(this, void 0, void 0, function* () {
        if (ne == null)
          return null;
        const ie = yield this.resolveName(ne);
        return ie == null && logger$8.throwArgumentError("provided ENS name resolves to null", "tx.to", ne), ie;
      })), ee.to.catch((ne) => {
      }));
      const te = ee.maxFeePerGas != null || ee.maxPriorityFeePerGas != null;
      if (ee.gasPrice != null && (ee.type === 2 || te) ? logger$8.throwArgumentError("eip-1559 transaction do not support gasPrice", "transaction", X) : (ee.type === 0 || ee.type === 1) && te && logger$8.throwArgumentError("pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "transaction", X), (ee.type === 2 || ee.type == null) && ee.maxFeePerGas != null && ee.maxPriorityFeePerGas != null)
        ee.type = 2;
      else if (ee.type === 0 || ee.type === 1)
        ee.gasPrice == null && (ee.gasPrice = this.getGasPrice());
      else {
        const ne = yield this.getFeeData();
        if (ee.type == null)
          if (ne.maxFeePerGas != null && ne.maxPriorityFeePerGas != null)
            if (ee.type = 2, ee.gasPrice != null) {
              const ie = ee.gasPrice;
              delete ee.gasPrice, ee.maxFeePerGas = ie, ee.maxPriorityFeePerGas = ie;
            } else
              ee.maxFeePerGas == null && (ee.maxFeePerGas = ne.maxFeePerGas), ee.maxPriorityFeePerGas == null && (ee.maxPriorityFeePerGas = ne.maxPriorityFeePerGas);
          else
            ne.gasPrice != null ? (te && logger$8.throwError("network does not support EIP-1559", Logger.errors.UNSUPPORTED_OPERATION, {
              operation: "populateTransaction"
            }), ee.gasPrice == null && (ee.gasPrice = ne.gasPrice), ee.type = 0) : logger$8.throwError("failed to get consistent fee data", Logger.errors.UNSUPPORTED_OPERATION, {
              operation: "signer.getFeeData"
            });
        else
          ee.type === 2 && (ee.maxFeePerGas == null && (ee.maxFeePerGas = ne.maxFeePerGas), ee.maxPriorityFeePerGas == null && (ee.maxPriorityFeePerGas = ne.maxPriorityFeePerGas));
      }
      return ee.nonce == null && (ee.nonce = this.getTransactionCount("pending")), ee.gasLimit == null && (ee.gasLimit = this.estimateGas(ee).catch((ne) => {
        if (forwardErrors.indexOf(ne.code) >= 0)
          throw ne;
        return logger$8.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {
          error: ne,
          tx: ee
        });
      })), ee.chainId == null ? ee.chainId = this.getChainId() : ee.chainId = Promise.all([
        Promise.resolve(ee.chainId),
        this.getChainId()
      ]).then((ne) => (ne[1] !== 0 && ne[0] !== ne[1] && logger$8.throwArgumentError("chainId address mismatch", "transaction", X), ne[0])), yield resolveProperties(ee);
    });
  }
  ///////////////////
  // Sub-classes SHOULD leave these alone
  _checkProvider(X) {
    this.provider || logger$8.throwError("missing provider", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: X || "_checkProvider"
    });
  }
  static isSigner(X) {
    return !!(X && X._isSigner);
  }
}
class VoidSigner extends Signer {
  constructor(X, ee) {
    super(), defineReadOnly(this, "address", X), defineReadOnly(this, "provider", ee || null);
  }
  getAddress() {
    return Promise.resolve(this.address);
  }
  _fail(X, ee) {
    return Promise.resolve().then(() => {
      logger$8.throwError(X, Logger.errors.UNSUPPORTED_OPERATION, { operation: ee });
    });
  }
  signMessage(X) {
    return this._fail("VoidSigner cannot sign messages", "signMessage");
  }
  signTransaction(X) {
    return this._fail("VoidSigner cannot sign transactions", "signTransaction");
  }
  _signTypedData(X, ee, te) {
    return this._fail("VoidSigner cannot sign typed data", "signTypedData");
  }
  connect(X) {
    return new VoidSigner(this.address, X);
  }
}
var hash$5 = {}, utils$g = {}, minimalisticAssert$2 = assert$b;
function assert$b(Y, X) {
  if (!Y)
    throw new Error(X || "Assertion failed");
}
assert$b.equal = function(Y, X, ee) {
  if (Y != X)
    throw new Error(ee || "Assertion failed: " + Y + " != " + X);
};
var inherits_browser$2 = { exports: {} };
typeof Object.create == "function" ? inherits_browser$2.exports = function(Y, X) {
  X && (Y.super_ = X, Y.prototype = Object.create(X.prototype, {
    constructor: {
      value: Y,
      enumerable: !1,
      writable: !0,
      configurable: !0
    }
  }));
} : inherits_browser$2.exports = function(Y, X) {
  if (X) {
    Y.super_ = X;
    var ee = function() {
    };
    ee.prototype = X.prototype, Y.prototype = new ee(), Y.prototype.constructor = Y;
  }
};
var inherits_browserExports$1 = inherits_browser$2.exports, assert$a = minimalisticAssert$2, inherits$e = inherits_browserExports$1;
utils$g.inherits = inherits$e;
function isSurrogatePair(Y, X) {
  return (Y.charCodeAt(X) & 64512) !== 55296 || X < 0 || X + 1 >= Y.length ? !1 : (Y.charCodeAt(X + 1) & 64512) === 56320;
}
function toArray(Y, X) {
  if (Array.isArray(Y))
    return Y.slice();
  if (!Y)
    return [];
  var ee = [];
  if (typeof Y == "string")
    if (X) {
      if (X === "hex")
        for (Y = Y.replace(/[^a-z0-9]+/ig, ""), Y.length % 2 !== 0 && (Y = "0" + Y), ne = 0; ne < Y.length; ne += 2)
          ee.push(parseInt(Y[ne] + Y[ne + 1], 16));
    } else
      for (var te = 0, ne = 0; ne < Y.length; ne++) {
        var ie = Y.charCodeAt(ne);
        ie < 128 ? ee[te++] = ie : ie < 2048 ? (ee[te++] = ie >> 6 | 192, ee[te++] = ie & 63 | 128) : isSurrogatePair(Y, ne) ? (ie = 65536 + ((ie & 1023) << 10) + (Y.charCodeAt(++ne) & 1023), ee[te++] = ie >> 18 | 240, ee[te++] = ie >> 12 & 63 | 128, ee[te++] = ie >> 6 & 63 | 128, ee[te++] = ie & 63 | 128) : (ee[te++] = ie >> 12 | 224, ee[te++] = ie >> 6 & 63 | 128, ee[te++] = ie & 63 | 128);
      }
  else
    for (ne = 0; ne < Y.length; ne++)
      ee[ne] = Y[ne] | 0;
  return ee;
}
utils$g.toArray = toArray;
function toHex(Y) {
  for (var X = "", ee = 0; ee < Y.length; ee++)
    X += zero2(Y[ee].toString(16));
  return X;
}
utils$g.toHex = toHex;
function htonl(Y) {
  var X = Y >>> 24 | Y >>> 8 & 65280 | Y << 8 & 16711680 | (Y & 255) << 24;
  return X >>> 0;
}
utils$g.htonl = htonl;
function toHex32(Y, X) {
  for (var ee = "", te = 0; te < Y.length; te++) {
    var ne = Y[te];
    X === "little" && (ne = htonl(ne)), ee += zero8(ne.toString(16));
  }
  return ee;
}
utils$g.toHex32 = toHex32;
function zero2(Y) {
  return Y.length === 1 ? "0" + Y : Y;
}
utils$g.zero2 = zero2;
function zero8(Y) {
  return Y.length === 7 ? "0" + Y : Y.length === 6 ? "00" + Y : Y.length === 5 ? "000" + Y : Y.length === 4 ? "0000" + Y : Y.length === 3 ? "00000" + Y : Y.length === 2 ? "000000" + Y : Y.length === 1 ? "0000000" + Y : Y;
}
utils$g.zero8 = zero8;
function join32(Y, X, ee, te) {
  var ne = ee - X;
  assert$a(ne % 4 === 0);
  for (var ie = new Array(ne / 4), oe = 0, se = X; oe < ie.length; oe++, se += 4) {
    var ae;
    te === "big" ? ae = Y[se] << 24 | Y[se + 1] << 16 | Y[se + 2] << 8 | Y[se + 3] : ae = Y[se + 3] << 24 | Y[se + 2] << 16 | Y[se + 1] << 8 | Y[se], ie[oe] = ae >>> 0;
  }
  return ie;
}
utils$g.join32 = join32;
function split32(Y, X) {
  for (var ee = new Array(Y.length * 4), te = 0, ne = 0; te < Y.length; te++, ne += 4) {
    var ie = Y[te];
    X === "big" ? (ee[ne] = ie >>> 24, ee[ne + 1] = ie >>> 16 & 255, ee[ne + 2] = ie >>> 8 & 255, ee[ne + 3] = ie & 255) : (ee[ne + 3] = ie >>> 24, ee[ne + 2] = ie >>> 16 & 255, ee[ne + 1] = ie >>> 8 & 255, ee[ne] = ie & 255);
  }
  return ee;
}
utils$g.split32 = split32;
function rotr32$1(Y, X) {
  return Y >>> X | Y << 32 - X;
}
utils$g.rotr32 = rotr32$1;
function rotl32$2(Y, X) {
  return Y << X | Y >>> 32 - X;
}
utils$g.rotl32 = rotl32$2;
function sum32$3(Y, X) {
  return Y + X >>> 0;
}
utils$g.sum32 = sum32$3;
function sum32_3$1(Y, X, ee) {
  return Y + X + ee >>> 0;
}
utils$g.sum32_3 = sum32_3$1;
function sum32_4$2(Y, X, ee, te) {
  return Y + X + ee + te >>> 0;
}
utils$g.sum32_4 = sum32_4$2;
function sum32_5$2(Y, X, ee, te, ne) {
  return Y + X + ee + te + ne >>> 0;
}
utils$g.sum32_5 = sum32_5$2;
function sum64$1(Y, X, ee, te) {
  var ne = Y[X], ie = Y[X + 1], oe = te + ie >>> 0, se = (oe < te ? 1 : 0) + ee + ne;
  Y[X] = se >>> 0, Y[X + 1] = oe;
}
utils$g.sum64 = sum64$1;
function sum64_hi$1(Y, X, ee, te) {
  var ne = X + te >>> 0, ie = (ne < X ? 1 : 0) + Y + ee;
  return ie >>> 0;
}
utils$g.sum64_hi = sum64_hi$1;
function sum64_lo$1(Y, X, ee, te) {
  var ne = X + te;
  return ne >>> 0;
}
utils$g.sum64_lo = sum64_lo$1;
function sum64_4_hi$1(Y, X, ee, te, ne, ie, oe, se) {
  var ae = 0, ue = X;
  ue = ue + te >>> 0, ae += ue < X ? 1 : 0, ue = ue + ie >>> 0, ae += ue < ie ? 1 : 0, ue = ue + se >>> 0, ae += ue < se ? 1 : 0;
  var le = Y + ee + ne + oe + ae;
  return le >>> 0;
}
utils$g.sum64_4_hi = sum64_4_hi$1;
function sum64_4_lo$1(Y, X, ee, te, ne, ie, oe, se) {
  var ae = X + te + ie + se;
  return ae >>> 0;
}
utils$g.sum64_4_lo = sum64_4_lo$1;
function sum64_5_hi$1(Y, X, ee, te, ne, ie, oe, se, ae, ue) {
  var le = 0, he = X;
  he = he + te >>> 0, le += he < X ? 1 : 0, he = he + ie >>> 0, le += he < ie ? 1 : 0, he = he + se >>> 0, le += he < se ? 1 : 0, he = he + ue >>> 0, le += he < ue ? 1 : 0;
  var me = Y + ee + ne + oe + ae + le;
  return me >>> 0;
}
utils$g.sum64_5_hi = sum64_5_hi$1;
function sum64_5_lo$1(Y, X, ee, te, ne, ie, oe, se, ae, ue) {
  var le = X + te + ie + se + ue;
  return le >>> 0;
}
utils$g.sum64_5_lo = sum64_5_lo$1;
function rotr64_hi$1(Y, X, ee) {
  var te = X << 32 - ee | Y >>> ee;
  return te >>> 0;
}
utils$g.rotr64_hi = rotr64_hi$1;
function rotr64_lo$1(Y, X, ee) {
  var te = Y << 32 - ee | X >>> ee;
  return te >>> 0;
}
utils$g.rotr64_lo = rotr64_lo$1;
function shr64_hi$1(Y, X, ee) {
  return Y >>> ee;
}
utils$g.shr64_hi = shr64_hi$1;
function shr64_lo$1(Y, X, ee) {
  var te = Y << 32 - ee | X >>> ee;
  return te >>> 0;
}
utils$g.shr64_lo = shr64_lo$1;
var common$7 = {}, utils$f = utils$g, assert$9 = minimalisticAssert$2;
function BlockHash$4() {
  this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;
}
common$7.BlockHash = BlockHash$4;
BlockHash$4.prototype.update = function(Y, X) {
  if (Y = utils$f.toArray(Y, X), this.pending ? this.pending = this.pending.concat(Y) : this.pending = Y, this.pendingTotal += Y.length, this.pending.length >= this._delta8) {
    Y = this.pending;
    var ee = Y.length % this._delta8;
    this.pending = Y.slice(Y.length - ee, Y.length), this.pending.length === 0 && (this.pending = null), Y = utils$f.join32(Y, 0, Y.length - ee, this.endian);
    for (var te = 0; te < Y.length; te += this._delta32)
      this._update(Y, te, te + this._delta32);
  }
  return this;
};
BlockHash$4.prototype.digest = function(Y) {
  return this.update(this._pad()), assert$9(this.pending === null), this._digest(Y);
};
BlockHash$4.prototype._pad = function() {
  var Y = this.pendingTotal, X = this._delta8, ee = X - (Y + this.padLength) % X, te = new Array(ee + this.padLength);
  te[0] = 128;
  for (var ne = 1; ne < ee; ne++)
    te[ne] = 0;
  if (Y <<= 3, this.endian === "big") {
    for (var ie = 8; ie < this.padLength; ie++)
      te[ne++] = 0;
    te[ne++] = 0, te[ne++] = 0, te[ne++] = 0, te[ne++] = 0, te[ne++] = Y >>> 24 & 255, te[ne++] = Y >>> 16 & 255, te[ne++] = Y >>> 8 & 255, te[ne++] = Y & 255;
  } else
    for (te[ne++] = Y & 255, te[ne++] = Y >>> 8 & 255, te[ne++] = Y >>> 16 & 255, te[ne++] = Y >>> 24 & 255, te[ne++] = 0, te[ne++] = 0, te[ne++] = 0, te[ne++] = 0, ie = 8; ie < this.padLength; ie++)
      te[ne++] = 0;
  return te;
};
var sha$3 = {}, common$6 = {}, utils$e = utils$g, rotr32 = utils$e.rotr32;
function ft_1$1(Y, X, ee, te) {
  if (Y === 0)
    return ch32$1(X, ee, te);
  if (Y === 1 || Y === 3)
    return p32(X, ee, te);
  if (Y === 2)
    return maj32$1(X, ee, te);
}
common$6.ft_1 = ft_1$1;
function ch32$1(Y, X, ee) {
  return Y & X ^ ~Y & ee;
}
common$6.ch32 = ch32$1;
function maj32$1(Y, X, ee) {
  return Y & X ^ Y & ee ^ X & ee;
}
common$6.maj32 = maj32$1;
function p32(Y, X, ee) {
  return Y ^ X ^ ee;
}
common$6.p32 = p32;
function s0_256$1(Y) {
  return rotr32(Y, 2) ^ rotr32(Y, 13) ^ rotr32(Y, 22);
}
common$6.s0_256 = s0_256$1;
function s1_256$1(Y) {
  return rotr32(Y, 6) ^ rotr32(Y, 11) ^ rotr32(Y, 25);
}
common$6.s1_256 = s1_256$1;
function g0_256$1(Y) {
  return rotr32(Y, 7) ^ rotr32(Y, 18) ^ Y >>> 3;
}
common$6.g0_256 = g0_256$1;
function g1_256$1(Y) {
  return rotr32(Y, 17) ^ rotr32(Y, 19) ^ Y >>> 10;
}
common$6.g1_256 = g1_256$1;
var utils$d = utils$g, common$5 = common$7, shaCommon$1 = common$6, rotl32$1 = utils$d.rotl32, sum32$2 = utils$d.sum32, sum32_5$1 = utils$d.sum32_5, ft_1 = shaCommon$1.ft_1, BlockHash$3 = common$5.BlockHash, sha1_K = [
  1518500249,
  1859775393,
  2400959708,
  3395469782
];
function SHA1() {
  if (!(this instanceof SHA1))
    return new SHA1();
  BlockHash$3.call(this), this.h = [
    1732584193,
    4023233417,
    2562383102,
    271733878,
    3285377520
  ], this.W = new Array(80);
}
utils$d.inherits(SHA1, BlockHash$3);
var _1$1 = SHA1;
SHA1.blockSize = 512;
SHA1.outSize = 160;
SHA1.hmacStrength = 80;
SHA1.padLength = 64;
SHA1.prototype._update = function(Y, X) {
  for (var ee = this.W, te = 0; te < 16; te++)
    ee[te] = Y[X + te];
  for (; te < ee.length; te++)
    ee[te] = rotl32$1(ee[te - 3] ^ ee[te - 8] ^ ee[te - 14] ^ ee[te - 16], 1);
  var ne = this.h[0], ie = this.h[1], oe = this.h[2], se = this.h[3], ae = this.h[4];
  for (te = 0; te < ee.length; te++) {
    var ue = ~~(te / 20), le = sum32_5$1(rotl32$1(ne, 5), ft_1(ue, ie, oe, se), ae, ee[te], sha1_K[ue]);
    ae = se, se = oe, oe = rotl32$1(ie, 30), ie = ne, ne = le;
  }
  this.h[0] = sum32$2(this.h[0], ne), this.h[1] = sum32$2(this.h[1], ie), this.h[2] = sum32$2(this.h[2], oe), this.h[3] = sum32$2(this.h[3], se), this.h[4] = sum32$2(this.h[4], ae);
};
SHA1.prototype._digest = function(Y) {
  return Y === "hex" ? utils$d.toHex32(this.h, "big") : utils$d.split32(this.h, "big");
};
var utils$c = utils$g, common$4 = common$7, shaCommon = common$6, assert$8 = minimalisticAssert$2, sum32$1 = utils$c.sum32, sum32_4$1 = utils$c.sum32_4, sum32_5 = utils$c.sum32_5, ch32 = shaCommon.ch32, maj32 = shaCommon.maj32, s0_256 = shaCommon.s0_256, s1_256 = shaCommon.s1_256, g0_256 = shaCommon.g0_256, g1_256 = shaCommon.g1_256, BlockHash$2 = common$4.BlockHash, sha256_K = [
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
];
function SHA256$3() {
  if (!(this instanceof SHA256$3))
    return new SHA256$3();
  BlockHash$2.call(this), this.h = [
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ], this.k = sha256_K, this.W = new Array(64);
}
utils$c.inherits(SHA256$3, BlockHash$2);
var _256$1 = SHA256$3;
SHA256$3.blockSize = 512;
SHA256$3.outSize = 256;
SHA256$3.hmacStrength = 192;
SHA256$3.padLength = 64;
SHA256$3.prototype._update = function(Y, X) {
  for (var ee = this.W, te = 0; te < 16; te++)
    ee[te] = Y[X + te];
  for (; te < ee.length; te++)
    ee[te] = sum32_4$1(g1_256(ee[te - 2]), ee[te - 7], g0_256(ee[te - 15]), ee[te - 16]);
  var ne = this.h[0], ie = this.h[1], oe = this.h[2], se = this.h[3], ae = this.h[4], ue = this.h[5], le = this.h[6], he = this.h[7];
  for (assert$8(this.k.length === ee.length), te = 0; te < ee.length; te++) {
    var me = sum32_5(he, s1_256(ae), ch32(ae, ue, le), this.k[te], ee[te]), ye = sum32$1(s0_256(ne), maj32(ne, ie, oe));
    he = le, le = ue, ue = ae, ae = sum32$1(se, me), se = oe, oe = ie, ie = ne, ne = sum32$1(me, ye);
  }
  this.h[0] = sum32$1(this.h[0], ne), this.h[1] = sum32$1(this.h[1], ie), this.h[2] = sum32$1(this.h[2], oe), this.h[3] = sum32$1(this.h[3], se), this.h[4] = sum32$1(this.h[4], ae), this.h[5] = sum32$1(this.h[5], ue), this.h[6] = sum32$1(this.h[6], le), this.h[7] = sum32$1(this.h[7], he);
};
SHA256$3.prototype._digest = function(Y) {
  return Y === "hex" ? utils$c.toHex32(this.h, "big") : utils$c.split32(this.h, "big");
};
var utils$b = utils$g, SHA256$2 = _256$1;
function SHA224$1() {
  if (!(this instanceof SHA224$1))
    return new SHA224$1();
  SHA256$2.call(this), this.h = [
    3238371032,
    914150663,
    812702999,
    4144912697,
    4290775857,
    1750603025,
    1694076839,
    3204075428
  ];
}
utils$b.inherits(SHA224$1, SHA256$2);
var _224$1 = SHA224$1;
SHA224$1.blockSize = 512;
SHA224$1.outSize = 224;
SHA224$1.hmacStrength = 192;
SHA224$1.padLength = 64;
SHA224$1.prototype._digest = function(Y) {
  return Y === "hex" ? utils$b.toHex32(this.h.slice(0, 7), "big") : utils$b.split32(this.h.slice(0, 7), "big");
};
var utils$a = utils$g, common$3 = common$7, assert$7 = minimalisticAssert$2, rotr64_hi = utils$a.rotr64_hi, rotr64_lo = utils$a.rotr64_lo, shr64_hi = utils$a.shr64_hi, shr64_lo = utils$a.shr64_lo, sum64 = utils$a.sum64, sum64_hi = utils$a.sum64_hi, sum64_lo = utils$a.sum64_lo, sum64_4_hi = utils$a.sum64_4_hi, sum64_4_lo = utils$a.sum64_4_lo, sum64_5_hi = utils$a.sum64_5_hi, sum64_5_lo = utils$a.sum64_5_lo, BlockHash$1 = common$3.BlockHash, sha512_K = [
  1116352408,
  3609767458,
  1899447441,
  602891725,
  3049323471,
  3964484399,
  3921009573,
  2173295548,
  961987163,
  4081628472,
  1508970993,
  3053834265,
  2453635748,
  2937671579,
  2870763221,
  3664609560,
  3624381080,
  2734883394,
  310598401,
  1164996542,
  607225278,
  1323610764,
  1426881987,
  3590304994,
  1925078388,
  4068182383,
  2162078206,
  991336113,
  2614888103,
  633803317,
  3248222580,
  3479774868,
  3835390401,
  2666613458,
  4022224774,
  944711139,
  264347078,
  2341262773,
  604807628,
  2007800933,
  770255983,
  1495990901,
  1249150122,
  1856431235,
  1555081692,
  3175218132,
  1996064986,
  2198950837,
  2554220882,
  3999719339,
  2821834349,
  766784016,
  2952996808,
  2566594879,
  3210313671,
  3203337956,
  3336571891,
  1034457026,
  3584528711,
  2466948901,
  113926993,
  3758326383,
  338241895,
  168717936,
  666307205,
  1188179964,
  773529912,
  1546045734,
  1294757372,
  1522805485,
  1396182291,
  2643833823,
  1695183700,
  2343527390,
  1986661051,
  1014477480,
  2177026350,
  1206759142,
  2456956037,
  344077627,
  2730485921,
  1290863460,
  2820302411,
  3158454273,
  3259730800,
  3505952657,
  3345764771,
  106217008,
  3516065817,
  3606008344,
  3600352804,
  1432725776,
  4094571909,
  1467031594,
  275423344,
  851169720,
  430227734,
  3100823752,
  506948616,
  1363258195,
  659060556,
  3750685593,
  883997877,
  3785050280,
  958139571,
  3318307427,
  1322822218,
  3812723403,
  1537002063,
  2003034995,
  1747873779,
  3602036899,
  1955562222,
  1575990012,
  2024104815,
  1125592928,
  2227730452,
  2716904306,
  2361852424,
  442776044,
  2428436474,
  593698344,
  2756734187,
  3733110249,
  3204031479,
  2999351573,
  3329325298,
  3815920427,
  3391569614,
  3928383900,
  3515267271,
  566280711,
  3940187606,
  3454069534,
  4118630271,
  4000239992,
  116418474,
  1914138554,
  174292421,
  2731055270,
  289380356,
  3203993006,
  460393269,
  320620315,
  685471733,
  587496836,
  852142971,
  1086792851,
  1017036298,
  365543100,
  1126000580,
  2618297676,
  1288033470,
  3409855158,
  1501505948,
  4234509866,
  1607167915,
  987167468,
  1816402316,
  1246189591
];
function SHA512$4() {
  if (!(this instanceof SHA512$4))
    return new SHA512$4();
  BlockHash$1.call(this), this.h = [
    1779033703,
    4089235720,
    3144134277,
    2227873595,
    1013904242,
    4271175723,
    2773480762,
    1595750129,
    1359893119,
    2917565137,
    2600822924,
    725511199,
    528734635,
    4215389547,
    1541459225,
    327033209
  ], this.k = sha512_K, this.W = new Array(160);
}
utils$a.inherits(SHA512$4, BlockHash$1);
var _512$1 = SHA512$4;
SHA512$4.blockSize = 1024;
SHA512$4.outSize = 512;
SHA512$4.hmacStrength = 192;
SHA512$4.padLength = 128;
SHA512$4.prototype._prepareBlock = function(Y, X) {
  for (var ee = this.W, te = 0; te < 32; te++)
    ee[te] = Y[X + te];
  for (; te < ee.length; te += 2) {
    var ne = g1_512_hi(ee[te - 4], ee[te - 3]), ie = g1_512_lo(ee[te - 4], ee[te - 3]), oe = ee[te - 14], se = ee[te - 13], ae = g0_512_hi(ee[te - 30], ee[te - 29]), ue = g0_512_lo(ee[te - 30], ee[te - 29]), le = ee[te - 32], he = ee[te - 31];
    ee[te] = sum64_4_hi(
      ne,
      ie,
      oe,
      se,
      ae,
      ue,
      le,
      he
    ), ee[te + 1] = sum64_4_lo(
      ne,
      ie,
      oe,
      se,
      ae,
      ue,
      le,
      he
    );
  }
};
SHA512$4.prototype._update = function(Y, X) {
  this._prepareBlock(Y, X);
  var ee = this.W, te = this.h[0], ne = this.h[1], ie = this.h[2], oe = this.h[3], se = this.h[4], ae = this.h[5], ue = this.h[6], le = this.h[7], he = this.h[8], me = this.h[9], ye = this.h[10], we = this.h[11], Ee = this.h[12], Re = this.h[13], Ue = this.h[14], Me = this.h[15];
  assert$7(this.k.length === ee.length);
  for (var De = 0; De < ee.length; De += 2) {
    var Fe = Ue, Ke = Me, tt = s1_512_hi(he, me), rt = s1_512_lo(he, me), it = ch64_hi(he, me, ye, we, Ee), _t = ch64_lo(he, me, ye, we, Ee, Re), Dt = this.k[De], je = this.k[De + 1], ze = ee[De], fe = ee[De + 1], de = sum64_5_hi(
      Fe,
      Ke,
      tt,
      rt,
      it,
      _t,
      Dt,
      je,
      ze,
      fe
    ), be = sum64_5_lo(
      Fe,
      Ke,
      tt,
      rt,
      it,
      _t,
      Dt,
      je,
      ze,
      fe
    );
    Fe = s0_512_hi(te, ne), Ke = s0_512_lo(te, ne), tt = maj64_hi(te, ne, ie, oe, se), rt = maj64_lo(te, ne, ie, oe, se, ae);
    var Te = sum64_hi(Fe, Ke, tt, rt), Ce = sum64_lo(Fe, Ke, tt, rt);
    Ue = Ee, Me = Re, Ee = ye, Re = we, ye = he, we = me, he = sum64_hi(ue, le, de, be), me = sum64_lo(le, le, de, be), ue = se, le = ae, se = ie, ae = oe, ie = te, oe = ne, te = sum64_hi(de, be, Te, Ce), ne = sum64_lo(de, be, Te, Ce);
  }
  sum64(this.h, 0, te, ne), sum64(this.h, 2, ie, oe), sum64(this.h, 4, se, ae), sum64(this.h, 6, ue, le), sum64(this.h, 8, he, me), sum64(this.h, 10, ye, we), sum64(this.h, 12, Ee, Re), sum64(this.h, 14, Ue, Me);
};
SHA512$4.prototype._digest = function(Y) {
  return Y === "hex" ? utils$a.toHex32(this.h, "big") : utils$a.split32(this.h, "big");
};
function ch64_hi(Y, X, ee, te, ne) {
  var ie = Y & ee ^ ~Y & ne;
  return ie < 0 && (ie += 4294967296), ie;
}
function ch64_lo(Y, X, ee, te, ne, ie) {
  var oe = X & te ^ ~X & ie;
  return oe < 0 && (oe += 4294967296), oe;
}
function maj64_hi(Y, X, ee, te, ne) {
  var ie = Y & ee ^ Y & ne ^ ee & ne;
  return ie < 0 && (ie += 4294967296), ie;
}
function maj64_lo(Y, X, ee, te, ne, ie) {
  var oe = X & te ^ X & ie ^ te & ie;
  return oe < 0 && (oe += 4294967296), oe;
}
function s0_512_hi(Y, X) {
  var ee = rotr64_hi(Y, X, 28), te = rotr64_hi(X, Y, 2), ne = rotr64_hi(X, Y, 7), ie = ee ^ te ^ ne;
  return ie < 0 && (ie += 4294967296), ie;
}
function s0_512_lo(Y, X) {
  var ee = rotr64_lo(Y, X, 28), te = rotr64_lo(X, Y, 2), ne = rotr64_lo(X, Y, 7), ie = ee ^ te ^ ne;
  return ie < 0 && (ie += 4294967296), ie;
}
function s1_512_hi(Y, X) {
  var ee = rotr64_hi(Y, X, 14), te = rotr64_hi(Y, X, 18), ne = rotr64_hi(X, Y, 9), ie = ee ^ te ^ ne;
  return ie < 0 && (ie += 4294967296), ie;
}
function s1_512_lo(Y, X) {
  var ee = rotr64_lo(Y, X, 14), te = rotr64_lo(Y, X, 18), ne = rotr64_lo(X, Y, 9), ie = ee ^ te ^ ne;
  return ie < 0 && (ie += 4294967296), ie;
}
function g0_512_hi(Y, X) {
  var ee = rotr64_hi(Y, X, 1), te = rotr64_hi(Y, X, 8), ne = shr64_hi(Y, X, 7), ie = ee ^ te ^ ne;
  return ie < 0 && (ie += 4294967296), ie;
}
function g0_512_lo(Y, X) {
  var ee = rotr64_lo(Y, X, 1), te = rotr64_lo(Y, X, 8), ne = shr64_lo(Y, X, 7), ie = ee ^ te ^ ne;
  return ie < 0 && (ie += 4294967296), ie;
}
function g1_512_hi(Y, X) {
  var ee = rotr64_hi(Y, X, 19), te = rotr64_hi(X, Y, 29), ne = shr64_hi(Y, X, 6), ie = ee ^ te ^ ne;
  return ie < 0 && (ie += 4294967296), ie;
}
function g1_512_lo(Y, X) {
  var ee = rotr64_lo(Y, X, 19), te = rotr64_lo(X, Y, 29), ne = shr64_lo(Y, X, 6), ie = ee ^ te ^ ne;
  return ie < 0 && (ie += 4294967296), ie;
}
var utils$9 = utils$g, SHA512$3 = _512$1;
function SHA384$1() {
  if (!(this instanceof SHA384$1))
    return new SHA384$1();
  SHA512$3.call(this), this.h = [
    3418070365,
    3238371032,
    1654270250,
    914150663,
    2438529370,
    812702999,
    355462360,
    4144912697,
    1731405415,
    4290775857,
    2394180231,
    1750603025,
    3675008525,
    1694076839,
    1203062813,
    3204075428
  ];
}
utils$9.inherits(SHA384$1, SHA512$3);
var _384$1 = SHA384$1;
SHA384$1.blockSize = 1024;
SHA384$1.outSize = 384;
SHA384$1.hmacStrength = 192;
SHA384$1.padLength = 128;
SHA384$1.prototype._digest = function(Y) {
  return Y === "hex" ? utils$9.toHex32(this.h.slice(0, 12), "big") : utils$9.split32(this.h.slice(0, 12), "big");
};
sha$3.sha1 = _1$1;
sha$3.sha224 = _224$1;
sha$3.sha256 = _256$1;
sha$3.sha384 = _384$1;
sha$3.sha512 = _512$1;
var ripemd$1 = {}, utils$8 = utils$g, common$2 = common$7, rotl32 = utils$8.rotl32, sum32 = utils$8.sum32, sum32_3 = utils$8.sum32_3, sum32_4 = utils$8.sum32_4, BlockHash = common$2.BlockHash;
function RIPEMD160$2() {
  if (!(this instanceof RIPEMD160$2))
    return new RIPEMD160$2();
  BlockHash.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little";
}
utils$8.inherits(RIPEMD160$2, BlockHash);
ripemd$1.ripemd160 = RIPEMD160$2;
RIPEMD160$2.blockSize = 512;
RIPEMD160$2.outSize = 160;
RIPEMD160$2.hmacStrength = 192;
RIPEMD160$2.padLength = 64;
RIPEMD160$2.prototype._update = function(Y, X) {
  for (var ee = this.h[0], te = this.h[1], ne = this.h[2], ie = this.h[3], oe = this.h[4], se = ee, ae = te, ue = ne, le = ie, he = oe, me = 0; me < 80; me++) {
    var ye = sum32(
      rotl32(
        sum32_4(ee, f$1(me, te, ne, ie), Y[r[me] + X], K$4(me)),
        s[me]
      ),
      oe
    );
    ee = oe, oe = ie, ie = rotl32(ne, 10), ne = te, te = ye, ye = sum32(
      rotl32(
        sum32_4(se, f$1(79 - me, ae, ue, le), Y[rh[me] + X], Kh(me)),
        sh[me]
      ),
      he
    ), se = he, he = le, le = rotl32(ue, 10), ue = ae, ae = ye;
  }
  ye = sum32_3(this.h[1], ne, le), this.h[1] = sum32_3(this.h[2], ie, he), this.h[2] = sum32_3(this.h[3], oe, se), this.h[3] = sum32_3(this.h[4], ee, ae), this.h[4] = sum32_3(this.h[0], te, ue), this.h[0] = ye;
};
RIPEMD160$2.prototype._digest = function(Y) {
  return Y === "hex" ? utils$8.toHex32(this.h, "little") : utils$8.split32(this.h, "little");
};
function f$1(Y, X, ee, te) {
  return Y <= 15 ? X ^ ee ^ te : Y <= 31 ? X & ee | ~X & te : Y <= 47 ? (X | ~ee) ^ te : Y <= 63 ? X & te | ee & ~te : X ^ (ee | ~te);
}
function K$4(Y) {
  return Y <= 15 ? 0 : Y <= 31 ? 1518500249 : Y <= 47 ? 1859775393 : Y <= 63 ? 2400959708 : 2840853838;
}
function Kh(Y) {
  return Y <= 15 ? 1352829926 : Y <= 31 ? 1548603684 : Y <= 47 ? 1836072691 : Y <= 63 ? 2053994217 : 0;
}
var r = [
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  7,
  4,
  13,
  1,
  10,
  6,
  15,
  3,
  12,
  0,
  9,
  5,
  2,
  14,
  11,
  8,
  3,
  10,
  14,
  4,
  9,
  15,
  8,
  1,
  2,
  7,
  0,
  6,
  13,
  11,
  5,
  12,
  1,
  9,
  11,
  10,
  0,
  8,
  12,
  4,
  13,
  3,
  7,
  15,
  14,
  5,
  6,
  2,
  4,
  0,
  5,
  9,
  7,
  12,
  2,
  10,
  14,
  1,
  3,
  8,
  11,
  6,
  15,
  13
], rh = [
  5,
  14,
  7,
  0,
  9,
  2,
  11,
  4,
  13,
  6,
  15,
  8,
  1,
  10,
  3,
  12,
  6,
  11,
  3,
  7,
  0,
  13,
  5,
  10,
  14,
  15,
  8,
  12,
  4,
  9,
  1,
  2,
  15,
  5,
  1,
  3,
  7,
  14,
  6,
  9,
  11,
  8,
  12,
  2,
  10,
  0,
  4,
  13,
  8,
  6,
  4,
  1,
  3,
  11,
  15,
  0,
  5,
  12,
  2,
  13,
  9,
  7,
  10,
  14,
  12,
  15,
  10,
  4,
  1,
  5,
  8,
  7,
  6,
  2,
  13,
  14,
  0,
  3,
  9,
  11
], s = [
  11,
  14,
  15,
  12,
  5,
  8,
  7,
  9,
  11,
  13,
  14,
  15,
  6,
  7,
  9,
  8,
  7,
  6,
  8,
  13,
  11,
  9,
  7,
  15,
  7,
  12,
  15,
  9,
  11,
  7,
  13,
  12,
  11,
  13,
  6,
  7,
  14,
  9,
  13,
  15,
  14,
  8,
  13,
  6,
  5,
  12,
  7,
  5,
  11,
  12,
  14,
  15,
  14,
  15,
  9,
  8,
  9,
  14,
  5,
  6,
  8,
  6,
  5,
  12,
  9,
  15,
  5,
  11,
  6,
  8,
  13,
  12,
  5,
  12,
  13,
  14,
  11,
  8,
  5,
  6
], sh = [
  8,
  9,
  9,
  11,
  13,
  15,
  15,
  5,
  7,
  7,
  8,
  11,
  14,
  14,
  12,
  6,
  9,
  13,
  15,
  7,
  12,
  8,
  9,
  11,
  7,
  7,
  12,
  7,
  6,
  15,
  13,
  11,
  9,
  7,
  15,
  11,
  8,
  6,
  6,
  14,
  12,
  13,
  5,
  14,
  13,
  13,
  7,
  5,
  15,
  5,
  8,
  11,
  14,
  14,
  6,
  14,
  6,
  9,
  12,
  9,
  12,
  5,
  15,
  8,
  8,
  5,
  12,
  9,
  12,
  5,
  14,
  6,
  8,
  13,
  6,
  5,
  15,
  13,
  11,
  11
], utils$7 = utils$g, assert$6 = minimalisticAssert$2;
function Hmac$2(Y, X, ee) {
  if (!(this instanceof Hmac$2))
    return new Hmac$2(Y, X, ee);
  this.Hash = Y, this.blockSize = Y.blockSize / 8, this.outSize = Y.outSize / 8, this.inner = null, this.outer = null, this._init(utils$7.toArray(X, ee));
}
var hmac$3 = Hmac$2;
Hmac$2.prototype._init = function(Y) {
  Y.length > this.blockSize && (Y = new this.Hash().update(Y).digest()), assert$6(Y.length <= this.blockSize);
  for (var X = Y.length; X < this.blockSize; X++)
    Y.push(0);
  for (X = 0; X < Y.length; X++)
    Y[X] ^= 54;
  for (this.inner = new this.Hash().update(Y), X = 0; X < Y.length; X++)
    Y[X] ^= 106;
  this.outer = new this.Hash().update(Y);
};
Hmac$2.prototype.update = function(Y, X) {
  return this.inner.update(Y, X), this;
};
Hmac$2.prototype.digest = function(Y) {
  return this.outer.update(this.inner.digest()), this.outer.digest(Y);
};
(function(Y) {
  var X = Y;
  X.utils = utils$g, X.common = common$7, X.sha = sha$3, X.ripemd = ripemd$1, X.hmac = hmac$3, X.sha1 = X.sha.sha1, X.sha256 = X.sha.sha256, X.sha224 = X.sha.sha224, X.sha384 = X.sha.sha384, X.sha512 = X.sha.sha512, X.ripemd160 = X.ripemd.ripemd160;
})(hash$5);
const hash$4 = /* @__PURE__ */ getDefaultExportFromCjs$3(hash$5);
function createCommonjsModule(Y, X, ee) {
  return ee = {
    path: X,
    exports: {},
    require: function(te, ne) {
      return commonjsRequire$1(te, ne ?? ee.path);
    }
  }, Y(ee, ee.exports), ee.exports;
}
function commonjsRequire$1() {
  throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
}
var minimalisticAssert$1 = assert$3;
function assert$3(Y, X) {
  if (!Y)
    throw new Error(X || "Assertion failed");
}
assert$3.equal = function(Y, X, ee) {
  if (Y != X)
    throw new Error(ee || "Assertion failed: " + Y + " != " + X);
};
var utils_1$1 = createCommonjsModule(function(Y, X) {
  var ee = X;
  function te(oe, se) {
    if (Array.isArray(oe))
      return oe.slice();
    if (!oe)
      return [];
    var ae = [];
    if (typeof oe != "string") {
      for (var ue = 0; ue < oe.length; ue++)
        ae[ue] = oe[ue] | 0;
      return ae;
    }
    if (se === "hex") {
      oe = oe.replace(/[^a-z0-9]+/ig, ""), oe.length % 2 !== 0 && (oe = "0" + oe);
      for (var ue = 0; ue < oe.length; ue += 2)
        ae.push(parseInt(oe[ue] + oe[ue + 1], 16));
    } else
      for (var ue = 0; ue < oe.length; ue++) {
        var le = oe.charCodeAt(ue), he = le >> 8, me = le & 255;
        he ? ae.push(he, me) : ae.push(me);
      }
    return ae;
  }
  ee.toArray = te;
  function ne(oe) {
    return oe.length === 1 ? "0" + oe : oe;
  }
  ee.zero2 = ne;
  function ie(oe) {
    for (var se = "", ae = 0; ae < oe.length; ae++)
      se += ne(oe[ae].toString(16));
    return se;
  }
  ee.toHex = ie, ee.encode = function(oe, se) {
    return se === "hex" ? ie(oe) : oe;
  };
}), utils_1$1$1 = createCommonjsModule(function(Y, X) {
  var ee = X;
  ee.assert = minimalisticAssert$1, ee.toArray = utils_1$1.toArray, ee.zero2 = utils_1$1.zero2, ee.toHex = utils_1$1.toHex, ee.encode = utils_1$1.encode;
  function te(ae, ue, le) {
    var he = new Array(Math.max(ae.bitLength(), le) + 1);
    he.fill(0);
    for (var me = 1 << ue + 1, ye = ae.clone(), we = 0; we < he.length; we++) {
      var Ee, Re = ye.andln(me - 1);
      ye.isOdd() ? (Re > (me >> 1) - 1 ? Ee = (me >> 1) - Re : Ee = Re, ye.isubn(Ee)) : Ee = 0, he[we] = Ee, ye.iushrn(1);
    }
    return he;
  }
  ee.getNAF = te;
  function ne(ae, ue) {
    var le = [
      [],
      []
    ];
    ae = ae.clone(), ue = ue.clone();
    for (var he = 0, me = 0, ye; ae.cmpn(-he) > 0 || ue.cmpn(-me) > 0; ) {
      var we = ae.andln(3) + he & 3, Ee = ue.andln(3) + me & 3;
      we === 3 && (we = -1), Ee === 3 && (Ee = -1);
      var Re;
      we & 1 ? (ye = ae.andln(7) + he & 7, (ye === 3 || ye === 5) && Ee === 2 ? Re = -we : Re = we) : Re = 0, le[0].push(Re);
      var Ue;
      Ee & 1 ? (ye = ue.andln(7) + me & 7, (ye === 3 || ye === 5) && we === 2 ? Ue = -Ee : Ue = Ee) : Ue = 0, le[1].push(Ue), 2 * he === Re + 1 && (he = 1 - he), 2 * me === Ue + 1 && (me = 1 - me), ae.iushrn(1), ue.iushrn(1);
    }
    return le;
  }
  ee.getJSF = ne;
  function ie(ae, ue, le) {
    var he = "_" + ue;
    ae.prototype[ue] = function() {
      return this[he] !== void 0 ? this[he] : this[he] = le.call(this);
    };
  }
  ee.cachedProperty = ie;
  function oe(ae) {
    return typeof ae == "string" ? ee.toArray(ae, "hex") : ae;
  }
  ee.parseBytes = oe;
  function se(ae) {
    return new BN$2(ae, "hex", "le");
  }
  ee.intFromLE = se;
}), getNAF = utils_1$1$1.getNAF, getJSF = utils_1$1$1.getJSF, assert$1$1 = utils_1$1$1.assert;
function BaseCurve(Y, X) {
  this.type = Y, this.p = new BN$2(X.p, 16), this.red = X.prime ? BN$2.red(X.prime) : BN$2.mont(this.p), this.zero = new BN$2(0).toRed(this.red), this.one = new BN$2(1).toRed(this.red), this.two = new BN$2(2).toRed(this.red), this.n = X.n && new BN$2(X.n, 16), this.g = X.g && this.pointFromJSON(X.g, X.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
  var ee = this.n && this.p.div(this.n);
  !ee || ee.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = !0, this.redN = this.n.toRed(this.red));
}
var base$4 = BaseCurve;
BaseCurve.prototype.point = function() {
  throw new Error("Not implemented");
};
BaseCurve.prototype.validate = function() {
  throw new Error("Not implemented");
};
BaseCurve.prototype._fixedNafMul = function(Y, X) {
  assert$1$1(Y.precomputed);
  var ee = Y._getDoubles(), te = getNAF(X, 1, this._bitLength), ne = (1 << ee.step + 1) - (ee.step % 2 === 0 ? 2 : 1);
  ne /= 3;
  var ie = [], oe, se;
  for (oe = 0; oe < te.length; oe += ee.step) {
    se = 0;
    for (var ae = oe + ee.step - 1; ae >= oe; ae--)
      se = (se << 1) + te[ae];
    ie.push(se);
  }
  for (var ue = this.jpoint(null, null, null), le = this.jpoint(null, null, null), he = ne; he > 0; he--) {
    for (oe = 0; oe < ie.length; oe++)
      se = ie[oe], se === he ? le = le.mixedAdd(ee.points[oe]) : se === -he && (le = le.mixedAdd(ee.points[oe].neg()));
    ue = ue.add(le);
  }
  return ue.toP();
};
BaseCurve.prototype._wnafMul = function(Y, X) {
  var ee = 4, te = Y._getNAFPoints(ee);
  ee = te.wnd;
  for (var ne = te.points, ie = getNAF(X, ee, this._bitLength), oe = this.jpoint(null, null, null), se = ie.length - 1; se >= 0; se--) {
    for (var ae = 0; se >= 0 && ie[se] === 0; se--)
      ae++;
    if (se >= 0 && ae++, oe = oe.dblp(ae), se < 0)
      break;
    var ue = ie[se];
    assert$1$1(ue !== 0), Y.type === "affine" ? ue > 0 ? oe = oe.mixedAdd(ne[ue - 1 >> 1]) : oe = oe.mixedAdd(ne[-ue - 1 >> 1].neg()) : ue > 0 ? oe = oe.add(ne[ue - 1 >> 1]) : oe = oe.add(ne[-ue - 1 >> 1].neg());
  }
  return Y.type === "affine" ? oe.toP() : oe;
};
BaseCurve.prototype._wnafMulAdd = function(Y, X, ee, te, ne) {
  var ie = this._wnafT1, oe = this._wnafT2, se = this._wnafT3, ae = 0, ue, le, he;
  for (ue = 0; ue < te; ue++) {
    he = X[ue];
    var me = he._getNAFPoints(Y);
    ie[ue] = me.wnd, oe[ue] = me.points;
  }
  for (ue = te - 1; ue >= 1; ue -= 2) {
    var ye = ue - 1, we = ue;
    if (ie[ye] !== 1 || ie[we] !== 1) {
      se[ye] = getNAF(ee[ye], ie[ye], this._bitLength), se[we] = getNAF(ee[we], ie[we], this._bitLength), ae = Math.max(se[ye].length, ae), ae = Math.max(se[we].length, ae);
      continue;
    }
    var Ee = [
      X[ye],
      /* 1 */
      null,
      /* 3 */
      null,
      /* 5 */
      X[we]
      /* 7 */
    ];
    X[ye].y.cmp(X[we].y) === 0 ? (Ee[1] = X[ye].add(X[we]), Ee[2] = X[ye].toJ().mixedAdd(X[we].neg())) : X[ye].y.cmp(X[we].y.redNeg()) === 0 ? (Ee[1] = X[ye].toJ().mixedAdd(X[we]), Ee[2] = X[ye].add(X[we].neg())) : (Ee[1] = X[ye].toJ().mixedAdd(X[we]), Ee[2] = X[ye].toJ().mixedAdd(X[we].neg()));
    var Re = [
      -3,
      /* -1 -1 */
      -1,
      /* -1 0 */
      -5,
      /* -1 1 */
      -7,
      /* 0 -1 */
      0,
      /* 0 0 */
      7,
      /* 0 1 */
      5,
      /* 1 -1 */
      1,
      /* 1 0 */
      3
      /* 1 1 */
    ], Ue = getJSF(ee[ye], ee[we]);
    for (ae = Math.max(Ue[0].length, ae), se[ye] = new Array(ae), se[we] = new Array(ae), le = 0; le < ae; le++) {
      var Me = Ue[0][le] | 0, De = Ue[1][le] | 0;
      se[ye][le] = Re[(Me + 1) * 3 + (De + 1)], se[we][le] = 0, oe[ye] = Ee;
    }
  }
  var Fe = this.jpoint(null, null, null), Ke = this._wnafT4;
  for (ue = ae; ue >= 0; ue--) {
    for (var tt = 0; ue >= 0; ) {
      var rt = !0;
      for (le = 0; le < te; le++)
        Ke[le] = se[le][ue] | 0, Ke[le] !== 0 && (rt = !1);
      if (!rt)
        break;
      tt++, ue--;
    }
    if (ue >= 0 && tt++, Fe = Fe.dblp(tt), ue < 0)
      break;
    for (le = 0; le < te; le++) {
      var it = Ke[le];
      it !== 0 && (it > 0 ? he = oe[le][it - 1 >> 1] : it < 0 && (he = oe[le][-it - 1 >> 1].neg()), he.type === "affine" ? Fe = Fe.mixedAdd(he) : Fe = Fe.add(he));
    }
  }
  for (ue = 0; ue < te; ue++)
    oe[ue] = null;
  return ne ? Fe : Fe.toP();
};
function BasePoint(Y, X) {
  this.curve = Y, this.type = X, this.precomputed = null;
}
BaseCurve.BasePoint = BasePoint;
BasePoint.prototype.eq = function() {
  throw new Error("Not implemented");
};
BasePoint.prototype.validate = function() {
  return this.curve.validate(this);
};
BaseCurve.prototype.decodePoint = function(Y, X) {
  Y = utils_1$1$1.toArray(Y, X);
  var ee = this.p.byteLength();
  if ((Y[0] === 4 || Y[0] === 6 || Y[0] === 7) && Y.length - 1 === 2 * ee) {
    Y[0] === 6 ? assert$1$1(Y[Y.length - 1] % 2 === 0) : Y[0] === 7 && assert$1$1(Y[Y.length - 1] % 2 === 1);
    var te = this.point(
      Y.slice(1, 1 + ee),
      Y.slice(1 + ee, 1 + 2 * ee)
    );
    return te;
  } else if ((Y[0] === 2 || Y[0] === 3) && Y.length - 1 === ee)
    return this.pointFromX(Y.slice(1, 1 + ee), Y[0] === 3);
  throw new Error("Unknown point format");
};
BasePoint.prototype.encodeCompressed = function(Y) {
  return this.encode(Y, !0);
};
BasePoint.prototype._encode = function(Y) {
  var X = this.curve.p.byteLength(), ee = this.getX().toArray("be", X);
  return Y ? [this.getY().isEven() ? 2 : 3].concat(ee) : [4].concat(ee, this.getY().toArray("be", X));
};
BasePoint.prototype.encode = function(Y, X) {
  return utils_1$1$1.encode(this._encode(X), Y);
};
BasePoint.prototype.precompute = function(Y) {
  if (this.precomputed)
    return this;
  var X = {
    doubles: null,
    naf: null,
    beta: null
  };
  return X.naf = this._getNAFPoints(8), X.doubles = this._getDoubles(4, Y), X.beta = this._getBeta(), this.precomputed = X, this;
};
BasePoint.prototype._hasDoubles = function(Y) {
  if (!this.precomputed)
    return !1;
  var X = this.precomputed.doubles;
  return X ? X.points.length >= Math.ceil((Y.bitLength() + 1) / X.step) : !1;
};
BasePoint.prototype._getDoubles = function(Y, X) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;
  for (var ee = [this], te = this, ne = 0; ne < X; ne += Y) {
    for (var ie = 0; ie < Y; ie++)
      te = te.dbl();
    ee.push(te);
  }
  return {
    step: Y,
    points: ee
  };
};
BasePoint.prototype._getNAFPoints = function(Y) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;
  for (var X = [this], ee = (1 << Y) - 1, te = ee === 1 ? null : this.dbl(), ne = 1; ne < ee; ne++)
    X[ne] = X[ne - 1].add(te);
  return {
    wnd: Y,
    points: X
  };
};
BasePoint.prototype._getBeta = function() {
  return null;
};
BasePoint.prototype.dblp = function(Y) {
  for (var X = this, ee = 0; ee < Y; ee++)
    X = X.dbl();
  return X;
};
var inherits_browser$1 = createCommonjsModule(function(Y) {
  typeof Object.create == "function" ? Y.exports = function(X, ee) {
    ee && (X.super_ = ee, X.prototype = Object.create(ee.prototype, {
      constructor: {
        value: X,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }));
  } : Y.exports = function(X, ee) {
    if (ee) {
      X.super_ = ee;
      var te = function() {
      };
      te.prototype = ee.prototype, X.prototype = new te(), X.prototype.constructor = X;
    }
  };
}), assert$2$1 = utils_1$1$1.assert;
function ShortCurve(Y) {
  base$4.call(this, "short", Y), this.a = new BN$2(Y.a, 16).toRed(this.red), this.b = new BN$2(Y.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(Y), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);
}
inherits_browser$1(ShortCurve, base$4);
var short_1 = ShortCurve;
ShortCurve.prototype._getEndomorphism = function(Y) {
  if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
    var X, ee;
    if (Y.beta)
      X = new BN$2(Y.beta, 16).toRed(this.red);
    else {
      var te = this._getEndoRoots(this.p);
      X = te[0].cmp(te[1]) < 0 ? te[0] : te[1], X = X.toRed(this.red);
    }
    if (Y.lambda)
      ee = new BN$2(Y.lambda, 16);
    else {
      var ne = this._getEndoRoots(this.n);
      this.g.mul(ne[0]).x.cmp(this.g.x.redMul(X)) === 0 ? ee = ne[0] : (ee = ne[1], assert$2$1(this.g.mul(ee).x.cmp(this.g.x.redMul(X)) === 0));
    }
    var ie;
    return Y.basis ? ie = Y.basis.map(function(oe) {
      return {
        a: new BN$2(oe.a, 16),
        b: new BN$2(oe.b, 16)
      };
    }) : ie = this._getEndoBasis(ee), {
      beta: X,
      lambda: ee,
      basis: ie
    };
  }
};
ShortCurve.prototype._getEndoRoots = function(Y) {
  var X = Y === this.p ? this.red : BN$2.mont(Y), ee = new BN$2(2).toRed(X).redInvm(), te = ee.redNeg(), ne = new BN$2(3).toRed(X).redNeg().redSqrt().redMul(ee), ie = te.redAdd(ne).fromRed(), oe = te.redSub(ne).fromRed();
  return [ie, oe];
};
ShortCurve.prototype._getEndoBasis = function(Y) {
  for (var X = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), ee = Y, te = this.n.clone(), ne = new BN$2(1), ie = new BN$2(0), oe = new BN$2(0), se = new BN$2(1), ae, ue, le, he, me, ye, we, Ee = 0, Re, Ue; ee.cmpn(0) !== 0; ) {
    var Me = te.div(ee);
    Re = te.sub(Me.mul(ee)), Ue = oe.sub(Me.mul(ne));
    var De = se.sub(Me.mul(ie));
    if (!le && Re.cmp(X) < 0)
      ae = we.neg(), ue = ne, le = Re.neg(), he = Ue;
    else if (le && ++Ee === 2)
      break;
    we = Re, te = ee, ee = Re, oe = ne, ne = Ue, se = ie, ie = De;
  }
  me = Re.neg(), ye = Ue;
  var Fe = le.sqr().add(he.sqr()), Ke = me.sqr().add(ye.sqr());
  return Ke.cmp(Fe) >= 0 && (me = ae, ye = ue), le.negative && (le = le.neg(), he = he.neg()), me.negative && (me = me.neg(), ye = ye.neg()), [
    { a: le, b: he },
    { a: me, b: ye }
  ];
};
ShortCurve.prototype._endoSplit = function(Y) {
  var X = this.endo.basis, ee = X[0], te = X[1], ne = te.b.mul(Y).divRound(this.n), ie = ee.b.neg().mul(Y).divRound(this.n), oe = ne.mul(ee.a), se = ie.mul(te.a), ae = ne.mul(ee.b), ue = ie.mul(te.b), le = Y.sub(oe).sub(se), he = ae.add(ue).neg();
  return { k1: le, k2: he };
};
ShortCurve.prototype.pointFromX = function(Y, X) {
  Y = new BN$2(Y, 16), Y.red || (Y = Y.toRed(this.red));
  var ee = Y.redSqr().redMul(Y).redIAdd(Y.redMul(this.a)).redIAdd(this.b), te = ee.redSqrt();
  if (te.redSqr().redSub(ee).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var ne = te.fromRed().isOdd();
  return (X && !ne || !X && ne) && (te = te.redNeg()), this.point(Y, te);
};
ShortCurve.prototype.validate = function(Y) {
  if (Y.inf)
    return !0;
  var X = Y.x, ee = Y.y, te = this.a.redMul(X), ne = X.redSqr().redMul(X).redIAdd(te).redIAdd(this.b);
  return ee.redSqr().redISub(ne).cmpn(0) === 0;
};
ShortCurve.prototype._endoWnafMulAdd = function(Y, X, ee) {
  for (var te = this._endoWnafT1, ne = this._endoWnafT2, ie = 0; ie < Y.length; ie++) {
    var oe = this._endoSplit(X[ie]), se = Y[ie], ae = se._getBeta();
    oe.k1.negative && (oe.k1.ineg(), se = se.neg(!0)), oe.k2.negative && (oe.k2.ineg(), ae = ae.neg(!0)), te[ie * 2] = se, te[ie * 2 + 1] = ae, ne[ie * 2] = oe.k1, ne[ie * 2 + 1] = oe.k2;
  }
  for (var ue = this._wnafMulAdd(1, te, ne, ie * 2, ee), le = 0; le < ie * 2; le++)
    te[le] = null, ne[le] = null;
  return ue;
};
function Point(Y, X, ee, te) {
  base$4.BasePoint.call(this, Y, "affine"), X === null && ee === null ? (this.x = null, this.y = null, this.inf = !0) : (this.x = new BN$2(X, 16), this.y = new BN$2(ee, 16), te && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1);
}
inherits_browser$1(Point, base$4.BasePoint);
ShortCurve.prototype.point = function(Y, X, ee) {
  return new Point(this, Y, X, ee);
};
ShortCurve.prototype.pointFromJSON = function(Y, X) {
  return Point.fromJSON(this, Y, X);
};
Point.prototype._getBeta = function() {
  if (this.curve.endo) {
    var Y = this.precomputed;
    if (Y && Y.beta)
      return Y.beta;
    var X = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
    if (Y) {
      var ee = this.curve, te = function(ne) {
        return ee.point(ne.x.redMul(ee.endo.beta), ne.y);
      };
      Y.beta = X, X.precomputed = {
        beta: null,
        naf: Y.naf && {
          wnd: Y.naf.wnd,
          points: Y.naf.points.map(te)
        },
        doubles: Y.doubles && {
          step: Y.doubles.step,
          points: Y.doubles.points.map(te)
        }
      };
    }
    return X;
  }
};
Point.prototype.toJSON = function() {
  return this.precomputed ? [this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1)
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1)
    }
  }] : [this.x, this.y];
};
Point.fromJSON = function(Y, X, ee) {
  typeof X == "string" && (X = JSON.parse(X));
  var te = Y.point(X[0], X[1], ee);
  if (!X[2])
    return te;
  function ne(oe) {
    return Y.point(oe[0], oe[1], ee);
  }
  var ie = X[2];
  return te.precomputed = {
    beta: null,
    doubles: ie.doubles && {
      step: ie.doubles.step,
      points: [te].concat(ie.doubles.points.map(ne))
    },
    naf: ie.naf && {
      wnd: ie.naf.wnd,
      points: [te].concat(ie.naf.points.map(ne))
    }
  }, te;
};
Point.prototype.inspect = function() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
};
Point.prototype.isInfinity = function() {
  return this.inf;
};
Point.prototype.add = function(Y) {
  if (this.inf)
    return Y;
  if (Y.inf)
    return this;
  if (this.eq(Y))
    return this.dbl();
  if (this.neg().eq(Y))
    return this.curve.point(null, null);
  if (this.x.cmp(Y.x) === 0)
    return this.curve.point(null, null);
  var X = this.y.redSub(Y.y);
  X.cmpn(0) !== 0 && (X = X.redMul(this.x.redSub(Y.x).redInvm()));
  var ee = X.redSqr().redISub(this.x).redISub(Y.x), te = X.redMul(this.x.redSub(ee)).redISub(this.y);
  return this.curve.point(ee, te);
};
Point.prototype.dbl = function() {
  if (this.inf)
    return this;
  var Y = this.y.redAdd(this.y);
  if (Y.cmpn(0) === 0)
    return this.curve.point(null, null);
  var X = this.curve.a, ee = this.x.redSqr(), te = Y.redInvm(), ne = ee.redAdd(ee).redIAdd(ee).redIAdd(X).redMul(te), ie = ne.redSqr().redISub(this.x.redAdd(this.x)), oe = ne.redMul(this.x.redSub(ie)).redISub(this.y);
  return this.curve.point(ie, oe);
};
Point.prototype.getX = function() {
  return this.x.fromRed();
};
Point.prototype.getY = function() {
  return this.y.fromRed();
};
Point.prototype.mul = function(Y) {
  return Y = new BN$2(Y, 16), this.isInfinity() ? this : this._hasDoubles(Y) ? this.curve._fixedNafMul(this, Y) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [Y]) : this.curve._wnafMul(this, Y);
};
Point.prototype.mulAdd = function(Y, X, ee) {
  var te = [this, X], ne = [Y, ee];
  return this.curve.endo ? this.curve._endoWnafMulAdd(te, ne) : this.curve._wnafMulAdd(1, te, ne, 2);
};
Point.prototype.jmulAdd = function(Y, X, ee) {
  var te = [this, X], ne = [Y, ee];
  return this.curve.endo ? this.curve._endoWnafMulAdd(te, ne, !0) : this.curve._wnafMulAdd(1, te, ne, 2, !0);
};
Point.prototype.eq = function(Y) {
  return this === Y || this.inf === Y.inf && (this.inf || this.x.cmp(Y.x) === 0 && this.y.cmp(Y.y) === 0);
};
Point.prototype.neg = function(Y) {
  if (this.inf)
    return this;
  var X = this.curve.point(this.x, this.y.redNeg());
  if (Y && this.precomputed) {
    var ee = this.precomputed, te = function(ne) {
      return ne.neg();
    };
    X.precomputed = {
      naf: ee.naf && {
        wnd: ee.naf.wnd,
        points: ee.naf.points.map(te)
      },
      doubles: ee.doubles && {
        step: ee.doubles.step,
        points: ee.doubles.points.map(te)
      }
    };
  }
  return X;
};
Point.prototype.toJ = function() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);
  var Y = this.curve.jpoint(this.x, this.y, this.curve.one);
  return Y;
};
function JPoint(Y, X, ee, te) {
  base$4.BasePoint.call(this, Y, "jacobian"), X === null && ee === null && te === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new BN$2(0)) : (this.x = new BN$2(X, 16), this.y = new BN$2(ee, 16), this.z = new BN$2(te, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;
}
inherits_browser$1(JPoint, base$4.BasePoint);
ShortCurve.prototype.jpoint = function(Y, X, ee) {
  return new JPoint(this, Y, X, ee);
};
JPoint.prototype.toP = function() {
  if (this.isInfinity())
    return this.curve.point(null, null);
  var Y = this.z.redInvm(), X = Y.redSqr(), ee = this.x.redMul(X), te = this.y.redMul(X).redMul(Y);
  return this.curve.point(ee, te);
};
JPoint.prototype.neg = function() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};
JPoint.prototype.add = function(Y) {
  if (this.isInfinity())
    return Y;
  if (Y.isInfinity())
    return this;
  var X = Y.z.redSqr(), ee = this.z.redSqr(), te = this.x.redMul(X), ne = Y.x.redMul(ee), ie = this.y.redMul(X.redMul(Y.z)), oe = Y.y.redMul(ee.redMul(this.z)), se = te.redSub(ne), ae = ie.redSub(oe);
  if (se.cmpn(0) === 0)
    return ae.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var ue = se.redSqr(), le = ue.redMul(se), he = te.redMul(ue), me = ae.redSqr().redIAdd(le).redISub(he).redISub(he), ye = ae.redMul(he.redISub(me)).redISub(ie.redMul(le)), we = this.z.redMul(Y.z).redMul(se);
  return this.curve.jpoint(me, ye, we);
};
JPoint.prototype.mixedAdd = function(Y) {
  if (this.isInfinity())
    return Y.toJ();
  if (Y.isInfinity())
    return this;
  var X = this.z.redSqr(), ee = this.x, te = Y.x.redMul(X), ne = this.y, ie = Y.y.redMul(X).redMul(this.z), oe = ee.redSub(te), se = ne.redSub(ie);
  if (oe.cmpn(0) === 0)
    return se.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var ae = oe.redSqr(), ue = ae.redMul(oe), le = ee.redMul(ae), he = se.redSqr().redIAdd(ue).redISub(le).redISub(le), me = se.redMul(le.redISub(he)).redISub(ne.redMul(ue)), ye = this.z.redMul(oe);
  return this.curve.jpoint(he, me, ye);
};
JPoint.prototype.dblp = function(Y) {
  if (Y === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!Y)
    return this.dbl();
  var X;
  if (this.curve.zeroA || this.curve.threeA) {
    var ee = this;
    for (X = 0; X < Y; X++)
      ee = ee.dbl();
    return ee;
  }
  var te = this.curve.a, ne = this.curve.tinv, ie = this.x, oe = this.y, se = this.z, ae = se.redSqr().redSqr(), ue = oe.redAdd(oe);
  for (X = 0; X < Y; X++) {
    var le = ie.redSqr(), he = ue.redSqr(), me = he.redSqr(), ye = le.redAdd(le).redIAdd(le).redIAdd(te.redMul(ae)), we = ie.redMul(he), Ee = ye.redSqr().redISub(we.redAdd(we)), Re = we.redISub(Ee), Ue = ye.redMul(Re);
    Ue = Ue.redIAdd(Ue).redISub(me);
    var Me = ue.redMul(se);
    X + 1 < Y && (ae = ae.redMul(me)), ie = Ee, se = Me, ue = Ue;
  }
  return this.curve.jpoint(ie, ue.redMul(ne), se);
};
JPoint.prototype.dbl = function() {
  return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();
};
JPoint.prototype._zeroDbl = function() {
  var Y, X, ee;
  if (this.zOne) {
    var te = this.x.redSqr(), ne = this.y.redSqr(), ie = ne.redSqr(), oe = this.x.redAdd(ne).redSqr().redISub(te).redISub(ie);
    oe = oe.redIAdd(oe);
    var se = te.redAdd(te).redIAdd(te), ae = se.redSqr().redISub(oe).redISub(oe), ue = ie.redIAdd(ie);
    ue = ue.redIAdd(ue), ue = ue.redIAdd(ue), Y = ae, X = se.redMul(oe.redISub(ae)).redISub(ue), ee = this.y.redAdd(this.y);
  } else {
    var le = this.x.redSqr(), he = this.y.redSqr(), me = he.redSqr(), ye = this.x.redAdd(he).redSqr().redISub(le).redISub(me);
    ye = ye.redIAdd(ye);
    var we = le.redAdd(le).redIAdd(le), Ee = we.redSqr(), Re = me.redIAdd(me);
    Re = Re.redIAdd(Re), Re = Re.redIAdd(Re), Y = Ee.redISub(ye).redISub(ye), X = we.redMul(ye.redISub(Y)).redISub(Re), ee = this.y.redMul(this.z), ee = ee.redIAdd(ee);
  }
  return this.curve.jpoint(Y, X, ee);
};
JPoint.prototype._threeDbl = function() {
  var Y, X, ee;
  if (this.zOne) {
    var te = this.x.redSqr(), ne = this.y.redSqr(), ie = ne.redSqr(), oe = this.x.redAdd(ne).redSqr().redISub(te).redISub(ie);
    oe = oe.redIAdd(oe);
    var se = te.redAdd(te).redIAdd(te).redIAdd(this.curve.a), ae = se.redSqr().redISub(oe).redISub(oe);
    Y = ae;
    var ue = ie.redIAdd(ie);
    ue = ue.redIAdd(ue), ue = ue.redIAdd(ue), X = se.redMul(oe.redISub(ae)).redISub(ue), ee = this.y.redAdd(this.y);
  } else {
    var le = this.z.redSqr(), he = this.y.redSqr(), me = this.x.redMul(he), ye = this.x.redSub(le).redMul(this.x.redAdd(le));
    ye = ye.redAdd(ye).redIAdd(ye);
    var we = me.redIAdd(me);
    we = we.redIAdd(we);
    var Ee = we.redAdd(we);
    Y = ye.redSqr().redISub(Ee), ee = this.y.redAdd(this.z).redSqr().redISub(he).redISub(le);
    var Re = he.redSqr();
    Re = Re.redIAdd(Re), Re = Re.redIAdd(Re), Re = Re.redIAdd(Re), X = ye.redMul(we.redISub(Y)).redISub(Re);
  }
  return this.curve.jpoint(Y, X, ee);
};
JPoint.prototype._dbl = function() {
  var Y = this.curve.a, X = this.x, ee = this.y, te = this.z, ne = te.redSqr().redSqr(), ie = X.redSqr(), oe = ee.redSqr(), se = ie.redAdd(ie).redIAdd(ie).redIAdd(Y.redMul(ne)), ae = X.redAdd(X);
  ae = ae.redIAdd(ae);
  var ue = ae.redMul(oe), le = se.redSqr().redISub(ue.redAdd(ue)), he = ue.redISub(le), me = oe.redSqr();
  me = me.redIAdd(me), me = me.redIAdd(me), me = me.redIAdd(me);
  var ye = se.redMul(he).redISub(me), we = ee.redAdd(ee).redMul(te);
  return this.curve.jpoint(le, ye, we);
};
JPoint.prototype.trpl = function() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);
  var Y = this.x.redSqr(), X = this.y.redSqr(), ee = this.z.redSqr(), te = X.redSqr(), ne = Y.redAdd(Y).redIAdd(Y), ie = ne.redSqr(), oe = this.x.redAdd(X).redSqr().redISub(Y).redISub(te);
  oe = oe.redIAdd(oe), oe = oe.redAdd(oe).redIAdd(oe), oe = oe.redISub(ie);
  var se = oe.redSqr(), ae = te.redIAdd(te);
  ae = ae.redIAdd(ae), ae = ae.redIAdd(ae), ae = ae.redIAdd(ae);
  var ue = ne.redIAdd(oe).redSqr().redISub(ie).redISub(se).redISub(ae), le = X.redMul(ue);
  le = le.redIAdd(le), le = le.redIAdd(le);
  var he = this.x.redMul(se).redISub(le);
  he = he.redIAdd(he), he = he.redIAdd(he);
  var me = this.y.redMul(ue.redMul(ae.redISub(ue)).redISub(oe.redMul(se)));
  me = me.redIAdd(me), me = me.redIAdd(me), me = me.redIAdd(me);
  var ye = this.z.redAdd(oe).redSqr().redISub(ee).redISub(se);
  return this.curve.jpoint(he, me, ye);
};
JPoint.prototype.mul = function(Y, X) {
  return Y = new BN$2(Y, X), this.curve._wnafMul(this, Y);
};
JPoint.prototype.eq = function(Y) {
  if (Y.type === "affine")
    return this.eq(Y.toJ());
  if (this === Y)
    return !0;
  var X = this.z.redSqr(), ee = Y.z.redSqr();
  if (this.x.redMul(ee).redISub(Y.x.redMul(X)).cmpn(0) !== 0)
    return !1;
  var te = X.redMul(this.z), ne = ee.redMul(Y.z);
  return this.y.redMul(ne).redISub(Y.y.redMul(te)).cmpn(0) === 0;
};
JPoint.prototype.eqXToP = function(Y) {
  var X = this.z.redSqr(), ee = Y.toRed(this.curve.red).redMul(X);
  if (this.x.cmp(ee) === 0)
    return !0;
  for (var te = Y.clone(), ne = this.curve.redN.redMul(X); ; ) {
    if (te.iadd(this.curve.n), te.cmp(this.curve.p) >= 0)
      return !1;
    if (ee.redIAdd(ne), this.x.cmp(ee) === 0)
      return !0;
  }
};
JPoint.prototype.inspect = function() {
  return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
};
JPoint.prototype.isInfinity = function() {
  return this.z.cmpn(0) === 0;
};
var curve_1 = createCommonjsModule(function(Y, X) {
  var ee = X;
  ee.base = base$4, ee.short = short_1, ee.mont = /*RicMoo:ethers:require(./mont)*/
  null, ee.edwards = /*RicMoo:ethers:require(./edwards)*/
  null;
}), curves_1 = createCommonjsModule(function(Y, X) {
  var ee = X, te = utils_1$1$1.assert;
  function ne(se) {
    se.type === "short" ? this.curve = new curve_1.short(se) : se.type === "edwards" ? this.curve = new curve_1.edwards(se) : this.curve = new curve_1.mont(se), this.g = this.curve.g, this.n = this.curve.n, this.hash = se.hash, te(this.g.validate(), "Invalid curve"), te(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
  }
  ee.PresetCurve = ne;
  function ie(se, ae) {
    Object.defineProperty(ee, se, {
      configurable: !0,
      enumerable: !0,
      get: function() {
        var ue = new ne(ae);
        return Object.defineProperty(ee, se, {
          configurable: !0,
          enumerable: !0,
          value: ue
        }), ue;
      }
    });
  }
  ie("p192", {
    type: "short",
    prime: "p192",
    p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
    b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
    n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
    hash: hash$4.sha256,
    gRed: !1,
    g: [
      "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
      "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
    ]
  }), ie("p224", {
    type: "short",
    prime: "p224",
    p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
    b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
    n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
    hash: hash$4.sha256,
    gRed: !1,
    g: [
      "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
      "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
    ]
  }), ie("p256", {
    type: "short",
    prime: null,
    p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
    a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
    b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
    n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
    hash: hash$4.sha256,
    gRed: !1,
    g: [
      "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
      "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
    ]
  }), ie("p384", {
    type: "short",
    prime: null,
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
    a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
    b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
    n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
    hash: hash$4.sha384,
    gRed: !1,
    g: [
      "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
      "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
    ]
  }), ie("p521", {
    type: "short",
    prime: null,
    p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
    a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
    b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
    n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
    hash: hash$4.sha512,
    gRed: !1,
    g: [
      "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
      "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
    ]
  }), ie("curve25519", {
    type: "mont",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "76d06",
    b: "1",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: hash$4.sha256,
    gRed: !1,
    g: [
      "9"
    ]
  }), ie("ed25519", {
    type: "edwards",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "-1",
    c: "1",
    // -121665 * (121666^(-1)) (mod P)
    d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: hash$4.sha256,
    gRed: !1,
    g: [
      "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
      // 4/5
      "6666666666666666666666666666666666666666666666666666666666666658"
    ]
  });
  var oe;
  try {
    oe = /*RicMoo:ethers:require(./precomputed/secp256k1)*/
    null.crash();
  } catch {
    oe = void 0;
  }
  ie("secp256k1", {
    type: "short",
    prime: "k256",
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
    a: "0",
    b: "7",
    n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
    h: "1",
    hash: hash$4.sha256,
    // Precomputed endomorphism
    beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
    lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
    basis: [
      {
        a: "3086d221a7d46bcde86c90e49284eb15",
        b: "-e4437ed6010e88286f547fa90abfe4c3"
      },
      {
        a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
        b: "3086d221a7d46bcde86c90e49284eb15"
      }
    ],
    gRed: !1,
    g: [
      "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
      "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
      oe
    ]
  });
});
function HmacDRBG(Y) {
  if (!(this instanceof HmacDRBG))
    return new HmacDRBG(Y);
  this.hash = Y.hash, this.predResist = !!Y.predResist, this.outLen = this.hash.outSize, this.minEntropy = Y.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
  var X = utils_1$1.toArray(Y.entropy, Y.entropyEnc || "hex"), ee = utils_1$1.toArray(Y.nonce, Y.nonceEnc || "hex"), te = utils_1$1.toArray(Y.pers, Y.persEnc || "hex");
  minimalisticAssert$1(
    X.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  ), this._init(X, ee, te);
}
var hmacDrbg$1 = HmacDRBG;
HmacDRBG.prototype._init = function(Y, X, ee) {
  var te = Y.concat(X).concat(ee);
  this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
  for (var ne = 0; ne < this.V.length; ne++)
    this.K[ne] = 0, this.V[ne] = 1;
  this._update(te), this._reseed = 1, this.reseedInterval = 281474976710656;
};
HmacDRBG.prototype._hmac = function() {
  return new hash$4.hmac(this.hash, this.K);
};
HmacDRBG.prototype._update = function(Y) {
  var X = this._hmac().update(this.V).update([0]);
  Y && (X = X.update(Y)), this.K = X.digest(), this.V = this._hmac().update(this.V).digest(), Y && (this.K = this._hmac().update(this.V).update([1]).update(Y).digest(), this.V = this._hmac().update(this.V).digest());
};
HmacDRBG.prototype.reseed = function(Y, X, ee, te) {
  typeof X != "string" && (te = ee, ee = X, X = null), Y = utils_1$1.toArray(Y, X), ee = utils_1$1.toArray(ee, te), minimalisticAssert$1(
    Y.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  ), this._update(Y.concat(ee || [])), this._reseed = 1;
};
HmacDRBG.prototype.generate = function(Y, X, ee, te) {
  if (this._reseed > this.reseedInterval)
    throw new Error("Reseed is required");
  typeof X != "string" && (te = ee, ee = X, X = null), ee && (ee = utils_1$1.toArray(ee, te || "hex"), this._update(ee));
  for (var ne = []; ne.length < Y; )
    this.V = this._hmac().update(this.V).digest(), ne = ne.concat(this.V);
  var ie = ne.slice(0, Y);
  return this._update(ee), this._reseed++, utils_1$1.encode(ie, X);
};
var assert$3$1 = utils_1$1$1.assert;
function KeyPair(Y, X) {
  this.ec = Y, this.priv = null, this.pub = null, X.priv && this._importPrivate(X.priv, X.privEnc), X.pub && this._importPublic(X.pub, X.pubEnc);
}
var key$2 = KeyPair;
KeyPair.fromPublic = function(Y, X, ee) {
  return X instanceof KeyPair ? X : new KeyPair(Y, {
    pub: X,
    pubEnc: ee
  });
};
KeyPair.fromPrivate = function(Y, X, ee) {
  return X instanceof KeyPair ? X : new KeyPair(Y, {
    priv: X,
    privEnc: ee
  });
};
KeyPair.prototype.validate = function() {
  var Y = this.getPublic();
  return Y.isInfinity() ? { result: !1, reason: "Invalid public key" } : Y.validate() ? Y.mul(this.ec.curve.n).isInfinity() ? { result: !0, reason: null } : { result: !1, reason: "Public key * N != O" } : { result: !1, reason: "Public key is not a point" };
};
KeyPair.prototype.getPublic = function(Y, X) {
  return typeof Y == "string" && (X = Y, Y = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), X ? this.pub.encode(X, Y) : this.pub;
};
KeyPair.prototype.getPrivate = function(Y) {
  return Y === "hex" ? this.priv.toString(16, 2) : this.priv;
};
KeyPair.prototype._importPrivate = function(Y, X) {
  this.priv = new BN$2(Y, X || 16), this.priv = this.priv.umod(this.ec.curve.n);
};
KeyPair.prototype._importPublic = function(Y, X) {
  if (Y.x || Y.y) {
    this.ec.curve.type === "mont" ? assert$3$1(Y.x, "Need x coordinate") : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") && assert$3$1(Y.x && Y.y, "Need both x and y coordinate"), this.pub = this.ec.curve.point(Y.x, Y.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(Y, X);
};
KeyPair.prototype.derive = function(Y) {
  return Y.validate() || assert$3$1(Y.validate(), "public point not validated"), Y.mul(this.priv).getX();
};
KeyPair.prototype.sign = function(Y, X, ee) {
  return this.ec.sign(Y, this, X, ee);
};
KeyPair.prototype.verify = function(Y, X) {
  return this.ec.verify(Y, X, this);
};
KeyPair.prototype.inspect = function() {
  return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
};
var assert$4 = utils_1$1$1.assert;
function Signature(Y, X) {
  if (Y instanceof Signature)
    return Y;
  this._importDER(Y, X) || (assert$4(Y.r && Y.s, "Signature without r or s"), this.r = new BN$2(Y.r, 16), this.s = new BN$2(Y.s, 16), Y.recoveryParam === void 0 ? this.recoveryParam = null : this.recoveryParam = Y.recoveryParam);
}
var signature$2 = Signature;
function Position() {
  this.place = 0;
}
function getLength(Y, X) {
  var ee = Y[X.place++];
  if (!(ee & 128))
    return ee;
  var te = ee & 15;
  if (te === 0 || te > 4)
    return !1;
  for (var ne = 0, ie = 0, oe = X.place; ie < te; ie++, oe++)
    ne <<= 8, ne |= Y[oe], ne >>>= 0;
  return ne <= 127 ? !1 : (X.place = oe, ne);
}
function rmPadding(Y) {
  for (var X = 0, ee = Y.length - 1; !Y[X] && !(Y[X + 1] & 128) && X < ee; )
    X++;
  return X === 0 ? Y : Y.slice(X);
}
Signature.prototype._importDER = function(Y, X) {
  Y = utils_1$1$1.toArray(Y, X);
  var ee = new Position();
  if (Y[ee.place++] !== 48)
    return !1;
  var te = getLength(Y, ee);
  if (te === !1 || te + ee.place !== Y.length || Y[ee.place++] !== 2)
    return !1;
  var ne = getLength(Y, ee);
  if (ne === !1)
    return !1;
  var ie = Y.slice(ee.place, ne + ee.place);
  if (ee.place += ne, Y[ee.place++] !== 2)
    return !1;
  var oe = getLength(Y, ee);
  if (oe === !1 || Y.length !== oe + ee.place)
    return !1;
  var se = Y.slice(ee.place, oe + ee.place);
  if (ie[0] === 0)
    if (ie[1] & 128)
      ie = ie.slice(1);
    else
      return !1;
  if (se[0] === 0)
    if (se[1] & 128)
      se = se.slice(1);
    else
      return !1;
  return this.r = new BN$2(ie), this.s = new BN$2(se), this.recoveryParam = null, !0;
};
function constructLength(Y, X) {
  if (X < 128) {
    Y.push(X);
    return;
  }
  var ee = 1 + (Math.log(X) / Math.LN2 >>> 3);
  for (Y.push(ee | 128); --ee; )
    Y.push(X >>> (ee << 3) & 255);
  Y.push(X);
}
Signature.prototype.toDER = function(Y) {
  var X = this.r.toArray(), ee = this.s.toArray();
  for (X[0] & 128 && (X = [0].concat(X)), ee[0] & 128 && (ee = [0].concat(ee)), X = rmPadding(X), ee = rmPadding(ee); !ee[0] && !(ee[1] & 128); )
    ee = ee.slice(1);
  var te = [2];
  constructLength(te, X.length), te = te.concat(X), te.push(2), constructLength(te, ee.length);
  var ne = te.concat(ee), ie = [48];
  return constructLength(ie, ne.length), ie = ie.concat(ne), utils_1$1$1.encode(ie, Y);
};
var rand = (
  /*RicMoo:ethers:require(brorand)*/
  function() {
    throw new Error("unsupported");
  }
), assert$5 = utils_1$1$1.assert;
function EC(Y) {
  if (!(this instanceof EC))
    return new EC(Y);
  typeof Y == "string" && (assert$5(
    Object.prototype.hasOwnProperty.call(curves_1, Y),
    "Unknown curve " + Y
  ), Y = curves_1[Y]), Y instanceof curves_1.PresetCurve && (Y = { curve: Y }), this.curve = Y.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = Y.curve.g, this.g.precompute(Y.curve.n.bitLength() + 1), this.hash = Y.hash || Y.curve.hash;
}
var ec$1 = EC;
EC.prototype.keyPair = function(Y) {
  return new key$2(this, Y);
};
EC.prototype.keyFromPrivate = function(Y, X) {
  return key$2.fromPrivate(this, Y, X);
};
EC.prototype.keyFromPublic = function(Y, X) {
  return key$2.fromPublic(this, Y, X);
};
EC.prototype.genKeyPair = function(Y) {
  Y || (Y = {});
  for (var X = new hmacDrbg$1({
    hash: this.hash,
    pers: Y.pers,
    persEnc: Y.persEnc || "utf8",
    entropy: Y.entropy || rand(this.hash.hmacStrength),
    entropyEnc: Y.entropy && Y.entropyEnc || "utf8",
    nonce: this.n.toArray()
  }), ee = this.n.byteLength(), te = this.n.sub(new BN$2(2)); ; ) {
    var ne = new BN$2(X.generate(ee));
    if (!(ne.cmp(te) > 0))
      return ne.iaddn(1), this.keyFromPrivate(ne);
  }
};
EC.prototype._truncateToN = function(Y, X) {
  var ee = Y.byteLength() * 8 - this.n.bitLength();
  return ee > 0 && (Y = Y.ushrn(ee)), !X && Y.cmp(this.n) >= 0 ? Y.sub(this.n) : Y;
};
EC.prototype.sign = function(Y, X, ee, te) {
  typeof ee == "object" && (te = ee, ee = null), te || (te = {}), X = this.keyFromPrivate(X, ee), Y = this._truncateToN(new BN$2(Y, 16));
  for (var ne = this.n.byteLength(), ie = X.getPrivate().toArray("be", ne), oe = Y.toArray("be", ne), se = new hmacDrbg$1({
    hash: this.hash,
    entropy: ie,
    nonce: oe,
    pers: te.pers,
    persEnc: te.persEnc || "utf8"
  }), ae = this.n.sub(new BN$2(1)), ue = 0; ; ue++) {
    var le = te.k ? te.k(ue) : new BN$2(se.generate(this.n.byteLength()));
    if (le = this._truncateToN(le, !0), !(le.cmpn(1) <= 0 || le.cmp(ae) >= 0)) {
      var he = this.g.mul(le);
      if (!he.isInfinity()) {
        var me = he.getX(), ye = me.umod(this.n);
        if (ye.cmpn(0) !== 0) {
          var we = le.invm(this.n).mul(ye.mul(X.getPrivate()).iadd(Y));
          if (we = we.umod(this.n), we.cmpn(0) !== 0) {
            var Ee = (he.getY().isOdd() ? 1 : 0) | (me.cmp(ye) !== 0 ? 2 : 0);
            return te.canonical && we.cmp(this.nh) > 0 && (we = this.n.sub(we), Ee ^= 1), new signature$2({ r: ye, s: we, recoveryParam: Ee });
          }
        }
      }
    }
  }
};
EC.prototype.verify = function(Y, X, ee, te) {
  Y = this._truncateToN(new BN$2(Y, 16)), ee = this.keyFromPublic(ee, te), X = new signature$2(X, "hex");
  var ne = X.r, ie = X.s;
  if (ne.cmpn(1) < 0 || ne.cmp(this.n) >= 0 || ie.cmpn(1) < 0 || ie.cmp(this.n) >= 0)
    return !1;
  var oe = ie.invm(this.n), se = oe.mul(Y).umod(this.n), ae = oe.mul(ne).umod(this.n), ue;
  return this.curve._maxwellTrick ? (ue = this.g.jmulAdd(se, ee.getPublic(), ae), ue.isInfinity() ? !1 : ue.eqXToP(ne)) : (ue = this.g.mulAdd(se, ee.getPublic(), ae), ue.isInfinity() ? !1 : ue.getX().umod(this.n).cmp(ne) === 0);
};
EC.prototype.recoverPubKey = function(Y, X, ee, te) {
  assert$5((3 & ee) === ee, "The recovery param is more than two bits"), X = new signature$2(X, te);
  var ne = this.n, ie = new BN$2(Y), oe = X.r, se = X.s, ae = ee & 1, ue = ee >> 1;
  if (oe.cmp(this.curve.p.umod(this.curve.n)) >= 0 && ue)
    throw new Error("Unable to find sencond key candinate");
  ue ? oe = this.curve.pointFromX(oe.add(this.curve.n), ae) : oe = this.curve.pointFromX(oe, ae);
  var le = X.r.invm(ne), he = ne.sub(ie).mul(le).umod(ne), me = se.mul(le).umod(ne);
  return this.g.mulAdd(he, oe, me);
};
EC.prototype.getKeyRecoveryParam = function(Y, X, ee, te) {
  if (X = new signature$2(X, te), X.recoveryParam !== null)
    return X.recoveryParam;
  for (var ne = 0; ne < 4; ne++) {
    var ie;
    try {
      ie = this.recoverPubKey(Y, X, ne);
    } catch {
      continue;
    }
    if (ie.eq(ee))
      return ne;
  }
  throw new Error("Unable to find valid recovery factor");
};
var elliptic_1 = createCommonjsModule(function(Y, X) {
  var ee = X;
  ee.version = "6.5.4", ee.utils = utils_1$1$1, ee.rand = /*RicMoo:ethers:require(brorand)*/
  function() {
    throw new Error("unsupported");
  }, ee.curve = curve_1, ee.curves = curves_1, ee.ec = ec$1, ee.eddsa = /*RicMoo:ethers:require(./elliptic/eddsa)*/
  null;
}), EC$1 = elliptic_1.ec;
const version$7 = "signing-key/5.7.0", logger$7 = new Logger(version$7);
let _curve = null;
function getCurve() {
  return _curve || (_curve = new EC$1("secp256k1")), _curve;
}
class SigningKey {
  constructor(X) {
    defineReadOnly(this, "curve", "secp256k1"), defineReadOnly(this, "privateKey", hexlify(X)), hexDataLength(this.privateKey) !== 32 && logger$7.throwArgumentError("invalid private key", "privateKey", "[[ REDACTED ]]");
    const ee = getCurve().keyFromPrivate(arrayify(this.privateKey));
    defineReadOnly(this, "publicKey", "0x" + ee.getPublic(!1, "hex")), defineReadOnly(this, "compressedPublicKey", "0x" + ee.getPublic(!0, "hex")), defineReadOnly(this, "_isSigningKey", !0);
  }
  _addPoint(X) {
    const ee = getCurve().keyFromPublic(arrayify(this.publicKey)), te = getCurve().keyFromPublic(arrayify(X));
    return "0x" + ee.pub.add(te.pub).encodeCompressed("hex");
  }
  signDigest(X) {
    const ee = getCurve().keyFromPrivate(arrayify(this.privateKey)), te = arrayify(X);
    te.length !== 32 && logger$7.throwArgumentError("bad digest length", "digest", X);
    const ne = ee.sign(te, { canonical: !0 });
    return splitSignature({
      recoveryParam: ne.recoveryParam,
      r: hexZeroPad("0x" + ne.r.toString(16), 32),
      s: hexZeroPad("0x" + ne.s.toString(16), 32)
    });
  }
  computeSharedSecret(X) {
    const ee = getCurve().keyFromPrivate(arrayify(this.privateKey)), te = getCurve().keyFromPublic(arrayify(computePublicKey(X)));
    return hexZeroPad("0x" + ee.derive(te.getPublic()).toString(16), 32);
  }
  static isSigningKey(X) {
    return !!(X && X._isSigningKey);
  }
}
function recoverPublicKey(Y, X) {
  const ee = splitSignature(X), te = { r: arrayify(ee.r), s: arrayify(ee.s) };
  return "0x" + getCurve().recoverPubKey(arrayify(Y), te, ee.recoveryParam).encode("hex", !1);
}
function computePublicKey(Y, X) {
  const ee = arrayify(Y);
  if (ee.length === 32) {
    const te = new SigningKey(ee);
    return X ? "0x" + getCurve().keyFromPrivate(ee).getPublic(!0, "hex") : te.publicKey;
  } else {
    if (ee.length === 33)
      return X ? hexlify(ee) : "0x" + getCurve().keyFromPublic(ee).getPublic(!1, "hex");
    if (ee.length === 65)
      return X ? "0x" + getCurve().keyFromPublic(ee).getPublic(!0, "hex") : hexlify(ee);
  }
  return logger$7.throwArgumentError("invalid public or private key", "key", "[REDACTED]");
}
const version$6 = "transactions/5.7.0", logger$6 = new Logger(version$6);
var TransactionTypes;
(function(Y) {
  Y[Y.legacy = 0] = "legacy", Y[Y.eip2930 = 1] = "eip2930", Y[Y.eip1559 = 2] = "eip1559";
})(TransactionTypes || (TransactionTypes = {}));
function handleAddress(Y) {
  return Y === "0x" ? null : getAddress(Y);
}
function handleNumber(Y) {
  return Y === "0x" ? Zero$1 : BigNumber.from(Y);
}
function computeAddress(Y) {
  const X = computePublicKey(Y);
  return getAddress(hexDataSlice(keccak256(hexDataSlice(X, 1)), 12));
}
function recoverAddress(Y, X) {
  return computeAddress(recoverPublicKey(arrayify(Y), X));
}
function formatNumber(Y, X) {
  const ee = stripZeros(BigNumber.from(Y).toHexString());
  return ee.length > 32 && logger$6.throwArgumentError("invalid length for " + X, "transaction:" + X, Y), ee;
}
function accessSetify(Y, X) {
  return {
    address: getAddress(Y),
    storageKeys: (X || []).map((ee, te) => (hexDataLength(ee) !== 32 && logger$6.throwArgumentError("invalid access list storageKey", `accessList[${Y}:${te}]`, ee), ee.toLowerCase()))
  };
}
function accessListify(Y) {
  if (Array.isArray(Y))
    return Y.map((ee, te) => Array.isArray(ee) ? (ee.length > 2 && logger$6.throwArgumentError("access list expected to be [ address, storageKeys[] ]", `value[${te}]`, ee), accessSetify(ee[0], ee[1])) : accessSetify(ee.address, ee.storageKeys));
  const X = Object.keys(Y).map((ee) => {
    const te = Y[ee].reduce((ne, ie) => (ne[ie] = !0, ne), {});
    return accessSetify(ee, Object.keys(te).sort());
  });
  return X.sort((ee, te) => ee.address.localeCompare(te.address)), X;
}
function formatAccessList(Y) {
  return accessListify(Y).map((X) => [X.address, X.storageKeys]);
}
function _serializeEip1559(Y, X) {
  if (Y.gasPrice != null) {
    const te = BigNumber.from(Y.gasPrice), ne = BigNumber.from(Y.maxFeePerGas || 0);
    te.eq(ne) || logger$6.throwArgumentError("mismatch EIP-1559 gasPrice != maxFeePerGas", "tx", {
      gasPrice: te,
      maxFeePerGas: ne
    });
  }
  const ee = [
    formatNumber(Y.chainId || 0, "chainId"),
    formatNumber(Y.nonce || 0, "nonce"),
    formatNumber(Y.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
    formatNumber(Y.maxFeePerGas || 0, "maxFeePerGas"),
    formatNumber(Y.gasLimit || 0, "gasLimit"),
    Y.to != null ? getAddress(Y.to) : "0x",
    formatNumber(Y.value || 0, "value"),
    Y.data || "0x",
    formatAccessList(Y.accessList || [])
  ];
  if (X) {
    const te = splitSignature(X);
    ee.push(formatNumber(te.recoveryParam, "recoveryParam")), ee.push(stripZeros(te.r)), ee.push(stripZeros(te.s));
  }
  return hexConcat(["0x02", encode$2(ee)]);
}
function _serializeEip2930(Y, X) {
  const ee = [
    formatNumber(Y.chainId || 0, "chainId"),
    formatNumber(Y.nonce || 0, "nonce"),
    formatNumber(Y.gasPrice || 0, "gasPrice"),
    formatNumber(Y.gasLimit || 0, "gasLimit"),
    Y.to != null ? getAddress(Y.to) : "0x",
    formatNumber(Y.value || 0, "value"),
    Y.data || "0x",
    formatAccessList(Y.accessList || [])
  ];
  if (X) {
    const te = splitSignature(X);
    ee.push(formatNumber(te.recoveryParam, "recoveryParam")), ee.push(stripZeros(te.r)), ee.push(stripZeros(te.s));
  }
  return hexConcat(["0x01", encode$2(ee)]);
}
function _parseEipSignature(Y, X, ee) {
  try {
    const te = handleNumber(X[0]).toNumber();
    if (te !== 0 && te !== 1)
      throw new Error("bad recid");
    Y.v = te;
  } catch {
    logger$6.throwArgumentError("invalid v for transaction type: 1", "v", X[0]);
  }
  Y.r = hexZeroPad(X[1], 32), Y.s = hexZeroPad(X[2], 32);
  try {
    const te = keccak256(ee(Y));
    Y.from = recoverAddress(te, { r: Y.r, s: Y.s, recoveryParam: Y.v });
  } catch {
  }
}
function _parseEip1559(Y) {
  const X = decode$2(Y.slice(1));
  X.length !== 9 && X.length !== 12 && logger$6.throwArgumentError("invalid component count for transaction type: 2", "payload", hexlify(Y));
  const ee = handleNumber(X[2]), te = handleNumber(X[3]), ne = {
    type: 2,
    chainId: handleNumber(X[0]).toNumber(),
    nonce: handleNumber(X[1]).toNumber(),
    maxPriorityFeePerGas: ee,
    maxFeePerGas: te,
    gasPrice: null,
    gasLimit: handleNumber(X[4]),
    to: handleAddress(X[5]),
    value: handleNumber(X[6]),
    data: X[7],
    accessList: accessListify(X[8])
  };
  return X.length === 9 || (ne.hash = keccak256(Y), _parseEipSignature(ne, X.slice(9), _serializeEip1559)), ne;
}
function _parseEip2930(Y) {
  const X = decode$2(Y.slice(1));
  X.length !== 8 && X.length !== 11 && logger$6.throwArgumentError("invalid component count for transaction type: 1", "payload", hexlify(Y));
  const ee = {
    type: 1,
    chainId: handleNumber(X[0]).toNumber(),
    nonce: handleNumber(X[1]).toNumber(),
    gasPrice: handleNumber(X[2]),
    gasLimit: handleNumber(X[3]),
    to: handleAddress(X[4]),
    value: handleNumber(X[5]),
    data: X[6],
    accessList: accessListify(X[7])
  };
  return X.length === 8 || (ee.hash = keccak256(Y), _parseEipSignature(ee, X.slice(8), _serializeEip2930)), ee;
}
function _parse(Y) {
  const X = decode$2(Y);
  X.length !== 9 && X.length !== 6 && logger$6.throwArgumentError("invalid raw transaction", "rawTransaction", Y);
  const ee = {
    nonce: handleNumber(X[0]).toNumber(),
    gasPrice: handleNumber(X[1]),
    gasLimit: handleNumber(X[2]),
    to: handleAddress(X[3]),
    value: handleNumber(X[4]),
    data: X[5],
    chainId: 0
  };
  if (X.length === 6)
    return ee;
  try {
    ee.v = BigNumber.from(X[6]).toNumber();
  } catch {
    return ee;
  }
  if (ee.r = hexZeroPad(X[7], 32), ee.s = hexZeroPad(X[8], 32), BigNumber.from(ee.r).isZero() && BigNumber.from(ee.s).isZero())
    ee.chainId = ee.v, ee.v = 0;
  else {
    ee.chainId = Math.floor((ee.v - 35) / 2), ee.chainId < 0 && (ee.chainId = 0);
    let te = ee.v - 27;
    const ne = X.slice(0, 6);
    ee.chainId !== 0 && (ne.push(hexlify(ee.chainId)), ne.push("0x"), ne.push("0x"), te -= ee.chainId * 2 + 8);
    const ie = keccak256(encode$2(ne));
    try {
      ee.from = recoverAddress(ie, { r: hexlify(ee.r), s: hexlify(ee.s), recoveryParam: te });
    } catch {
    }
    ee.hash = keccak256(Y);
  }
  return ee.type = null, ee;
}
function parse$1(Y) {
  const X = arrayify(Y);
  if (X[0] > 127)
    return _parse(X);
  switch (X[0]) {
    case 1:
      return _parseEip2930(X);
    case 2:
      return _parseEip1559(X);
  }
  return logger$6.throwError(`unsupported transaction type: ${X[0]}`, Logger.errors.UNSUPPORTED_OPERATION, {
    operation: "parseTransaction",
    transactionType: X[0]
  });
}
const version$5 = "contracts/5.7.0";
var __awaiter$4 = function(Y, X, ee, te) {
  function ne(ie) {
    return ie instanceof ee ? ie : new ee(function(oe) {
      oe(ie);
    });
  }
  return new (ee || (ee = Promise))(function(ie, oe) {
    function se(le) {
      try {
        ue(te.next(le));
      } catch (he) {
        oe(he);
      }
    }
    function ae(le) {
      try {
        ue(te.throw(le));
      } catch (he) {
        oe(he);
      }
    }
    function ue(le) {
      le.done ? ie(le.value) : ne(le.value).then(se, ae);
    }
    ue((te = te.apply(Y, X || [])).next());
  });
};
const logger$5 = new Logger(version$5);
function resolveName(Y, X) {
  return __awaiter$4(this, void 0, void 0, function* () {
    const ee = yield X;
    typeof ee != "string" && logger$5.throwArgumentError("invalid address or ENS name", "name", ee);
    try {
      return getAddress(ee);
    } catch {
    }
    Y || logger$5.throwError("a provider or signer is needed to resolve ENS names", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "resolveName"
    });
    const te = yield Y.resolveName(ee);
    return te == null && logger$5.throwArgumentError("resolver or addr is not configured for ENS name", "name", ee), te;
  });
}
function resolveAddresses(Y, X, ee) {
  return __awaiter$4(this, void 0, void 0, function* () {
    return Array.isArray(ee) ? yield Promise.all(ee.map((te, ne) => resolveAddresses(Y, Array.isArray(X) ? X[ne] : X[te.name], te))) : ee.type === "address" ? yield resolveName(Y, X) : ee.type === "tuple" ? yield resolveAddresses(Y, X, ee.components) : ee.baseType === "array" ? Array.isArray(X) ? yield Promise.all(X.map((te) => resolveAddresses(Y, te, ee.arrayChildren))) : Promise.reject(logger$5.makeError("invalid value for array", Logger.errors.INVALID_ARGUMENT, {
      argument: "value",
      value: X
    })) : X;
  });
}
function populateTransaction(Y, X, ee) {
  return __awaiter$4(this, void 0, void 0, function* () {
    let te = {};
    ee.length === X.inputs.length + 1 && typeof ee[ee.length - 1] == "object" && (te = shallowCopy(ee.pop())), logger$5.checkArgumentCount(ee.length, X.inputs.length, "passed to contract"), Y.signer ? te.from ? te.from = resolveProperties({
      override: resolveName(Y.signer, te.from),
      signer: Y.signer.getAddress()
    }).then((ue) => __awaiter$4(this, void 0, void 0, function* () {
      return getAddress(ue.signer) !== ue.override && logger$5.throwError("Contract with a Signer cannot override from", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "overrides.from"
      }), ue.override;
    })) : te.from = Y.signer.getAddress() : te.from && (te.from = resolveName(Y.provider, te.from));
    const ne = yield resolveProperties({
      args: resolveAddresses(Y.signer || Y.provider, ee, X.inputs),
      address: Y.resolvedAddress,
      overrides: resolveProperties(te) || {}
    }), ie = Y.interface.encodeFunctionData(X, ne.args), oe = {
      data: ie,
      to: ne.address
    }, se = ne.overrides;
    if (se.nonce != null && (oe.nonce = BigNumber.from(se.nonce).toNumber()), se.gasLimit != null && (oe.gasLimit = BigNumber.from(se.gasLimit)), se.gasPrice != null && (oe.gasPrice = BigNumber.from(se.gasPrice)), se.maxFeePerGas != null && (oe.maxFeePerGas = BigNumber.from(se.maxFeePerGas)), se.maxPriorityFeePerGas != null && (oe.maxPriorityFeePerGas = BigNumber.from(se.maxPriorityFeePerGas)), se.from != null && (oe.from = se.from), se.type != null && (oe.type = se.type), se.accessList != null && (oe.accessList = accessListify(se.accessList)), oe.gasLimit == null && X.gas != null) {
      let ue = 21e3;
      const le = arrayify(ie);
      for (let he = 0; he < le.length; he++)
        ue += 4, le[he] && (ue += 64);
      oe.gasLimit = BigNumber.from(X.gas).add(ue);
    }
    if (se.value) {
      const ue = BigNumber.from(se.value);
      !ue.isZero() && !X.payable && logger$5.throwError("non-payable method cannot override value", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "overrides.value",
        value: te.value
      }), oe.value = ue;
    }
    se.customData && (oe.customData = shallowCopy(se.customData)), se.ccipReadEnabled && (oe.ccipReadEnabled = !!se.ccipReadEnabled), delete te.nonce, delete te.gasLimit, delete te.gasPrice, delete te.from, delete te.value, delete te.type, delete te.accessList, delete te.maxFeePerGas, delete te.maxPriorityFeePerGas, delete te.customData, delete te.ccipReadEnabled;
    const ae = Object.keys(te).filter((ue) => te[ue] != null);
    return ae.length && logger$5.throwError(`cannot override ${ae.map((ue) => JSON.stringify(ue)).join(",")}`, Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "overrides",
      overrides: ae
    }), oe;
  });
}
function buildPopulate(Y, X) {
  return function(...ee) {
    return populateTransaction(Y, X, ee);
  };
}
function buildEstimate(Y, X) {
  const ee = Y.signer || Y.provider;
  return function(...te) {
    return __awaiter$4(this, void 0, void 0, function* () {
      ee || logger$5.throwError("estimate require a provider or signer", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "estimateGas"
      });
      const ne = yield populateTransaction(Y, X, te);
      return yield ee.estimateGas(ne);
    });
  };
}
function addContractWait(Y, X) {
  const ee = X.wait.bind(X);
  X.wait = (te) => ee(te).then((ne) => (ne.events = ne.logs.map((ie) => {
    let oe = deepCopy(ie), se = null;
    try {
      se = Y.interface.parseLog(ie);
    } catch {
    }
    return se && (oe.args = se.args, oe.decode = (ae, ue) => Y.interface.decodeEventLog(se.eventFragment, ae, ue), oe.event = se.name, oe.eventSignature = se.signature), oe.removeListener = () => Y.provider, oe.getBlock = () => Y.provider.getBlock(ne.blockHash), oe.getTransaction = () => Y.provider.getTransaction(ne.transactionHash), oe.getTransactionReceipt = () => Promise.resolve(ne), oe;
  }), ne));
}
function buildCall(Y, X, ee) {
  const te = Y.signer || Y.provider;
  return function(...ne) {
    return __awaiter$4(this, void 0, void 0, function* () {
      let ie;
      if (ne.length === X.inputs.length + 1 && typeof ne[ne.length - 1] == "object") {
        const ae = shallowCopy(ne.pop());
        ae.blockTag != null && (ie = yield ae.blockTag), delete ae.blockTag, ne.push(ae);
      }
      Y.deployTransaction != null && (yield Y._deployed(ie));
      const oe = yield populateTransaction(Y, X, ne), se = yield te.call(oe, ie);
      try {
        let ae = Y.interface.decodeFunctionResult(X, se);
        return ee && X.outputs.length === 1 && (ae = ae[0]), ae;
      } catch (ae) {
        throw ae.code === Logger.errors.CALL_EXCEPTION && (ae.address = Y.address, ae.args = ne, ae.transaction = oe), ae;
      }
    });
  };
}
function buildSend(Y, X) {
  return function(...ee) {
    return __awaiter$4(this, void 0, void 0, function* () {
      Y.signer || logger$5.throwError("sending a transaction requires a signer", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "sendTransaction"
      }), Y.deployTransaction != null && (yield Y._deployed());
      const te = yield populateTransaction(Y, X, ee), ne = yield Y.signer.sendTransaction(te);
      return addContractWait(Y, ne), ne;
    });
  };
}
function buildDefault(Y, X, ee) {
  return X.constant ? buildCall(Y, X, ee) : buildSend(Y, X);
}
function getEventTag$1(Y) {
  return Y.address && (Y.topics == null || Y.topics.length === 0) ? "*" : (Y.address || "*") + "@" + (Y.topics ? Y.topics.map((X) => Array.isArray(X) ? X.join("|") : X).join(":") : "");
}
class RunningEvent {
  constructor(X, ee) {
    defineReadOnly(this, "tag", X), defineReadOnly(this, "filter", ee), this._listeners = [];
  }
  addListener(X, ee) {
    this._listeners.push({ listener: X, once: ee });
  }
  removeListener(X) {
    let ee = !1;
    this._listeners = this._listeners.filter((te) => ee || te.listener !== X ? !0 : (ee = !0, !1));
  }
  removeAllListeners() {
    this._listeners = [];
  }
  listeners() {
    return this._listeners.map((X) => X.listener);
  }
  listenerCount() {
    return this._listeners.length;
  }
  run(X) {
    const ee = this.listenerCount();
    return this._listeners = this._listeners.filter((te) => {
      const ne = X.slice();
      return setTimeout(() => {
        te.listener.apply(this, ne);
      }, 0), !te.once;
    }), ee;
  }
  prepareEvent(X) {
  }
  // Returns the array that will be applied to an emit
  getEmit(X) {
    return [X];
  }
}
class ErrorRunningEvent extends RunningEvent {
  constructor() {
    super("error", null);
  }
}
class FragmentRunningEvent extends RunningEvent {
  constructor(X, ee, te, ne) {
    const ie = {
      address: X
    };
    let oe = ee.getEventTopic(te);
    ne ? (oe !== ne[0] && logger$5.throwArgumentError("topic mismatch", "topics", ne), ie.topics = ne.slice()) : ie.topics = [oe], super(getEventTag$1(ie), ie), defineReadOnly(this, "address", X), defineReadOnly(this, "interface", ee), defineReadOnly(this, "fragment", te);
  }
  prepareEvent(X) {
    super.prepareEvent(X), X.event = this.fragment.name, X.eventSignature = this.fragment.format(), X.decode = (ee, te) => this.interface.decodeEventLog(this.fragment, ee, te);
    try {
      X.args = this.interface.decodeEventLog(this.fragment, X.data, X.topics);
    } catch (ee) {
      X.args = null, X.decodeError = ee;
    }
  }
  getEmit(X) {
    const ee = checkResultErrors(X.args);
    if (ee.length)
      throw ee[0].error;
    const te = (X.args || []).slice();
    return te.push(X), te;
  }
}
class WildcardRunningEvent extends RunningEvent {
  constructor(X, ee) {
    super("*", { address: X }), defineReadOnly(this, "address", X), defineReadOnly(this, "interface", ee);
  }
  prepareEvent(X) {
    super.prepareEvent(X);
    try {
      const ee = this.interface.parseLog(X);
      X.event = ee.name, X.eventSignature = ee.signature, X.decode = (te, ne) => this.interface.decodeEventLog(ee.eventFragment, te, ne), X.args = ee.args;
    } catch {
    }
  }
}
class BaseContract {
  constructor(X, ee, te) {
    defineReadOnly(this, "interface", getStatic(new.target, "getInterface")(ee)), te == null ? (defineReadOnly(this, "provider", null), defineReadOnly(this, "signer", null)) : Signer.isSigner(te) ? (defineReadOnly(this, "provider", te.provider || null), defineReadOnly(this, "signer", te)) : Provider.isProvider(te) ? (defineReadOnly(this, "provider", te), defineReadOnly(this, "signer", null)) : logger$5.throwArgumentError("invalid signer or provider", "signerOrProvider", te), defineReadOnly(this, "callStatic", {}), defineReadOnly(this, "estimateGas", {}), defineReadOnly(this, "functions", {}), defineReadOnly(this, "populateTransaction", {}), defineReadOnly(this, "filters", {});
    {
      const oe = {};
      Object.keys(this.interface.events).forEach((se) => {
        const ae = this.interface.events[se];
        defineReadOnly(this.filters, se, (...ue) => ({
          address: this.address,
          topics: this.interface.encodeFilterTopics(ae, ue)
        })), oe[ae.name] || (oe[ae.name] = []), oe[ae.name].push(se);
      }), Object.keys(oe).forEach((se) => {
        const ae = oe[se];
        ae.length === 1 ? defineReadOnly(this.filters, se, this.filters[ae[0]]) : logger$5.warn(`Duplicate definition of ${se} (${ae.join(", ")})`);
      });
    }
    if (defineReadOnly(this, "_runningEvents", {}), defineReadOnly(this, "_wrappedEmits", {}), X == null && logger$5.throwArgumentError("invalid contract address or ENS name", "addressOrName", X), defineReadOnly(this, "address", X), this.provider)
      defineReadOnly(this, "resolvedAddress", resolveName(this.provider, X));
    else
      try {
        defineReadOnly(this, "resolvedAddress", Promise.resolve(getAddress(X)));
      } catch {
        logger$5.throwError("provider is required to use ENS name as contract address", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "new Contract"
        });
      }
    this.resolvedAddress.catch((oe) => {
    });
    const ne = {}, ie = {};
    Object.keys(this.interface.functions).forEach((oe) => {
      const se = this.interface.functions[oe];
      if (ie[oe]) {
        logger$5.warn(`Duplicate ABI entry for ${JSON.stringify(oe)}`);
        return;
      }
      ie[oe] = !0;
      {
        const ae = se.name;
        ne[`%${ae}`] || (ne[`%${ae}`] = []), ne[`%${ae}`].push(oe);
      }
      this[oe] == null && defineReadOnly(this, oe, buildDefault(this, se, !0)), this.functions[oe] == null && defineReadOnly(this.functions, oe, buildDefault(this, se, !1)), this.callStatic[oe] == null && defineReadOnly(this.callStatic, oe, buildCall(this, se, !0)), this.populateTransaction[oe] == null && defineReadOnly(this.populateTransaction, oe, buildPopulate(this, se)), this.estimateGas[oe] == null && defineReadOnly(this.estimateGas, oe, buildEstimate(this, se));
    }), Object.keys(ne).forEach((oe) => {
      const se = ne[oe];
      if (se.length > 1)
        return;
      oe = oe.substring(1);
      const ae = se[0];
      try {
        this[oe] == null && defineReadOnly(this, oe, this[ae]);
      } catch {
      }
      this.functions[oe] == null && defineReadOnly(this.functions, oe, this.functions[ae]), this.callStatic[oe] == null && defineReadOnly(this.callStatic, oe, this.callStatic[ae]), this.populateTransaction[oe] == null && defineReadOnly(this.populateTransaction, oe, this.populateTransaction[ae]), this.estimateGas[oe] == null && defineReadOnly(this.estimateGas, oe, this.estimateGas[ae]);
    });
  }
  static getContractAddress(X) {
    return getContractAddress(X);
  }
  static getInterface(X) {
    return Interface.isInterface(X) ? X : new Interface(X);
  }
  // @TODO: Allow timeout?
  deployed() {
    return this._deployed();
  }
  _deployed(X) {
    return this._deployedPromise || (this.deployTransaction ? this._deployedPromise = this.deployTransaction.wait().then(() => this) : this._deployedPromise = this.provider.getCode(this.address, X).then((ee) => (ee === "0x" && logger$5.throwError("contract not deployed", Logger.errors.UNSUPPORTED_OPERATION, {
      contractAddress: this.address,
      operation: "getDeployed"
    }), this))), this._deployedPromise;
  }
  // @TODO:
  // estimateFallback(overrides?: TransactionRequest): Promise<BigNumber>
  // @TODO:
  // estimateDeploy(bytecode: string, ...args): Promise<BigNumber>
  fallback(X) {
    this.signer || logger$5.throwError("sending a transactions require a signer", Logger.errors.UNSUPPORTED_OPERATION, { operation: "sendTransaction(fallback)" });
    const ee = shallowCopy(X || {});
    return ["from", "to"].forEach(function(te) {
      ee[te] != null && logger$5.throwError("cannot override " + te, Logger.errors.UNSUPPORTED_OPERATION, { operation: te });
    }), ee.to = this.resolvedAddress, this.deployed().then(() => this.signer.sendTransaction(ee));
  }
  // Reconnect to a different signer or provider
  connect(X) {
    typeof X == "string" && (X = new VoidSigner(X, this.provider));
    const ee = new this.constructor(this.address, this.interface, X);
    return this.deployTransaction && defineReadOnly(ee, "deployTransaction", this.deployTransaction), ee;
  }
  // Re-attach to a different on-chain instance of this contract
  attach(X) {
    return new this.constructor(X, this.interface, this.signer || this.provider);
  }
  static isIndexed(X) {
    return Indexed.isIndexed(X);
  }
  _normalizeRunningEvent(X) {
    return this._runningEvents[X.tag] ? this._runningEvents[X.tag] : X;
  }
  _getRunningEvent(X) {
    if (typeof X == "string") {
      if (X === "error")
        return this._normalizeRunningEvent(new ErrorRunningEvent());
      if (X === "event")
        return this._normalizeRunningEvent(new RunningEvent("event", null));
      if (X === "*")
        return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));
      const ee = this.interface.getEvent(X);
      return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, ee));
    }
    if (X.topics && X.topics.length > 0) {
      try {
        const te = X.topics[0];
        if (typeof te != "string")
          throw new Error("invalid topic");
        const ne = this.interface.getEvent(te);
        return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, ne, X.topics));
      } catch {
      }
      const ee = {
        address: this.address,
        topics: X.topics
      };
      return this._normalizeRunningEvent(new RunningEvent(getEventTag$1(ee), ee));
    }
    return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));
  }
  _checkRunningEvents(X) {
    if (X.listenerCount() === 0) {
      delete this._runningEvents[X.tag];
      const ee = this._wrappedEmits[X.tag];
      ee && X.filter && (this.provider.off(X.filter, ee), delete this._wrappedEmits[X.tag]);
    }
  }
  // Subclasses can override this to gracefully recover
  // from parse errors if they wish
  _wrapEvent(X, ee, te) {
    const ne = deepCopy(ee);
    return ne.removeListener = () => {
      te && (X.removeListener(te), this._checkRunningEvents(X));
    }, ne.getBlock = () => this.provider.getBlock(ee.blockHash), ne.getTransaction = () => this.provider.getTransaction(ee.transactionHash), ne.getTransactionReceipt = () => this.provider.getTransactionReceipt(ee.transactionHash), X.prepareEvent(ne), ne;
  }
  _addEventListener(X, ee, te) {
    if (this.provider || logger$5.throwError("events require a provider or a signer with a provider", Logger.errors.UNSUPPORTED_OPERATION, { operation: "once" }), X.addListener(ee, te), this._runningEvents[X.tag] = X, !this._wrappedEmits[X.tag]) {
      const ne = (ie) => {
        let oe = this._wrapEvent(X, ie, ee);
        if (oe.decodeError == null)
          try {
            const se = X.getEmit(oe);
            this.emit(X.filter, ...se);
          } catch (se) {
            oe.decodeError = se.error;
          }
        X.filter != null && this.emit("event", oe), oe.decodeError != null && this.emit("error", oe.decodeError, oe);
      };
      this._wrappedEmits[X.tag] = ne, X.filter != null && this.provider.on(X.filter, ne);
    }
  }
  queryFilter(X, ee, te) {
    const ne = this._getRunningEvent(X), ie = shallowCopy(ne.filter);
    return typeof ee == "string" && isHexString(ee, 32) ? (te != null && logger$5.throwArgumentError("cannot specify toBlock with blockhash", "toBlock", te), ie.blockHash = ee) : (ie.fromBlock = ee ?? 0, ie.toBlock = te ?? "latest"), this.provider.getLogs(ie).then((oe) => oe.map((se) => this._wrapEvent(ne, se, null)));
  }
  on(X, ee) {
    return this._addEventListener(this._getRunningEvent(X), ee, !1), this;
  }
  once(X, ee) {
    return this._addEventListener(this._getRunningEvent(X), ee, !0), this;
  }
  emit(X, ...ee) {
    if (!this.provider)
      return !1;
    const te = this._getRunningEvent(X), ne = te.run(ee) > 0;
    return this._checkRunningEvents(te), ne;
  }
  listenerCount(X) {
    return this.provider ? X == null ? Object.keys(this._runningEvents).reduce((ee, te) => ee + this._runningEvents[te].listenerCount(), 0) : this._getRunningEvent(X).listenerCount() : 0;
  }
  listeners(X) {
    if (!this.provider)
      return [];
    if (X == null) {
      const ee = [];
      for (let te in this._runningEvents)
        this._runningEvents[te].listeners().forEach((ne) => {
          ee.push(ne);
        });
      return ee;
    }
    return this._getRunningEvent(X).listeners();
  }
  removeAllListeners(X) {
    if (!this.provider)
      return this;
    if (X == null) {
      for (const te in this._runningEvents) {
        const ne = this._runningEvents[te];
        ne.removeAllListeners(), this._checkRunningEvents(ne);
      }
      return this;
    }
    const ee = this._getRunningEvent(X);
    return ee.removeAllListeners(), this._checkRunningEvents(ee), this;
  }
  off(X, ee) {
    if (!this.provider)
      return this;
    const te = this._getRunningEvent(X);
    return te.removeListener(ee), this._checkRunningEvents(te), this;
  }
  removeListener(X, ee) {
    return this.off(X, ee);
  }
}
class Contract extends BaseContract {
}
class BaseX {
  constructor(X) {
    defineReadOnly(this, "alphabet", X), defineReadOnly(this, "base", X.length), defineReadOnly(this, "_alphabetMap", {}), defineReadOnly(this, "_leader", X.charAt(0));
    for (let ee = 0; ee < X.length; ee++)
      this._alphabetMap[X.charAt(ee)] = ee;
  }
  encode(X) {
    let ee = arrayify(X);
    if (ee.length === 0)
      return "";
    let te = [0];
    for (let ie = 0; ie < ee.length; ++ie) {
      let oe = ee[ie];
      for (let se = 0; se < te.length; ++se)
        oe += te[se] << 8, te[se] = oe % this.base, oe = oe / this.base | 0;
      for (; oe > 0; )
        te.push(oe % this.base), oe = oe / this.base | 0;
    }
    let ne = "";
    for (let ie = 0; ee[ie] === 0 && ie < ee.length - 1; ++ie)
      ne += this._leader;
    for (let ie = te.length - 1; ie >= 0; --ie)
      ne += this.alphabet[te[ie]];
    return ne;
  }
  decode(X) {
    if (typeof X != "string")
      throw new TypeError("Expected String");
    let ee = [];
    if (X.length === 0)
      return new Uint8Array(ee);
    ee.push(0);
    for (let te = 0; te < X.length; te++) {
      let ne = this._alphabetMap[X[te]];
      if (ne === void 0)
        throw new Error("Non-base" + this.base + " character");
      let ie = ne;
      for (let oe = 0; oe < ee.length; ++oe)
        ie += ee[oe] * this.base, ee[oe] = ie & 255, ie >>= 8;
      for (; ie > 0; )
        ee.push(ie & 255), ie >>= 8;
    }
    for (let te = 0; X[te] === this._leader && te < X.length - 1; ++te)
      ee.push(0);
    return arrayify(new Uint8Array(ee.reverse()));
  }
}
new BaseX("abcdefghijklmnopqrstuvwxyz234567");
const Base58 = new BaseX("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
function sha256$4(Y) {
  return "0x" + hash$4.sha256().update(arrayify(Y)).digest("hex");
}
const version$4 = "networks/5.7.1", logger$4 = new Logger(version$4);
function isRenetworkable(Y) {
  return Y && typeof Y.renetwork == "function";
}
function ethDefaultProvider(Y) {
  const X = function(ee, te) {
    te == null && (te = {});
    const ne = [];
    if (ee.InfuraProvider && te.infura !== "-")
      try {
        ne.push(new ee.InfuraProvider(Y, te.infura));
      } catch {
      }
    if (ee.EtherscanProvider && te.etherscan !== "-")
      try {
        ne.push(new ee.EtherscanProvider(Y, te.etherscan));
      } catch {
      }
    if (ee.AlchemyProvider && te.alchemy !== "-")
      try {
        ne.push(new ee.AlchemyProvider(Y, te.alchemy));
      } catch {
      }
    if (ee.PocketProvider && te.pocket !== "-") {
      const ie = ["goerli", "ropsten", "rinkeby", "sepolia"];
      try {
        const oe = new ee.PocketProvider(Y, te.pocket);
        oe.network && ie.indexOf(oe.network.name) === -1 && ne.push(oe);
      } catch {
      }
    }
    if (ee.CloudflareProvider && te.cloudflare !== "-")
      try {
        ne.push(new ee.CloudflareProvider(Y));
      } catch {
      }
    if (ee.AnkrProvider && te.ankr !== "-")
      try {
        const ie = ["ropsten"], oe = new ee.AnkrProvider(Y, te.ankr);
        oe.network && ie.indexOf(oe.network.name) === -1 && ne.push(oe);
      } catch {
      }
    if (ne.length === 0)
      return null;
    if (ee.FallbackProvider) {
      let ie = 1;
      return te.quorum != null ? ie = te.quorum : Y === "homestead" && (ie = 2), new ee.FallbackProvider(ne, ie);
    }
    return ne[0];
  };
  return X.renetwork = function(ee) {
    return ethDefaultProvider(ee);
  }, X;
}
function etcDefaultProvider(Y, X) {
  const ee = function(te, ne) {
    return te.JsonRpcProvider ? new te.JsonRpcProvider(Y, X) : null;
  };
  return ee.renetwork = function(te) {
    return etcDefaultProvider(Y, te);
  }, ee;
}
const homestead = {
  chainId: 1,
  ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
  name: "homestead",
  _defaultProvider: ethDefaultProvider("homestead")
}, ropsten = {
  chainId: 3,
  ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
  name: "ropsten",
  _defaultProvider: ethDefaultProvider("ropsten")
}, classicMordor = {
  chainId: 63,
  name: "classicMordor",
  _defaultProvider: etcDefaultProvider("https://www.ethercluster.com/mordor", "classicMordor")
}, networks = {
  unspecified: { chainId: 0, name: "unspecified" },
  homestead,
  mainnet: homestead,
  morden: { chainId: 2, name: "morden" },
  ropsten,
  testnet: ropsten,
  rinkeby: {
    chainId: 4,
    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
    name: "rinkeby",
    _defaultProvider: ethDefaultProvider("rinkeby")
  },
  kovan: {
    chainId: 42,
    name: "kovan",
    _defaultProvider: ethDefaultProvider("kovan")
  },
  goerli: {
    chainId: 5,
    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
    name: "goerli",
    _defaultProvider: ethDefaultProvider("goerli")
  },
  kintsugi: { chainId: 1337702, name: "kintsugi" },
  sepolia: {
    chainId: 11155111,
    name: "sepolia",
    _defaultProvider: ethDefaultProvider("sepolia")
  },
  // ETC (See: #351)
  classic: {
    chainId: 61,
    name: "classic",
    _defaultProvider: etcDefaultProvider("https://www.ethercluster.com/etc", "classic")
  },
  classicMorden: { chainId: 62, name: "classicMorden" },
  classicMordor,
  classicTestnet: classicMordor,
  classicKotti: {
    chainId: 6,
    name: "classicKotti",
    _defaultProvider: etcDefaultProvider("https://www.ethercluster.com/kotti", "classicKotti")
  },
  xdai: { chainId: 100, name: "xdai" },
  matic: {
    chainId: 137,
    name: "matic",
    _defaultProvider: ethDefaultProvider("matic")
  },
  maticmum: { chainId: 80001, name: "maticmum" },
  optimism: {
    chainId: 10,
    name: "optimism",
    _defaultProvider: ethDefaultProvider("optimism")
  },
  "optimism-kovan": { chainId: 69, name: "optimism-kovan" },
  "optimism-goerli": { chainId: 420, name: "optimism-goerli" },
  arbitrum: { chainId: 42161, name: "arbitrum" },
  "arbitrum-rinkeby": { chainId: 421611, name: "arbitrum-rinkeby" },
  "arbitrum-goerli": { chainId: 421613, name: "arbitrum-goerli" },
  bnb: { chainId: 56, name: "bnb" },
  bnbt: { chainId: 97, name: "bnbt" }
};
function getNetwork(Y) {
  if (Y == null)
    return null;
  if (typeof Y == "number") {
    for (const te in networks) {
      const ne = networks[te];
      if (ne.chainId === Y)
        return {
          name: ne.name,
          chainId: ne.chainId,
          ensAddress: ne.ensAddress || null,
          _defaultProvider: ne._defaultProvider || null
        };
    }
    return {
      chainId: Y,
      name: "unknown"
    };
  }
  if (typeof Y == "string") {
    const te = networks[Y];
    return te == null ? null : {
      name: te.name,
      chainId: te.chainId,
      ensAddress: te.ensAddress,
      _defaultProvider: te._defaultProvider || null
    };
  }
  const X = networks[Y.name];
  if (!X)
    return typeof Y.chainId != "number" && logger$4.throwArgumentError("invalid network chainId", "network", Y), Y;
  Y.chainId !== 0 && Y.chainId !== X.chainId && logger$4.throwArgumentError("network chainId mismatch", "network", Y);
  let ee = Y._defaultProvider || null;
  return ee == null && X._defaultProvider && (isRenetworkable(X._defaultProvider) ? ee = X._defaultProvider.renetwork(Y) : ee = X._defaultProvider), {
    name: Y.name,
    chainId: X.chainId,
    ensAddress: Y.ensAddress || X.ensAddress || null,
    _defaultProvider: ee
  };
}
const version$3 = "web/5.7.1";
var __awaiter$3 = function(Y, X, ee, te) {
  function ne(ie) {
    return ie instanceof ee ? ie : new ee(function(oe) {
      oe(ie);
    });
  }
  return new (ee || (ee = Promise))(function(ie, oe) {
    function se(le) {
      try {
        ue(te.next(le));
      } catch (he) {
        oe(he);
      }
    }
    function ae(le) {
      try {
        ue(te.throw(le));
      } catch (he) {
        oe(he);
      }
    }
    function ue(le) {
      le.done ? ie(le.value) : ne(le.value).then(se, ae);
    }
    ue((te = te.apply(Y, X || [])).next());
  });
};
function getUrl(Y, X) {
  return __awaiter$3(this, void 0, void 0, function* () {
    X == null && (X = {});
    const ee = {
      method: X.method || "GET",
      headers: X.headers || {},
      body: X.body || void 0
    };
    if (X.skipFetchSetup !== !0 && (ee.mode = "cors", ee.cache = "no-cache", ee.credentials = "same-origin", ee.redirect = "follow", ee.referrer = "client"), X.fetchOptions != null) {
      const oe = X.fetchOptions;
      oe.mode && (ee.mode = oe.mode), oe.cache && (ee.cache = oe.cache), oe.credentials && (ee.credentials = oe.credentials), oe.redirect && (ee.redirect = oe.redirect), oe.referrer && (ee.referrer = oe.referrer);
    }
    const te = yield fetch(Y, ee), ne = yield te.arrayBuffer(), ie = {};
    return te.headers.forEach ? te.headers.forEach((oe, se) => {
      ie[se.toLowerCase()] = oe;
    }) : te.headers.keys().forEach((oe) => {
      ie[oe.toLowerCase()] = te.headers.get(oe);
    }), {
      headers: ie,
      statusCode: te.status,
      statusMessage: te.statusText,
      body: arrayify(new Uint8Array(ne))
    };
  });
}
var __awaiter$2 = function(Y, X, ee, te) {
  function ne(ie) {
    return ie instanceof ee ? ie : new ee(function(oe) {
      oe(ie);
    });
  }
  return new (ee || (ee = Promise))(function(ie, oe) {
    function se(le) {
      try {
        ue(te.next(le));
      } catch (he) {
        oe(he);
      }
    }
    function ae(le) {
      try {
        ue(te.throw(le));
      } catch (he) {
        oe(he);
      }
    }
    function ue(le) {
      le.done ? ie(le.value) : ne(le.value).then(se, ae);
    }
    ue((te = te.apply(Y, X || [])).next());
  });
};
const logger$3 = new Logger(version$3);
function staller(Y) {
  return new Promise((X) => {
    setTimeout(X, Y);
  });
}
function bodyify(Y, X) {
  if (Y == null)
    return null;
  if (typeof Y == "string")
    return Y;
  if (isBytesLike(Y)) {
    if (X && (X.split("/")[0] === "text" || X.split(";")[0].trim() === "application/json"))
      try {
        return toUtf8String(Y);
      } catch {
      }
    return hexlify(Y);
  }
  return Y;
}
function unpercent(Y) {
  return toUtf8Bytes(Y.replace(/%([0-9a-f][0-9a-f])/gi, (X, ee) => String.fromCharCode(parseInt(ee, 16))));
}
function _fetchData(Y, X, ee) {
  const te = typeof Y == "object" && Y.throttleLimit != null ? Y.throttleLimit : 12;
  logger$3.assertArgument(te > 0 && te % 1 === 0, "invalid connection throttle limit", "connection.throttleLimit", te);
  const ne = typeof Y == "object" ? Y.throttleCallback : null, ie = typeof Y == "object" && typeof Y.throttleSlotInterval == "number" ? Y.throttleSlotInterval : 100;
  logger$3.assertArgument(ie > 0 && ie % 1 === 0, "invalid connection throttle slot interval", "connection.throttleSlotInterval", ie);
  const oe = typeof Y == "object" ? !!Y.errorPassThrough : !1, se = {};
  let ae = null;
  const ue = {
    method: "GET"
  };
  let le = !1, he = 2 * 60 * 1e3;
  if (typeof Y == "string")
    ae = Y;
  else if (typeof Y == "object") {
    if ((Y == null || Y.url == null) && logger$3.throwArgumentError("missing URL", "connection.url", Y), ae = Y.url, typeof Y.timeout == "number" && Y.timeout > 0 && (he = Y.timeout), Y.headers)
      for (const Ue in Y.headers)
        se[Ue.toLowerCase()] = { key: Ue, value: String(Y.headers[Ue]) }, ["if-none-match", "if-modified-since"].indexOf(Ue.toLowerCase()) >= 0 && (le = !0);
    if (ue.allowGzip = !!Y.allowGzip, Y.user != null && Y.password != null) {
      ae.substring(0, 6) !== "https:" && Y.allowInsecureAuthentication !== !0 && logger$3.throwError("basic authentication requires a secure https url", Logger.errors.INVALID_ARGUMENT, { argument: "url", url: ae, user: Y.user, password: "[REDACTED]" });
      const Ue = Y.user + ":" + Y.password;
      se.authorization = {
        key: "Authorization",
        value: "Basic " + encode$1(toUtf8Bytes(Ue))
      };
    }
    Y.skipFetchSetup != null && (ue.skipFetchSetup = !!Y.skipFetchSetup), Y.fetchOptions != null && (ue.fetchOptions = shallowCopy(Y.fetchOptions));
  }
  const me = new RegExp("^data:([^;:]*)?(;base64)?,(.*)$", "i"), ye = ae ? ae.match(me) : null;
  if (ye)
    try {
      const Ue = {
        statusCode: 200,
        statusMessage: "OK",
        headers: { "content-type": ye[1] || "text/plain" },
        body: ye[2] ? decode$1(ye[3]) : unpercent(ye[3])
      };
      let Me = Ue.body;
      return ee && (Me = ee(Ue.body, Ue)), Promise.resolve(Me);
    } catch (Ue) {
      logger$3.throwError("processing response error", Logger.errors.SERVER_ERROR, {
        body: bodyify(ye[1], ye[2]),
        error: Ue,
        requestBody: null,
        requestMethod: "GET",
        url: ae
      });
    }
  X && (ue.method = "POST", ue.body = X, se["content-type"] == null && (se["content-type"] = { key: "Content-Type", value: "application/octet-stream" }), se["content-length"] == null && (se["content-length"] = { key: "Content-Length", value: String(X.length) }));
  const we = {};
  Object.keys(se).forEach((Ue) => {
    const Me = se[Ue];
    we[Me.key] = Me.value;
  }), ue.headers = we;
  const Ee = function() {
    let Ue = null;
    return { promise: new Promise(function(Me, De) {
      he && (Ue = setTimeout(() => {
        Ue != null && (Ue = null, De(logger$3.makeError("timeout", Logger.errors.TIMEOUT, {
          requestBody: bodyify(ue.body, we["content-type"]),
          requestMethod: ue.method,
          timeout: he,
          url: ae
        })));
      }, he));
    }), cancel: function() {
      Ue != null && (clearTimeout(Ue), Ue = null);
    } };
  }(), Re = function() {
    return __awaiter$2(this, void 0, void 0, function* () {
      for (let Ue = 0; Ue < te; Ue++) {
        let Me = null;
        try {
          if (Me = yield getUrl(ae, ue), Ue < te) {
            if (Me.statusCode === 301 || Me.statusCode === 302) {
              const Fe = Me.headers.location || "";
              if (ue.method === "GET" && Fe.match(/^https:/)) {
                ae = Me.headers.location;
                continue;
              }
            } else if (Me.statusCode === 429) {
              let Fe = !0;
              if (ne && (Fe = yield ne(Ue, ae)), Fe) {
                let Ke = 0;
                const tt = Me.headers["retry-after"];
                typeof tt == "string" && tt.match(/^[1-9][0-9]*$/) ? Ke = parseInt(tt) * 1e3 : Ke = ie * parseInt(String(Math.random() * Math.pow(2, Ue))), yield staller(Ke);
                continue;
              }
            }
          }
        } catch (Fe) {
          Me = Fe.response, Me == null && (Ee.cancel(), logger$3.throwError("missing response", Logger.errors.SERVER_ERROR, {
            requestBody: bodyify(ue.body, we["content-type"]),
            requestMethod: ue.method,
            serverError: Fe,
            url: ae
          }));
        }
        let De = Me.body;
        if (le && Me.statusCode === 304 ? De = null : !oe && (Me.statusCode < 200 || Me.statusCode >= 300) && (Ee.cancel(), logger$3.throwError("bad response", Logger.errors.SERVER_ERROR, {
          status: Me.statusCode,
          headers: Me.headers,
          body: bodyify(De, Me.headers ? Me.headers["content-type"] : null),
          requestBody: bodyify(ue.body, we["content-type"]),
          requestMethod: ue.method,
          url: ae
        })), ee)
          try {
            const Fe = yield ee(De, Me);
            return Ee.cancel(), Fe;
          } catch (Fe) {
            if (Fe.throttleRetry && Ue < te) {
              let Ke = !0;
              if (ne && (Ke = yield ne(Ue, ae)), Ke) {
                const tt = ie * parseInt(String(Math.random() * Math.pow(2, Ue)));
                yield staller(tt);
                continue;
              }
            }
            Ee.cancel(), logger$3.throwError("processing response error", Logger.errors.SERVER_ERROR, {
              body: bodyify(De, Me.headers ? Me.headers["content-type"] : null),
              error: Fe,
              requestBody: bodyify(ue.body, we["content-type"]),
              requestMethod: ue.method,
              url: ae
            });
          }
        return Ee.cancel(), De;
      }
      return logger$3.throwError("failed response", Logger.errors.SERVER_ERROR, {
        requestBody: bodyify(ue.body, we["content-type"]),
        requestMethod: ue.method,
        url: ae
      });
    });
  }();
  return Promise.race([Ee.promise, Re]);
}
function fetchJson(Y, X, ee) {
  let te = (ie, oe) => {
    let se = null;
    if (ie != null)
      try {
        se = JSON.parse(toUtf8String(ie));
      } catch (ae) {
        logger$3.throwError("invalid JSON", Logger.errors.SERVER_ERROR, {
          body: ie,
          error: ae
        });
      }
    return ee && (se = ee(se, oe)), se;
  }, ne = null;
  if (X != null) {
    ne = toUtf8Bytes(X);
    const ie = typeof Y == "string" ? { url: Y } : shallowCopy(Y);
    ie.headers ? Object.keys(ie.headers).filter((oe) => oe.toLowerCase() === "content-type").length !== 0 || (ie.headers = shallowCopy(ie.headers), ie.headers["content-type"] = "application/json") : ie.headers = { "content-type": "application/json" }, Y = ie;
  }
  return _fetchData(Y, ne, te);
}
function poll(Y, X) {
  return X || (X = {}), X = shallowCopy(X), X.floor == null && (X.floor = 0), X.ceiling == null && (X.ceiling = 1e4), X.interval == null && (X.interval = 250), new Promise(function(ee, te) {
    let ne = null, ie = !1;
    const oe = () => ie ? !1 : (ie = !0, ne && clearTimeout(ne), !0);
    X.timeout && (ne = setTimeout(() => {
      oe() && te(new Error("timeout"));
    }, X.timeout));
    const se = X.retryLimit;
    let ae = 0;
    function ue() {
      return Y().then(function(le) {
        if (le !== void 0)
          oe() && ee(le);
        else if (X.oncePoll)
          X.oncePoll.once("poll", ue);
        else if (X.onceBlock)
          X.onceBlock.once("block", ue);
        else if (!ie) {
          if (ae++, ae > se) {
            oe() && te(new Error("retry limit reached"));
            return;
          }
          let he = X.interval * parseInt(String(Math.random() * Math.pow(2, ae)));
          he < X.floor && (he = X.floor), he > X.ceiling && (he = X.ceiling), setTimeout(ue, he);
        }
        return null;
      }, function(le) {
        oe() && te(le);
      });
    }
    ue();
  });
}
var ALPHABET$2 = "qpzry9x8gf2tvdw0s3jn54khce6mua7l", ALPHABET_MAP = {};
for (var z = 0; z < ALPHABET$2.length; z++) {
  var x = ALPHABET$2.charAt(z);
  if (ALPHABET_MAP[x] !== void 0)
    throw new TypeError(x + " is ambiguous");
  ALPHABET_MAP[x] = z;
}
function polymodStep(Y) {
  var X = Y >> 25;
  return (Y & 33554431) << 5 ^ -(X >> 0 & 1) & 996825010 ^ -(X >> 1 & 1) & 642813549 ^ -(X >> 2 & 1) & 513874426 ^ -(X >> 3 & 1) & 1027748829 ^ -(X >> 4 & 1) & 705979059;
}
function prefixChk(Y) {
  for (var X = 1, ee = 0; ee < Y.length; ++ee) {
    var te = Y.charCodeAt(ee);
    if (te < 33 || te > 126)
      return "Invalid prefix (" + Y + ")";
    X = polymodStep(X) ^ te >> 5;
  }
  for (X = polymodStep(X), ee = 0; ee < Y.length; ++ee) {
    var ne = Y.charCodeAt(ee);
    X = polymodStep(X) ^ ne & 31;
  }
  return X;
}
function encode(Y, X, ee) {
  if (ee = ee || 90, Y.length + 7 + X.length > ee)
    throw new TypeError("Exceeds length limit");
  Y = Y.toLowerCase();
  var te = prefixChk(Y);
  if (typeof te == "string")
    throw new Error(te);
  for (var ne = Y + "1", ie = 0; ie < X.length; ++ie) {
    var oe = X[ie];
    if (oe >> 5)
      throw new Error("Non 5-bit word");
    te = polymodStep(te) ^ oe, ne += ALPHABET$2.charAt(oe);
  }
  for (ie = 0; ie < 6; ++ie)
    te = polymodStep(te);
  for (te ^= 1, ie = 0; ie < 6; ++ie) {
    var se = te >> (5 - ie) * 5 & 31;
    ne += ALPHABET$2.charAt(se);
  }
  return ne;
}
function __decode(Y, X) {
  if (X = X || 90, Y.length < 8)
    return Y + " too short";
  if (Y.length > X)
    return "Exceeds length limit";
  var ee = Y.toLowerCase(), te = Y.toUpperCase();
  if (Y !== ee && Y !== te)
    return "Mixed-case string " + Y;
  Y = ee;
  var ne = Y.lastIndexOf("1");
  if (ne === -1)
    return "No separator character for " + Y;
  if (ne === 0)
    return "Missing prefix for " + Y;
  var ie = Y.slice(0, ne), oe = Y.slice(ne + 1);
  if (oe.length < 6)
    return "Data too short";
  var se = prefixChk(ie);
  if (typeof se == "string")
    return se;
  for (var ae = [], ue = 0; ue < oe.length; ++ue) {
    var le = oe.charAt(ue), he = ALPHABET_MAP[le];
    if (he === void 0)
      return "Unknown character " + le;
    se = polymodStep(se) ^ he, !(ue + 6 >= oe.length) && ae.push(he);
  }
  return se !== 1 ? "Invalid checksum for " + Y : { prefix: ie, words: ae };
}
function decodeUnsafe() {
  var Y = __decode.apply(null, arguments);
  if (typeof Y == "object")
    return Y;
}
function decode(Y) {
  var X = __decode.apply(null, arguments);
  if (typeof X == "object")
    return X;
  throw new Error(X);
}
function convert(Y, X, ee, te) {
  for (var ne = 0, ie = 0, oe = (1 << ee) - 1, se = [], ae = 0; ae < Y.length; ++ae)
    for (ne = ne << X | Y[ae], ie += X; ie >= ee; )
      ie -= ee, se.push(ne >> ie & oe);
  if (te)
    ie > 0 && se.push(ne << ee - ie & oe);
  else {
    if (ie >= X)
      return "Excess padding";
    if (ne << ee - ie & oe)
      return "Non-zero padding";
  }
  return se;
}
function toWordsUnsafe(Y) {
  var X = convert(Y, 8, 5, !0);
  if (Array.isArray(X))
    return X;
}
function toWords(Y) {
  var X = convert(Y, 8, 5, !0);
  if (Array.isArray(X))
    return X;
  throw new Error(X);
}
function fromWordsUnsafe(Y) {
  var X = convert(Y, 5, 8, !1);
  if (Array.isArray(X))
    return X;
}
function fromWords(Y) {
  var X = convert(Y, 5, 8, !1);
  if (Array.isArray(X))
    return X;
  throw new Error(X);
}
var bech32 = {
  decodeUnsafe,
  decode,
  encode,
  toWordsUnsafe,
  toWords,
  fromWordsUnsafe,
  fromWords
};
const bech32$1 = /* @__PURE__ */ getDefaultExportFromCjs$3(bech32), version$2 = "providers/5.7.2", logger$2 = new Logger(version$2);
class Formatter {
  constructor() {
    this.formats = this.getDefaultFormats();
  }
  getDefaultFormats() {
    const X = {}, ee = this.address.bind(this), te = this.bigNumber.bind(this), ne = this.blockTag.bind(this), ie = this.data.bind(this), oe = this.hash.bind(this), se = this.hex.bind(this), ae = this.number.bind(this), ue = this.type.bind(this), le = (he) => this.data(he, !0);
    return X.transaction = {
      hash: oe,
      type: ue,
      accessList: Formatter.allowNull(this.accessList.bind(this), null),
      blockHash: Formatter.allowNull(oe, null),
      blockNumber: Formatter.allowNull(ae, null),
      transactionIndex: Formatter.allowNull(ae, null),
      confirmations: Formatter.allowNull(ae, null),
      from: ee,
      // either (gasPrice) or (maxPriorityFeePerGas + maxFeePerGas)
      // must be set
      gasPrice: Formatter.allowNull(te),
      maxPriorityFeePerGas: Formatter.allowNull(te),
      maxFeePerGas: Formatter.allowNull(te),
      gasLimit: te,
      to: Formatter.allowNull(ee, null),
      value: te,
      nonce: ae,
      data: ie,
      r: Formatter.allowNull(this.uint256),
      s: Formatter.allowNull(this.uint256),
      v: Formatter.allowNull(ae),
      creates: Formatter.allowNull(ee, null),
      raw: Formatter.allowNull(ie)
    }, X.transactionRequest = {
      from: Formatter.allowNull(ee),
      nonce: Formatter.allowNull(ae),
      gasLimit: Formatter.allowNull(te),
      gasPrice: Formatter.allowNull(te),
      maxPriorityFeePerGas: Formatter.allowNull(te),
      maxFeePerGas: Formatter.allowNull(te),
      to: Formatter.allowNull(ee),
      value: Formatter.allowNull(te),
      data: Formatter.allowNull(le),
      type: Formatter.allowNull(ae),
      accessList: Formatter.allowNull(this.accessList.bind(this), null)
    }, X.receiptLog = {
      transactionIndex: ae,
      blockNumber: ae,
      transactionHash: oe,
      address: ee,
      topics: Formatter.arrayOf(oe),
      data: ie,
      logIndex: ae,
      blockHash: oe
    }, X.receipt = {
      to: Formatter.allowNull(this.address, null),
      from: Formatter.allowNull(this.address, null),
      contractAddress: Formatter.allowNull(ee, null),
      transactionIndex: ae,
      // should be allowNull(hash), but broken-EIP-658 support is handled in receipt
      root: Formatter.allowNull(se),
      gasUsed: te,
      logsBloom: Formatter.allowNull(ie),
      blockHash: oe,
      transactionHash: oe,
      logs: Formatter.arrayOf(this.receiptLog.bind(this)),
      blockNumber: ae,
      confirmations: Formatter.allowNull(ae, null),
      cumulativeGasUsed: te,
      effectiveGasPrice: Formatter.allowNull(te),
      status: Formatter.allowNull(ae),
      type: ue
    }, X.block = {
      hash: Formatter.allowNull(oe),
      parentHash: oe,
      number: ae,
      timestamp: ae,
      nonce: Formatter.allowNull(se),
      difficulty: this.difficulty.bind(this),
      gasLimit: te,
      gasUsed: te,
      miner: Formatter.allowNull(ee),
      extraData: ie,
      transactions: Formatter.allowNull(Formatter.arrayOf(oe)),
      baseFeePerGas: Formatter.allowNull(te)
    }, X.blockWithTransactions = shallowCopy(X.block), X.blockWithTransactions.transactions = Formatter.allowNull(Formatter.arrayOf(this.transactionResponse.bind(this))), X.filter = {
      fromBlock: Formatter.allowNull(ne, void 0),
      toBlock: Formatter.allowNull(ne, void 0),
      blockHash: Formatter.allowNull(oe, void 0),
      address: Formatter.allowNull(ee, void 0),
      topics: Formatter.allowNull(this.topics.bind(this), void 0)
    }, X.filterLog = {
      blockNumber: Formatter.allowNull(ae),
      blockHash: Formatter.allowNull(oe),
      transactionIndex: ae,
      removed: Formatter.allowNull(this.boolean.bind(this)),
      address: ee,
      data: Formatter.allowFalsish(ie, "0x"),
      topics: Formatter.arrayOf(oe),
      transactionHash: oe,
      logIndex: ae
    }, X;
  }
  accessList(X) {
    return accessListify(X || []);
  }
  // Requires a BigNumberish that is within the IEEE754 safe integer range; returns a number
  // Strict! Used on input.
  number(X) {
    return X === "0x" ? 0 : BigNumber.from(X).toNumber();
  }
  type(X) {
    return X === "0x" || X == null ? 0 : BigNumber.from(X).toNumber();
  }
  // Strict! Used on input.
  bigNumber(X) {
    return BigNumber.from(X);
  }
  // Requires a boolean, "true" or  "false"; returns a boolean
  boolean(X) {
    if (typeof X == "boolean")
      return X;
    if (typeof X == "string") {
      if (X = X.toLowerCase(), X === "true")
        return !0;
      if (X === "false")
        return !1;
    }
    throw new Error("invalid boolean - " + X);
  }
  hex(X, ee) {
    return typeof X == "string" && (!ee && X.substring(0, 2) !== "0x" && (X = "0x" + X), isHexString(X)) ? X.toLowerCase() : logger$2.throwArgumentError("invalid hash", "value", X);
  }
  data(X, ee) {
    const te = this.hex(X, ee);
    if (te.length % 2 !== 0)
      throw new Error("invalid data; odd-length - " + X);
    return te;
  }
  // Requires an address
  // Strict! Used on input.
  address(X) {
    return getAddress(X);
  }
  callAddress(X) {
    if (!isHexString(X, 32))
      return null;
    const ee = getAddress(hexDataSlice(X, 12));
    return ee === AddressZero ? null : ee;
  }
  contractAddress(X) {
    return getContractAddress(X);
  }
  // Strict! Used on input.
  blockTag(X) {
    if (X == null)
      return "latest";
    if (X === "earliest")
      return "0x0";
    switch (X) {
      case "earliest":
        return "0x0";
      case "latest":
      case "pending":
      case "safe":
      case "finalized":
        return X;
    }
    if (typeof X == "number" || isHexString(X))
      return hexValue(X);
    throw new Error("invalid blockTag");
  }
  // Requires a hash, optionally requires 0x prefix; returns prefixed lowercase hash.
  hash(X, ee) {
    const te = this.hex(X, ee);
    return hexDataLength(te) !== 32 ? logger$2.throwArgumentError("invalid hash", "value", X) : te;
  }
  // Returns the difficulty as a number, or if too large (i.e. PoA network) null
  difficulty(X) {
    if (X == null)
      return null;
    const ee = BigNumber.from(X);
    try {
      return ee.toNumber();
    } catch {
    }
    return null;
  }
  uint256(X) {
    if (!isHexString(X))
      throw new Error("invalid uint256");
    return hexZeroPad(X, 32);
  }
  _block(X, ee) {
    X.author != null && X.miner == null && (X.miner = X.author);
    const te = X._difficulty != null ? X._difficulty : X.difficulty, ne = Formatter.check(ee, X);
    return ne._difficulty = te == null ? null : BigNumber.from(te), ne;
  }
  block(X) {
    return this._block(X, this.formats.block);
  }
  blockWithTransactions(X) {
    return this._block(X, this.formats.blockWithTransactions);
  }
  // Strict! Used on input.
  transactionRequest(X) {
    return Formatter.check(this.formats.transactionRequest, X);
  }
  transactionResponse(X) {
    X.gas != null && X.gasLimit == null && (X.gasLimit = X.gas), X.to && BigNumber.from(X.to).isZero() && (X.to = "0x0000000000000000000000000000000000000000"), X.input != null && X.data == null && (X.data = X.input), X.to == null && X.creates == null && (X.creates = this.contractAddress(X)), (X.type === 1 || X.type === 2) && X.accessList == null && (X.accessList = []);
    const ee = Formatter.check(this.formats.transaction, X);
    if (X.chainId != null) {
      let te = X.chainId;
      isHexString(te) && (te = BigNumber.from(te).toNumber()), ee.chainId = te;
    } else {
      let te = X.networkId;
      te == null && ee.v == null && (te = X.chainId), isHexString(te) && (te = BigNumber.from(te).toNumber()), typeof te != "number" && ee.v != null && (te = (ee.v - 35) / 2, te < 0 && (te = 0), te = parseInt(te)), typeof te != "number" && (te = 0), ee.chainId = te;
    }
    return ee.blockHash && ee.blockHash.replace(/0/g, "") === "x" && (ee.blockHash = null), ee;
  }
  transaction(X) {
    return parse$1(X);
  }
  receiptLog(X) {
    return Formatter.check(this.formats.receiptLog, X);
  }
  receipt(X) {
    const ee = Formatter.check(this.formats.receipt, X);
    if (ee.root != null)
      if (ee.root.length <= 4) {
        const te = BigNumber.from(ee.root).toNumber();
        te === 0 || te === 1 ? (ee.status != null && ee.status !== te && logger$2.throwArgumentError("alt-root-status/status mismatch", "value", { root: ee.root, status: ee.status }), ee.status = te, delete ee.root) : logger$2.throwArgumentError("invalid alt-root-status", "value.root", ee.root);
      } else
        ee.root.length !== 66 && logger$2.throwArgumentError("invalid root hash", "value.root", ee.root);
    return ee.status != null && (ee.byzantium = !0), ee;
  }
  topics(X) {
    return Array.isArray(X) ? X.map((ee) => this.topics(ee)) : X != null ? this.hash(X, !0) : null;
  }
  filter(X) {
    return Formatter.check(this.formats.filter, X);
  }
  filterLog(X) {
    return Formatter.check(this.formats.filterLog, X);
  }
  static check(X, ee) {
    const te = {};
    for (const ne in X)
      try {
        const ie = X[ne](ee[ne]);
        ie !== void 0 && (te[ne] = ie);
      } catch (ie) {
        throw ie.checkKey = ne, ie.checkValue = ee[ne], ie;
      }
    return te;
  }
  // if value is null-ish, nullValue is returned
  static allowNull(X, ee) {
    return function(te) {
      return te == null ? ee : X(te);
    };
  }
  // If value is false-ish, replaceValue is returned
  static allowFalsish(X, ee) {
    return function(te) {
      return te ? X(te) : ee;
    };
  }
  // Requires an Array satisfying check
  static arrayOf(X) {
    return function(ee) {
      if (!Array.isArray(ee))
        throw new Error("not an array");
      const te = [];
      return ee.forEach(function(ne) {
        te.push(X(ne));
      }), te;
    };
  }
}
var __awaiter$1 = function(Y, X, ee, te) {
  function ne(ie) {
    return ie instanceof ee ? ie : new ee(function(oe) {
      oe(ie);
    });
  }
  return new (ee || (ee = Promise))(function(ie, oe) {
    function se(le) {
      try {
        ue(te.next(le));
      } catch (he) {
        oe(he);
      }
    }
    function ae(le) {
      try {
        ue(te.throw(le));
      } catch (he) {
        oe(he);
      }
    }
    function ue(le) {
      le.done ? ie(le.value) : ne(le.value).then(se, ae);
    }
    ue((te = te.apply(Y, X || [])).next());
  });
};
const logger$1 = new Logger(version$2), MAX_CCIP_REDIRECTS = 10;
function checkTopic(Y) {
  return Y == null ? "null" : (hexDataLength(Y) !== 32 && logger$1.throwArgumentError("invalid topic", "topic", Y), Y.toLowerCase());
}
function serializeTopics(Y) {
  for (Y = Y.slice(); Y.length > 0 && Y[Y.length - 1] == null; )
    Y.pop();
  return Y.map((X) => {
    if (Array.isArray(X)) {
      const ee = {};
      X.forEach((ne) => {
        ee[checkTopic(ne)] = !0;
      });
      const te = Object.keys(ee);
      return te.sort(), te.join("|");
    } else
      return checkTopic(X);
  }).join("&");
}
function deserializeTopics(Y) {
  return Y === "" ? [] : Y.split(/&/g).map((X) => {
    if (X === "")
      return [];
    const ee = X.split("|").map((te) => te === "null" ? null : te);
    return ee.length === 1 ? ee[0] : ee;
  });
}
function getEventTag(Y) {
  if (typeof Y == "string") {
    if (Y = Y.toLowerCase(), hexDataLength(Y) === 32)
      return "tx:" + Y;
    if (Y.indexOf(":") === -1)
      return Y;
  } else {
    if (Array.isArray(Y))
      return "filter:*:" + serializeTopics(Y);
    if (ForkEvent.isForkEvent(Y))
      throw logger$1.warn("not implemented"), new Error("not implemented");
    if (Y && typeof Y == "object")
      return "filter:" + (Y.address || "*") + ":" + serializeTopics(Y.topics || []);
  }
  throw new Error("invalid event - " + Y);
}
function getTime() {
  return (/* @__PURE__ */ new Date()).getTime();
}
function stall(Y) {
  return new Promise((X) => {
    setTimeout(X, Y);
  });
}
const PollableEvents = ["block", "network", "pending", "poll"];
let Event$1 = class {
  constructor(Y, X, ee) {
    defineReadOnly(this, "tag", Y), defineReadOnly(this, "listener", X), defineReadOnly(this, "once", ee), this._lastBlockNumber = -2, this._inflight = !1;
  }
  get event() {
    switch (this.type) {
      case "tx":
        return this.hash;
      case "filter":
        return this.filter;
    }
    return this.tag;
  }
  get type() {
    return this.tag.split(":")[0];
  }
  get hash() {
    const Y = this.tag.split(":");
    return Y[0] !== "tx" ? null : Y[1];
  }
  get filter() {
    const Y = this.tag.split(":");
    if (Y[0] !== "filter")
      return null;
    const X = Y[1], ee = deserializeTopics(Y[2]), te = {};
    return ee.length > 0 && (te.topics = ee), X && X !== "*" && (te.address = X), te;
  }
  pollable() {
    return this.tag.indexOf(":") >= 0 || PollableEvents.indexOf(this.tag) >= 0;
  }
};
const coinInfos = {
  0: { symbol: "btc", p2pkh: 0, p2sh: 5, prefix: "bc" },
  2: { symbol: "ltc", p2pkh: 48, p2sh: 50, prefix: "ltc" },
  3: { symbol: "doge", p2pkh: 30, p2sh: 22 },
  60: { symbol: "eth", ilk: "eth" },
  61: { symbol: "etc", ilk: "eth" },
  700: { symbol: "xdai", ilk: "eth" }
};
function bytes32ify(Y) {
  return hexZeroPad(BigNumber.from(Y).toHexString(), 32);
}
function base58Encode(Y) {
  return Base58.encode(concat([Y, hexDataSlice(sha256$4(sha256$4(Y)), 0, 4)]));
}
const matcherIpfs = new RegExp("^(ipfs)://(.*)$", "i"), matchers = [
  new RegExp("^(https)://(.*)$", "i"),
  new RegExp("^(data):(.*)$", "i"),
  matcherIpfs,
  new RegExp("^eip155:[0-9]+/(erc[0-9]+):(.*)$", "i")
];
function _parseString(Y, X) {
  try {
    return toUtf8String(_parseBytes(Y, X));
  } catch {
  }
  return null;
}
function _parseBytes(Y, X) {
  if (Y === "0x")
    return null;
  const ee = BigNumber.from(hexDataSlice(Y, X, X + 32)).toNumber(), te = BigNumber.from(hexDataSlice(Y, ee, ee + 32)).toNumber();
  return hexDataSlice(Y, ee + 32, ee + 32 + te);
}
function getIpfsLink(Y) {
  return Y.match(/^ipfs:\/\/ipfs\//i) ? Y = Y.substring(12) : Y.match(/^ipfs:\/\//i) ? Y = Y.substring(7) : logger$1.throwArgumentError("unsupported IPFS format", "link", Y), `https://gateway.ipfs.io/ipfs/${Y}`;
}
function numPad(Y) {
  const X = arrayify(Y);
  if (X.length > 32)
    throw new Error("internal; should not happen");
  const ee = new Uint8Array(32);
  return ee.set(X, 32 - X.length), ee;
}
function bytesPad(Y) {
  if (Y.length % 32 === 0)
    return Y;
  const X = new Uint8Array(Math.ceil(Y.length / 32) * 32);
  return X.set(Y), X;
}
function encodeBytes(Y) {
  const X = [];
  let ee = 0;
  for (let te = 0; te < Y.length; te++)
    X.push(null), ee += 32;
  for (let te = 0; te < Y.length; te++) {
    const ne = arrayify(Y[te]);
    X[te] = numPad(ee), X.push(numPad(ne.length)), X.push(bytesPad(ne)), ee += 32 + Math.ceil(ne.length / 32) * 32;
  }
  return hexConcat(X);
}
class Resolver {
  // The resolvedAddress is only for creating a ReverseLookup resolver
  constructor(X, ee, te, ne) {
    defineReadOnly(this, "provider", X), defineReadOnly(this, "name", te), defineReadOnly(this, "address", X.formatter.address(ee)), defineReadOnly(this, "_resolvedAddress", ne);
  }
  supportsWildcard() {
    return this._supportsEip2544 || (this._supportsEip2544 = this.provider.call({
      to: this.address,
      data: "0x01ffc9a79061b92300000000000000000000000000000000000000000000000000000000"
    }).then((X) => BigNumber.from(X).eq(1)).catch((X) => {
      if (X.code === Logger.errors.CALL_EXCEPTION)
        return !1;
      throw this._supportsEip2544 = null, X;
    })), this._supportsEip2544;
  }
  _fetch(X, ee) {
    return __awaiter$1(this, void 0, void 0, function* () {
      const te = {
        to: this.address,
        ccipReadEnabled: !0,
        data: hexConcat([X, namehash(this.name), ee || "0x"])
      };
      let ne = !1;
      (yield this.supportsWildcard()) && (ne = !0, te.data = hexConcat(["0x9061b923", encodeBytes([dnsEncode(this.name), te.data])]));
      try {
        let ie = yield this.provider.call(te);
        return arrayify(ie).length % 32 === 4 && logger$1.throwError("resolver threw error", Logger.errors.CALL_EXCEPTION, {
          transaction: te,
          data: ie
        }), ne && (ie = _parseBytes(ie, 0)), ie;
      } catch (ie) {
        if (ie.code === Logger.errors.CALL_EXCEPTION)
          return null;
        throw ie;
      }
    });
  }
  _fetchBytes(X, ee) {
    return __awaiter$1(this, void 0, void 0, function* () {
      const te = yield this._fetch(X, ee);
      return te != null ? _parseBytes(te, 0) : null;
    });
  }
  _getAddress(X, ee) {
    const te = coinInfos[String(X)];
    if (te == null && logger$1.throwError(`unsupported coin type: ${X}`, Logger.errors.UNSUPPORTED_OPERATION, {
      operation: `getAddress(${X})`
    }), te.ilk === "eth")
      return this.provider.formatter.address(ee);
    const ne = arrayify(ee);
    if (te.p2pkh != null) {
      const ie = ee.match(/^0x76a9([0-9a-f][0-9a-f])([0-9a-f]*)88ac$/);
      if (ie) {
        const oe = parseInt(ie[1], 16);
        if (ie[2].length === oe * 2 && oe >= 1 && oe <= 75)
          return base58Encode(concat([[te.p2pkh], "0x" + ie[2]]));
      }
    }
    if (te.p2sh != null) {
      const ie = ee.match(/^0xa9([0-9a-f][0-9a-f])([0-9a-f]*)87$/);
      if (ie) {
        const oe = parseInt(ie[1], 16);
        if (ie[2].length === oe * 2 && oe >= 1 && oe <= 75)
          return base58Encode(concat([[te.p2sh], "0x" + ie[2]]));
      }
    }
    if (te.prefix != null) {
      const ie = ne[1];
      let oe = ne[0];
      if (oe === 0 ? ie !== 20 && ie !== 32 && (oe = -1) : oe = -1, oe >= 0 && ne.length === 2 + ie && ie >= 1 && ie <= 75) {
        const se = bech32$1.toWords(ne.slice(2));
        return se.unshift(oe), bech32$1.encode(te.prefix, se);
      }
    }
    return null;
  }
  getAddress(X) {
    return __awaiter$1(this, void 0, void 0, function* () {
      if (X == null && (X = 60), X === 60)
        try {
          const ne = yield this._fetch("0x3b3b57de");
          return ne === "0x" || ne === HashZero ? null : this.provider.formatter.callAddress(ne);
        } catch (ne) {
          if (ne.code === Logger.errors.CALL_EXCEPTION)
            return null;
          throw ne;
        }
      const ee = yield this._fetchBytes("0xf1cb7e06", bytes32ify(X));
      if (ee == null || ee === "0x")
        return null;
      const te = this._getAddress(X, ee);
      return te == null && logger$1.throwError("invalid or unsupported coin data", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: `getAddress(${X})`,
        coinType: X,
        data: ee
      }), te;
    });
  }
  getAvatar() {
    return __awaiter$1(this, void 0, void 0, function* () {
      const X = [{ type: "name", content: this.name }];
      try {
        const ee = yield this.getText("avatar");
        if (ee == null)
          return null;
        for (let te = 0; te < matchers.length; te++) {
          const ne = ee.match(matchers[te]);
          if (ne == null)
            continue;
          const ie = ne[1].toLowerCase();
          switch (ie) {
            case "https":
              return X.push({ type: "url", content: ee }), { linkage: X, url: ee };
            case "data":
              return X.push({ type: "data", content: ee }), { linkage: X, url: ee };
            case "ipfs":
              return X.push({ type: "ipfs", content: ee }), { linkage: X, url: getIpfsLink(ee) };
            case "erc721":
            case "erc1155": {
              const oe = ie === "erc721" ? "0xc87b56dd" : "0x0e89341c";
              X.push({ type: ie, content: ee });
              const se = this._resolvedAddress || (yield this.getAddress()), ae = (ne[2] || "").split("/");
              if (ae.length !== 2)
                return null;
              const ue = yield this.provider.formatter.address(ae[0]), le = hexZeroPad(BigNumber.from(ae[1]).toHexString(), 32);
              if (ie === "erc721") {
                const Ee = this.provider.formatter.callAddress(yield this.provider.call({
                  to: ue,
                  data: hexConcat(["0x6352211e", le])
                }));
                if (se !== Ee)
                  return null;
                X.push({ type: "owner", content: Ee });
              } else if (ie === "erc1155") {
                const Ee = BigNumber.from(yield this.provider.call({
                  to: ue,
                  data: hexConcat(["0x00fdd58e", hexZeroPad(se, 32), le])
                }));
                if (Ee.isZero())
                  return null;
                X.push({ type: "balance", content: Ee.toString() });
              }
              const he = {
                to: this.provider.formatter.address(ae[0]),
                data: hexConcat([oe, le])
              };
              let me = _parseString(yield this.provider.call(he), 0);
              if (me == null)
                return null;
              X.push({ type: "metadata-url-base", content: me }), ie === "erc1155" && (me = me.replace("{id}", le.substring(2)), X.push({ type: "metadata-url-expanded", content: me })), me.match(/^ipfs:/i) && (me = getIpfsLink(me)), X.push({ type: "metadata-url", content: me });
              const ye = yield fetchJson(me);
              if (!ye)
                return null;
              X.push({ type: "metadata", content: JSON.stringify(ye) });
              let we = ye.image;
              if (typeof we != "string")
                return null;
              if (!we.match(/^(https:\/\/|data:)/i)) {
                if (we.match(matcherIpfs) == null)
                  return null;
                X.push({ type: "url-ipfs", content: we }), we = getIpfsLink(we);
              }
              return X.push({ type: "url", content: we }), { linkage: X, url: we };
            }
          }
        }
      } catch {
      }
      return null;
    });
  }
  getContentHash() {
    return __awaiter$1(this, void 0, void 0, function* () {
      const X = yield this._fetchBytes("0xbc1c58d1");
      if (X == null || X === "0x")
        return null;
      const ee = X.match(/^0xe3010170(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
      if (ee) {
        const oe = parseInt(ee[3], 16);
        if (ee[4].length === oe * 2)
          return "ipfs://" + Base58.encode("0x" + ee[1]);
      }
      const te = X.match(/^0xe5010172(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
      if (te) {
        const oe = parseInt(te[3], 16);
        if (te[4].length === oe * 2)
          return "ipns://" + Base58.encode("0x" + te[1]);
      }
      const ne = X.match(/^0xe40101fa011b20([0-9a-f]*)$/);
      if (ne && ne[1].length === 32 * 2)
        return "bzz://" + ne[1];
      const ie = X.match(/^0x90b2c605([0-9a-f]*)$/);
      if (ie && ie[1].length === 34 * 2) {
        const oe = { "=": "", "+": "-", "/": "_" };
        return "sia://" + encode$1("0x" + ie[1]).replace(/[=+\/]/g, (se) => oe[se]);
      }
      return logger$1.throwError("invalid or unsupported content hash data", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "getContentHash()",
        data: X
      });
    });
  }
  getText(X) {
    return __awaiter$1(this, void 0, void 0, function* () {
      let ee = toUtf8Bytes(X);
      ee = concat([bytes32ify(64), bytes32ify(ee.length), ee]), ee.length % 32 !== 0 && (ee = concat([ee, hexZeroPad("0x", 32 - X.length % 32)]));
      const te = yield this._fetchBytes("0x59d1d43c", hexlify(ee));
      return te == null || te === "0x" ? null : toUtf8String(te);
    });
  }
}
let defaultFormatter = null, nextPollId = 1;
class BaseProvider extends Provider {
  /**
   *  ready
   *
   *  A Promise<Network> that resolves only once the provider is ready.
   *
   *  Sub-classes that call the super with a network without a chainId
   *  MUST set this. Standard named networks have a known chainId.
   *
   */
  constructor(X) {
    if (super(), this._events = [], this._emitted = { block: -2 }, this.disableCcipRead = !1, this.formatter = new.target.getFormatter(), defineReadOnly(this, "anyNetwork", X === "any"), this.anyNetwork && (X = this.detectNetwork()), X instanceof Promise)
      this._networkPromise = X, X.catch((ee) => {
      }), this._ready().catch((ee) => {
      });
    else {
      const ee = getStatic(new.target, "getNetwork")(X);
      ee ? (defineReadOnly(this, "_network", ee), this.emit("network", ee, null)) : logger$1.throwArgumentError("invalid network", "network", X);
    }
    this._maxInternalBlockNumber = -1024, this._lastBlockNumber = -2, this._maxFilterBlockRange = 10, this._pollingInterval = 4e3, this._fastQueryDate = 0;
  }
  _ready() {
    return __awaiter$1(this, void 0, void 0, function* () {
      if (this._network == null) {
        let X = null;
        if (this._networkPromise)
          try {
            X = yield this._networkPromise;
          } catch {
          }
        X == null && (X = yield this.detectNetwork()), X || logger$1.throwError("no network detected", Logger.errors.UNKNOWN_ERROR, {}), this._network == null && (this.anyNetwork ? this._network = X : defineReadOnly(this, "_network", X), this.emit("network", X, null));
      }
      return this._network;
    });
  }
  // This will always return the most recently established network.
  // For "any", this can change (a "network" event is emitted before
  // any change is reflected); otherwise this cannot change
  get ready() {
    return poll(() => this._ready().then((X) => X, (X) => {
      if (!(X.code === Logger.errors.NETWORK_ERROR && X.event === "noNetwork"))
        throw X;
    }));
  }
  // @TODO: Remove this and just create a singleton formatter
  static getFormatter() {
    return defaultFormatter == null && (defaultFormatter = new Formatter()), defaultFormatter;
  }
  // @TODO: Remove this and just use getNetwork
  static getNetwork(X) {
    return getNetwork(X ?? "homestead");
  }
  ccipReadFetch(X, ee, te) {
    return __awaiter$1(this, void 0, void 0, function* () {
      if (this.disableCcipRead || te.length === 0)
        return null;
      const ne = X.to.toLowerCase(), ie = ee.toLowerCase(), oe = [];
      for (let se = 0; se < te.length; se++) {
        const ae = te[se], ue = ae.replace("{sender}", ne).replace("{data}", ie), le = ae.indexOf("{data}") >= 0 ? null : JSON.stringify({ data: ie, sender: ne }), he = yield fetchJson({ url: ue, errorPassThrough: !0 }, le, (ye, we) => (ye.status = we.statusCode, ye));
        if (he.data)
          return he.data;
        const me = he.message || "unknown error";
        if (he.status >= 400 && he.status < 500)
          return logger$1.throwError(`response not found during CCIP fetch: ${me}`, Logger.errors.SERVER_ERROR, { url: ae, errorMessage: me });
        oe.push(me);
      }
      return logger$1.throwError(`error encountered during CCIP fetch: ${oe.map((se) => JSON.stringify(se)).join(", ")}`, Logger.errors.SERVER_ERROR, {
        urls: te,
        errorMessages: oe
      });
    });
  }
  // Fetches the blockNumber, but will reuse any result that is less
  // than maxAge old or has been requested since the last request
  _getInternalBlockNumber(X) {
    return __awaiter$1(this, void 0, void 0, function* () {
      if (yield this._ready(), X > 0)
        for (; this._internalBlockNumber; ) {
          const ne = this._internalBlockNumber;
          try {
            const ie = yield ne;
            if (getTime() - ie.respTime <= X)
              return ie.blockNumber;
            break;
          } catch {
            if (this._internalBlockNumber === ne)
              break;
          }
        }
      const ee = getTime(), te = resolveProperties({
        blockNumber: this.perform("getBlockNumber", {}),
        networkError: this.getNetwork().then((ne) => null, (ne) => ne)
      }).then(({ blockNumber: ne, networkError: ie }) => {
        if (ie)
          throw this._internalBlockNumber === te && (this._internalBlockNumber = null), ie;
        const oe = getTime();
        return ne = BigNumber.from(ne).toNumber(), ne < this._maxInternalBlockNumber && (ne = this._maxInternalBlockNumber), this._maxInternalBlockNumber = ne, this._setFastBlockNumber(ne), { blockNumber: ne, reqTime: ee, respTime: oe };
      });
      return this._internalBlockNumber = te, te.catch((ne) => {
        this._internalBlockNumber === te && (this._internalBlockNumber = null);
      }), (yield te).blockNumber;
    });
  }
  poll() {
    return __awaiter$1(this, void 0, void 0, function* () {
      const X = nextPollId++, ee = [];
      let te = null;
      try {
        te = yield this._getInternalBlockNumber(100 + this.pollingInterval / 2);
      } catch (ne) {
        this.emit("error", ne);
        return;
      }
      if (this._setFastBlockNumber(te), this.emit("poll", X, te), te === this._lastBlockNumber) {
        this.emit("didPoll", X);
        return;
      }
      if (this._emitted.block === -2 && (this._emitted.block = te - 1), Math.abs(this._emitted.block - te) > 1e3)
        logger$1.warn(`network block skew detected; skipping block events (emitted=${this._emitted.block} blockNumber${te})`), this.emit("error", logger$1.makeError("network block skew detected", Logger.errors.NETWORK_ERROR, {
          blockNumber: te,
          event: "blockSkew",
          previousBlockNumber: this._emitted.block
        })), this.emit("block", te);
      else
        for (let ne = this._emitted.block + 1; ne <= te; ne++)
          this.emit("block", ne);
      this._emitted.block !== te && (this._emitted.block = te, Object.keys(this._emitted).forEach((ne) => {
        if (ne === "block")
          return;
        const ie = this._emitted[ne];
        ie !== "pending" && te - ie > 12 && delete this._emitted[ne];
      })), this._lastBlockNumber === -2 && (this._lastBlockNumber = te - 1), this._events.forEach((ne) => {
        switch (ne.type) {
          case "tx": {
            const ie = ne.hash;
            let oe = this.getTransactionReceipt(ie).then((se) => (!se || se.blockNumber == null || (this._emitted["t:" + ie] = se.blockNumber, this.emit(ie, se)), null)).catch((se) => {
              this.emit("error", se);
            });
            ee.push(oe);
            break;
          }
          case "filter": {
            if (!ne._inflight) {
              ne._inflight = !0, ne._lastBlockNumber === -2 && (ne._lastBlockNumber = te - 1);
              const ie = ne.filter;
              ie.fromBlock = ne._lastBlockNumber + 1, ie.toBlock = te;
              const oe = ie.toBlock - this._maxFilterBlockRange;
              oe > ie.fromBlock && (ie.fromBlock = oe), ie.fromBlock < 0 && (ie.fromBlock = 0);
              const se = this.getLogs(ie).then((ae) => {
                ne._inflight = !1, ae.length !== 0 && ae.forEach((ue) => {
                  ue.blockNumber > ne._lastBlockNumber && (ne._lastBlockNumber = ue.blockNumber), this._emitted["b:" + ue.blockHash] = ue.blockNumber, this._emitted["t:" + ue.transactionHash] = ue.blockNumber, this.emit(ie, ue);
                });
              }).catch((ae) => {
                this.emit("error", ae), ne._inflight = !1;
              });
              ee.push(se);
            }
            break;
          }
        }
      }), this._lastBlockNumber = te, Promise.all(ee).then(() => {
        this.emit("didPoll", X);
      }).catch((ne) => {
        this.emit("error", ne);
      });
    });
  }
  // Deprecated; do not use this
  resetEventsBlock(X) {
    this._lastBlockNumber = X - 1, this.polling && this.poll();
  }
  get network() {
    return this._network;
  }
  // This method should query the network if the underlying network
  // can change, such as when connected to a JSON-RPC backend
  detectNetwork() {
    return __awaiter$1(this, void 0, void 0, function* () {
      return logger$1.throwError("provider does not support network detection", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "provider.detectNetwork"
      });
    });
  }
  getNetwork() {
    return __awaiter$1(this, void 0, void 0, function* () {
      const X = yield this._ready(), ee = yield this.detectNetwork();
      if (X.chainId !== ee.chainId) {
        if (this.anyNetwork)
          return this._network = ee, this._lastBlockNumber = -2, this._fastBlockNumber = null, this._fastBlockNumberPromise = null, this._fastQueryDate = 0, this._emitted.block = -2, this._maxInternalBlockNumber = -1024, this._internalBlockNumber = null, this.emit("network", ee, X), yield stall(0), this._network;
        const te = logger$1.makeError("underlying network changed", Logger.errors.NETWORK_ERROR, {
          event: "changed",
          network: X,
          detectedNetwork: ee
        });
        throw this.emit("error", te), te;
      }
      return X;
    });
  }
  get blockNumber() {
    return this._getInternalBlockNumber(100 + this.pollingInterval / 2).then((X) => {
      this._setFastBlockNumber(X);
    }, (X) => {
    }), this._fastBlockNumber != null ? this._fastBlockNumber : -1;
  }
  get polling() {
    return this._poller != null;
  }
  set polling(X) {
    X && !this._poller ? (this._poller = setInterval(() => {
      this.poll();
    }, this.pollingInterval), this._bootstrapPoll || (this._bootstrapPoll = setTimeout(() => {
      this.poll(), this._bootstrapPoll = setTimeout(() => {
        this._poller || this.poll(), this._bootstrapPoll = null;
      }, this.pollingInterval);
    }, 0))) : !X && this._poller && (clearInterval(this._poller), this._poller = null);
  }
  get pollingInterval() {
    return this._pollingInterval;
  }
  set pollingInterval(X) {
    if (typeof X != "number" || X <= 0 || parseInt(String(X)) != X)
      throw new Error("invalid polling interval");
    this._pollingInterval = X, this._poller && (clearInterval(this._poller), this._poller = setInterval(() => {
      this.poll();
    }, this._pollingInterval));
  }
  _getFastBlockNumber() {
    const X = getTime();
    return X - this._fastQueryDate > 2 * this._pollingInterval && (this._fastQueryDate = X, this._fastBlockNumberPromise = this.getBlockNumber().then((ee) => ((this._fastBlockNumber == null || ee > this._fastBlockNumber) && (this._fastBlockNumber = ee), this._fastBlockNumber))), this._fastBlockNumberPromise;
  }
  _setFastBlockNumber(X) {
    this._fastBlockNumber != null && X < this._fastBlockNumber || (this._fastQueryDate = getTime(), (this._fastBlockNumber == null || X > this._fastBlockNumber) && (this._fastBlockNumber = X, this._fastBlockNumberPromise = Promise.resolve(X)));
  }
  waitForTransaction(X, ee, te) {
    return __awaiter$1(this, void 0, void 0, function* () {
      return this._waitForTransaction(X, ee ?? 1, te || 0, null);
    });
  }
  _waitForTransaction(X, ee, te, ne) {
    return __awaiter$1(this, void 0, void 0, function* () {
      const ie = yield this.getTransactionReceipt(X);
      return (ie ? ie.confirmations : 0) >= ee ? ie : new Promise((oe, se) => {
        const ae = [];
        let ue = !1;
        const le = function() {
          return ue ? !0 : (ue = !0, ae.forEach((me) => {
            me();
          }), !1);
        }, he = (me) => {
          me.confirmations < ee || le() || oe(me);
        };
        if (this.on(X, he), ae.push(() => {
          this.removeListener(X, he);
        }), ne) {
          let me = ne.startBlock, ye = null;
          const we = (Ee) => __awaiter$1(this, void 0, void 0, function* () {
            ue || (yield stall(1e3), this.getTransactionCount(ne.from).then((Re) => __awaiter$1(this, void 0, void 0, function* () {
              if (!ue) {
                if (Re <= ne.nonce)
                  me = Ee;
                else {
                  {
                    const Ue = yield this.getTransaction(X);
                    if (Ue && Ue.blockNumber != null)
                      return;
                  }
                  for (ye == null && (ye = me - 3, ye < ne.startBlock && (ye = ne.startBlock)); ye <= Ee; ) {
                    if (ue)
                      return;
                    const Ue = yield this.getBlockWithTransactions(ye);
                    for (let Me = 0; Me < Ue.transactions.length; Me++) {
                      const De = Ue.transactions[Me];
                      if (De.hash === X)
                        return;
                      if (De.from === ne.from && De.nonce === ne.nonce) {
                        if (ue)
                          return;
                        const Fe = yield this.waitForTransaction(De.hash, ee);
                        if (le())
                          return;
                        let Ke = "replaced";
                        De.data === ne.data && De.to === ne.to && De.value.eq(ne.value) ? Ke = "repriced" : De.data === "0x" && De.from === De.to && De.value.isZero() && (Ke = "cancelled"), se(logger$1.makeError("transaction was replaced", Logger.errors.TRANSACTION_REPLACED, {
                          cancelled: Ke === "replaced" || Ke === "cancelled",
                          reason: Ke,
                          replacement: this._wrapTransaction(De),
                          hash: X,
                          receipt: Fe
                        }));
                        return;
                      }
                    }
                    ye++;
                  }
                }
                ue || this.once("block", we);
              }
            }), (Re) => {
              ue || this.once("block", we);
            }));
          });
          if (ue)
            return;
          this.once("block", we), ae.push(() => {
            this.removeListener("block", we);
          });
        }
        if (typeof te == "number" && te > 0) {
          const me = setTimeout(() => {
            le() || se(logger$1.makeError("timeout exceeded", Logger.errors.TIMEOUT, { timeout: te }));
          }, te);
          me.unref && me.unref(), ae.push(() => {
            clearTimeout(me);
          });
        }
      });
    });
  }
  getBlockNumber() {
    return __awaiter$1(this, void 0, void 0, function* () {
      return this._getInternalBlockNumber(0);
    });
  }
  getGasPrice() {
    return __awaiter$1(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const X = yield this.perform("getGasPrice", {});
      try {
        return BigNumber.from(X);
      } catch (ee) {
        return logger$1.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
          method: "getGasPrice",
          result: X,
          error: ee
        });
      }
    });
  }
  getBalance(X, ee) {
    return __awaiter$1(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const te = yield resolveProperties({
        address: this._getAddress(X),
        blockTag: this._getBlockTag(ee)
      }), ne = yield this.perform("getBalance", te);
      try {
        return BigNumber.from(ne);
      } catch (ie) {
        return logger$1.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
          method: "getBalance",
          params: te,
          result: ne,
          error: ie
        });
      }
    });
  }
  getTransactionCount(X, ee) {
    return __awaiter$1(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const te = yield resolveProperties({
        address: this._getAddress(X),
        blockTag: this._getBlockTag(ee)
      }), ne = yield this.perform("getTransactionCount", te);
      try {
        return BigNumber.from(ne).toNumber();
      } catch (ie) {
        return logger$1.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
          method: "getTransactionCount",
          params: te,
          result: ne,
          error: ie
        });
      }
    });
  }
  getCode(X, ee) {
    return __awaiter$1(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const te = yield resolveProperties({
        address: this._getAddress(X),
        blockTag: this._getBlockTag(ee)
      }), ne = yield this.perform("getCode", te);
      try {
        return hexlify(ne);
      } catch (ie) {
        return logger$1.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
          method: "getCode",
          params: te,
          result: ne,
          error: ie
        });
      }
    });
  }
  getStorageAt(X, ee, te) {
    return __awaiter$1(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const ne = yield resolveProperties({
        address: this._getAddress(X),
        blockTag: this._getBlockTag(te),
        position: Promise.resolve(ee).then((oe) => hexValue(oe))
      }), ie = yield this.perform("getStorageAt", ne);
      try {
        return hexlify(ie);
      } catch (oe) {
        return logger$1.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
          method: "getStorageAt",
          params: ne,
          result: ie,
          error: oe
        });
      }
    });
  }
  // This should be called by any subclass wrapping a TransactionResponse
  _wrapTransaction(X, ee, te) {
    if (ee != null && hexDataLength(ee) !== 32)
      throw new Error("invalid response - sendTransaction");
    const ne = X;
    return ee != null && X.hash !== ee && logger$1.throwError("Transaction hash mismatch from Provider.sendTransaction.", Logger.errors.UNKNOWN_ERROR, { expectedHash: X.hash, returnedHash: ee }), ne.wait = (ie, oe) => __awaiter$1(this, void 0, void 0, function* () {
      ie == null && (ie = 1), oe == null && (oe = 0);
      let se;
      ie !== 0 && te != null && (se = {
        data: X.data,
        from: X.from,
        nonce: X.nonce,
        to: X.to,
        value: X.value,
        startBlock: te
      });
      const ae = yield this._waitForTransaction(X.hash, ie, oe, se);
      return ae == null && ie === 0 ? null : (this._emitted["t:" + X.hash] = ae.blockNumber, ae.status === 0 && logger$1.throwError("transaction failed", Logger.errors.CALL_EXCEPTION, {
        transactionHash: X.hash,
        transaction: X,
        receipt: ae
      }), ae);
    }), ne;
  }
  sendTransaction(X) {
    return __awaiter$1(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const ee = yield Promise.resolve(X).then((ie) => hexlify(ie)), te = this.formatter.transaction(X);
      te.confirmations == null && (te.confirmations = 0);
      const ne = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
      try {
        const ie = yield this.perform("sendTransaction", { signedTransaction: ee });
        return this._wrapTransaction(te, ie, ne);
      } catch (ie) {
        throw ie.transaction = te, ie.transactionHash = te.hash, ie;
      }
    });
  }
  _getTransactionRequest(X) {
    return __awaiter$1(this, void 0, void 0, function* () {
      const ee = yield X, te = {};
      return ["from", "to"].forEach((ne) => {
        ee[ne] != null && (te[ne] = Promise.resolve(ee[ne]).then((ie) => ie ? this._getAddress(ie) : null));
      }), ["gasLimit", "gasPrice", "maxFeePerGas", "maxPriorityFeePerGas", "value"].forEach((ne) => {
        ee[ne] != null && (te[ne] = Promise.resolve(ee[ne]).then((ie) => ie ? BigNumber.from(ie) : null));
      }), ["type"].forEach((ne) => {
        ee[ne] != null && (te[ne] = Promise.resolve(ee[ne]).then((ie) => ie ?? null));
      }), ee.accessList && (te.accessList = this.formatter.accessList(ee.accessList)), ["data"].forEach((ne) => {
        ee[ne] != null && (te[ne] = Promise.resolve(ee[ne]).then((ie) => ie ? hexlify(ie) : null));
      }), this.formatter.transactionRequest(yield resolveProperties(te));
    });
  }
  _getFilter(X) {
    return __awaiter$1(this, void 0, void 0, function* () {
      X = yield X;
      const ee = {};
      return X.address != null && (ee.address = this._getAddress(X.address)), ["blockHash", "topics"].forEach((te) => {
        X[te] != null && (ee[te] = X[te]);
      }), ["fromBlock", "toBlock"].forEach((te) => {
        X[te] != null && (ee[te] = this._getBlockTag(X[te]));
      }), this.formatter.filter(yield resolveProperties(ee));
    });
  }
  _call(X, ee, te) {
    return __awaiter$1(this, void 0, void 0, function* () {
      te >= MAX_CCIP_REDIRECTS && logger$1.throwError("CCIP read exceeded maximum redirections", Logger.errors.SERVER_ERROR, {
        redirects: te,
        transaction: X
      });
      const ne = X.to, ie = yield this.perform("call", { transaction: X, blockTag: ee });
      if (te >= 0 && ee === "latest" && ne != null && ie.substring(0, 10) === "0x556f1830" && hexDataLength(ie) % 32 === 4)
        try {
          const oe = hexDataSlice(ie, 4), se = hexDataSlice(oe, 0, 32);
          BigNumber.from(se).eq(ne) || logger$1.throwError("CCIP Read sender did not match", Logger.errors.CALL_EXCEPTION, {
            name: "OffchainLookup",
            signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
            transaction: X,
            data: ie
          });
          const ae = [], ue = BigNumber.from(hexDataSlice(oe, 32, 64)).toNumber(), le = BigNumber.from(hexDataSlice(oe, ue, ue + 32)).toNumber(), he = hexDataSlice(oe, ue + 32);
          for (let Ue = 0; Ue < le; Ue++) {
            const Me = _parseString(he, Ue * 32);
            Me == null && logger$1.throwError("CCIP Read contained corrupt URL string", Logger.errors.CALL_EXCEPTION, {
              name: "OffchainLookup",
              signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
              transaction: X,
              data: ie
            }), ae.push(Me);
          }
          const me = _parseBytes(oe, 64);
          BigNumber.from(hexDataSlice(oe, 100, 128)).isZero() || logger$1.throwError("CCIP Read callback selector included junk", Logger.errors.CALL_EXCEPTION, {
            name: "OffchainLookup",
            signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
            transaction: X,
            data: ie
          });
          const ye = hexDataSlice(oe, 96, 100), we = _parseBytes(oe, 128), Ee = yield this.ccipReadFetch(X, me, ae);
          Ee == null && logger$1.throwError("CCIP Read disabled or provided no URLs", Logger.errors.CALL_EXCEPTION, {
            name: "OffchainLookup",
            signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
            transaction: X,
            data: ie
          });
          const Re = {
            to: ne,
            data: hexConcat([ye, encodeBytes([Ee, we])])
          };
          return this._call(Re, ee, te + 1);
        } catch (oe) {
          if (oe.code === Logger.errors.SERVER_ERROR)
            throw oe;
        }
      try {
        return hexlify(ie);
      } catch (oe) {
        return logger$1.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
          method: "call",
          params: { transaction: X, blockTag: ee },
          result: ie,
          error: oe
        });
      }
    });
  }
  call(X, ee) {
    return __awaiter$1(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const te = yield resolveProperties({
        transaction: this._getTransactionRequest(X),
        blockTag: this._getBlockTag(ee),
        ccipReadEnabled: Promise.resolve(X.ccipReadEnabled)
      });
      return this._call(te.transaction, te.blockTag, te.ccipReadEnabled ? 0 : -1);
    });
  }
  estimateGas(X) {
    return __awaiter$1(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const ee = yield resolveProperties({
        transaction: this._getTransactionRequest(X)
      }), te = yield this.perform("estimateGas", ee);
      try {
        return BigNumber.from(te);
      } catch (ne) {
        return logger$1.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
          method: "estimateGas",
          params: ee,
          result: te,
          error: ne
        });
      }
    });
  }
  _getAddress(X) {
    return __awaiter$1(this, void 0, void 0, function* () {
      X = yield X, typeof X != "string" && logger$1.throwArgumentError("invalid address or ENS name", "name", X);
      const ee = yield this.resolveName(X);
      return ee == null && logger$1.throwError("ENS name not configured", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: `resolveName(${JSON.stringify(X)})`
      }), ee;
    });
  }
  _getBlock(X, ee) {
    return __awaiter$1(this, void 0, void 0, function* () {
      yield this.getNetwork(), X = yield X;
      let te = -128;
      const ne = {
        includeTransactions: !!ee
      };
      if (isHexString(X, 32))
        ne.blockHash = X;
      else
        try {
          ne.blockTag = yield this._getBlockTag(X), isHexString(ne.blockTag) && (te = parseInt(ne.blockTag.substring(2), 16));
        } catch {
          logger$1.throwArgumentError("invalid block hash or block tag", "blockHashOrBlockTag", X);
        }
      return poll(() => __awaiter$1(this, void 0, void 0, function* () {
        const ie = yield this.perform("getBlock", ne);
        if (ie == null)
          return ne.blockHash != null && this._emitted["b:" + ne.blockHash] == null || ne.blockTag != null && te > this._emitted.block ? null : void 0;
        if (ee) {
          let oe = null;
          for (let ae = 0; ae < ie.transactions.length; ae++) {
            const ue = ie.transactions[ae];
            if (ue.blockNumber == null)
              ue.confirmations = 0;
            else if (ue.confirmations == null) {
              oe == null && (oe = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval));
              let le = oe - ue.blockNumber + 1;
              le <= 0 && (le = 1), ue.confirmations = le;
            }
          }
          const se = this.formatter.blockWithTransactions(ie);
          return se.transactions = se.transactions.map((ae) => this._wrapTransaction(ae)), se;
        }
        return this.formatter.block(ie);
      }), { oncePoll: this });
    });
  }
  getBlock(X) {
    return this._getBlock(X, !1);
  }
  getBlockWithTransactions(X) {
    return this._getBlock(X, !0);
  }
  getTransaction(X) {
    return __awaiter$1(this, void 0, void 0, function* () {
      yield this.getNetwork(), X = yield X;
      const ee = { transactionHash: this.formatter.hash(X, !0) };
      return poll(() => __awaiter$1(this, void 0, void 0, function* () {
        const te = yield this.perform("getTransaction", ee);
        if (te == null)
          return this._emitted["t:" + X] == null ? null : void 0;
        const ne = this.formatter.transactionResponse(te);
        if (ne.blockNumber == null)
          ne.confirmations = 0;
        else if (ne.confirmations == null) {
          let ie = (yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval)) - ne.blockNumber + 1;
          ie <= 0 && (ie = 1), ne.confirmations = ie;
        }
        return this._wrapTransaction(ne);
      }), { oncePoll: this });
    });
  }
  getTransactionReceipt(X) {
    return __awaiter$1(this, void 0, void 0, function* () {
      yield this.getNetwork(), X = yield X;
      const ee = { transactionHash: this.formatter.hash(X, !0) };
      return poll(() => __awaiter$1(this, void 0, void 0, function* () {
        const te = yield this.perform("getTransactionReceipt", ee);
        if (te == null)
          return this._emitted["t:" + X] == null ? null : void 0;
        if (te.blockHash == null)
          return;
        const ne = this.formatter.receipt(te);
        if (ne.blockNumber == null)
          ne.confirmations = 0;
        else if (ne.confirmations == null) {
          let ie = (yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval)) - ne.blockNumber + 1;
          ie <= 0 && (ie = 1), ne.confirmations = ie;
        }
        return ne;
      }), { oncePoll: this });
    });
  }
  getLogs(X) {
    return __awaiter$1(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const ee = yield resolveProperties({ filter: this._getFilter(X) }), te = yield this.perform("getLogs", ee);
      return te.forEach((ne) => {
        ne.removed == null && (ne.removed = !1);
      }), Formatter.arrayOf(this.formatter.filterLog.bind(this.formatter))(te);
    });
  }
  getEtherPrice() {
    return __awaiter$1(this, void 0, void 0, function* () {
      return yield this.getNetwork(), this.perform("getEtherPrice", {});
    });
  }
  _getBlockTag(X) {
    return __awaiter$1(this, void 0, void 0, function* () {
      if (X = yield X, typeof X == "number" && X < 0) {
        X % 1 && logger$1.throwArgumentError("invalid BlockTag", "blockTag", X);
        let ee = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
        return ee += X, ee < 0 && (ee = 0), this.formatter.blockTag(ee);
      }
      return this.formatter.blockTag(X);
    });
  }
  getResolver(X) {
    return __awaiter$1(this, void 0, void 0, function* () {
      let ee = X;
      for (; ; ) {
        if (ee === "" || ee === "." || X !== "eth" && ee === "eth")
          return null;
        const te = yield this._getResolver(ee, "getResolver");
        if (te != null) {
          const ne = new Resolver(this, te, X);
          return ee !== X && !(yield ne.supportsWildcard()) ? null : ne;
        }
        ee = ee.split(".").slice(1).join(".");
      }
    });
  }
  _getResolver(X, ee) {
    return __awaiter$1(this, void 0, void 0, function* () {
      ee == null && (ee = "ENS");
      const te = yield this.getNetwork();
      te.ensAddress || logger$1.throwError("network does not support ENS", Logger.errors.UNSUPPORTED_OPERATION, { operation: ee, network: te.name });
      try {
        const ne = yield this.call({
          to: te.ensAddress,
          data: "0x0178b8bf" + namehash(X).substring(2)
        });
        return this.formatter.callAddress(ne);
      } catch {
      }
      return null;
    });
  }
  resolveName(X) {
    return __awaiter$1(this, void 0, void 0, function* () {
      X = yield X;
      try {
        return Promise.resolve(this.formatter.address(X));
      } catch (te) {
        if (isHexString(X))
          throw te;
      }
      typeof X != "string" && logger$1.throwArgumentError("invalid ENS name", "name", X);
      const ee = yield this.getResolver(X);
      return ee ? yield ee.getAddress() : null;
    });
  }
  lookupAddress(X) {
    return __awaiter$1(this, void 0, void 0, function* () {
      X = yield X, X = this.formatter.address(X);
      const ee = X.substring(2).toLowerCase() + ".addr.reverse", te = yield this._getResolver(ee, "lookupAddress");
      if (te == null)
        return null;
      const ne = _parseString(yield this.call({
        to: te,
        data: "0x691f3431" + namehash(ee).substring(2)
      }), 0);
      return (yield this.resolveName(ne)) != X ? null : ne;
    });
  }
  getAvatar(X) {
    return __awaiter$1(this, void 0, void 0, function* () {
      let ee = null;
      if (isHexString(X)) {
        const ne = this.formatter.address(X).substring(2).toLowerCase() + ".addr.reverse", ie = yield this._getResolver(ne, "getAvatar");
        if (!ie)
          return null;
        ee = new Resolver(this, ie, ne);
        try {
          const oe = yield ee.getAvatar();
          if (oe)
            return oe.url;
        } catch (oe) {
          if (oe.code !== Logger.errors.CALL_EXCEPTION)
            throw oe;
        }
        try {
          const oe = _parseString(yield this.call({
            to: ie,
            data: "0x691f3431" + namehash(ne).substring(2)
          }), 0);
          ee = yield this.getResolver(oe);
        } catch (oe) {
          if (oe.code !== Logger.errors.CALL_EXCEPTION)
            throw oe;
          return null;
        }
      } else if (ee = yield this.getResolver(X), !ee)
        return null;
      const te = yield ee.getAvatar();
      return te == null ? null : te.url;
    });
  }
  perform(X, ee) {
    return logger$1.throwError(X + " not implemented", Logger.errors.NOT_IMPLEMENTED, { operation: X });
  }
  _startEvent(X) {
    this.polling = this._events.filter((ee) => ee.pollable()).length > 0;
  }
  _stopEvent(X) {
    this.polling = this._events.filter((ee) => ee.pollable()).length > 0;
  }
  _addEventListener(X, ee, te) {
    const ne = new Event$1(getEventTag(X), ee, te);
    return this._events.push(ne), this._startEvent(ne), this;
  }
  on(X, ee) {
    return this._addEventListener(X, ee, !1);
  }
  once(X, ee) {
    return this._addEventListener(X, ee, !0);
  }
  emit(X, ...ee) {
    let te = !1, ne = [], ie = getEventTag(X);
    return this._events = this._events.filter((oe) => oe.tag !== ie ? !0 : (setTimeout(() => {
      oe.listener.apply(this, ee);
    }, 0), te = !0, oe.once ? (ne.push(oe), !1) : !0)), ne.forEach((oe) => {
      this._stopEvent(oe);
    }), te;
  }
  listenerCount(X) {
    if (!X)
      return this._events.length;
    let ee = getEventTag(X);
    return this._events.filter((te) => te.tag === ee).length;
  }
  listeners(X) {
    if (X == null)
      return this._events.map((te) => te.listener);
    let ee = getEventTag(X);
    return this._events.filter((te) => te.tag === ee).map((te) => te.listener);
  }
  off(X, ee) {
    if (ee == null)
      return this.removeAllListeners(X);
    const te = [];
    let ne = !1, ie = getEventTag(X);
    return this._events = this._events.filter((oe) => oe.tag !== ie || oe.listener != ee || ne ? !0 : (ne = !0, te.push(oe), !1)), te.forEach((oe) => {
      this._stopEvent(oe);
    }), this;
  }
  removeAllListeners(X) {
    let ee = [];
    if (X == null)
      ee = this._events, this._events = [];
    else {
      const te = getEventTag(X);
      this._events = this._events.filter((ne) => ne.tag !== te ? !0 : (ee.push(ne), !1));
    }
    return ee.forEach((te) => {
      this._stopEvent(te);
    }), this;
  }
}
var __awaiter = function(Y, X, ee, te) {
  function ne(ie) {
    return ie instanceof ee ? ie : new ee(function(oe) {
      oe(ie);
    });
  }
  return new (ee || (ee = Promise))(function(ie, oe) {
    function se(le) {
      try {
        ue(te.next(le));
      } catch (he) {
        oe(he);
      }
    }
    function ae(le) {
      try {
        ue(te.throw(le));
      } catch (he) {
        oe(he);
      }
    }
    function ue(le) {
      le.done ? ie(le.value) : ne(le.value).then(se, ae);
    }
    ue((te = te.apply(Y, X || [])).next());
  });
};
const logger = new Logger(version$2), errorGas = ["call", "estimateGas"];
function spelunk(Y, X) {
  if (Y == null)
    return null;
  if (typeof Y.message == "string" && Y.message.match("reverted")) {
    const ee = isHexString(Y.data) ? Y.data : null;
    if (!X || ee)
      return { message: Y.message, data: ee };
  }
  if (typeof Y == "object") {
    for (const ee in Y) {
      const te = spelunk(Y[ee], X);
      if (te)
        return te;
    }
    return null;
  }
  if (typeof Y == "string")
    try {
      return spelunk(JSON.parse(Y), X);
    } catch {
    }
  return null;
}
function checkError(Y, X, ee) {
  const te = ee.transaction || ee.signedTransaction;
  if (Y === "call") {
    const ie = spelunk(X, !0);
    if (ie)
      return ie.data;
    logger.throwError("missing revert data in call exception; Transaction reverted without a reason string", Logger.errors.CALL_EXCEPTION, {
      data: "0x",
      transaction: te,
      error: X
    });
  }
  if (Y === "estimateGas") {
    let ie = spelunk(X.body, !1);
    ie == null && (ie = spelunk(X, !1)), ie && logger.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {
      reason: ie.message,
      method: Y,
      transaction: te,
      error: X
    });
  }
  let ne = X.message;
  throw X.code === Logger.errors.SERVER_ERROR && X.error && typeof X.error.message == "string" ? ne = X.error.message : typeof X.body == "string" ? ne = X.body : typeof X.responseText == "string" && (ne = X.responseText), ne = (ne || "").toLowerCase(), ne.match(/insufficient funds|base fee exceeds gas limit|InsufficientFunds/i) && logger.throwError("insufficient funds for intrinsic transaction cost", Logger.errors.INSUFFICIENT_FUNDS, {
    error: X,
    method: Y,
    transaction: te
  }), ne.match(/nonce (is )?too low/i) && logger.throwError("nonce has already been used", Logger.errors.NONCE_EXPIRED, {
    error: X,
    method: Y,
    transaction: te
  }), ne.match(/replacement transaction underpriced|transaction gas price.*too low/i) && logger.throwError("replacement fee too low", Logger.errors.REPLACEMENT_UNDERPRICED, {
    error: X,
    method: Y,
    transaction: te
  }), ne.match(/only replay-protected/i) && logger.throwError("legacy pre-eip-155 transactions not supported", Logger.errors.UNSUPPORTED_OPERATION, {
    error: X,
    method: Y,
    transaction: te
  }), errorGas.indexOf(Y) >= 0 && ne.match(/gas required exceeds allowance|always failing transaction|execution reverted|revert/) && logger.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {
    error: X,
    method: Y,
    transaction: te
  }), X;
}
function timer(Y) {
  return new Promise(function(X) {
    setTimeout(X, Y);
  });
}
function getResult(Y) {
  if (Y.error) {
    const X = new Error(Y.error.message);
    throw X.code = Y.error.code, X.data = Y.error.data, X;
  }
  return Y.result;
}
function getLowerCase(Y) {
  return Y && Y.toLowerCase();
}
const _constructorGuard = {};
class JsonRpcSigner extends Signer {
  constructor(X, ee, te) {
    if (super(), X !== _constructorGuard)
      throw new Error("do not call the JsonRpcSigner constructor directly; use provider.getSigner");
    defineReadOnly(this, "provider", ee), te == null && (te = 0), typeof te == "string" ? (defineReadOnly(this, "_address", this.provider.formatter.address(te)), defineReadOnly(this, "_index", null)) : typeof te == "number" ? (defineReadOnly(this, "_index", te), defineReadOnly(this, "_address", null)) : logger.throwArgumentError("invalid address or index", "addressOrIndex", te);
  }
  connect(X) {
    return logger.throwError("cannot alter JSON-RPC Signer connection", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "connect"
    });
  }
  connectUnchecked() {
    return new UncheckedJsonRpcSigner(_constructorGuard, this.provider, this._address || this._index);
  }
  getAddress() {
    return this._address ? Promise.resolve(this._address) : this.provider.send("eth_accounts", []).then((X) => (X.length <= this._index && logger.throwError("unknown account #" + this._index, Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "getAddress"
    }), this.provider.formatter.address(X[this._index])));
  }
  sendUncheckedTransaction(X) {
    X = shallowCopy(X);
    const ee = this.getAddress().then((te) => (te && (te = te.toLowerCase()), te));
    if (X.gasLimit == null) {
      const te = shallowCopy(X);
      te.from = ee, X.gasLimit = this.provider.estimateGas(te);
    }
    return X.to != null && (X.to = Promise.resolve(X.to).then((te) => __awaiter(this, void 0, void 0, function* () {
      if (te == null)
        return null;
      const ne = yield this.provider.resolveName(te);
      return ne == null && logger.throwArgumentError("provided ENS name resolves to null", "tx.to", te), ne;
    }))), resolveProperties({
      tx: resolveProperties(X),
      sender: ee
    }).then(({ tx: te, sender: ne }) => {
      te.from != null ? te.from.toLowerCase() !== ne && logger.throwArgumentError("from address mismatch", "transaction", X) : te.from = ne;
      const ie = this.provider.constructor.hexlifyTransaction(te, { from: !0 });
      return this.provider.send("eth_sendTransaction", [ie]).then((oe) => oe, (oe) => (typeof oe.message == "string" && oe.message.match(/user denied/i) && logger.throwError("user rejected transaction", Logger.errors.ACTION_REJECTED, {
        action: "sendTransaction",
        transaction: te
      }), checkError("sendTransaction", oe, ie)));
    });
  }
  signTransaction(X) {
    return logger.throwError("signing transactions is unsupported", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "signTransaction"
    });
  }
  sendTransaction(X) {
    return __awaiter(this, void 0, void 0, function* () {
      const ee = yield this.provider._getInternalBlockNumber(100 + 2 * this.provider.pollingInterval), te = yield this.sendUncheckedTransaction(X);
      try {
        return yield poll(() => __awaiter(this, void 0, void 0, function* () {
          const ne = yield this.provider.getTransaction(te);
          if (ne !== null)
            return this.provider._wrapTransaction(ne, te, ee);
        }), { oncePoll: this.provider });
      } catch (ne) {
        throw ne.transactionHash = te, ne;
      }
    });
  }
  signMessage(X) {
    return __awaiter(this, void 0, void 0, function* () {
      const ee = typeof X == "string" ? toUtf8Bytes(X) : X, te = yield this.getAddress();
      try {
        return yield this.provider.send("personal_sign", [hexlify(ee), te.toLowerCase()]);
      } catch (ne) {
        throw typeof ne.message == "string" && ne.message.match(/user denied/i) && logger.throwError("user rejected signing", Logger.errors.ACTION_REJECTED, {
          action: "signMessage",
          from: te,
          messageData: X
        }), ne;
      }
    });
  }
  _legacySignMessage(X) {
    return __awaiter(this, void 0, void 0, function* () {
      const ee = typeof X == "string" ? toUtf8Bytes(X) : X, te = yield this.getAddress();
      try {
        return yield this.provider.send("eth_sign", [te.toLowerCase(), hexlify(ee)]);
      } catch (ne) {
        throw typeof ne.message == "string" && ne.message.match(/user denied/i) && logger.throwError("user rejected signing", Logger.errors.ACTION_REJECTED, {
          action: "_legacySignMessage",
          from: te,
          messageData: X
        }), ne;
      }
    });
  }
  _signTypedData(X, ee, te) {
    return __awaiter(this, void 0, void 0, function* () {
      const ne = yield TypedDataEncoder.resolveNames(X, ee, te, (oe) => this.provider.resolveName(oe)), ie = yield this.getAddress();
      try {
        return yield this.provider.send("eth_signTypedData_v4", [
          ie.toLowerCase(),
          JSON.stringify(TypedDataEncoder.getPayload(ne.domain, ee, ne.value))
        ]);
      } catch (oe) {
        throw typeof oe.message == "string" && oe.message.match(/user denied/i) && logger.throwError("user rejected signing", Logger.errors.ACTION_REJECTED, {
          action: "_signTypedData",
          from: ie,
          messageData: { domain: ne.domain, types: ee, value: ne.value }
        }), oe;
      }
    });
  }
  unlock(X) {
    return __awaiter(this, void 0, void 0, function* () {
      const ee = this.provider, te = yield this.getAddress();
      return ee.send("personal_unlockAccount", [te.toLowerCase(), X, null]);
    });
  }
}
class UncheckedJsonRpcSigner extends JsonRpcSigner {
  sendTransaction(X) {
    return this.sendUncheckedTransaction(X).then((ee) => ({
      hash: ee,
      nonce: null,
      gasLimit: null,
      gasPrice: null,
      data: null,
      value: null,
      chainId: null,
      confirmations: 0,
      from: null,
      wait: (te) => this.provider.waitForTransaction(ee, te)
    }));
  }
}
const allowedTransactionKeys = {
  chainId: !0,
  data: !0,
  gasLimit: !0,
  gasPrice: !0,
  nonce: !0,
  to: !0,
  value: !0,
  type: !0,
  accessList: !0,
  maxFeePerGas: !0,
  maxPriorityFeePerGas: !0
};
class JsonRpcProvider extends BaseProvider {
  constructor(X, ee) {
    let te = ee;
    te == null && (te = new Promise((ne, ie) => {
      setTimeout(() => {
        this.detectNetwork().then((oe) => {
          ne(oe);
        }, (oe) => {
          ie(oe);
        });
      }, 0);
    })), super(te), X || (X = getStatic(this.constructor, "defaultUrl")()), typeof X == "string" ? defineReadOnly(this, "connection", Object.freeze({
      url: X
    })) : defineReadOnly(this, "connection", Object.freeze(shallowCopy(X))), this._nextId = 42;
  }
  get _cache() {
    return this._eventLoopCache == null && (this._eventLoopCache = {}), this._eventLoopCache;
  }
  static defaultUrl() {
    return "http://localhost:8545";
  }
  detectNetwork() {
    return this._cache.detectNetwork || (this._cache.detectNetwork = this._uncachedDetectNetwork(), setTimeout(() => {
      this._cache.detectNetwork = null;
    }, 0)), this._cache.detectNetwork;
  }
  _uncachedDetectNetwork() {
    return __awaiter(this, void 0, void 0, function* () {
      yield timer(0);
      let X = null;
      try {
        X = yield this.send("eth_chainId", []);
      } catch {
        try {
          X = yield this.send("net_version", []);
        } catch {
        }
      }
      if (X != null) {
        const ee = getStatic(this.constructor, "getNetwork");
        try {
          return ee(BigNumber.from(X).toNumber());
        } catch (te) {
          return logger.throwError("could not detect network", Logger.errors.NETWORK_ERROR, {
            chainId: X,
            event: "invalidNetwork",
            serverError: te
          });
        }
      }
      return logger.throwError("could not detect network", Logger.errors.NETWORK_ERROR, {
        event: "noNetwork"
      });
    });
  }
  getSigner(X) {
    return new JsonRpcSigner(_constructorGuard, this, X);
  }
  getUncheckedSigner(X) {
    return this.getSigner(X).connectUnchecked();
  }
  listAccounts() {
    return this.send("eth_accounts", []).then((X) => X.map((ee) => this.formatter.address(ee)));
  }
  send(X, ee) {
    const te = {
      method: X,
      params: ee,
      id: this._nextId++,
      jsonrpc: "2.0"
    };
    this.emit("debug", {
      action: "request",
      request: deepCopy(te),
      provider: this
    });
    const ne = ["eth_chainId", "eth_blockNumber"].indexOf(X) >= 0;
    if (ne && this._cache[X])
      return this._cache[X];
    const ie = fetchJson(this.connection, JSON.stringify(te), getResult).then((oe) => (this.emit("debug", {
      action: "response",
      request: te,
      response: oe,
      provider: this
    }), oe), (oe) => {
      throw this.emit("debug", {
        action: "response",
        error: oe,
        request: te,
        provider: this
      }), oe;
    });
    return ne && (this._cache[X] = ie, setTimeout(() => {
      this._cache[X] = null;
    }, 0)), ie;
  }
  prepareRequest(X, ee) {
    switch (X) {
      case "getBlockNumber":
        return ["eth_blockNumber", []];
      case "getGasPrice":
        return ["eth_gasPrice", []];
      case "getBalance":
        return ["eth_getBalance", [getLowerCase(ee.address), ee.blockTag]];
      case "getTransactionCount":
        return ["eth_getTransactionCount", [getLowerCase(ee.address), ee.blockTag]];
      case "getCode":
        return ["eth_getCode", [getLowerCase(ee.address), ee.blockTag]];
      case "getStorageAt":
        return ["eth_getStorageAt", [getLowerCase(ee.address), hexZeroPad(ee.position, 32), ee.blockTag]];
      case "sendTransaction":
        return ["eth_sendRawTransaction", [ee.signedTransaction]];
      case "getBlock":
        return ee.blockTag ? ["eth_getBlockByNumber", [ee.blockTag, !!ee.includeTransactions]] : ee.blockHash ? ["eth_getBlockByHash", [ee.blockHash, !!ee.includeTransactions]] : null;
      case "getTransaction":
        return ["eth_getTransactionByHash", [ee.transactionHash]];
      case "getTransactionReceipt":
        return ["eth_getTransactionReceipt", [ee.transactionHash]];
      case "call":
        return ["eth_call", [getStatic(this.constructor, "hexlifyTransaction")(ee.transaction, { from: !0 }), ee.blockTag]];
      case "estimateGas":
        return ["eth_estimateGas", [getStatic(this.constructor, "hexlifyTransaction")(ee.transaction, { from: !0 })]];
      case "getLogs":
        return ee.filter && ee.filter.address != null && (ee.filter.address = getLowerCase(ee.filter.address)), ["eth_getLogs", [ee.filter]];
    }
    return null;
  }
  perform(X, ee) {
    return __awaiter(this, void 0, void 0, function* () {
      if (X === "call" || X === "estimateGas") {
        const ne = ee.transaction;
        if (ne && ne.type != null && BigNumber.from(ne.type).isZero() && ne.maxFeePerGas == null && ne.maxPriorityFeePerGas == null) {
          const ie = yield this.getFeeData();
          ie.maxFeePerGas == null && ie.maxPriorityFeePerGas == null && (ee = shallowCopy(ee), ee.transaction = shallowCopy(ne), delete ee.transaction.type);
        }
      }
      const te = this.prepareRequest(X, ee);
      te == null && logger.throwError(X + " not implemented", Logger.errors.NOT_IMPLEMENTED, { operation: X });
      try {
        return yield this.send(te[0], te[1]);
      } catch (ne) {
        return checkError(X, ne, ee);
      }
    });
  }
  _startEvent(X) {
    X.tag === "pending" && this._startPending(), super._startEvent(X);
  }
  _startPending() {
    if (this._pendingFilter != null)
      return;
    const X = this, ee = this.send("eth_newPendingTransactionFilter", []);
    this._pendingFilter = ee, ee.then(function(te) {
      function ne() {
        X.send("eth_getFilterChanges", [te]).then(function(ie) {
          if (X._pendingFilter != ee)
            return null;
          let oe = Promise.resolve();
          return ie.forEach(function(se) {
            X._emitted["t:" + se.toLowerCase()] = "pending", oe = oe.then(function() {
              return X.getTransaction(se).then(function(ae) {
                return X.emit("pending", ae), null;
              });
            });
          }), oe.then(function() {
            return timer(1e3);
          });
        }).then(function() {
          if (X._pendingFilter != ee) {
            X.send("eth_uninstallFilter", [te]);
            return;
          }
          return setTimeout(function() {
            ne();
          }, 0), null;
        }).catch((ie) => {
        });
      }
      return ne(), te;
    }).catch((te) => {
    });
  }
  _stopEvent(X) {
    X.tag === "pending" && this.listenerCount("pending") === 0 && (this._pendingFilter = null), super._stopEvent(X);
  }
  // Convert an ethers.js transaction into a JSON-RPC transaction
  //  - gasLimit => gas
  //  - All values hexlified
  //  - All numeric values zero-striped
  //  - All addresses are lowercased
  // NOTE: This allows a TransactionRequest, but all values should be resolved
  //       before this is called
  // @TODO: This will likely be removed in future versions and prepareRequest
  //        will be the preferred method for this.
  static hexlifyTransaction(X, ee) {
    const te = shallowCopy(allowedTransactionKeys);
    if (ee)
      for (const ie in ee)
        ee[ie] && (te[ie] = !0);
    checkProperties(X, te);
    const ne = {};
    return ["chainId", "gasLimit", "gasPrice", "type", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "value"].forEach(function(ie) {
      if (X[ie] == null)
        return;
      const oe = hexValue(BigNumber.from(X[ie]));
      ie === "gasLimit" && (ie = "gas"), ne[ie] = oe;
    }), ["from", "to", "data"].forEach(function(ie) {
      X[ie] != null && (ne[ie] = hexlify(X[ie]));
    }), X.accessList && (ne.accessList = accessListify(X.accessList)), ne;
  }
}
var buffer$1 = {}, base64Js = {};
base64Js.byteLength = byteLength;
base64Js.toByteArray = toByteArray;
base64Js.fromByteArray = fromByteArray;
var lookup = [], revLookup = [], Arr = typeof Uint8Array < "u" ? Uint8Array : Array, code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var i$1 = 0, len = code.length; i$1 < len; ++i$1)
  lookup[i$1] = code[i$1], revLookup[code.charCodeAt(i$1)] = i$1;
revLookup[45] = 62;
revLookup[95] = 63;
function getLens(Y) {
  var X = Y.length;
  if (X % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var ee = Y.indexOf("=");
  ee === -1 && (ee = X);
  var te = ee === X ? 0 : 4 - ee % 4;
  return [ee, te];
}
function byteLength(Y) {
  var X = getLens(Y), ee = X[0], te = X[1];
  return (ee + te) * 3 / 4 - te;
}
function _byteLength(Y, X, ee) {
  return (X + ee) * 3 / 4 - ee;
}
function toByteArray(Y) {
  var X, ee = getLens(Y), te = ee[0], ne = ee[1], ie = new Arr(_byteLength(Y, te, ne)), oe = 0, se = ne > 0 ? te - 4 : te, ae;
  for (ae = 0; ae < se; ae += 4)
    X = revLookup[Y.charCodeAt(ae)] << 18 | revLookup[Y.charCodeAt(ae + 1)] << 12 | revLookup[Y.charCodeAt(ae + 2)] << 6 | revLookup[Y.charCodeAt(ae + 3)], ie[oe++] = X >> 16 & 255, ie[oe++] = X >> 8 & 255, ie[oe++] = X & 255;
  return ne === 2 && (X = revLookup[Y.charCodeAt(ae)] << 2 | revLookup[Y.charCodeAt(ae + 1)] >> 4, ie[oe++] = X & 255), ne === 1 && (X = revLookup[Y.charCodeAt(ae)] << 10 | revLookup[Y.charCodeAt(ae + 1)] << 4 | revLookup[Y.charCodeAt(ae + 2)] >> 2, ie[oe++] = X >> 8 & 255, ie[oe++] = X & 255), ie;
}
function tripletToBase64(Y) {
  return lookup[Y >> 18 & 63] + lookup[Y >> 12 & 63] + lookup[Y >> 6 & 63] + lookup[Y & 63];
}
function encodeChunk(Y, X, ee) {
  for (var te, ne = [], ie = X; ie < ee; ie += 3)
    te = (Y[ie] << 16 & 16711680) + (Y[ie + 1] << 8 & 65280) + (Y[ie + 2] & 255), ne.push(tripletToBase64(te));
  return ne.join("");
}
function fromByteArray(Y) {
  for (var X, ee = Y.length, te = ee % 3, ne = [], ie = 16383, oe = 0, se = ee - te; oe < se; oe += ie)
    ne.push(encodeChunk(Y, oe, oe + ie > se ? se : oe + ie));
  return te === 1 ? (X = Y[ee - 1], ne.push(
    lookup[X >> 2] + lookup[X << 4 & 63] + "=="
  )) : te === 2 && (X = (Y[ee - 2] << 8) + Y[ee - 1], ne.push(
    lookup[X >> 10] + lookup[X >> 4 & 63] + lookup[X << 2 & 63] + "="
  )), ne.join("");
}
var ieee754 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
ieee754.read = function(Y, X, ee, te, ne) {
  var ie, oe, se = ne * 8 - te - 1, ae = (1 << se) - 1, ue = ae >> 1, le = -7, he = ee ? ne - 1 : 0, me = ee ? -1 : 1, ye = Y[X + he];
  for (he += me, ie = ye & (1 << -le) - 1, ye >>= -le, le += se; le > 0; ie = ie * 256 + Y[X + he], he += me, le -= 8)
    ;
  for (oe = ie & (1 << -le) - 1, ie >>= -le, le += te; le > 0; oe = oe * 256 + Y[X + he], he += me, le -= 8)
    ;
  if (ie === 0)
    ie = 1 - ue;
  else {
    if (ie === ae)
      return oe ? NaN : (ye ? -1 : 1) * (1 / 0);
    oe = oe + Math.pow(2, te), ie = ie - ue;
  }
  return (ye ? -1 : 1) * oe * Math.pow(2, ie - te);
};
ieee754.write = function(Y, X, ee, te, ne, ie) {
  var oe, se, ae, ue = ie * 8 - ne - 1, le = (1 << ue) - 1, he = le >> 1, me = ne === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, ye = te ? 0 : ie - 1, we = te ? 1 : -1, Ee = X < 0 || X === 0 && 1 / X < 0 ? 1 : 0;
  for (X = Math.abs(X), isNaN(X) || X === 1 / 0 ? (se = isNaN(X) ? 1 : 0, oe = le) : (oe = Math.floor(Math.log(X) / Math.LN2), X * (ae = Math.pow(2, -oe)) < 1 && (oe--, ae *= 2), oe + he >= 1 ? X += me / ae : X += me * Math.pow(2, 1 - he), X * ae >= 2 && (oe++, ae /= 2), oe + he >= le ? (se = 0, oe = le) : oe + he >= 1 ? (se = (X * ae - 1) * Math.pow(2, ne), oe = oe + he) : (se = X * Math.pow(2, he - 1) * Math.pow(2, ne), oe = 0)); ne >= 8; Y[ee + ye] = se & 255, ye += we, se /= 256, ne -= 8)
    ;
  for (oe = oe << ne | se, ue += ne; ue > 0; Y[ee + ye] = oe & 255, ye += we, oe /= 256, ue -= 8)
    ;
  Y[ee + ye - we] |= Ee * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(Y) {
  const X = base64Js, ee = ieee754, te = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  Y.Buffer = le, Y.SlowBuffer = Ke, Y.INSPECT_MAX_BYTES = 50;
  const ne = 2147483647;
  Y.kMaxLength = ne;
  const { Uint8Array: ie, ArrayBuffer: oe, SharedArrayBuffer: se } = globalThis;
  le.TYPED_ARRAY_SUPPORT = ae(), !le.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
    "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
  );
  function ae() {
    try {
      const He = new ie(1), Je = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(Je, ie.prototype), Object.setPrototypeOf(He, Je), He.foo() === 42;
    } catch {
      return !1;
    }
  }
  Object.defineProperty(le.prototype, "parent", {
    enumerable: !0,
    get: function() {
      if (le.isBuffer(this))
        return this.buffer;
    }
  }), Object.defineProperty(le.prototype, "offset", {
    enumerable: !0,
    get: function() {
      if (le.isBuffer(this))
        return this.byteOffset;
    }
  });
  function ue(He) {
    if (He > ne)
      throw new RangeError('The value "' + He + '" is invalid for option "size"');
    const Je = new ie(He);
    return Object.setPrototypeOf(Je, le.prototype), Je;
  }
  function le(He, Je, st) {
    if (typeof He == "number") {
      if (typeof Je == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return we(He);
    }
    return he(He, Je, st);
  }
  le.poolSize = 8192;
  function he(He, Je, st) {
    if (typeof He == "string")
      return Ee(He, Je);
    if (oe.isView(He))
      return Ue(He);
    if (He == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof He
      );
    if (sX(He, oe) || He && sX(He.buffer, oe) || typeof se < "u" && (sX(He, se) || He && sX(He.buffer, se)))
      return Me(He, Je, st);
    if (typeof He == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    const gt = He.valueOf && He.valueOf();
    if (gt != null && gt !== He)
      return le.from(gt, Je, st);
    const kt = De(He);
    if (kt)
      return kt;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof He[Symbol.toPrimitive] == "function")
      return le.from(He[Symbol.toPrimitive]("string"), Je, st);
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof He
    );
  }
  le.from = function(He, Je, st) {
    return he(He, Je, st);
  }, Object.setPrototypeOf(le.prototype, ie.prototype), Object.setPrototypeOf(le, ie);
  function me(He) {
    if (typeof He != "number")
      throw new TypeError('"size" argument must be of type number');
    if (He < 0)
      throw new RangeError('The value "' + He + '" is invalid for option "size"');
  }
  function ye(He, Je, st) {
    return me(He), He <= 0 ? ue(He) : Je !== void 0 ? typeof st == "string" ? ue(He).fill(Je, st) : ue(He).fill(Je) : ue(He);
  }
  le.alloc = function(He, Je, st) {
    return ye(He, Je, st);
  };
  function we(He) {
    return me(He), ue(He < 0 ? 0 : Fe(He) | 0);
  }
  le.allocUnsafe = function(He) {
    return we(He);
  }, le.allocUnsafeSlow = function(He) {
    return we(He);
  };
  function Ee(He, Je) {
    if ((typeof Je != "string" || Je === "") && (Je = "utf8"), !le.isEncoding(Je))
      throw new TypeError("Unknown encoding: " + Je);
    const st = tt(He, Je) | 0;
    let gt = ue(st);
    const kt = gt.write(He, Je);
    return kt !== st && (gt = gt.slice(0, kt)), gt;
  }
  function Re(He) {
    const Je = He.length < 0 ? 0 : Fe(He.length) | 0, st = ue(Je);
    for (let gt = 0; gt < Je; gt += 1)
      st[gt] = He[gt] & 255;
    return st;
  }
  function Ue(He) {
    if (sX(He, ie)) {
      const Je = new ie(He);
      return Me(Je.buffer, Je.byteOffset, Je.byteLength);
    }
    return Re(He);
  }
  function Me(He, Je, st) {
    if (Je < 0 || He.byteLength < Je)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (He.byteLength < Je + (st || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let gt;
    return Je === void 0 && st === void 0 ? gt = new ie(He) : st === void 0 ? gt = new ie(He, Je) : gt = new ie(He, Je, st), Object.setPrototypeOf(gt, le.prototype), gt;
  }
  function De(He) {
    if (le.isBuffer(He)) {
      const Je = Fe(He.length) | 0, st = ue(Je);
      return st.length === 0 || He.copy(st, 0, 0, Je), st;
    }
    if (He.length !== void 0)
      return typeof He.length != "number" || nX(He.length) ? ue(0) : Re(He);
    if (He.type === "Buffer" && Array.isArray(He.data))
      return Re(He.data);
  }
  function Fe(He) {
    if (He >= ne)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + ne.toString(16) + " bytes");
    return He | 0;
  }
  function Ke(He) {
    return +He != He && (He = 0), le.alloc(+He);
  }
  le.isBuffer = function(He) {
    return He != null && He._isBuffer === !0 && He !== le.prototype;
  }, le.compare = function(He, Je) {
    if (sX(He, ie) && (He = le.from(He, He.offset, He.byteLength)), sX(Je, ie) && (Je = le.from(Je, Je.offset, Je.byteLength)), !le.isBuffer(He) || !le.isBuffer(Je))
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (He === Je)
      return 0;
    let st = He.length, gt = Je.length;
    for (let kt = 0, Vt = Math.min(st, gt); kt < Vt; ++kt)
      if (He[kt] !== Je[kt]) {
        st = He[kt], gt = Je[kt];
        break;
      }
    return st < gt ? -1 : gt < st ? 1 : 0;
  }, le.isEncoding = function(He) {
    switch (String(He).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  }, le.concat = function(He, Je) {
    if (!Array.isArray(He))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (He.length === 0)
      return le.alloc(0);
    let st;
    if (Je === void 0)
      for (Je = 0, st = 0; st < He.length; ++st)
        Je += He[st].length;
    const gt = le.allocUnsafe(Je);
    let kt = 0;
    for (st = 0; st < He.length; ++st) {
      let Vt = He[st];
      if (sX(Vt, ie))
        kt + Vt.length > gt.length ? (le.isBuffer(Vt) || (Vt = le.from(Vt)), Vt.copy(gt, kt)) : ie.prototype.set.call(
          gt,
          Vt,
          kt
        );
      else if (le.isBuffer(Vt))
        Vt.copy(gt, kt);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      kt += Vt.length;
    }
    return gt;
  };
  function tt(He, Je) {
    if (le.isBuffer(He))
      return He.length;
    if (oe.isView(He) || sX(He, oe))
      return He.byteLength;
    if (typeof He != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof He
      );
    const st = He.length, gt = arguments.length > 2 && arguments[2] === !0;
    if (!gt && st === 0)
      return 0;
    let kt = !1;
    for (; ; )
      switch (Je) {
        case "ascii":
        case "latin1":
        case "binary":
          return st;
        case "utf8":
        case "utf-8":
          return w_(He).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return st * 2;
        case "hex":
          return st >>> 1;
        case "base64":
          return Nn(He).length;
        default:
          if (kt)
            return gt ? -1 : w_(He).length;
          Je = ("" + Je).toLowerCase(), kt = !0;
      }
  }
  le.byteLength = tt;
  function rt(He, Je, st) {
    let gt = !1;
    if ((Je === void 0 || Je < 0) && (Je = 0), Je > this.length || ((st === void 0 || st > this.length) && (st = this.length), st <= 0) || (st >>>= 0, Je >>>= 0, st <= Je))
      return "";
    for (He || (He = "utf8"); ; )
      switch (He) {
        case "hex":
          return Ae(this, Je, st);
        case "utf8":
        case "utf-8":
          return Ce(this, Je, st);
        case "ascii":
          return ke(this, Je, st);
        case "latin1":
        case "binary":
          return ge(this, Je, st);
        case "base64":
          return Te(this, Je, st);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return Ge(this, Je, st);
        default:
          if (gt)
            throw new TypeError("Unknown encoding: " + He);
          He = (He + "").toLowerCase(), gt = !0;
      }
  }
  le.prototype._isBuffer = !0;
  function it(He, Je, st) {
    const gt = He[Je];
    He[Je] = He[st], He[st] = gt;
  }
  le.prototype.swap16 = function() {
    const He = this.length;
    if (He % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let Je = 0; Je < He; Je += 2)
      it(this, Je, Je + 1);
    return this;
  }, le.prototype.swap32 = function() {
    const He = this.length;
    if (He % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let Je = 0; Je < He; Je += 4)
      it(this, Je, Je + 3), it(this, Je + 1, Je + 2);
    return this;
  }, le.prototype.swap64 = function() {
    const He = this.length;
    if (He % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let Je = 0; Je < He; Je += 8)
      it(this, Je, Je + 7), it(this, Je + 1, Je + 6), it(this, Je + 2, Je + 5), it(this, Je + 3, Je + 4);
    return this;
  }, le.prototype.toString = function() {
    const He = this.length;
    return He === 0 ? "" : arguments.length === 0 ? Ce(this, 0, He) : rt.apply(this, arguments);
  }, le.prototype.toLocaleString = le.prototype.toString, le.prototype.equals = function(He) {
    if (!le.isBuffer(He))
      throw new TypeError("Argument must be a Buffer");
    return this === He ? !0 : le.compare(this, He) === 0;
  }, le.prototype.inspect = function() {
    let He = "";
    const Je = Y.INSPECT_MAX_BYTES;
    return He = this.toString("hex", 0, Je).replace(/(.{2})/g, "$1 ").trim(), this.length > Je && (He += " ... "), "<Buffer " + He + ">";
  }, te && (le.prototype[te] = le.prototype.inspect), le.prototype.compare = function(He, Je, st, gt, kt) {
    if (sX(He, ie) && (He = le.from(He, He.offset, He.byteLength)), !le.isBuffer(He))
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof He
      );
    if (Je === void 0 && (Je = 0), st === void 0 && (st = He ? He.length : 0), gt === void 0 && (gt = 0), kt === void 0 && (kt = this.length), Je < 0 || st > He.length || gt < 0 || kt > this.length)
      throw new RangeError("out of range index");
    if (gt >= kt && Je >= st)
      return 0;
    if (gt >= kt)
      return -1;
    if (Je >= st)
      return 1;
    if (Je >>>= 0, st >>>= 0, gt >>>= 0, kt >>>= 0, this === He)
      return 0;
    let Vt = kt - gt, Lr = st - Je;
    const Ci = Math.min(Vt, Lr), Qr = this.slice(gt, kt), xX = He.slice(Je, st);
    for (let lX = 0; lX < Ci; ++lX)
      if (Qr[lX] !== xX[lX]) {
        Vt = Qr[lX], Lr = xX[lX];
        break;
      }
    return Vt < Lr ? -1 : Lr < Vt ? 1 : 0;
  };
  function _t(He, Je, st, gt, kt) {
    if (He.length === 0)
      return -1;
    if (typeof st == "string" ? (gt = st, st = 0) : st > 2147483647 ? st = 2147483647 : st < -2147483648 && (st = -2147483648), st = +st, nX(st) && (st = kt ? 0 : He.length - 1), st < 0 && (st = He.length + st), st >= He.length) {
      if (kt)
        return -1;
      st = He.length - 1;
    } else if (st < 0)
      if (kt)
        st = 0;
      else
        return -1;
    if (typeof Je == "string" && (Je = le.from(Je, gt)), le.isBuffer(Je))
      return Je.length === 0 ? -1 : Dt(He, Je, st, gt, kt);
    if (typeof Je == "number")
      return Je = Je & 255, typeof ie.prototype.indexOf == "function" ? kt ? ie.prototype.indexOf.call(He, Je, st) : ie.prototype.lastIndexOf.call(He, Je, st) : Dt(He, [Je], st, gt, kt);
    throw new TypeError("val must be string, number or Buffer");
  }
  function Dt(He, Je, st, gt, kt) {
    let Vt = 1, Lr = He.length, Ci = Je.length;
    if (gt !== void 0 && (gt = String(gt).toLowerCase(), gt === "ucs2" || gt === "ucs-2" || gt === "utf16le" || gt === "utf-16le")) {
      if (He.length < 2 || Je.length < 2)
        return -1;
      Vt = 2, Lr /= 2, Ci /= 2, st /= 2;
    }
    function Qr(lX, rX) {
      return Vt === 1 ? lX[rX] : lX.readUInt16BE(rX * Vt);
    }
    let xX;
    if (kt) {
      let lX = -1;
      for (xX = st; xX < Lr; xX++)
        if (Qr(He, xX) === Qr(Je, lX === -1 ? 0 : xX - lX)) {
          if (lX === -1 && (lX = xX), xX - lX + 1 === Ci)
            return lX * Vt;
        } else
          lX !== -1 && (xX -= xX - lX), lX = -1;
    } else
      for (st + Ci > Lr && (st = Lr - Ci), xX = st; xX >= 0; xX--) {
        let lX = !0;
        for (let rX = 0; rX < Ci; rX++)
          if (Qr(He, xX + rX) !== Qr(Je, rX)) {
            lX = !1;
            break;
          }
        if (lX)
          return xX;
      }
    return -1;
  }
  le.prototype.includes = function(He, Je, st) {
    return this.indexOf(He, Je, st) !== -1;
  }, le.prototype.indexOf = function(He, Je, st) {
    return _t(this, He, Je, st, !0);
  }, le.prototype.lastIndexOf = function(He, Je, st) {
    return _t(this, He, Je, st, !1);
  };
  function je(He, Je, st, gt) {
    st = Number(st) || 0;
    const kt = He.length - st;
    gt ? (gt = Number(gt), gt > kt && (gt = kt)) : gt = kt;
    const Vt = Je.length;
    gt > Vt / 2 && (gt = Vt / 2);
    let Lr;
    for (Lr = 0; Lr < gt; ++Lr) {
      const Ci = parseInt(Je.substr(Lr * 2, 2), 16);
      if (nX(Ci))
        return Lr;
      He[st + Lr] = Ci;
    }
    return Lr;
  }
  function ze(He, Je, st, gt) {
    return SX(w_(Je, He.length - st), He, st, gt);
  }
  function fe(He, Je, st, gt) {
    return SX(hX(Je), He, st, gt);
  }
  function de(He, Je, st, gt) {
    return SX(Nn(Je), He, st, gt);
  }
  function be(He, Je, st, gt) {
    return SX(oX(Je, He.length - st), He, st, gt);
  }
  le.prototype.write = function(He, Je, st, gt) {
    if (Je === void 0)
      gt = "utf8", st = this.length, Je = 0;
    else if (st === void 0 && typeof Je == "string")
      gt = Je, st = this.length, Je = 0;
    else if (isFinite(Je))
      Je = Je >>> 0, isFinite(st) ? (st = st >>> 0, gt === void 0 && (gt = "utf8")) : (gt = st, st = void 0);
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    const kt = this.length - Je;
    if ((st === void 0 || st > kt) && (st = kt), He.length > 0 && (st < 0 || Je < 0) || Je > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    gt || (gt = "utf8");
    let Vt = !1;
    for (; ; )
      switch (gt) {
        case "hex":
          return je(this, He, Je, st);
        case "utf8":
        case "utf-8":
          return ze(this, He, Je, st);
        case "ascii":
        case "latin1":
        case "binary":
          return fe(this, He, Je, st);
        case "base64":
          return de(this, He, Je, st);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return be(this, He, Je, st);
        default:
          if (Vt)
            throw new TypeError("Unknown encoding: " + gt);
          gt = ("" + gt).toLowerCase(), Vt = !0;
      }
  }, le.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function Te(He, Je, st) {
    return Je === 0 && st === He.length ? X.fromByteArray(He) : X.fromByteArray(He.slice(Je, st));
  }
  function Ce(He, Je, st) {
    st = Math.min(He.length, st);
    const gt = [];
    let kt = Je;
    for (; kt < st; ) {
      const Vt = He[kt];
      let Lr = null, Ci = Vt > 239 ? 4 : Vt > 223 ? 3 : Vt > 191 ? 2 : 1;
      if (kt + Ci <= st) {
        let Qr, xX, lX, rX;
        switch (Ci) {
          case 1:
            Vt < 128 && (Lr = Vt);
            break;
          case 2:
            Qr = He[kt + 1], (Qr & 192) === 128 && (rX = (Vt & 31) << 6 | Qr & 63, rX > 127 && (Lr = rX));
            break;
          case 3:
            Qr = He[kt + 1], xX = He[kt + 2], (Qr & 192) === 128 && (xX & 192) === 128 && (rX = (Vt & 15) << 12 | (Qr & 63) << 6 | xX & 63, rX > 2047 && (rX < 55296 || rX > 57343) && (Lr = rX));
            break;
          case 4:
            Qr = He[kt + 1], xX = He[kt + 2], lX = He[kt + 3], (Qr & 192) === 128 && (xX & 192) === 128 && (lX & 192) === 128 && (rX = (Vt & 15) << 18 | (Qr & 63) << 12 | (xX & 63) << 6 | lX & 63, rX > 65535 && rX < 1114112 && (Lr = rX));
        }
      }
      Lr === null ? (Lr = 65533, Ci = 1) : Lr > 65535 && (Lr -= 65536, gt.push(Lr >>> 10 & 1023 | 55296), Lr = 56320 | Lr & 1023), gt.push(Lr), kt += Ci;
    }
    return Se(gt);
  }
  const Pe = 4096;
  function Se(He) {
    const Je = He.length;
    if (Je <= Pe)
      return String.fromCharCode.apply(String, He);
    let st = "", gt = 0;
    for (; gt < Je; )
      st += String.fromCharCode.apply(
        String,
        He.slice(gt, gt += Pe)
      );
    return st;
  }
  function ke(He, Je, st) {
    let gt = "";
    st = Math.min(He.length, st);
    for (let kt = Je; kt < st; ++kt)
      gt += String.fromCharCode(He[kt] & 127);
    return gt;
  }
  function ge(He, Je, st) {
    let gt = "";
    st = Math.min(He.length, st);
    for (let kt = Je; kt < st; ++kt)
      gt += String.fromCharCode(He[kt]);
    return gt;
  }
  function Ae(He, Je, st) {
    const gt = He.length;
    (!Je || Je < 0) && (Je = 0), (!st || st < 0 || st > gt) && (st = gt);
    let kt = "";
    for (let Vt = Je; Vt < st; ++Vt)
      kt += Ye[He[Vt]];
    return kt;
  }
  function Ge(He, Je, st) {
    const gt = He.slice(Je, st);
    let kt = "";
    for (let Vt = 0; Vt < gt.length - 1; Vt += 2)
      kt += String.fromCharCode(gt[Vt] + gt[Vt + 1] * 256);
    return kt;
  }
  le.prototype.slice = function(He, Je) {
    const st = this.length;
    He = ~~He, Je = Je === void 0 ? st : ~~Je, He < 0 ? (He += st, He < 0 && (He = 0)) : He > st && (He = st), Je < 0 ? (Je += st, Je < 0 && (Je = 0)) : Je > st && (Je = st), Je < He && (Je = He);
    const gt = this.subarray(He, Je);
    return Object.setPrototypeOf(gt, le.prototype), gt;
  };
  function Xe(He, Je, st) {
    if (He % 1 !== 0 || He < 0)
      throw new RangeError("offset is not uint");
    if (He + Je > st)
      throw new RangeError("Trying to access beyond buffer length");
  }
  le.prototype.readUintLE = le.prototype.readUIntLE = function(He, Je, st) {
    He = He >>> 0, Je = Je >>> 0, st || Xe(He, Je, this.length);
    let gt = this[He], kt = 1, Vt = 0;
    for (; ++Vt < Je && (kt *= 256); )
      gt += this[He + Vt] * kt;
    return gt;
  }, le.prototype.readUintBE = le.prototype.readUIntBE = function(He, Je, st) {
    He = He >>> 0, Je = Je >>> 0, st || Xe(He, Je, this.length);
    let gt = this[He + --Je], kt = 1;
    for (; Je > 0 && (kt *= 256); )
      gt += this[He + --Je] * kt;
    return gt;
  }, le.prototype.readUint8 = le.prototype.readUInt8 = function(He, Je) {
    return He = He >>> 0, Je || Xe(He, 1, this.length), this[He];
  }, le.prototype.readUint16LE = le.prototype.readUInt16LE = function(He, Je) {
    return He = He >>> 0, Je || Xe(He, 2, this.length), this[He] | this[He + 1] << 8;
  }, le.prototype.readUint16BE = le.prototype.readUInt16BE = function(He, Je) {
    return He = He >>> 0, Je || Xe(He, 2, this.length), this[He] << 8 | this[He + 1];
  }, le.prototype.readUint32LE = le.prototype.readUInt32LE = function(He, Je) {
    return He = He >>> 0, Je || Xe(He, 4, this.length), (this[He] | this[He + 1] << 8 | this[He + 2] << 16) + this[He + 3] * 16777216;
  }, le.prototype.readUint32BE = le.prototype.readUInt32BE = function(He, Je) {
    return He = He >>> 0, Je || Xe(He, 4, this.length), this[He] * 16777216 + (this[He + 1] << 16 | this[He + 2] << 8 | this[He + 3]);
  }, le.prototype.readBigUInt64LE = lt(function(He) {
    He = He >>> 0, Fr(He, "offset");
    const Je = this[He], st = this[He + 7];
    (Je === void 0 || st === void 0) && an(He, this.length - 8);
    const gt = Je + this[++He] * 2 ** 8 + this[++He] * 2 ** 16 + this[++He] * 2 ** 24, kt = this[++He] + this[++He] * 2 ** 8 + this[++He] * 2 ** 16 + st * 2 ** 24;
    return BigInt(gt) + (BigInt(kt) << BigInt(32));
  }), le.prototype.readBigUInt64BE = lt(function(He) {
    He = He >>> 0, Fr(He, "offset");
    const Je = this[He], st = this[He + 7];
    (Je === void 0 || st === void 0) && an(He, this.length - 8);
    const gt = Je * 2 ** 24 + this[++He] * 2 ** 16 + this[++He] * 2 ** 8 + this[++He], kt = this[++He] * 2 ** 24 + this[++He] * 2 ** 16 + this[++He] * 2 ** 8 + st;
    return (BigInt(gt) << BigInt(32)) + BigInt(kt);
  }), le.prototype.readIntLE = function(He, Je, st) {
    He = He >>> 0, Je = Je >>> 0, st || Xe(He, Je, this.length);
    let gt = this[He], kt = 1, Vt = 0;
    for (; ++Vt < Je && (kt *= 256); )
      gt += this[He + Vt] * kt;
    return kt *= 128, gt >= kt && (gt -= Math.pow(2, 8 * Je)), gt;
  }, le.prototype.readIntBE = function(He, Je, st) {
    He = He >>> 0, Je = Je >>> 0, st || Xe(He, Je, this.length);
    let gt = Je, kt = 1, Vt = this[He + --gt];
    for (; gt > 0 && (kt *= 256); )
      Vt += this[He + --gt] * kt;
    return kt *= 128, Vt >= kt && (Vt -= Math.pow(2, 8 * Je)), Vt;
  }, le.prototype.readInt8 = function(He, Je) {
    return He = He >>> 0, Je || Xe(He, 1, this.length), this[He] & 128 ? (255 - this[He] + 1) * -1 : this[He];
  }, le.prototype.readInt16LE = function(He, Je) {
    He = He >>> 0, Je || Xe(He, 2, this.length);
    const st = this[He] | this[He + 1] << 8;
    return st & 32768 ? st | 4294901760 : st;
  }, le.prototype.readInt16BE = function(He, Je) {
    He = He >>> 0, Je || Xe(He, 2, this.length);
    const st = this[He + 1] | this[He] << 8;
    return st & 32768 ? st | 4294901760 : st;
  }, le.prototype.readInt32LE = function(He, Je) {
    return He = He >>> 0, Je || Xe(He, 4, this.length), this[He] | this[He + 1] << 8 | this[He + 2] << 16 | this[He + 3] << 24;
  }, le.prototype.readInt32BE = function(He, Je) {
    return He = He >>> 0, Je || Xe(He, 4, this.length), this[He] << 24 | this[He + 1] << 16 | this[He + 2] << 8 | this[He + 3];
  }, le.prototype.readBigInt64LE = lt(function(He) {
    He = He >>> 0, Fr(He, "offset");
    const Je = this[He], st = this[He + 7];
    (Je === void 0 || st === void 0) && an(He, this.length - 8);
    const gt = this[He + 4] + this[He + 5] * 2 ** 8 + this[He + 6] * 2 ** 16 + (st << 24);
    return (BigInt(gt) << BigInt(32)) + BigInt(Je + this[++He] * 2 ** 8 + this[++He] * 2 ** 16 + this[++He] * 2 ** 24);
  }), le.prototype.readBigInt64BE = lt(function(He) {
    He = He >>> 0, Fr(He, "offset");
    const Je = this[He], st = this[He + 7];
    (Je === void 0 || st === void 0) && an(He, this.length - 8);
    const gt = (Je << 24) + // Overflow
    this[++He] * 2 ** 16 + this[++He] * 2 ** 8 + this[++He];
    return (BigInt(gt) << BigInt(32)) + BigInt(this[++He] * 2 ** 24 + this[++He] * 2 ** 16 + this[++He] * 2 ** 8 + st);
  }), le.prototype.readFloatLE = function(He, Je) {
    return He = He >>> 0, Je || Xe(He, 4, this.length), ee.read(this, He, !0, 23, 4);
  }, le.prototype.readFloatBE = function(He, Je) {
    return He = He >>> 0, Je || Xe(He, 4, this.length), ee.read(this, He, !1, 23, 4);
  }, le.prototype.readDoubleLE = function(He, Je) {
    return He = He >>> 0, Je || Xe(He, 8, this.length), ee.read(this, He, !0, 52, 8);
  }, le.prototype.readDoubleBE = function(He, Je) {
    return He = He >>> 0, Je || Xe(He, 8, this.length), ee.read(this, He, !1, 52, 8);
  };
  function $e(He, Je, st, gt, kt, Vt) {
    if (!le.isBuffer(He))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (Je > kt || Je < Vt)
      throw new RangeError('"value" argument is out of bounds');
    if (st + gt > He.length)
      throw new RangeError("Index out of range");
  }
  le.prototype.writeUintLE = le.prototype.writeUIntLE = function(He, Je, st, gt) {
    if (He = +He, Je = Je >>> 0, st = st >>> 0, !gt) {
      const Lr = Math.pow(2, 8 * st) - 1;
      $e(this, He, Je, st, Lr, 0);
    }
    let kt = 1, Vt = 0;
    for (this[Je] = He & 255; ++Vt < st && (kt *= 256); )
      this[Je + Vt] = He / kt & 255;
    return Je + st;
  }, le.prototype.writeUintBE = le.prototype.writeUIntBE = function(He, Je, st, gt) {
    if (He = +He, Je = Je >>> 0, st = st >>> 0, !gt) {
      const Lr = Math.pow(2, 8 * st) - 1;
      $e(this, He, Je, st, Lr, 0);
    }
    let kt = st - 1, Vt = 1;
    for (this[Je + kt] = He & 255; --kt >= 0 && (Vt *= 256); )
      this[Je + kt] = He / Vt & 255;
    return Je + st;
  }, le.prototype.writeUint8 = le.prototype.writeUInt8 = function(He, Je, st) {
    return He = +He, Je = Je >>> 0, st || $e(this, He, Je, 1, 255, 0), this[Je] = He & 255, Je + 1;
  }, le.prototype.writeUint16LE = le.prototype.writeUInt16LE = function(He, Je, st) {
    return He = +He, Je = Je >>> 0, st || $e(this, He, Je, 2, 65535, 0), this[Je] = He & 255, this[Je + 1] = He >>> 8, Je + 2;
  }, le.prototype.writeUint16BE = le.prototype.writeUInt16BE = function(He, Je, st) {
    return He = +He, Je = Je >>> 0, st || $e(this, He, Je, 2, 65535, 0), this[Je] = He >>> 8, this[Je + 1] = He & 255, Je + 2;
  }, le.prototype.writeUint32LE = le.prototype.writeUInt32LE = function(He, Je, st) {
    return He = +He, Je = Je >>> 0, st || $e(this, He, Je, 4, 4294967295, 0), this[Je + 3] = He >>> 24, this[Je + 2] = He >>> 16, this[Je + 1] = He >>> 8, this[Je] = He & 255, Je + 4;
  }, le.prototype.writeUint32BE = le.prototype.writeUInt32BE = function(He, Je, st) {
    return He = +He, Je = Je >>> 0, st || $e(this, He, Je, 4, 4294967295, 0), this[Je] = He >>> 24, this[Je + 1] = He >>> 16, this[Je + 2] = He >>> 8, this[Je + 3] = He & 255, Je + 4;
  };
  function Ze(He, Je, st, gt, kt) {
    Er(Je, gt, kt, He, st, 7);
    let Vt = Number(Je & BigInt(4294967295));
    He[st++] = Vt, Vt = Vt >> 8, He[st++] = Vt, Vt = Vt >> 8, He[st++] = Vt, Vt = Vt >> 8, He[st++] = Vt;
    let Lr = Number(Je >> BigInt(32) & BigInt(4294967295));
    return He[st++] = Lr, Lr = Lr >> 8, He[st++] = Lr, Lr = Lr >> 8, He[st++] = Lr, Lr = Lr >> 8, He[st++] = Lr, st;
  }
  function ot(He, Je, st, gt, kt) {
    Er(Je, gt, kt, He, st, 7);
    let Vt = Number(Je & BigInt(4294967295));
    He[st + 7] = Vt, Vt = Vt >> 8, He[st + 6] = Vt, Vt = Vt >> 8, He[st + 5] = Vt, Vt = Vt >> 8, He[st + 4] = Vt;
    let Lr = Number(Je >> BigInt(32) & BigInt(4294967295));
    return He[st + 3] = Lr, Lr = Lr >> 8, He[st + 2] = Lr, Lr = Lr >> 8, He[st + 1] = Lr, Lr = Lr >> 8, He[st] = Lr, st + 8;
  }
  le.prototype.writeBigUInt64LE = lt(function(He, Je = 0) {
    return Ze(this, He, Je, BigInt(0), BigInt("0xffffffffffffffff"));
  }), le.prototype.writeBigUInt64BE = lt(function(He, Je = 0) {
    return ot(this, He, Je, BigInt(0), BigInt("0xffffffffffffffff"));
  }), le.prototype.writeIntLE = function(He, Je, st, gt) {
    if (He = +He, Je = Je >>> 0, !gt) {
      const Ci = Math.pow(2, 8 * st - 1);
      $e(this, He, Je, st, Ci - 1, -Ci);
    }
    let kt = 0, Vt = 1, Lr = 0;
    for (this[Je] = He & 255; ++kt < st && (Vt *= 256); )
      He < 0 && Lr === 0 && this[Je + kt - 1] !== 0 && (Lr = 1), this[Je + kt] = (He / Vt >> 0) - Lr & 255;
    return Je + st;
  }, le.prototype.writeIntBE = function(He, Je, st, gt) {
    if (He = +He, Je = Je >>> 0, !gt) {
      const Ci = Math.pow(2, 8 * st - 1);
      $e(this, He, Je, st, Ci - 1, -Ci);
    }
    let kt = st - 1, Vt = 1, Lr = 0;
    for (this[Je + kt] = He & 255; --kt >= 0 && (Vt *= 256); )
      He < 0 && Lr === 0 && this[Je + kt + 1] !== 0 && (Lr = 1), this[Je + kt] = (He / Vt >> 0) - Lr & 255;
    return Je + st;
  }, le.prototype.writeInt8 = function(He, Je, st) {
    return He = +He, Je = Je >>> 0, st || $e(this, He, Je, 1, 127, -128), He < 0 && (He = 255 + He + 1), this[Je] = He & 255, Je + 1;
  }, le.prototype.writeInt16LE = function(He, Je, st) {
    return He = +He, Je = Je >>> 0, st || $e(this, He, Je, 2, 32767, -32768), this[Je] = He & 255, this[Je + 1] = He >>> 8, Je + 2;
  }, le.prototype.writeInt16BE = function(He, Je, st) {
    return He = +He, Je = Je >>> 0, st || $e(this, He, Je, 2, 32767, -32768), this[Je] = He >>> 8, this[Je + 1] = He & 255, Je + 2;
  }, le.prototype.writeInt32LE = function(He, Je, st) {
    return He = +He, Je = Je >>> 0, st || $e(this, He, Je, 4, 2147483647, -2147483648), this[Je] = He & 255, this[Je + 1] = He >>> 8, this[Je + 2] = He >>> 16, this[Je + 3] = He >>> 24, Je + 4;
  }, le.prototype.writeInt32BE = function(He, Je, st) {
    return He = +He, Je = Je >>> 0, st || $e(this, He, Je, 4, 2147483647, -2147483648), He < 0 && (He = 4294967295 + He + 1), this[Je] = He >>> 24, this[Je + 1] = He >>> 16, this[Je + 2] = He >>> 8, this[Je + 3] = He & 255, Je + 4;
  }, le.prototype.writeBigInt64LE = lt(function(He, Je = 0) {
    return Ze(this, He, Je, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), le.prototype.writeBigInt64BE = lt(function(He, Je = 0) {
    return ot(this, He, Je, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function ct(He, Je, st, gt, kt, Vt) {
    if (st + gt > He.length)
      throw new RangeError("Index out of range");
    if (st < 0)
      throw new RangeError("Index out of range");
  }
  function At(He, Je, st, gt, kt) {
    return Je = +Je, st = st >>> 0, kt || ct(He, Je, st, 4), ee.write(He, Je, st, gt, 23, 4), st + 4;
  }
  le.prototype.writeFloatLE = function(He, Je, st) {
    return At(this, He, Je, !0, st);
  }, le.prototype.writeFloatBE = function(He, Je, st) {
    return At(this, He, Je, !1, st);
  };
  function Tt(He, Je, st, gt, kt) {
    return Je = +Je, st = st >>> 0, kt || ct(He, Je, st, 8), ee.write(He, Je, st, gt, 52, 8), st + 8;
  }
  le.prototype.writeDoubleLE = function(He, Je, st) {
    return Tt(this, He, Je, !0, st);
  }, le.prototype.writeDoubleBE = function(He, Je, st) {
    return Tt(this, He, Je, !1, st);
  }, le.prototype.copy = function(He, Je, st, gt) {
    if (!le.isBuffer(He))
      throw new TypeError("argument should be a Buffer");
    if (st || (st = 0), !gt && gt !== 0 && (gt = this.length), Je >= He.length && (Je = He.length), Je || (Je = 0), gt > 0 && gt < st && (gt = st), gt === st || He.length === 0 || this.length === 0)
      return 0;
    if (Je < 0)
      throw new RangeError("targetStart out of bounds");
    if (st < 0 || st >= this.length)
      throw new RangeError("Index out of range");
    if (gt < 0)
      throw new RangeError("sourceEnd out of bounds");
    gt > this.length && (gt = this.length), He.length - Je < gt - st && (gt = He.length - Je + st);
    const kt = gt - st;
    return this === He && typeof ie.prototype.copyWithin == "function" ? this.copyWithin(Je, st, gt) : ie.prototype.set.call(
      He,
      this.subarray(st, gt),
      Je
    ), kt;
  }, le.prototype.fill = function(He, Je, st, gt) {
    if (typeof He == "string") {
      if (typeof Je == "string" ? (gt = Je, Je = 0, st = this.length) : typeof st == "string" && (gt = st, st = this.length), gt !== void 0 && typeof gt != "string")
        throw new TypeError("encoding must be a string");
      if (typeof gt == "string" && !le.isEncoding(gt))
        throw new TypeError("Unknown encoding: " + gt);
      if (He.length === 1) {
        const Vt = He.charCodeAt(0);
        (gt === "utf8" && Vt < 128 || gt === "latin1") && (He = Vt);
      }
    } else
      typeof He == "number" ? He = He & 255 : typeof He == "boolean" && (He = Number(He));
    if (Je < 0 || this.length < Je || this.length < st)
      throw new RangeError("Out of range index");
    if (st <= Je)
      return this;
    Je = Je >>> 0, st = st === void 0 ? this.length : st >>> 0, He || (He = 0);
    let kt;
    if (typeof He == "number")
      for (kt = Je; kt < st; ++kt)
        this[kt] = He;
    else {
      const Vt = le.isBuffer(He) ? He : le.from(He, gt), Lr = Vt.length;
      if (Lr === 0)
        throw new TypeError('The value "' + He + '" is invalid for argument "value"');
      for (kt = 0; kt < st - Je; ++kt)
        this[kt + Je] = Vt[kt % Lr];
    }
    return this;
  };
  const dt = {};
  function vt(He, Je, st) {
    dt[He] = class extends st {
      constructor() {
        super(), Object.defineProperty(this, "message", {
          value: Je.apply(this, arguments),
          writable: !0,
          configurable: !0
        }), this.name = `${this.name} [${He}]`, this.stack, delete this.name;
      }
      get code() {
        return He;
      }
      set code(gt) {
        Object.defineProperty(this, "code", {
          configurable: !0,
          enumerable: !0,
          value: gt,
          writable: !0
        });
      }
      toString() {
        return `${this.name} [${He}]: ${this.message}`;
      }
    };
  }
  vt(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(He) {
      return He ? `${He} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    },
    RangeError
  ), vt(
    "ERR_INVALID_ARG_TYPE",
    function(He, Je) {
      return `The "${He}" argument must be of type number. Received type ${typeof Je}`;
    },
    TypeError
  ), vt(
    "ERR_OUT_OF_RANGE",
    function(He, Je, st) {
      let gt = `The value of "${He}" is out of range.`, kt = st;
      return Number.isInteger(st) && Math.abs(st) > 2 ** 32 ? kt = Ut(String(st)) : typeof st == "bigint" && (kt = String(st), (st > BigInt(2) ** BigInt(32) || st < -(BigInt(2) ** BigInt(32))) && (kt = Ut(kt)), kt += "n"), gt += ` It must be ${Je}. Received ${kt}`, gt;
    },
    RangeError
  );
  function Ut(He) {
    let Je = "", st = He.length;
    const gt = He[0] === "-" ? 1 : 0;
    for (; st >= gt + 4; st -= 3)
      Je = `_${He.slice(st - 3, st)}${Je}`;
    return `${He.slice(0, st)}${Je}`;
  }
  function It(He, Je, st) {
    Fr(Je, "offset"), (He[Je] === void 0 || He[Je + st] === void 0) && an(Je, He.length - (st + 1));
  }
  function Er(He, Je, st, gt, kt, Vt) {
    if (He > st || He < Je) {
      const Lr = typeof Je == "bigint" ? "n" : "";
      let Ci;
      throw Vt > 3 ? Je === 0 || Je === BigInt(0) ? Ci = `>= 0${Lr} and < 2${Lr} ** ${(Vt + 1) * 8}${Lr}` : Ci = `>= -(2${Lr} ** ${(Vt + 1) * 8 - 1}${Lr}) and < 2 ** ${(Vt + 1) * 8 - 1}${Lr}` : Ci = `>= ${Je}${Lr} and <= ${st}${Lr}`, new dt.ERR_OUT_OF_RANGE("value", Ci, He);
    }
    It(gt, kt, Vt);
  }
  function Fr(He, Je) {
    if (typeof He != "number")
      throw new dt.ERR_INVALID_ARG_TYPE(Je, "number", He);
  }
  function an(He, Je, st) {
    throw Math.floor(He) !== He ? (Fr(He, st), new dt.ERR_OUT_OF_RANGE(st || "offset", "an integer", He)) : Je < 0 ? new dt.ERR_BUFFER_OUT_OF_BOUNDS() : new dt.ERR_OUT_OF_RANGE(
      st || "offset",
      `>= ${st ? 1 : 0} and <= ${Je}`,
      He
    );
  }
  const wX = /[^+/0-9A-Za-z-_]/g;
  function Ct(He) {
    if (He = He.split("=")[0], He = He.trim().replace(wX, ""), He.length < 2)
      return "";
    for (; He.length % 4 !== 0; )
      He = He + "=";
    return He;
  }
  function w_(He, Je) {
    Je = Je || 1 / 0;
    let st;
    const gt = He.length;
    let kt = null;
    const Vt = [];
    for (let Lr = 0; Lr < gt; ++Lr) {
      if (st = He.charCodeAt(Lr), st > 55295 && st < 57344) {
        if (!kt) {
          if (st > 56319) {
            (Je -= 3) > -1 && Vt.push(239, 191, 189);
            continue;
          } else if (Lr + 1 === gt) {
            (Je -= 3) > -1 && Vt.push(239, 191, 189);
            continue;
          }
          kt = st;
          continue;
        }
        if (st < 56320) {
          (Je -= 3) > -1 && Vt.push(239, 191, 189), kt = st;
          continue;
        }
        st = (kt - 55296 << 10 | st - 56320) + 65536;
      } else
        kt && (Je -= 3) > -1 && Vt.push(239, 191, 189);
      if (kt = null, st < 128) {
        if ((Je -= 1) < 0)
          break;
        Vt.push(st);
      } else if (st < 2048) {
        if ((Je -= 2) < 0)
          break;
        Vt.push(
          st >> 6 | 192,
          st & 63 | 128
        );
      } else if (st < 65536) {
        if ((Je -= 3) < 0)
          break;
        Vt.push(
          st >> 12 | 224,
          st >> 6 & 63 | 128,
          st & 63 | 128
        );
      } else if (st < 1114112) {
        if ((Je -= 4) < 0)
          break;
        Vt.push(
          st >> 18 | 240,
          st >> 12 & 63 | 128,
          st >> 6 & 63 | 128,
          st & 63 | 128
        );
      } else
        throw new Error("Invalid code point");
    }
    return Vt;
  }
  function hX(He) {
    const Je = [];
    for (let st = 0; st < He.length; ++st)
      Je.push(He.charCodeAt(st) & 255);
    return Je;
  }
  function oX(He, Je) {
    let st, gt, kt;
    const Vt = [];
    for (let Lr = 0; Lr < He.length && !((Je -= 2) < 0); ++Lr)
      st = He.charCodeAt(Lr), gt = st >> 8, kt = st % 256, Vt.push(kt), Vt.push(gt);
    return Vt;
  }
  function Nn(He) {
    return X.toByteArray(Ct(He));
  }
  function SX(He, Je, st, gt) {
    let kt;
    for (kt = 0; kt < gt && !(kt + st >= Je.length || kt >= He.length); ++kt)
      Je[kt + st] = He[kt];
    return kt;
  }
  function sX(He, Je) {
    return He instanceof Je || He != null && He.constructor != null && He.constructor.name != null && He.constructor.name === Je.name;
  }
  function nX(He) {
    return He !== He;
  }
  const Ye = function() {
    const He = "0123456789abcdef", Je = new Array(256);
    for (let st = 0; st < 16; ++st) {
      const gt = st * 16;
      for (let kt = 0; kt < 16; ++kt)
        Je[gt + kt] = He[st] + He[kt];
    }
    return Je;
  }();
  function lt(He) {
    return typeof BigInt > "u" ? pt : He;
  }
  function pt() {
    throw new Error("BigInt not supported");
  }
})(buffer$1);
const Buffer$e = buffer$1.Buffer, Blob$2 = buffer$1.Blob, BlobOptions = buffer$1.BlobOptions, Buffer$1$1 = buffer$1.Buffer, File$1 = buffer$1.File, FileOptions = buffer$1.FileOptions, INSPECT_MAX_BYTES = buffer$1.INSPECT_MAX_BYTES, SlowBuffer = buffer$1.SlowBuffer, TranscodeEncoding = buffer$1.TranscodeEncoding, atob$1 = buffer$1.atob, btoa$1 = buffer$1.btoa, constants$1 = buffer$1.constants, isAscii = buffer$1.isAscii, isUtf8 = buffer$1.isUtf8, kMaxLength = buffer$1.kMaxLength, kStringMaxLength = buffer$1.kStringMaxLength, resolveObjectURL = buffer$1.resolveObjectURL, transcode = buffer$1.transcode, dist$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Blob: Blob$2,
  BlobOptions,
  Buffer: Buffer$1$1,
  File: File$1,
  FileOptions,
  INSPECT_MAX_BYTES,
  SlowBuffer,
  TranscodeEncoding,
  atob: atob$1,
  btoa: btoa$1,
  constants: constants$1,
  default: Buffer$e,
  isAscii,
  isUtf8,
  kMaxLength,
  kStringMaxLength,
  resolveObjectURL,
  transcode
}, Symbol.toStringTag, { value: "Module" }));
var commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" || typeof window < "u" ? window : typeof self < "u" ? self : {};
function getDefaultExportFromCjs$2(Y) {
  return Y && Y.__esModule && Object.prototype.hasOwnProperty.call(Y, "default") ? Y.default : Y;
}
function getAugmentedNamespace(Y) {
  if (Y.__esModule)
    return Y;
  var X = Y.default;
  if (typeof X == "function") {
    var ee = function te() {
      return this instanceof te ? Reflect.construct(X, arguments, this.constructor) : X.apply(this, arguments);
    };
    ee.prototype = X.prototype;
  } else
    ee = {};
  return Object.defineProperty(ee, "__esModule", { value: !0 }), Object.keys(Y).forEach(function(te) {
    var ne = Object.getOwnPropertyDescriptor(Y, te);
    Object.defineProperty(ee, te, ne.get ? ne : {
      enumerable: !0,
      get: function() {
        return Y[te];
      }
    });
  }), ee;
}
var dist = {}, inherits_browser = { exports: {} };
typeof Object.create == "function" ? inherits_browser.exports = function(Y, X) {
  X && (Y.super_ = X, Y.prototype = Object.create(X.prototype, {
    constructor: {
      value: Y,
      enumerable: !1,
      writable: !0,
      configurable: !0
    }
  }));
} : inherits_browser.exports = function(Y, X) {
  if (X) {
    Y.super_ = X;
    var ee = function() {
    };
    ee.prototype = X.prototype, Y.prototype = new ee(), Y.prototype.constructor = Y;
  }
};
var inherits_browserExports = inherits_browser.exports, safeBuffer = { exports: {} };
const require$$0$3 = /* @__PURE__ */ getAugmentedNamespace(dist$1);
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
(function(Y, X) {
  var ee = require$$0$3, te = ee.Buffer;
  function ne(oe, se) {
    for (var ae in oe)
      se[ae] = oe[ae];
  }
  te.from && te.alloc && te.allocUnsafe && te.allocUnsafeSlow ? Y.exports = ee : (ne(ee, X), X.Buffer = ie);
  function ie(oe, se, ae) {
    return te(oe, se, ae);
  }
  ie.prototype = Object.create(te.prototype), ne(te, ie), ie.from = function(oe, se, ae) {
    if (typeof oe == "number")
      throw new TypeError("Argument must not be a number");
    return te(oe, se, ae);
  }, ie.alloc = function(oe, se, ae) {
    if (typeof oe != "number")
      throw new TypeError("Argument must be a number");
    var ue = te(oe);
    return se !== void 0 ? typeof ae == "string" ? ue.fill(se, ae) : ue.fill(se) : ue.fill(0), ue;
  }, ie.allocUnsafe = function(oe) {
    if (typeof oe != "number")
      throw new TypeError("Argument must be a number");
    return te(oe);
  }, ie.allocUnsafeSlow = function(oe) {
    if (typeof oe != "number")
      throw new TypeError("Argument must be a number");
    return ee.SlowBuffer(oe);
  };
})(safeBuffer, safeBuffer.exports);
var safeBufferExports = safeBuffer.exports, events = { exports: {} }, R = typeof Reflect == "object" ? Reflect : null, ReflectApply = R && typeof R.apply == "function" ? R.apply : function(Y, X, ee) {
  return Function.prototype.apply.call(Y, X, ee);
}, ReflectOwnKeys;
R && typeof R.ownKeys == "function" ? ReflectOwnKeys = R.ownKeys : Object.getOwnPropertySymbols ? ReflectOwnKeys = function(Y) {
  return Object.getOwnPropertyNames(Y).concat(Object.getOwnPropertySymbols(Y));
} : ReflectOwnKeys = function(Y) {
  return Object.getOwnPropertyNames(Y);
};
function ProcessEmitWarning(Y) {
  console && console.warn && console.warn(Y);
}
var NumberIsNaN = Number.isNaN || function(Y) {
  return Y !== Y;
};
function EventEmitter() {
  EventEmitter.init.call(this);
}
events.exports = EventEmitter;
events.exports.once = once$2;
EventEmitter.EventEmitter = EventEmitter;
EventEmitter.prototype._events = void 0;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = void 0;
var defaultMaxListeners = 10;
function checkListener(Y) {
  if (typeof Y != "function")
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof Y);
}
Object.defineProperty(EventEmitter, "defaultMaxListeners", {
  enumerable: !0,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(Y) {
    if (typeof Y != "number" || Y < 0 || NumberIsNaN(Y))
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + Y + ".");
    defaultMaxListeners = Y;
  }
});
EventEmitter.init = function() {
  (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
};
EventEmitter.prototype.setMaxListeners = function(Y) {
  if (typeof Y != "number" || Y < 0 || NumberIsNaN(Y))
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + Y + ".");
  return this._maxListeners = Y, this;
};
function _getMaxListeners(Y) {
  return Y._maxListeners === void 0 ? EventEmitter.defaultMaxListeners : Y._maxListeners;
}
EventEmitter.prototype.getMaxListeners = function() {
  return _getMaxListeners(this);
};
EventEmitter.prototype.emit = function(Y) {
  for (var X = [], ee = 1; ee < arguments.length; ee++)
    X.push(arguments[ee]);
  var te = Y === "error", ne = this._events;
  if (ne !== void 0)
    te = te && ne.error === void 0;
  else if (!te)
    return !1;
  if (te) {
    var ie;
    if (X.length > 0 && (ie = X[0]), ie instanceof Error)
      throw ie;
    var oe = new Error("Unhandled error." + (ie ? " (" + ie.message + ")" : ""));
    throw oe.context = ie, oe;
  }
  var se = ne[Y];
  if (se === void 0)
    return !1;
  if (typeof se == "function")
    ReflectApply(se, this, X);
  else
    for (var ae = se.length, ue = arrayClone(se, ae), ee = 0; ee < ae; ++ee)
      ReflectApply(ue[ee], this, X);
  return !0;
};
function _addListener(Y, X, ee, te) {
  var ne, ie, oe;
  if (checkListener(ee), ie = Y._events, ie === void 0 ? (ie = Y._events = /* @__PURE__ */ Object.create(null), Y._eventsCount = 0) : (ie.newListener !== void 0 && (Y.emit(
    "newListener",
    X,
    ee.listener ? ee.listener : ee
  ), ie = Y._events), oe = ie[X]), oe === void 0)
    oe = ie[X] = ee, ++Y._eventsCount;
  else if (typeof oe == "function" ? oe = ie[X] = te ? [ee, oe] : [oe, ee] : te ? oe.unshift(ee) : oe.push(ee), ne = _getMaxListeners(Y), ne > 0 && oe.length > ne && !oe.warned) {
    oe.warned = !0;
    var se = new Error("Possible EventEmitter memory leak detected. " + oe.length + " " + String(X) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    se.name = "MaxListenersExceededWarning", se.emitter = Y, se.type = X, se.count = oe.length, ProcessEmitWarning(se);
  }
  return Y;
}
EventEmitter.prototype.addListener = function(Y, X) {
  return _addListener(this, Y, X, !1);
};
EventEmitter.prototype.on = EventEmitter.prototype.addListener;
EventEmitter.prototype.prependListener = function(Y, X) {
  return _addListener(this, Y, X, !0);
};
function onceWrapper() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function _onceWrap(Y, X, ee) {
  var te = { fired: !1, wrapFn: void 0, target: Y, type: X, listener: ee }, ne = onceWrapper.bind(te);
  return ne.listener = ee, te.wrapFn = ne, ne;
}
EventEmitter.prototype.once = function(Y, X) {
  return checkListener(X), this.on(Y, _onceWrap(this, Y, X)), this;
};
EventEmitter.prototype.prependOnceListener = function(Y, X) {
  return checkListener(X), this.prependListener(Y, _onceWrap(this, Y, X)), this;
};
EventEmitter.prototype.removeListener = function(Y, X) {
  var ee, te, ne, ie, oe;
  if (checkListener(X), te = this._events, te === void 0)
    return this;
  if (ee = te[Y], ee === void 0)
    return this;
  if (ee === X || ee.listener === X)
    --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete te[Y], te.removeListener && this.emit("removeListener", Y, ee.listener || X));
  else if (typeof ee != "function") {
    for (ne = -1, ie = ee.length - 1; ie >= 0; ie--)
      if (ee[ie] === X || ee[ie].listener === X) {
        oe = ee[ie].listener, ne = ie;
        break;
      }
    if (ne < 0)
      return this;
    ne === 0 ? ee.shift() : spliceOne(ee, ne), ee.length === 1 && (te[Y] = ee[0]), te.removeListener !== void 0 && this.emit("removeListener", Y, oe || X);
  }
  return this;
};
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.removeAllListeners = function(Y) {
  var X, ee, te;
  if (ee = this._events, ee === void 0)
    return this;
  if (ee.removeListener === void 0)
    return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : ee[Y] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete ee[Y]), this;
  if (arguments.length === 0) {
    var ne = Object.keys(ee), ie;
    for (te = 0; te < ne.length; ++te)
      ie = ne[te], ie !== "removeListener" && this.removeAllListeners(ie);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if (X = ee[Y], typeof X == "function")
    this.removeListener(Y, X);
  else if (X !== void 0)
    for (te = X.length - 1; te >= 0; te--)
      this.removeListener(Y, X[te]);
  return this;
};
function _listeners(Y, X, ee) {
  var te = Y._events;
  if (te === void 0)
    return [];
  var ne = te[X];
  return ne === void 0 ? [] : typeof ne == "function" ? ee ? [ne.listener || ne] : [ne] : ee ? unwrapListeners(ne) : arrayClone(ne, ne.length);
}
EventEmitter.prototype.listeners = function(Y) {
  return _listeners(this, Y, !0);
};
EventEmitter.prototype.rawListeners = function(Y) {
  return _listeners(this, Y, !1);
};
EventEmitter.listenerCount = function(Y, X) {
  return typeof Y.listenerCount == "function" ? Y.listenerCount(X) : listenerCount.call(Y, X);
};
EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(Y) {
  var X = this._events;
  if (X !== void 0) {
    var ee = X[Y];
    if (typeof ee == "function")
      return 1;
    if (ee !== void 0)
      return ee.length;
  }
  return 0;
}
EventEmitter.prototype.eventNames = function() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};
function arrayClone(Y, X) {
  for (var ee = new Array(X), te = 0; te < X; ++te)
    ee[te] = Y[te];
  return ee;
}
function spliceOne(Y, X) {
  for (; X + 1 < Y.length; X++)
    Y[X] = Y[X + 1];
  Y.pop();
}
function unwrapListeners(Y) {
  for (var X = new Array(Y.length), ee = 0; ee < X.length; ++ee)
    X[ee] = Y[ee].listener || Y[ee];
  return X;
}
function once$2(Y, X) {
  return new Promise(function(ee, te) {
    function ne(oe) {
      Y.removeListener(X, ie), te(oe);
    }
    function ie() {
      typeof Y.removeListener == "function" && Y.removeListener("error", ne), ee([].slice.call(arguments));
    }
    eventTargetAgnosticAddListener(Y, X, ie, { once: !0 }), X !== "error" && addErrorHandlerIfEventEmitter(Y, ne, { once: !0 });
  });
}
function addErrorHandlerIfEventEmitter(Y, X, ee) {
  typeof Y.on == "function" && eventTargetAgnosticAddListener(Y, "error", X, ee);
}
function eventTargetAgnosticAddListener(Y, X, ee, te) {
  if (typeof Y.on == "function")
    te.once ? Y.once(X, ee) : Y.on(X, ee);
  else if (typeof Y.addEventListener == "function")
    Y.addEventListener(X, function ne(ie) {
      te.once && Y.removeEventListener(X, ne), ee(ie);
    });
  else
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof Y);
}
var eventsExports = events.exports;
function getDefaultExportFromCjs$1(Y) {
  return Y && Y.__esModule && Object.prototype.hasOwnProperty.call(Y, "default") ? Y.default : Y;
}
var browser$e = { exports: {} }, process$1 = browser$e.exports = {}, cachedSetTimeout, cachedClearTimeout;
function defaultSetTimout() {
  throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout() {
  throw new Error("clearTimeout has not been defined");
}
(function() {
  try {
    typeof setTimeout == "function" ? cachedSetTimeout = setTimeout : cachedSetTimeout = defaultSetTimout;
  } catch {
    cachedSetTimeout = defaultSetTimout;
  }
  try {
    typeof clearTimeout == "function" ? cachedClearTimeout = clearTimeout : cachedClearTimeout = defaultClearTimeout;
  } catch {
    cachedClearTimeout = defaultClearTimeout;
  }
})();
function runTimeout(Y) {
  if (cachedSetTimeout === setTimeout)
    return setTimeout(Y, 0);
  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout)
    return cachedSetTimeout = setTimeout, setTimeout(Y, 0);
  try {
    return cachedSetTimeout(Y, 0);
  } catch {
    try {
      return cachedSetTimeout.call(null, Y, 0);
    } catch {
      return cachedSetTimeout.call(this, Y, 0);
    }
  }
}
function runClearTimeout(Y) {
  if (cachedClearTimeout === clearTimeout)
    return clearTimeout(Y);
  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout)
    return cachedClearTimeout = clearTimeout, clearTimeout(Y);
  try {
    return cachedClearTimeout(Y);
  } catch {
    try {
      return cachedClearTimeout.call(null, Y);
    } catch {
      return cachedClearTimeout.call(this, Y);
    }
  }
}
var queue = [], draining = !1, currentQueue, queueIndex = -1;
function cleanUpNextTick() {
  !draining || !currentQueue || (draining = !1, currentQueue.length ? queue = currentQueue.concat(queue) : queueIndex = -1, queue.length && drainQueue());
}
function drainQueue() {
  if (!draining) {
    var Y = runTimeout(cleanUpNextTick);
    draining = !0;
    for (var X = queue.length; X; ) {
      for (currentQueue = queue, queue = []; ++queueIndex < X; )
        currentQueue && currentQueue[queueIndex].run();
      queueIndex = -1, X = queue.length;
    }
    currentQueue = null, draining = !1, runClearTimeout(Y);
  }
}
process$1.nextTick = function(Y) {
  var X = new Array(arguments.length - 1);
  if (arguments.length > 1)
    for (var ee = 1; ee < arguments.length; ee++)
      X[ee - 1] = arguments[ee];
  queue.push(new Item(Y, X)), queue.length === 1 && !draining && runTimeout(drainQueue);
};
function Item(Y, X) {
  this.fun = Y, this.array = X;
}
Item.prototype.run = function() {
  this.fun.apply(null, this.array);
};
process$1.title = "browser";
process$1.browser = !0;
process$1.env = {};
process$1.argv = [];
process$1.version = "";
process$1.versions = {};
function noop$2() {
}
process$1.on = noop$2;
process$1.addListener = noop$2;
process$1.once = noop$2;
process$1.off = noop$2;
process$1.removeListener = noop$2;
process$1.removeAllListeners = noop$2;
process$1.emit = noop$2;
process$1.prependListener = noop$2;
process$1.prependOnceListener = noop$2;
process$1.listeners = function(Y) {
  return [];
};
process$1.binding = function(Y) {
  throw new Error("process.binding is not supported");
};
process$1.cwd = function() {
  return "/";
};
process$1.chdir = function(Y) {
  throw new Error("process.chdir is not supported");
};
process$1.umask = function() {
  return 0;
};
var browserExports = browser$e.exports;
const process$1$1 = /* @__PURE__ */ getDefaultExportFromCjs$1(browserExports);
var streamBrowser = eventsExports.EventEmitter, util = {}, types = {}, shams$1 = function() {
  if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
    return !1;
  if (typeof Symbol.iterator == "symbol")
    return !0;
  var Y = {}, X = Symbol("test"), ee = Object(X);
  if (typeof X == "string" || Object.prototype.toString.call(X) !== "[object Symbol]" || Object.prototype.toString.call(ee) !== "[object Symbol]")
    return !1;
  var te = 42;
  Y[X] = te;
  for (X in Y)
    return !1;
  if (typeof Object.keys == "function" && Object.keys(Y).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(Y).length !== 0)
    return !1;
  var ne = Object.getOwnPropertySymbols(Y);
  if (ne.length !== 1 || ne[0] !== X || !Object.prototype.propertyIsEnumerable.call(Y, X))
    return !1;
  if (typeof Object.getOwnPropertyDescriptor == "function") {
    var ie = Object.getOwnPropertyDescriptor(Y, X);
    if (ie.value !== te || ie.enumerable !== !0)
      return !1;
  }
  return !0;
}, hasSymbols$2 = shams$1, shams = function() {
  return hasSymbols$2() && !!Symbol.toStringTag;
}, esErrors = Error, _eval = EvalError, range = RangeError, ref = ReferenceError, syntax = SyntaxError, type$1 = TypeError, uri = URIError, origSymbol = typeof Symbol < "u" && Symbol, hasSymbolSham = shams$1, hasSymbols$1 = function() {
  return typeof origSymbol != "function" || typeof Symbol != "function" || typeof origSymbol("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : hasSymbolSham();
}, test = {
  __proto__: null,
  foo: {}
}, $Object = Object, hasProto$1 = function() {
  return { __proto__: test }.foo === test.foo && !(test instanceof $Object);
}, ERROR_MESSAGE = "Function.prototype.bind called on incompatible ", toStr$3 = Object.prototype.toString, max = Math.max, funcType = "[object Function]", concatty = function(Y, X) {
  for (var ee = [], te = 0; te < Y.length; te += 1)
    ee[te] = Y[te];
  for (var ne = 0; ne < X.length; ne += 1)
    ee[ne + Y.length] = X[ne];
  return ee;
}, slicy = function(Y, X) {
  for (var ee = [], te = X || 0, ne = 0; te < Y.length; te += 1, ne += 1)
    ee[ne] = Y[te];
  return ee;
}, joiny = function(Y, X) {
  for (var ee = "", te = 0; te < Y.length; te += 1)
    ee += Y[te], te + 1 < Y.length && (ee += X);
  return ee;
}, implementation$1 = function(Y) {
  var X = this;
  if (typeof X != "function" || toStr$3.apply(X) !== funcType)
    throw new TypeError(ERROR_MESSAGE + X);
  for (var ee = slicy(arguments, 1), te, ne = function() {
    if (this instanceof te) {
      var ue = X.apply(
        this,
        concatty(ee, arguments)
      );
      return Object(ue) === ue ? ue : this;
    }
    return X.apply(
      Y,
      concatty(ee, arguments)
    );
  }, ie = max(0, X.length - ee.length), oe = [], se = 0; se < ie; se++)
    oe[se] = "$" + se;
  if (te = Function("binder", "return function (" + joiny(oe, ",") + "){ return binder.apply(this,arguments); }")(ne), X.prototype) {
    var ae = function() {
    };
    ae.prototype = X.prototype, te.prototype = new ae(), ae.prototype = null;
  }
  return te;
}, implementation = implementation$1, functionBind = Function.prototype.bind || implementation, call$1 = Function.prototype.call, $hasOwn = Object.prototype.hasOwnProperty, bind$1 = functionBind, hasown = bind$1.call(call$1, $hasOwn), undefined$1, $Error = esErrors, $EvalError = _eval, $RangeError = range, $ReferenceError = ref, $SyntaxError$1 = syntax, $TypeError$2 = type$1, $URIError = uri, $Function = Function, getEvalledConstructor = function(Y) {
  try {
    return $Function('"use strict"; return (' + Y + ").constructor;")();
  } catch {
  }
}, $gOPD$1 = Object.getOwnPropertyDescriptor;
if ($gOPD$1)
  try {
    $gOPD$1({}, "");
  } catch {
    $gOPD$1 = null;
  }
var throwTypeError = function() {
  throw new $TypeError$2();
}, ThrowTypeError = $gOPD$1 ? function() {
  try {
    return arguments.callee, throwTypeError;
  } catch {
    try {
      return $gOPD$1(arguments, "callee").get;
    } catch {
      return throwTypeError;
    }
  }
}() : throwTypeError, hasSymbols = hasSymbols$1(), hasProto = hasProto$1(), getProto$1 = Object.getPrototypeOf || (hasProto ? function(Y) {
  return Y.__proto__;
} : null), needsEval = {}, TypedArray = typeof Uint8Array > "u" || !getProto$1 ? undefined$1 : getProto$1(Uint8Array), INTRINSICS = {
  __proto__: null,
  "%AggregateError%": typeof AggregateError > "u" ? undefined$1 : AggregateError,
  "%Array%": Array,
  "%ArrayBuffer%": typeof ArrayBuffer > "u" ? undefined$1 : ArrayBuffer,
  "%ArrayIteratorPrototype%": hasSymbols && getProto$1 ? getProto$1([][Symbol.iterator]()) : undefined$1,
  "%AsyncFromSyncIteratorPrototype%": undefined$1,
  "%AsyncFunction%": needsEval,
  "%AsyncGenerator%": needsEval,
  "%AsyncGeneratorFunction%": needsEval,
  "%AsyncIteratorPrototype%": needsEval,
  "%Atomics%": typeof Atomics > "u" ? undefined$1 : Atomics,
  "%BigInt%": typeof BigInt > "u" ? undefined$1 : BigInt,
  "%BigInt64Array%": typeof BigInt64Array > "u" ? undefined$1 : BigInt64Array,
  "%BigUint64Array%": typeof BigUint64Array > "u" ? undefined$1 : BigUint64Array,
  "%Boolean%": Boolean,
  "%DataView%": typeof DataView > "u" ? undefined$1 : DataView,
  "%Date%": Date,
  "%decodeURI%": decodeURI,
  "%decodeURIComponent%": decodeURIComponent,
  "%encodeURI%": encodeURI,
  "%encodeURIComponent%": encodeURIComponent,
  "%Error%": $Error,
  "%eval%": eval,
  // eslint-disable-line no-eval
  "%EvalError%": $EvalError,
  "%Float32Array%": typeof Float32Array > "u" ? undefined$1 : Float32Array,
  "%Float64Array%": typeof Float64Array > "u" ? undefined$1 : Float64Array,
  "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? undefined$1 : FinalizationRegistry,
  "%Function%": $Function,
  "%GeneratorFunction%": needsEval,
  "%Int8Array%": typeof Int8Array > "u" ? undefined$1 : Int8Array,
  "%Int16Array%": typeof Int16Array > "u" ? undefined$1 : Int16Array,
  "%Int32Array%": typeof Int32Array > "u" ? undefined$1 : Int32Array,
  "%isFinite%": isFinite,
  "%isNaN%": isNaN,
  "%IteratorPrototype%": hasSymbols && getProto$1 ? getProto$1(getProto$1([][Symbol.iterator]())) : undefined$1,
  "%JSON%": typeof JSON == "object" ? JSON : undefined$1,
  "%Map%": typeof Map > "u" ? undefined$1 : Map,
  "%MapIteratorPrototype%": typeof Map > "u" || !hasSymbols || !getProto$1 ? undefined$1 : getProto$1((/* @__PURE__ */ new Map())[Symbol.iterator]()),
  "%Math%": Math,
  "%Number%": Number,
  "%Object%": Object,
  "%parseFloat%": parseFloat,
  "%parseInt%": parseInt,
  "%Promise%": typeof Promise > "u" ? undefined$1 : Promise,
  "%Proxy%": typeof Proxy > "u" ? undefined$1 : Proxy,
  "%RangeError%": $RangeError,
  "%ReferenceError%": $ReferenceError,
  "%Reflect%": typeof Reflect > "u" ? undefined$1 : Reflect,
  "%RegExp%": RegExp,
  "%Set%": typeof Set > "u" ? undefined$1 : Set,
  "%SetIteratorPrototype%": typeof Set > "u" || !hasSymbols || !getProto$1 ? undefined$1 : getProto$1((/* @__PURE__ */ new Set())[Symbol.iterator]()),
  "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? undefined$1 : SharedArrayBuffer,
  "%String%": String,
  "%StringIteratorPrototype%": hasSymbols && getProto$1 ? getProto$1(""[Symbol.iterator]()) : undefined$1,
  "%Symbol%": hasSymbols ? Symbol : undefined$1,
  "%SyntaxError%": $SyntaxError$1,
  "%ThrowTypeError%": ThrowTypeError,
  "%TypedArray%": TypedArray,
  "%TypeError%": $TypeError$2,
  "%Uint8Array%": typeof Uint8Array > "u" ? undefined$1 : Uint8Array,
  "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? undefined$1 : Uint8ClampedArray,
  "%Uint16Array%": typeof Uint16Array > "u" ? undefined$1 : Uint16Array,
  "%Uint32Array%": typeof Uint32Array > "u" ? undefined$1 : Uint32Array,
  "%URIError%": $URIError,
  "%WeakMap%": typeof WeakMap > "u" ? undefined$1 : WeakMap,
  "%WeakRef%": typeof WeakRef > "u" ? undefined$1 : WeakRef,
  "%WeakSet%": typeof WeakSet > "u" ? undefined$1 : WeakSet
};
if (getProto$1)
  try {
    null.error;
  } catch (Y) {
    var errorProto = getProto$1(getProto$1(Y));
    INTRINSICS["%Error.prototype%"] = errorProto;
  }
var doEval = function Y(X) {
  var ee;
  if (X === "%AsyncFunction%")
    ee = getEvalledConstructor("async function () {}");
  else if (X === "%GeneratorFunction%")
    ee = getEvalledConstructor("function* () {}");
  else if (X === "%AsyncGeneratorFunction%")
    ee = getEvalledConstructor("async function* () {}");
  else if (X === "%AsyncGenerator%") {
    var te = Y("%AsyncGeneratorFunction%");
    te && (ee = te.prototype);
  } else if (X === "%AsyncIteratorPrototype%") {
    var ne = Y("%AsyncGenerator%");
    ne && getProto$1 && (ee = getProto$1(ne.prototype));
  }
  return INTRINSICS[X] = ee, ee;
}, LEGACY_ALIASES = {
  __proto__: null,
  "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
  "%ArrayPrototype%": ["Array", "prototype"],
  "%ArrayProto_entries%": ["Array", "prototype", "entries"],
  "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
  "%ArrayProto_keys%": ["Array", "prototype", "keys"],
  "%ArrayProto_values%": ["Array", "prototype", "values"],
  "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
  "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
  "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
  "%BooleanPrototype%": ["Boolean", "prototype"],
  "%DataViewPrototype%": ["DataView", "prototype"],
  "%DatePrototype%": ["Date", "prototype"],
  "%ErrorPrototype%": ["Error", "prototype"],
  "%EvalErrorPrototype%": ["EvalError", "prototype"],
  "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
  "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
  "%FunctionPrototype%": ["Function", "prototype"],
  "%Generator%": ["GeneratorFunction", "prototype"],
  "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
  "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
  "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
  "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
  "%JSONParse%": ["JSON", "parse"],
  "%JSONStringify%": ["JSON", "stringify"],
  "%MapPrototype%": ["Map", "prototype"],
  "%NumberPrototype%": ["Number", "prototype"],
  "%ObjectPrototype%": ["Object", "prototype"],
  "%ObjProto_toString%": ["Object", "prototype", "toString"],
  "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
  "%PromisePrototype%": ["Promise", "prototype"],
  "%PromiseProto_then%": ["Promise", "prototype", "then"],
  "%Promise_all%": ["Promise", "all"],
  "%Promise_reject%": ["Promise", "reject"],
  "%Promise_resolve%": ["Promise", "resolve"],
  "%RangeErrorPrototype%": ["RangeError", "prototype"],
  "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
  "%RegExpPrototype%": ["RegExp", "prototype"],
  "%SetPrototype%": ["Set", "prototype"],
  "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
  "%StringPrototype%": ["String", "prototype"],
  "%SymbolPrototype%": ["Symbol", "prototype"],
  "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
  "%TypedArrayPrototype%": ["TypedArray", "prototype"],
  "%TypeErrorPrototype%": ["TypeError", "prototype"],
  "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
  "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
  "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
  "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
  "%URIErrorPrototype%": ["URIError", "prototype"],
  "%WeakMapPrototype%": ["WeakMap", "prototype"],
  "%WeakSetPrototype%": ["WeakSet", "prototype"]
}, bind = functionBind, hasOwn = hasown, $concat = bind.call(Function.call, Array.prototype.concat), $spliceApply = bind.call(Function.apply, Array.prototype.splice), $replace = bind.call(Function.call, String.prototype.replace), $strSlice = bind.call(Function.call, String.prototype.slice), $exec = bind.call(Function.call, RegExp.prototype.exec), rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, reEscapeChar = /\\(\\)?/g, stringToPath = function(Y) {
  var X = $strSlice(Y, 0, 1), ee = $strSlice(Y, -1);
  if (X === "%" && ee !== "%")
    throw new $SyntaxError$1("invalid intrinsic syntax, expected closing `%`");
  if (ee === "%" && X !== "%")
    throw new $SyntaxError$1("invalid intrinsic syntax, expected opening `%`");
  var te = [];
  return $replace(Y, rePropName, function(ne, ie, oe, se) {
    te[te.length] = oe ? $replace(se, reEscapeChar, "$1") : ie || ne;
  }), te;
}, getBaseIntrinsic = function(Y, X) {
  var ee = Y, te;
  if (hasOwn(LEGACY_ALIASES, ee) && (te = LEGACY_ALIASES[ee], ee = "%" + te[0] + "%"), hasOwn(INTRINSICS, ee)) {
    var ne = INTRINSICS[ee];
    if (ne === needsEval && (ne = doEval(ee)), typeof ne > "u" && !X)
      throw new $TypeError$2("intrinsic " + Y + " exists, but is not available. Please file an issue!");
    return {
      alias: te,
      name: ee,
      value: ne
    };
  }
  throw new $SyntaxError$1("intrinsic " + Y + " does not exist!");
}, getIntrinsic = function(Y, X) {
  if (typeof Y != "string" || Y.length === 0)
    throw new $TypeError$2("intrinsic name must be a non-empty string");
  if (arguments.length > 1 && typeof X != "boolean")
    throw new $TypeError$2('"allowMissing" argument must be a boolean');
  if ($exec(/^%?[^%]*%?$/, Y) === null)
    throw new $SyntaxError$1("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
  var ee = stringToPath(Y), te = ee.length > 0 ? ee[0] : "", ne = getBaseIntrinsic("%" + te + "%", X), ie = ne.name, oe = ne.value, se = !1, ae = ne.alias;
  ae && (te = ae[0], $spliceApply(ee, $concat([0, 1], ae)));
  for (var ue = 1, le = !0; ue < ee.length; ue += 1) {
    var he = ee[ue], me = $strSlice(he, 0, 1), ye = $strSlice(he, -1);
    if ((me === '"' || me === "'" || me === "`" || ye === '"' || ye === "'" || ye === "`") && me !== ye)
      throw new $SyntaxError$1("property names with quotes must have matching quotes");
    if ((he === "constructor" || !le) && (se = !0), te += "." + he, ie = "%" + te + "%", hasOwn(INTRINSICS, ie))
      oe = INTRINSICS[ie];
    else if (oe != null) {
      if (!(he in oe)) {
        if (!X)
          throw new $TypeError$2("base intrinsic for " + Y + " exists, but the property is not available.");
        return;
      }
      if ($gOPD$1 && ue + 1 >= ee.length) {
        var we = $gOPD$1(oe, he);
        le = !!we, le && "get" in we && !("originalValue" in we.get) ? oe = we.get : oe = oe[he];
      } else
        le = hasOwn(oe, he), oe = oe[he];
      le && !se && (INTRINSICS[ie] = oe);
    }
  }
  return oe;
}, callBind$2 = { exports: {} }, esDefineProperty, hasRequiredEsDefineProperty;
function requireEsDefineProperty() {
  if (hasRequiredEsDefineProperty)
    return esDefineProperty;
  hasRequiredEsDefineProperty = 1;
  var Y = getIntrinsic, X = Y("%Object.defineProperty%", !0) || !1;
  if (X)
    try {
      X({}, "a", { value: 1 });
    } catch {
      X = !1;
    }
  return esDefineProperty = X, esDefineProperty;
}
var GetIntrinsic$2 = getIntrinsic, $gOPD = GetIntrinsic$2("%Object.getOwnPropertyDescriptor%", !0);
if ($gOPD)
  try {
    $gOPD([], "length");
  } catch {
    $gOPD = null;
  }
var gopd$1 = $gOPD, $defineProperty$1 = requireEsDefineProperty(), $SyntaxError = syntax, $TypeError$1 = type$1, gopd = gopd$1, defineDataProperty = function(Y, X, ee) {
  if (!Y || typeof Y != "object" && typeof Y != "function")
    throw new $TypeError$1("`obj` must be an object or a function`");
  if (typeof X != "string" && typeof X != "symbol")
    throw new $TypeError$1("`property` must be a string or a symbol`");
  if (arguments.length > 3 && typeof arguments[3] != "boolean" && arguments[3] !== null)
    throw new $TypeError$1("`nonEnumerable`, if provided, must be a boolean or null");
  if (arguments.length > 4 && typeof arguments[4] != "boolean" && arguments[4] !== null)
    throw new $TypeError$1("`nonWritable`, if provided, must be a boolean or null");
  if (arguments.length > 5 && typeof arguments[5] != "boolean" && arguments[5] !== null)
    throw new $TypeError$1("`nonConfigurable`, if provided, must be a boolean or null");
  if (arguments.length > 6 && typeof arguments[6] != "boolean")
    throw new $TypeError$1("`loose`, if provided, must be a boolean");
  var te = arguments.length > 3 ? arguments[3] : null, ne = arguments.length > 4 ? arguments[4] : null, ie = arguments.length > 5 ? arguments[5] : null, oe = arguments.length > 6 ? arguments[6] : !1, se = !!gopd && gopd(Y, X);
  if ($defineProperty$1)
    $defineProperty$1(Y, X, {
      configurable: ie === null && se ? se.configurable : !ie,
      enumerable: te === null && se ? se.enumerable : !te,
      value: ee,
      writable: ne === null && se ? se.writable : !ne
    });
  else if (oe || !te && !ne && !ie)
    Y[X] = ee;
  else
    throw new $SyntaxError("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
}, $defineProperty = requireEsDefineProperty(), hasPropertyDescriptors = function() {
  return !!$defineProperty;
};
hasPropertyDescriptors.hasArrayLengthDefineBug = function() {
  if (!$defineProperty)
    return null;
  try {
    return $defineProperty([], "length", { value: 1 }).length !== 1;
  } catch {
    return !0;
  }
};
var hasPropertyDescriptors_1 = hasPropertyDescriptors, GetIntrinsic$1 = getIntrinsic, define$1 = defineDataProperty, hasDescriptors = hasPropertyDescriptors_1(), gOPD$1 = gopd$1, $TypeError = type$1, $floor = GetIntrinsic$1("%Math.floor%"), setFunctionLength = function(Y, X) {
  if (typeof Y != "function")
    throw new $TypeError("`fn` is not a function");
  if (typeof X != "number" || X < 0 || X > 4294967295 || $floor(X) !== X)
    throw new $TypeError("`length` must be a positive 32-bit integer");
  var ee = arguments.length > 2 && !!arguments[2], te = !0, ne = !0;
  if ("length" in Y && gOPD$1) {
    var ie = gOPD$1(Y, "length");
    ie && !ie.configurable && (te = !1), ie && !ie.writable && (ne = !1);
  }
  return (te || ne || !ee) && (hasDescriptors ? define$1(
    /** @type {Parameters<define>[0]} */
    Y,
    "length",
    X,
    !0,
    !0
  ) : define$1(
    /** @type {Parameters<define>[0]} */
    Y,
    "length",
    X
  )), Y;
};
(function(Y) {
  var X = functionBind, ee = getIntrinsic, te = setFunctionLength, ne = type$1, ie = ee("%Function.prototype.apply%"), oe = ee("%Function.prototype.call%"), se = ee("%Reflect.apply%", !0) || X.call(oe, ie), ae = requireEsDefineProperty(), ue = ee("%Math.max%");
  Y.exports = function(he) {
    if (typeof he != "function")
      throw new ne("a function is required");
    var me = se(X, oe, arguments);
    return te(
      me,
      1 + ue(0, he.length - (arguments.length - 1)),
      !0
    );
  };
  var le = function() {
    return se(X, ie, arguments);
  };
  ae ? ae(Y.exports, "apply", { value: le }) : Y.exports.apply = le;
})(callBind$2);
var callBindExports = callBind$2.exports, GetIntrinsic = getIntrinsic, callBind$1 = callBindExports, $indexOf$1 = callBind$1(GetIntrinsic("String.prototype.indexOf")), callBound$2 = function(Y, X) {
  var ee = GetIntrinsic(Y, !!X);
  return typeof ee == "function" && $indexOf$1(Y, ".prototype.") > -1 ? callBind$1(ee) : ee;
}, hasToStringTag$3 = shams(), callBound$1 = callBound$2, $toString$1 = callBound$1("Object.prototype.toString"), isStandardArguments = function(Y) {
  return hasToStringTag$3 && Y && typeof Y == "object" && Symbol.toStringTag in Y ? !1 : $toString$1(Y) === "[object Arguments]";
}, isLegacyArguments = function(Y) {
  return isStandardArguments(Y) ? !0 : Y !== null && typeof Y == "object" && typeof Y.length == "number" && Y.length >= 0 && $toString$1(Y) !== "[object Array]" && $toString$1(Y.callee) === "[object Function]";
}, supportsStandardArguments = function() {
  return isStandardArguments(arguments);
}();
isStandardArguments.isLegacyArguments = isLegacyArguments;
var isArguments = supportsStandardArguments ? isStandardArguments : isLegacyArguments, toStr$2 = Object.prototype.toString, fnToStr$1 = Function.prototype.toString, isFnRegex = /^\s*(?:function)?\*/, hasToStringTag$2 = shams(), getProto = Object.getPrototypeOf, getGeneratorFunc = function() {
  if (!hasToStringTag$2)
    return !1;
  try {
    return Function("return function*() {}")();
  } catch {
  }
}, GeneratorFunction, isGeneratorFunction = function(Y) {
  if (typeof Y != "function")
    return !1;
  if (isFnRegex.test(fnToStr$1.call(Y)))
    return !0;
  if (!hasToStringTag$2) {
    var X = toStr$2.call(Y);
    return X === "[object GeneratorFunction]";
  }
  if (!getProto)
    return !1;
  if (typeof GeneratorFunction > "u") {
    var ee = getGeneratorFunc();
    GeneratorFunction = ee ? getProto(ee) : !1;
  }
  return getProto(Y) === GeneratorFunction;
}, fnToStr = Function.prototype.toString, reflectApply = typeof Reflect == "object" && Reflect !== null && Reflect.apply, badArrayLike, isCallableMarker;
if (typeof reflectApply == "function" && typeof Object.defineProperty == "function")
  try {
    badArrayLike = Object.defineProperty({}, "length", {
      get: function() {
        throw isCallableMarker;
      }
    }), isCallableMarker = {}, reflectApply(function() {
      throw 42;
    }, null, badArrayLike);
  } catch (Y) {
    Y !== isCallableMarker && (reflectApply = null);
  }
else
  reflectApply = null;
var constructorRegex = /^\s*class\b/, isES6ClassFn = function(Y) {
  try {
    var X = fnToStr.call(Y);
    return constructorRegex.test(X);
  } catch {
    return !1;
  }
}, tryFunctionObject = function(Y) {
  try {
    return isES6ClassFn(Y) ? !1 : (fnToStr.call(Y), !0);
  } catch {
    return !1;
  }
}, toStr$1 = Object.prototype.toString, objectClass = "[object Object]", fnClass = "[object Function]", genClass = "[object GeneratorFunction]", ddaClass = "[object HTMLAllCollection]", ddaClass2 = "[object HTML document.all class]", ddaClass3 = "[object HTMLCollection]", hasToStringTag$1 = typeof Symbol == "function" && !!Symbol.toStringTag, isIE68 = !(0 in [,]), isDDA = function() {
  return !1;
};
if (typeof document == "object") {
  var all = document.all;
  toStr$1.call(all) === toStr$1.call(document.all) && (isDDA = function(Y) {
    if ((isIE68 || !Y) && (typeof Y > "u" || typeof Y == "object"))
      try {
        var X = toStr$1.call(Y);
        return (X === ddaClass || X === ddaClass2 || X === ddaClass3 || X === objectClass) && Y("") == null;
      } catch {
      }
    return !1;
  });
}
var isCallable$1 = reflectApply ? function(Y) {
  if (isDDA(Y))
    return !0;
  if (!Y || typeof Y != "function" && typeof Y != "object")
    return !1;
  try {
    reflectApply(Y, null, badArrayLike);
  } catch (X) {
    if (X !== isCallableMarker)
      return !1;
  }
  return !isES6ClassFn(Y) && tryFunctionObject(Y);
} : function(Y) {
  if (isDDA(Y))
    return !0;
  if (!Y || typeof Y != "function" && typeof Y != "object")
    return !1;
  if (hasToStringTag$1)
    return tryFunctionObject(Y);
  if (isES6ClassFn(Y))
    return !1;
  var X = toStr$1.call(Y);
  return X !== fnClass && X !== genClass && !/^\[object HTML/.test(X) ? !1 : tryFunctionObject(Y);
}, isCallable = isCallable$1, toStr = Object.prototype.toString, hasOwnProperty = Object.prototype.hasOwnProperty, forEachArray = function(Y, X, ee) {
  for (var te = 0, ne = Y.length; te < ne; te++)
    hasOwnProperty.call(Y, te) && (ee == null ? X(Y[te], te, Y) : X.call(ee, Y[te], te, Y));
}, forEachString = function(Y, X, ee) {
  for (var te = 0, ne = Y.length; te < ne; te++)
    ee == null ? X(Y.charAt(te), te, Y) : X.call(ee, Y.charAt(te), te, Y);
}, forEachObject = function(Y, X, ee) {
  for (var te in Y)
    hasOwnProperty.call(Y, te) && (ee == null ? X(Y[te], te, Y) : X.call(ee, Y[te], te, Y));
}, forEach$1 = function(Y, X, ee) {
  if (!isCallable(X))
    throw new TypeError("iterator must be a function");
  var te;
  arguments.length >= 3 && (te = ee), toStr.call(Y) === "[object Array]" ? forEachArray(Y, X, te) : typeof Y == "string" ? forEachString(Y, X, te) : forEachObject(Y, X, te);
}, forEach_1 = forEach$1, possibleTypedArrayNames = [
  "Float32Array",
  "Float64Array",
  "Int8Array",
  "Int16Array",
  "Int32Array",
  "Uint8Array",
  "Uint8ClampedArray",
  "Uint16Array",
  "Uint32Array",
  "BigInt64Array",
  "BigUint64Array"
], possibleNames = possibleTypedArrayNames, g$1 = typeof globalThis > "u" ? commonjsGlobal : globalThis, availableTypedArrays$1 = function() {
  for (var Y = [], X = 0; X < possibleNames.length; X++)
    typeof g$1[possibleNames[X]] == "function" && (Y[Y.length] = possibleNames[X]);
  return Y;
}, forEach = forEach_1, availableTypedArrays = availableTypedArrays$1, callBind = callBindExports, callBound = callBound$2, gOPD = gopd$1, $toString = callBound("Object.prototype.toString"), hasToStringTag = shams(), g = typeof globalThis > "u" ? commonjsGlobal : globalThis, typedArrays = availableTypedArrays(), $slice = callBound("String.prototype.slice"), getPrototypeOf$1 = Object.getPrototypeOf, $indexOf = callBound("Array.prototype.indexOf", !0) || /** @type {(array: readonly unknown[], value: unknown) => keyof array} */
function(Y, X) {
  for (var ee = 0; ee < Y.length; ee += 1)
    if (Y[ee] === X)
      return ee;
  return -1;
}, cache = { __proto__: null };
hasToStringTag && gOPD && getPrototypeOf$1 ? forEach(typedArrays, function(Y) {
  var X = new g[Y]();
  if (Symbol.toStringTag in X) {
    var ee = getPrototypeOf$1(X), te = gOPD(ee, Symbol.toStringTag);
    if (!te) {
      var ne = getPrototypeOf$1(ee);
      te = gOPD(ne, Symbol.toStringTag);
    }
    cache["$" + Y] = callBind(te.get);
  }
}) : forEach(typedArrays, function(Y) {
  var X = new g[Y](), ee = X.slice || X.set;
  ee && (cache["$" + Y] = callBind(ee));
});
var tryTypedArrays = function(Y) {
  var X = !1;
  return forEach(
    // eslint-disable-next-line no-extra-parens
    /** @type {Record<`\$${TypedArrayName}`, typeof cache>} */
    /** @type {any} */
    cache,
    /** @type {(getter: typeof cache, name: `\$${TypedArrayName}`) => void} */
    function(ee, te) {
      if (!X)
        try {
          "$" + ee(Y) === te && (X = $slice(te, 1));
        } catch {
        }
    }
  ), X;
}, trySlices = function(Y) {
  var X = !1;
  return forEach(
    // eslint-disable-next-line no-extra-parens
    /** @type {any} */
    cache,
    /** @type {(getter: typeof cache, name: `\$${TypedArrayName}`) => void} */
    function(ee, te) {
      if (!X)
        try {
          ee(Y), X = $slice(te, 1);
        } catch {
        }
    }
  ), X;
}, whichTypedArray$1 = function(Y) {
  if (!Y || typeof Y != "object")
    return !1;
  if (!hasToStringTag) {
    var X = $slice($toString(Y), 8, -1);
    return $indexOf(typedArrays, X) > -1 ? X : X !== "Object" ? !1 : trySlices(Y);
  }
  return gOPD ? tryTypedArrays(Y) : null;
}, whichTypedArray = whichTypedArray$1, isTypedArray = function(Y) {
  return !!whichTypedArray(Y);
};
(function(Y) {
  var X = isArguments, ee = isGeneratorFunction, te = whichTypedArray$1, ne = isTypedArray;
  function ie(Ct) {
    return Ct.call.bind(Ct);
  }
  var oe = typeof BigInt < "u", se = typeof Symbol < "u", ae = ie(Object.prototype.toString), ue = ie(Number.prototype.valueOf), le = ie(String.prototype.valueOf), he = ie(Boolean.prototype.valueOf);
  if (oe)
    var me = ie(BigInt.prototype.valueOf);
  if (se)
    var ye = ie(Symbol.prototype.valueOf);
  function we(Ct, w_) {
    if (typeof Ct != "object")
      return !1;
    try {
      return w_(Ct), !0;
    } catch {
      return !1;
    }
  }
  Y.isArgumentsObject = X, Y.isGeneratorFunction = ee, Y.isTypedArray = ne;
  function Ee(Ct) {
    return typeof Promise < "u" && Ct instanceof Promise || Ct !== null && typeof Ct == "object" && typeof Ct.then == "function" && typeof Ct.catch == "function";
  }
  Y.isPromise = Ee;
  function Re(Ct) {
    return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? ArrayBuffer.isView(Ct) : ne(Ct) || Ge(Ct);
  }
  Y.isArrayBufferView = Re;
  function Ue(Ct) {
    return te(Ct) === "Uint8Array";
  }
  Y.isUint8Array = Ue;
  function Me(Ct) {
    return te(Ct) === "Uint8ClampedArray";
  }
  Y.isUint8ClampedArray = Me;
  function De(Ct) {
    return te(Ct) === "Uint16Array";
  }
  Y.isUint16Array = De;
  function Fe(Ct) {
    return te(Ct) === "Uint32Array";
  }
  Y.isUint32Array = Fe;
  function Ke(Ct) {
    return te(Ct) === "Int8Array";
  }
  Y.isInt8Array = Ke;
  function tt(Ct) {
    return te(Ct) === "Int16Array";
  }
  Y.isInt16Array = tt;
  function rt(Ct) {
    return te(Ct) === "Int32Array";
  }
  Y.isInt32Array = rt;
  function it(Ct) {
    return te(Ct) === "Float32Array";
  }
  Y.isFloat32Array = it;
  function _t(Ct) {
    return te(Ct) === "Float64Array";
  }
  Y.isFloat64Array = _t;
  function Dt(Ct) {
    return te(Ct) === "BigInt64Array";
  }
  Y.isBigInt64Array = Dt;
  function je(Ct) {
    return te(Ct) === "BigUint64Array";
  }
  Y.isBigUint64Array = je;
  function ze(Ct) {
    return ae(Ct) === "[object Map]";
  }
  ze.working = typeof Map < "u" && ze(/* @__PURE__ */ new Map());
  function fe(Ct) {
    return typeof Map > "u" ? !1 : ze.working ? ze(Ct) : Ct instanceof Map;
  }
  Y.isMap = fe;
  function de(Ct) {
    return ae(Ct) === "[object Set]";
  }
  de.working = typeof Set < "u" && de(/* @__PURE__ */ new Set());
  function be(Ct) {
    return typeof Set > "u" ? !1 : de.working ? de(Ct) : Ct instanceof Set;
  }
  Y.isSet = be;
  function Te(Ct) {
    return ae(Ct) === "[object WeakMap]";
  }
  Te.working = typeof WeakMap < "u" && Te(/* @__PURE__ */ new WeakMap());
  function Ce(Ct) {
    return typeof WeakMap > "u" ? !1 : Te.working ? Te(Ct) : Ct instanceof WeakMap;
  }
  Y.isWeakMap = Ce;
  function Pe(Ct) {
    return ae(Ct) === "[object WeakSet]";
  }
  Pe.working = typeof WeakSet < "u" && Pe(/* @__PURE__ */ new WeakSet());
  function Se(Ct) {
    return Pe(Ct);
  }
  Y.isWeakSet = Se;
  function ke(Ct) {
    return ae(Ct) === "[object ArrayBuffer]";
  }
  ke.working = typeof ArrayBuffer < "u" && ke(new ArrayBuffer());
  function ge(Ct) {
    return typeof ArrayBuffer > "u" ? !1 : ke.working ? ke(Ct) : Ct instanceof ArrayBuffer;
  }
  Y.isArrayBuffer = ge;
  function Ae(Ct) {
    return ae(Ct) === "[object DataView]";
  }
  Ae.working = typeof ArrayBuffer < "u" && typeof DataView < "u" && Ae(new DataView(new ArrayBuffer(1), 0, 1));
  function Ge(Ct) {
    return typeof DataView > "u" ? !1 : Ae.working ? Ae(Ct) : Ct instanceof DataView;
  }
  Y.isDataView = Ge;
  var Xe = typeof SharedArrayBuffer < "u" ? SharedArrayBuffer : void 0;
  function $e(Ct) {
    return ae(Ct) === "[object SharedArrayBuffer]";
  }
  function Ze(Ct) {
    return typeof Xe > "u" ? !1 : (typeof $e.working > "u" && ($e.working = $e(new Xe())), $e.working ? $e(Ct) : Ct instanceof Xe);
  }
  Y.isSharedArrayBuffer = Ze;
  function ot(Ct) {
    return ae(Ct) === "[object AsyncFunction]";
  }
  Y.isAsyncFunction = ot;
  function ct(Ct) {
    return ae(Ct) === "[object Map Iterator]";
  }
  Y.isMapIterator = ct;
  function At(Ct) {
    return ae(Ct) === "[object Set Iterator]";
  }
  Y.isSetIterator = At;
  function Tt(Ct) {
    return ae(Ct) === "[object Generator]";
  }
  Y.isGeneratorObject = Tt;
  function dt(Ct) {
    return ae(Ct) === "[object WebAssembly.Module]";
  }
  Y.isWebAssemblyCompiledModule = dt;
  function vt(Ct) {
    return we(Ct, ue);
  }
  Y.isNumberObject = vt;
  function Ut(Ct) {
    return we(Ct, le);
  }
  Y.isStringObject = Ut;
  function It(Ct) {
    return we(Ct, he);
  }
  Y.isBooleanObject = It;
  function Er(Ct) {
    return oe && we(Ct, me);
  }
  Y.isBigIntObject = Er;
  function Fr(Ct) {
    return se && we(Ct, ye);
  }
  Y.isSymbolObject = Fr;
  function an(Ct) {
    return vt(Ct) || Ut(Ct) || It(Ct) || Er(Ct) || Fr(Ct);
  }
  Y.isBoxedPrimitive = an;
  function wX(Ct) {
    return typeof Uint8Array < "u" && (ge(Ct) || Ze(Ct));
  }
  Y.isAnyArrayBuffer = wX, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(Ct) {
    Object.defineProperty(Y, Ct, {
      enumerable: !1,
      value: function() {
        throw new Error(Ct + " is not supported in userland");
      }
    });
  });
})(types);
var isBufferBrowser = function(Y) {
  return Y && typeof Y == "object" && typeof Y.copy == "function" && typeof Y.fill == "function" && typeof Y.readUInt8 == "function";
};
(function(Y) {
  var X = Object.getOwnPropertyDescriptors || function(Ae) {
    for (var Ge = Object.keys(Ae), Xe = {}, $e = 0; $e < Ge.length; $e++)
      Xe[Ge[$e]] = Object.getOwnPropertyDescriptor(Ae, Ge[$e]);
    return Xe;
  }, ee = /%[sdj%]/g;
  Y.format = function(Ae) {
    if (!Ke(Ae)) {
      for (var Ge = [], Xe = 0; Xe < arguments.length; Xe++)
        Ge.push(oe(arguments[Xe]));
      return Ge.join(" ");
    }
    for (var Xe = 1, $e = arguments, Ze = $e.length, ot = String(Ae).replace(ee, function(Tt) {
      if (Tt === "%%")
        return "%";
      if (Xe >= Ze)
        return Tt;
      switch (Tt) {
        case "%s":
          return String($e[Xe++]);
        case "%d":
          return Number($e[Xe++]);
        case "%j":
          try {
            return JSON.stringify($e[Xe++]);
          } catch {
            return "[Circular]";
          }
        default:
          return Tt;
      }
    }), ct = $e[Xe]; Xe < Ze; ct = $e[++Xe])
      Me(ct) || !_t(ct) ? ot += " " + ct : ot += " " + oe(ct);
    return ot;
  }, Y.deprecate = function(Ae, Ge) {
    if (typeof process$1$1 < "u" && process$1$1.noDeprecation === !0)
      return Ae;
    if (typeof process$1$1 > "u")
      return function() {
        return Y.deprecate(Ae, Ge).apply(this, arguments);
      };
    var Xe = !1;
    function $e() {
      if (!Xe) {
        if (process$1$1.throwDeprecation)
          throw new Error(Ge);
        process$1$1.traceDeprecation ? console.trace(Ge) : console.error(Ge), Xe = !0;
      }
      return Ae.apply(this, arguments);
    }
    return $e;
  };
  var te = {}, ne = /^$/;
  if (process$1$1.env.NODE_DEBUG) {
    var ie = process$1$1.env.NODE_DEBUG;
    ie = ie.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), ne = new RegExp("^" + ie + "$", "i");
  }
  Y.debuglog = function(Ae) {
    if (Ae = Ae.toUpperCase(), !te[Ae])
      if (ne.test(Ae)) {
        var Ge = process$1$1.pid;
        te[Ae] = function() {
          var Xe = Y.format.apply(Y, arguments);
          console.error("%s %d: %s", Ae, Ge, Xe);
        };
      } else
        te[Ae] = function() {
        };
    return te[Ae];
  };
  function oe(Ae, Ge) {
    var Xe = {
      seen: [],
      stylize: ae
    };
    return arguments.length >= 3 && (Xe.depth = arguments[2]), arguments.length >= 4 && (Xe.colors = arguments[3]), Ue(Ge) ? Xe.showHidden = Ge : Ge && Y._extend(Xe, Ge), rt(Xe.showHidden) && (Xe.showHidden = !1), rt(Xe.depth) && (Xe.depth = 2), rt(Xe.colors) && (Xe.colors = !1), rt(Xe.customInspect) && (Xe.customInspect = !0), Xe.colors && (Xe.stylize = se), le(Xe, Ae, Xe.depth);
  }
  Y.inspect = oe, oe.colors = {
    bold: [1, 22],
    italic: [3, 23],
    underline: [4, 24],
    inverse: [7, 27],
    white: [37, 39],
    grey: [90, 39],
    black: [30, 39],
    blue: [34, 39],
    cyan: [36, 39],
    green: [32, 39],
    magenta: [35, 39],
    red: [31, 39],
    yellow: [33, 39]
  }, oe.styles = {
    special: "cyan",
    number: "yellow",
    boolean: "yellow",
    undefined: "grey",
    null: "bold",
    string: "green",
    date: "magenta",
    // "name": intentionally not styling
    regexp: "red"
  };
  function se(Ae, Ge) {
    var Xe = oe.styles[Ge];
    return Xe ? "\x1B[" + oe.colors[Xe][0] + "m" + Ae + "\x1B[" + oe.colors[Xe][1] + "m" : Ae;
  }
  function ae(Ae, Ge) {
    return Ae;
  }
  function ue(Ae) {
    var Ge = {};
    return Ae.forEach(function(Xe, $e) {
      Ge[Xe] = !0;
    }), Ge;
  }
  function le(Ae, Ge, Xe) {
    if (Ae.customInspect && Ge && ze(Ge.inspect) && // Filter out the util module, it's inspect function is special
    Ge.inspect !== Y.inspect && // Also filter out any prototype objects using the circular check.
    !(Ge.constructor && Ge.constructor.prototype === Ge)) {
      var $e = Ge.inspect(Xe, Ae);
      return Ke($e) || ($e = le(Ae, $e, Xe)), $e;
    }
    var Ze = he(Ae, Ge);
    if (Ze)
      return Ze;
    var ot = Object.keys(Ge), ct = ue(ot);
    if (Ae.showHidden && (ot = Object.getOwnPropertyNames(Ge)), je(Ge) && (ot.indexOf("message") >= 0 || ot.indexOf("description") >= 0))
      return me(Ge);
    if (ot.length === 0) {
      if (ze(Ge)) {
        var At = Ge.name ? ": " + Ge.name : "";
        return Ae.stylize("[Function" + At + "]", "special");
      }
      if (it(Ge))
        return Ae.stylize(RegExp.prototype.toString.call(Ge), "regexp");
      if (Dt(Ge))
        return Ae.stylize(Date.prototype.toString.call(Ge), "date");
      if (je(Ge))
        return me(Ge);
    }
    var Tt = "", dt = !1, vt = ["{", "}"];
    if (Re(Ge) && (dt = !0, vt = ["[", "]"]), ze(Ge)) {
      var Ut = Ge.name ? ": " + Ge.name : "";
      Tt = " [Function" + Ut + "]";
    }
    if (it(Ge) && (Tt = " " + RegExp.prototype.toString.call(Ge)), Dt(Ge) && (Tt = " " + Date.prototype.toUTCString.call(Ge)), je(Ge) && (Tt = " " + me(Ge)), ot.length === 0 && (!dt || Ge.length == 0))
      return vt[0] + Tt + vt[1];
    if (Xe < 0)
      return it(Ge) ? Ae.stylize(RegExp.prototype.toString.call(Ge), "regexp") : Ae.stylize("[Object]", "special");
    Ae.seen.push(Ge);
    var It;
    return dt ? It = ye(Ae, Ge, Xe, ct, ot) : It = ot.map(function(Er) {
      return we(Ae, Ge, Xe, ct, Er, dt);
    }), Ae.seen.pop(), Ee(It, Tt, vt);
  }
  function he(Ae, Ge) {
    if (rt(Ge))
      return Ae.stylize("undefined", "undefined");
    if (Ke(Ge)) {
      var Xe = "'" + JSON.stringify(Ge).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
      return Ae.stylize(Xe, "string");
    }
    if (Fe(Ge))
      return Ae.stylize("" + Ge, "number");
    if (Ue(Ge))
      return Ae.stylize("" + Ge, "boolean");
    if (Me(Ge))
      return Ae.stylize("null", "null");
  }
  function me(Ae) {
    return "[" + Error.prototype.toString.call(Ae) + "]";
  }
  function ye(Ae, Ge, Xe, $e, Ze) {
    for (var ot = [], ct = 0, At = Ge.length; ct < At; ++ct)
      Pe(Ge, String(ct)) ? ot.push(we(
        Ae,
        Ge,
        Xe,
        $e,
        String(ct),
        !0
      )) : ot.push("");
    return Ze.forEach(function(Tt) {
      Tt.match(/^\d+$/) || ot.push(we(
        Ae,
        Ge,
        Xe,
        $e,
        Tt,
        !0
      ));
    }), ot;
  }
  function we(Ae, Ge, Xe, $e, Ze, ot) {
    var ct, At, Tt;
    if (Tt = Object.getOwnPropertyDescriptor(Ge, Ze) || { value: Ge[Ze] }, Tt.get ? Tt.set ? At = Ae.stylize("[Getter/Setter]", "special") : At = Ae.stylize("[Getter]", "special") : Tt.set && (At = Ae.stylize("[Setter]", "special")), Pe($e, Ze) || (ct = "[" + Ze + "]"), At || (Ae.seen.indexOf(Tt.value) < 0 ? (Me(Xe) ? At = le(Ae, Tt.value, null) : At = le(Ae, Tt.value, Xe - 1), At.indexOf(`
`) > -1 && (ot ? At = At.split(`
`).map(function(dt) {
      return "  " + dt;
    }).join(`
`).slice(2) : At = `
` + At.split(`
`).map(function(dt) {
      return "   " + dt;
    }).join(`
`))) : At = Ae.stylize("[Circular]", "special")), rt(ct)) {
      if (ot && Ze.match(/^\d+$/))
        return At;
      ct = JSON.stringify("" + Ze), ct.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (ct = ct.slice(1, -1), ct = Ae.stylize(ct, "name")) : (ct = ct.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), ct = Ae.stylize(ct, "string"));
    }
    return ct + ": " + At;
  }
  function Ee(Ae, Ge, Xe) {
    var $e = Ae.reduce(function(Ze, ot) {
      return ot.indexOf(`
`) >= 0, Ze + ot.replace(/\u001b\[\d\d?m/g, "").length + 1;
    }, 0);
    return $e > 60 ? Xe[0] + (Ge === "" ? "" : Ge + `
 `) + " " + Ae.join(`,
  `) + " " + Xe[1] : Xe[0] + Ge + " " + Ae.join(", ") + " " + Xe[1];
  }
  Y.types = types;
  function Re(Ae) {
    return Array.isArray(Ae);
  }
  Y.isArray = Re;
  function Ue(Ae) {
    return typeof Ae == "boolean";
  }
  Y.isBoolean = Ue;
  function Me(Ae) {
    return Ae === null;
  }
  Y.isNull = Me;
  function De(Ae) {
    return Ae == null;
  }
  Y.isNullOrUndefined = De;
  function Fe(Ae) {
    return typeof Ae == "number";
  }
  Y.isNumber = Fe;
  function Ke(Ae) {
    return typeof Ae == "string";
  }
  Y.isString = Ke;
  function tt(Ae) {
    return typeof Ae == "symbol";
  }
  Y.isSymbol = tt;
  function rt(Ae) {
    return Ae === void 0;
  }
  Y.isUndefined = rt;
  function it(Ae) {
    return _t(Ae) && de(Ae) === "[object RegExp]";
  }
  Y.isRegExp = it, Y.types.isRegExp = it;
  function _t(Ae) {
    return typeof Ae == "object" && Ae !== null;
  }
  Y.isObject = _t;
  function Dt(Ae) {
    return _t(Ae) && de(Ae) === "[object Date]";
  }
  Y.isDate = Dt, Y.types.isDate = Dt;
  function je(Ae) {
    return _t(Ae) && (de(Ae) === "[object Error]" || Ae instanceof Error);
  }
  Y.isError = je, Y.types.isNativeError = je;
  function ze(Ae) {
    return typeof Ae == "function";
  }
  Y.isFunction = ze;
  function fe(Ae) {
    return Ae === null || typeof Ae == "boolean" || typeof Ae == "number" || typeof Ae == "string" || typeof Ae == "symbol" || // ES6 symbol
    typeof Ae > "u";
  }
  Y.isPrimitive = fe, Y.isBuffer = isBufferBrowser;
  function de(Ae) {
    return Object.prototype.toString.call(Ae);
  }
  function be(Ae) {
    return Ae < 10 ? "0" + Ae.toString(10) : Ae.toString(10);
  }
  var Te = [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ];
  function Ce() {
    var Ae = /* @__PURE__ */ new Date(), Ge = [
      be(Ae.getHours()),
      be(Ae.getMinutes()),
      be(Ae.getSeconds())
    ].join(":");
    return [Ae.getDate(), Te[Ae.getMonth()], Ge].join(" ");
  }
  Y.log = function() {
    console.log("%s - %s", Ce(), Y.format.apply(Y, arguments));
  }, Y.inherits = inherits_browserExports, Y._extend = function(Ae, Ge) {
    if (!Ge || !_t(Ge))
      return Ae;
    for (var Xe = Object.keys(Ge), $e = Xe.length; $e--; )
      Ae[Xe[$e]] = Ge[Xe[$e]];
    return Ae;
  };
  function Pe(Ae, Ge) {
    return Object.prototype.hasOwnProperty.call(Ae, Ge);
  }
  var Se = typeof Symbol < "u" ? Symbol("util.promisify.custom") : void 0;
  Y.promisify = function(Ae) {
    if (typeof Ae != "function")
      throw new TypeError('The "original" argument must be of type Function');
    if (Se && Ae[Se]) {
      var Ge = Ae[Se];
      if (typeof Ge != "function")
        throw new TypeError('The "util.promisify.custom" argument must be of type Function');
      return Object.defineProperty(Ge, Se, {
        value: Ge,
        enumerable: !1,
        writable: !1,
        configurable: !0
      }), Ge;
    }
    function Ge() {
      for (var Xe, $e, Ze = new Promise(function(At, Tt) {
        Xe = At, $e = Tt;
      }), ot = [], ct = 0; ct < arguments.length; ct++)
        ot.push(arguments[ct]);
      ot.push(function(At, Tt) {
        At ? $e(At) : Xe(Tt);
      });
      try {
        Ae.apply(this, ot);
      } catch (At) {
        $e(At);
      }
      return Ze;
    }
    return Object.setPrototypeOf(Ge, Object.getPrototypeOf(Ae)), Se && Object.defineProperty(Ge, Se, {
      value: Ge,
      enumerable: !1,
      writable: !1,
      configurable: !0
    }), Object.defineProperties(
      Ge,
      X(Ae)
    );
  }, Y.promisify.custom = Se;
  function ke(Ae, Ge) {
    if (!Ae) {
      var Xe = new Error("Promise was rejected with a falsy value");
      Xe.reason = Ae, Ae = Xe;
    }
    return Ge(Ae);
  }
  function ge(Ae) {
    if (typeof Ae != "function")
      throw new TypeError('The "original" argument must be of type Function');
    function Ge() {
      for (var Xe = [], $e = 0; $e < arguments.length; $e++)
        Xe.push(arguments[$e]);
      var Ze = Xe.pop();
      if (typeof Ze != "function")
        throw new TypeError("The last argument must be of type Function");
      var ot = this, ct = function() {
        return Ze.apply(ot, arguments);
      };
      Ae.apply(this, Xe).then(
        function(At) {
          process$1$1.nextTick(ct.bind(null, null, At));
        },
        function(At) {
          process$1$1.nextTick(ke.bind(null, At, ct));
        }
      );
    }
    return Object.setPrototypeOf(Ge, Object.getPrototypeOf(Ae)), Object.defineProperties(
      Ge,
      X(Ae)
    ), Ge;
  }
  Y.callbackify = ge;
})(util);
var buffer_list, hasRequiredBuffer_list;
function requireBuffer_list() {
  if (hasRequiredBuffer_list)
    return buffer_list;
  hasRequiredBuffer_list = 1;
  function Y(we, Ee) {
    var Re = Object.keys(we);
    if (Object.getOwnPropertySymbols) {
      var Ue = Object.getOwnPropertySymbols(we);
      Ee && (Ue = Ue.filter(function(Me) {
        return Object.getOwnPropertyDescriptor(we, Me).enumerable;
      })), Re.push.apply(Re, Ue);
    }
    return Re;
  }
  function X(we) {
    for (var Ee = 1; Ee < arguments.length; Ee++) {
      var Re = arguments[Ee] != null ? arguments[Ee] : {};
      Ee % 2 ? Y(Object(Re), !0).forEach(function(Ue) {
        ee(we, Ue, Re[Ue]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(we, Object.getOwnPropertyDescriptors(Re)) : Y(Object(Re)).forEach(function(Ue) {
        Object.defineProperty(we, Ue, Object.getOwnPropertyDescriptor(Re, Ue));
      });
    }
    return we;
  }
  function ee(we, Ee, Re) {
    return Ee = oe(Ee), Ee in we ? Object.defineProperty(we, Ee, { value: Re, enumerable: !0, configurable: !0, writable: !0 }) : we[Ee] = Re, we;
  }
  function te(we, Ee) {
    if (!(we instanceof Ee))
      throw new TypeError("Cannot call a class as a function");
  }
  function ne(we, Ee) {
    for (var Re = 0; Re < Ee.length; Re++) {
      var Ue = Ee[Re];
      Ue.enumerable = Ue.enumerable || !1, Ue.configurable = !0, "value" in Ue && (Ue.writable = !0), Object.defineProperty(we, oe(Ue.key), Ue);
    }
  }
  function ie(we, Ee, Re) {
    return Ee && ne(we.prototype, Ee), Re && ne(we, Re), Object.defineProperty(we, "prototype", { writable: !1 }), we;
  }
  function oe(we) {
    var Ee = se(we, "string");
    return typeof Ee == "symbol" ? Ee : String(Ee);
  }
  function se(we, Ee) {
    if (typeof we != "object" || we === null)
      return we;
    var Re = we[Symbol.toPrimitive];
    if (Re !== void 0) {
      var Ue = Re.call(we, Ee || "default");
      if (typeof Ue != "object")
        return Ue;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (Ee === "string" ? String : Number)(we);
  }
  var ae = require$$0$3, ue = ae.Buffer, le = util, he = le.inspect, me = he && he.custom || "inspect";
  function ye(we, Ee, Re) {
    ue.prototype.copy.call(we, Ee, Re);
  }
  return buffer_list = /* @__PURE__ */ function() {
    function we() {
      te(this, we), this.head = null, this.tail = null, this.length = 0;
    }
    return ie(we, [{
      key: "push",
      value: function(Ee) {
        var Re = {
          data: Ee,
          next: null
        };
        this.length > 0 ? this.tail.next = Re : this.head = Re, this.tail = Re, ++this.length;
      }
    }, {
      key: "unshift",
      value: function(Ee) {
        var Re = {
          data: Ee,
          next: this.head
        };
        this.length === 0 && (this.tail = Re), this.head = Re, ++this.length;
      }
    }, {
      key: "shift",
      value: function() {
        if (this.length !== 0) {
          var Ee = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, Ee;
        }
      }
    }, {
      key: "clear",
      value: function() {
        this.head = this.tail = null, this.length = 0;
      }
    }, {
      key: "join",
      value: function(Ee) {
        if (this.length === 0)
          return "";
        for (var Re = this.head, Ue = "" + Re.data; Re = Re.next; )
          Ue += Ee + Re.data;
        return Ue;
      }
    }, {
      key: "concat",
      value: function(Ee) {
        if (this.length === 0)
          return ue.alloc(0);
        for (var Re = ue.allocUnsafe(Ee >>> 0), Ue = this.head, Me = 0; Ue; )
          ye(Ue.data, Re, Me), Me += Ue.data.length, Ue = Ue.next;
        return Re;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: function(Ee, Re) {
        var Ue;
        return Ee < this.head.data.length ? (Ue = this.head.data.slice(0, Ee), this.head.data = this.head.data.slice(Ee)) : Ee === this.head.data.length ? Ue = this.shift() : Ue = Re ? this._getString(Ee) : this._getBuffer(Ee), Ue;
      }
    }, {
      key: "first",
      value: function() {
        return this.head.data;
      }
      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: function(Ee) {
        var Re = this.head, Ue = 1, Me = Re.data;
        for (Ee -= Me.length; Re = Re.next; ) {
          var De = Re.data, Fe = Ee > De.length ? De.length : Ee;
          if (Fe === De.length ? Me += De : Me += De.slice(0, Ee), Ee -= Fe, Ee === 0) {
            Fe === De.length ? (++Ue, Re.next ? this.head = Re.next : this.head = this.tail = null) : (this.head = Re, Re.data = De.slice(Fe));
            break;
          }
          ++Ue;
        }
        return this.length -= Ue, Me;
      }
      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: function(Ee) {
        var Re = ue.allocUnsafe(Ee), Ue = this.head, Me = 1;
        for (Ue.data.copy(Re), Ee -= Ue.data.length; Ue = Ue.next; ) {
          var De = Ue.data, Fe = Ee > De.length ? De.length : Ee;
          if (De.copy(Re, Re.length - Ee, 0, Fe), Ee -= Fe, Ee === 0) {
            Fe === De.length ? (++Me, Ue.next ? this.head = Ue.next : this.head = this.tail = null) : (this.head = Ue, Ue.data = De.slice(Fe));
            break;
          }
          ++Me;
        }
        return this.length -= Me, Re;
      }
      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: me,
      value: function(Ee, Re) {
        return he(this, X(X({}, Re), {}, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: !1
        }));
      }
    }]), we;
  }(), buffer_list;
}
function destroy(Y, X) {
  var ee = this, te = this._readableState && this._readableState.destroyed, ne = this._writableState && this._writableState.destroyed;
  return te || ne ? (X ? X(Y) : Y && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, process$1$1.nextTick(emitErrorNT, this, Y)) : process$1$1.nextTick(emitErrorNT, this, Y)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(Y || null, function(ie) {
    !X && ie ? ee._writableState ? ee._writableState.errorEmitted ? process$1$1.nextTick(emitCloseNT, ee) : (ee._writableState.errorEmitted = !0, process$1$1.nextTick(emitErrorAndCloseNT, ee, ie)) : process$1$1.nextTick(emitErrorAndCloseNT, ee, ie) : X ? (process$1$1.nextTick(emitCloseNT, ee), X(ie)) : process$1$1.nextTick(emitCloseNT, ee);
  }), this);
}
function emitErrorAndCloseNT(Y, X) {
  emitErrorNT(Y, X), emitCloseNT(Y);
}
function emitCloseNT(Y) {
  Y._writableState && !Y._writableState.emitClose || Y._readableState && !Y._readableState.emitClose || Y.emit("close");
}
function undestroy() {
  this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
}
function emitErrorNT(Y, X) {
  Y.emit("error", X);
}
function errorOrDestroy(Y, X) {
  var ee = Y._readableState, te = Y._writableState;
  ee && ee.autoDestroy || te && te.autoDestroy ? Y.destroy(X) : Y.emit("error", X);
}
var destroy_1 = {
  destroy,
  undestroy,
  errorOrDestroy
}, errorsBrowser = {};
function _inheritsLoose(Y, X) {
  Y.prototype = Object.create(X.prototype), Y.prototype.constructor = Y, Y.__proto__ = X;
}
var codes = {};
function createErrorType(Y, X, ee) {
  ee || (ee = Error);
  function te(ie, oe, se) {
    return typeof X == "string" ? X : X(ie, oe, se);
  }
  var ne = /* @__PURE__ */ function(ie) {
    _inheritsLoose(oe, ie);
    function oe(se, ae, ue) {
      return ie.call(this, te(se, ae, ue)) || this;
    }
    return oe;
  }(ee);
  ne.prototype.name = ee.name, ne.prototype.code = Y, codes[Y] = ne;
}
function oneOf(Y, X) {
  if (Array.isArray(Y)) {
    var ee = Y.length;
    return Y = Y.map(function(te) {
      return String(te);
    }), ee > 2 ? "one of ".concat(X, " ").concat(Y.slice(0, ee - 1).join(", "), ", or ") + Y[ee - 1] : ee === 2 ? "one of ".concat(X, " ").concat(Y[0], " or ").concat(Y[1]) : "of ".concat(X, " ").concat(Y[0]);
  } else
    return "of ".concat(X, " ").concat(String(Y));
}
function startsWith(Y, X, ee) {
  return Y.substr(!ee || ee < 0 ? 0 : +ee, X.length) === X;
}
function endsWith(Y, X, ee) {
  return (ee === void 0 || ee > Y.length) && (ee = Y.length), Y.substring(ee - X.length, ee) === X;
}
function includes(Y, X, ee) {
  return typeof ee != "number" && (ee = 0), ee + X.length > Y.length ? !1 : Y.indexOf(X, ee) !== -1;
}
createErrorType("ERR_INVALID_OPT_VALUE", function(Y, X) {
  return 'The value "' + X + '" is invalid for option "' + Y + '"';
}, TypeError);
createErrorType("ERR_INVALID_ARG_TYPE", function(Y, X, ee) {
  var te;
  typeof X == "string" && startsWith(X, "not ") ? (te = "must not be", X = X.replace(/^not /, "")) : te = "must be";
  var ne;
  if (endsWith(Y, " argument"))
    ne = "The ".concat(Y, " ").concat(te, " ").concat(oneOf(X, "type"));
  else {
    var ie = includes(Y, ".") ? "property" : "argument";
    ne = 'The "'.concat(Y, '" ').concat(ie, " ").concat(te, " ").concat(oneOf(X, "type"));
  }
  return ne += ". Received type ".concat(typeof ee), ne;
}, TypeError);
createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(Y) {
  return "The " + Y + " method is not implemented";
});
createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
createErrorType("ERR_STREAM_DESTROYED", function(Y) {
  return "Cannot call " + Y + " after a stream was destroyed";
});
createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
createErrorType("ERR_UNKNOWN_ENCODING", function(Y) {
  return "Unknown encoding: " + Y;
}, TypeError);
createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
errorsBrowser.codes = codes;
var ERR_INVALID_OPT_VALUE = errorsBrowser.codes.ERR_INVALID_OPT_VALUE;
function highWaterMarkFrom(Y, X, ee) {
  return Y.highWaterMark != null ? Y.highWaterMark : X ? Y[ee] : null;
}
function getHighWaterMark(Y, X, ee, te) {
  var ne = highWaterMarkFrom(X, te, ee);
  if (ne != null) {
    if (!(isFinite(ne) && Math.floor(ne) === ne) || ne < 0) {
      var ie = te ? ee : "highWaterMark";
      throw new ERR_INVALID_OPT_VALUE(ie, ne);
    }
    return Math.floor(ne);
  }
  return Y.objectMode ? 16 : 16 * 1024;
}
var state = {
  getHighWaterMark
}, browser$d = deprecate;
function deprecate(Y, X) {
  if (config("noDeprecation"))
    return Y;
  var ee = !1;
  function te() {
    if (!ee) {
      if (config("throwDeprecation"))
        throw new Error(X);
      config("traceDeprecation") ? console.trace(X) : console.warn(X), ee = !0;
    }
    return Y.apply(this, arguments);
  }
  return te;
}
function config(Y) {
  try {
    if (!commonjsGlobal.localStorage)
      return !1;
  } catch {
    return !1;
  }
  var X = commonjsGlobal.localStorage[Y];
  return X == null ? !1 : String(X).toLowerCase() === "true";
}
var _stream_writable, hasRequired_stream_writable;
function require_stream_writable() {
  if (hasRequired_stream_writable)
    return _stream_writable;
  hasRequired_stream_writable = 1, _stream_writable = it;
  function Y(Ze) {
    var ot = this;
    this.next = null, this.entry = null, this.finish = function() {
      $e(ot, Ze);
    };
  }
  var X;
  it.WritableState = tt;
  var ee = {
    deprecate: browser$d
  }, te = streamBrowser, ne = require$$0$3.Buffer, ie = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function oe(Ze) {
    return ne.from(Ze);
  }
  function se(Ze) {
    return ne.isBuffer(Ze) || Ze instanceof ie;
  }
  var ae = destroy_1, ue = state, le = ue.getHighWaterMark, he = errorsBrowser.codes, me = he.ERR_INVALID_ARG_TYPE, ye = he.ERR_METHOD_NOT_IMPLEMENTED, we = he.ERR_MULTIPLE_CALLBACK, Ee = he.ERR_STREAM_CANNOT_PIPE, Re = he.ERR_STREAM_DESTROYED, Ue = he.ERR_STREAM_NULL_VALUES, Me = he.ERR_STREAM_WRITE_AFTER_END, De = he.ERR_UNKNOWN_ENCODING, Fe = ae.errorOrDestroy;
  inherits_browserExports(it, te);
  function Ke() {
  }
  function tt(Ze, ot, ct) {
    X = X || require_stream_duplex(), Ze = Ze || {}, typeof ct != "boolean" && (ct = ot instanceof X), this.objectMode = !!Ze.objectMode, ct && (this.objectMode = this.objectMode || !!Ze.writableObjectMode), this.highWaterMark = le(this, Ze, "writableHighWaterMark", ct), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var At = Ze.decodeStrings === !1;
    this.decodeStrings = !At, this.defaultEncoding = Ze.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(Tt) {
      Te(ot, Tt);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = Ze.emitClose !== !1, this.autoDestroy = !!Ze.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new Y(this);
  }
  tt.prototype.getBuffer = function() {
    for (var Ze = this.bufferedRequest, ot = []; Ze; )
      ot.push(Ze), Ze = Ze.next;
    return ot;
  }, function() {
    try {
      Object.defineProperty(tt.prototype, "buffer", {
        get: ee.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var rt;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (rt = Function.prototype[Symbol.hasInstance], Object.defineProperty(it, Symbol.hasInstance, {
    value: function(Ze) {
      return rt.call(this, Ze) ? !0 : this !== it ? !1 : Ze && Ze._writableState instanceof tt;
    }
  })) : rt = function(Ze) {
    return Ze instanceof this;
  };
  function it(Ze) {
    X = X || require_stream_duplex();
    var ot = this instanceof X;
    if (!ot && !rt.call(it, this))
      return new it(Ze);
    this._writableState = new tt(Ze, this, ot), this.writable = !0, Ze && (typeof Ze.write == "function" && (this._write = Ze.write), typeof Ze.writev == "function" && (this._writev = Ze.writev), typeof Ze.destroy == "function" && (this._destroy = Ze.destroy), typeof Ze.final == "function" && (this._final = Ze.final)), te.call(this);
  }
  it.prototype.pipe = function() {
    Fe(this, new Ee());
  };
  function _t(Ze, ot) {
    var ct = new Me();
    Fe(Ze, ct), process$1$1.nextTick(ot, ct);
  }
  function Dt(Ze, ot, ct, At) {
    var Tt;
    return ct === null ? Tt = new Ue() : typeof ct != "string" && !ot.objectMode && (Tt = new me("chunk", ["string", "Buffer"], ct)), Tt ? (Fe(Ze, Tt), process$1$1.nextTick(At, Tt), !1) : !0;
  }
  it.prototype.write = function(Ze, ot, ct) {
    var At = this._writableState, Tt = !1, dt = !At.objectMode && se(Ze);
    return dt && !ne.isBuffer(Ze) && (Ze = oe(Ze)), typeof ot == "function" && (ct = ot, ot = null), dt ? ot = "buffer" : ot || (ot = At.defaultEncoding), typeof ct != "function" && (ct = Ke), At.ending ? _t(this, ct) : (dt || Dt(this, At, Ze, ct)) && (At.pendingcb++, Tt = ze(this, At, dt, Ze, ot, ct)), Tt;
  }, it.prototype.cork = function() {
    this._writableState.corked++;
  }, it.prototype.uncork = function() {
    var Ze = this._writableState;
    Ze.corked && (Ze.corked--, !Ze.writing && !Ze.corked && !Ze.bufferProcessing && Ze.bufferedRequest && Se(this, Ze));
  }, it.prototype.setDefaultEncoding = function(Ze) {
    if (typeof Ze == "string" && (Ze = Ze.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((Ze + "").toLowerCase()) > -1))
      throw new De(Ze);
    return this._writableState.defaultEncoding = Ze, this;
  }, Object.defineProperty(it.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function je(Ze, ot, ct) {
    return !Ze.objectMode && Ze.decodeStrings !== !1 && typeof ot == "string" && (ot = ne.from(ot, ct)), ot;
  }
  Object.defineProperty(it.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function ze(Ze, ot, ct, At, Tt, dt) {
    if (!ct) {
      var vt = je(ot, At, Tt);
      At !== vt && (ct = !0, Tt = "buffer", At = vt);
    }
    var Ut = ot.objectMode ? 1 : At.length;
    ot.length += Ut;
    var It = ot.length < ot.highWaterMark;
    if (It || (ot.needDrain = !0), ot.writing || ot.corked) {
      var Er = ot.lastBufferedRequest;
      ot.lastBufferedRequest = {
        chunk: At,
        encoding: Tt,
        isBuf: ct,
        callback: dt,
        next: null
      }, Er ? Er.next = ot.lastBufferedRequest : ot.bufferedRequest = ot.lastBufferedRequest, ot.bufferedRequestCount += 1;
    } else
      fe(Ze, ot, !1, Ut, At, Tt, dt);
    return It;
  }
  function fe(Ze, ot, ct, At, Tt, dt, vt) {
    ot.writelen = At, ot.writecb = vt, ot.writing = !0, ot.sync = !0, ot.destroyed ? ot.onwrite(new Re("write")) : ct ? Ze._writev(Tt, ot.onwrite) : Ze._write(Tt, dt, ot.onwrite), ot.sync = !1;
  }
  function de(Ze, ot, ct, At, Tt) {
    --ot.pendingcb, ct ? (process$1$1.nextTick(Tt, At), process$1$1.nextTick(Ge, Ze, ot), Ze._writableState.errorEmitted = !0, Fe(Ze, At)) : (Tt(At), Ze._writableState.errorEmitted = !0, Fe(Ze, At), Ge(Ze, ot));
  }
  function be(Ze) {
    Ze.writing = !1, Ze.writecb = null, Ze.length -= Ze.writelen, Ze.writelen = 0;
  }
  function Te(Ze, ot) {
    var ct = Ze._writableState, At = ct.sync, Tt = ct.writecb;
    if (typeof Tt != "function")
      throw new we();
    if (be(ct), ot)
      de(Ze, ct, At, ot, Tt);
    else {
      var dt = ke(ct) || Ze.destroyed;
      !dt && !ct.corked && !ct.bufferProcessing && ct.bufferedRequest && Se(Ze, ct), At ? process$1$1.nextTick(Ce, Ze, ct, dt, Tt) : Ce(Ze, ct, dt, Tt);
    }
  }
  function Ce(Ze, ot, ct, At) {
    ct || Pe(Ze, ot), ot.pendingcb--, At(), Ge(Ze, ot);
  }
  function Pe(Ze, ot) {
    ot.length === 0 && ot.needDrain && (ot.needDrain = !1, Ze.emit("drain"));
  }
  function Se(Ze, ot) {
    ot.bufferProcessing = !0;
    var ct = ot.bufferedRequest;
    if (Ze._writev && ct && ct.next) {
      var At = ot.bufferedRequestCount, Tt = new Array(At), dt = ot.corkedRequestsFree;
      dt.entry = ct;
      for (var vt = 0, Ut = !0; ct; )
        Tt[vt] = ct, ct.isBuf || (Ut = !1), ct = ct.next, vt += 1;
      Tt.allBuffers = Ut, fe(Ze, ot, !0, ot.length, Tt, "", dt.finish), ot.pendingcb++, ot.lastBufferedRequest = null, dt.next ? (ot.corkedRequestsFree = dt.next, dt.next = null) : ot.corkedRequestsFree = new Y(ot), ot.bufferedRequestCount = 0;
    } else {
      for (; ct; ) {
        var It = ct.chunk, Er = ct.encoding, Fr = ct.callback, an = ot.objectMode ? 1 : It.length;
        if (fe(Ze, ot, !1, an, It, Er, Fr), ct = ct.next, ot.bufferedRequestCount--, ot.writing)
          break;
      }
      ct === null && (ot.lastBufferedRequest = null);
    }
    ot.bufferedRequest = ct, ot.bufferProcessing = !1;
  }
  it.prototype._write = function(Ze, ot, ct) {
    ct(new ye("_write()"));
  }, it.prototype._writev = null, it.prototype.end = function(Ze, ot, ct) {
    var At = this._writableState;
    return typeof Ze == "function" ? (ct = Ze, Ze = null, ot = null) : typeof ot == "function" && (ct = ot, ot = null), Ze != null && this.write(Ze, ot), At.corked && (At.corked = 1, this.uncork()), At.ending || Xe(this, At, ct), this;
  }, Object.defineProperty(it.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function ke(Ze) {
    return Ze.ending && Ze.length === 0 && Ze.bufferedRequest === null && !Ze.finished && !Ze.writing;
  }
  function ge(Ze, ot) {
    Ze._final(function(ct) {
      ot.pendingcb--, ct && Fe(Ze, ct), ot.prefinished = !0, Ze.emit("prefinish"), Ge(Ze, ot);
    });
  }
  function Ae(Ze, ot) {
    !ot.prefinished && !ot.finalCalled && (typeof Ze._final == "function" && !ot.destroyed ? (ot.pendingcb++, ot.finalCalled = !0, process$1$1.nextTick(ge, Ze, ot)) : (ot.prefinished = !0, Ze.emit("prefinish")));
  }
  function Ge(Ze, ot) {
    var ct = ke(ot);
    if (ct && (Ae(Ze, ot), ot.pendingcb === 0 && (ot.finished = !0, Ze.emit("finish"), ot.autoDestroy))) {
      var At = Ze._readableState;
      (!At || At.autoDestroy && At.endEmitted) && Ze.destroy();
    }
    return ct;
  }
  function Xe(Ze, ot, ct) {
    ot.ending = !0, Ge(Ze, ot), ct && (ot.finished ? process$1$1.nextTick(ct) : Ze.once("finish", ct)), ot.ended = !0, Ze.writable = !1;
  }
  function $e(Ze, ot, ct) {
    var At = Ze.entry;
    for (Ze.entry = null; At; ) {
      var Tt = At.callback;
      ot.pendingcb--, Tt(ct), At = At.next;
    }
    ot.corkedRequestsFree.next = Ze;
  }
  return Object.defineProperty(it.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function(Ze) {
      this._writableState && (this._writableState.destroyed = Ze);
    }
  }), it.prototype.destroy = ae.destroy, it.prototype._undestroy = ae.undestroy, it.prototype._destroy = function(Ze, ot) {
    ot(Ze);
  }, _stream_writable;
}
var _stream_duplex, hasRequired_stream_duplex;
function require_stream_duplex() {
  if (hasRequired_stream_duplex)
    return _stream_duplex;
  hasRequired_stream_duplex = 1;
  var Y = Object.keys || function(ue) {
    var le = [];
    for (var he in ue)
      le.push(he);
    return le;
  };
  _stream_duplex = oe;
  var X = require_stream_readable(), ee = require_stream_writable();
  inherits_browserExports(oe, X);
  for (var te = Y(ee.prototype), ne = 0; ne < te.length; ne++) {
    var ie = te[ne];
    oe.prototype[ie] || (oe.prototype[ie] = ee.prototype[ie]);
  }
  function oe(ue) {
    if (!(this instanceof oe))
      return new oe(ue);
    X.call(this, ue), ee.call(this, ue), this.allowHalfOpen = !0, ue && (ue.readable === !1 && (this.readable = !1), ue.writable === !1 && (this.writable = !1), ue.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", se)));
  }
  Object.defineProperty(oe.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  }), Object.defineProperty(oe.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  }), Object.defineProperty(oe.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function se() {
    this._writableState.ended || process$1$1.nextTick(ae, this);
  }
  function ae(ue) {
    ue.end();
  }
  return Object.defineProperty(oe.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(ue) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = ue, this._writableState.destroyed = ue);
    }
  }), _stream_duplex;
}
var string_decoder = {}, Buffer$d = safeBufferExports.Buffer, isEncoding = Buffer$d.isEncoding || function(Y) {
  switch (Y = "" + Y, Y && Y.toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
    case "raw":
      return !0;
    default:
      return !1;
  }
};
function _normalizeEncoding(Y) {
  if (!Y)
    return "utf8";
  for (var X; ; )
    switch (Y) {
      case "utf8":
      case "utf-8":
        return "utf8";
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return "utf16le";
      case "latin1":
      case "binary":
        return "latin1";
      case "base64":
      case "ascii":
      case "hex":
        return Y;
      default:
        if (X)
          return;
        Y = ("" + Y).toLowerCase(), X = !0;
    }
}
function normalizeEncoding(Y) {
  var X = _normalizeEncoding(Y);
  if (typeof X != "string" && (Buffer$d.isEncoding === isEncoding || !isEncoding(Y)))
    throw new Error("Unknown encoding: " + Y);
  return X || Y;
}
string_decoder.StringDecoder = StringDecoder$1;
function StringDecoder$1(Y) {
  this.encoding = normalizeEncoding(Y);
  var X;
  switch (this.encoding) {
    case "utf16le":
      this.text = utf16Text, this.end = utf16End, X = 4;
      break;
    case "utf8":
      this.fillLast = utf8FillLast, X = 4;
      break;
    case "base64":
      this.text = base64Text, this.end = base64End, X = 3;
      break;
    default:
      this.write = simpleWrite, this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0, this.lastTotal = 0, this.lastChar = Buffer$d.allocUnsafe(X);
}
StringDecoder$1.prototype.write = function(Y) {
  if (Y.length === 0)
    return "";
  var X, ee;
  if (this.lastNeed) {
    if (X = this.fillLast(Y), X === void 0)
      return "";
    ee = this.lastNeed, this.lastNeed = 0;
  } else
    ee = 0;
  return ee < Y.length ? X ? X + this.text(Y, ee) : this.text(Y, ee) : X || "";
};
StringDecoder$1.prototype.end = utf8End;
StringDecoder$1.prototype.text = utf8Text;
StringDecoder$1.prototype.fillLast = function(Y) {
  if (this.lastNeed <= Y.length)
    return Y.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
  Y.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, Y.length), this.lastNeed -= Y.length;
};
function utf8CheckByte(Y) {
  return Y <= 127 ? 0 : Y >> 5 === 6 ? 2 : Y >> 4 === 14 ? 3 : Y >> 3 === 30 ? 4 : Y >> 6 === 2 ? -1 : -2;
}
function utf8CheckIncomplete(Y, X, ee) {
  var te = X.length - 1;
  if (te < ee)
    return 0;
  var ne = utf8CheckByte(X[te]);
  return ne >= 0 ? (ne > 0 && (Y.lastNeed = ne - 1), ne) : --te < ee || ne === -2 ? 0 : (ne = utf8CheckByte(X[te]), ne >= 0 ? (ne > 0 && (Y.lastNeed = ne - 2), ne) : --te < ee || ne === -2 ? 0 : (ne = utf8CheckByte(X[te]), ne >= 0 ? (ne > 0 && (ne === 2 ? ne = 0 : Y.lastNeed = ne - 3), ne) : 0));
}
function utf8CheckExtraBytes(Y, X, ee) {
  if ((X[0] & 192) !== 128)
    return Y.lastNeed = 0, "";
  if (Y.lastNeed > 1 && X.length > 1) {
    if ((X[1] & 192) !== 128)
      return Y.lastNeed = 1, "";
    if (Y.lastNeed > 2 && X.length > 2 && (X[2] & 192) !== 128)
      return Y.lastNeed = 2, "";
  }
}
function utf8FillLast(Y) {
  var X = this.lastTotal - this.lastNeed, ee = utf8CheckExtraBytes(this, Y);
  if (ee !== void 0)
    return ee;
  if (this.lastNeed <= Y.length)
    return Y.copy(this.lastChar, X, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
  Y.copy(this.lastChar, X, 0, Y.length), this.lastNeed -= Y.length;
}
function utf8Text(Y, X) {
  var ee = utf8CheckIncomplete(this, Y, X);
  if (!this.lastNeed)
    return Y.toString("utf8", X);
  this.lastTotal = ee;
  var te = Y.length - (ee - this.lastNeed);
  return Y.copy(this.lastChar, 0, te), Y.toString("utf8", X, te);
}
function utf8End(Y) {
  var X = Y && Y.length ? this.write(Y) : "";
  return this.lastNeed ? X + "" : X;
}
function utf16Text(Y, X) {
  if ((Y.length - X) % 2 === 0) {
    var ee = Y.toString("utf16le", X);
    if (ee) {
      var te = ee.charCodeAt(ee.length - 1);
      if (te >= 55296 && te <= 56319)
        return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = Y[Y.length - 2], this.lastChar[1] = Y[Y.length - 1], ee.slice(0, -1);
    }
    return ee;
  }
  return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = Y[Y.length - 1], Y.toString("utf16le", X, Y.length - 1);
}
function utf16End(Y) {
  var X = Y && Y.length ? this.write(Y) : "";
  if (this.lastNeed) {
    var ee = this.lastTotal - this.lastNeed;
    return X + this.lastChar.toString("utf16le", 0, ee);
  }
  return X;
}
function base64Text(Y, X) {
  var ee = (Y.length - X) % 3;
  return ee === 0 ? Y.toString("base64", X) : (this.lastNeed = 3 - ee, this.lastTotal = 3, ee === 1 ? this.lastChar[0] = Y[Y.length - 1] : (this.lastChar[0] = Y[Y.length - 2], this.lastChar[1] = Y[Y.length - 1]), Y.toString("base64", X, Y.length - ee));
}
function base64End(Y) {
  var X = Y && Y.length ? this.write(Y) : "";
  return this.lastNeed ? X + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : X;
}
function simpleWrite(Y) {
  return Y.toString(this.encoding);
}
function simpleEnd(Y) {
  return Y && Y.length ? this.write(Y) : "";
}
var ERR_STREAM_PREMATURE_CLOSE = errorsBrowser.codes.ERR_STREAM_PREMATURE_CLOSE;
function once$1(Y) {
  var X = !1;
  return function() {
    if (!X) {
      X = !0;
      for (var ee = arguments.length, te = new Array(ee), ne = 0; ne < ee; ne++)
        te[ne] = arguments[ne];
      Y.apply(this, te);
    }
  };
}
function noop$1() {
}
function isRequest$1(Y) {
  return Y.setHeader && typeof Y.abort == "function";
}
function eos$1(Y, X, ee) {
  if (typeof X == "function")
    return eos$1(Y, null, X);
  X || (X = {}), ee = once$1(ee || noop$1);
  var te = X.readable || X.readable !== !1 && Y.readable, ne = X.writable || X.writable !== !1 && Y.writable, ie = function() {
    Y.writable || se();
  }, oe = Y._writableState && Y._writableState.finished, se = function() {
    ne = !1, oe = !0, te || ee.call(Y);
  }, ae = Y._readableState && Y._readableState.endEmitted, ue = function() {
    te = !1, ae = !0, ne || ee.call(Y);
  }, le = function(ye) {
    ee.call(Y, ye);
  }, he = function() {
    var ye;
    if (te && !ae)
      return (!Y._readableState || !Y._readableState.ended) && (ye = new ERR_STREAM_PREMATURE_CLOSE()), ee.call(Y, ye);
    if (ne && !oe)
      return (!Y._writableState || !Y._writableState.ended) && (ye = new ERR_STREAM_PREMATURE_CLOSE()), ee.call(Y, ye);
  }, me = function() {
    Y.req.on("finish", se);
  };
  return isRequest$1(Y) ? (Y.on("complete", se), Y.on("abort", he), Y.req ? me() : Y.on("request", me)) : ne && !Y._writableState && (Y.on("end", ie), Y.on("close", ie)), Y.on("end", ue), Y.on("finish", se), X.error !== !1 && Y.on("error", le), Y.on("close", he), function() {
    Y.removeListener("complete", se), Y.removeListener("abort", he), Y.removeListener("request", me), Y.req && Y.req.removeListener("finish", se), Y.removeListener("end", ie), Y.removeListener("close", ie), Y.removeListener("finish", se), Y.removeListener("end", ue), Y.removeListener("error", le), Y.removeListener("close", he);
  };
}
var endOfStream = eos$1, async_iterator, hasRequiredAsync_iterator;
function requireAsync_iterator() {
  if (hasRequiredAsync_iterator)
    return async_iterator;
  hasRequiredAsync_iterator = 1;
  var Y;
  function X(De, Fe, Ke) {
    return Fe = ee(Fe), Fe in De ? Object.defineProperty(De, Fe, { value: Ke, enumerable: !0, configurable: !0, writable: !0 }) : De[Fe] = Ke, De;
  }
  function ee(De) {
    var Fe = te(De, "string");
    return typeof Fe == "symbol" ? Fe : String(Fe);
  }
  function te(De, Fe) {
    if (typeof De != "object" || De === null)
      return De;
    var Ke = De[Symbol.toPrimitive];
    if (Ke !== void 0) {
      var tt = Ke.call(De, Fe || "default");
      if (typeof tt != "object")
        return tt;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (Fe === "string" ? String : Number)(De);
  }
  var ne = endOfStream, ie = Symbol("lastResolve"), oe = Symbol("lastReject"), se = Symbol("error"), ae = Symbol("ended"), ue = Symbol("lastPromise"), le = Symbol("handlePromise"), he = Symbol("stream");
  function me(De, Fe) {
    return {
      value: De,
      done: Fe
    };
  }
  function ye(De) {
    var Fe = De[ie];
    if (Fe !== null) {
      var Ke = De[he].read();
      Ke !== null && (De[ue] = null, De[ie] = null, De[oe] = null, Fe(me(Ke, !1)));
    }
  }
  function we(De) {
    process$1$1.nextTick(ye, De);
  }
  function Ee(De, Fe) {
    return function(Ke, tt) {
      De.then(function() {
        if (Fe[ae]) {
          Ke(me(void 0, !0));
          return;
        }
        Fe[le](Ke, tt);
      }, tt);
    };
  }
  var Re = Object.getPrototypeOf(function() {
  }), Ue = Object.setPrototypeOf((Y = {
    get stream() {
      return this[he];
    },
    next: function() {
      var De = this, Fe = this[se];
      if (Fe !== null)
        return Promise.reject(Fe);
      if (this[ae])
        return Promise.resolve(me(void 0, !0));
      if (this[he].destroyed)
        return new Promise(function(it, _t) {
          process$1$1.nextTick(function() {
            De[se] ? _t(De[se]) : it(me(void 0, !0));
          });
        });
      var Ke = this[ue], tt;
      if (Ke)
        tt = new Promise(Ee(Ke, this));
      else {
        var rt = this[he].read();
        if (rt !== null)
          return Promise.resolve(me(rt, !1));
        tt = new Promise(this[le]);
      }
      return this[ue] = tt, tt;
    }
  }, X(Y, Symbol.asyncIterator, function() {
    return this;
  }), X(Y, "return", function() {
    var De = this;
    return new Promise(function(Fe, Ke) {
      De[he].destroy(null, function(tt) {
        if (tt) {
          Ke(tt);
          return;
        }
        Fe(me(void 0, !0));
      });
    });
  }), Y), Re), Me = function(De) {
    var Fe, Ke = Object.create(Ue, (Fe = {}, X(Fe, he, {
      value: De,
      writable: !0
    }), X(Fe, ie, {
      value: null,
      writable: !0
    }), X(Fe, oe, {
      value: null,
      writable: !0
    }), X(Fe, se, {
      value: null,
      writable: !0
    }), X(Fe, ae, {
      value: De._readableState.endEmitted,
      writable: !0
    }), X(Fe, le, {
      value: function(tt, rt) {
        var it = Ke[he].read();
        it ? (Ke[ue] = null, Ke[ie] = null, Ke[oe] = null, tt(me(it, !1))) : (Ke[ie] = tt, Ke[oe] = rt);
      },
      writable: !0
    }), Fe));
    return Ke[ue] = null, ne(De, function(tt) {
      if (tt && tt.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var rt = Ke[oe];
        rt !== null && (Ke[ue] = null, Ke[ie] = null, Ke[oe] = null, rt(tt)), Ke[se] = tt;
        return;
      }
      var it = Ke[ie];
      it !== null && (Ke[ue] = null, Ke[ie] = null, Ke[oe] = null, it(me(void 0, !0))), Ke[ae] = !0;
    }), De.on("readable", we.bind(null, Ke)), Ke;
  };
  return async_iterator = Me, async_iterator;
}
var fromBrowser, hasRequiredFromBrowser;
function requireFromBrowser() {
  return hasRequiredFromBrowser || (hasRequiredFromBrowser = 1, fromBrowser = function() {
    throw new Error("Readable.from is not available in the browser");
  }), fromBrowser;
}
var _stream_readable, hasRequired_stream_readable;
function require_stream_readable() {
  if (hasRequired_stream_readable)
    return _stream_readable;
  hasRequired_stream_readable = 1, _stream_readable = _t;
  var Y;
  _t.ReadableState = it, eventsExports.EventEmitter;
  var X = function(dt, vt) {
    return dt.listeners(vt).length;
  }, ee = streamBrowser, te = require$$0$3.Buffer, ne = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function ie(dt) {
    return te.from(dt);
  }
  function oe(dt) {
    return te.isBuffer(dt) || dt instanceof ne;
  }
  var se = util, ae;
  se && se.debuglog ? ae = se.debuglog("stream") : ae = function() {
  };
  var ue = requireBuffer_list(), le = destroy_1, he = state, me = he.getHighWaterMark, ye = errorsBrowser.codes, we = ye.ERR_INVALID_ARG_TYPE, Ee = ye.ERR_STREAM_PUSH_AFTER_EOF, Re = ye.ERR_METHOD_NOT_IMPLEMENTED, Ue = ye.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, Me, De, Fe;
  inherits_browserExports(_t, ee);
  var Ke = le.errorOrDestroy, tt = ["error", "close", "destroy", "pause", "resume"];
  function rt(dt, vt, Ut) {
    if (typeof dt.prependListener == "function")
      return dt.prependListener(vt, Ut);
    !dt._events || !dt._events[vt] ? dt.on(vt, Ut) : Array.isArray(dt._events[vt]) ? dt._events[vt].unshift(Ut) : dt._events[vt] = [Ut, dt._events[vt]];
  }
  function it(dt, vt, Ut) {
    Y = Y || require_stream_duplex(), dt = dt || {}, typeof Ut != "boolean" && (Ut = vt instanceof Y), this.objectMode = !!dt.objectMode, Ut && (this.objectMode = this.objectMode || !!dt.readableObjectMode), this.highWaterMark = me(this, dt, "readableHighWaterMark", Ut), this.buffer = new ue(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = dt.emitClose !== !1, this.autoDestroy = !!dt.autoDestroy, this.destroyed = !1, this.defaultEncoding = dt.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, dt.encoding && (Me || (Me = string_decoder.StringDecoder), this.decoder = new Me(dt.encoding), this.encoding = dt.encoding);
  }
  function _t(dt) {
    if (Y = Y || require_stream_duplex(), !(this instanceof _t))
      return new _t(dt);
    var vt = this instanceof Y;
    this._readableState = new it(dt, this, vt), this.readable = !0, dt && (typeof dt.read == "function" && (this._read = dt.read), typeof dt.destroy == "function" && (this._destroy = dt.destroy)), ee.call(this);
  }
  Object.defineProperty(_t.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(dt) {
      this._readableState && (this._readableState.destroyed = dt);
    }
  }), _t.prototype.destroy = le.destroy, _t.prototype._undestroy = le.undestroy, _t.prototype._destroy = function(dt, vt) {
    vt(dt);
  }, _t.prototype.push = function(dt, vt) {
    var Ut = this._readableState, It;
    return Ut.objectMode ? It = !0 : typeof dt == "string" && (vt = vt || Ut.defaultEncoding, vt !== Ut.encoding && (dt = te.from(dt, vt), vt = ""), It = !0), Dt(this, dt, vt, !1, It);
  }, _t.prototype.unshift = function(dt) {
    return Dt(this, dt, null, !0, !1);
  };
  function Dt(dt, vt, Ut, It, Er) {
    ae("readableAddChunk", vt);
    var Fr = dt._readableState;
    if (vt === null)
      Fr.reading = !1, Te(dt, Fr);
    else {
      var an;
      if (Er || (an = ze(Fr, vt)), an)
        Ke(dt, an);
      else if (Fr.objectMode || vt && vt.length > 0)
        if (typeof vt != "string" && !Fr.objectMode && Object.getPrototypeOf(vt) !== te.prototype && (vt = ie(vt)), It)
          Fr.endEmitted ? Ke(dt, new Ue()) : je(dt, Fr, vt, !0);
        else if (Fr.ended)
          Ke(dt, new Ee());
        else {
          if (Fr.destroyed)
            return !1;
          Fr.reading = !1, Fr.decoder && !Ut ? (vt = Fr.decoder.write(vt), Fr.objectMode || vt.length !== 0 ? je(dt, Fr, vt, !1) : Se(dt, Fr)) : je(dt, Fr, vt, !1);
        }
      else
        It || (Fr.reading = !1, Se(dt, Fr));
    }
    return !Fr.ended && (Fr.length < Fr.highWaterMark || Fr.length === 0);
  }
  function je(dt, vt, Ut, It) {
    vt.flowing && vt.length === 0 && !vt.sync ? (vt.awaitDrain = 0, dt.emit("data", Ut)) : (vt.length += vt.objectMode ? 1 : Ut.length, It ? vt.buffer.unshift(Ut) : vt.buffer.push(Ut), vt.needReadable && Ce(dt)), Se(dt, vt);
  }
  function ze(dt, vt) {
    var Ut;
    return !oe(vt) && typeof vt != "string" && vt !== void 0 && !dt.objectMode && (Ut = new we("chunk", ["string", "Buffer", "Uint8Array"], vt)), Ut;
  }
  _t.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, _t.prototype.setEncoding = function(dt) {
    Me || (Me = string_decoder.StringDecoder);
    var vt = new Me(dt);
    this._readableState.decoder = vt, this._readableState.encoding = this._readableState.decoder.encoding;
    for (var Ut = this._readableState.buffer.head, It = ""; Ut !== null; )
      It += vt.write(Ut.data), Ut = Ut.next;
    return this._readableState.buffer.clear(), It !== "" && this._readableState.buffer.push(It), this._readableState.length = It.length, this;
  };
  var fe = 1073741824;
  function de(dt) {
    return dt >= fe ? dt = fe : (dt--, dt |= dt >>> 1, dt |= dt >>> 2, dt |= dt >>> 4, dt |= dt >>> 8, dt |= dt >>> 16, dt++), dt;
  }
  function be(dt, vt) {
    return dt <= 0 || vt.length === 0 && vt.ended ? 0 : vt.objectMode ? 1 : dt !== dt ? vt.flowing && vt.length ? vt.buffer.head.data.length : vt.length : (dt > vt.highWaterMark && (vt.highWaterMark = de(dt)), dt <= vt.length ? dt : vt.ended ? vt.length : (vt.needReadable = !0, 0));
  }
  _t.prototype.read = function(dt) {
    ae("read", dt), dt = parseInt(dt, 10);
    var vt = this._readableState, Ut = dt;
    if (dt !== 0 && (vt.emittedReadable = !1), dt === 0 && vt.needReadable && ((vt.highWaterMark !== 0 ? vt.length >= vt.highWaterMark : vt.length > 0) || vt.ended))
      return ae("read: emitReadable", vt.length, vt.ended), vt.length === 0 && vt.ended ? ct(this) : Ce(this), null;
    if (dt = be(dt, vt), dt === 0 && vt.ended)
      return vt.length === 0 && ct(this), null;
    var It = vt.needReadable;
    ae("need readable", It), (vt.length === 0 || vt.length - dt < vt.highWaterMark) && (It = !0, ae("length less than watermark", It)), vt.ended || vt.reading ? (It = !1, ae("reading or ended", It)) : It && (ae("do read"), vt.reading = !0, vt.sync = !0, vt.length === 0 && (vt.needReadable = !0), this._read(vt.highWaterMark), vt.sync = !1, vt.reading || (dt = be(Ut, vt)));
    var Er;
    return dt > 0 ? Er = ot(dt, vt) : Er = null, Er === null ? (vt.needReadable = vt.length <= vt.highWaterMark, dt = 0) : (vt.length -= dt, vt.awaitDrain = 0), vt.length === 0 && (vt.ended || (vt.needReadable = !0), Ut !== dt && vt.ended && ct(this)), Er !== null && this.emit("data", Er), Er;
  };
  function Te(dt, vt) {
    if (ae("onEofChunk"), !vt.ended) {
      if (vt.decoder) {
        var Ut = vt.decoder.end();
        Ut && Ut.length && (vt.buffer.push(Ut), vt.length += vt.objectMode ? 1 : Ut.length);
      }
      vt.ended = !0, vt.sync ? Ce(dt) : (vt.needReadable = !1, vt.emittedReadable || (vt.emittedReadable = !0, Pe(dt)));
    }
  }
  function Ce(dt) {
    var vt = dt._readableState;
    ae("emitReadable", vt.needReadable, vt.emittedReadable), vt.needReadable = !1, vt.emittedReadable || (ae("emitReadable", vt.flowing), vt.emittedReadable = !0, process$1$1.nextTick(Pe, dt));
  }
  function Pe(dt) {
    var vt = dt._readableState;
    ae("emitReadable_", vt.destroyed, vt.length, vt.ended), !vt.destroyed && (vt.length || vt.ended) && (dt.emit("readable"), vt.emittedReadable = !1), vt.needReadable = !vt.flowing && !vt.ended && vt.length <= vt.highWaterMark, Ze(dt);
  }
  function Se(dt, vt) {
    vt.readingMore || (vt.readingMore = !0, process$1$1.nextTick(ke, dt, vt));
  }
  function ke(dt, vt) {
    for (; !vt.reading && !vt.ended && (vt.length < vt.highWaterMark || vt.flowing && vt.length === 0); ) {
      var Ut = vt.length;
      if (ae("maybeReadMore read 0"), dt.read(0), Ut === vt.length)
        break;
    }
    vt.readingMore = !1;
  }
  _t.prototype._read = function(dt) {
    Ke(this, new Re("_read()"));
  }, _t.prototype.pipe = function(dt, vt) {
    var Ut = this, It = this._readableState;
    switch (It.pipesCount) {
      case 0:
        It.pipes = dt;
        break;
      case 1:
        It.pipes = [It.pipes, dt];
        break;
      default:
        It.pipes.push(dt);
        break;
    }
    It.pipesCount += 1, ae("pipe count=%d opts=%j", It.pipesCount, vt);
    var Er = (!vt || vt.end !== !1) && dt !== process$1$1.stdout && dt !== process$1$1.stderr, Fr = Er ? wX : nX;
    It.endEmitted ? process$1$1.nextTick(Fr) : Ut.once("end", Fr), dt.on("unpipe", an);
    function an(Ye, lt) {
      ae("onunpipe"), Ye === Ut && lt && lt.hasUnpiped === !1 && (lt.hasUnpiped = !0, hX());
    }
    function wX() {
      ae("onend"), dt.end();
    }
    var Ct = ge(Ut);
    dt.on("drain", Ct);
    var w_ = !1;
    function hX() {
      ae("cleanup"), dt.removeListener("close", SX), dt.removeListener("finish", sX), dt.removeListener("drain", Ct), dt.removeListener("error", Nn), dt.removeListener("unpipe", an), Ut.removeListener("end", wX), Ut.removeListener("end", nX), Ut.removeListener("data", oX), w_ = !0, It.awaitDrain && (!dt._writableState || dt._writableState.needDrain) && Ct();
    }
    Ut.on("data", oX);
    function oX(Ye) {
      ae("ondata");
      var lt = dt.write(Ye);
      ae("dest.write", lt), lt === !1 && ((It.pipesCount === 1 && It.pipes === dt || It.pipesCount > 1 && Tt(It.pipes, dt) !== -1) && !w_ && (ae("false write response, pause", It.awaitDrain), It.awaitDrain++), Ut.pause());
    }
    function Nn(Ye) {
      ae("onerror", Ye), nX(), dt.removeListener("error", Nn), X(dt, "error") === 0 && Ke(dt, Ye);
    }
    rt(dt, "error", Nn);
    function SX() {
      dt.removeListener("finish", sX), nX();
    }
    dt.once("close", SX);
    function sX() {
      ae("onfinish"), dt.removeListener("close", SX), nX();
    }
    dt.once("finish", sX);
    function nX() {
      ae("unpipe"), Ut.unpipe(dt);
    }
    return dt.emit("pipe", Ut), It.flowing || (ae("pipe resume"), Ut.resume()), dt;
  };
  function ge(dt) {
    return function() {
      var vt = dt._readableState;
      ae("pipeOnDrain", vt.awaitDrain), vt.awaitDrain && vt.awaitDrain--, vt.awaitDrain === 0 && X(dt, "data") && (vt.flowing = !0, Ze(dt));
    };
  }
  _t.prototype.unpipe = function(dt) {
    var vt = this._readableState, Ut = {
      hasUnpiped: !1
    };
    if (vt.pipesCount === 0)
      return this;
    if (vt.pipesCount === 1)
      return dt && dt !== vt.pipes ? this : (dt || (dt = vt.pipes), vt.pipes = null, vt.pipesCount = 0, vt.flowing = !1, dt && dt.emit("unpipe", this, Ut), this);
    if (!dt) {
      var It = vt.pipes, Er = vt.pipesCount;
      vt.pipes = null, vt.pipesCount = 0, vt.flowing = !1;
      for (var Fr = 0; Fr < Er; Fr++)
        It[Fr].emit("unpipe", this, {
          hasUnpiped: !1
        });
      return this;
    }
    var an = Tt(vt.pipes, dt);
    return an === -1 ? this : (vt.pipes.splice(an, 1), vt.pipesCount -= 1, vt.pipesCount === 1 && (vt.pipes = vt.pipes[0]), dt.emit("unpipe", this, Ut), this);
  }, _t.prototype.on = function(dt, vt) {
    var Ut = ee.prototype.on.call(this, dt, vt), It = this._readableState;
    return dt === "data" ? (It.readableListening = this.listenerCount("readable") > 0, It.flowing !== !1 && this.resume()) : dt === "readable" && !It.endEmitted && !It.readableListening && (It.readableListening = It.needReadable = !0, It.flowing = !1, It.emittedReadable = !1, ae("on readable", It.length, It.reading), It.length ? Ce(this) : It.reading || process$1$1.nextTick(Ge, this)), Ut;
  }, _t.prototype.addListener = _t.prototype.on, _t.prototype.removeListener = function(dt, vt) {
    var Ut = ee.prototype.removeListener.call(this, dt, vt);
    return dt === "readable" && process$1$1.nextTick(Ae, this), Ut;
  }, _t.prototype.removeAllListeners = function(dt) {
    var vt = ee.prototype.removeAllListeners.apply(this, arguments);
    return (dt === "readable" || dt === void 0) && process$1$1.nextTick(Ae, this), vt;
  };
  function Ae(dt) {
    var vt = dt._readableState;
    vt.readableListening = dt.listenerCount("readable") > 0, vt.resumeScheduled && !vt.paused ? vt.flowing = !0 : dt.listenerCount("data") > 0 && dt.resume();
  }
  function Ge(dt) {
    ae("readable nexttick read 0"), dt.read(0);
  }
  _t.prototype.resume = function() {
    var dt = this._readableState;
    return dt.flowing || (ae("resume"), dt.flowing = !dt.readableListening, Xe(this, dt)), dt.paused = !1, this;
  };
  function Xe(dt, vt) {
    vt.resumeScheduled || (vt.resumeScheduled = !0, process$1$1.nextTick($e, dt, vt));
  }
  function $e(dt, vt) {
    ae("resume", vt.reading), vt.reading || dt.read(0), vt.resumeScheduled = !1, dt.emit("resume"), Ze(dt), vt.flowing && !vt.reading && dt.read(0);
  }
  _t.prototype.pause = function() {
    return ae("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (ae("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
  };
  function Ze(dt) {
    var vt = dt._readableState;
    for (ae("flow", vt.flowing); vt.flowing && dt.read() !== null; )
      ;
  }
  _t.prototype.wrap = function(dt) {
    var vt = this, Ut = this._readableState, It = !1;
    dt.on("end", function() {
      if (ae("wrapped end"), Ut.decoder && !Ut.ended) {
        var an = Ut.decoder.end();
        an && an.length && vt.push(an);
      }
      vt.push(null);
    }), dt.on("data", function(an) {
      if (ae("wrapped data"), Ut.decoder && (an = Ut.decoder.write(an)), !(Ut.objectMode && an == null) && !(!Ut.objectMode && (!an || !an.length))) {
        var wX = vt.push(an);
        wX || (It = !0, dt.pause());
      }
    });
    for (var Er in dt)
      this[Er] === void 0 && typeof dt[Er] == "function" && (this[Er] = /* @__PURE__ */ function(an) {
        return function() {
          return dt[an].apply(dt, arguments);
        };
      }(Er));
    for (var Fr = 0; Fr < tt.length; Fr++)
      dt.on(tt[Fr], this.emit.bind(this, tt[Fr]));
    return this._read = function(an) {
      ae("wrapped _read", an), It && (It = !1, dt.resume());
    }, this;
  }, typeof Symbol == "function" && (_t.prototype[Symbol.asyncIterator] = function() {
    return De === void 0 && (De = requireAsync_iterator()), De(this);
  }), Object.defineProperty(_t.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), Object.defineProperty(_t.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState && this._readableState.buffer;
    }
  }), Object.defineProperty(_t.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.flowing;
    },
    set: function(dt) {
      this._readableState && (this._readableState.flowing = dt);
    }
  }), _t._fromList = ot, Object.defineProperty(_t.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.length;
    }
  });
  function ot(dt, vt) {
    if (vt.length === 0)
      return null;
    var Ut;
    return vt.objectMode ? Ut = vt.buffer.shift() : !dt || dt >= vt.length ? (vt.decoder ? Ut = vt.buffer.join("") : vt.buffer.length === 1 ? Ut = vt.buffer.first() : Ut = vt.buffer.concat(vt.length), vt.buffer.clear()) : Ut = vt.buffer.consume(dt, vt.decoder), Ut;
  }
  function ct(dt) {
    var vt = dt._readableState;
    ae("endReadable", vt.endEmitted), vt.endEmitted || (vt.ended = !0, process$1$1.nextTick(At, vt, dt));
  }
  function At(dt, vt) {
    if (ae("endReadableNT", dt.endEmitted, dt.length), !dt.endEmitted && dt.length === 0 && (dt.endEmitted = !0, vt.readable = !1, vt.emit("end"), dt.autoDestroy)) {
      var Ut = vt._writableState;
      (!Ut || Ut.autoDestroy && Ut.finished) && vt.destroy();
    }
  }
  typeof Symbol == "function" && (_t.from = function(dt, vt) {
    return Fe === void 0 && (Fe = requireFromBrowser()), Fe(_t, dt, vt);
  });
  function Tt(dt, vt) {
    for (var Ut = 0, It = dt.length; Ut < It; Ut++)
      if (dt[Ut] === vt)
        return Ut;
    return -1;
  }
  return _stream_readable;
}
var _stream_transform = Transform$3, _require$codes$1 = errorsBrowser.codes, ERR_METHOD_NOT_IMPLEMENTED = _require$codes$1.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes$1.ERR_MULTIPLE_CALLBACK, ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes$1.ERR_TRANSFORM_ALREADY_TRANSFORMING, ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes$1.ERR_TRANSFORM_WITH_LENGTH_0, Duplex = require_stream_duplex();
inherits_browserExports(Transform$3, Duplex);
function afterTransform(Y, X) {
  var ee = this._transformState;
  ee.transforming = !1;
  var te = ee.writecb;
  if (te === null)
    return this.emit("error", new ERR_MULTIPLE_CALLBACK());
  ee.writechunk = null, ee.writecb = null, X != null && this.push(X), te(Y);
  var ne = this._readableState;
  ne.reading = !1, (ne.needReadable || ne.length < ne.highWaterMark) && this._read(ne.highWaterMark);
}
function Transform$3(Y) {
  if (!(this instanceof Transform$3))
    return new Transform$3(Y);
  Duplex.call(this, Y), this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: !1,
    transforming: !1,
    writecb: null,
    writechunk: null,
    writeencoding: null
  }, this._readableState.needReadable = !0, this._readableState.sync = !1, Y && (typeof Y.transform == "function" && (this._transform = Y.transform), typeof Y.flush == "function" && (this._flush = Y.flush)), this.on("prefinish", prefinish);
}
function prefinish() {
  var Y = this;
  typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(X, ee) {
    done(Y, X, ee);
  }) : done(this, null, null);
}
Transform$3.prototype.push = function(Y, X) {
  return this._transformState.needTransform = !1, Duplex.prototype.push.call(this, Y, X);
};
Transform$3.prototype._transform = function(Y, X, ee) {
  ee(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
};
Transform$3.prototype._write = function(Y, X, ee) {
  var te = this._transformState;
  if (te.writecb = ee, te.writechunk = Y, te.writeencoding = X, !te.transforming) {
    var ne = this._readableState;
    (te.needTransform || ne.needReadable || ne.length < ne.highWaterMark) && this._read(ne.highWaterMark);
  }
};
Transform$3.prototype._read = function(Y) {
  var X = this._transformState;
  X.writechunk !== null && !X.transforming ? (X.transforming = !0, this._transform(X.writechunk, X.writeencoding, X.afterTransform)) : X.needTransform = !0;
};
Transform$3.prototype._destroy = function(Y, X) {
  Duplex.prototype._destroy.call(this, Y, function(ee) {
    X(ee);
  });
};
function done(Y, X, ee) {
  if (X)
    return Y.emit("error", X);
  if (ee != null && Y.push(ee), Y._writableState.length)
    throw new ERR_TRANSFORM_WITH_LENGTH_0();
  if (Y._transformState.transforming)
    throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
  return Y.push(null);
}
var _stream_passthrough = PassThrough, Transform$2 = _stream_transform;
inherits_browserExports(PassThrough, Transform$2);
function PassThrough(Y) {
  if (!(this instanceof PassThrough))
    return new PassThrough(Y);
  Transform$2.call(this, Y);
}
PassThrough.prototype._transform = function(Y, X, ee) {
  ee(null, Y);
};
var eos;
function once(Y) {
  var X = !1;
  return function() {
    X || (X = !0, Y.apply(void 0, arguments));
  };
}
var _require$codes = errorsBrowser.codes, ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
function noop(Y) {
  if (Y)
    throw Y;
}
function isRequest(Y) {
  return Y.setHeader && typeof Y.abort == "function";
}
function destroyer(Y, X, ee, te) {
  te = once(te);
  var ne = !1;
  Y.on("close", function() {
    ne = !0;
  }), eos === void 0 && (eos = endOfStream), eos(Y, {
    readable: X,
    writable: ee
  }, function(oe) {
    if (oe)
      return te(oe);
    ne = !0, te();
  });
  var ie = !1;
  return function(oe) {
    if (!ne && !ie) {
      if (ie = !0, isRequest(Y))
        return Y.abort();
      if (typeof Y.destroy == "function")
        return Y.destroy();
      te(oe || new ERR_STREAM_DESTROYED("pipe"));
    }
  };
}
function call(Y) {
  Y();
}
function pipe(Y, X) {
  return Y.pipe(X);
}
function popCallback(Y) {
  return !Y.length || typeof Y[Y.length - 1] != "function" ? noop : Y.pop();
}
function pipeline() {
  for (var Y = arguments.length, X = new Array(Y), ee = 0; ee < Y; ee++)
    X[ee] = arguments[ee];
  var te = popCallback(X);
  if (Array.isArray(X[0]) && (X = X[0]), X.length < 2)
    throw new ERR_MISSING_ARGS("streams");
  var ne, ie = X.map(function(oe, se) {
    var ae = se < X.length - 1, ue = se > 0;
    return destroyer(oe, ae, ue, function(le) {
      ne || (ne = le), le && ie.forEach(call), !ae && (ie.forEach(call), te(ne));
    });
  });
  return X.reduce(pipe);
}
var pipeline_1 = pipeline, streamBrowserify = Stream$1, EE = eventsExports.EventEmitter, inherits$d = inherits_browserExports;
inherits$d(Stream$1, EE);
Stream$1.Readable = require_stream_readable();
Stream$1.Writable = require_stream_writable();
Stream$1.Duplex = require_stream_duplex();
Stream$1.Transform = _stream_transform;
Stream$1.PassThrough = _stream_passthrough;
Stream$1.finished = endOfStream;
Stream$1.pipeline = pipeline_1;
Stream$1.Stream = Stream$1;
function Stream$1() {
  EE.call(this);
}
Stream$1.prototype.pipe = function(Y, X) {
  var ee = this;
  function te(le) {
    Y.writable && Y.write(le) === !1 && ee.pause && ee.pause();
  }
  ee.on("data", te);
  function ne() {
    ee.readable && ee.resume && ee.resume();
  }
  Y.on("drain", ne), !Y._isStdio && (!X || X.end !== !1) && (ee.on("end", oe), ee.on("close", se));
  var ie = !1;
  function oe() {
    ie || (ie = !0, Y.end());
  }
  function se() {
    ie || (ie = !0, typeof Y.destroy == "function" && Y.destroy());
  }
  function ae(le) {
    if (ue(), EE.listenerCount(this, "error") === 0)
      throw le;
  }
  ee.on("error", ae), Y.on("error", ae);
  function ue() {
    ee.removeListener("data", te), Y.removeListener("drain", ne), ee.removeListener("end", oe), ee.removeListener("close", se), ee.removeListener("error", ae), Y.removeListener("error", ae), ee.removeListener("end", ue), ee.removeListener("close", ue), Y.removeListener("close", ue);
  }
  return ee.on("end", ue), ee.on("close", ue), Y.on("close", ue), Y.emit("pipe", ee), Y;
};
var Buffer$c = safeBufferExports.Buffer, Transform$1 = streamBrowserify.Transform, StringDecoder = string_decoder.StringDecoder, inherits$c = inherits_browserExports;
function CipherBase(Y) {
  Transform$1.call(this), this.hashMode = typeof Y == "string", this.hashMode ? this[Y] = this._finalOrDigest : this.final = this._finalOrDigest, this._final && (this.__final = this._final, this._final = null), this._decoder = null, this._encoding = null;
}
inherits$c(CipherBase, Transform$1);
CipherBase.prototype.update = function(Y, X, ee) {
  typeof Y == "string" && (Y = Buffer$c.from(Y, X));
  var te = this._update(Y);
  return this.hashMode ? this : (ee && (te = this._toString(te, ee)), te);
};
CipherBase.prototype.setAutoPadding = function() {
};
CipherBase.prototype.getAuthTag = function() {
  throw new Error("trying to get auth tag in unsupported state");
};
CipherBase.prototype.setAuthTag = function() {
  throw new Error("trying to set auth tag in unsupported state");
};
CipherBase.prototype.setAAD = function() {
  throw new Error("trying to set aad in unsupported state");
};
CipherBase.prototype._transform = function(Y, X, ee) {
  var te;
  try {
    this.hashMode ? this._update(Y) : this.push(this._update(Y));
  } catch (ne) {
    te = ne;
  } finally {
    ee(te);
  }
};
CipherBase.prototype._flush = function(Y) {
  var X;
  try {
    this.push(this.__final());
  } catch (ee) {
    X = ee;
  }
  Y(X);
};
CipherBase.prototype._finalOrDigest = function(Y) {
  var X = this.__final() || Buffer$c.alloc(0);
  return Y && (X = this._toString(X, Y, !0)), X;
};
CipherBase.prototype._toString = function(Y, X, ee) {
  if (this._decoder || (this._decoder = new StringDecoder(X), this._encoding = X), this._encoding !== X)
    throw new Error("can't switch encodings");
  var te = this._decoder.write(Y);
  return ee && (te += this._decoder.end()), te;
};
var cipherBase = CipherBase, inherits$b = inherits_browserExports, Buffer$b = safeBufferExports.Buffer, Base$1 = cipherBase, ZEROS$1 = Buffer$b.alloc(128), blocksize = 64;
function Hmac$1(Y, X) {
  Base$1.call(this, "digest"), typeof X == "string" && (X = Buffer$b.from(X)), this._alg = Y, this._key = X, X.length > blocksize ? X = Y(X) : X.length < blocksize && (X = Buffer$b.concat([X, ZEROS$1], blocksize));
  for (var ee = this._ipad = Buffer$b.allocUnsafe(blocksize), te = this._opad = Buffer$b.allocUnsafe(blocksize), ne = 0; ne < blocksize; ne++)
    ee[ne] = X[ne] ^ 54, te[ne] = X[ne] ^ 92;
  this._hash = [ee];
}
inherits$b(Hmac$1, Base$1);
Hmac$1.prototype._update = function(Y) {
  this._hash.push(Y);
};
Hmac$1.prototype._final = function() {
  var Y = this._alg(Buffer$b.concat(this._hash));
  return this._alg(Buffer$b.concat([this._opad, Y]));
};
var legacy = Hmac$1, readableBrowser = { exports: {} };
(function(Y, X) {
  X = Y.exports = require_stream_readable(), X.Stream = X, X.Readable = X, X.Writable = require_stream_writable(), X.Duplex = require_stream_duplex(), X.Transform = _stream_transform, X.PassThrough = _stream_passthrough, X.finished = endOfStream, X.pipeline = pipeline_1;
})(readableBrowser, readableBrowser.exports);
var readableBrowserExports = readableBrowser.exports, Buffer$a = safeBufferExports.Buffer, Transform = readableBrowserExports.Transform, inherits$a = inherits_browserExports;
function throwIfNotStringOrBuffer(Y, X) {
  if (!Buffer$a.isBuffer(Y) && typeof Y != "string")
    throw new TypeError(X + " must be a string or a buffer");
}
function HashBase$2(Y) {
  Transform.call(this), this._block = Buffer$a.allocUnsafe(Y), this._blockSize = Y, this._blockOffset = 0, this._length = [0, 0, 0, 0], this._finalized = !1;
}
inherits$a(HashBase$2, Transform);
HashBase$2.prototype._transform = function(Y, X, ee) {
  var te = null;
  try {
    this.update(Y, X);
  } catch (ne) {
    te = ne;
  }
  ee(te);
};
HashBase$2.prototype._flush = function(Y) {
  var X = null;
  try {
    this.push(this.digest());
  } catch (ee) {
    X = ee;
  }
  Y(X);
};
HashBase$2.prototype.update = function(Y, X) {
  if (throwIfNotStringOrBuffer(Y, "Data"), this._finalized)
    throw new Error("Digest already called");
  Buffer$a.isBuffer(Y) || (Y = Buffer$a.from(Y, X));
  for (var ee = this._block, te = 0; this._blockOffset + Y.length - te >= this._blockSize; ) {
    for (var ne = this._blockOffset; ne < this._blockSize; )
      ee[ne++] = Y[te++];
    this._update(), this._blockOffset = 0;
  }
  for (; te < Y.length; )
    ee[this._blockOffset++] = Y[te++];
  for (var ie = 0, oe = Y.length * 8; oe > 0; ++ie)
    this._length[ie] += oe, oe = this._length[ie] / 4294967296 | 0, oe > 0 && (this._length[ie] -= 4294967296 * oe);
  return this;
};
HashBase$2.prototype._update = function() {
  throw new Error("_update is not implemented");
};
HashBase$2.prototype.digest = function(Y) {
  if (this._finalized)
    throw new Error("Digest already called");
  this._finalized = !0;
  var X = this._digest();
  Y !== void 0 && (X = X.toString(Y)), this._block.fill(0), this._blockOffset = 0;
  for (var ee = 0; ee < 4; ++ee)
    this._length[ee] = 0;
  return X;
};
HashBase$2.prototype._digest = function() {
  throw new Error("_digest is not implemented");
};
var hashBase = HashBase$2, inherits$9 = inherits_browserExports, HashBase$1 = hashBase, Buffer$9 = safeBufferExports.Buffer, ARRAY16$1 = new Array(16);
function MD5$1() {
  HashBase$1.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878;
}
inherits$9(MD5$1, HashBase$1);
MD5$1.prototype._update = function() {
  for (var Y = ARRAY16$1, X = 0; X < 16; ++X)
    Y[X] = this._block.readInt32LE(X * 4);
  var ee = this._a, te = this._b, ne = this._c, ie = this._d;
  ee = fnF(ee, te, ne, ie, Y[0], 3614090360, 7), ie = fnF(ie, ee, te, ne, Y[1], 3905402710, 12), ne = fnF(ne, ie, ee, te, Y[2], 606105819, 17), te = fnF(te, ne, ie, ee, Y[3], 3250441966, 22), ee = fnF(ee, te, ne, ie, Y[4], 4118548399, 7), ie = fnF(ie, ee, te, ne, Y[5], 1200080426, 12), ne = fnF(ne, ie, ee, te, Y[6], 2821735955, 17), te = fnF(te, ne, ie, ee, Y[7], 4249261313, 22), ee = fnF(ee, te, ne, ie, Y[8], 1770035416, 7), ie = fnF(ie, ee, te, ne, Y[9], 2336552879, 12), ne = fnF(ne, ie, ee, te, Y[10], 4294925233, 17), te = fnF(te, ne, ie, ee, Y[11], 2304563134, 22), ee = fnF(ee, te, ne, ie, Y[12], 1804603682, 7), ie = fnF(ie, ee, te, ne, Y[13], 4254626195, 12), ne = fnF(ne, ie, ee, te, Y[14], 2792965006, 17), te = fnF(te, ne, ie, ee, Y[15], 1236535329, 22), ee = fnG(ee, te, ne, ie, Y[1], 4129170786, 5), ie = fnG(ie, ee, te, ne, Y[6], 3225465664, 9), ne = fnG(ne, ie, ee, te, Y[11], 643717713, 14), te = fnG(te, ne, ie, ee, Y[0], 3921069994, 20), ee = fnG(ee, te, ne, ie, Y[5], 3593408605, 5), ie = fnG(ie, ee, te, ne, Y[10], 38016083, 9), ne = fnG(ne, ie, ee, te, Y[15], 3634488961, 14), te = fnG(te, ne, ie, ee, Y[4], 3889429448, 20), ee = fnG(ee, te, ne, ie, Y[9], 568446438, 5), ie = fnG(ie, ee, te, ne, Y[14], 3275163606, 9), ne = fnG(ne, ie, ee, te, Y[3], 4107603335, 14), te = fnG(te, ne, ie, ee, Y[8], 1163531501, 20), ee = fnG(ee, te, ne, ie, Y[13], 2850285829, 5), ie = fnG(ie, ee, te, ne, Y[2], 4243563512, 9), ne = fnG(ne, ie, ee, te, Y[7], 1735328473, 14), te = fnG(te, ne, ie, ee, Y[12], 2368359562, 20), ee = fnH(ee, te, ne, ie, Y[5], 4294588738, 4), ie = fnH(ie, ee, te, ne, Y[8], 2272392833, 11), ne = fnH(ne, ie, ee, te, Y[11], 1839030562, 16), te = fnH(te, ne, ie, ee, Y[14], 4259657740, 23), ee = fnH(ee, te, ne, ie, Y[1], 2763975236, 4), ie = fnH(ie, ee, te, ne, Y[4], 1272893353, 11), ne = fnH(ne, ie, ee, te, Y[7], 4139469664, 16), te = fnH(te, ne, ie, ee, Y[10], 3200236656, 23), ee = fnH(ee, te, ne, ie, Y[13], 681279174, 4), ie = fnH(ie, ee, te, ne, Y[0], 3936430074, 11), ne = fnH(ne, ie, ee, te, Y[3], 3572445317, 16), te = fnH(te, ne, ie, ee, Y[6], 76029189, 23), ee = fnH(ee, te, ne, ie, Y[9], 3654602809, 4), ie = fnH(ie, ee, te, ne, Y[12], 3873151461, 11), ne = fnH(ne, ie, ee, te, Y[15], 530742520, 16), te = fnH(te, ne, ie, ee, Y[2], 3299628645, 23), ee = fnI(ee, te, ne, ie, Y[0], 4096336452, 6), ie = fnI(ie, ee, te, ne, Y[7], 1126891415, 10), ne = fnI(ne, ie, ee, te, Y[14], 2878612391, 15), te = fnI(te, ne, ie, ee, Y[5], 4237533241, 21), ee = fnI(ee, te, ne, ie, Y[12], 1700485571, 6), ie = fnI(ie, ee, te, ne, Y[3], 2399980690, 10), ne = fnI(ne, ie, ee, te, Y[10], 4293915773, 15), te = fnI(te, ne, ie, ee, Y[1], 2240044497, 21), ee = fnI(ee, te, ne, ie, Y[8], 1873313359, 6), ie = fnI(ie, ee, te, ne, Y[15], 4264355552, 10), ne = fnI(ne, ie, ee, te, Y[6], 2734768916, 15), te = fnI(te, ne, ie, ee, Y[13], 1309151649, 21), ee = fnI(ee, te, ne, ie, Y[4], 4149444226, 6), ie = fnI(ie, ee, te, ne, Y[11], 3174756917, 10), ne = fnI(ne, ie, ee, te, Y[2], 718787259, 15), te = fnI(te, ne, ie, ee, Y[9], 3951481745, 21), this._a = this._a + ee | 0, this._b = this._b + te | 0, this._c = this._c + ne | 0, this._d = this._d + ie | 0;
};
MD5$1.prototype._digest = function() {
  this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
  var Y = Buffer$9.allocUnsafe(16);
  return Y.writeInt32LE(this._a, 0), Y.writeInt32LE(this._b, 4), Y.writeInt32LE(this._c, 8), Y.writeInt32LE(this._d, 12), Y;
};
function rotl$1(Y, X) {
  return Y << X | Y >>> 32 - X;
}
function fnF(Y, X, ee, te, ne, ie, oe) {
  return rotl$1(Y + (X & ee | ~X & te) + ne + ie | 0, oe) + X | 0;
}
function fnG(Y, X, ee, te, ne, ie, oe) {
  return rotl$1(Y + (X & te | ee & ~te) + ne + ie | 0, oe) + X | 0;
}
function fnH(Y, X, ee, te, ne, ie, oe) {
  return rotl$1(Y + (X ^ ee ^ te) + ne + ie | 0, oe) + X | 0;
}
function fnI(Y, X, ee, te, ne, ie, oe) {
  return rotl$1(Y + (ee ^ (X | ~te)) + ne + ie | 0, oe) + X | 0;
}
var md5_js = MD5$1, MD5 = md5_js, md5$2 = function(Y) {
  return new MD5().update(Y).digest();
}, Buffer$8 = require$$0$3.Buffer, inherits$8 = inherits_browserExports, HashBase = hashBase, ARRAY16 = new Array(16), zl = [
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  7,
  4,
  13,
  1,
  10,
  6,
  15,
  3,
  12,
  0,
  9,
  5,
  2,
  14,
  11,
  8,
  3,
  10,
  14,
  4,
  9,
  15,
  8,
  1,
  2,
  7,
  0,
  6,
  13,
  11,
  5,
  12,
  1,
  9,
  11,
  10,
  0,
  8,
  12,
  4,
  13,
  3,
  7,
  15,
  14,
  5,
  6,
  2,
  4,
  0,
  5,
  9,
  7,
  12,
  2,
  10,
  14,
  1,
  3,
  8,
  11,
  6,
  15,
  13
], zr = [
  5,
  14,
  7,
  0,
  9,
  2,
  11,
  4,
  13,
  6,
  15,
  8,
  1,
  10,
  3,
  12,
  6,
  11,
  3,
  7,
  0,
  13,
  5,
  10,
  14,
  15,
  8,
  12,
  4,
  9,
  1,
  2,
  15,
  5,
  1,
  3,
  7,
  14,
  6,
  9,
  11,
  8,
  12,
  2,
  10,
  0,
  4,
  13,
  8,
  6,
  4,
  1,
  3,
  11,
  15,
  0,
  5,
  12,
  2,
  13,
  9,
  7,
  10,
  14,
  12,
  15,
  10,
  4,
  1,
  5,
  8,
  7,
  6,
  2,
  13,
  14,
  0,
  3,
  9,
  11
], sl = [
  11,
  14,
  15,
  12,
  5,
  8,
  7,
  9,
  11,
  13,
  14,
  15,
  6,
  7,
  9,
  8,
  7,
  6,
  8,
  13,
  11,
  9,
  7,
  15,
  7,
  12,
  15,
  9,
  11,
  7,
  13,
  12,
  11,
  13,
  6,
  7,
  14,
  9,
  13,
  15,
  14,
  8,
  13,
  6,
  5,
  12,
  7,
  5,
  11,
  12,
  14,
  15,
  14,
  15,
  9,
  8,
  9,
  14,
  5,
  6,
  8,
  6,
  5,
  12,
  9,
  15,
  5,
  11,
  6,
  8,
  13,
  12,
  5,
  12,
  13,
  14,
  11,
  8,
  5,
  6
], sr = [
  8,
  9,
  9,
  11,
  13,
  15,
  15,
  5,
  7,
  7,
  8,
  11,
  14,
  14,
  12,
  6,
  9,
  13,
  15,
  7,
  12,
  8,
  9,
  11,
  7,
  7,
  12,
  7,
  6,
  15,
  13,
  11,
  9,
  7,
  15,
  11,
  8,
  6,
  6,
  14,
  12,
  13,
  5,
  14,
  13,
  13,
  7,
  5,
  15,
  5,
  8,
  11,
  14,
  14,
  6,
  14,
  6,
  9,
  12,
  9,
  12,
  5,
  15,
  8,
  8,
  5,
  12,
  9,
  12,
  5,
  14,
  6,
  8,
  13,
  6,
  5,
  15,
  13,
  11,
  11
], hl = [0, 1518500249, 1859775393, 2400959708, 2840853838], hr = [1352829926, 1548603684, 1836072691, 2053994217, 0];
function RIPEMD160$1() {
  HashBase.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520;
}
inherits$8(RIPEMD160$1, HashBase);
RIPEMD160$1.prototype._update = function() {
  for (var Y = ARRAY16, X = 0; X < 16; ++X)
    Y[X] = this._block.readInt32LE(X * 4);
  for (var ee = this._a | 0, te = this._b | 0, ne = this._c | 0, ie = this._d | 0, oe = this._e | 0, se = this._a | 0, ae = this._b | 0, ue = this._c | 0, le = this._d | 0, he = this._e | 0, me = 0; me < 80; me += 1) {
    var ye, we;
    me < 16 ? (ye = fn1(ee, te, ne, ie, oe, Y[zl[me]], hl[0], sl[me]), we = fn5(se, ae, ue, le, he, Y[zr[me]], hr[0], sr[me])) : me < 32 ? (ye = fn2(ee, te, ne, ie, oe, Y[zl[me]], hl[1], sl[me]), we = fn4(se, ae, ue, le, he, Y[zr[me]], hr[1], sr[me])) : me < 48 ? (ye = fn3(ee, te, ne, ie, oe, Y[zl[me]], hl[2], sl[me]), we = fn3(se, ae, ue, le, he, Y[zr[me]], hr[2], sr[me])) : me < 64 ? (ye = fn4(ee, te, ne, ie, oe, Y[zl[me]], hl[3], sl[me]), we = fn2(se, ae, ue, le, he, Y[zr[me]], hr[3], sr[me])) : (ye = fn5(ee, te, ne, ie, oe, Y[zl[me]], hl[4], sl[me]), we = fn1(se, ae, ue, le, he, Y[zr[me]], hr[4], sr[me])), ee = oe, oe = ie, ie = rotl(ne, 10), ne = te, te = ye, se = he, he = le, le = rotl(ue, 10), ue = ae, ae = we;
  }
  var Ee = this._b + ne + le | 0;
  this._b = this._c + ie + he | 0, this._c = this._d + oe + se | 0, this._d = this._e + ee + ae | 0, this._e = this._a + te + ue | 0, this._a = Ee;
};
RIPEMD160$1.prototype._digest = function() {
  this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
  var Y = Buffer$8.alloc ? Buffer$8.alloc(20) : new Buffer$8(20);
  return Y.writeInt32LE(this._a, 0), Y.writeInt32LE(this._b, 4), Y.writeInt32LE(this._c, 8), Y.writeInt32LE(this._d, 12), Y.writeInt32LE(this._e, 16), Y;
};
function rotl(Y, X) {
  return Y << X | Y >>> 32 - X;
}
function fn1(Y, X, ee, te, ne, ie, oe, se) {
  return rotl(Y + (X ^ ee ^ te) + ie + oe | 0, se) + ne | 0;
}
function fn2(Y, X, ee, te, ne, ie, oe, se) {
  return rotl(Y + (X & ee | ~X & te) + ie + oe | 0, se) + ne | 0;
}
function fn3(Y, X, ee, te, ne, ie, oe, se) {
  return rotl(Y + ((X | ~ee) ^ te) + ie + oe | 0, se) + ne | 0;
}
function fn4(Y, X, ee, te, ne, ie, oe, se) {
  return rotl(Y + (X & te | ee & ~te) + ie + oe | 0, se) + ne | 0;
}
function fn5(Y, X, ee, te, ne, ie, oe, se) {
  return rotl(Y + (X ^ (ee | ~te)) + ie + oe | 0, se) + ne | 0;
}
var ripemd160 = RIPEMD160$1, sha_js = { exports: {} }, Buffer$7 = safeBufferExports.Buffer;
function Hash$7(Y, X) {
  this._block = Buffer$7.alloc(Y), this._finalSize = X, this._blockSize = Y, this._len = 0;
}
Hash$7.prototype.update = function(Y, X) {
  typeof Y == "string" && (X = X || "utf8", Y = Buffer$7.from(Y, X));
  for (var ee = this._block, te = this._blockSize, ne = Y.length, ie = this._len, oe = 0; oe < ne; ) {
    for (var se = ie % te, ae = Math.min(ne - oe, te - se), ue = 0; ue < ae; ue++)
      ee[se + ue] = Y[oe + ue];
    ie += ae, oe += ae, ie % te === 0 && this._update(ee);
  }
  return this._len += ne, this;
};
Hash$7.prototype.digest = function(Y) {
  var X = this._len % this._blockSize;
  this._block[X] = 128, this._block.fill(0, X + 1), X >= this._finalSize && (this._update(this._block), this._block.fill(0));
  var ee = this._len * 8;
  if (ee <= 4294967295)
    this._block.writeUInt32BE(ee, this._blockSize - 4);
  else {
    var te = (ee & 4294967295) >>> 0, ne = (ee - te) / 4294967296;
    this._block.writeUInt32BE(ne, this._blockSize - 8), this._block.writeUInt32BE(te, this._blockSize - 4);
  }
  this._update(this._block);
  var ie = this._hash();
  return Y ? ie.toString(Y) : ie;
};
Hash$7.prototype._update = function() {
  throw new Error("_update must be implemented by subclass");
};
var hash$3 = Hash$7, inherits$7 = inherits_browserExports, Hash$6 = hash$3, Buffer$6 = safeBufferExports.Buffer, K$3 = [
  1518500249,
  1859775393,
  -1894007588,
  -899497514
], W$5 = new Array(80);
function Sha() {
  this.init(), this._w = W$5, Hash$6.call(this, 64, 56);
}
inherits$7(Sha, Hash$6);
Sha.prototype.init = function() {
  return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
};
function rotl5$1(Y) {
  return Y << 5 | Y >>> 27;
}
function rotl30$1(Y) {
  return Y << 30 | Y >>> 2;
}
function ft$1(Y, X, ee, te) {
  return Y === 0 ? X & ee | ~X & te : Y === 2 ? X & ee | X & te | ee & te : X ^ ee ^ te;
}
Sha.prototype._update = function(Y) {
  for (var X = this._w, ee = this._a | 0, te = this._b | 0, ne = this._c | 0, ie = this._d | 0, oe = this._e | 0, se = 0; se < 16; ++se)
    X[se] = Y.readInt32BE(se * 4);
  for (; se < 80; ++se)
    X[se] = X[se - 3] ^ X[se - 8] ^ X[se - 14] ^ X[se - 16];
  for (var ae = 0; ae < 80; ++ae) {
    var ue = ~~(ae / 20), le = rotl5$1(ee) + ft$1(ue, te, ne, ie) + oe + X[ae] + K$3[ue] | 0;
    oe = ie, ie = ne, ne = rotl30$1(te), te = ee, ee = le;
  }
  this._a = ee + this._a | 0, this._b = te + this._b | 0, this._c = ne + this._c | 0, this._d = ie + this._d | 0, this._e = oe + this._e | 0;
};
Sha.prototype._hash = function() {
  var Y = Buffer$6.allocUnsafe(20);
  return Y.writeInt32BE(this._a | 0, 0), Y.writeInt32BE(this._b | 0, 4), Y.writeInt32BE(this._c | 0, 8), Y.writeInt32BE(this._d | 0, 12), Y.writeInt32BE(this._e | 0, 16), Y;
};
var sha$2 = Sha, inherits$6 = inherits_browserExports, Hash$5 = hash$3, Buffer$5 = safeBufferExports.Buffer, K$2 = [
  1518500249,
  1859775393,
  -1894007588,
  -899497514
], W$4 = new Array(80);
function Sha1() {
  this.init(), this._w = W$4, Hash$5.call(this, 64, 56);
}
inherits$6(Sha1, Hash$5);
Sha1.prototype.init = function() {
  return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
};
function rotl1(Y) {
  return Y << 1 | Y >>> 31;
}
function rotl5(Y) {
  return Y << 5 | Y >>> 27;
}
function rotl30(Y) {
  return Y << 30 | Y >>> 2;
}
function ft(Y, X, ee, te) {
  return Y === 0 ? X & ee | ~X & te : Y === 2 ? X & ee | X & te | ee & te : X ^ ee ^ te;
}
Sha1.prototype._update = function(Y) {
  for (var X = this._w, ee = this._a | 0, te = this._b | 0, ne = this._c | 0, ie = this._d | 0, oe = this._e | 0, se = 0; se < 16; ++se)
    X[se] = Y.readInt32BE(se * 4);
  for (; se < 80; ++se)
    X[se] = rotl1(X[se - 3] ^ X[se - 8] ^ X[se - 14] ^ X[se - 16]);
  for (var ae = 0; ae < 80; ++ae) {
    var ue = ~~(ae / 20), le = rotl5(ee) + ft(ue, te, ne, ie) + oe + X[ae] + K$2[ue] | 0;
    oe = ie, ie = ne, ne = rotl30(te), te = ee, ee = le;
  }
  this._a = ee + this._a | 0, this._b = te + this._b | 0, this._c = ne + this._c | 0, this._d = ie + this._d | 0, this._e = oe + this._e | 0;
};
Sha1.prototype._hash = function() {
  var Y = Buffer$5.allocUnsafe(20);
  return Y.writeInt32BE(this._a | 0, 0), Y.writeInt32BE(this._b | 0, 4), Y.writeInt32BE(this._c | 0, 8), Y.writeInt32BE(this._d | 0, 12), Y.writeInt32BE(this._e | 0, 16), Y;
};
var sha1$1 = Sha1, inherits$5 = inherits_browserExports, Hash$4 = hash$3, Buffer$4 = safeBufferExports.Buffer, K$1 = [
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
], W$3 = new Array(64);
function Sha256$1() {
  this.init(), this._w = W$3, Hash$4.call(this, 64, 56);
}
inherits$5(Sha256$1, Hash$4);
Sha256$1.prototype.init = function() {
  return this._a = 1779033703, this._b = 3144134277, this._c = 1013904242, this._d = 2773480762, this._e = 1359893119, this._f = 2600822924, this._g = 528734635, this._h = 1541459225, this;
};
function ch(Y, X, ee) {
  return ee ^ Y & (X ^ ee);
}
function maj$1(Y, X, ee) {
  return Y & X | ee & (Y | X);
}
function sigma0$1(Y) {
  return (Y >>> 2 | Y << 30) ^ (Y >>> 13 | Y << 19) ^ (Y >>> 22 | Y << 10);
}
function sigma1$1(Y) {
  return (Y >>> 6 | Y << 26) ^ (Y >>> 11 | Y << 21) ^ (Y >>> 25 | Y << 7);
}
function gamma0(Y) {
  return (Y >>> 7 | Y << 25) ^ (Y >>> 18 | Y << 14) ^ Y >>> 3;
}
function gamma1(Y) {
  return (Y >>> 17 | Y << 15) ^ (Y >>> 19 | Y << 13) ^ Y >>> 10;
}
Sha256$1.prototype._update = function(Y) {
  for (var X = this._w, ee = this._a | 0, te = this._b | 0, ne = this._c | 0, ie = this._d | 0, oe = this._e | 0, se = this._f | 0, ae = this._g | 0, ue = this._h | 0, le = 0; le < 16; ++le)
    X[le] = Y.readInt32BE(le * 4);
  for (; le < 64; ++le)
    X[le] = gamma1(X[le - 2]) + X[le - 7] + gamma0(X[le - 15]) + X[le - 16] | 0;
  for (var he = 0; he < 64; ++he) {
    var me = ue + sigma1$1(oe) + ch(oe, se, ae) + K$1[he] + X[he] | 0, ye = sigma0$1(ee) + maj$1(ee, te, ne) | 0;
    ue = ae, ae = se, se = oe, oe = ie + me | 0, ie = ne, ne = te, te = ee, ee = me + ye | 0;
  }
  this._a = ee + this._a | 0, this._b = te + this._b | 0, this._c = ne + this._c | 0, this._d = ie + this._d | 0, this._e = oe + this._e | 0, this._f = se + this._f | 0, this._g = ae + this._g | 0, this._h = ue + this._h | 0;
};
Sha256$1.prototype._hash = function() {
  var Y = Buffer$4.allocUnsafe(32);
  return Y.writeInt32BE(this._a, 0), Y.writeInt32BE(this._b, 4), Y.writeInt32BE(this._c, 8), Y.writeInt32BE(this._d, 12), Y.writeInt32BE(this._e, 16), Y.writeInt32BE(this._f, 20), Y.writeInt32BE(this._g, 24), Y.writeInt32BE(this._h, 28), Y;
};
var sha256$3 = Sha256$1, inherits$4 = inherits_browserExports, Sha256 = sha256$3, Hash$3 = hash$3, Buffer$3 = safeBufferExports.Buffer, W$2 = new Array(64);
function Sha224() {
  this.init(), this._w = W$2, Hash$3.call(this, 64, 56);
}
inherits$4(Sha224, Sha256);
Sha224.prototype.init = function() {
  return this._a = 3238371032, this._b = 914150663, this._c = 812702999, this._d = 4144912697, this._e = 4290775857, this._f = 1750603025, this._g = 1694076839, this._h = 3204075428, this;
};
Sha224.prototype._hash = function() {
  var Y = Buffer$3.allocUnsafe(28);
  return Y.writeInt32BE(this._a, 0), Y.writeInt32BE(this._b, 4), Y.writeInt32BE(this._c, 8), Y.writeInt32BE(this._d, 12), Y.writeInt32BE(this._e, 16), Y.writeInt32BE(this._f, 20), Y.writeInt32BE(this._g, 24), Y;
};
var sha224$1 = Sha224, inherits$3 = inherits_browserExports, Hash$2 = hash$3, Buffer$2 = safeBufferExports.Buffer, K = [
  1116352408,
  3609767458,
  1899447441,
  602891725,
  3049323471,
  3964484399,
  3921009573,
  2173295548,
  961987163,
  4081628472,
  1508970993,
  3053834265,
  2453635748,
  2937671579,
  2870763221,
  3664609560,
  3624381080,
  2734883394,
  310598401,
  1164996542,
  607225278,
  1323610764,
  1426881987,
  3590304994,
  1925078388,
  4068182383,
  2162078206,
  991336113,
  2614888103,
  633803317,
  3248222580,
  3479774868,
  3835390401,
  2666613458,
  4022224774,
  944711139,
  264347078,
  2341262773,
  604807628,
  2007800933,
  770255983,
  1495990901,
  1249150122,
  1856431235,
  1555081692,
  3175218132,
  1996064986,
  2198950837,
  2554220882,
  3999719339,
  2821834349,
  766784016,
  2952996808,
  2566594879,
  3210313671,
  3203337956,
  3336571891,
  1034457026,
  3584528711,
  2466948901,
  113926993,
  3758326383,
  338241895,
  168717936,
  666307205,
  1188179964,
  773529912,
  1546045734,
  1294757372,
  1522805485,
  1396182291,
  2643833823,
  1695183700,
  2343527390,
  1986661051,
  1014477480,
  2177026350,
  1206759142,
  2456956037,
  344077627,
  2730485921,
  1290863460,
  2820302411,
  3158454273,
  3259730800,
  3505952657,
  3345764771,
  106217008,
  3516065817,
  3606008344,
  3600352804,
  1432725776,
  4094571909,
  1467031594,
  275423344,
  851169720,
  430227734,
  3100823752,
  506948616,
  1363258195,
  659060556,
  3750685593,
  883997877,
  3785050280,
  958139571,
  3318307427,
  1322822218,
  3812723403,
  1537002063,
  2003034995,
  1747873779,
  3602036899,
  1955562222,
  1575990012,
  2024104815,
  1125592928,
  2227730452,
  2716904306,
  2361852424,
  442776044,
  2428436474,
  593698344,
  2756734187,
  3733110249,
  3204031479,
  2999351573,
  3329325298,
  3815920427,
  3391569614,
  3928383900,
  3515267271,
  566280711,
  3940187606,
  3454069534,
  4118630271,
  4000239992,
  116418474,
  1914138554,
  174292421,
  2731055270,
  289380356,
  3203993006,
  460393269,
  320620315,
  685471733,
  587496836,
  852142971,
  1086792851,
  1017036298,
  365543100,
  1126000580,
  2618297676,
  1288033470,
  3409855158,
  1501505948,
  4234509866,
  1607167915,
  987167468,
  1816402316,
  1246189591
], W$1 = new Array(160);
function Sha512() {
  this.init(), this._w = W$1, Hash$2.call(this, 128, 112);
}
inherits$3(Sha512, Hash$2);
Sha512.prototype.init = function() {
  return this._ah = 1779033703, this._bh = 3144134277, this._ch = 1013904242, this._dh = 2773480762, this._eh = 1359893119, this._fh = 2600822924, this._gh = 528734635, this._hh = 1541459225, this._al = 4089235720, this._bl = 2227873595, this._cl = 4271175723, this._dl = 1595750129, this._el = 2917565137, this._fl = 725511199, this._gl = 4215389547, this._hl = 327033209, this;
};
function Ch(Y, X, ee) {
  return ee ^ Y & (X ^ ee);
}
function maj(Y, X, ee) {
  return Y & X | ee & (Y | X);
}
function sigma0(Y, X) {
  return (Y >>> 28 | X << 4) ^ (X >>> 2 | Y << 30) ^ (X >>> 7 | Y << 25);
}
function sigma1(Y, X) {
  return (Y >>> 14 | X << 18) ^ (Y >>> 18 | X << 14) ^ (X >>> 9 | Y << 23);
}
function Gamma0(Y, X) {
  return (Y >>> 1 | X << 31) ^ (Y >>> 8 | X << 24) ^ Y >>> 7;
}
function Gamma0l(Y, X) {
  return (Y >>> 1 | X << 31) ^ (Y >>> 8 | X << 24) ^ (Y >>> 7 | X << 25);
}
function Gamma1(Y, X) {
  return (Y >>> 19 | X << 13) ^ (X >>> 29 | Y << 3) ^ Y >>> 6;
}
function Gamma1l(Y, X) {
  return (Y >>> 19 | X << 13) ^ (X >>> 29 | Y << 3) ^ (Y >>> 6 | X << 26);
}
function getCarry(Y, X) {
  return Y >>> 0 < X >>> 0 ? 1 : 0;
}
Sha512.prototype._update = function(Y) {
  for (var X = this._w, ee = this._ah | 0, te = this._bh | 0, ne = this._ch | 0, ie = this._dh | 0, oe = this._eh | 0, se = this._fh | 0, ae = this._gh | 0, ue = this._hh | 0, le = this._al | 0, he = this._bl | 0, me = this._cl | 0, ye = this._dl | 0, we = this._el | 0, Ee = this._fl | 0, Re = this._gl | 0, Ue = this._hl | 0, Me = 0; Me < 32; Me += 2)
    X[Me] = Y.readInt32BE(Me * 4), X[Me + 1] = Y.readInt32BE(Me * 4 + 4);
  for (; Me < 160; Me += 2) {
    var De = X[Me - 30], Fe = X[Me - 15 * 2 + 1], Ke = Gamma0(De, Fe), tt = Gamma0l(Fe, De);
    De = X[Me - 2 * 2], Fe = X[Me - 2 * 2 + 1];
    var rt = Gamma1(De, Fe), it = Gamma1l(Fe, De), _t = X[Me - 7 * 2], Dt = X[Me - 7 * 2 + 1], je = X[Me - 16 * 2], ze = X[Me - 16 * 2 + 1], fe = tt + Dt | 0, de = Ke + _t + getCarry(fe, tt) | 0;
    fe = fe + it | 0, de = de + rt + getCarry(fe, it) | 0, fe = fe + ze | 0, de = de + je + getCarry(fe, ze) | 0, X[Me] = de, X[Me + 1] = fe;
  }
  for (var be = 0; be < 160; be += 2) {
    de = X[be], fe = X[be + 1];
    var Te = maj(ee, te, ne), Ce = maj(le, he, me), Pe = sigma0(ee, le), Se = sigma0(le, ee), ke = sigma1(oe, we), ge = sigma1(we, oe), Ae = K[be], Ge = K[be + 1], Xe = Ch(oe, se, ae), $e = Ch(we, Ee, Re), Ze = Ue + ge | 0, ot = ue + ke + getCarry(Ze, Ue) | 0;
    Ze = Ze + $e | 0, ot = ot + Xe + getCarry(Ze, $e) | 0, Ze = Ze + Ge | 0, ot = ot + Ae + getCarry(Ze, Ge) | 0, Ze = Ze + fe | 0, ot = ot + de + getCarry(Ze, fe) | 0;
    var ct = Se + Ce | 0, At = Pe + Te + getCarry(ct, Se) | 0;
    ue = ae, Ue = Re, ae = se, Re = Ee, se = oe, Ee = we, we = ye + Ze | 0, oe = ie + ot + getCarry(we, ye) | 0, ie = ne, ye = me, ne = te, me = he, te = ee, he = le, le = Ze + ct | 0, ee = ot + At + getCarry(le, Ze) | 0;
  }
  this._al = this._al + le | 0, this._bl = this._bl + he | 0, this._cl = this._cl + me | 0, this._dl = this._dl + ye | 0, this._el = this._el + we | 0, this._fl = this._fl + Ee | 0, this._gl = this._gl + Re | 0, this._hl = this._hl + Ue | 0, this._ah = this._ah + ee + getCarry(this._al, le) | 0, this._bh = this._bh + te + getCarry(this._bl, he) | 0, this._ch = this._ch + ne + getCarry(this._cl, me) | 0, this._dh = this._dh + ie + getCarry(this._dl, ye) | 0, this._eh = this._eh + oe + getCarry(this._el, we) | 0, this._fh = this._fh + se + getCarry(this._fl, Ee) | 0, this._gh = this._gh + ae + getCarry(this._gl, Re) | 0, this._hh = this._hh + ue + getCarry(this._hl, Ue) | 0;
};
Sha512.prototype._hash = function() {
  var Y = Buffer$2.allocUnsafe(64);
  function X(ee, te, ne) {
    Y.writeInt32BE(ee, ne), Y.writeInt32BE(te, ne + 4);
  }
  return X(this._ah, this._al, 0), X(this._bh, this._bl, 8), X(this._ch, this._cl, 16), X(this._dh, this._dl, 24), X(this._eh, this._el, 32), X(this._fh, this._fl, 40), X(this._gh, this._gl, 48), X(this._hh, this._hl, 56), Y;
};
var sha512$3 = Sha512, inherits$2 = inherits_browserExports, SHA512$2 = sha512$3, Hash$1 = hash$3, Buffer$1 = safeBufferExports.Buffer, W = new Array(160);
function Sha384() {
  this.init(), this._w = W, Hash$1.call(this, 128, 112);
}
inherits$2(Sha384, SHA512$2);
Sha384.prototype.init = function() {
  return this._ah = 3418070365, this._bh = 1654270250, this._ch = 2438529370, this._dh = 355462360, this._eh = 1731405415, this._fh = 2394180231, this._gh = 3675008525, this._hh = 1203062813, this._al = 3238371032, this._bl = 914150663, this._cl = 812702999, this._dl = 4144912697, this._el = 4290775857, this._fl = 1750603025, this._gl = 1694076839, this._hl = 3204075428, this;
};
Sha384.prototype._hash = function() {
  var Y = Buffer$1.allocUnsafe(48);
  function X(ee, te, ne) {
    Y.writeInt32BE(ee, ne), Y.writeInt32BE(te, ne + 4);
  }
  return X(this._ah, this._al, 0), X(this._bh, this._bl, 8), X(this._ch, this._cl, 16), X(this._dh, this._dl, 24), X(this._eh, this._el, 32), X(this._fh, this._fl, 40), Y;
};
var sha384$1 = Sha384, exports = sha_js.exports = function(Y) {
  Y = Y.toLowerCase();
  var X = exports[Y];
  if (!X)
    throw new Error(Y + " is not supported (we accept pull requests)");
  return new X();
};
exports.sha = sha$2;
exports.sha1 = sha1$1;
exports.sha224 = sha224$1;
exports.sha256 = sha256$3;
exports.sha384 = sha384$1;
exports.sha512 = sha512$3;
var sha_jsExports = sha_js.exports, inherits$1 = inherits_browserExports, Legacy = legacy, Base = cipherBase, Buffer$f = safeBufferExports.Buffer, md5$1 = md5$2, RIPEMD160 = ripemd160, sha$1 = sha_jsExports, ZEROS = Buffer$f.alloc(128);
function Hmac(Y, X) {
  Base.call(this, "digest"), typeof X == "string" && (X = Buffer$f.from(X));
  var ee = Y === "sha512" || Y === "sha384" ? 128 : 64;
  if (this._alg = Y, this._key = X, X.length > ee) {
    var te = Y === "rmd160" ? new RIPEMD160() : sha$1(Y);
    X = te.update(X).digest();
  } else
    X.length < ee && (X = Buffer$f.concat([X, ZEROS], ee));
  for (var ne = this._ipad = Buffer$f.allocUnsafe(ee), ie = this._opad = Buffer$f.allocUnsafe(ee), oe = 0; oe < ee; oe++)
    ne[oe] = X[oe] ^ 54, ie[oe] = X[oe] ^ 92;
  this._hash = Y === "rmd160" ? new RIPEMD160() : sha$1(Y), this._hash.update(ne);
}
inherits$1(Hmac, Base);
Hmac.prototype._update = function(Y) {
  this._hash.update(Y);
};
Hmac.prototype._final = function() {
  var Y = this._hash.digest(), X = this._alg === "rmd160" ? new RIPEMD160() : sha$1(this._alg);
  return X.update(this._opad).update(Y).digest();
};
var browser$c = function(Y, X) {
  return Y = Y.toLowerCase(), Y === "rmd160" || Y === "ripemd160" ? new Hmac("rmd160", X) : Y === "md5" ? new Legacy(md5$1, X) : new Hmac(Y, X);
};
function commonjsRequire(Y) {
  throw new Error('Could not dynamically require "' + Y + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var naclFast = { exports: {} }, cryptoBrowserify = {}, browser$b = { exports: {} }, hasRequiredBrowser$9;
function requireBrowser$9() {
  if (hasRequiredBrowser$9)
    return browser$b.exports;
  hasRequiredBrowser$9 = 1;
  var Y = 65536, X = 4294967295;
  function ee() {
    throw new Error(`Secure random number generation is not supported by this browser.
Use Chrome, Firefox or Internet Explorer 11`);
  }
  var te = safeBufferExports.Buffer, ne = commonjsGlobal.crypto || commonjsGlobal.msCrypto;
  ne && ne.getRandomValues ? browser$b.exports = ie : browser$b.exports = ee;
  function ie(oe, se) {
    if (oe > X)
      throw new RangeError("requested too many random bytes");
    var ae = te.allocUnsafe(oe);
    if (oe > 0)
      if (oe > Y)
        for (var ue = 0; ue < oe; ue += Y)
          ne.getRandomValues(ae.slice(ue, ue + Y));
      else
        ne.getRandomValues(ae);
    return typeof se == "function" ? process$1$1.nextTick(function() {
      se(null, ae);
    }) : ae;
  }
  return browser$b.exports;
}
var browser$a, hasRequiredBrowser$8;
function requireBrowser$8() {
  if (hasRequiredBrowser$8)
    return browser$a;
  hasRequiredBrowser$8 = 1;
  var Y = inherits_browserExports, X = md5_js, ee = ripemd160, te = sha_jsExports, ne = cipherBase;
  function ie(oe) {
    ne.call(this, "digest"), this._hash = oe;
  }
  return Y(ie, ne), ie.prototype._update = function(oe) {
    this._hash.update(oe);
  }, ie.prototype._final = function() {
    return this._hash.digest();
  }, browser$a = function(oe) {
    return oe = oe.toLowerCase(), oe === "md5" ? new X() : oe === "rmd160" || oe === "ripemd160" ? new ee() : new ie(te(oe));
  }, browser$a;
}
const sha224WithRSAEncryption = {
  sign: "rsa",
  hash: "sha224",
  id: "302d300d06096086480165030402040500041c"
}, sha256WithRSAEncryption = {
  sign: "rsa",
  hash: "sha256",
  id: "3031300d060960864801650304020105000420"
}, sha384WithRSAEncryption = {
  sign: "rsa",
  hash: "sha384",
  id: "3041300d060960864801650304020205000430"
}, sha512WithRSAEncryption = {
  sign: "rsa",
  hash: "sha512",
  id: "3051300d060960864801650304020305000440"
}, sha256$2 = {
  sign: "ecdsa",
  hash: "sha256",
  id: ""
}, sha224 = {
  sign: "ecdsa",
  hash: "sha224",
  id: ""
}, sha384 = {
  sign: "ecdsa",
  hash: "sha384",
  id: ""
}, sha512$2 = {
  sign: "ecdsa",
  hash: "sha512",
  id: ""
}, DSA = {
  sign: "dsa",
  hash: "sha1",
  id: ""
}, ripemd160WithRSA = {
  sign: "rsa",
  hash: "rmd160",
  id: "3021300906052b2403020105000414"
}, md5WithRSAEncryption = {
  sign: "rsa",
  hash: "md5",
  id: "3020300c06082a864886f70d020505000410"
}, require$$6$1 = {
  sha224WithRSAEncryption,
  "RSA-SHA224": {
    sign: "ecdsa/rsa",
    hash: "sha224",
    id: "302d300d06096086480165030402040500041c"
  },
  sha256WithRSAEncryption,
  "RSA-SHA256": {
    sign: "ecdsa/rsa",
    hash: "sha256",
    id: "3031300d060960864801650304020105000420"
  },
  sha384WithRSAEncryption,
  "RSA-SHA384": {
    sign: "ecdsa/rsa",
    hash: "sha384",
    id: "3041300d060960864801650304020205000430"
  },
  sha512WithRSAEncryption,
  "RSA-SHA512": {
    sign: "ecdsa/rsa",
    hash: "sha512",
    id: "3051300d060960864801650304020305000440"
  },
  "RSA-SHA1": {
    sign: "rsa",
    hash: "sha1",
    id: "3021300906052b0e03021a05000414"
  },
  "ecdsa-with-SHA1": {
    sign: "ecdsa",
    hash: "sha1",
    id: ""
  },
  sha256: sha256$2,
  sha224,
  sha384,
  sha512: sha512$2,
  "DSA-SHA": {
    sign: "dsa",
    hash: "sha1",
    id: ""
  },
  "DSA-SHA1": {
    sign: "dsa",
    hash: "sha1",
    id: ""
  },
  DSA,
  "DSA-WITH-SHA224": {
    sign: "dsa",
    hash: "sha224",
    id: ""
  },
  "DSA-SHA224": {
    sign: "dsa",
    hash: "sha224",
    id: ""
  },
  "DSA-WITH-SHA256": {
    sign: "dsa",
    hash: "sha256",
    id: ""
  },
  "DSA-SHA256": {
    sign: "dsa",
    hash: "sha256",
    id: ""
  },
  "DSA-WITH-SHA384": {
    sign: "dsa",
    hash: "sha384",
    id: ""
  },
  "DSA-SHA384": {
    sign: "dsa",
    hash: "sha384",
    id: ""
  },
  "DSA-WITH-SHA512": {
    sign: "dsa",
    hash: "sha512",
    id: ""
  },
  "DSA-SHA512": {
    sign: "dsa",
    hash: "sha512",
    id: ""
  },
  "DSA-RIPEMD160": {
    sign: "dsa",
    hash: "rmd160",
    id: ""
  },
  ripemd160WithRSA,
  "RSA-RIPEMD160": {
    sign: "rsa",
    hash: "rmd160",
    id: "3021300906052b2403020105000414"
  },
  md5WithRSAEncryption,
  "RSA-MD5": {
    sign: "rsa",
    hash: "md5",
    id: "3020300c06082a864886f70d020505000410"
  }
};
var algos, hasRequiredAlgos;
function requireAlgos() {
  return hasRequiredAlgos || (hasRequiredAlgos = 1, algos = require$$6$1), algos;
}
var browser$9 = {}, precondition, hasRequiredPrecondition;
function requirePrecondition() {
  if (hasRequiredPrecondition)
    return precondition;
  hasRequiredPrecondition = 1;
  var Y = Math.pow(2, 30) - 1;
  return precondition = function(X, ee) {
    if (typeof X != "number")
      throw new TypeError("Iterations not a number");
    if (X < 0)
      throw new TypeError("Bad iterations");
    if (typeof ee != "number")
      throw new TypeError("Key length not a number");
    if (ee < 0 || ee > Y || ee !== ee)
      throw new TypeError("Bad key length");
  }, precondition;
}
var defaultEncoding_1, hasRequiredDefaultEncoding;
function requireDefaultEncoding() {
  if (hasRequiredDefaultEncoding)
    return defaultEncoding_1;
  hasRequiredDefaultEncoding = 1;
  var Y;
  if (commonjsGlobal.process && commonjsGlobal.process.browser)
    Y = "utf-8";
  else if (commonjsGlobal.process && commonjsGlobal.process.version) {
    var X = parseInt(process$1$1.version.split(".")[0].slice(1), 10);
    Y = X >= 6 ? "utf-8" : "binary";
  } else
    Y = "utf-8";
  return defaultEncoding_1 = Y, defaultEncoding_1;
}
var toBuffer$1, hasRequiredToBuffer;
function requireToBuffer() {
  if (hasRequiredToBuffer)
    return toBuffer$1;
  hasRequiredToBuffer = 1;
  var Y = safeBufferExports.Buffer;
  return toBuffer$1 = function(X, ee, te) {
    if (Y.isBuffer(X))
      return X;
    if (typeof X == "string")
      return Y.from(X, ee);
    if (ArrayBuffer.isView(X))
      return Y.from(X.buffer);
    throw new TypeError(te + " must be a string, a Buffer, a typed array or a DataView");
  }, toBuffer$1;
}
var syncBrowser, hasRequiredSyncBrowser;
function requireSyncBrowser() {
  if (hasRequiredSyncBrowser)
    return syncBrowser;
  hasRequiredSyncBrowser = 1;
  var Y = md5$2, X = ripemd160, ee = sha_jsExports, te = safeBufferExports.Buffer, ne = requirePrecondition(), ie = requireDefaultEncoding(), oe = requireToBuffer(), se = te.alloc(128), ae = {
    md5: 16,
    sha1: 20,
    sha224: 28,
    sha256: 32,
    sha384: 48,
    sha512: 64,
    rmd160: 20,
    ripemd160: 20
  };
  function ue(me, ye, we) {
    var Ee = le(me), Re = me === "sha512" || me === "sha384" ? 128 : 64;
    ye.length > Re ? ye = Ee(ye) : ye.length < Re && (ye = te.concat([ye, se], Re));
    for (var Ue = te.allocUnsafe(Re + ae[me]), Me = te.allocUnsafe(Re + ae[me]), De = 0; De < Re; De++)
      Ue[De] = ye[De] ^ 54, Me[De] = ye[De] ^ 92;
    var Fe = te.allocUnsafe(Re + we + 4);
    Ue.copy(Fe, 0, 0, Re), this.ipad1 = Fe, this.ipad2 = Ue, this.opad = Me, this.alg = me, this.blocksize = Re, this.hash = Ee, this.size = ae[me];
  }
  ue.prototype.run = function(me, ye) {
    me.copy(ye, this.blocksize);
    var we = this.hash(ye);
    return we.copy(this.opad, this.blocksize), this.hash(this.opad);
  };
  function le(me) {
    function ye(Ee) {
      return ee(me).update(Ee).digest();
    }
    function we(Ee) {
      return new X().update(Ee).digest();
    }
    return me === "rmd160" || me === "ripemd160" ? we : me === "md5" ? Y : ye;
  }
  function he(me, ye, we, Ee, Re) {
    ne(we, Ee), me = oe(me, ie, "Password"), ye = oe(ye, ie, "Salt"), Re = Re || "sha1";
    var Ue = new ue(Re, me, ye.length), Me = te.allocUnsafe(Ee), De = te.allocUnsafe(ye.length + 4);
    ye.copy(De, 0, 0, ye.length);
    for (var Fe = 0, Ke = ae[Re], tt = Math.ceil(Ee / Ke), rt = 1; rt <= tt; rt++) {
      De.writeUInt32BE(rt, ye.length);
      for (var it = Ue.run(De, Ue.ipad1), _t = it, Dt = 1; Dt < we; Dt++) {
        _t = Ue.run(_t, Ue.ipad2);
        for (var je = 0; je < Ke; je++)
          it[je] ^= _t[je];
      }
      it.copy(Me, Fe), Fe += Ke;
    }
    return Me;
  }
  return syncBrowser = he, syncBrowser;
}
var async, hasRequiredAsync;
function requireAsync() {
  if (hasRequiredAsync)
    return async;
  hasRequiredAsync = 1;
  var Y = safeBufferExports.Buffer, X = requirePrecondition(), ee = requireDefaultEncoding(), te = requireSyncBrowser(), ne = requireToBuffer(), ie, oe = commonjsGlobal.crypto && commonjsGlobal.crypto.subtle, se = {
    sha: "SHA-1",
    "sha-1": "SHA-1",
    sha1: "SHA-1",
    sha256: "SHA-256",
    "sha-256": "SHA-256",
    sha384: "SHA-384",
    "sha-384": "SHA-384",
    "sha-512": "SHA-512",
    sha512: "SHA-512"
  }, ae = [];
  function ue(we) {
    if (commonjsGlobal.process && !commonjsGlobal.process.browser || !oe || !oe.importKey || !oe.deriveBits)
      return Promise.resolve(!1);
    if (ae[we] !== void 0)
      return ae[we];
    ie = ie || Y.alloc(8);
    var Ee = me(ie, ie, 10, 128, we).then(function() {
      return !0;
    }).catch(function() {
      return !1;
    });
    return ae[we] = Ee, Ee;
  }
  var le;
  function he() {
    return le || (commonjsGlobal.process && commonjsGlobal.process.nextTick ? le = commonjsGlobal.process.nextTick : commonjsGlobal.queueMicrotask ? le = commonjsGlobal.queueMicrotask : commonjsGlobal.setImmediate ? le = commonjsGlobal.setImmediate : le = commonjsGlobal.setTimeout, le);
  }
  function me(we, Ee, Re, Ue, Me) {
    return oe.importKey(
      "raw",
      we,
      { name: "PBKDF2" },
      !1,
      ["deriveBits"]
    ).then(function(De) {
      return oe.deriveBits({
        name: "PBKDF2",
        salt: Ee,
        iterations: Re,
        hash: {
          name: Me
        }
      }, De, Ue << 3);
    }).then(function(De) {
      return Y.from(De);
    });
  }
  function ye(we, Ee) {
    we.then(function(Re) {
      he()(function() {
        Ee(null, Re);
      });
    }, function(Re) {
      he()(function() {
        Ee(Re);
      });
    });
  }
  return async = function(we, Ee, Re, Ue, Me, De) {
    typeof Me == "function" && (De = Me, Me = void 0), Me = Me || "sha1";
    var Fe = se[Me.toLowerCase()];
    if (!Fe || typeof commonjsGlobal.Promise != "function") {
      he()(function() {
        var Ke;
        try {
          Ke = te(we, Ee, Re, Ue, Me);
        } catch (tt) {
          return De(tt);
        }
        De(null, Ke);
      });
      return;
    }
    if (X(Re, Ue), we = ne(we, ee, "Password"), Ee = ne(Ee, ee, "Salt"), typeof De != "function")
      throw new Error("No callback provided to pbkdf2");
    ye(ue(Fe).then(function(Ke) {
      return Ke ? me(we, Ee, Re, Ue, Fe) : te(we, Ee, Re, Ue, Me);
    }), De);
  }, async;
}
var hasRequiredBrowser$7;
function requireBrowser$7() {
  return hasRequiredBrowser$7 || (hasRequiredBrowser$7 = 1, browser$9.pbkdf2 = requireAsync(), browser$9.pbkdf2Sync = requireSyncBrowser()), browser$9;
}
var browser$8 = {}, des$1 = {}, utils$6 = {}, hasRequiredUtils$4;
function requireUtils$4() {
  if (hasRequiredUtils$4)
    return utils$6;
  hasRequiredUtils$4 = 1, utils$6.readUInt32BE = function(te, ne) {
    var ie = te[0 + ne] << 24 | te[1 + ne] << 16 | te[2 + ne] << 8 | te[3 + ne];
    return ie >>> 0;
  }, utils$6.writeUInt32BE = function(te, ne, ie) {
    te[0 + ie] = ne >>> 24, te[1 + ie] = ne >>> 16 & 255, te[2 + ie] = ne >>> 8 & 255, te[3 + ie] = ne & 255;
  }, utils$6.ip = function(te, ne, ie, oe) {
    for (var se = 0, ae = 0, ue = 6; ue >= 0; ue -= 2) {
      for (var le = 0; le <= 24; le += 8)
        se <<= 1, se |= ne >>> le + ue & 1;
      for (var le = 0; le <= 24; le += 8)
        se <<= 1, se |= te >>> le + ue & 1;
    }
    for (var ue = 6; ue >= 0; ue -= 2) {
      for (var le = 1; le <= 25; le += 8)
        ae <<= 1, ae |= ne >>> le + ue & 1;
      for (var le = 1; le <= 25; le += 8)
        ae <<= 1, ae |= te >>> le + ue & 1;
    }
    ie[oe + 0] = se >>> 0, ie[oe + 1] = ae >>> 0;
  }, utils$6.rip = function(te, ne, ie, oe) {
    for (var se = 0, ae = 0, ue = 0; ue < 4; ue++)
      for (var le = 24; le >= 0; le -= 8)
        se <<= 1, se |= ne >>> le + ue & 1, se <<= 1, se |= te >>> le + ue & 1;
    for (var ue = 4; ue < 8; ue++)
      for (var le = 24; le >= 0; le -= 8)
        ae <<= 1, ae |= ne >>> le + ue & 1, ae <<= 1, ae |= te >>> le + ue & 1;
    ie[oe + 0] = se >>> 0, ie[oe + 1] = ae >>> 0;
  }, utils$6.pc1 = function(te, ne, ie, oe) {
    for (var se = 0, ae = 0, ue = 7; ue >= 5; ue--) {
      for (var le = 0; le <= 24; le += 8)
        se <<= 1, se |= ne >> le + ue & 1;
      for (var le = 0; le <= 24; le += 8)
        se <<= 1, se |= te >> le + ue & 1;
    }
    for (var le = 0; le <= 24; le += 8)
      se <<= 1, se |= ne >> le + ue & 1;
    for (var ue = 1; ue <= 3; ue++) {
      for (var le = 0; le <= 24; le += 8)
        ae <<= 1, ae |= ne >> le + ue & 1;
      for (var le = 0; le <= 24; le += 8)
        ae <<= 1, ae |= te >> le + ue & 1;
    }
    for (var le = 0; le <= 24; le += 8)
      ae <<= 1, ae |= te >> le + ue & 1;
    ie[oe + 0] = se >>> 0, ie[oe + 1] = ae >>> 0;
  }, utils$6.r28shl = function(te, ne) {
    return te << ne & 268435455 | te >>> 28 - ne;
  };
  var Y = [
    // inL => outL
    14,
    11,
    17,
    4,
    27,
    23,
    25,
    0,
    13,
    22,
    7,
    18,
    5,
    9,
    16,
    24,
    2,
    20,
    12,
    21,
    1,
    8,
    15,
    26,
    // inR => outR
    15,
    4,
    25,
    19,
    9,
    1,
    26,
    16,
    5,
    11,
    23,
    8,
    12,
    7,
    17,
    0,
    22,
    3,
    10,
    14,
    6,
    20,
    27,
    24
  ];
  utils$6.pc2 = function(te, ne, ie, oe) {
    for (var se = 0, ae = 0, ue = Y.length >>> 1, le = 0; le < ue; le++)
      se <<= 1, se |= te >>> Y[le] & 1;
    for (var le = ue; le < Y.length; le++)
      ae <<= 1, ae |= ne >>> Y[le] & 1;
    ie[oe + 0] = se >>> 0, ie[oe + 1] = ae >>> 0;
  }, utils$6.expand = function(te, ne, ie) {
    var oe = 0, se = 0;
    oe = (te & 1) << 5 | te >>> 27;
    for (var ae = 23; ae >= 15; ae -= 4)
      oe <<= 6, oe |= te >>> ae & 63;
    for (var ae = 11; ae >= 3; ae -= 4)
      se |= te >>> ae & 63, se <<= 6;
    se |= (te & 31) << 1 | te >>> 31, ne[ie + 0] = oe >>> 0, ne[ie + 1] = se >>> 0;
  };
  var X = [
    14,
    0,
    4,
    15,
    13,
    7,
    1,
    4,
    2,
    14,
    15,
    2,
    11,
    13,
    8,
    1,
    3,
    10,
    10,
    6,
    6,
    12,
    12,
    11,
    5,
    9,
    9,
    5,
    0,
    3,
    7,
    8,
    4,
    15,
    1,
    12,
    14,
    8,
    8,
    2,
    13,
    4,
    6,
    9,
    2,
    1,
    11,
    7,
    15,
    5,
    12,
    11,
    9,
    3,
    7,
    14,
    3,
    10,
    10,
    0,
    5,
    6,
    0,
    13,
    15,
    3,
    1,
    13,
    8,
    4,
    14,
    7,
    6,
    15,
    11,
    2,
    3,
    8,
    4,
    14,
    9,
    12,
    7,
    0,
    2,
    1,
    13,
    10,
    12,
    6,
    0,
    9,
    5,
    11,
    10,
    5,
    0,
    13,
    14,
    8,
    7,
    10,
    11,
    1,
    10,
    3,
    4,
    15,
    13,
    4,
    1,
    2,
    5,
    11,
    8,
    6,
    12,
    7,
    6,
    12,
    9,
    0,
    3,
    5,
    2,
    14,
    15,
    9,
    10,
    13,
    0,
    7,
    9,
    0,
    14,
    9,
    6,
    3,
    3,
    4,
    15,
    6,
    5,
    10,
    1,
    2,
    13,
    8,
    12,
    5,
    7,
    14,
    11,
    12,
    4,
    11,
    2,
    15,
    8,
    1,
    13,
    1,
    6,
    10,
    4,
    13,
    9,
    0,
    8,
    6,
    15,
    9,
    3,
    8,
    0,
    7,
    11,
    4,
    1,
    15,
    2,
    14,
    12,
    3,
    5,
    11,
    10,
    5,
    14,
    2,
    7,
    12,
    7,
    13,
    13,
    8,
    14,
    11,
    3,
    5,
    0,
    6,
    6,
    15,
    9,
    0,
    10,
    3,
    1,
    4,
    2,
    7,
    8,
    2,
    5,
    12,
    11,
    1,
    12,
    10,
    4,
    14,
    15,
    9,
    10,
    3,
    6,
    15,
    9,
    0,
    0,
    6,
    12,
    10,
    11,
    1,
    7,
    13,
    13,
    8,
    15,
    9,
    1,
    4,
    3,
    5,
    14,
    11,
    5,
    12,
    2,
    7,
    8,
    2,
    4,
    14,
    2,
    14,
    12,
    11,
    4,
    2,
    1,
    12,
    7,
    4,
    10,
    7,
    11,
    13,
    6,
    1,
    8,
    5,
    5,
    0,
    3,
    15,
    15,
    10,
    13,
    3,
    0,
    9,
    14,
    8,
    9,
    6,
    4,
    11,
    2,
    8,
    1,
    12,
    11,
    7,
    10,
    1,
    13,
    14,
    7,
    2,
    8,
    13,
    15,
    6,
    9,
    15,
    12,
    0,
    5,
    9,
    6,
    10,
    3,
    4,
    0,
    5,
    14,
    3,
    12,
    10,
    1,
    15,
    10,
    4,
    15,
    2,
    9,
    7,
    2,
    12,
    6,
    9,
    8,
    5,
    0,
    6,
    13,
    1,
    3,
    13,
    4,
    14,
    14,
    0,
    7,
    11,
    5,
    3,
    11,
    8,
    9,
    4,
    14,
    3,
    15,
    2,
    5,
    12,
    2,
    9,
    8,
    5,
    12,
    15,
    3,
    10,
    7,
    11,
    0,
    14,
    4,
    1,
    10,
    7,
    1,
    6,
    13,
    0,
    11,
    8,
    6,
    13,
    4,
    13,
    11,
    0,
    2,
    11,
    14,
    7,
    15,
    4,
    0,
    9,
    8,
    1,
    13,
    10,
    3,
    14,
    12,
    3,
    9,
    5,
    7,
    12,
    5,
    2,
    10,
    15,
    6,
    8,
    1,
    6,
    1,
    6,
    4,
    11,
    11,
    13,
    13,
    8,
    12,
    1,
    3,
    4,
    7,
    10,
    14,
    7,
    10,
    9,
    15,
    5,
    6,
    0,
    8,
    15,
    0,
    14,
    5,
    2,
    9,
    3,
    2,
    12,
    13,
    1,
    2,
    15,
    8,
    13,
    4,
    8,
    6,
    10,
    15,
    3,
    11,
    7,
    1,
    4,
    10,
    12,
    9,
    5,
    3,
    6,
    14,
    11,
    5,
    0,
    0,
    14,
    12,
    9,
    7,
    2,
    7,
    2,
    11,
    1,
    4,
    14,
    1,
    7,
    9,
    4,
    12,
    10,
    14,
    8,
    2,
    13,
    0,
    15,
    6,
    12,
    10,
    9,
    13,
    0,
    15,
    3,
    3,
    5,
    5,
    6,
    8,
    11
  ];
  utils$6.substitute = function(te, ne) {
    for (var ie = 0, oe = 0; oe < 4; oe++) {
      var se = te >>> 18 - oe * 6 & 63, ae = X[oe * 64 + se];
      ie <<= 4, ie |= ae;
    }
    for (var oe = 0; oe < 4; oe++) {
      var se = ne >>> 18 - oe * 6 & 63, ae = X[4 * 64 + oe * 64 + se];
      ie <<= 4, ie |= ae;
    }
    return ie >>> 0;
  };
  var ee = [
    16,
    25,
    12,
    11,
    3,
    20,
    4,
    15,
    31,
    17,
    9,
    6,
    27,
    14,
    1,
    22,
    30,
    24,
    8,
    18,
    0,
    5,
    29,
    23,
    13,
    19,
    2,
    26,
    10,
    21,
    28,
    7
  ];
  return utils$6.permute = function(te) {
    for (var ne = 0, ie = 0; ie < ee.length; ie++)
      ne <<= 1, ne |= te >>> ee[ie] & 1;
    return ne >>> 0;
  }, utils$6.padSplit = function(te, ne, ie) {
    for (var oe = te.toString(2); oe.length < ne; )
      oe = "0" + oe;
    for (var se = [], ae = 0; ae < ne; ae += ie)
      se.push(oe.slice(ae, ae + ie));
    return se.join(" ");
  }, utils$6;
}
var minimalisticAssert, hasRequiredMinimalisticAssert;
function requireMinimalisticAssert() {
  if (hasRequiredMinimalisticAssert)
    return minimalisticAssert;
  hasRequiredMinimalisticAssert = 1, minimalisticAssert = Y;
  function Y(X, ee) {
    if (!X)
      throw new Error(ee || "Assertion failed");
  }
  return Y.equal = function(X, ee, te) {
    if (X != ee)
      throw new Error(te || "Assertion failed: " + X + " != " + ee);
  }, minimalisticAssert;
}
var cipher, hasRequiredCipher;
function requireCipher() {
  if (hasRequiredCipher)
    return cipher;
  hasRequiredCipher = 1;
  var Y = requireMinimalisticAssert();
  function X(ee) {
    this.options = ee, this.type = this.options.type, this.blockSize = 8, this._init(), this.buffer = new Array(this.blockSize), this.bufferOff = 0, this.padding = ee.padding !== !1;
  }
  return cipher = X, X.prototype._init = function() {
  }, X.prototype.update = function(ee) {
    return ee.length === 0 ? [] : this.type === "decrypt" ? this._updateDecrypt(ee) : this._updateEncrypt(ee);
  }, X.prototype._buffer = function(ee, te) {
    for (var ne = Math.min(this.buffer.length - this.bufferOff, ee.length - te), ie = 0; ie < ne; ie++)
      this.buffer[this.bufferOff + ie] = ee[te + ie];
    return this.bufferOff += ne, ne;
  }, X.prototype._flushBuffer = function(ee, te) {
    return this._update(this.buffer, 0, ee, te), this.bufferOff = 0, this.blockSize;
  }, X.prototype._updateEncrypt = function(ee) {
    var te = 0, ne = 0, ie = (this.bufferOff + ee.length) / this.blockSize | 0, oe = new Array(ie * this.blockSize);
    this.bufferOff !== 0 && (te += this._buffer(ee, te), this.bufferOff === this.buffer.length && (ne += this._flushBuffer(oe, ne)));
    for (var se = ee.length - (ee.length - te) % this.blockSize; te < se; te += this.blockSize)
      this._update(ee, te, oe, ne), ne += this.blockSize;
    for (; te < ee.length; te++, this.bufferOff++)
      this.buffer[this.bufferOff] = ee[te];
    return oe;
  }, X.prototype._updateDecrypt = function(ee) {
    for (var te = 0, ne = 0, ie = Math.ceil((this.bufferOff + ee.length) / this.blockSize) - 1, oe = new Array(ie * this.blockSize); ie > 0; ie--)
      te += this._buffer(ee, te), ne += this._flushBuffer(oe, ne);
    return te += this._buffer(ee, te), oe;
  }, X.prototype.final = function(ee) {
    var te;
    ee && (te = this.update(ee));
    var ne;
    return this.type === "encrypt" ? ne = this._finalEncrypt() : ne = this._finalDecrypt(), te ? te.concat(ne) : ne;
  }, X.prototype._pad = function(ee, te) {
    if (te === 0)
      return !1;
    for (; te < ee.length; )
      ee[te++] = 0;
    return !0;
  }, X.prototype._finalEncrypt = function() {
    if (!this._pad(this.buffer, this.bufferOff))
      return [];
    var ee = new Array(this.blockSize);
    return this._update(this.buffer, 0, ee, 0), ee;
  }, X.prototype._unpad = function(ee) {
    return ee;
  }, X.prototype._finalDecrypt = function() {
    Y.equal(this.bufferOff, this.blockSize, "Not enough data to decrypt");
    var ee = new Array(this.blockSize);
    return this._flushBuffer(ee, 0), this._unpad(ee);
  }, cipher;
}
var des, hasRequiredDes$1;
function requireDes$1() {
  if (hasRequiredDes$1)
    return des;
  hasRequiredDes$1 = 1;
  var Y = requireMinimalisticAssert(), X = inherits_browserExports, ee = requireUtils$4(), te = requireCipher();
  function ne() {
    this.tmp = new Array(2), this.keys = null;
  }
  function ie(se) {
    te.call(this, se);
    var ae = new ne();
    this._desState = ae, this.deriveKeys(ae, se.key);
  }
  X(ie, te), des = ie, ie.create = function(se) {
    return new ie(se);
  };
  var oe = [
    1,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    1
  ];
  return ie.prototype.deriveKeys = function(se, ae) {
    se.keys = new Array(16 * 2), Y.equal(ae.length, this.blockSize, "Invalid key length");
    var ue = ee.readUInt32BE(ae, 0), le = ee.readUInt32BE(ae, 4);
    ee.pc1(ue, le, se.tmp, 0), ue = se.tmp[0], le = se.tmp[1];
    for (var he = 0; he < se.keys.length; he += 2) {
      var me = oe[he >>> 1];
      ue = ee.r28shl(ue, me), le = ee.r28shl(le, me), ee.pc2(ue, le, se.keys, he);
    }
  }, ie.prototype._update = function(se, ae, ue, le) {
    var he = this._desState, me = ee.readUInt32BE(se, ae), ye = ee.readUInt32BE(se, ae + 4);
    ee.ip(me, ye, he.tmp, 0), me = he.tmp[0], ye = he.tmp[1], this.type === "encrypt" ? this._encrypt(he, me, ye, he.tmp, 0) : this._decrypt(he, me, ye, he.tmp, 0), me = he.tmp[0], ye = he.tmp[1], ee.writeUInt32BE(ue, me, le), ee.writeUInt32BE(ue, ye, le + 4);
  }, ie.prototype._pad = function(se, ae) {
    if (this.padding === !1)
      return !1;
    for (var ue = se.length - ae, le = ae; le < se.length; le++)
      se[le] = ue;
    return !0;
  }, ie.prototype._unpad = function(se) {
    if (this.padding === !1)
      return se;
    for (var ae = se[se.length - 1], ue = se.length - ae; ue < se.length; ue++)
      Y.equal(se[ue], ae);
    return se.slice(0, se.length - ae);
  }, ie.prototype._encrypt = function(se, ae, ue, le, he) {
    for (var me = ae, ye = ue, we = 0; we < se.keys.length; we += 2) {
      var Ee = se.keys[we], Re = se.keys[we + 1];
      ee.expand(ye, se.tmp, 0), Ee ^= se.tmp[0], Re ^= se.tmp[1];
      var Ue = ee.substitute(Ee, Re), Me = ee.permute(Ue), De = ye;
      ye = (me ^ Me) >>> 0, me = De;
    }
    ee.rip(ye, me, le, he);
  }, ie.prototype._decrypt = function(se, ae, ue, le, he) {
    for (var me = ue, ye = ae, we = se.keys.length - 2; we >= 0; we -= 2) {
      var Ee = se.keys[we], Re = se.keys[we + 1];
      ee.expand(me, se.tmp, 0), Ee ^= se.tmp[0], Re ^= se.tmp[1];
      var Ue = ee.substitute(Ee, Re), Me = ee.permute(Ue), De = me;
      me = (ye ^ Me) >>> 0, ye = De;
    }
    ee.rip(me, ye, le, he);
  }, des;
}
var cbc$1 = {}, hasRequiredCbc$1;
function requireCbc$1() {
  if (hasRequiredCbc$1)
    return cbc$1;
  hasRequiredCbc$1 = 1;
  var Y = requireMinimalisticAssert(), X = inherits_browserExports, ee = {};
  function te(ie) {
    Y.equal(ie.length, 8, "Invalid IV length"), this.iv = new Array(8);
    for (var oe = 0; oe < this.iv.length; oe++)
      this.iv[oe] = ie[oe];
  }
  function ne(ie) {
    function oe(le) {
      ie.call(this, le), this._cbcInit();
    }
    X(oe, ie);
    for (var se = Object.keys(ee), ae = 0; ae < se.length; ae++) {
      var ue = se[ae];
      oe.prototype[ue] = ee[ue];
    }
    return oe.create = function(le) {
      return new oe(le);
    }, oe;
  }
  return cbc$1.instantiate = ne, ee._cbcInit = function() {
    var ie = new te(this.options.iv);
    this._cbcState = ie;
  }, ee._update = function(ie, oe, se, ae) {
    var ue = this._cbcState, le = this.constructor.super_.prototype, he = ue.iv;
    if (this.type === "encrypt") {
      for (var me = 0; me < this.blockSize; me++)
        he[me] ^= ie[oe + me];
      le._update.call(this, he, 0, se, ae);
      for (var me = 0; me < this.blockSize; me++)
        he[me] = se[ae + me];
    } else {
      le._update.call(this, ie, oe, se, ae);
      for (var me = 0; me < this.blockSize; me++)
        se[ae + me] ^= he[me];
      for (var me = 0; me < this.blockSize; me++)
        he[me] = ie[oe + me];
    }
  }, cbc$1;
}
var ede, hasRequiredEde;
function requireEde() {
  if (hasRequiredEde)
    return ede;
  hasRequiredEde = 1;
  var Y = requireMinimalisticAssert(), X = inherits_browserExports, ee = requireCipher(), te = requireDes$1();
  function ne(oe, se) {
    Y.equal(se.length, 24, "Invalid key length");
    var ae = se.slice(0, 8), ue = se.slice(8, 16), le = se.slice(16, 24);
    oe === "encrypt" ? this.ciphers = [
      te.create({ type: "encrypt", key: ae }),
      te.create({ type: "decrypt", key: ue }),
      te.create({ type: "encrypt", key: le })
    ] : this.ciphers = [
      te.create({ type: "decrypt", key: le }),
      te.create({ type: "encrypt", key: ue }),
      te.create({ type: "decrypt", key: ae })
    ];
  }
  function ie(oe) {
    ee.call(this, oe);
    var se = new ne(this.type, this.options.key);
    this._edeState = se;
  }
  return X(ie, ee), ede = ie, ie.create = function(oe) {
    return new ie(oe);
  }, ie.prototype._update = function(oe, se, ae, ue) {
    var le = this._edeState;
    le.ciphers[0]._update(oe, se, ae, ue), le.ciphers[1]._update(ae, ue, ae, ue), le.ciphers[2]._update(ae, ue, ae, ue);
  }, ie.prototype._pad = te.prototype._pad, ie.prototype._unpad = te.prototype._unpad, ede;
}
var hasRequiredDes;
function requireDes() {
  return hasRequiredDes || (hasRequiredDes = 1, des$1.utils = requireUtils$4(), des$1.Cipher = requireCipher(), des$1.DES = requireDes$1(), des$1.CBC = requireCbc$1(), des$1.EDE = requireEde()), des$1;
}
var browserifyDes, hasRequiredBrowserifyDes;
function requireBrowserifyDes() {
  if (hasRequiredBrowserifyDes)
    return browserifyDes;
  hasRequiredBrowserifyDes = 1;
  var Y = cipherBase, X = requireDes(), ee = inherits_browserExports, te = safeBufferExports.Buffer, ne = {
    "des-ede3-cbc": X.CBC.instantiate(X.EDE),
    "des-ede3": X.EDE,
    "des-ede-cbc": X.CBC.instantiate(X.EDE),
    "des-ede": X.EDE,
    "des-cbc": X.CBC.instantiate(X.DES),
    "des-ecb": X.DES
  };
  ne.des = ne["des-cbc"], ne.des3 = ne["des-ede3-cbc"], browserifyDes = ie, ee(ie, Y);
  function ie(oe) {
    Y.call(this);
    var se = oe.mode.toLowerCase(), ae = ne[se], ue;
    oe.decrypt ? ue = "decrypt" : ue = "encrypt";
    var le = oe.key;
    te.isBuffer(le) || (le = te.from(le)), (se === "des-ede" || se === "des-ede-cbc") && (le = te.concat([le, le.slice(0, 8)]));
    var he = oe.iv;
    te.isBuffer(he) || (he = te.from(he)), this._des = ae.create({
      key: le,
      iv: he,
      type: ue
    });
  }
  return ie.prototype._update = function(oe) {
    return te.from(this._des.update(oe));
  }, ie.prototype._final = function() {
    return te.from(this._des.final());
  }, browserifyDes;
}
var browser$7 = {}, encrypter = {}, ecb = {}, hasRequiredEcb;
function requireEcb() {
  return hasRequiredEcb || (hasRequiredEcb = 1, ecb.encrypt = function(Y, X) {
    return Y._cipher.encryptBlock(X);
  }, ecb.decrypt = function(Y, X) {
    return Y._cipher.decryptBlock(X);
  }), ecb;
}
var cbc = {}, bufferXor, hasRequiredBufferXor;
function requireBufferXor() {
  return hasRequiredBufferXor || (hasRequiredBufferXor = 1, bufferXor = function(Y, X) {
    for (var ee = Math.min(Y.length, X.length), te = new Buffer$e(ee), ne = 0; ne < ee; ++ne)
      te[ne] = Y[ne] ^ X[ne];
    return te;
  }), bufferXor;
}
var hasRequiredCbc;
function requireCbc() {
  if (hasRequiredCbc)
    return cbc;
  hasRequiredCbc = 1;
  var Y = requireBufferXor();
  return cbc.encrypt = function(X, ee) {
    var te = Y(ee, X._prev);
    return X._prev = X._cipher.encryptBlock(te), X._prev;
  }, cbc.decrypt = function(X, ee) {
    var te = X._prev;
    X._prev = ee;
    var ne = X._cipher.decryptBlock(ee);
    return Y(ne, te);
  }, cbc;
}
var cfb = {}, hasRequiredCfb;
function requireCfb() {
  if (hasRequiredCfb)
    return cfb;
  hasRequiredCfb = 1;
  var Y = safeBufferExports.Buffer, X = requireBufferXor();
  function ee(te, ne, ie) {
    var oe = ne.length, se = X(ne, te._cache);
    return te._cache = te._cache.slice(oe), te._prev = Y.concat([te._prev, ie ? ne : se]), se;
  }
  return cfb.encrypt = function(te, ne, ie) {
    for (var oe = Y.allocUnsafe(0), se; ne.length; )
      if (te._cache.length === 0 && (te._cache = te._cipher.encryptBlock(te._prev), te._prev = Y.allocUnsafe(0)), te._cache.length <= ne.length)
        se = te._cache.length, oe = Y.concat([oe, ee(te, ne.slice(0, se), ie)]), ne = ne.slice(se);
      else {
        oe = Y.concat([oe, ee(te, ne, ie)]);
        break;
      }
    return oe;
  }, cfb;
}
var cfb8 = {}, hasRequiredCfb8;
function requireCfb8() {
  if (hasRequiredCfb8)
    return cfb8;
  hasRequiredCfb8 = 1;
  var Y = safeBufferExports.Buffer;
  function X(ee, te, ne) {
    var ie = ee._cipher.encryptBlock(ee._prev), oe = ie[0] ^ te;
    return ee._prev = Y.concat([
      ee._prev.slice(1),
      Y.from([ne ? te : oe])
    ]), oe;
  }
  return cfb8.encrypt = function(ee, te, ne) {
    for (var ie = te.length, oe = Y.allocUnsafe(ie), se = -1; ++se < ie; )
      oe[se] = X(ee, te[se], ne);
    return oe;
  }, cfb8;
}
var cfb1 = {}, hasRequiredCfb1;
function requireCfb1() {
  if (hasRequiredCfb1)
    return cfb1;
  hasRequiredCfb1 = 1;
  var Y = safeBufferExports.Buffer;
  function X(te, ne, ie) {
    for (var oe, se = -1, ae = 8, ue = 0, le, he; ++se < ae; )
      oe = te._cipher.encryptBlock(te._prev), le = ne & 1 << 7 - se ? 128 : 0, he = oe[0] ^ le, ue += (he & 128) >> se % 8, te._prev = ee(te._prev, ie ? le : he);
    return ue;
  }
  function ee(te, ne) {
    var ie = te.length, oe = -1, se = Y.allocUnsafe(te.length);
    for (te = Y.concat([te, Y.from([ne])]); ++oe < ie; )
      se[oe] = te[oe] << 1 | te[oe + 1] >> 7;
    return se;
  }
  return cfb1.encrypt = function(te, ne, ie) {
    for (var oe = ne.length, se = Y.allocUnsafe(oe), ae = -1; ++ae < oe; )
      se[ae] = X(te, ne[ae], ie);
    return se;
  }, cfb1;
}
var ofb = {}, hasRequiredOfb;
function requireOfb() {
  if (hasRequiredOfb)
    return ofb;
  hasRequiredOfb = 1;
  var Y = requireBufferXor();
  function X(ee) {
    return ee._prev = ee._cipher.encryptBlock(ee._prev), ee._prev;
  }
  return ofb.encrypt = function(ee, te) {
    for (; ee._cache.length < te.length; )
      ee._cache = Buffer$e.concat([ee._cache, X(ee)]);
    var ne = ee._cache.slice(0, te.length);
    return ee._cache = ee._cache.slice(te.length), Y(te, ne);
  }, ofb;
}
var ctr = {}, incr32_1, hasRequiredIncr32;
function requireIncr32() {
  if (hasRequiredIncr32)
    return incr32_1;
  hasRequiredIncr32 = 1;
  function Y(X) {
    for (var ee = X.length, te; ee--; )
      if (te = X.readUInt8(ee), te === 255)
        X.writeUInt8(0, ee);
      else {
        te++, X.writeUInt8(te, ee);
        break;
      }
  }
  return incr32_1 = Y, incr32_1;
}
var hasRequiredCtr;
function requireCtr() {
  if (hasRequiredCtr)
    return ctr;
  hasRequiredCtr = 1;
  var Y = requireBufferXor(), X = safeBufferExports.Buffer, ee = requireIncr32();
  function te(ie) {
    var oe = ie._cipher.encryptBlockRaw(ie._prev);
    return ee(ie._prev), oe;
  }
  var ne = 16;
  return ctr.encrypt = function(ie, oe) {
    var se = Math.ceil(oe.length / ne), ae = ie._cache.length;
    ie._cache = X.concat([
      ie._cache,
      X.allocUnsafe(se * ne)
    ]);
    for (var ue = 0; ue < se; ue++) {
      var le = te(ie), he = ae + ue * ne;
      ie._cache.writeUInt32BE(le[0], he + 0), ie._cache.writeUInt32BE(le[1], he + 4), ie._cache.writeUInt32BE(le[2], he + 8), ie._cache.writeUInt32BE(le[3], he + 12);
    }
    var me = ie._cache.slice(0, oe.length);
    return ie._cache = ie._cache.slice(oe.length), Y(oe, me);
  }, ctr;
}
const aes128 = {
  cipher: "AES",
  key: 128,
  iv: 16,
  mode: "CBC",
  type: "block"
}, aes192 = {
  cipher: "AES",
  key: 192,
  iv: 16,
  mode: "CBC",
  type: "block"
}, aes256 = {
  cipher: "AES",
  key: 256,
  iv: 16,
  mode: "CBC",
  type: "block"
}, require$$2$2 = {
  "aes-128-ecb": {
    cipher: "AES",
    key: 128,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-192-ecb": {
    cipher: "AES",
    key: 192,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-256-ecb": {
    cipher: "AES",
    key: 256,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-128-cbc": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  "aes-192-cbc": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  "aes-256-cbc": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  aes128,
  aes192,
  aes256,
  "aes-128-cfb": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-192-cfb": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-256-cfb": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-128-cfb8": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-192-cfb8": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-256-cfb8": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-128-cfb1": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-192-cfb1": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-256-cfb1": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-128-ofb": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-192-ofb": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-256-ofb": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-128-ctr": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-192-ctr": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-256-ctr": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-128-gcm": {
    cipher: "AES",
    key: 128,
    iv: 12,
    mode: "GCM",
    type: "auth"
  },
  "aes-192-gcm": {
    cipher: "AES",
    key: 192,
    iv: 12,
    mode: "GCM",
    type: "auth"
  },
  "aes-256-gcm": {
    cipher: "AES",
    key: 256,
    iv: 12,
    mode: "GCM",
    type: "auth"
  }
};
var modes_1, hasRequiredModes$1;
function requireModes$1() {
  if (hasRequiredModes$1)
    return modes_1;
  hasRequiredModes$1 = 1;
  var Y = {
    ECB: requireEcb(),
    CBC: requireCbc(),
    CFB: requireCfb(),
    CFB8: requireCfb8(),
    CFB1: requireCfb1(),
    OFB: requireOfb(),
    CTR: requireCtr(),
    GCM: requireCtr()
  }, X = require$$2$2;
  for (var ee in X)
    X[ee].module = Y[X[ee].mode];
  return modes_1 = X, modes_1;
}
var aes = {}, hasRequiredAes;
function requireAes() {
  if (hasRequiredAes)
    return aes;
  hasRequiredAes = 1;
  var Y = safeBufferExports.Buffer;
  function X(se) {
    Y.isBuffer(se) || (se = Y.from(se));
    for (var ae = se.length / 4 | 0, ue = new Array(ae), le = 0; le < ae; le++)
      ue[le] = se.readUInt32BE(le * 4);
    return ue;
  }
  function ee(se) {
    for (var ae = 0; ae < se.length; se++)
      se[ae] = 0;
  }
  function te(se, ae, ue, le, he) {
    for (var me = ue[0], ye = ue[1], we = ue[2], Ee = ue[3], Re = se[0] ^ ae[0], Ue = se[1] ^ ae[1], Me = se[2] ^ ae[2], De = se[3] ^ ae[3], Fe, Ke, tt, rt, it = 4, _t = 1; _t < he; _t++)
      Fe = me[Re >>> 24] ^ ye[Ue >>> 16 & 255] ^ we[Me >>> 8 & 255] ^ Ee[De & 255] ^ ae[it++], Ke = me[Ue >>> 24] ^ ye[Me >>> 16 & 255] ^ we[De >>> 8 & 255] ^ Ee[Re & 255] ^ ae[it++], tt = me[Me >>> 24] ^ ye[De >>> 16 & 255] ^ we[Re >>> 8 & 255] ^ Ee[Ue & 255] ^ ae[it++], rt = me[De >>> 24] ^ ye[Re >>> 16 & 255] ^ we[Ue >>> 8 & 255] ^ Ee[Me & 255] ^ ae[it++], Re = Fe, Ue = Ke, Me = tt, De = rt;
    return Fe = (le[Re >>> 24] << 24 | le[Ue >>> 16 & 255] << 16 | le[Me >>> 8 & 255] << 8 | le[De & 255]) ^ ae[it++], Ke = (le[Ue >>> 24] << 24 | le[Me >>> 16 & 255] << 16 | le[De >>> 8 & 255] << 8 | le[Re & 255]) ^ ae[it++], tt = (le[Me >>> 24] << 24 | le[De >>> 16 & 255] << 16 | le[Re >>> 8 & 255] << 8 | le[Ue & 255]) ^ ae[it++], rt = (le[De >>> 24] << 24 | le[Re >>> 16 & 255] << 16 | le[Ue >>> 8 & 255] << 8 | le[Me & 255]) ^ ae[it++], Fe = Fe >>> 0, Ke = Ke >>> 0, tt = tt >>> 0, rt = rt >>> 0, [Fe, Ke, tt, rt];
  }
  var ne = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], ie = function() {
    for (var se = new Array(256), ae = 0; ae < 256; ae++)
      ae < 128 ? se[ae] = ae << 1 : se[ae] = ae << 1 ^ 283;
    for (var ue = [], le = [], he = [[], [], [], []], me = [[], [], [], []], ye = 0, we = 0, Ee = 0; Ee < 256; ++Ee) {
      var Re = we ^ we << 1 ^ we << 2 ^ we << 3 ^ we << 4;
      Re = Re >>> 8 ^ Re & 255 ^ 99, ue[ye] = Re, le[Re] = ye;
      var Ue = se[ye], Me = se[Ue], De = se[Me], Fe = se[Re] * 257 ^ Re * 16843008;
      he[0][ye] = Fe << 24 | Fe >>> 8, he[1][ye] = Fe << 16 | Fe >>> 16, he[2][ye] = Fe << 8 | Fe >>> 24, he[3][ye] = Fe, Fe = De * 16843009 ^ Me * 65537 ^ Ue * 257 ^ ye * 16843008, me[0][Re] = Fe << 24 | Fe >>> 8, me[1][Re] = Fe << 16 | Fe >>> 16, me[2][Re] = Fe << 8 | Fe >>> 24, me[3][Re] = Fe, ye === 0 ? ye = we = 1 : (ye = Ue ^ se[se[se[De ^ Ue]]], we ^= se[se[we]]);
    }
    return {
      SBOX: ue,
      INV_SBOX: le,
      SUB_MIX: he,
      INV_SUB_MIX: me
    };
  }();
  function oe(se) {
    this._key = X(se), this._reset();
  }
  return oe.blockSize = 4 * 4, oe.keySize = 256 / 8, oe.prototype.blockSize = oe.blockSize, oe.prototype.keySize = oe.keySize, oe.prototype._reset = function() {
    for (var se = this._key, ae = se.length, ue = ae + 6, le = (ue + 1) * 4, he = [], me = 0; me < ae; me++)
      he[me] = se[me];
    for (me = ae; me < le; me++) {
      var ye = he[me - 1];
      me % ae === 0 ? (ye = ye << 8 | ye >>> 24, ye = ie.SBOX[ye >>> 24] << 24 | ie.SBOX[ye >>> 16 & 255] << 16 | ie.SBOX[ye >>> 8 & 255] << 8 | ie.SBOX[ye & 255], ye ^= ne[me / ae | 0] << 24) : ae > 6 && me % ae === 4 && (ye = ie.SBOX[ye >>> 24] << 24 | ie.SBOX[ye >>> 16 & 255] << 16 | ie.SBOX[ye >>> 8 & 255] << 8 | ie.SBOX[ye & 255]), he[me] = he[me - ae] ^ ye;
    }
    for (var we = [], Ee = 0; Ee < le; Ee++) {
      var Re = le - Ee, Ue = he[Re - (Ee % 4 ? 0 : 4)];
      Ee < 4 || Re <= 4 ? we[Ee] = Ue : we[Ee] = ie.INV_SUB_MIX[0][ie.SBOX[Ue >>> 24]] ^ ie.INV_SUB_MIX[1][ie.SBOX[Ue >>> 16 & 255]] ^ ie.INV_SUB_MIX[2][ie.SBOX[Ue >>> 8 & 255]] ^ ie.INV_SUB_MIX[3][ie.SBOX[Ue & 255]];
    }
    this._nRounds = ue, this._keySchedule = he, this._invKeySchedule = we;
  }, oe.prototype.encryptBlockRaw = function(se) {
    return se = X(se), te(se, this._keySchedule, ie.SUB_MIX, ie.SBOX, this._nRounds);
  }, oe.prototype.encryptBlock = function(se) {
    var ae = this.encryptBlockRaw(se), ue = Y.allocUnsafe(16);
    return ue.writeUInt32BE(ae[0], 0), ue.writeUInt32BE(ae[1], 4), ue.writeUInt32BE(ae[2], 8), ue.writeUInt32BE(ae[3], 12), ue;
  }, oe.prototype.decryptBlock = function(se) {
    se = X(se);
    var ae = se[1];
    se[1] = se[3], se[3] = ae;
    var ue = te(se, this._invKeySchedule, ie.INV_SUB_MIX, ie.INV_SBOX, this._nRounds), le = Y.allocUnsafe(16);
    return le.writeUInt32BE(ue[0], 0), le.writeUInt32BE(ue[3], 4), le.writeUInt32BE(ue[2], 8), le.writeUInt32BE(ue[1], 12), le;
  }, oe.prototype.scrub = function() {
    ee(this._keySchedule), ee(this._invKeySchedule), ee(this._key);
  }, aes.AES = oe, aes;
}
var ghash, hasRequiredGhash;
function requireGhash() {
  if (hasRequiredGhash)
    return ghash;
  hasRequiredGhash = 1;
  var Y = safeBufferExports.Buffer, X = Y.alloc(16, 0);
  function ee(ie) {
    return [
      ie.readUInt32BE(0),
      ie.readUInt32BE(4),
      ie.readUInt32BE(8),
      ie.readUInt32BE(12)
    ];
  }
  function te(ie) {
    var oe = Y.allocUnsafe(16);
    return oe.writeUInt32BE(ie[0] >>> 0, 0), oe.writeUInt32BE(ie[1] >>> 0, 4), oe.writeUInt32BE(ie[2] >>> 0, 8), oe.writeUInt32BE(ie[3] >>> 0, 12), oe;
  }
  function ne(ie) {
    this.h = ie, this.state = Y.alloc(16, 0), this.cache = Y.allocUnsafe(0);
  }
  return ne.prototype.ghash = function(ie) {
    for (var oe = -1; ++oe < ie.length; )
      this.state[oe] ^= ie[oe];
    this._multiply();
  }, ne.prototype._multiply = function() {
    for (var ie = ee(this.h), oe = [0, 0, 0, 0], se, ae, ue, le = -1; ++le < 128; ) {
      for (ae = (this.state[~~(le / 8)] & 1 << 7 - le % 8) !== 0, ae && (oe[0] ^= ie[0], oe[1] ^= ie[1], oe[2] ^= ie[2], oe[3] ^= ie[3]), ue = (ie[3] & 1) !== 0, se = 3; se > 0; se--)
        ie[se] = ie[se] >>> 1 | (ie[se - 1] & 1) << 31;
      ie[0] = ie[0] >>> 1, ue && (ie[0] = ie[0] ^ 225 << 24);
    }
    this.state = te(oe);
  }, ne.prototype.update = function(ie) {
    this.cache = Y.concat([this.cache, ie]);
    for (var oe; this.cache.length >= 16; )
      oe = this.cache.slice(0, 16), this.cache = this.cache.slice(16), this.ghash(oe);
  }, ne.prototype.final = function(ie, oe) {
    return this.cache.length && this.ghash(Y.concat([this.cache, X], 16)), this.ghash(te([0, ie, 0, oe])), this.state;
  }, ghash = ne, ghash;
}
var authCipher, hasRequiredAuthCipher;
function requireAuthCipher() {
  if (hasRequiredAuthCipher)
    return authCipher;
  hasRequiredAuthCipher = 1;
  var Y = requireAes(), X = safeBufferExports.Buffer, ee = cipherBase, te = inherits_browserExports, ne = requireGhash(), ie = requireBufferXor(), oe = requireIncr32();
  function se(le, he) {
    var me = 0;
    le.length !== he.length && me++;
    for (var ye = Math.min(le.length, he.length), we = 0; we < ye; ++we)
      me += le[we] ^ he[we];
    return me;
  }
  function ae(le, he, me) {
    if (he.length === 12)
      return le._finID = X.concat([he, X.from([0, 0, 0, 1])]), X.concat([he, X.from([0, 0, 0, 2])]);
    var ye = new ne(me), we = he.length, Ee = we % 16;
    ye.update(he), Ee && (Ee = 16 - Ee, ye.update(X.alloc(Ee, 0))), ye.update(X.alloc(8, 0));
    var Re = we * 8, Ue = X.alloc(8);
    Ue.writeUIntBE(Re, 0, 8), ye.update(Ue), le._finID = ye.state;
    var Me = X.from(le._finID);
    return oe(Me), Me;
  }
  function ue(le, he, me, ye) {
    ee.call(this);
    var we = X.alloc(4, 0);
    this._cipher = new Y.AES(he);
    var Ee = this._cipher.encryptBlock(we);
    this._ghash = new ne(Ee), me = ae(this, me, Ee), this._prev = X.from(me), this._cache = X.allocUnsafe(0), this._secCache = X.allocUnsafe(0), this._decrypt = ye, this._alen = 0, this._len = 0, this._mode = le, this._authTag = null, this._called = !1;
  }
  return te(ue, ee), ue.prototype._update = function(le) {
    if (!this._called && this._alen) {
      var he = 16 - this._alen % 16;
      he < 16 && (he = X.alloc(he, 0), this._ghash.update(he));
    }
    this._called = !0;
    var me = this._mode.encrypt(this, le);
    return this._decrypt ? this._ghash.update(le) : this._ghash.update(me), this._len += le.length, me;
  }, ue.prototype._final = function() {
    if (this._decrypt && !this._authTag)
      throw new Error("Unsupported state or unable to authenticate data");
    var le = ie(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID));
    if (this._decrypt && se(le, this._authTag))
      throw new Error("Unsupported state or unable to authenticate data");
    this._authTag = le, this._cipher.scrub();
  }, ue.prototype.getAuthTag = function() {
    if (this._decrypt || !X.isBuffer(this._authTag))
      throw new Error("Attempting to get auth tag in unsupported state");
    return this._authTag;
  }, ue.prototype.setAuthTag = function(le) {
    if (!this._decrypt)
      throw new Error("Attempting to set auth tag in unsupported state");
    this._authTag = le;
  }, ue.prototype.setAAD = function(le) {
    if (this._called)
      throw new Error("Attempting to set AAD in unsupported state");
    this._ghash.update(le), this._alen += le.length;
  }, authCipher = ue, authCipher;
}
var streamCipher, hasRequiredStreamCipher;
function requireStreamCipher() {
  if (hasRequiredStreamCipher)
    return streamCipher;
  hasRequiredStreamCipher = 1;
  var Y = requireAes(), X = safeBufferExports.Buffer, ee = cipherBase, te = inherits_browserExports;
  function ne(ie, oe, se, ae) {
    ee.call(this), this._cipher = new Y.AES(oe), this._prev = X.from(se), this._cache = X.allocUnsafe(0), this._secCache = X.allocUnsafe(0), this._decrypt = ae, this._mode = ie;
  }
  return te(ne, ee), ne.prototype._update = function(ie) {
    return this._mode.encrypt(this, ie, this._decrypt);
  }, ne.prototype._final = function() {
    this._cipher.scrub();
  }, streamCipher = ne, streamCipher;
}
var evp_bytestokey, hasRequiredEvp_bytestokey;
function requireEvp_bytestokey() {
  if (hasRequiredEvp_bytestokey)
    return evp_bytestokey;
  hasRequiredEvp_bytestokey = 1;
  var Y = safeBufferExports.Buffer, X = md5_js;
  function ee(te, ne, ie, oe) {
    if (Y.isBuffer(te) || (te = Y.from(te, "binary")), ne && (Y.isBuffer(ne) || (ne = Y.from(ne, "binary")), ne.length !== 8))
      throw new RangeError("salt should be Buffer with 8 byte length");
    for (var se = ie / 8, ae = Y.alloc(se), ue = Y.alloc(oe || 0), le = Y.alloc(0); se > 0 || oe > 0; ) {
      var he = new X();
      he.update(le), he.update(te), ne && he.update(ne), le = he.digest();
      var me = 0;
      if (se > 0) {
        var ye = ae.length - se;
        me = Math.min(se, le.length), le.copy(ae, ye, 0, me), se -= me;
      }
      if (me < le.length && oe > 0) {
        var we = ue.length - oe, Ee = Math.min(oe, le.length - me);
        le.copy(ue, we, me, me + Ee), oe -= Ee;
      }
    }
    return le.fill(0), { key: ae, iv: ue };
  }
  return evp_bytestokey = ee, evp_bytestokey;
}
var hasRequiredEncrypter;
function requireEncrypter() {
  if (hasRequiredEncrypter)
    return encrypter;
  hasRequiredEncrypter = 1;
  var Y = requireModes$1(), X = requireAuthCipher(), ee = safeBufferExports.Buffer, te = requireStreamCipher(), ne = cipherBase, ie = requireAes(), oe = requireEvp_bytestokey(), se = inherits_browserExports;
  function ae(ye, we, Ee) {
    ne.call(this), this._cache = new le(), this._cipher = new ie.AES(we), this._prev = ee.from(Ee), this._mode = ye, this._autopadding = !0;
  }
  se(ae, ne), ae.prototype._update = function(ye) {
    this._cache.add(ye);
    for (var we, Ee, Re = []; we = this._cache.get(); )
      Ee = this._mode.encrypt(this, we), Re.push(Ee);
    return ee.concat(Re);
  };
  var ue = ee.alloc(16, 16);
  ae.prototype._final = function() {
    var ye = this._cache.flush();
    if (this._autopadding)
      return ye = this._mode.encrypt(this, ye), this._cipher.scrub(), ye;
    if (!ye.equals(ue))
      throw this._cipher.scrub(), new Error("data not multiple of block length");
  }, ae.prototype.setAutoPadding = function(ye) {
    return this._autopadding = !!ye, this;
  };
  function le() {
    this.cache = ee.allocUnsafe(0);
  }
  le.prototype.add = function(ye) {
    this.cache = ee.concat([this.cache, ye]);
  }, le.prototype.get = function() {
    if (this.cache.length > 15) {
      var ye = this.cache.slice(0, 16);
      return this.cache = this.cache.slice(16), ye;
    }
    return null;
  }, le.prototype.flush = function() {
    for (var ye = 16 - this.cache.length, we = ee.allocUnsafe(ye), Ee = -1; ++Ee < ye; )
      we.writeUInt8(ye, Ee);
    return ee.concat([this.cache, we]);
  };
  function he(ye, we, Ee) {
    var Re = Y[ye.toLowerCase()];
    if (!Re)
      throw new TypeError("invalid suite type");
    if (typeof we == "string" && (we = ee.from(we)), we.length !== Re.key / 8)
      throw new TypeError("invalid key length " + we.length);
    if (typeof Ee == "string" && (Ee = ee.from(Ee)), Re.mode !== "GCM" && Ee.length !== Re.iv)
      throw new TypeError("invalid iv length " + Ee.length);
    return Re.type === "stream" ? new te(Re.module, we, Ee) : Re.type === "auth" ? new X(Re.module, we, Ee) : new ae(Re.module, we, Ee);
  }
  function me(ye, we) {
    var Ee = Y[ye.toLowerCase()];
    if (!Ee)
      throw new TypeError("invalid suite type");
    var Re = oe(we, !1, Ee.key, Ee.iv);
    return he(ye, Re.key, Re.iv);
  }
  return encrypter.createCipheriv = he, encrypter.createCipher = me, encrypter;
}
var decrypter = {}, hasRequiredDecrypter;
function requireDecrypter() {
  if (hasRequiredDecrypter)
    return decrypter;
  hasRequiredDecrypter = 1;
  var Y = requireAuthCipher(), X = safeBufferExports.Buffer, ee = requireModes$1(), te = requireStreamCipher(), ne = cipherBase, ie = requireAes(), oe = requireEvp_bytestokey(), se = inherits_browserExports;
  function ae(ye, we, Ee) {
    ne.call(this), this._cache = new ue(), this._last = void 0, this._cipher = new ie.AES(we), this._prev = X.from(Ee), this._mode = ye, this._autopadding = !0;
  }
  se(ae, ne), ae.prototype._update = function(ye) {
    this._cache.add(ye);
    for (var we, Ee, Re = []; we = this._cache.get(this._autopadding); )
      Ee = this._mode.decrypt(this, we), Re.push(Ee);
    return X.concat(Re);
  }, ae.prototype._final = function() {
    var ye = this._cache.flush();
    if (this._autopadding)
      return le(this._mode.decrypt(this, ye));
    if (ye)
      throw new Error("data not multiple of block length");
  }, ae.prototype.setAutoPadding = function(ye) {
    return this._autopadding = !!ye, this;
  };
  function ue() {
    this.cache = X.allocUnsafe(0);
  }
  ue.prototype.add = function(ye) {
    this.cache = X.concat([this.cache, ye]);
  }, ue.prototype.get = function(ye) {
    var we;
    if (ye) {
      if (this.cache.length > 16)
        return we = this.cache.slice(0, 16), this.cache = this.cache.slice(16), we;
    } else if (this.cache.length >= 16)
      return we = this.cache.slice(0, 16), this.cache = this.cache.slice(16), we;
    return null;
  }, ue.prototype.flush = function() {
    if (this.cache.length)
      return this.cache;
  };
  function le(ye) {
    var we = ye[15];
    if (we < 1 || we > 16)
      throw new Error("unable to decrypt data");
    for (var Ee = -1; ++Ee < we; )
      if (ye[Ee + (16 - we)] !== we)
        throw new Error("unable to decrypt data");
    if (we !== 16)
      return ye.slice(0, 16 - we);
  }
  function he(ye, we, Ee) {
    var Re = ee[ye.toLowerCase()];
    if (!Re)
      throw new TypeError("invalid suite type");
    if (typeof Ee == "string" && (Ee = X.from(Ee)), Re.mode !== "GCM" && Ee.length !== Re.iv)
      throw new TypeError("invalid iv length " + Ee.length);
    if (typeof we == "string" && (we = X.from(we)), we.length !== Re.key / 8)
      throw new TypeError("invalid key length " + we.length);
    return Re.type === "stream" ? new te(Re.module, we, Ee, !0) : Re.type === "auth" ? new Y(Re.module, we, Ee, !0) : new ae(Re.module, we, Ee);
  }
  function me(ye, we) {
    var Ee = ee[ye.toLowerCase()];
    if (!Ee)
      throw new TypeError("invalid suite type");
    var Re = oe(we, !1, Ee.key, Ee.iv);
    return he(ye, Re.key, Re.iv);
  }
  return decrypter.createDecipher = me, decrypter.createDecipheriv = he, decrypter;
}
var hasRequiredBrowser$6;
function requireBrowser$6() {
  if (hasRequiredBrowser$6)
    return browser$7;
  hasRequiredBrowser$6 = 1;
  var Y = requireEncrypter(), X = requireDecrypter(), ee = require$$2$2;
  function te() {
    return Object.keys(ee);
  }
  return browser$7.createCipher = browser$7.Cipher = Y.createCipher, browser$7.createCipheriv = browser$7.Cipheriv = Y.createCipheriv, browser$7.createDecipher = browser$7.Decipher = X.createDecipher, browser$7.createDecipheriv = browser$7.Decipheriv = X.createDecipheriv, browser$7.listCiphers = browser$7.getCiphers = te, browser$7;
}
var modes = {}, hasRequiredModes;
function requireModes() {
  return hasRequiredModes || (hasRequiredModes = 1, function(Y) {
    Y["des-ecb"] = {
      key: 8,
      iv: 0
    }, Y["des-cbc"] = Y.des = {
      key: 8,
      iv: 8
    }, Y["des-ede3-cbc"] = Y.des3 = {
      key: 24,
      iv: 8
    }, Y["des-ede3"] = {
      key: 24,
      iv: 0
    }, Y["des-ede-cbc"] = {
      key: 16,
      iv: 8
    }, Y["des-ede"] = {
      key: 16,
      iv: 0
    };
  }(modes)), modes;
}
var hasRequiredBrowser$5;
function requireBrowser$5() {
  if (hasRequiredBrowser$5)
    return browser$8;
  hasRequiredBrowser$5 = 1;
  var Y = requireBrowserifyDes(), X = requireBrowser$6(), ee = requireModes$1(), te = requireModes(), ne = requireEvp_bytestokey();
  function ie(le, he) {
    le = le.toLowerCase();
    var me, ye;
    if (ee[le])
      me = ee[le].key, ye = ee[le].iv;
    else if (te[le])
      me = te[le].key * 8, ye = te[le].iv;
    else
      throw new TypeError("invalid suite type");
    var we = ne(he, !1, me, ye);
    return se(le, we.key, we.iv);
  }
  function oe(le, he) {
    le = le.toLowerCase();
    var me, ye;
    if (ee[le])
      me = ee[le].key, ye = ee[le].iv;
    else if (te[le])
      me = te[le].key * 8, ye = te[le].iv;
    else
      throw new TypeError("invalid suite type");
    var we = ne(he, !1, me, ye);
    return ae(le, we.key, we.iv);
  }
  function se(le, he, me) {
    if (le = le.toLowerCase(), ee[le])
      return X.createCipheriv(le, he, me);
    if (te[le])
      return new Y({ key: he, iv: me, mode: le });
    throw new TypeError("invalid suite type");
  }
  function ae(le, he, me) {
    if (le = le.toLowerCase(), ee[le])
      return X.createDecipheriv(le, he, me);
    if (te[le])
      return new Y({ key: he, iv: me, mode: le, decrypt: !0 });
    throw new TypeError("invalid suite type");
  }
  function ue() {
    return Object.keys(te).concat(X.getCiphers());
  }
  return browser$8.createCipher = browser$8.Cipher = ie, browser$8.createCipheriv = browser$8.Cipheriv = se, browser$8.createDecipher = browser$8.Decipher = oe, browser$8.createDecipheriv = browser$8.Decipheriv = ae, browser$8.listCiphers = browser$8.getCiphers = ue, browser$8;
}
var browser$6 = {}, bn$1 = { exports: {} }, hasRequiredBn;
function requireBn() {
  return hasRequiredBn || (hasRequiredBn = 1, function(Y) {
    (function(X, ee) {
      function te(je, ze) {
        if (!je)
          throw new Error(ze || "Assertion failed");
      }
      function ne(je, ze) {
        je.super_ = ze;
        var fe = function() {
        };
        fe.prototype = ze.prototype, je.prototype = new fe(), je.prototype.constructor = je;
      }
      function ie(je, ze, fe) {
        if (ie.isBN(je))
          return je;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, je !== null && ((ze === "le" || ze === "be") && (fe = ze, ze = 10), this._init(je || 0, ze || 10, fe || "be"));
      }
      typeof X == "object" ? X.exports = ie : ee.BN = ie, ie.BN = ie, ie.wordSize = 26;
      var oe;
      try {
        typeof window < "u" && typeof window.Buffer < "u" ? oe = window.Buffer : oe = require$$0$3.Buffer;
      } catch {
      }
      ie.isBN = function(je) {
        return je instanceof ie ? !0 : je !== null && typeof je == "object" && je.constructor.wordSize === ie.wordSize && Array.isArray(je.words);
      }, ie.max = function(je, ze) {
        return je.cmp(ze) > 0 ? je : ze;
      }, ie.min = function(je, ze) {
        return je.cmp(ze) < 0 ? je : ze;
      }, ie.prototype._init = function(je, ze, fe) {
        if (typeof je == "number")
          return this._initNumber(je, ze, fe);
        if (typeof je == "object")
          return this._initArray(je, ze, fe);
        ze === "hex" && (ze = 16), te(ze === (ze | 0) && ze >= 2 && ze <= 36), je = je.toString().replace(/\s+/g, "");
        var de = 0;
        je[0] === "-" && (de++, this.negative = 1), de < je.length && (ze === 16 ? this._parseHex(je, de, fe) : (this._parseBase(je, ze, de), fe === "le" && this._initArray(this.toArray(), ze, fe)));
      }, ie.prototype._initNumber = function(je, ze, fe) {
        je < 0 && (this.negative = 1, je = -je), je < 67108864 ? (this.words = [je & 67108863], this.length = 1) : je < 4503599627370496 ? (this.words = [
          je & 67108863,
          je / 67108864 & 67108863
        ], this.length = 2) : (te(je < 9007199254740992), this.words = [
          je & 67108863,
          je / 67108864 & 67108863,
          1
        ], this.length = 3), fe === "le" && this._initArray(this.toArray(), ze, fe);
      }, ie.prototype._initArray = function(je, ze, fe) {
        if (te(typeof je.length == "number"), je.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(je.length / 3), this.words = new Array(this.length);
        for (var de = 0; de < this.length; de++)
          this.words[de] = 0;
        var be, Te, Ce = 0;
        if (fe === "be")
          for (de = je.length - 1, be = 0; de >= 0; de -= 3)
            Te = je[de] | je[de - 1] << 8 | je[de - 2] << 16, this.words[be] |= Te << Ce & 67108863, this.words[be + 1] = Te >>> 26 - Ce & 67108863, Ce += 24, Ce >= 26 && (Ce -= 26, be++);
        else if (fe === "le")
          for (de = 0, be = 0; de < je.length; de += 3)
            Te = je[de] | je[de + 1] << 8 | je[de + 2] << 16, this.words[be] |= Te << Ce & 67108863, this.words[be + 1] = Te >>> 26 - Ce & 67108863, Ce += 24, Ce >= 26 && (Ce -= 26, be++);
        return this.strip();
      };
      function se(je, ze) {
        var fe = je.charCodeAt(ze);
        return fe >= 65 && fe <= 70 ? fe - 55 : fe >= 97 && fe <= 102 ? fe - 87 : fe - 48 & 15;
      }
      function ae(je, ze, fe) {
        var de = se(je, fe);
        return fe - 1 >= ze && (de |= se(je, fe - 1) << 4), de;
      }
      ie.prototype._parseHex = function(je, ze, fe) {
        this.length = Math.ceil((je.length - ze) / 6), this.words = new Array(this.length);
        for (var de = 0; de < this.length; de++)
          this.words[de] = 0;
        var be = 0, Te = 0, Ce;
        if (fe === "be")
          for (de = je.length - 1; de >= ze; de -= 2)
            Ce = ae(je, ze, de) << be, this.words[Te] |= Ce & 67108863, be >= 18 ? (be -= 18, Te += 1, this.words[Te] |= Ce >>> 26) : be += 8;
        else {
          var Pe = je.length - ze;
          for (de = Pe % 2 === 0 ? ze + 1 : ze; de < je.length; de += 2)
            Ce = ae(je, ze, de) << be, this.words[Te] |= Ce & 67108863, be >= 18 ? (be -= 18, Te += 1, this.words[Te] |= Ce >>> 26) : be += 8;
        }
        this.strip();
      };
      function ue(je, ze, fe, de) {
        for (var be = 0, Te = Math.min(je.length, fe), Ce = ze; Ce < Te; Ce++) {
          var Pe = je.charCodeAt(Ce) - 48;
          be *= de, Pe >= 49 ? be += Pe - 49 + 10 : Pe >= 17 ? be += Pe - 17 + 10 : be += Pe;
        }
        return be;
      }
      ie.prototype._parseBase = function(je, ze, fe) {
        this.words = [0], this.length = 1;
        for (var de = 0, be = 1; be <= 67108863; be *= ze)
          de++;
        de--, be = be / ze | 0;
        for (var Te = je.length - fe, Ce = Te % de, Pe = Math.min(Te, Te - Ce) + fe, Se = 0, ke = fe; ke < Pe; ke += de)
          Se = ue(je, ke, ke + de, ze), this.imuln(be), this.words[0] + Se < 67108864 ? this.words[0] += Se : this._iaddn(Se);
        if (Ce !== 0) {
          var ge = 1;
          for (Se = ue(je, ke, je.length, ze), ke = 0; ke < Ce; ke++)
            ge *= ze;
          this.imuln(ge), this.words[0] + Se < 67108864 ? this.words[0] += Se : this._iaddn(Se);
        }
        this.strip();
      }, ie.prototype.copy = function(je) {
        je.words = new Array(this.length);
        for (var ze = 0; ze < this.length; ze++)
          je.words[ze] = this.words[ze];
        je.length = this.length, je.negative = this.negative, je.red = this.red;
      }, ie.prototype.clone = function() {
        var je = new ie(null);
        return this.copy(je), je;
      }, ie.prototype._expand = function(je) {
        for (; this.length < je; )
          this.words[this.length++] = 0;
        return this;
      }, ie.prototype.strip = function() {
        for (; this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }, ie.prototype._normSign = function() {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }, ie.prototype.inspect = function() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var le = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ], he = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ], me = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      ie.prototype.toString = function(je, ze) {
        je = je || 10, ze = ze | 0 || 1;
        var fe;
        if (je === 16 || je === "hex") {
          fe = "";
          for (var de = 0, be = 0, Te = 0; Te < this.length; Te++) {
            var Ce = this.words[Te], Pe = ((Ce << de | be) & 16777215).toString(16);
            be = Ce >>> 24 - de & 16777215, be !== 0 || Te !== this.length - 1 ? fe = le[6 - Pe.length] + Pe + fe : fe = Pe + fe, de += 2, de >= 26 && (de -= 26, Te--);
          }
          for (be !== 0 && (fe = be.toString(16) + fe); fe.length % ze !== 0; )
            fe = "0" + fe;
          return this.negative !== 0 && (fe = "-" + fe), fe;
        }
        if (je === (je | 0) && je >= 2 && je <= 36) {
          var Se = he[je], ke = me[je];
          fe = "";
          var ge = this.clone();
          for (ge.negative = 0; !ge.isZero(); ) {
            var Ae = ge.modn(ke).toString(je);
            ge = ge.idivn(ke), ge.isZero() ? fe = Ae + fe : fe = le[Se - Ae.length] + Ae + fe;
          }
          for (this.isZero() && (fe = "0" + fe); fe.length % ze !== 0; )
            fe = "0" + fe;
          return this.negative !== 0 && (fe = "-" + fe), fe;
        }
        te(!1, "Base should be between 2 and 36");
      }, ie.prototype.toNumber = function() {
        var je = this.words[0];
        return this.length === 2 ? je += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? je += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && te(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -je : je;
      }, ie.prototype.toJSON = function() {
        return this.toString(16);
      }, ie.prototype.toBuffer = function(je, ze) {
        return te(typeof oe < "u"), this.toArrayLike(oe, je, ze);
      }, ie.prototype.toArray = function(je, ze) {
        return this.toArrayLike(Array, je, ze);
      }, ie.prototype.toArrayLike = function(je, ze, fe) {
        var de = this.byteLength(), be = fe || Math.max(1, de);
        te(de <= be, "byte array longer than desired length"), te(be > 0, "Requested array length <= 0"), this.strip();
        var Te = ze === "le", Ce = new je(be), Pe, Se, ke = this.clone();
        if (Te) {
          for (Se = 0; !ke.isZero(); Se++)
            Pe = ke.andln(255), ke.iushrn(8), Ce[Se] = Pe;
          for (; Se < be; Se++)
            Ce[Se] = 0;
        } else {
          for (Se = 0; Se < be - de; Se++)
            Ce[Se] = 0;
          for (Se = 0; !ke.isZero(); Se++)
            Pe = ke.andln(255), ke.iushrn(8), Ce[be - Se - 1] = Pe;
        }
        return Ce;
      }, Math.clz32 ? ie.prototype._countBits = function(je) {
        return 32 - Math.clz32(je);
      } : ie.prototype._countBits = function(je) {
        var ze = je, fe = 0;
        return ze >= 4096 && (fe += 13, ze >>>= 13), ze >= 64 && (fe += 7, ze >>>= 7), ze >= 8 && (fe += 4, ze >>>= 4), ze >= 2 && (fe += 2, ze >>>= 2), fe + ze;
      }, ie.prototype._zeroBits = function(je) {
        if (je === 0)
          return 26;
        var ze = je, fe = 0;
        return ze & 8191 || (fe += 13, ze >>>= 13), ze & 127 || (fe += 7, ze >>>= 7), ze & 15 || (fe += 4, ze >>>= 4), ze & 3 || (fe += 2, ze >>>= 2), ze & 1 || fe++, fe;
      }, ie.prototype.bitLength = function() {
        var je = this.words[this.length - 1], ze = this._countBits(je);
        return (this.length - 1) * 26 + ze;
      };
      function ye(je) {
        for (var ze = new Array(je.bitLength()), fe = 0; fe < ze.length; fe++) {
          var de = fe / 26 | 0, be = fe % 26;
          ze[fe] = (je.words[de] & 1 << be) >>> be;
        }
        return ze;
      }
      ie.prototype.zeroBits = function() {
        if (this.isZero())
          return 0;
        for (var je = 0, ze = 0; ze < this.length; ze++) {
          var fe = this._zeroBits(this.words[ze]);
          if (je += fe, fe !== 26)
            break;
        }
        return je;
      }, ie.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, ie.prototype.toTwos = function(je) {
        return this.negative !== 0 ? this.abs().inotn(je).iaddn(1) : this.clone();
      }, ie.prototype.fromTwos = function(je) {
        return this.testn(je - 1) ? this.notn(je).iaddn(1).ineg() : this.clone();
      }, ie.prototype.isNeg = function() {
        return this.negative !== 0;
      }, ie.prototype.neg = function() {
        return this.clone().ineg();
      }, ie.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this;
      }, ie.prototype.iuor = function(je) {
        for (; this.length < je.length; )
          this.words[this.length++] = 0;
        for (var ze = 0; ze < je.length; ze++)
          this.words[ze] = this.words[ze] | je.words[ze];
        return this.strip();
      }, ie.prototype.ior = function(je) {
        return te((this.negative | je.negative) === 0), this.iuor(je);
      }, ie.prototype.or = function(je) {
        return this.length > je.length ? this.clone().ior(je) : je.clone().ior(this);
      }, ie.prototype.uor = function(je) {
        return this.length > je.length ? this.clone().iuor(je) : je.clone().iuor(this);
      }, ie.prototype.iuand = function(je) {
        var ze;
        this.length > je.length ? ze = je : ze = this;
        for (var fe = 0; fe < ze.length; fe++)
          this.words[fe] = this.words[fe] & je.words[fe];
        return this.length = ze.length, this.strip();
      }, ie.prototype.iand = function(je) {
        return te((this.negative | je.negative) === 0), this.iuand(je);
      }, ie.prototype.and = function(je) {
        return this.length > je.length ? this.clone().iand(je) : je.clone().iand(this);
      }, ie.prototype.uand = function(je) {
        return this.length > je.length ? this.clone().iuand(je) : je.clone().iuand(this);
      }, ie.prototype.iuxor = function(je) {
        var ze, fe;
        this.length > je.length ? (ze = this, fe = je) : (ze = je, fe = this);
        for (var de = 0; de < fe.length; de++)
          this.words[de] = ze.words[de] ^ fe.words[de];
        if (this !== ze)
          for (; de < ze.length; de++)
            this.words[de] = ze.words[de];
        return this.length = ze.length, this.strip();
      }, ie.prototype.ixor = function(je) {
        return te((this.negative | je.negative) === 0), this.iuxor(je);
      }, ie.prototype.xor = function(je) {
        return this.length > je.length ? this.clone().ixor(je) : je.clone().ixor(this);
      }, ie.prototype.uxor = function(je) {
        return this.length > je.length ? this.clone().iuxor(je) : je.clone().iuxor(this);
      }, ie.prototype.inotn = function(je) {
        te(typeof je == "number" && je >= 0);
        var ze = Math.ceil(je / 26) | 0, fe = je % 26;
        this._expand(ze), fe > 0 && ze--;
        for (var de = 0; de < ze; de++)
          this.words[de] = ~this.words[de] & 67108863;
        return fe > 0 && (this.words[de] = ~this.words[de] & 67108863 >> 26 - fe), this.strip();
      }, ie.prototype.notn = function(je) {
        return this.clone().inotn(je);
      }, ie.prototype.setn = function(je, ze) {
        te(typeof je == "number" && je >= 0);
        var fe = je / 26 | 0, de = je % 26;
        return this._expand(fe + 1), ze ? this.words[fe] = this.words[fe] | 1 << de : this.words[fe] = this.words[fe] & ~(1 << de), this.strip();
      }, ie.prototype.iadd = function(je) {
        var ze;
        if (this.negative !== 0 && je.negative === 0)
          return this.negative = 0, ze = this.isub(je), this.negative ^= 1, this._normSign();
        if (this.negative === 0 && je.negative !== 0)
          return je.negative = 0, ze = this.isub(je), je.negative = 1, ze._normSign();
        var fe, de;
        this.length > je.length ? (fe = this, de = je) : (fe = je, de = this);
        for (var be = 0, Te = 0; Te < de.length; Te++)
          ze = (fe.words[Te] | 0) + (de.words[Te] | 0) + be, this.words[Te] = ze & 67108863, be = ze >>> 26;
        for (; be !== 0 && Te < fe.length; Te++)
          ze = (fe.words[Te] | 0) + be, this.words[Te] = ze & 67108863, be = ze >>> 26;
        if (this.length = fe.length, be !== 0)
          this.words[this.length] = be, this.length++;
        else if (fe !== this)
          for (; Te < fe.length; Te++)
            this.words[Te] = fe.words[Te];
        return this;
      }, ie.prototype.add = function(je) {
        var ze;
        return je.negative !== 0 && this.negative === 0 ? (je.negative = 0, ze = this.sub(je), je.negative ^= 1, ze) : je.negative === 0 && this.negative !== 0 ? (this.negative = 0, ze = je.sub(this), this.negative = 1, ze) : this.length > je.length ? this.clone().iadd(je) : je.clone().iadd(this);
      }, ie.prototype.isub = function(je) {
        if (je.negative !== 0) {
          je.negative = 0;
          var ze = this.iadd(je);
          return je.negative = 1, ze._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(je), this.negative = 1, this._normSign();
        var fe = this.cmp(je);
        if (fe === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var de, be;
        fe > 0 ? (de = this, be = je) : (de = je, be = this);
        for (var Te = 0, Ce = 0; Ce < be.length; Ce++)
          ze = (de.words[Ce] | 0) - (be.words[Ce] | 0) + Te, Te = ze >> 26, this.words[Ce] = ze & 67108863;
        for (; Te !== 0 && Ce < de.length; Ce++)
          ze = (de.words[Ce] | 0) + Te, Te = ze >> 26, this.words[Ce] = ze & 67108863;
        if (Te === 0 && Ce < de.length && de !== this)
          for (; Ce < de.length; Ce++)
            this.words[Ce] = de.words[Ce];
        return this.length = Math.max(this.length, Ce), de !== this && (this.negative = 1), this.strip();
      }, ie.prototype.sub = function(je) {
        return this.clone().isub(je);
      };
      function we(je, ze, fe) {
        fe.negative = ze.negative ^ je.negative;
        var de = je.length + ze.length | 0;
        fe.length = de, de = de - 1 | 0;
        var be = je.words[0] | 0, Te = ze.words[0] | 0, Ce = be * Te, Pe = Ce & 67108863, Se = Ce / 67108864 | 0;
        fe.words[0] = Pe;
        for (var ke = 1; ke < de; ke++) {
          for (var ge = Se >>> 26, Ae = Se & 67108863, Ge = Math.min(ke, ze.length - 1), Xe = Math.max(0, ke - je.length + 1); Xe <= Ge; Xe++) {
            var $e = ke - Xe | 0;
            be = je.words[$e] | 0, Te = ze.words[Xe] | 0, Ce = be * Te + Ae, ge += Ce / 67108864 | 0, Ae = Ce & 67108863;
          }
          fe.words[ke] = Ae | 0, Se = ge | 0;
        }
        return Se !== 0 ? fe.words[ke] = Se | 0 : fe.length--, fe.strip();
      }
      var Ee = function(je, ze, fe) {
        var de = je.words, be = ze.words, Te = fe.words, Ce = 0, Pe, Se, ke, ge = de[0] | 0, Ae = ge & 8191, Ge = ge >>> 13, Xe = de[1] | 0, $e = Xe & 8191, Ze = Xe >>> 13, ot = de[2] | 0, ct = ot & 8191, At = ot >>> 13, Tt = de[3] | 0, dt = Tt & 8191, vt = Tt >>> 13, Ut = de[4] | 0, It = Ut & 8191, Er = Ut >>> 13, Fr = de[5] | 0, an = Fr & 8191, wX = Fr >>> 13, Ct = de[6] | 0, w_ = Ct & 8191, hX = Ct >>> 13, oX = de[7] | 0, Nn = oX & 8191, SX = oX >>> 13, sX = de[8] | 0, nX = sX & 8191, Ye = sX >>> 13, lt = de[9] | 0, pt = lt & 8191, He = lt >>> 13, Je = be[0] | 0, st = Je & 8191, gt = Je >>> 13, kt = be[1] | 0, Vt = kt & 8191, Lr = kt >>> 13, Ci = be[2] | 0, Qr = Ci & 8191, xX = Ci >>> 13, lX = be[3] | 0, rX = lX & 8191, FX = lX >>> 13, BX = be[4] | 0, cX = BX & 8191, MX = BX >>> 13, EX = be[5] | 0, yX = EX & 8191, jX = EX >>> 13, AX = be[6] | 0, vX = AX & 8191, PX = AX >>> 13, kX = be[7] | 0, qe = kX & 8191, Qe = kX >>> 13, Ve = be[8] | 0, Ie = Ve & 8191, nt = Ve >>> 13, Et = be[9] | 0, xt = Et & 8191, Jt = Et >>> 13;
        fe.negative = je.negative ^ ze.negative, fe.length = 19, Pe = Math.imul(Ae, st), Se = Math.imul(Ae, gt), Se = Se + Math.imul(Ge, st) | 0, ke = Math.imul(Ge, gt);
        var Yt = (Ce + Pe | 0) + ((Se & 8191) << 13) | 0;
        Ce = (ke + (Se >>> 13) | 0) + (Yt >>> 26) | 0, Yt &= 67108863, Pe = Math.imul($e, st), Se = Math.imul($e, gt), Se = Se + Math.imul(Ze, st) | 0, ke = Math.imul(Ze, gt), Pe = Pe + Math.imul(Ae, Vt) | 0, Se = Se + Math.imul(Ae, Lr) | 0, Se = Se + Math.imul(Ge, Vt) | 0, ke = ke + Math.imul(Ge, Lr) | 0;
        var _r = (Ce + Pe | 0) + ((Se & 8191) << 13) | 0;
        Ce = (ke + (Se >>> 13) | 0) + (_r >>> 26) | 0, _r &= 67108863, Pe = Math.imul(ct, st), Se = Math.imul(ct, gt), Se = Se + Math.imul(At, st) | 0, ke = Math.imul(At, gt), Pe = Pe + Math.imul($e, Vt) | 0, Se = Se + Math.imul($e, Lr) | 0, Se = Se + Math.imul(Ze, Vt) | 0, ke = ke + Math.imul(Ze, Lr) | 0, Pe = Pe + Math.imul(Ae, Qr) | 0, Se = Se + Math.imul(Ae, xX) | 0, Se = Se + Math.imul(Ge, Qr) | 0, ke = ke + Math.imul(Ge, xX) | 0;
        var cn = (Ce + Pe | 0) + ((Se & 8191) << 13) | 0;
        Ce = (ke + (Se >>> 13) | 0) + (cn >>> 26) | 0, cn &= 67108863, Pe = Math.imul(dt, st), Se = Math.imul(dt, gt), Se = Se + Math.imul(vt, st) | 0, ke = Math.imul(vt, gt), Pe = Pe + Math.imul(ct, Vt) | 0, Se = Se + Math.imul(ct, Lr) | 0, Se = Se + Math.imul(At, Vt) | 0, ke = ke + Math.imul(At, Lr) | 0, Pe = Pe + Math.imul($e, Qr) | 0, Se = Se + Math.imul($e, xX) | 0, Se = Se + Math.imul(Ze, Qr) | 0, ke = ke + Math.imul(Ze, xX) | 0, Pe = Pe + Math.imul(Ae, rX) | 0, Se = Se + Math.imul(Ae, FX) | 0, Se = Se + Math.imul(Ge, rX) | 0, ke = ke + Math.imul(Ge, FX) | 0;
        var _X = (Ce + Pe | 0) + ((Se & 8191) << 13) | 0;
        Ce = (ke + (Se >>> 13) | 0) + (_X >>> 26) | 0, _X &= 67108863, Pe = Math.imul(It, st), Se = Math.imul(It, gt), Se = Se + Math.imul(Er, st) | 0, ke = Math.imul(Er, gt), Pe = Pe + Math.imul(dt, Vt) | 0, Se = Se + Math.imul(dt, Lr) | 0, Se = Se + Math.imul(vt, Vt) | 0, ke = ke + Math.imul(vt, Lr) | 0, Pe = Pe + Math.imul(ct, Qr) | 0, Se = Se + Math.imul(ct, xX) | 0, Se = Se + Math.imul(At, Qr) | 0, ke = ke + Math.imul(At, xX) | 0, Pe = Pe + Math.imul($e, rX) | 0, Se = Se + Math.imul($e, FX) | 0, Se = Se + Math.imul(Ze, rX) | 0, ke = ke + Math.imul(Ze, FX) | 0, Pe = Pe + Math.imul(Ae, cX) | 0, Se = Se + Math.imul(Ae, MX) | 0, Se = Se + Math.imul(Ge, cX) | 0, ke = ke + Math.imul(Ge, MX) | 0;
        var un = (Ce + Pe | 0) + ((Se & 8191) << 13) | 0;
        Ce = (ke + (Se >>> 13) | 0) + (un >>> 26) | 0, un &= 67108863, Pe = Math.imul(an, st), Se = Math.imul(an, gt), Se = Se + Math.imul(wX, st) | 0, ke = Math.imul(wX, gt), Pe = Pe + Math.imul(It, Vt) | 0, Se = Se + Math.imul(It, Lr) | 0, Se = Se + Math.imul(Er, Vt) | 0, ke = ke + Math.imul(Er, Lr) | 0, Pe = Pe + Math.imul(dt, Qr) | 0, Se = Se + Math.imul(dt, xX) | 0, Se = Se + Math.imul(vt, Qr) | 0, ke = ke + Math.imul(vt, xX) | 0, Pe = Pe + Math.imul(ct, rX) | 0, Se = Se + Math.imul(ct, FX) | 0, Se = Se + Math.imul(At, rX) | 0, ke = ke + Math.imul(At, FX) | 0, Pe = Pe + Math.imul($e, cX) | 0, Se = Se + Math.imul($e, MX) | 0, Se = Se + Math.imul(Ze, cX) | 0, ke = ke + Math.imul(Ze, MX) | 0, Pe = Pe + Math.imul(Ae, yX) | 0, Se = Se + Math.imul(Ae, jX) | 0, Se = Se + Math.imul(Ge, yX) | 0, ke = ke + Math.imul(Ge, jX) | 0;
        var aX = (Ce + Pe | 0) + ((Se & 8191) << 13) | 0;
        Ce = (ke + (Se >>> 13) | 0) + (aX >>> 26) | 0, aX &= 67108863, Pe = Math.imul(w_, st), Se = Math.imul(w_, gt), Se = Se + Math.imul(hX, st) | 0, ke = Math.imul(hX, gt), Pe = Pe + Math.imul(an, Vt) | 0, Se = Se + Math.imul(an, Lr) | 0, Se = Se + Math.imul(wX, Vt) | 0, ke = ke + Math.imul(wX, Lr) | 0, Pe = Pe + Math.imul(It, Qr) | 0, Se = Se + Math.imul(It, xX) | 0, Se = Se + Math.imul(Er, Qr) | 0, ke = ke + Math.imul(Er, xX) | 0, Pe = Pe + Math.imul(dt, rX) | 0, Se = Se + Math.imul(dt, FX) | 0, Se = Se + Math.imul(vt, rX) | 0, ke = ke + Math.imul(vt, FX) | 0, Pe = Pe + Math.imul(ct, cX) | 0, Se = Se + Math.imul(ct, MX) | 0, Se = Se + Math.imul(At, cX) | 0, ke = ke + Math.imul(At, MX) | 0, Pe = Pe + Math.imul($e, yX) | 0, Se = Se + Math.imul($e, jX) | 0, Se = Se + Math.imul(Ze, yX) | 0, ke = ke + Math.imul(Ze, jX) | 0, Pe = Pe + Math.imul(Ae, vX) | 0, Se = Se + Math.imul(Ae, PX) | 0, Se = Se + Math.imul(Ge, vX) | 0, ke = ke + Math.imul(Ge, PX) | 0;
        var uX = (Ce + Pe | 0) + ((Se & 8191) << 13) | 0;
        Ce = (ke + (Se >>> 13) | 0) + (uX >>> 26) | 0, uX &= 67108863, Pe = Math.imul(Nn, st), Se = Math.imul(Nn, gt), Se = Se + Math.imul(SX, st) | 0, ke = Math.imul(SX, gt), Pe = Pe + Math.imul(w_, Vt) | 0, Se = Se + Math.imul(w_, Lr) | 0, Se = Se + Math.imul(hX, Vt) | 0, ke = ke + Math.imul(hX, Lr) | 0, Pe = Pe + Math.imul(an, Qr) | 0, Se = Se + Math.imul(an, xX) | 0, Se = Se + Math.imul(wX, Qr) | 0, ke = ke + Math.imul(wX, xX) | 0, Pe = Pe + Math.imul(It, rX) | 0, Se = Se + Math.imul(It, FX) | 0, Se = Se + Math.imul(Er, rX) | 0, ke = ke + Math.imul(Er, FX) | 0, Pe = Pe + Math.imul(dt, cX) | 0, Se = Se + Math.imul(dt, MX) | 0, Se = Se + Math.imul(vt, cX) | 0, ke = ke + Math.imul(vt, MX) | 0, Pe = Pe + Math.imul(ct, yX) | 0, Se = Se + Math.imul(ct, jX) | 0, Se = Se + Math.imul(At, yX) | 0, ke = ke + Math.imul(At, jX) | 0, Pe = Pe + Math.imul($e, vX) | 0, Se = Se + Math.imul($e, PX) | 0, Se = Se + Math.imul(Ze, vX) | 0, ke = ke + Math.imul(Ze, PX) | 0, Pe = Pe + Math.imul(Ae, qe) | 0, Se = Se + Math.imul(Ae, Qe) | 0, Se = Se + Math.imul(Ge, qe) | 0, ke = ke + Math.imul(Ge, Qe) | 0;
        var fX = (Ce + Pe | 0) + ((Se & 8191) << 13) | 0;
        Ce = (ke + (Se >>> 13) | 0) + (fX >>> 26) | 0, fX &= 67108863, Pe = Math.imul(nX, st), Se = Math.imul(nX, gt), Se = Se + Math.imul(Ye, st) | 0, ke = Math.imul(Ye, gt), Pe = Pe + Math.imul(Nn, Vt) | 0, Se = Se + Math.imul(Nn, Lr) | 0, Se = Se + Math.imul(SX, Vt) | 0, ke = ke + Math.imul(SX, Lr) | 0, Pe = Pe + Math.imul(w_, Qr) | 0, Se = Se + Math.imul(w_, xX) | 0, Se = Se + Math.imul(hX, Qr) | 0, ke = ke + Math.imul(hX, xX) | 0, Pe = Pe + Math.imul(an, rX) | 0, Se = Se + Math.imul(an, FX) | 0, Se = Se + Math.imul(wX, rX) | 0, ke = ke + Math.imul(wX, FX) | 0, Pe = Pe + Math.imul(It, cX) | 0, Se = Se + Math.imul(It, MX) | 0, Se = Se + Math.imul(Er, cX) | 0, ke = ke + Math.imul(Er, MX) | 0, Pe = Pe + Math.imul(dt, yX) | 0, Se = Se + Math.imul(dt, jX) | 0, Se = Se + Math.imul(vt, yX) | 0, ke = ke + Math.imul(vt, jX) | 0, Pe = Pe + Math.imul(ct, vX) | 0, Se = Se + Math.imul(ct, PX) | 0, Se = Se + Math.imul(At, vX) | 0, ke = ke + Math.imul(At, PX) | 0, Pe = Pe + Math.imul($e, qe) | 0, Se = Se + Math.imul($e, Qe) | 0, Se = Se + Math.imul(Ze, qe) | 0, ke = ke + Math.imul(Ze, Qe) | 0, Pe = Pe + Math.imul(Ae, Ie) | 0, Se = Se + Math.imul(Ae, nt) | 0, Se = Se + Math.imul(Ge, Ie) | 0, ke = ke + Math.imul(Ge, nt) | 0;
        var bX = (Ce + Pe | 0) + ((Se & 8191) << 13) | 0;
        Ce = (ke + (Se >>> 13) | 0) + (bX >>> 26) | 0, bX &= 67108863, Pe = Math.imul(pt, st), Se = Math.imul(pt, gt), Se = Se + Math.imul(He, st) | 0, ke = Math.imul(He, gt), Pe = Pe + Math.imul(nX, Vt) | 0, Se = Se + Math.imul(nX, Lr) | 0, Se = Se + Math.imul(Ye, Vt) | 0, ke = ke + Math.imul(Ye, Lr) | 0, Pe = Pe + Math.imul(Nn, Qr) | 0, Se = Se + Math.imul(Nn, xX) | 0, Se = Se + Math.imul(SX, Qr) | 0, ke = ke + Math.imul(SX, xX) | 0, Pe = Pe + Math.imul(w_, rX) | 0, Se = Se + Math.imul(w_, FX) | 0, Se = Se + Math.imul(hX, rX) | 0, ke = ke + Math.imul(hX, FX) | 0, Pe = Pe + Math.imul(an, cX) | 0, Se = Se + Math.imul(an, MX) | 0, Se = Se + Math.imul(wX, cX) | 0, ke = ke + Math.imul(wX, MX) | 0, Pe = Pe + Math.imul(It, yX) | 0, Se = Se + Math.imul(It, jX) | 0, Se = Se + Math.imul(Er, yX) | 0, ke = ke + Math.imul(Er, jX) | 0, Pe = Pe + Math.imul(dt, vX) | 0, Se = Se + Math.imul(dt, PX) | 0, Se = Se + Math.imul(vt, vX) | 0, ke = ke + Math.imul(vt, PX) | 0, Pe = Pe + Math.imul(ct, qe) | 0, Se = Se + Math.imul(ct, Qe) | 0, Se = Se + Math.imul(At, qe) | 0, ke = ke + Math.imul(At, Qe) | 0, Pe = Pe + Math.imul($e, Ie) | 0, Se = Se + Math.imul($e, nt) | 0, Se = Se + Math.imul(Ze, Ie) | 0, ke = ke + Math.imul(Ze, nt) | 0, Pe = Pe + Math.imul(Ae, xt) | 0, Se = Se + Math.imul(Ae, Jt) | 0, Se = Se + Math.imul(Ge, xt) | 0, ke = ke + Math.imul(Ge, Jt) | 0;
        var dX = (Ce + Pe | 0) + ((Se & 8191) << 13) | 0;
        Ce = (ke + (Se >>> 13) | 0) + (dX >>> 26) | 0, dX &= 67108863, Pe = Math.imul(pt, Vt), Se = Math.imul(pt, Lr), Se = Se + Math.imul(He, Vt) | 0, ke = Math.imul(He, Lr), Pe = Pe + Math.imul(nX, Qr) | 0, Se = Se + Math.imul(nX, xX) | 0, Se = Se + Math.imul(Ye, Qr) | 0, ke = ke + Math.imul(Ye, xX) | 0, Pe = Pe + Math.imul(Nn, rX) | 0, Se = Se + Math.imul(Nn, FX) | 0, Se = Se + Math.imul(SX, rX) | 0, ke = ke + Math.imul(SX, FX) | 0, Pe = Pe + Math.imul(w_, cX) | 0, Se = Se + Math.imul(w_, MX) | 0, Se = Se + Math.imul(hX, cX) | 0, ke = ke + Math.imul(hX, MX) | 0, Pe = Pe + Math.imul(an, yX) | 0, Se = Se + Math.imul(an, jX) | 0, Se = Se + Math.imul(wX, yX) | 0, ke = ke + Math.imul(wX, jX) | 0, Pe = Pe + Math.imul(It, vX) | 0, Se = Se + Math.imul(It, PX) | 0, Se = Se + Math.imul(Er, vX) | 0, ke = ke + Math.imul(Er, PX) | 0, Pe = Pe + Math.imul(dt, qe) | 0, Se = Se + Math.imul(dt, Qe) | 0, Se = Se + Math.imul(vt, qe) | 0, ke = ke + Math.imul(vt, Qe) | 0, Pe = Pe + Math.imul(ct, Ie) | 0, Se = Se + Math.imul(ct, nt) | 0, Se = Se + Math.imul(At, Ie) | 0, ke = ke + Math.imul(At, nt) | 0, Pe = Pe + Math.imul($e, xt) | 0, Se = Se + Math.imul($e, Jt) | 0, Se = Se + Math.imul(Ze, xt) | 0, ke = ke + Math.imul(Ze, Jt) | 0;
        var mX = (Ce + Pe | 0) + ((Se & 8191) << 13) | 0;
        Ce = (ke + (Se >>> 13) | 0) + (mX >>> 26) | 0, mX &= 67108863, Pe = Math.imul(pt, Qr), Se = Math.imul(pt, xX), Se = Se + Math.imul(He, Qr) | 0, ke = Math.imul(He, xX), Pe = Pe + Math.imul(nX, rX) | 0, Se = Se + Math.imul(nX, FX) | 0, Se = Se + Math.imul(Ye, rX) | 0, ke = ke + Math.imul(Ye, FX) | 0, Pe = Pe + Math.imul(Nn, cX) | 0, Se = Se + Math.imul(Nn, MX) | 0, Se = Se + Math.imul(SX, cX) | 0, ke = ke + Math.imul(SX, MX) | 0, Pe = Pe + Math.imul(w_, yX) | 0, Se = Se + Math.imul(w_, jX) | 0, Se = Se + Math.imul(hX, yX) | 0, ke = ke + Math.imul(hX, jX) | 0, Pe = Pe + Math.imul(an, vX) | 0, Se = Se + Math.imul(an, PX) | 0, Se = Se + Math.imul(wX, vX) | 0, ke = ke + Math.imul(wX, PX) | 0, Pe = Pe + Math.imul(It, qe) | 0, Se = Se + Math.imul(It, Qe) | 0, Se = Se + Math.imul(Er, qe) | 0, ke = ke + Math.imul(Er, Qe) | 0, Pe = Pe + Math.imul(dt, Ie) | 0, Se = Se + Math.imul(dt, nt) | 0, Se = Se + Math.imul(vt, Ie) | 0, ke = ke + Math.imul(vt, nt) | 0, Pe = Pe + Math.imul(ct, xt) | 0, Se = Se + Math.imul(ct, Jt) | 0, Se = Se + Math.imul(At, xt) | 0, ke = ke + Math.imul(At, Jt) | 0;
        var pX = (Ce + Pe | 0) + ((Se & 8191) << 13) | 0;
        Ce = (ke + (Se >>> 13) | 0) + (pX >>> 26) | 0, pX &= 67108863, Pe = Math.imul(pt, rX), Se = Math.imul(pt, FX), Se = Se + Math.imul(He, rX) | 0, ke = Math.imul(He, FX), Pe = Pe + Math.imul(nX, cX) | 0, Se = Se + Math.imul(nX, MX) | 0, Se = Se + Math.imul(Ye, cX) | 0, ke = ke + Math.imul(Ye, MX) | 0, Pe = Pe + Math.imul(Nn, yX) | 0, Se = Se + Math.imul(Nn, jX) | 0, Se = Se + Math.imul(SX, yX) | 0, ke = ke + Math.imul(SX, jX) | 0, Pe = Pe + Math.imul(w_, vX) | 0, Se = Se + Math.imul(w_, PX) | 0, Se = Se + Math.imul(hX, vX) | 0, ke = ke + Math.imul(hX, PX) | 0, Pe = Pe + Math.imul(an, qe) | 0, Se = Se + Math.imul(an, Qe) | 0, Se = Se + Math.imul(wX, qe) | 0, ke = ke + Math.imul(wX, Qe) | 0, Pe = Pe + Math.imul(It, Ie) | 0, Se = Se + Math.imul(It, nt) | 0, Se = Se + Math.imul(Er, Ie) | 0, ke = ke + Math.imul(Er, nt) | 0, Pe = Pe + Math.imul(dt, xt) | 0, Se = Se + Math.imul(dt, Jt) | 0, Se = Se + Math.imul(vt, xt) | 0, ke = ke + Math.imul(vt, Jt) | 0;
        var G_ = (Ce + Pe | 0) + ((Se & 8191) << 13) | 0;
        Ce = (ke + (Se >>> 13) | 0) + (G_ >>> 26) | 0, G_ &= 67108863, Pe = Math.imul(pt, cX), Se = Math.imul(pt, MX), Se = Se + Math.imul(He, cX) | 0, ke = Math.imul(He, MX), Pe = Pe + Math.imul(nX, yX) | 0, Se = Se + Math.imul(nX, jX) | 0, Se = Se + Math.imul(Ye, yX) | 0, ke = ke + Math.imul(Ye, jX) | 0, Pe = Pe + Math.imul(Nn, vX) | 0, Se = Se + Math.imul(Nn, PX) | 0, Se = Se + Math.imul(SX, vX) | 0, ke = ke + Math.imul(SX, PX) | 0, Pe = Pe + Math.imul(w_, qe) | 0, Se = Se + Math.imul(w_, Qe) | 0, Se = Se + Math.imul(hX, qe) | 0, ke = ke + Math.imul(hX, Qe) | 0, Pe = Pe + Math.imul(an, Ie) | 0, Se = Se + Math.imul(an, nt) | 0, Se = Se + Math.imul(wX, Ie) | 0, ke = ke + Math.imul(wX, nt) | 0, Pe = Pe + Math.imul(It, xt) | 0, Se = Se + Math.imul(It, Jt) | 0, Se = Se + Math.imul(Er, xt) | 0, ke = ke + Math.imul(Er, Jt) | 0;
        var iX = (Ce + Pe | 0) + ((Se & 8191) << 13) | 0;
        Ce = (ke + (Se >>> 13) | 0) + (iX >>> 26) | 0, iX &= 67108863, Pe = Math.imul(pt, yX), Se = Math.imul(pt, jX), Se = Se + Math.imul(He, yX) | 0, ke = Math.imul(He, jX), Pe = Pe + Math.imul(nX, vX) | 0, Se = Se + Math.imul(nX, PX) | 0, Se = Se + Math.imul(Ye, vX) | 0, ke = ke + Math.imul(Ye, PX) | 0, Pe = Pe + Math.imul(Nn, qe) | 0, Se = Se + Math.imul(Nn, Qe) | 0, Se = Se + Math.imul(SX, qe) | 0, ke = ke + Math.imul(SX, Qe) | 0, Pe = Pe + Math.imul(w_, Ie) | 0, Se = Se + Math.imul(w_, nt) | 0, Se = Se + Math.imul(hX, Ie) | 0, ke = ke + Math.imul(hX, nt) | 0, Pe = Pe + Math.imul(an, xt) | 0, Se = Se + Math.imul(an, Jt) | 0, Se = Se + Math.imul(wX, xt) | 0, ke = ke + Math.imul(wX, Jt) | 0;
        var og = (Ce + Pe | 0) + ((Se & 8191) << 13) | 0;
        Ce = (ke + (Se >>> 13) | 0) + (og >>> 26) | 0, og &= 67108863, Pe = Math.imul(pt, vX), Se = Math.imul(pt, PX), Se = Se + Math.imul(He, vX) | 0, ke = Math.imul(He, PX), Pe = Pe + Math.imul(nX, qe) | 0, Se = Se + Math.imul(nX, Qe) | 0, Se = Se + Math.imul(Ye, qe) | 0, ke = ke + Math.imul(Ye, Qe) | 0, Pe = Pe + Math.imul(Nn, Ie) | 0, Se = Se + Math.imul(Nn, nt) | 0, Se = Se + Math.imul(SX, Ie) | 0, ke = ke + Math.imul(SX, nt) | 0, Pe = Pe + Math.imul(w_, xt) | 0, Se = Se + Math.imul(w_, Jt) | 0, Se = Se + Math.imul(hX, xt) | 0, ke = ke + Math.imul(hX, Jt) | 0;
        var eX = (Ce + Pe | 0) + ((Se & 8191) << 13) | 0;
        Ce = (ke + (Se >>> 13) | 0) + (eX >>> 26) | 0, eX &= 67108863, Pe = Math.imul(pt, qe), Se = Math.imul(pt, Qe), Se = Se + Math.imul(He, qe) | 0, ke = Math.imul(He, Qe), Pe = Pe + Math.imul(nX, Ie) | 0, Se = Se + Math.imul(nX, nt) | 0, Se = Se + Math.imul(Ye, Ie) | 0, ke = ke + Math.imul(Ye, nt) | 0, Pe = Pe + Math.imul(Nn, xt) | 0, Se = Se + Math.imul(Nn, Jt) | 0, Se = Se + Math.imul(SX, xt) | 0, ke = ke + Math.imul(SX, Jt) | 0;
        var tX = (Ce + Pe | 0) + ((Se & 8191) << 13) | 0;
        Ce = (ke + (Se >>> 13) | 0) + (tX >>> 26) | 0, tX &= 67108863, Pe = Math.imul(pt, Ie), Se = Math.imul(pt, nt), Se = Se + Math.imul(He, Ie) | 0, ke = Math.imul(He, nt), Pe = Pe + Math.imul(nX, xt) | 0, Se = Se + Math.imul(nX, Jt) | 0, Se = Se + Math.imul(Ye, xt) | 0, ke = ke + Math.imul(Ye, Jt) | 0;
        var An = (Ce + Pe | 0) + ((Se & 8191) << 13) | 0;
        Ce = (ke + (Se >>> 13) | 0) + (An >>> 26) | 0, An &= 67108863, Pe = Math.imul(pt, xt), Se = Math.imul(pt, Jt), Se = Se + Math.imul(He, xt) | 0, ke = Math.imul(He, Jt);
        var Gt = (Ce + Pe | 0) + ((Se & 8191) << 13) | 0;
        return Ce = (ke + (Se >>> 13) | 0) + (Gt >>> 26) | 0, Gt &= 67108863, Te[0] = Yt, Te[1] = _r, Te[2] = cn, Te[3] = _X, Te[4] = un, Te[5] = aX, Te[6] = uX, Te[7] = fX, Te[8] = bX, Te[9] = dX, Te[10] = mX, Te[11] = pX, Te[12] = G_, Te[13] = iX, Te[14] = og, Te[15] = eX, Te[16] = tX, Te[17] = An, Te[18] = Gt, Ce !== 0 && (Te[19] = Ce, fe.length++), fe;
      };
      Math.imul || (Ee = we);
      function Re(je, ze, fe) {
        fe.negative = ze.negative ^ je.negative, fe.length = je.length + ze.length;
        for (var de = 0, be = 0, Te = 0; Te < fe.length - 1; Te++) {
          var Ce = be;
          be = 0;
          for (var Pe = de & 67108863, Se = Math.min(Te, ze.length - 1), ke = Math.max(0, Te - je.length + 1); ke <= Se; ke++) {
            var ge = Te - ke, Ae = je.words[ge] | 0, Ge = ze.words[ke] | 0, Xe = Ae * Ge, $e = Xe & 67108863;
            Ce = Ce + (Xe / 67108864 | 0) | 0, $e = $e + Pe | 0, Pe = $e & 67108863, Ce = Ce + ($e >>> 26) | 0, be += Ce >>> 26, Ce &= 67108863;
          }
          fe.words[Te] = Pe, de = Ce, Ce = be;
        }
        return de !== 0 ? fe.words[Te] = de : fe.length--, fe.strip();
      }
      function Ue(je, ze, fe) {
        var de = new Me();
        return de.mulp(je, ze, fe);
      }
      ie.prototype.mulTo = function(je, ze) {
        var fe, de = this.length + je.length;
        return this.length === 10 && je.length === 10 ? fe = Ee(this, je, ze) : de < 63 ? fe = we(this, je, ze) : de < 1024 ? fe = Re(this, je, ze) : fe = Ue(this, je, ze), fe;
      };
      function Me(je, ze) {
        this.x = je, this.y = ze;
      }
      Me.prototype.makeRBT = function(je) {
        for (var ze = new Array(je), fe = ie.prototype._countBits(je) - 1, de = 0; de < je; de++)
          ze[de] = this.revBin(de, fe, je);
        return ze;
      }, Me.prototype.revBin = function(je, ze, fe) {
        if (je === 0 || je === fe - 1)
          return je;
        for (var de = 0, be = 0; be < ze; be++)
          de |= (je & 1) << ze - be - 1, je >>= 1;
        return de;
      }, Me.prototype.permute = function(je, ze, fe, de, be, Te) {
        for (var Ce = 0; Ce < Te; Ce++)
          de[Ce] = ze[je[Ce]], be[Ce] = fe[je[Ce]];
      }, Me.prototype.transform = function(je, ze, fe, de, be, Te) {
        this.permute(Te, je, ze, fe, de, be);
        for (var Ce = 1; Ce < be; Ce <<= 1)
          for (var Pe = Ce << 1, Se = Math.cos(2 * Math.PI / Pe), ke = Math.sin(2 * Math.PI / Pe), ge = 0; ge < be; ge += Pe)
            for (var Ae = Se, Ge = ke, Xe = 0; Xe < Ce; Xe++) {
              var $e = fe[ge + Xe], Ze = de[ge + Xe], ot = fe[ge + Xe + Ce], ct = de[ge + Xe + Ce], At = Ae * ot - Ge * ct;
              ct = Ae * ct + Ge * ot, ot = At, fe[ge + Xe] = $e + ot, de[ge + Xe] = Ze + ct, fe[ge + Xe + Ce] = $e - ot, de[ge + Xe + Ce] = Ze - ct, Xe !== Pe && (At = Se * Ae - ke * Ge, Ge = Se * Ge + ke * Ae, Ae = At);
            }
      }, Me.prototype.guessLen13b = function(je, ze) {
        var fe = Math.max(ze, je) | 1, de = fe & 1, be = 0;
        for (fe = fe / 2 | 0; fe; fe = fe >>> 1)
          be++;
        return 1 << be + 1 + de;
      }, Me.prototype.conjugate = function(je, ze, fe) {
        if (!(fe <= 1))
          for (var de = 0; de < fe / 2; de++) {
            var be = je[de];
            je[de] = je[fe - de - 1], je[fe - de - 1] = be, be = ze[de], ze[de] = -ze[fe - de - 1], ze[fe - de - 1] = -be;
          }
      }, Me.prototype.normalize13b = function(je, ze) {
        for (var fe = 0, de = 0; de < ze / 2; de++) {
          var be = Math.round(je[2 * de + 1] / ze) * 8192 + Math.round(je[2 * de] / ze) + fe;
          je[de] = be & 67108863, be < 67108864 ? fe = 0 : fe = be / 67108864 | 0;
        }
        return je;
      }, Me.prototype.convert13b = function(je, ze, fe, de) {
        for (var be = 0, Te = 0; Te < ze; Te++)
          be = be + (je[Te] | 0), fe[2 * Te] = be & 8191, be = be >>> 13, fe[2 * Te + 1] = be & 8191, be = be >>> 13;
        for (Te = 2 * ze; Te < de; ++Te)
          fe[Te] = 0;
        te(be === 0), te((be & -8192) === 0);
      }, Me.prototype.stub = function(je) {
        for (var ze = new Array(je), fe = 0; fe < je; fe++)
          ze[fe] = 0;
        return ze;
      }, Me.prototype.mulp = function(je, ze, fe) {
        var de = 2 * this.guessLen13b(je.length, ze.length), be = this.makeRBT(de), Te = this.stub(de), Ce = new Array(de), Pe = new Array(de), Se = new Array(de), ke = new Array(de), ge = new Array(de), Ae = new Array(de), Ge = fe.words;
        Ge.length = de, this.convert13b(je.words, je.length, Ce, de), this.convert13b(ze.words, ze.length, ke, de), this.transform(Ce, Te, Pe, Se, de, be), this.transform(ke, Te, ge, Ae, de, be);
        for (var Xe = 0; Xe < de; Xe++) {
          var $e = Pe[Xe] * ge[Xe] - Se[Xe] * Ae[Xe];
          Se[Xe] = Pe[Xe] * Ae[Xe] + Se[Xe] * ge[Xe], Pe[Xe] = $e;
        }
        return this.conjugate(Pe, Se, de), this.transform(Pe, Se, Ge, Te, de, be), this.conjugate(Ge, Te, de), this.normalize13b(Ge, de), fe.negative = je.negative ^ ze.negative, fe.length = je.length + ze.length, fe.strip();
      }, ie.prototype.mul = function(je) {
        var ze = new ie(null);
        return ze.words = new Array(this.length + je.length), this.mulTo(je, ze);
      }, ie.prototype.mulf = function(je) {
        var ze = new ie(null);
        return ze.words = new Array(this.length + je.length), Ue(this, je, ze);
      }, ie.prototype.imul = function(je) {
        return this.clone().mulTo(je, this);
      }, ie.prototype.imuln = function(je) {
        te(typeof je == "number"), te(je < 67108864);
        for (var ze = 0, fe = 0; fe < this.length; fe++) {
          var de = (this.words[fe] | 0) * je, be = (de & 67108863) + (ze & 67108863);
          ze >>= 26, ze += de / 67108864 | 0, ze += be >>> 26, this.words[fe] = be & 67108863;
        }
        return ze !== 0 && (this.words[fe] = ze, this.length++), this;
      }, ie.prototype.muln = function(je) {
        return this.clone().imuln(je);
      }, ie.prototype.sqr = function() {
        return this.mul(this);
      }, ie.prototype.isqr = function() {
        return this.imul(this.clone());
      }, ie.prototype.pow = function(je) {
        var ze = ye(je);
        if (ze.length === 0)
          return new ie(1);
        for (var fe = this, de = 0; de < ze.length && ze[de] === 0; de++, fe = fe.sqr())
          ;
        if (++de < ze.length)
          for (var be = fe.sqr(); de < ze.length; de++, be = be.sqr())
            ze[de] !== 0 && (fe = fe.mul(be));
        return fe;
      }, ie.prototype.iushln = function(je) {
        te(typeof je == "number" && je >= 0);
        var ze = je % 26, fe = (je - ze) / 26, de = 67108863 >>> 26 - ze << 26 - ze, be;
        if (ze !== 0) {
          var Te = 0;
          for (be = 0; be < this.length; be++) {
            var Ce = this.words[be] & de, Pe = (this.words[be] | 0) - Ce << ze;
            this.words[be] = Pe | Te, Te = Ce >>> 26 - ze;
          }
          Te && (this.words[be] = Te, this.length++);
        }
        if (fe !== 0) {
          for (be = this.length - 1; be >= 0; be--)
            this.words[be + fe] = this.words[be];
          for (be = 0; be < fe; be++)
            this.words[be] = 0;
          this.length += fe;
        }
        return this.strip();
      }, ie.prototype.ishln = function(je) {
        return te(this.negative === 0), this.iushln(je);
      }, ie.prototype.iushrn = function(je, ze, fe) {
        te(typeof je == "number" && je >= 0);
        var de;
        ze ? de = (ze - ze % 26) / 26 : de = 0;
        var be = je % 26, Te = Math.min((je - be) / 26, this.length), Ce = 67108863 ^ 67108863 >>> be << be, Pe = fe;
        if (de -= Te, de = Math.max(0, de), Pe) {
          for (var Se = 0; Se < Te; Se++)
            Pe.words[Se] = this.words[Se];
          Pe.length = Te;
        }
        if (Te !== 0)
          if (this.length > Te)
            for (this.length -= Te, Se = 0; Se < this.length; Se++)
              this.words[Se] = this.words[Se + Te];
          else
            this.words[0] = 0, this.length = 1;
        var ke = 0;
        for (Se = this.length - 1; Se >= 0 && (ke !== 0 || Se >= de); Se--) {
          var ge = this.words[Se] | 0;
          this.words[Se] = ke << 26 - be | ge >>> be, ke = ge & Ce;
        }
        return Pe && ke !== 0 && (Pe.words[Pe.length++] = ke), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
      }, ie.prototype.ishrn = function(je, ze, fe) {
        return te(this.negative === 0), this.iushrn(je, ze, fe);
      }, ie.prototype.shln = function(je) {
        return this.clone().ishln(je);
      }, ie.prototype.ushln = function(je) {
        return this.clone().iushln(je);
      }, ie.prototype.shrn = function(je) {
        return this.clone().ishrn(je);
      }, ie.prototype.ushrn = function(je) {
        return this.clone().iushrn(je);
      }, ie.prototype.testn = function(je) {
        te(typeof je == "number" && je >= 0);
        var ze = je % 26, fe = (je - ze) / 26, de = 1 << ze;
        if (this.length <= fe)
          return !1;
        var be = this.words[fe];
        return !!(be & de);
      }, ie.prototype.imaskn = function(je) {
        te(typeof je == "number" && je >= 0);
        var ze = je % 26, fe = (je - ze) / 26;
        if (te(this.negative === 0, "imaskn works only with positive numbers"), this.length <= fe)
          return this;
        if (ze !== 0 && fe++, this.length = Math.min(fe, this.length), ze !== 0) {
          var de = 67108863 ^ 67108863 >>> ze << ze;
          this.words[this.length - 1] &= de;
        }
        return this.strip();
      }, ie.prototype.maskn = function(je) {
        return this.clone().imaskn(je);
      }, ie.prototype.iaddn = function(je) {
        return te(typeof je == "number"), te(je < 67108864), je < 0 ? this.isubn(-je) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < je ? (this.words[0] = je - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(je), this.negative = 1, this) : this._iaddn(je);
      }, ie.prototype._iaddn = function(je) {
        this.words[0] += je;
        for (var ze = 0; ze < this.length && this.words[ze] >= 67108864; ze++)
          this.words[ze] -= 67108864, ze === this.length - 1 ? this.words[ze + 1] = 1 : this.words[ze + 1]++;
        return this.length = Math.max(this.length, ze + 1), this;
      }, ie.prototype.isubn = function(je) {
        if (te(typeof je == "number"), te(je < 67108864), je < 0)
          return this.iaddn(-je);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(je), this.negative = 1, this;
        if (this.words[0] -= je, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var ze = 0; ze < this.length && this.words[ze] < 0; ze++)
            this.words[ze] += 67108864, this.words[ze + 1] -= 1;
        return this.strip();
      }, ie.prototype.addn = function(je) {
        return this.clone().iaddn(je);
      }, ie.prototype.subn = function(je) {
        return this.clone().isubn(je);
      }, ie.prototype.iabs = function() {
        return this.negative = 0, this;
      }, ie.prototype.abs = function() {
        return this.clone().iabs();
      }, ie.prototype._ishlnsubmul = function(je, ze, fe) {
        var de = je.length + fe, be;
        this._expand(de);
        var Te, Ce = 0;
        for (be = 0; be < je.length; be++) {
          Te = (this.words[be + fe] | 0) + Ce;
          var Pe = (je.words[be] | 0) * ze;
          Te -= Pe & 67108863, Ce = (Te >> 26) - (Pe / 67108864 | 0), this.words[be + fe] = Te & 67108863;
        }
        for (; be < this.length - fe; be++)
          Te = (this.words[be + fe] | 0) + Ce, Ce = Te >> 26, this.words[be + fe] = Te & 67108863;
        if (Ce === 0)
          return this.strip();
        for (te(Ce === -1), Ce = 0, be = 0; be < this.length; be++)
          Te = -(this.words[be] | 0) + Ce, Ce = Te >> 26, this.words[be] = Te & 67108863;
        return this.negative = 1, this.strip();
      }, ie.prototype._wordDiv = function(je, ze) {
        var fe = this.length - je.length, de = this.clone(), be = je, Te = be.words[be.length - 1] | 0, Ce = this._countBits(Te);
        fe = 26 - Ce, fe !== 0 && (be = be.ushln(fe), de.iushln(fe), Te = be.words[be.length - 1] | 0);
        var Pe = de.length - be.length, Se;
        if (ze !== "mod") {
          Se = new ie(null), Se.length = Pe + 1, Se.words = new Array(Se.length);
          for (var ke = 0; ke < Se.length; ke++)
            Se.words[ke] = 0;
        }
        var ge = de.clone()._ishlnsubmul(be, 1, Pe);
        ge.negative === 0 && (de = ge, Se && (Se.words[Pe] = 1));
        for (var Ae = Pe - 1; Ae >= 0; Ae--) {
          var Ge = (de.words[be.length + Ae] | 0) * 67108864 + (de.words[be.length + Ae - 1] | 0);
          for (Ge = Math.min(Ge / Te | 0, 67108863), de._ishlnsubmul(be, Ge, Ae); de.negative !== 0; )
            Ge--, de.negative = 0, de._ishlnsubmul(be, 1, Ae), de.isZero() || (de.negative ^= 1);
          Se && (Se.words[Ae] = Ge);
        }
        return Se && Se.strip(), de.strip(), ze !== "div" && fe !== 0 && de.iushrn(fe), {
          div: Se || null,
          mod: de
        };
      }, ie.prototype.divmod = function(je, ze, fe) {
        if (te(!je.isZero()), this.isZero())
          return {
            div: new ie(0),
            mod: new ie(0)
          };
        var de, be, Te;
        return this.negative !== 0 && je.negative === 0 ? (Te = this.neg().divmod(je, ze), ze !== "mod" && (de = Te.div.neg()), ze !== "div" && (be = Te.mod.neg(), fe && be.negative !== 0 && be.iadd(je)), {
          div: de,
          mod: be
        }) : this.negative === 0 && je.negative !== 0 ? (Te = this.divmod(je.neg(), ze), ze !== "mod" && (de = Te.div.neg()), {
          div: de,
          mod: Te.mod
        }) : this.negative & je.negative ? (Te = this.neg().divmod(je.neg(), ze), ze !== "div" && (be = Te.mod.neg(), fe && be.negative !== 0 && be.isub(je)), {
          div: Te.div,
          mod: be
        }) : je.length > this.length || this.cmp(je) < 0 ? {
          div: new ie(0),
          mod: this
        } : je.length === 1 ? ze === "div" ? {
          div: this.divn(je.words[0]),
          mod: null
        } : ze === "mod" ? {
          div: null,
          mod: new ie(this.modn(je.words[0]))
        } : {
          div: this.divn(je.words[0]),
          mod: new ie(this.modn(je.words[0]))
        } : this._wordDiv(je, ze);
      }, ie.prototype.div = function(je) {
        return this.divmod(je, "div", !1).div;
      }, ie.prototype.mod = function(je) {
        return this.divmod(je, "mod", !1).mod;
      }, ie.prototype.umod = function(je) {
        return this.divmod(je, "mod", !0).mod;
      }, ie.prototype.divRound = function(je) {
        var ze = this.divmod(je);
        if (ze.mod.isZero())
          return ze.div;
        var fe = ze.div.negative !== 0 ? ze.mod.isub(je) : ze.mod, de = je.ushrn(1), be = je.andln(1), Te = fe.cmp(de);
        return Te < 0 || be === 1 && Te === 0 ? ze.div : ze.div.negative !== 0 ? ze.div.isubn(1) : ze.div.iaddn(1);
      }, ie.prototype.modn = function(je) {
        te(je <= 67108863);
        for (var ze = (1 << 26) % je, fe = 0, de = this.length - 1; de >= 0; de--)
          fe = (ze * fe + (this.words[de] | 0)) % je;
        return fe;
      }, ie.prototype.idivn = function(je) {
        te(je <= 67108863);
        for (var ze = 0, fe = this.length - 1; fe >= 0; fe--) {
          var de = (this.words[fe] | 0) + ze * 67108864;
          this.words[fe] = de / je | 0, ze = de % je;
        }
        return this.strip();
      }, ie.prototype.divn = function(je) {
        return this.clone().idivn(je);
      }, ie.prototype.egcd = function(je) {
        te(je.negative === 0), te(!je.isZero());
        var ze = this, fe = je.clone();
        ze.negative !== 0 ? ze = ze.umod(je) : ze = ze.clone();
        for (var de = new ie(1), be = new ie(0), Te = new ie(0), Ce = new ie(1), Pe = 0; ze.isEven() && fe.isEven(); )
          ze.iushrn(1), fe.iushrn(1), ++Pe;
        for (var Se = fe.clone(), ke = ze.clone(); !ze.isZero(); ) {
          for (var ge = 0, Ae = 1; !(ze.words[0] & Ae) && ge < 26; ++ge, Ae <<= 1)
            ;
          if (ge > 0)
            for (ze.iushrn(ge); ge-- > 0; )
              (de.isOdd() || be.isOdd()) && (de.iadd(Se), be.isub(ke)), de.iushrn(1), be.iushrn(1);
          for (var Ge = 0, Xe = 1; !(fe.words[0] & Xe) && Ge < 26; ++Ge, Xe <<= 1)
            ;
          if (Ge > 0)
            for (fe.iushrn(Ge); Ge-- > 0; )
              (Te.isOdd() || Ce.isOdd()) && (Te.iadd(Se), Ce.isub(ke)), Te.iushrn(1), Ce.iushrn(1);
          ze.cmp(fe) >= 0 ? (ze.isub(fe), de.isub(Te), be.isub(Ce)) : (fe.isub(ze), Te.isub(de), Ce.isub(be));
        }
        return {
          a: Te,
          b: Ce,
          gcd: fe.iushln(Pe)
        };
      }, ie.prototype._invmp = function(je) {
        te(je.negative === 0), te(!je.isZero());
        var ze = this, fe = je.clone();
        ze.negative !== 0 ? ze = ze.umod(je) : ze = ze.clone();
        for (var de = new ie(1), be = new ie(0), Te = fe.clone(); ze.cmpn(1) > 0 && fe.cmpn(1) > 0; ) {
          for (var Ce = 0, Pe = 1; !(ze.words[0] & Pe) && Ce < 26; ++Ce, Pe <<= 1)
            ;
          if (Ce > 0)
            for (ze.iushrn(Ce); Ce-- > 0; )
              de.isOdd() && de.iadd(Te), de.iushrn(1);
          for (var Se = 0, ke = 1; !(fe.words[0] & ke) && Se < 26; ++Se, ke <<= 1)
            ;
          if (Se > 0)
            for (fe.iushrn(Se); Se-- > 0; )
              be.isOdd() && be.iadd(Te), be.iushrn(1);
          ze.cmp(fe) >= 0 ? (ze.isub(fe), de.isub(be)) : (fe.isub(ze), be.isub(de));
        }
        var ge;
        return ze.cmpn(1) === 0 ? ge = de : ge = be, ge.cmpn(0) < 0 && ge.iadd(je), ge;
      }, ie.prototype.gcd = function(je) {
        if (this.isZero())
          return je.abs();
        if (je.isZero())
          return this.abs();
        var ze = this.clone(), fe = je.clone();
        ze.negative = 0, fe.negative = 0;
        for (var de = 0; ze.isEven() && fe.isEven(); de++)
          ze.iushrn(1), fe.iushrn(1);
        do {
          for (; ze.isEven(); )
            ze.iushrn(1);
          for (; fe.isEven(); )
            fe.iushrn(1);
          var be = ze.cmp(fe);
          if (be < 0) {
            var Te = ze;
            ze = fe, fe = Te;
          } else if (be === 0 || fe.cmpn(1) === 0)
            break;
          ze.isub(fe);
        } while (!0);
        return fe.iushln(de);
      }, ie.prototype.invm = function(je) {
        return this.egcd(je).a.umod(je);
      }, ie.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, ie.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, ie.prototype.andln = function(je) {
        return this.words[0] & je;
      }, ie.prototype.bincn = function(je) {
        te(typeof je == "number");
        var ze = je % 26, fe = (je - ze) / 26, de = 1 << ze;
        if (this.length <= fe)
          return this._expand(fe + 1), this.words[fe] |= de, this;
        for (var be = de, Te = fe; be !== 0 && Te < this.length; Te++) {
          var Ce = this.words[Te] | 0;
          Ce += be, be = Ce >>> 26, Ce &= 67108863, this.words[Te] = Ce;
        }
        return be !== 0 && (this.words[Te] = be, this.length++), this;
      }, ie.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, ie.prototype.cmpn = function(je) {
        var ze = je < 0;
        if (this.negative !== 0 && !ze)
          return -1;
        if (this.negative === 0 && ze)
          return 1;
        this.strip();
        var fe;
        if (this.length > 1)
          fe = 1;
        else {
          ze && (je = -je), te(je <= 67108863, "Number is too big");
          var de = this.words[0] | 0;
          fe = de === je ? 0 : de < je ? -1 : 1;
        }
        return this.negative !== 0 ? -fe | 0 : fe;
      }, ie.prototype.cmp = function(je) {
        if (this.negative !== 0 && je.negative === 0)
          return -1;
        if (this.negative === 0 && je.negative !== 0)
          return 1;
        var ze = this.ucmp(je);
        return this.negative !== 0 ? -ze | 0 : ze;
      }, ie.prototype.ucmp = function(je) {
        if (this.length > je.length)
          return 1;
        if (this.length < je.length)
          return -1;
        for (var ze = 0, fe = this.length - 1; fe >= 0; fe--) {
          var de = this.words[fe] | 0, be = je.words[fe] | 0;
          if (de !== be) {
            de < be ? ze = -1 : de > be && (ze = 1);
            break;
          }
        }
        return ze;
      }, ie.prototype.gtn = function(je) {
        return this.cmpn(je) === 1;
      }, ie.prototype.gt = function(je) {
        return this.cmp(je) === 1;
      }, ie.prototype.gten = function(je) {
        return this.cmpn(je) >= 0;
      }, ie.prototype.gte = function(je) {
        return this.cmp(je) >= 0;
      }, ie.prototype.ltn = function(je) {
        return this.cmpn(je) === -1;
      }, ie.prototype.lt = function(je) {
        return this.cmp(je) === -1;
      }, ie.prototype.lten = function(je) {
        return this.cmpn(je) <= 0;
      }, ie.prototype.lte = function(je) {
        return this.cmp(je) <= 0;
      }, ie.prototype.eqn = function(je) {
        return this.cmpn(je) === 0;
      }, ie.prototype.eq = function(je) {
        return this.cmp(je) === 0;
      }, ie.red = function(je) {
        return new _t(je);
      }, ie.prototype.toRed = function(je) {
        return te(!this.red, "Already a number in reduction context"), te(this.negative === 0, "red works only with positives"), je.convertTo(this)._forceRed(je);
      }, ie.prototype.fromRed = function() {
        return te(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, ie.prototype._forceRed = function(je) {
        return this.red = je, this;
      }, ie.prototype.forceRed = function(je) {
        return te(!this.red, "Already a number in reduction context"), this._forceRed(je);
      }, ie.prototype.redAdd = function(je) {
        return te(this.red, "redAdd works only with red numbers"), this.red.add(this, je);
      }, ie.prototype.redIAdd = function(je) {
        return te(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, je);
      }, ie.prototype.redSub = function(je) {
        return te(this.red, "redSub works only with red numbers"), this.red.sub(this, je);
      }, ie.prototype.redISub = function(je) {
        return te(this.red, "redISub works only with red numbers"), this.red.isub(this, je);
      }, ie.prototype.redShl = function(je) {
        return te(this.red, "redShl works only with red numbers"), this.red.shl(this, je);
      }, ie.prototype.redMul = function(je) {
        return te(this.red, "redMul works only with red numbers"), this.red._verify2(this, je), this.red.mul(this, je);
      }, ie.prototype.redIMul = function(je) {
        return te(this.red, "redMul works only with red numbers"), this.red._verify2(this, je), this.red.imul(this, je);
      }, ie.prototype.redSqr = function() {
        return te(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, ie.prototype.redISqr = function() {
        return te(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, ie.prototype.redSqrt = function() {
        return te(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, ie.prototype.redInvm = function() {
        return te(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, ie.prototype.redNeg = function() {
        return te(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, ie.prototype.redPow = function(je) {
        return te(this.red && !je.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, je);
      };
      var De = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function Fe(je, ze) {
        this.name = je, this.p = new ie(ze, 16), this.n = this.p.bitLength(), this.k = new ie(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      Fe.prototype._tmp = function() {
        var je = new ie(null);
        return je.words = new Array(Math.ceil(this.n / 13)), je;
      }, Fe.prototype.ireduce = function(je) {
        var ze = je, fe;
        do
          this.split(ze, this.tmp), ze = this.imulK(ze), ze = ze.iadd(this.tmp), fe = ze.bitLength();
        while (fe > this.n);
        var de = fe < this.n ? -1 : ze.ucmp(this.p);
        return de === 0 ? (ze.words[0] = 0, ze.length = 1) : de > 0 ? ze.isub(this.p) : ze.strip !== void 0 ? ze.strip() : ze._strip(), ze;
      }, Fe.prototype.split = function(je, ze) {
        je.iushrn(this.n, 0, ze);
      }, Fe.prototype.imulK = function(je) {
        return je.imul(this.k);
      };
      function Ke() {
        Fe.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      ne(Ke, Fe), Ke.prototype.split = function(je, ze) {
        for (var fe = 4194303, de = Math.min(je.length, 9), be = 0; be < de; be++)
          ze.words[be] = je.words[be];
        if (ze.length = de, je.length <= 9) {
          je.words[0] = 0, je.length = 1;
          return;
        }
        var Te = je.words[9];
        for (ze.words[ze.length++] = Te & fe, be = 10; be < je.length; be++) {
          var Ce = je.words[be] | 0;
          je.words[be - 10] = (Ce & fe) << 4 | Te >>> 22, Te = Ce;
        }
        Te >>>= 22, je.words[be - 10] = Te, Te === 0 && je.length > 10 ? je.length -= 10 : je.length -= 9;
      }, Ke.prototype.imulK = function(je) {
        je.words[je.length] = 0, je.words[je.length + 1] = 0, je.length += 2;
        for (var ze = 0, fe = 0; fe < je.length; fe++) {
          var de = je.words[fe] | 0;
          ze += de * 977, je.words[fe] = ze & 67108863, ze = de * 64 + (ze / 67108864 | 0);
        }
        return je.words[je.length - 1] === 0 && (je.length--, je.words[je.length - 1] === 0 && je.length--), je;
      };
      function tt() {
        Fe.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      ne(tt, Fe);
      function rt() {
        Fe.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      ne(rt, Fe);
      function it() {
        Fe.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      ne(it, Fe), it.prototype.imulK = function(je) {
        for (var ze = 0, fe = 0; fe < je.length; fe++) {
          var de = (je.words[fe] | 0) * 19 + ze, be = de & 67108863;
          de >>>= 26, je.words[fe] = be, ze = de;
        }
        return ze !== 0 && (je.words[je.length++] = ze), je;
      }, ie._prime = function(je) {
        if (De[je])
          return De[je];
        var ze;
        if (je === "k256")
          ze = new Ke();
        else if (je === "p224")
          ze = new tt();
        else if (je === "p192")
          ze = new rt();
        else if (je === "p25519")
          ze = new it();
        else
          throw new Error("Unknown prime " + je);
        return De[je] = ze, ze;
      };
      function _t(je) {
        if (typeof je == "string") {
          var ze = ie._prime(je);
          this.m = ze.p, this.prime = ze;
        } else
          te(je.gtn(1), "modulus must be greater than 1"), this.m = je, this.prime = null;
      }
      _t.prototype._verify1 = function(je) {
        te(je.negative === 0, "red works only with positives"), te(je.red, "red works only with red numbers");
      }, _t.prototype._verify2 = function(je, ze) {
        te((je.negative | ze.negative) === 0, "red works only with positives"), te(
          je.red && je.red === ze.red,
          "red works only with red numbers"
        );
      }, _t.prototype.imod = function(je) {
        return this.prime ? this.prime.ireduce(je)._forceRed(this) : je.umod(this.m)._forceRed(this);
      }, _t.prototype.neg = function(je) {
        return je.isZero() ? je.clone() : this.m.sub(je)._forceRed(this);
      }, _t.prototype.add = function(je, ze) {
        this._verify2(je, ze);
        var fe = je.add(ze);
        return fe.cmp(this.m) >= 0 && fe.isub(this.m), fe._forceRed(this);
      }, _t.prototype.iadd = function(je, ze) {
        this._verify2(je, ze);
        var fe = je.iadd(ze);
        return fe.cmp(this.m) >= 0 && fe.isub(this.m), fe;
      }, _t.prototype.sub = function(je, ze) {
        this._verify2(je, ze);
        var fe = je.sub(ze);
        return fe.cmpn(0) < 0 && fe.iadd(this.m), fe._forceRed(this);
      }, _t.prototype.isub = function(je, ze) {
        this._verify2(je, ze);
        var fe = je.isub(ze);
        return fe.cmpn(0) < 0 && fe.iadd(this.m), fe;
      }, _t.prototype.shl = function(je, ze) {
        return this._verify1(je), this.imod(je.ushln(ze));
      }, _t.prototype.imul = function(je, ze) {
        return this._verify2(je, ze), this.imod(je.imul(ze));
      }, _t.prototype.mul = function(je, ze) {
        return this._verify2(je, ze), this.imod(je.mul(ze));
      }, _t.prototype.isqr = function(je) {
        return this.imul(je, je.clone());
      }, _t.prototype.sqr = function(je) {
        return this.mul(je, je);
      }, _t.prototype.sqrt = function(je) {
        if (je.isZero())
          return je.clone();
        var ze = this.m.andln(3);
        if (te(ze % 2 === 1), ze === 3) {
          var fe = this.m.add(new ie(1)).iushrn(2);
          return this.pow(je, fe);
        }
        for (var de = this.m.subn(1), be = 0; !de.isZero() && de.andln(1) === 0; )
          be++, de.iushrn(1);
        te(!de.isZero());
        var Te = new ie(1).toRed(this), Ce = Te.redNeg(), Pe = this.m.subn(1).iushrn(1), Se = this.m.bitLength();
        for (Se = new ie(2 * Se * Se).toRed(this); this.pow(Se, Pe).cmp(Ce) !== 0; )
          Se.redIAdd(Ce);
        for (var ke = this.pow(Se, de), ge = this.pow(je, de.addn(1).iushrn(1)), Ae = this.pow(je, de), Ge = be; Ae.cmp(Te) !== 0; ) {
          for (var Xe = Ae, $e = 0; Xe.cmp(Te) !== 0; $e++)
            Xe = Xe.redSqr();
          te($e < Ge);
          var Ze = this.pow(ke, new ie(1).iushln(Ge - $e - 1));
          ge = ge.redMul(Ze), ke = Ze.redSqr(), Ae = Ae.redMul(ke), Ge = $e;
        }
        return ge;
      }, _t.prototype.invm = function(je) {
        var ze = je._invmp(this.m);
        return ze.negative !== 0 ? (ze.negative = 0, this.imod(ze).redNeg()) : this.imod(ze);
      }, _t.prototype.pow = function(je, ze) {
        if (ze.isZero())
          return new ie(1).toRed(this);
        if (ze.cmpn(1) === 0)
          return je.clone();
        var fe = 4, de = new Array(1 << fe);
        de[0] = new ie(1).toRed(this), de[1] = je;
        for (var be = 2; be < de.length; be++)
          de[be] = this.mul(de[be - 1], je);
        var Te = de[0], Ce = 0, Pe = 0, Se = ze.bitLength() % 26;
        for (Se === 0 && (Se = 26), be = ze.length - 1; be >= 0; be--) {
          for (var ke = ze.words[be], ge = Se - 1; ge >= 0; ge--) {
            var Ae = ke >> ge & 1;
            if (Te !== de[0] && (Te = this.sqr(Te)), Ae === 0 && Ce === 0) {
              Pe = 0;
              continue;
            }
            Ce <<= 1, Ce |= Ae, Pe++, !(Pe !== fe && (be !== 0 || ge !== 0)) && (Te = this.mul(Te, de[Ce]), Pe = 0, Ce = 0);
          }
          Se = 26;
        }
        return Te;
      }, _t.prototype.convertTo = function(je) {
        var ze = je.umod(this.m);
        return ze === je ? ze.clone() : ze;
      }, _t.prototype.convertFrom = function(je) {
        var ze = je.clone();
        return ze.red = null, ze;
      }, ie.mont = function(je) {
        return new Dt(je);
      };
      function Dt(je) {
        _t.call(this, je), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new ie(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      ne(Dt, _t), Dt.prototype.convertTo = function(je) {
        return this.imod(je.ushln(this.shift));
      }, Dt.prototype.convertFrom = function(je) {
        var ze = this.imod(je.mul(this.rinv));
        return ze.red = null, ze;
      }, Dt.prototype.imul = function(je, ze) {
        if (je.isZero() || ze.isZero())
          return je.words[0] = 0, je.length = 1, je;
        var fe = je.imul(ze), de = fe.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), be = fe.isub(de).iushrn(this.shift), Te = be;
        return be.cmp(this.m) >= 0 ? Te = be.isub(this.m) : be.cmpn(0) < 0 && (Te = be.iadd(this.m)), Te._forceRed(this);
      }, Dt.prototype.mul = function(je, ze) {
        if (je.isZero() || ze.isZero())
          return new ie(0)._forceRed(this);
        var fe = je.mul(ze), de = fe.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), be = fe.isub(de).iushrn(this.shift), Te = be;
        return be.cmp(this.m) >= 0 ? Te = be.isub(this.m) : be.cmpn(0) < 0 && (Te = be.iadd(this.m)), Te._forceRed(this);
      }, Dt.prototype.invm = function(je) {
        var ze = this.imod(je._invmp(this.m).mul(this.r2));
        return ze._forceRed(this);
      };
    })(Y, commonjsGlobal);
  }(bn$1)), bn$1.exports;
}
var brorand = { exports: {} }, hasRequiredBrorand;
function requireBrorand() {
  if (hasRequiredBrorand)
    return brorand.exports;
  hasRequiredBrorand = 1;
  var Y;
  brorand.exports = function(te) {
    return Y || (Y = new X(null)), Y.generate(te);
  };
  function X(te) {
    this.rand = te;
  }
  if (brorand.exports.Rand = X, X.prototype.generate = function(te) {
    return this._rand(te);
  }, X.prototype._rand = function(te) {
    if (this.rand.getBytes)
      return this.rand.getBytes(te);
    for (var ne = new Uint8Array(te), ie = 0; ie < ne.length; ie++)
      ne[ie] = this.rand.getByte();
    return ne;
  }, typeof self == "object")
    self.crypto && self.crypto.getRandomValues ? X.prototype._rand = function(te) {
      var ne = new Uint8Array(te);
      return self.crypto.getRandomValues(ne), ne;
    } : self.msCrypto && self.msCrypto.getRandomValues ? X.prototype._rand = function(te) {
      var ne = new Uint8Array(te);
      return self.msCrypto.getRandomValues(ne), ne;
    } : typeof window == "object" && (X.prototype._rand = function() {
      throw new Error("Not implemented yet");
    });
  else
    try {
      var ee = requireCryptoBrowserify();
      if (typeof ee.randomBytes != "function")
        throw new Error("Not supported");
      X.prototype._rand = function(te) {
        return ee.randomBytes(te);
      };
    } catch {
    }
  return brorand.exports;
}
var mr, hasRequiredMr;
function requireMr() {
  if (hasRequiredMr)
    return mr;
  hasRequiredMr = 1;
  var Y = requireBn(), X = requireBrorand();
  function ee(te) {
    this.rand = te || new X.Rand();
  }
  return mr = ee, ee.create = function(te) {
    return new ee(te);
  }, ee.prototype._randbelow = function(te) {
    var ne = te.bitLength(), ie = Math.ceil(ne / 8);
    do
      var oe = new Y(this.rand.generate(ie));
    while (oe.cmp(te) >= 0);
    return oe;
  }, ee.prototype._randrange = function(te, ne) {
    var ie = ne.sub(te);
    return te.add(this._randbelow(ie));
  }, ee.prototype.test = function(te, ne, ie) {
    var oe = te.bitLength(), se = Y.mont(te), ae = new Y(1).toRed(se);
    ne || (ne = Math.max(1, oe / 48 | 0));
    for (var ue = te.subn(1), le = 0; !ue.testn(le); le++)
      ;
    for (var he = te.shrn(le), me = ue.toRed(se), ye = !0; ne > 0; ne--) {
      var we = this._randrange(new Y(2), ue);
      ie && ie(we);
      var Ee = we.toRed(se).redPow(he);
      if (!(Ee.cmp(ae) === 0 || Ee.cmp(me) === 0)) {
        for (var Re = 1; Re < le; Re++) {
          if (Ee = Ee.redSqr(), Ee.cmp(ae) === 0)
            return !1;
          if (Ee.cmp(me) === 0)
            break;
        }
        if (Re === le)
          return !1;
      }
    }
    return ye;
  }, ee.prototype.getDivisor = function(te, ne) {
    var ie = te.bitLength(), oe = Y.mont(te), se = new Y(1).toRed(oe);
    ne || (ne = Math.max(1, ie / 48 | 0));
    for (var ae = te.subn(1), ue = 0; !ae.testn(ue); ue++)
      ;
    for (var le = te.shrn(ue), he = ae.toRed(oe); ne > 0; ne--) {
      var me = this._randrange(new Y(2), ae), ye = te.gcd(me);
      if (ye.cmpn(1) !== 0)
        return ye;
      var we = me.toRed(oe).redPow(le);
      if (!(we.cmp(se) === 0 || we.cmp(he) === 0)) {
        for (var Ee = 1; Ee < ue; Ee++) {
          if (we = we.redSqr(), we.cmp(se) === 0)
            return we.fromRed().subn(1).gcd(te);
          if (we.cmp(he) === 0)
            break;
        }
        if (Ee === ue)
          return we = we.redSqr(), we.fromRed().subn(1).gcd(te);
      }
    }
    return !1;
  }, mr;
}
var generatePrime, hasRequiredGeneratePrime;
function requireGeneratePrime() {
  if (hasRequiredGeneratePrime)
    return generatePrime;
  hasRequiredGeneratePrime = 1;
  var Y = requireBrowser$9();
  generatePrime = Re, Re.simpleSieve = we, Re.fermatTest = Ee;
  var X = requireBn(), ee = new X(24), te = requireMr(), ne = new te(), ie = new X(1), oe = new X(2), se = new X(5);
  new X(16), new X(8);
  var ae = new X(10), ue = new X(3);
  new X(7);
  var le = new X(11), he = new X(4);
  new X(12);
  var me = null;
  function ye() {
    if (me !== null)
      return me;
    var Ue = 1048576, Me = [];
    Me[0] = 2;
    for (var De = 1, Fe = 3; Fe < Ue; Fe += 2) {
      for (var Ke = Math.ceil(Math.sqrt(Fe)), tt = 0; tt < De && Me[tt] <= Ke && Fe % Me[tt] !== 0; tt++)
        ;
      De !== tt && Me[tt] <= Ke || (Me[De++] = Fe);
    }
    return me = Me, Me;
  }
  function we(Ue) {
    for (var Me = ye(), De = 0; De < Me.length; De++)
      if (Ue.modn(Me[De]) === 0)
        return Ue.cmpn(Me[De]) === 0;
    return !0;
  }
  function Ee(Ue) {
    var Me = X.mont(Ue);
    return oe.toRed(Me).redPow(Ue.subn(1)).fromRed().cmpn(1) === 0;
  }
  function Re(Ue, Me) {
    if (Ue < 16)
      return Me === 2 || Me === 5 ? new X([140, 123]) : new X([140, 39]);
    Me = new X(Me);
    for (var De, Fe; ; ) {
      for (De = new X(Y(Math.ceil(Ue / 8))); De.bitLength() > Ue; )
        De.ishrn(1);
      if (De.isEven() && De.iadd(ie), De.testn(1) || De.iadd(oe), Me.cmp(oe)) {
        if (!Me.cmp(se))
          for (; De.mod(ae).cmp(ue); )
            De.iadd(he);
      } else
        for (; De.mod(ee).cmp(le); )
          De.iadd(he);
      if (Fe = De.shrn(1), we(Fe) && we(De) && Ee(Fe) && Ee(De) && ne.test(Fe) && ne.test(De))
        return De;
    }
  }
  return generatePrime;
}
const modp1 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff"
}, modp2 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff"
}, modp5 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff"
}, modp14 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff"
}, modp15 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff"
}, modp16 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff"
}, modp17 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff"
}, modp18 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff"
}, require$$1$2 = {
  modp1,
  modp2,
  modp5,
  modp14,
  modp15,
  modp16,
  modp17,
  modp18
};
var dh, hasRequiredDh;
function requireDh() {
  if (hasRequiredDh)
    return dh;
  hasRequiredDh = 1;
  var Y = requireBn(), X = requireMr(), ee = new X(), te = new Y(24), ne = new Y(11), ie = new Y(10), oe = new Y(3), se = new Y(7), ae = requireGeneratePrime(), ue = requireBrowser$9();
  dh = we;
  function le(Re, Ue) {
    return Ue = Ue || "utf8", Buffer$e.isBuffer(Re) || (Re = new Buffer$e(Re, Ue)), this._pub = new Y(Re), this;
  }
  function he(Re, Ue) {
    return Ue = Ue || "utf8", Buffer$e.isBuffer(Re) || (Re = new Buffer$e(Re, Ue)), this._priv = new Y(Re), this;
  }
  var me = {};
  function ye(Re, Ue) {
    var Me = Ue.toString("hex"), De = [Me, Re.toString(16)].join("_");
    if (De in me)
      return me[De];
    var Fe = 0;
    if (Re.isEven() || !ae.simpleSieve || !ae.fermatTest(Re) || !ee.test(Re))
      return Fe += 1, Me === "02" || Me === "05" ? Fe += 8 : Fe += 4, me[De] = Fe, Fe;
    ee.test(Re.shrn(1)) || (Fe += 2);
    var Ke;
    switch (Me) {
      case "02":
        Re.mod(te).cmp(ne) && (Fe += 8);
        break;
      case "05":
        Ke = Re.mod(ie), Ke.cmp(oe) && Ke.cmp(se) && (Fe += 8);
        break;
      default:
        Fe += 4;
    }
    return me[De] = Fe, Fe;
  }
  function we(Re, Ue, Me) {
    this.setGenerator(Ue), this.__prime = new Y(Re), this._prime = Y.mont(this.__prime), this._primeLen = Re.length, this._pub = void 0, this._priv = void 0, this._primeCode = void 0, Me ? (this.setPublicKey = le, this.setPrivateKey = he) : this._primeCode = 8;
  }
  Object.defineProperty(we.prototype, "verifyError", {
    enumerable: !0,
    get: function() {
      return typeof this._primeCode != "number" && (this._primeCode = ye(this.__prime, this.__gen)), this._primeCode;
    }
  }), we.prototype.generateKeys = function() {
    return this._priv || (this._priv = new Y(ue(this._primeLen))), this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed(), this.getPublicKey();
  }, we.prototype.computeSecret = function(Re) {
    Re = new Y(Re), Re = Re.toRed(this._prime);
    var Ue = Re.redPow(this._priv).fromRed(), Me = new Buffer$e(Ue.toArray()), De = this.getPrime();
    if (Me.length < De.length) {
      var Fe = new Buffer$e(De.length - Me.length);
      Fe.fill(0), Me = Buffer$e.concat([Fe, Me]);
    }
    return Me;
  }, we.prototype.getPublicKey = function(Re) {
    return Ee(this._pub, Re);
  }, we.prototype.getPrivateKey = function(Re) {
    return Ee(this._priv, Re);
  }, we.prototype.getPrime = function(Re) {
    return Ee(this.__prime, Re);
  }, we.prototype.getGenerator = function(Re) {
    return Ee(this._gen, Re);
  }, we.prototype.setGenerator = function(Re, Ue) {
    return Ue = Ue || "utf8", Buffer$e.isBuffer(Re) || (Re = new Buffer$e(Re, Ue)), this.__gen = Re, this._gen = new Y(Re), this;
  };
  function Ee(Re, Ue) {
    var Me = new Buffer$e(Re.toArray());
    return Ue ? Me.toString(Ue) : Me;
  }
  return dh;
}
var hasRequiredBrowser$4;
function requireBrowser$4() {
  if (hasRequiredBrowser$4)
    return browser$6;
  hasRequiredBrowser$4 = 1;
  var Y = requireGeneratePrime(), X = require$$1$2, ee = requireDh();
  function te(oe) {
    var se = new Buffer$e(X[oe].prime, "hex"), ae = new Buffer$e(X[oe].gen, "hex");
    return new ee(se, ae);
  }
  var ne = {
    binary: !0,
    hex: !0,
    base64: !0
  };
  function ie(oe, se, ae, ue) {
    return Buffer$e.isBuffer(se) || ne[se] === void 0 ? ie(oe, "binary", se, ae) : (se = se || "binary", ue = ue || "binary", ae = ae || new Buffer$e([2]), Buffer$e.isBuffer(ae) || (ae = new Buffer$e(ae, ue)), typeof oe == "number" ? new ee(Y(oe, ae), ae, !0) : (Buffer$e.isBuffer(oe) || (oe = new Buffer$e(oe, se)), new ee(oe, ae, !0)));
  }
  return browser$6.DiffieHellmanGroup = browser$6.createDiffieHellmanGroup = browser$6.getDiffieHellman = te, browser$6.createDiffieHellman = browser$6.DiffieHellman = ie, browser$6;
}
var sign$1 = { exports: {} }, bn = { exports: {} };
(function(Y) {
  (function(X, ee) {
    function te(fe, de) {
      if (!fe)
        throw new Error(de || "Assertion failed");
    }
    function ne(fe, de) {
      fe.super_ = de;
      var be = function() {
      };
      be.prototype = de.prototype, fe.prototype = new be(), fe.prototype.constructor = fe;
    }
    function ie(fe, de, be) {
      if (ie.isBN(fe))
        return fe;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, fe !== null && ((de === "le" || de === "be") && (be = de, de = 10), this._init(fe || 0, de || 10, be || "be"));
    }
    typeof X == "object" ? X.exports = ie : ee.BN = ie, ie.BN = ie, ie.wordSize = 26;
    var oe;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? oe = window.Buffer : oe = require$$0$3.Buffer;
    } catch {
    }
    ie.isBN = function(fe) {
      return fe instanceof ie ? !0 : fe !== null && typeof fe == "object" && fe.constructor.wordSize === ie.wordSize && Array.isArray(fe.words);
    }, ie.max = function(fe, de) {
      return fe.cmp(de) > 0 ? fe : de;
    }, ie.min = function(fe, de) {
      return fe.cmp(de) < 0 ? fe : de;
    }, ie.prototype._init = function(fe, de, be) {
      if (typeof fe == "number")
        return this._initNumber(fe, de, be);
      if (typeof fe == "object")
        return this._initArray(fe, de, be);
      de === "hex" && (de = 16), te(de === (de | 0) && de >= 2 && de <= 36), fe = fe.toString().replace(/\s+/g, "");
      var Te = 0;
      fe[0] === "-" && (Te++, this.negative = 1), Te < fe.length && (de === 16 ? this._parseHex(fe, Te, be) : (this._parseBase(fe, de, Te), be === "le" && this._initArray(this.toArray(), de, be)));
    }, ie.prototype._initNumber = function(fe, de, be) {
      fe < 0 && (this.negative = 1, fe = -fe), fe < 67108864 ? (this.words = [fe & 67108863], this.length = 1) : fe < 4503599627370496 ? (this.words = [
        fe & 67108863,
        fe / 67108864 & 67108863
      ], this.length = 2) : (te(fe < 9007199254740992), this.words = [
        fe & 67108863,
        fe / 67108864 & 67108863,
        1
      ], this.length = 3), be === "le" && this._initArray(this.toArray(), de, be);
    }, ie.prototype._initArray = function(fe, de, be) {
      if (te(typeof fe.length == "number"), fe.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(fe.length / 3), this.words = new Array(this.length);
      for (var Te = 0; Te < this.length; Te++)
        this.words[Te] = 0;
      var Ce, Pe, Se = 0;
      if (be === "be")
        for (Te = fe.length - 1, Ce = 0; Te >= 0; Te -= 3)
          Pe = fe[Te] | fe[Te - 1] << 8 | fe[Te - 2] << 16, this.words[Ce] |= Pe << Se & 67108863, this.words[Ce + 1] = Pe >>> 26 - Se & 67108863, Se += 24, Se >= 26 && (Se -= 26, Ce++);
      else if (be === "le")
        for (Te = 0, Ce = 0; Te < fe.length; Te += 3)
          Pe = fe[Te] | fe[Te + 1] << 8 | fe[Te + 2] << 16, this.words[Ce] |= Pe << Se & 67108863, this.words[Ce + 1] = Pe >>> 26 - Se & 67108863, Se += 24, Se >= 26 && (Se -= 26, Ce++);
      return this._strip();
    };
    function se(fe, de) {
      var be = fe.charCodeAt(de);
      if (be >= 48 && be <= 57)
        return be - 48;
      if (be >= 65 && be <= 70)
        return be - 55;
      if (be >= 97 && be <= 102)
        return be - 87;
      te(!1, "Invalid character in " + fe);
    }
    function ae(fe, de, be) {
      var Te = se(fe, be);
      return be - 1 >= de && (Te |= se(fe, be - 1) << 4), Te;
    }
    ie.prototype._parseHex = function(fe, de, be) {
      this.length = Math.ceil((fe.length - de) / 6), this.words = new Array(this.length);
      for (var Te = 0; Te < this.length; Te++)
        this.words[Te] = 0;
      var Ce = 0, Pe = 0, Se;
      if (be === "be")
        for (Te = fe.length - 1; Te >= de; Te -= 2)
          Se = ae(fe, de, Te) << Ce, this.words[Pe] |= Se & 67108863, Ce >= 18 ? (Ce -= 18, Pe += 1, this.words[Pe] |= Se >>> 26) : Ce += 8;
      else {
        var ke = fe.length - de;
        for (Te = ke % 2 === 0 ? de + 1 : de; Te < fe.length; Te += 2)
          Se = ae(fe, de, Te) << Ce, this.words[Pe] |= Se & 67108863, Ce >= 18 ? (Ce -= 18, Pe += 1, this.words[Pe] |= Se >>> 26) : Ce += 8;
      }
      this._strip();
    };
    function ue(fe, de, be, Te) {
      for (var Ce = 0, Pe = 0, Se = Math.min(fe.length, be), ke = de; ke < Se; ke++) {
        var ge = fe.charCodeAt(ke) - 48;
        Ce *= Te, ge >= 49 ? Pe = ge - 49 + 10 : ge >= 17 ? Pe = ge - 17 + 10 : Pe = ge, te(ge >= 0 && Pe < Te, "Invalid character"), Ce += Pe;
      }
      return Ce;
    }
    ie.prototype._parseBase = function(fe, de, be) {
      this.words = [0], this.length = 1;
      for (var Te = 0, Ce = 1; Ce <= 67108863; Ce *= de)
        Te++;
      Te--, Ce = Ce / de | 0;
      for (var Pe = fe.length - be, Se = Pe % Te, ke = Math.min(Pe, Pe - Se) + be, ge = 0, Ae = be; Ae < ke; Ae += Te)
        ge = ue(fe, Ae, Ae + Te, de), this.imuln(Ce), this.words[0] + ge < 67108864 ? this.words[0] += ge : this._iaddn(ge);
      if (Se !== 0) {
        var Ge = 1;
        for (ge = ue(fe, Ae, fe.length, de), Ae = 0; Ae < Se; Ae++)
          Ge *= de;
        this.imuln(Ge), this.words[0] + ge < 67108864 ? this.words[0] += ge : this._iaddn(ge);
      }
      this._strip();
    }, ie.prototype.copy = function(fe) {
      fe.words = new Array(this.length);
      for (var de = 0; de < this.length; de++)
        fe.words[de] = this.words[de];
      fe.length = this.length, fe.negative = this.negative, fe.red = this.red;
    };
    function le(fe, de) {
      fe.words = de.words, fe.length = de.length, fe.negative = de.negative, fe.red = de.red;
    }
    if (ie.prototype._move = function(fe) {
      le(fe, this);
    }, ie.prototype.clone = function() {
      var fe = new ie(null);
      return this.copy(fe), fe;
    }, ie.prototype._expand = function(fe) {
      for (; this.length < fe; )
        this.words[this.length++] = 0;
      return this;
    }, ie.prototype._strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, ie.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, typeof Symbol < "u" && typeof Symbol.for == "function")
      try {
        ie.prototype[Symbol.for("nodejs.util.inspect.custom")] = he;
      } catch {
        ie.prototype.inspect = he;
      }
    else
      ie.prototype.inspect = he;
    function he() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    }
    var me = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], ye = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], we = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    ie.prototype.toString = function(fe, de) {
      fe = fe || 10, de = de | 0 || 1;
      var be;
      if (fe === 16 || fe === "hex") {
        be = "";
        for (var Te = 0, Ce = 0, Pe = 0; Pe < this.length; Pe++) {
          var Se = this.words[Pe], ke = ((Se << Te | Ce) & 16777215).toString(16);
          Ce = Se >>> 24 - Te & 16777215, Te += 2, Te >= 26 && (Te -= 26, Pe--), Ce !== 0 || Pe !== this.length - 1 ? be = me[6 - ke.length] + ke + be : be = ke + be;
        }
        for (Ce !== 0 && (be = Ce.toString(16) + be); be.length % de !== 0; )
          be = "0" + be;
        return this.negative !== 0 && (be = "-" + be), be;
      }
      if (fe === (fe | 0) && fe >= 2 && fe <= 36) {
        var ge = ye[fe], Ae = we[fe];
        be = "";
        var Ge = this.clone();
        for (Ge.negative = 0; !Ge.isZero(); ) {
          var Xe = Ge.modrn(Ae).toString(fe);
          Ge = Ge.idivn(Ae), Ge.isZero() ? be = Xe + be : be = me[ge - Xe.length] + Xe + be;
        }
        for (this.isZero() && (be = "0" + be); be.length % de !== 0; )
          be = "0" + be;
        return this.negative !== 0 && (be = "-" + be), be;
      }
      te(!1, "Base should be between 2 and 36");
    }, ie.prototype.toNumber = function() {
      var fe = this.words[0];
      return this.length === 2 ? fe += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? fe += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && te(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -fe : fe;
    }, ie.prototype.toJSON = function() {
      return this.toString(16, 2);
    }, oe && (ie.prototype.toBuffer = function(fe, de) {
      return this.toArrayLike(oe, fe, de);
    }), ie.prototype.toArray = function(fe, de) {
      return this.toArrayLike(Array, fe, de);
    };
    var Ee = function(fe, de) {
      return fe.allocUnsafe ? fe.allocUnsafe(de) : new fe(de);
    };
    ie.prototype.toArrayLike = function(fe, de, be) {
      this._strip();
      var Te = this.byteLength(), Ce = be || Math.max(1, Te);
      te(Te <= Ce, "byte array longer than desired length"), te(Ce > 0, "Requested array length <= 0");
      var Pe = Ee(fe, Ce), Se = de === "le" ? "LE" : "BE";
      return this["_toArrayLike" + Se](Pe, Te), Pe;
    }, ie.prototype._toArrayLikeLE = function(fe, de) {
      for (var be = 0, Te = 0, Ce = 0, Pe = 0; Ce < this.length; Ce++) {
        var Se = this.words[Ce] << Pe | Te;
        fe[be++] = Se & 255, be < fe.length && (fe[be++] = Se >> 8 & 255), be < fe.length && (fe[be++] = Se >> 16 & 255), Pe === 6 ? (be < fe.length && (fe[be++] = Se >> 24 & 255), Te = 0, Pe = 0) : (Te = Se >>> 24, Pe += 2);
      }
      if (be < fe.length)
        for (fe[be++] = Te; be < fe.length; )
          fe[be++] = 0;
    }, ie.prototype._toArrayLikeBE = function(fe, de) {
      for (var be = fe.length - 1, Te = 0, Ce = 0, Pe = 0; Ce < this.length; Ce++) {
        var Se = this.words[Ce] << Pe | Te;
        fe[be--] = Se & 255, be >= 0 && (fe[be--] = Se >> 8 & 255), be >= 0 && (fe[be--] = Se >> 16 & 255), Pe === 6 ? (be >= 0 && (fe[be--] = Se >> 24 & 255), Te = 0, Pe = 0) : (Te = Se >>> 24, Pe += 2);
      }
      if (be >= 0)
        for (fe[be--] = Te; be >= 0; )
          fe[be--] = 0;
    }, Math.clz32 ? ie.prototype._countBits = function(fe) {
      return 32 - Math.clz32(fe);
    } : ie.prototype._countBits = function(fe) {
      var de = fe, be = 0;
      return de >= 4096 && (be += 13, de >>>= 13), de >= 64 && (be += 7, de >>>= 7), de >= 8 && (be += 4, de >>>= 4), de >= 2 && (be += 2, de >>>= 2), be + de;
    }, ie.prototype._zeroBits = function(fe) {
      if (fe === 0)
        return 26;
      var de = fe, be = 0;
      return de & 8191 || (be += 13, de >>>= 13), de & 127 || (be += 7, de >>>= 7), de & 15 || (be += 4, de >>>= 4), de & 3 || (be += 2, de >>>= 2), de & 1 || be++, be;
    }, ie.prototype.bitLength = function() {
      var fe = this.words[this.length - 1], de = this._countBits(fe);
      return (this.length - 1) * 26 + de;
    };
    function Re(fe) {
      for (var de = new Array(fe.bitLength()), be = 0; be < de.length; be++) {
        var Te = be / 26 | 0, Ce = be % 26;
        de[be] = fe.words[Te] >>> Ce & 1;
      }
      return de;
    }
    ie.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var fe = 0, de = 0; de < this.length; de++) {
        var be = this._zeroBits(this.words[de]);
        if (fe += be, be !== 26)
          break;
      }
      return fe;
    }, ie.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, ie.prototype.toTwos = function(fe) {
      return this.negative !== 0 ? this.abs().inotn(fe).iaddn(1) : this.clone();
    }, ie.prototype.fromTwos = function(fe) {
      return this.testn(fe - 1) ? this.notn(fe).iaddn(1).ineg() : this.clone();
    }, ie.prototype.isNeg = function() {
      return this.negative !== 0;
    }, ie.prototype.neg = function() {
      return this.clone().ineg();
    }, ie.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, ie.prototype.iuor = function(fe) {
      for (; this.length < fe.length; )
        this.words[this.length++] = 0;
      for (var de = 0; de < fe.length; de++)
        this.words[de] = this.words[de] | fe.words[de];
      return this._strip();
    }, ie.prototype.ior = function(fe) {
      return te((this.negative | fe.negative) === 0), this.iuor(fe);
    }, ie.prototype.or = function(fe) {
      return this.length > fe.length ? this.clone().ior(fe) : fe.clone().ior(this);
    }, ie.prototype.uor = function(fe) {
      return this.length > fe.length ? this.clone().iuor(fe) : fe.clone().iuor(this);
    }, ie.prototype.iuand = function(fe) {
      var de;
      this.length > fe.length ? de = fe : de = this;
      for (var be = 0; be < de.length; be++)
        this.words[be] = this.words[be] & fe.words[be];
      return this.length = de.length, this._strip();
    }, ie.prototype.iand = function(fe) {
      return te((this.negative | fe.negative) === 0), this.iuand(fe);
    }, ie.prototype.and = function(fe) {
      return this.length > fe.length ? this.clone().iand(fe) : fe.clone().iand(this);
    }, ie.prototype.uand = function(fe) {
      return this.length > fe.length ? this.clone().iuand(fe) : fe.clone().iuand(this);
    }, ie.prototype.iuxor = function(fe) {
      var de, be;
      this.length > fe.length ? (de = this, be = fe) : (de = fe, be = this);
      for (var Te = 0; Te < be.length; Te++)
        this.words[Te] = de.words[Te] ^ be.words[Te];
      if (this !== de)
        for (; Te < de.length; Te++)
          this.words[Te] = de.words[Te];
      return this.length = de.length, this._strip();
    }, ie.prototype.ixor = function(fe) {
      return te((this.negative | fe.negative) === 0), this.iuxor(fe);
    }, ie.prototype.xor = function(fe) {
      return this.length > fe.length ? this.clone().ixor(fe) : fe.clone().ixor(this);
    }, ie.prototype.uxor = function(fe) {
      return this.length > fe.length ? this.clone().iuxor(fe) : fe.clone().iuxor(this);
    }, ie.prototype.inotn = function(fe) {
      te(typeof fe == "number" && fe >= 0);
      var de = Math.ceil(fe / 26) | 0, be = fe % 26;
      this._expand(de), be > 0 && de--;
      for (var Te = 0; Te < de; Te++)
        this.words[Te] = ~this.words[Te] & 67108863;
      return be > 0 && (this.words[Te] = ~this.words[Te] & 67108863 >> 26 - be), this._strip();
    }, ie.prototype.notn = function(fe) {
      return this.clone().inotn(fe);
    }, ie.prototype.setn = function(fe, de) {
      te(typeof fe == "number" && fe >= 0);
      var be = fe / 26 | 0, Te = fe % 26;
      return this._expand(be + 1), de ? this.words[be] = this.words[be] | 1 << Te : this.words[be] = this.words[be] & ~(1 << Te), this._strip();
    }, ie.prototype.iadd = function(fe) {
      var de;
      if (this.negative !== 0 && fe.negative === 0)
        return this.negative = 0, de = this.isub(fe), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && fe.negative !== 0)
        return fe.negative = 0, de = this.isub(fe), fe.negative = 1, de._normSign();
      var be, Te;
      this.length > fe.length ? (be = this, Te = fe) : (be = fe, Te = this);
      for (var Ce = 0, Pe = 0; Pe < Te.length; Pe++)
        de = (be.words[Pe] | 0) + (Te.words[Pe] | 0) + Ce, this.words[Pe] = de & 67108863, Ce = de >>> 26;
      for (; Ce !== 0 && Pe < be.length; Pe++)
        de = (be.words[Pe] | 0) + Ce, this.words[Pe] = de & 67108863, Ce = de >>> 26;
      if (this.length = be.length, Ce !== 0)
        this.words[this.length] = Ce, this.length++;
      else if (be !== this)
        for (; Pe < be.length; Pe++)
          this.words[Pe] = be.words[Pe];
      return this;
    }, ie.prototype.add = function(fe) {
      var de;
      return fe.negative !== 0 && this.negative === 0 ? (fe.negative = 0, de = this.sub(fe), fe.negative ^= 1, de) : fe.negative === 0 && this.negative !== 0 ? (this.negative = 0, de = fe.sub(this), this.negative = 1, de) : this.length > fe.length ? this.clone().iadd(fe) : fe.clone().iadd(this);
    }, ie.prototype.isub = function(fe) {
      if (fe.negative !== 0) {
        fe.negative = 0;
        var de = this.iadd(fe);
        return fe.negative = 1, de._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(fe), this.negative = 1, this._normSign();
      var be = this.cmp(fe);
      if (be === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var Te, Ce;
      be > 0 ? (Te = this, Ce = fe) : (Te = fe, Ce = this);
      for (var Pe = 0, Se = 0; Se < Ce.length; Se++)
        de = (Te.words[Se] | 0) - (Ce.words[Se] | 0) + Pe, Pe = de >> 26, this.words[Se] = de & 67108863;
      for (; Pe !== 0 && Se < Te.length; Se++)
        de = (Te.words[Se] | 0) + Pe, Pe = de >> 26, this.words[Se] = de & 67108863;
      if (Pe === 0 && Se < Te.length && Te !== this)
        for (; Se < Te.length; Se++)
          this.words[Se] = Te.words[Se];
      return this.length = Math.max(this.length, Se), Te !== this && (this.negative = 1), this._strip();
    }, ie.prototype.sub = function(fe) {
      return this.clone().isub(fe);
    };
    function Ue(fe, de, be) {
      be.negative = de.negative ^ fe.negative;
      var Te = fe.length + de.length | 0;
      be.length = Te, Te = Te - 1 | 0;
      var Ce = fe.words[0] | 0, Pe = de.words[0] | 0, Se = Ce * Pe, ke = Se & 67108863, ge = Se / 67108864 | 0;
      be.words[0] = ke;
      for (var Ae = 1; Ae < Te; Ae++) {
        for (var Ge = ge >>> 26, Xe = ge & 67108863, $e = Math.min(Ae, de.length - 1), Ze = Math.max(0, Ae - fe.length + 1); Ze <= $e; Ze++) {
          var ot = Ae - Ze | 0;
          Ce = fe.words[ot] | 0, Pe = de.words[Ze] | 0, Se = Ce * Pe + Xe, Ge += Se / 67108864 | 0, Xe = Se & 67108863;
        }
        be.words[Ae] = Xe | 0, ge = Ge | 0;
      }
      return ge !== 0 ? be.words[Ae] = ge | 0 : be.length--, be._strip();
    }
    var Me = function(fe, de, be) {
      var Te = fe.words, Ce = de.words, Pe = be.words, Se = 0, ke, ge, Ae, Ge = Te[0] | 0, Xe = Ge & 8191, $e = Ge >>> 13, Ze = Te[1] | 0, ot = Ze & 8191, ct = Ze >>> 13, At = Te[2] | 0, Tt = At & 8191, dt = At >>> 13, vt = Te[3] | 0, Ut = vt & 8191, It = vt >>> 13, Er = Te[4] | 0, Fr = Er & 8191, an = Er >>> 13, wX = Te[5] | 0, Ct = wX & 8191, w_ = wX >>> 13, hX = Te[6] | 0, oX = hX & 8191, Nn = hX >>> 13, SX = Te[7] | 0, sX = SX & 8191, nX = SX >>> 13, Ye = Te[8] | 0, lt = Ye & 8191, pt = Ye >>> 13, He = Te[9] | 0, Je = He & 8191, st = He >>> 13, gt = Ce[0] | 0, kt = gt & 8191, Vt = gt >>> 13, Lr = Ce[1] | 0, Ci = Lr & 8191, Qr = Lr >>> 13, xX = Ce[2] | 0, lX = xX & 8191, rX = xX >>> 13, FX = Ce[3] | 0, BX = FX & 8191, cX = FX >>> 13, MX = Ce[4] | 0, EX = MX & 8191, yX = MX >>> 13, jX = Ce[5] | 0, AX = jX & 8191, vX = jX >>> 13, PX = Ce[6] | 0, kX = PX & 8191, qe = PX >>> 13, Qe = Ce[7] | 0, Ve = Qe & 8191, Ie = Qe >>> 13, nt = Ce[8] | 0, Et = nt & 8191, xt = nt >>> 13, Jt = Ce[9] | 0, Yt = Jt & 8191, _r = Jt >>> 13;
      be.negative = fe.negative ^ de.negative, be.length = 19, ke = Math.imul(Xe, kt), ge = Math.imul(Xe, Vt), ge = ge + Math.imul($e, kt) | 0, Ae = Math.imul($e, Vt);
      var cn = (Se + ke | 0) + ((ge & 8191) << 13) | 0;
      Se = (Ae + (ge >>> 13) | 0) + (cn >>> 26) | 0, cn &= 67108863, ke = Math.imul(ot, kt), ge = Math.imul(ot, Vt), ge = ge + Math.imul(ct, kt) | 0, Ae = Math.imul(ct, Vt), ke = ke + Math.imul(Xe, Ci) | 0, ge = ge + Math.imul(Xe, Qr) | 0, ge = ge + Math.imul($e, Ci) | 0, Ae = Ae + Math.imul($e, Qr) | 0;
      var _X = (Se + ke | 0) + ((ge & 8191) << 13) | 0;
      Se = (Ae + (ge >>> 13) | 0) + (_X >>> 26) | 0, _X &= 67108863, ke = Math.imul(Tt, kt), ge = Math.imul(Tt, Vt), ge = ge + Math.imul(dt, kt) | 0, Ae = Math.imul(dt, Vt), ke = ke + Math.imul(ot, Ci) | 0, ge = ge + Math.imul(ot, Qr) | 0, ge = ge + Math.imul(ct, Ci) | 0, Ae = Ae + Math.imul(ct, Qr) | 0, ke = ke + Math.imul(Xe, lX) | 0, ge = ge + Math.imul(Xe, rX) | 0, ge = ge + Math.imul($e, lX) | 0, Ae = Ae + Math.imul($e, rX) | 0;
      var un = (Se + ke | 0) + ((ge & 8191) << 13) | 0;
      Se = (Ae + (ge >>> 13) | 0) + (un >>> 26) | 0, un &= 67108863, ke = Math.imul(Ut, kt), ge = Math.imul(Ut, Vt), ge = ge + Math.imul(It, kt) | 0, Ae = Math.imul(It, Vt), ke = ke + Math.imul(Tt, Ci) | 0, ge = ge + Math.imul(Tt, Qr) | 0, ge = ge + Math.imul(dt, Ci) | 0, Ae = Ae + Math.imul(dt, Qr) | 0, ke = ke + Math.imul(ot, lX) | 0, ge = ge + Math.imul(ot, rX) | 0, ge = ge + Math.imul(ct, lX) | 0, Ae = Ae + Math.imul(ct, rX) | 0, ke = ke + Math.imul(Xe, BX) | 0, ge = ge + Math.imul(Xe, cX) | 0, ge = ge + Math.imul($e, BX) | 0, Ae = Ae + Math.imul($e, cX) | 0;
      var aX = (Se + ke | 0) + ((ge & 8191) << 13) | 0;
      Se = (Ae + (ge >>> 13) | 0) + (aX >>> 26) | 0, aX &= 67108863, ke = Math.imul(Fr, kt), ge = Math.imul(Fr, Vt), ge = ge + Math.imul(an, kt) | 0, Ae = Math.imul(an, Vt), ke = ke + Math.imul(Ut, Ci) | 0, ge = ge + Math.imul(Ut, Qr) | 0, ge = ge + Math.imul(It, Ci) | 0, Ae = Ae + Math.imul(It, Qr) | 0, ke = ke + Math.imul(Tt, lX) | 0, ge = ge + Math.imul(Tt, rX) | 0, ge = ge + Math.imul(dt, lX) | 0, Ae = Ae + Math.imul(dt, rX) | 0, ke = ke + Math.imul(ot, BX) | 0, ge = ge + Math.imul(ot, cX) | 0, ge = ge + Math.imul(ct, BX) | 0, Ae = Ae + Math.imul(ct, cX) | 0, ke = ke + Math.imul(Xe, EX) | 0, ge = ge + Math.imul(Xe, yX) | 0, ge = ge + Math.imul($e, EX) | 0, Ae = Ae + Math.imul($e, yX) | 0;
      var uX = (Se + ke | 0) + ((ge & 8191) << 13) | 0;
      Se = (Ae + (ge >>> 13) | 0) + (uX >>> 26) | 0, uX &= 67108863, ke = Math.imul(Ct, kt), ge = Math.imul(Ct, Vt), ge = ge + Math.imul(w_, kt) | 0, Ae = Math.imul(w_, Vt), ke = ke + Math.imul(Fr, Ci) | 0, ge = ge + Math.imul(Fr, Qr) | 0, ge = ge + Math.imul(an, Ci) | 0, Ae = Ae + Math.imul(an, Qr) | 0, ke = ke + Math.imul(Ut, lX) | 0, ge = ge + Math.imul(Ut, rX) | 0, ge = ge + Math.imul(It, lX) | 0, Ae = Ae + Math.imul(It, rX) | 0, ke = ke + Math.imul(Tt, BX) | 0, ge = ge + Math.imul(Tt, cX) | 0, ge = ge + Math.imul(dt, BX) | 0, Ae = Ae + Math.imul(dt, cX) | 0, ke = ke + Math.imul(ot, EX) | 0, ge = ge + Math.imul(ot, yX) | 0, ge = ge + Math.imul(ct, EX) | 0, Ae = Ae + Math.imul(ct, yX) | 0, ke = ke + Math.imul(Xe, AX) | 0, ge = ge + Math.imul(Xe, vX) | 0, ge = ge + Math.imul($e, AX) | 0, Ae = Ae + Math.imul($e, vX) | 0;
      var fX = (Se + ke | 0) + ((ge & 8191) << 13) | 0;
      Se = (Ae + (ge >>> 13) | 0) + (fX >>> 26) | 0, fX &= 67108863, ke = Math.imul(oX, kt), ge = Math.imul(oX, Vt), ge = ge + Math.imul(Nn, kt) | 0, Ae = Math.imul(Nn, Vt), ke = ke + Math.imul(Ct, Ci) | 0, ge = ge + Math.imul(Ct, Qr) | 0, ge = ge + Math.imul(w_, Ci) | 0, Ae = Ae + Math.imul(w_, Qr) | 0, ke = ke + Math.imul(Fr, lX) | 0, ge = ge + Math.imul(Fr, rX) | 0, ge = ge + Math.imul(an, lX) | 0, Ae = Ae + Math.imul(an, rX) | 0, ke = ke + Math.imul(Ut, BX) | 0, ge = ge + Math.imul(Ut, cX) | 0, ge = ge + Math.imul(It, BX) | 0, Ae = Ae + Math.imul(It, cX) | 0, ke = ke + Math.imul(Tt, EX) | 0, ge = ge + Math.imul(Tt, yX) | 0, ge = ge + Math.imul(dt, EX) | 0, Ae = Ae + Math.imul(dt, yX) | 0, ke = ke + Math.imul(ot, AX) | 0, ge = ge + Math.imul(ot, vX) | 0, ge = ge + Math.imul(ct, AX) | 0, Ae = Ae + Math.imul(ct, vX) | 0, ke = ke + Math.imul(Xe, kX) | 0, ge = ge + Math.imul(Xe, qe) | 0, ge = ge + Math.imul($e, kX) | 0, Ae = Ae + Math.imul($e, qe) | 0;
      var bX = (Se + ke | 0) + ((ge & 8191) << 13) | 0;
      Se = (Ae + (ge >>> 13) | 0) + (bX >>> 26) | 0, bX &= 67108863, ke = Math.imul(sX, kt), ge = Math.imul(sX, Vt), ge = ge + Math.imul(nX, kt) | 0, Ae = Math.imul(nX, Vt), ke = ke + Math.imul(oX, Ci) | 0, ge = ge + Math.imul(oX, Qr) | 0, ge = ge + Math.imul(Nn, Ci) | 0, Ae = Ae + Math.imul(Nn, Qr) | 0, ke = ke + Math.imul(Ct, lX) | 0, ge = ge + Math.imul(Ct, rX) | 0, ge = ge + Math.imul(w_, lX) | 0, Ae = Ae + Math.imul(w_, rX) | 0, ke = ke + Math.imul(Fr, BX) | 0, ge = ge + Math.imul(Fr, cX) | 0, ge = ge + Math.imul(an, BX) | 0, Ae = Ae + Math.imul(an, cX) | 0, ke = ke + Math.imul(Ut, EX) | 0, ge = ge + Math.imul(Ut, yX) | 0, ge = ge + Math.imul(It, EX) | 0, Ae = Ae + Math.imul(It, yX) | 0, ke = ke + Math.imul(Tt, AX) | 0, ge = ge + Math.imul(Tt, vX) | 0, ge = ge + Math.imul(dt, AX) | 0, Ae = Ae + Math.imul(dt, vX) | 0, ke = ke + Math.imul(ot, kX) | 0, ge = ge + Math.imul(ot, qe) | 0, ge = ge + Math.imul(ct, kX) | 0, Ae = Ae + Math.imul(ct, qe) | 0, ke = ke + Math.imul(Xe, Ve) | 0, ge = ge + Math.imul(Xe, Ie) | 0, ge = ge + Math.imul($e, Ve) | 0, Ae = Ae + Math.imul($e, Ie) | 0;
      var dX = (Se + ke | 0) + ((ge & 8191) << 13) | 0;
      Se = (Ae + (ge >>> 13) | 0) + (dX >>> 26) | 0, dX &= 67108863, ke = Math.imul(lt, kt), ge = Math.imul(lt, Vt), ge = ge + Math.imul(pt, kt) | 0, Ae = Math.imul(pt, Vt), ke = ke + Math.imul(sX, Ci) | 0, ge = ge + Math.imul(sX, Qr) | 0, ge = ge + Math.imul(nX, Ci) | 0, Ae = Ae + Math.imul(nX, Qr) | 0, ke = ke + Math.imul(oX, lX) | 0, ge = ge + Math.imul(oX, rX) | 0, ge = ge + Math.imul(Nn, lX) | 0, Ae = Ae + Math.imul(Nn, rX) | 0, ke = ke + Math.imul(Ct, BX) | 0, ge = ge + Math.imul(Ct, cX) | 0, ge = ge + Math.imul(w_, BX) | 0, Ae = Ae + Math.imul(w_, cX) | 0, ke = ke + Math.imul(Fr, EX) | 0, ge = ge + Math.imul(Fr, yX) | 0, ge = ge + Math.imul(an, EX) | 0, Ae = Ae + Math.imul(an, yX) | 0, ke = ke + Math.imul(Ut, AX) | 0, ge = ge + Math.imul(Ut, vX) | 0, ge = ge + Math.imul(It, AX) | 0, Ae = Ae + Math.imul(It, vX) | 0, ke = ke + Math.imul(Tt, kX) | 0, ge = ge + Math.imul(Tt, qe) | 0, ge = ge + Math.imul(dt, kX) | 0, Ae = Ae + Math.imul(dt, qe) | 0, ke = ke + Math.imul(ot, Ve) | 0, ge = ge + Math.imul(ot, Ie) | 0, ge = ge + Math.imul(ct, Ve) | 0, Ae = Ae + Math.imul(ct, Ie) | 0, ke = ke + Math.imul(Xe, Et) | 0, ge = ge + Math.imul(Xe, xt) | 0, ge = ge + Math.imul($e, Et) | 0, Ae = Ae + Math.imul($e, xt) | 0;
      var mX = (Se + ke | 0) + ((ge & 8191) << 13) | 0;
      Se = (Ae + (ge >>> 13) | 0) + (mX >>> 26) | 0, mX &= 67108863, ke = Math.imul(Je, kt), ge = Math.imul(Je, Vt), ge = ge + Math.imul(st, kt) | 0, Ae = Math.imul(st, Vt), ke = ke + Math.imul(lt, Ci) | 0, ge = ge + Math.imul(lt, Qr) | 0, ge = ge + Math.imul(pt, Ci) | 0, Ae = Ae + Math.imul(pt, Qr) | 0, ke = ke + Math.imul(sX, lX) | 0, ge = ge + Math.imul(sX, rX) | 0, ge = ge + Math.imul(nX, lX) | 0, Ae = Ae + Math.imul(nX, rX) | 0, ke = ke + Math.imul(oX, BX) | 0, ge = ge + Math.imul(oX, cX) | 0, ge = ge + Math.imul(Nn, BX) | 0, Ae = Ae + Math.imul(Nn, cX) | 0, ke = ke + Math.imul(Ct, EX) | 0, ge = ge + Math.imul(Ct, yX) | 0, ge = ge + Math.imul(w_, EX) | 0, Ae = Ae + Math.imul(w_, yX) | 0, ke = ke + Math.imul(Fr, AX) | 0, ge = ge + Math.imul(Fr, vX) | 0, ge = ge + Math.imul(an, AX) | 0, Ae = Ae + Math.imul(an, vX) | 0, ke = ke + Math.imul(Ut, kX) | 0, ge = ge + Math.imul(Ut, qe) | 0, ge = ge + Math.imul(It, kX) | 0, Ae = Ae + Math.imul(It, qe) | 0, ke = ke + Math.imul(Tt, Ve) | 0, ge = ge + Math.imul(Tt, Ie) | 0, ge = ge + Math.imul(dt, Ve) | 0, Ae = Ae + Math.imul(dt, Ie) | 0, ke = ke + Math.imul(ot, Et) | 0, ge = ge + Math.imul(ot, xt) | 0, ge = ge + Math.imul(ct, Et) | 0, Ae = Ae + Math.imul(ct, xt) | 0, ke = ke + Math.imul(Xe, Yt) | 0, ge = ge + Math.imul(Xe, _r) | 0, ge = ge + Math.imul($e, Yt) | 0, Ae = Ae + Math.imul($e, _r) | 0;
      var pX = (Se + ke | 0) + ((ge & 8191) << 13) | 0;
      Se = (Ae + (ge >>> 13) | 0) + (pX >>> 26) | 0, pX &= 67108863, ke = Math.imul(Je, Ci), ge = Math.imul(Je, Qr), ge = ge + Math.imul(st, Ci) | 0, Ae = Math.imul(st, Qr), ke = ke + Math.imul(lt, lX) | 0, ge = ge + Math.imul(lt, rX) | 0, ge = ge + Math.imul(pt, lX) | 0, Ae = Ae + Math.imul(pt, rX) | 0, ke = ke + Math.imul(sX, BX) | 0, ge = ge + Math.imul(sX, cX) | 0, ge = ge + Math.imul(nX, BX) | 0, Ae = Ae + Math.imul(nX, cX) | 0, ke = ke + Math.imul(oX, EX) | 0, ge = ge + Math.imul(oX, yX) | 0, ge = ge + Math.imul(Nn, EX) | 0, Ae = Ae + Math.imul(Nn, yX) | 0, ke = ke + Math.imul(Ct, AX) | 0, ge = ge + Math.imul(Ct, vX) | 0, ge = ge + Math.imul(w_, AX) | 0, Ae = Ae + Math.imul(w_, vX) | 0, ke = ke + Math.imul(Fr, kX) | 0, ge = ge + Math.imul(Fr, qe) | 0, ge = ge + Math.imul(an, kX) | 0, Ae = Ae + Math.imul(an, qe) | 0, ke = ke + Math.imul(Ut, Ve) | 0, ge = ge + Math.imul(Ut, Ie) | 0, ge = ge + Math.imul(It, Ve) | 0, Ae = Ae + Math.imul(It, Ie) | 0, ke = ke + Math.imul(Tt, Et) | 0, ge = ge + Math.imul(Tt, xt) | 0, ge = ge + Math.imul(dt, Et) | 0, Ae = Ae + Math.imul(dt, xt) | 0, ke = ke + Math.imul(ot, Yt) | 0, ge = ge + Math.imul(ot, _r) | 0, ge = ge + Math.imul(ct, Yt) | 0, Ae = Ae + Math.imul(ct, _r) | 0;
      var G_ = (Se + ke | 0) + ((ge & 8191) << 13) | 0;
      Se = (Ae + (ge >>> 13) | 0) + (G_ >>> 26) | 0, G_ &= 67108863, ke = Math.imul(Je, lX), ge = Math.imul(Je, rX), ge = ge + Math.imul(st, lX) | 0, Ae = Math.imul(st, rX), ke = ke + Math.imul(lt, BX) | 0, ge = ge + Math.imul(lt, cX) | 0, ge = ge + Math.imul(pt, BX) | 0, Ae = Ae + Math.imul(pt, cX) | 0, ke = ke + Math.imul(sX, EX) | 0, ge = ge + Math.imul(sX, yX) | 0, ge = ge + Math.imul(nX, EX) | 0, Ae = Ae + Math.imul(nX, yX) | 0, ke = ke + Math.imul(oX, AX) | 0, ge = ge + Math.imul(oX, vX) | 0, ge = ge + Math.imul(Nn, AX) | 0, Ae = Ae + Math.imul(Nn, vX) | 0, ke = ke + Math.imul(Ct, kX) | 0, ge = ge + Math.imul(Ct, qe) | 0, ge = ge + Math.imul(w_, kX) | 0, Ae = Ae + Math.imul(w_, qe) | 0, ke = ke + Math.imul(Fr, Ve) | 0, ge = ge + Math.imul(Fr, Ie) | 0, ge = ge + Math.imul(an, Ve) | 0, Ae = Ae + Math.imul(an, Ie) | 0, ke = ke + Math.imul(Ut, Et) | 0, ge = ge + Math.imul(Ut, xt) | 0, ge = ge + Math.imul(It, Et) | 0, Ae = Ae + Math.imul(It, xt) | 0, ke = ke + Math.imul(Tt, Yt) | 0, ge = ge + Math.imul(Tt, _r) | 0, ge = ge + Math.imul(dt, Yt) | 0, Ae = Ae + Math.imul(dt, _r) | 0;
      var iX = (Se + ke | 0) + ((ge & 8191) << 13) | 0;
      Se = (Ae + (ge >>> 13) | 0) + (iX >>> 26) | 0, iX &= 67108863, ke = Math.imul(Je, BX), ge = Math.imul(Je, cX), ge = ge + Math.imul(st, BX) | 0, Ae = Math.imul(st, cX), ke = ke + Math.imul(lt, EX) | 0, ge = ge + Math.imul(lt, yX) | 0, ge = ge + Math.imul(pt, EX) | 0, Ae = Ae + Math.imul(pt, yX) | 0, ke = ke + Math.imul(sX, AX) | 0, ge = ge + Math.imul(sX, vX) | 0, ge = ge + Math.imul(nX, AX) | 0, Ae = Ae + Math.imul(nX, vX) | 0, ke = ke + Math.imul(oX, kX) | 0, ge = ge + Math.imul(oX, qe) | 0, ge = ge + Math.imul(Nn, kX) | 0, Ae = Ae + Math.imul(Nn, qe) | 0, ke = ke + Math.imul(Ct, Ve) | 0, ge = ge + Math.imul(Ct, Ie) | 0, ge = ge + Math.imul(w_, Ve) | 0, Ae = Ae + Math.imul(w_, Ie) | 0, ke = ke + Math.imul(Fr, Et) | 0, ge = ge + Math.imul(Fr, xt) | 0, ge = ge + Math.imul(an, Et) | 0, Ae = Ae + Math.imul(an, xt) | 0, ke = ke + Math.imul(Ut, Yt) | 0, ge = ge + Math.imul(Ut, _r) | 0, ge = ge + Math.imul(It, Yt) | 0, Ae = Ae + Math.imul(It, _r) | 0;
      var og = (Se + ke | 0) + ((ge & 8191) << 13) | 0;
      Se = (Ae + (ge >>> 13) | 0) + (og >>> 26) | 0, og &= 67108863, ke = Math.imul(Je, EX), ge = Math.imul(Je, yX), ge = ge + Math.imul(st, EX) | 0, Ae = Math.imul(st, yX), ke = ke + Math.imul(lt, AX) | 0, ge = ge + Math.imul(lt, vX) | 0, ge = ge + Math.imul(pt, AX) | 0, Ae = Ae + Math.imul(pt, vX) | 0, ke = ke + Math.imul(sX, kX) | 0, ge = ge + Math.imul(sX, qe) | 0, ge = ge + Math.imul(nX, kX) | 0, Ae = Ae + Math.imul(nX, qe) | 0, ke = ke + Math.imul(oX, Ve) | 0, ge = ge + Math.imul(oX, Ie) | 0, ge = ge + Math.imul(Nn, Ve) | 0, Ae = Ae + Math.imul(Nn, Ie) | 0, ke = ke + Math.imul(Ct, Et) | 0, ge = ge + Math.imul(Ct, xt) | 0, ge = ge + Math.imul(w_, Et) | 0, Ae = Ae + Math.imul(w_, xt) | 0, ke = ke + Math.imul(Fr, Yt) | 0, ge = ge + Math.imul(Fr, _r) | 0, ge = ge + Math.imul(an, Yt) | 0, Ae = Ae + Math.imul(an, _r) | 0;
      var eX = (Se + ke | 0) + ((ge & 8191) << 13) | 0;
      Se = (Ae + (ge >>> 13) | 0) + (eX >>> 26) | 0, eX &= 67108863, ke = Math.imul(Je, AX), ge = Math.imul(Je, vX), ge = ge + Math.imul(st, AX) | 0, Ae = Math.imul(st, vX), ke = ke + Math.imul(lt, kX) | 0, ge = ge + Math.imul(lt, qe) | 0, ge = ge + Math.imul(pt, kX) | 0, Ae = Ae + Math.imul(pt, qe) | 0, ke = ke + Math.imul(sX, Ve) | 0, ge = ge + Math.imul(sX, Ie) | 0, ge = ge + Math.imul(nX, Ve) | 0, Ae = Ae + Math.imul(nX, Ie) | 0, ke = ke + Math.imul(oX, Et) | 0, ge = ge + Math.imul(oX, xt) | 0, ge = ge + Math.imul(Nn, Et) | 0, Ae = Ae + Math.imul(Nn, xt) | 0, ke = ke + Math.imul(Ct, Yt) | 0, ge = ge + Math.imul(Ct, _r) | 0, ge = ge + Math.imul(w_, Yt) | 0, Ae = Ae + Math.imul(w_, _r) | 0;
      var tX = (Se + ke | 0) + ((ge & 8191) << 13) | 0;
      Se = (Ae + (ge >>> 13) | 0) + (tX >>> 26) | 0, tX &= 67108863, ke = Math.imul(Je, kX), ge = Math.imul(Je, qe), ge = ge + Math.imul(st, kX) | 0, Ae = Math.imul(st, qe), ke = ke + Math.imul(lt, Ve) | 0, ge = ge + Math.imul(lt, Ie) | 0, ge = ge + Math.imul(pt, Ve) | 0, Ae = Ae + Math.imul(pt, Ie) | 0, ke = ke + Math.imul(sX, Et) | 0, ge = ge + Math.imul(sX, xt) | 0, ge = ge + Math.imul(nX, Et) | 0, Ae = Ae + Math.imul(nX, xt) | 0, ke = ke + Math.imul(oX, Yt) | 0, ge = ge + Math.imul(oX, _r) | 0, ge = ge + Math.imul(Nn, Yt) | 0, Ae = Ae + Math.imul(Nn, _r) | 0;
      var An = (Se + ke | 0) + ((ge & 8191) << 13) | 0;
      Se = (Ae + (ge >>> 13) | 0) + (An >>> 26) | 0, An &= 67108863, ke = Math.imul(Je, Ve), ge = Math.imul(Je, Ie), ge = ge + Math.imul(st, Ve) | 0, Ae = Math.imul(st, Ie), ke = ke + Math.imul(lt, Et) | 0, ge = ge + Math.imul(lt, xt) | 0, ge = ge + Math.imul(pt, Et) | 0, Ae = Ae + Math.imul(pt, xt) | 0, ke = ke + Math.imul(sX, Yt) | 0, ge = ge + Math.imul(sX, _r) | 0, ge = ge + Math.imul(nX, Yt) | 0, Ae = Ae + Math.imul(nX, _r) | 0;
      var Gt = (Se + ke | 0) + ((ge & 8191) << 13) | 0;
      Se = (Ae + (ge >>> 13) | 0) + (Gt >>> 26) | 0, Gt &= 67108863, ke = Math.imul(Je, Et), ge = Math.imul(Je, xt), ge = ge + Math.imul(st, Et) | 0, Ae = Math.imul(st, xt), ke = ke + Math.imul(lt, Yt) | 0, ge = ge + Math.imul(lt, _r) | 0, ge = ge + Math.imul(pt, Yt) | 0, Ae = Ae + Math.imul(pt, _r) | 0;
      var Wt = (Se + ke | 0) + ((ge & 8191) << 13) | 0;
      Se = (Ae + (ge >>> 13) | 0) + (Wt >>> 26) | 0, Wt &= 67108863, ke = Math.imul(Je, Yt), ge = Math.imul(Je, _r), ge = ge + Math.imul(st, Yt) | 0, Ae = Math.imul(st, _r);
      var vr = (Se + ke | 0) + ((ge & 8191) << 13) | 0;
      return Se = (Ae + (ge >>> 13) | 0) + (vr >>> 26) | 0, vr &= 67108863, Pe[0] = cn, Pe[1] = _X, Pe[2] = un, Pe[3] = aX, Pe[4] = uX, Pe[5] = fX, Pe[6] = bX, Pe[7] = dX, Pe[8] = mX, Pe[9] = pX, Pe[10] = G_, Pe[11] = iX, Pe[12] = og, Pe[13] = eX, Pe[14] = tX, Pe[15] = An, Pe[16] = Gt, Pe[17] = Wt, Pe[18] = vr, Se !== 0 && (Pe[19] = Se, be.length++), be;
    };
    Math.imul || (Me = Ue);
    function De(fe, de, be) {
      be.negative = de.negative ^ fe.negative, be.length = fe.length + de.length;
      for (var Te = 0, Ce = 0, Pe = 0; Pe < be.length - 1; Pe++) {
        var Se = Ce;
        Ce = 0;
        for (var ke = Te & 67108863, ge = Math.min(Pe, de.length - 1), Ae = Math.max(0, Pe - fe.length + 1); Ae <= ge; Ae++) {
          var Ge = Pe - Ae, Xe = fe.words[Ge] | 0, $e = de.words[Ae] | 0, Ze = Xe * $e, ot = Ze & 67108863;
          Se = Se + (Ze / 67108864 | 0) | 0, ot = ot + ke | 0, ke = ot & 67108863, Se = Se + (ot >>> 26) | 0, Ce += Se >>> 26, Se &= 67108863;
        }
        be.words[Pe] = ke, Te = Se, Se = Ce;
      }
      return Te !== 0 ? be.words[Pe] = Te : be.length--, be._strip();
    }
    function Fe(fe, de, be) {
      return De(fe, de, be);
    }
    ie.prototype.mulTo = function(fe, de) {
      var be, Te = this.length + fe.length;
      return this.length === 10 && fe.length === 10 ? be = Me(this, fe, de) : Te < 63 ? be = Ue(this, fe, de) : Te < 1024 ? be = De(this, fe, de) : be = Fe(this, fe, de), be;
    }, ie.prototype.mul = function(fe) {
      var de = new ie(null);
      return de.words = new Array(this.length + fe.length), this.mulTo(fe, de);
    }, ie.prototype.mulf = function(fe) {
      var de = new ie(null);
      return de.words = new Array(this.length + fe.length), Fe(this, fe, de);
    }, ie.prototype.imul = function(fe) {
      return this.clone().mulTo(fe, this);
    }, ie.prototype.imuln = function(fe) {
      var de = fe < 0;
      de && (fe = -fe), te(typeof fe == "number"), te(fe < 67108864);
      for (var be = 0, Te = 0; Te < this.length; Te++) {
        var Ce = (this.words[Te] | 0) * fe, Pe = (Ce & 67108863) + (be & 67108863);
        be >>= 26, be += Ce / 67108864 | 0, be += Pe >>> 26, this.words[Te] = Pe & 67108863;
      }
      return be !== 0 && (this.words[Te] = be, this.length++), de ? this.ineg() : this;
    }, ie.prototype.muln = function(fe) {
      return this.clone().imuln(fe);
    }, ie.prototype.sqr = function() {
      return this.mul(this);
    }, ie.prototype.isqr = function() {
      return this.imul(this.clone());
    }, ie.prototype.pow = function(fe) {
      var de = Re(fe);
      if (de.length === 0)
        return new ie(1);
      for (var be = this, Te = 0; Te < de.length && de[Te] === 0; Te++, be = be.sqr())
        ;
      if (++Te < de.length)
        for (var Ce = be.sqr(); Te < de.length; Te++, Ce = Ce.sqr())
          de[Te] !== 0 && (be = be.mul(Ce));
      return be;
    }, ie.prototype.iushln = function(fe) {
      te(typeof fe == "number" && fe >= 0);
      var de = fe % 26, be = (fe - de) / 26, Te = 67108863 >>> 26 - de << 26 - de, Ce;
      if (de !== 0) {
        var Pe = 0;
        for (Ce = 0; Ce < this.length; Ce++) {
          var Se = this.words[Ce] & Te, ke = (this.words[Ce] | 0) - Se << de;
          this.words[Ce] = ke | Pe, Pe = Se >>> 26 - de;
        }
        Pe && (this.words[Ce] = Pe, this.length++);
      }
      if (be !== 0) {
        for (Ce = this.length - 1; Ce >= 0; Ce--)
          this.words[Ce + be] = this.words[Ce];
        for (Ce = 0; Ce < be; Ce++)
          this.words[Ce] = 0;
        this.length += be;
      }
      return this._strip();
    }, ie.prototype.ishln = function(fe) {
      return te(this.negative === 0), this.iushln(fe);
    }, ie.prototype.iushrn = function(fe, de, be) {
      te(typeof fe == "number" && fe >= 0);
      var Te;
      de ? Te = (de - de % 26) / 26 : Te = 0;
      var Ce = fe % 26, Pe = Math.min((fe - Ce) / 26, this.length), Se = 67108863 ^ 67108863 >>> Ce << Ce, ke = be;
      if (Te -= Pe, Te = Math.max(0, Te), ke) {
        for (var ge = 0; ge < Pe; ge++)
          ke.words[ge] = this.words[ge];
        ke.length = Pe;
      }
      if (Pe !== 0)
        if (this.length > Pe)
          for (this.length -= Pe, ge = 0; ge < this.length; ge++)
            this.words[ge] = this.words[ge + Pe];
        else
          this.words[0] = 0, this.length = 1;
      var Ae = 0;
      for (ge = this.length - 1; ge >= 0 && (Ae !== 0 || ge >= Te); ge--) {
        var Ge = this.words[ge] | 0;
        this.words[ge] = Ae << 26 - Ce | Ge >>> Ce, Ae = Ge & Se;
      }
      return ke && Ae !== 0 && (ke.words[ke.length++] = Ae), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
    }, ie.prototype.ishrn = function(fe, de, be) {
      return te(this.negative === 0), this.iushrn(fe, de, be);
    }, ie.prototype.shln = function(fe) {
      return this.clone().ishln(fe);
    }, ie.prototype.ushln = function(fe) {
      return this.clone().iushln(fe);
    }, ie.prototype.shrn = function(fe) {
      return this.clone().ishrn(fe);
    }, ie.prototype.ushrn = function(fe) {
      return this.clone().iushrn(fe);
    }, ie.prototype.testn = function(fe) {
      te(typeof fe == "number" && fe >= 0);
      var de = fe % 26, be = (fe - de) / 26, Te = 1 << de;
      if (this.length <= be)
        return !1;
      var Ce = this.words[be];
      return !!(Ce & Te);
    }, ie.prototype.imaskn = function(fe) {
      te(typeof fe == "number" && fe >= 0);
      var de = fe % 26, be = (fe - de) / 26;
      if (te(this.negative === 0, "imaskn works only with positive numbers"), this.length <= be)
        return this;
      if (de !== 0 && be++, this.length = Math.min(be, this.length), de !== 0) {
        var Te = 67108863 ^ 67108863 >>> de << de;
        this.words[this.length - 1] &= Te;
      }
      return this._strip();
    }, ie.prototype.maskn = function(fe) {
      return this.clone().imaskn(fe);
    }, ie.prototype.iaddn = function(fe) {
      return te(typeof fe == "number"), te(fe < 67108864), fe < 0 ? this.isubn(-fe) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= fe ? (this.words[0] = fe - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(fe), this.negative = 1, this) : this._iaddn(fe);
    }, ie.prototype._iaddn = function(fe) {
      this.words[0] += fe;
      for (var de = 0; de < this.length && this.words[de] >= 67108864; de++)
        this.words[de] -= 67108864, de === this.length - 1 ? this.words[de + 1] = 1 : this.words[de + 1]++;
      return this.length = Math.max(this.length, de + 1), this;
    }, ie.prototype.isubn = function(fe) {
      if (te(typeof fe == "number"), te(fe < 67108864), fe < 0)
        return this.iaddn(-fe);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(fe), this.negative = 1, this;
      if (this.words[0] -= fe, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var de = 0; de < this.length && this.words[de] < 0; de++)
          this.words[de] += 67108864, this.words[de + 1] -= 1;
      return this._strip();
    }, ie.prototype.addn = function(fe) {
      return this.clone().iaddn(fe);
    }, ie.prototype.subn = function(fe) {
      return this.clone().isubn(fe);
    }, ie.prototype.iabs = function() {
      return this.negative = 0, this;
    }, ie.prototype.abs = function() {
      return this.clone().iabs();
    }, ie.prototype._ishlnsubmul = function(fe, de, be) {
      var Te = fe.length + be, Ce;
      this._expand(Te);
      var Pe, Se = 0;
      for (Ce = 0; Ce < fe.length; Ce++) {
        Pe = (this.words[Ce + be] | 0) + Se;
        var ke = (fe.words[Ce] | 0) * de;
        Pe -= ke & 67108863, Se = (Pe >> 26) - (ke / 67108864 | 0), this.words[Ce + be] = Pe & 67108863;
      }
      for (; Ce < this.length - be; Ce++)
        Pe = (this.words[Ce + be] | 0) + Se, Se = Pe >> 26, this.words[Ce + be] = Pe & 67108863;
      if (Se === 0)
        return this._strip();
      for (te(Se === -1), Se = 0, Ce = 0; Ce < this.length; Ce++)
        Pe = -(this.words[Ce] | 0) + Se, Se = Pe >> 26, this.words[Ce] = Pe & 67108863;
      return this.negative = 1, this._strip();
    }, ie.prototype._wordDiv = function(fe, de) {
      var be = this.length - fe.length, Te = this.clone(), Ce = fe, Pe = Ce.words[Ce.length - 1] | 0, Se = this._countBits(Pe);
      be = 26 - Se, be !== 0 && (Ce = Ce.ushln(be), Te.iushln(be), Pe = Ce.words[Ce.length - 1] | 0);
      var ke = Te.length - Ce.length, ge;
      if (de !== "mod") {
        ge = new ie(null), ge.length = ke + 1, ge.words = new Array(ge.length);
        for (var Ae = 0; Ae < ge.length; Ae++)
          ge.words[Ae] = 0;
      }
      var Ge = Te.clone()._ishlnsubmul(Ce, 1, ke);
      Ge.negative === 0 && (Te = Ge, ge && (ge.words[ke] = 1));
      for (var Xe = ke - 1; Xe >= 0; Xe--) {
        var $e = (Te.words[Ce.length + Xe] | 0) * 67108864 + (Te.words[Ce.length + Xe - 1] | 0);
        for ($e = Math.min($e / Pe | 0, 67108863), Te._ishlnsubmul(Ce, $e, Xe); Te.negative !== 0; )
          $e--, Te.negative = 0, Te._ishlnsubmul(Ce, 1, Xe), Te.isZero() || (Te.negative ^= 1);
        ge && (ge.words[Xe] = $e);
      }
      return ge && ge._strip(), Te._strip(), de !== "div" && be !== 0 && Te.iushrn(be), {
        div: ge || null,
        mod: Te
      };
    }, ie.prototype.divmod = function(fe, de, be) {
      if (te(!fe.isZero()), this.isZero())
        return {
          div: new ie(0),
          mod: new ie(0)
        };
      var Te, Ce, Pe;
      return this.negative !== 0 && fe.negative === 0 ? (Pe = this.neg().divmod(fe, de), de !== "mod" && (Te = Pe.div.neg()), de !== "div" && (Ce = Pe.mod.neg(), be && Ce.negative !== 0 && Ce.iadd(fe)), {
        div: Te,
        mod: Ce
      }) : this.negative === 0 && fe.negative !== 0 ? (Pe = this.divmod(fe.neg(), de), de !== "mod" && (Te = Pe.div.neg()), {
        div: Te,
        mod: Pe.mod
      }) : this.negative & fe.negative ? (Pe = this.neg().divmod(fe.neg(), de), de !== "div" && (Ce = Pe.mod.neg(), be && Ce.negative !== 0 && Ce.isub(fe)), {
        div: Pe.div,
        mod: Ce
      }) : fe.length > this.length || this.cmp(fe) < 0 ? {
        div: new ie(0),
        mod: this
      } : fe.length === 1 ? de === "div" ? {
        div: this.divn(fe.words[0]),
        mod: null
      } : de === "mod" ? {
        div: null,
        mod: new ie(this.modrn(fe.words[0]))
      } : {
        div: this.divn(fe.words[0]),
        mod: new ie(this.modrn(fe.words[0]))
      } : this._wordDiv(fe, de);
    }, ie.prototype.div = function(fe) {
      return this.divmod(fe, "div", !1).div;
    }, ie.prototype.mod = function(fe) {
      return this.divmod(fe, "mod", !1).mod;
    }, ie.prototype.umod = function(fe) {
      return this.divmod(fe, "mod", !0).mod;
    }, ie.prototype.divRound = function(fe) {
      var de = this.divmod(fe);
      if (de.mod.isZero())
        return de.div;
      var be = de.div.negative !== 0 ? de.mod.isub(fe) : de.mod, Te = fe.ushrn(1), Ce = fe.andln(1), Pe = be.cmp(Te);
      return Pe < 0 || Ce === 1 && Pe === 0 ? de.div : de.div.negative !== 0 ? de.div.isubn(1) : de.div.iaddn(1);
    }, ie.prototype.modrn = function(fe) {
      var de = fe < 0;
      de && (fe = -fe), te(fe <= 67108863);
      for (var be = (1 << 26) % fe, Te = 0, Ce = this.length - 1; Ce >= 0; Ce--)
        Te = (be * Te + (this.words[Ce] | 0)) % fe;
      return de ? -Te : Te;
    }, ie.prototype.modn = function(fe) {
      return this.modrn(fe);
    }, ie.prototype.idivn = function(fe) {
      var de = fe < 0;
      de && (fe = -fe), te(fe <= 67108863);
      for (var be = 0, Te = this.length - 1; Te >= 0; Te--) {
        var Ce = (this.words[Te] | 0) + be * 67108864;
        this.words[Te] = Ce / fe | 0, be = Ce % fe;
      }
      return this._strip(), de ? this.ineg() : this;
    }, ie.prototype.divn = function(fe) {
      return this.clone().idivn(fe);
    }, ie.prototype.egcd = function(fe) {
      te(fe.negative === 0), te(!fe.isZero());
      var de = this, be = fe.clone();
      de.negative !== 0 ? de = de.umod(fe) : de = de.clone();
      for (var Te = new ie(1), Ce = new ie(0), Pe = new ie(0), Se = new ie(1), ke = 0; de.isEven() && be.isEven(); )
        de.iushrn(1), be.iushrn(1), ++ke;
      for (var ge = be.clone(), Ae = de.clone(); !de.isZero(); ) {
        for (var Ge = 0, Xe = 1; !(de.words[0] & Xe) && Ge < 26; ++Ge, Xe <<= 1)
          ;
        if (Ge > 0)
          for (de.iushrn(Ge); Ge-- > 0; )
            (Te.isOdd() || Ce.isOdd()) && (Te.iadd(ge), Ce.isub(Ae)), Te.iushrn(1), Ce.iushrn(1);
        for (var $e = 0, Ze = 1; !(be.words[0] & Ze) && $e < 26; ++$e, Ze <<= 1)
          ;
        if ($e > 0)
          for (be.iushrn($e); $e-- > 0; )
            (Pe.isOdd() || Se.isOdd()) && (Pe.iadd(ge), Se.isub(Ae)), Pe.iushrn(1), Se.iushrn(1);
        de.cmp(be) >= 0 ? (de.isub(be), Te.isub(Pe), Ce.isub(Se)) : (be.isub(de), Pe.isub(Te), Se.isub(Ce));
      }
      return {
        a: Pe,
        b: Se,
        gcd: be.iushln(ke)
      };
    }, ie.prototype._invmp = function(fe) {
      te(fe.negative === 0), te(!fe.isZero());
      var de = this, be = fe.clone();
      de.negative !== 0 ? de = de.umod(fe) : de = de.clone();
      for (var Te = new ie(1), Ce = new ie(0), Pe = be.clone(); de.cmpn(1) > 0 && be.cmpn(1) > 0; ) {
        for (var Se = 0, ke = 1; !(de.words[0] & ke) && Se < 26; ++Se, ke <<= 1)
          ;
        if (Se > 0)
          for (de.iushrn(Se); Se-- > 0; )
            Te.isOdd() && Te.iadd(Pe), Te.iushrn(1);
        for (var ge = 0, Ae = 1; !(be.words[0] & Ae) && ge < 26; ++ge, Ae <<= 1)
          ;
        if (ge > 0)
          for (be.iushrn(ge); ge-- > 0; )
            Ce.isOdd() && Ce.iadd(Pe), Ce.iushrn(1);
        de.cmp(be) >= 0 ? (de.isub(be), Te.isub(Ce)) : (be.isub(de), Ce.isub(Te));
      }
      var Ge;
      return de.cmpn(1) === 0 ? Ge = Te : Ge = Ce, Ge.cmpn(0) < 0 && Ge.iadd(fe), Ge;
    }, ie.prototype.gcd = function(fe) {
      if (this.isZero())
        return fe.abs();
      if (fe.isZero())
        return this.abs();
      var de = this.clone(), be = fe.clone();
      de.negative = 0, be.negative = 0;
      for (var Te = 0; de.isEven() && be.isEven(); Te++)
        de.iushrn(1), be.iushrn(1);
      do {
        for (; de.isEven(); )
          de.iushrn(1);
        for (; be.isEven(); )
          be.iushrn(1);
        var Ce = de.cmp(be);
        if (Ce < 0) {
          var Pe = de;
          de = be, be = Pe;
        } else if (Ce === 0 || be.cmpn(1) === 0)
          break;
        de.isub(be);
      } while (!0);
      return be.iushln(Te);
    }, ie.prototype.invm = function(fe) {
      return this.egcd(fe).a.umod(fe);
    }, ie.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, ie.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, ie.prototype.andln = function(fe) {
      return this.words[0] & fe;
    }, ie.prototype.bincn = function(fe) {
      te(typeof fe == "number");
      var de = fe % 26, be = (fe - de) / 26, Te = 1 << de;
      if (this.length <= be)
        return this._expand(be + 1), this.words[be] |= Te, this;
      for (var Ce = Te, Pe = be; Ce !== 0 && Pe < this.length; Pe++) {
        var Se = this.words[Pe] | 0;
        Se += Ce, Ce = Se >>> 26, Se &= 67108863, this.words[Pe] = Se;
      }
      return Ce !== 0 && (this.words[Pe] = Ce, this.length++), this;
    }, ie.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, ie.prototype.cmpn = function(fe) {
      var de = fe < 0;
      if (this.negative !== 0 && !de)
        return -1;
      if (this.negative === 0 && de)
        return 1;
      this._strip();
      var be;
      if (this.length > 1)
        be = 1;
      else {
        de && (fe = -fe), te(fe <= 67108863, "Number is too big");
        var Te = this.words[0] | 0;
        be = Te === fe ? 0 : Te < fe ? -1 : 1;
      }
      return this.negative !== 0 ? -be | 0 : be;
    }, ie.prototype.cmp = function(fe) {
      if (this.negative !== 0 && fe.negative === 0)
        return -1;
      if (this.negative === 0 && fe.negative !== 0)
        return 1;
      var de = this.ucmp(fe);
      return this.negative !== 0 ? -de | 0 : de;
    }, ie.prototype.ucmp = function(fe) {
      if (this.length > fe.length)
        return 1;
      if (this.length < fe.length)
        return -1;
      for (var de = 0, be = this.length - 1; be >= 0; be--) {
        var Te = this.words[be] | 0, Ce = fe.words[be] | 0;
        if (Te !== Ce) {
          Te < Ce ? de = -1 : Te > Ce && (de = 1);
          break;
        }
      }
      return de;
    }, ie.prototype.gtn = function(fe) {
      return this.cmpn(fe) === 1;
    }, ie.prototype.gt = function(fe) {
      return this.cmp(fe) === 1;
    }, ie.prototype.gten = function(fe) {
      return this.cmpn(fe) >= 0;
    }, ie.prototype.gte = function(fe) {
      return this.cmp(fe) >= 0;
    }, ie.prototype.ltn = function(fe) {
      return this.cmpn(fe) === -1;
    }, ie.prototype.lt = function(fe) {
      return this.cmp(fe) === -1;
    }, ie.prototype.lten = function(fe) {
      return this.cmpn(fe) <= 0;
    }, ie.prototype.lte = function(fe) {
      return this.cmp(fe) <= 0;
    }, ie.prototype.eqn = function(fe) {
      return this.cmpn(fe) === 0;
    }, ie.prototype.eq = function(fe) {
      return this.cmp(fe) === 0;
    }, ie.red = function(fe) {
      return new je(fe);
    }, ie.prototype.toRed = function(fe) {
      return te(!this.red, "Already a number in reduction context"), te(this.negative === 0, "red works only with positives"), fe.convertTo(this)._forceRed(fe);
    }, ie.prototype.fromRed = function() {
      return te(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, ie.prototype._forceRed = function(fe) {
      return this.red = fe, this;
    }, ie.prototype.forceRed = function(fe) {
      return te(!this.red, "Already a number in reduction context"), this._forceRed(fe);
    }, ie.prototype.redAdd = function(fe) {
      return te(this.red, "redAdd works only with red numbers"), this.red.add(this, fe);
    }, ie.prototype.redIAdd = function(fe) {
      return te(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, fe);
    }, ie.prototype.redSub = function(fe) {
      return te(this.red, "redSub works only with red numbers"), this.red.sub(this, fe);
    }, ie.prototype.redISub = function(fe) {
      return te(this.red, "redISub works only with red numbers"), this.red.isub(this, fe);
    }, ie.prototype.redShl = function(fe) {
      return te(this.red, "redShl works only with red numbers"), this.red.shl(this, fe);
    }, ie.prototype.redMul = function(fe) {
      return te(this.red, "redMul works only with red numbers"), this.red._verify2(this, fe), this.red.mul(this, fe);
    }, ie.prototype.redIMul = function(fe) {
      return te(this.red, "redMul works only with red numbers"), this.red._verify2(this, fe), this.red.imul(this, fe);
    }, ie.prototype.redSqr = function() {
      return te(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, ie.prototype.redISqr = function() {
      return te(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, ie.prototype.redSqrt = function() {
      return te(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, ie.prototype.redInvm = function() {
      return te(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, ie.prototype.redNeg = function() {
      return te(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, ie.prototype.redPow = function(fe) {
      return te(this.red && !fe.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, fe);
    };
    var Ke = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function tt(fe, de) {
      this.name = fe, this.p = new ie(de, 16), this.n = this.p.bitLength(), this.k = new ie(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    tt.prototype._tmp = function() {
      var fe = new ie(null);
      return fe.words = new Array(Math.ceil(this.n / 13)), fe;
    }, tt.prototype.ireduce = function(fe) {
      var de = fe, be;
      do
        this.split(de, this.tmp), de = this.imulK(de), de = de.iadd(this.tmp), be = de.bitLength();
      while (be > this.n);
      var Te = be < this.n ? -1 : de.ucmp(this.p);
      return Te === 0 ? (de.words[0] = 0, de.length = 1) : Te > 0 ? de.isub(this.p) : de.strip !== void 0 ? de.strip() : de._strip(), de;
    }, tt.prototype.split = function(fe, de) {
      fe.iushrn(this.n, 0, de);
    }, tt.prototype.imulK = function(fe) {
      return fe.imul(this.k);
    };
    function rt() {
      tt.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    ne(rt, tt), rt.prototype.split = function(fe, de) {
      for (var be = 4194303, Te = Math.min(fe.length, 9), Ce = 0; Ce < Te; Ce++)
        de.words[Ce] = fe.words[Ce];
      if (de.length = Te, fe.length <= 9) {
        fe.words[0] = 0, fe.length = 1;
        return;
      }
      var Pe = fe.words[9];
      for (de.words[de.length++] = Pe & be, Ce = 10; Ce < fe.length; Ce++) {
        var Se = fe.words[Ce] | 0;
        fe.words[Ce - 10] = (Se & be) << 4 | Pe >>> 22, Pe = Se;
      }
      Pe >>>= 22, fe.words[Ce - 10] = Pe, Pe === 0 && fe.length > 10 ? fe.length -= 10 : fe.length -= 9;
    }, rt.prototype.imulK = function(fe) {
      fe.words[fe.length] = 0, fe.words[fe.length + 1] = 0, fe.length += 2;
      for (var de = 0, be = 0; be < fe.length; be++) {
        var Te = fe.words[be] | 0;
        de += Te * 977, fe.words[be] = de & 67108863, de = Te * 64 + (de / 67108864 | 0);
      }
      return fe.words[fe.length - 1] === 0 && (fe.length--, fe.words[fe.length - 1] === 0 && fe.length--), fe;
    };
    function it() {
      tt.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    ne(it, tt);
    function _t() {
      tt.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    ne(_t, tt);
    function Dt() {
      tt.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    ne(Dt, tt), Dt.prototype.imulK = function(fe) {
      for (var de = 0, be = 0; be < fe.length; be++) {
        var Te = (fe.words[be] | 0) * 19 + de, Ce = Te & 67108863;
        Te >>>= 26, fe.words[be] = Ce, de = Te;
      }
      return de !== 0 && (fe.words[fe.length++] = de), fe;
    }, ie._prime = function(fe) {
      if (Ke[fe])
        return Ke[fe];
      var de;
      if (fe === "k256")
        de = new rt();
      else if (fe === "p224")
        de = new it();
      else if (fe === "p192")
        de = new _t();
      else if (fe === "p25519")
        de = new Dt();
      else
        throw new Error("Unknown prime " + fe);
      return Ke[fe] = de, de;
    };
    function je(fe) {
      if (typeof fe == "string") {
        var de = ie._prime(fe);
        this.m = de.p, this.prime = de;
      } else
        te(fe.gtn(1), "modulus must be greater than 1"), this.m = fe, this.prime = null;
    }
    je.prototype._verify1 = function(fe) {
      te(fe.negative === 0, "red works only with positives"), te(fe.red, "red works only with red numbers");
    }, je.prototype._verify2 = function(fe, de) {
      te((fe.negative | de.negative) === 0, "red works only with positives"), te(
        fe.red && fe.red === de.red,
        "red works only with red numbers"
      );
    }, je.prototype.imod = function(fe) {
      return this.prime ? this.prime.ireduce(fe)._forceRed(this) : (le(fe, fe.umod(this.m)._forceRed(this)), fe);
    }, je.prototype.neg = function(fe) {
      return fe.isZero() ? fe.clone() : this.m.sub(fe)._forceRed(this);
    }, je.prototype.add = function(fe, de) {
      this._verify2(fe, de);
      var be = fe.add(de);
      return be.cmp(this.m) >= 0 && be.isub(this.m), be._forceRed(this);
    }, je.prototype.iadd = function(fe, de) {
      this._verify2(fe, de);
      var be = fe.iadd(de);
      return be.cmp(this.m) >= 0 && be.isub(this.m), be;
    }, je.prototype.sub = function(fe, de) {
      this._verify2(fe, de);
      var be = fe.sub(de);
      return be.cmpn(0) < 0 && be.iadd(this.m), be._forceRed(this);
    }, je.prototype.isub = function(fe, de) {
      this._verify2(fe, de);
      var be = fe.isub(de);
      return be.cmpn(0) < 0 && be.iadd(this.m), be;
    }, je.prototype.shl = function(fe, de) {
      return this._verify1(fe), this.imod(fe.ushln(de));
    }, je.prototype.imul = function(fe, de) {
      return this._verify2(fe, de), this.imod(fe.imul(de));
    }, je.prototype.mul = function(fe, de) {
      return this._verify2(fe, de), this.imod(fe.mul(de));
    }, je.prototype.isqr = function(fe) {
      return this.imul(fe, fe.clone());
    }, je.prototype.sqr = function(fe) {
      return this.mul(fe, fe);
    }, je.prototype.sqrt = function(fe) {
      if (fe.isZero())
        return fe.clone();
      var de = this.m.andln(3);
      if (te(de % 2 === 1), de === 3) {
        var be = this.m.add(new ie(1)).iushrn(2);
        return this.pow(fe, be);
      }
      for (var Te = this.m.subn(1), Ce = 0; !Te.isZero() && Te.andln(1) === 0; )
        Ce++, Te.iushrn(1);
      te(!Te.isZero());
      var Pe = new ie(1).toRed(this), Se = Pe.redNeg(), ke = this.m.subn(1).iushrn(1), ge = this.m.bitLength();
      for (ge = new ie(2 * ge * ge).toRed(this); this.pow(ge, ke).cmp(Se) !== 0; )
        ge.redIAdd(Se);
      for (var Ae = this.pow(ge, Te), Ge = this.pow(fe, Te.addn(1).iushrn(1)), Xe = this.pow(fe, Te), $e = Ce; Xe.cmp(Pe) !== 0; ) {
        for (var Ze = Xe, ot = 0; Ze.cmp(Pe) !== 0; ot++)
          Ze = Ze.redSqr();
        te(ot < $e);
        var ct = this.pow(Ae, new ie(1).iushln($e - ot - 1));
        Ge = Ge.redMul(ct), Ae = ct.redSqr(), Xe = Xe.redMul(Ae), $e = ot;
      }
      return Ge;
    }, je.prototype.invm = function(fe) {
      var de = fe._invmp(this.m);
      return de.negative !== 0 ? (de.negative = 0, this.imod(de).redNeg()) : this.imod(de);
    }, je.prototype.pow = function(fe, de) {
      if (de.isZero())
        return new ie(1).toRed(this);
      if (de.cmpn(1) === 0)
        return fe.clone();
      var be = 4, Te = new Array(1 << be);
      Te[0] = new ie(1).toRed(this), Te[1] = fe;
      for (var Ce = 2; Ce < Te.length; Ce++)
        Te[Ce] = this.mul(Te[Ce - 1], fe);
      var Pe = Te[0], Se = 0, ke = 0, ge = de.bitLength() % 26;
      for (ge === 0 && (ge = 26), Ce = de.length - 1; Ce >= 0; Ce--) {
        for (var Ae = de.words[Ce], Ge = ge - 1; Ge >= 0; Ge--) {
          var Xe = Ae >> Ge & 1;
          if (Pe !== Te[0] && (Pe = this.sqr(Pe)), Xe === 0 && Se === 0) {
            ke = 0;
            continue;
          }
          Se <<= 1, Se |= Xe, ke++, !(ke !== be && (Ce !== 0 || Ge !== 0)) && (Pe = this.mul(Pe, Te[Se]), ke = 0, Se = 0);
        }
        ge = 26;
      }
      return Pe;
    }, je.prototype.convertTo = function(fe) {
      var de = fe.umod(this.m);
      return de === fe ? de.clone() : de;
    }, je.prototype.convertFrom = function(fe) {
      var de = fe.clone();
      return de.red = null, de;
    }, ie.mont = function(fe) {
      return new ze(fe);
    };
    function ze(fe) {
      je.call(this, fe), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new ie(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    ne(ze, je), ze.prototype.convertTo = function(fe) {
      return this.imod(fe.ushln(this.shift));
    }, ze.prototype.convertFrom = function(fe) {
      var de = this.imod(fe.mul(this.rinv));
      return de.red = null, de;
    }, ze.prototype.imul = function(fe, de) {
      if (fe.isZero() || de.isZero())
        return fe.words[0] = 0, fe.length = 1, fe;
      var be = fe.imul(de), Te = be.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), Ce = be.isub(Te).iushrn(this.shift), Pe = Ce;
      return Ce.cmp(this.m) >= 0 ? Pe = Ce.isub(this.m) : Ce.cmpn(0) < 0 && (Pe = Ce.iadd(this.m)), Pe._forceRed(this);
    }, ze.prototype.mul = function(fe, de) {
      if (fe.isZero() || de.isZero())
        return new ie(0)._forceRed(this);
      var be = fe.mul(de), Te = be.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), Ce = be.isub(Te).iushrn(this.shift), Pe = Ce;
      return Ce.cmp(this.m) >= 0 ? Pe = Ce.isub(this.m) : Ce.cmpn(0) < 0 && (Pe = Ce.iadd(this.m)), Pe._forceRed(this);
    }, ze.prototype.invm = function(fe) {
      var de = this.imod(fe._invmp(this.m).mul(this.r2));
      return de._forceRed(this);
    };
  })(Y, commonjsGlobal);
})(bn);
var bnExports = bn.exports;
const BN = /* @__PURE__ */ getDefaultExportFromCjs$2(bnExports);
var browserifyRsa, hasRequiredBrowserifyRsa;
function requireBrowserifyRsa() {
  if (hasRequiredBrowserifyRsa)
    return browserifyRsa;
  hasRequiredBrowserifyRsa = 1;
  var Y = bnExports, X = requireBrowser$9();
  function ee(ie) {
    var oe = te(ie), se = oe.toRed(Y.mont(ie.modulus)).redPow(new Y(ie.publicExponent)).fromRed();
    return { blinder: se, unblinder: oe.invm(ie.modulus) };
  }
  function te(ie) {
    var oe = ie.modulus.byteLength(), se;
    do
      se = new Y(X(oe));
    while (se.cmp(ie.modulus) >= 0 || !se.umod(ie.prime1) || !se.umod(ie.prime2));
    return se;
  }
  function ne(ie, oe) {
    var se = ee(oe), ae = oe.modulus.byteLength(), ue = new Y(ie).mul(se.blinder).umod(oe.modulus), le = ue.toRed(Y.mont(oe.prime1)), he = ue.toRed(Y.mont(oe.prime2)), me = oe.coefficient, ye = oe.prime1, we = oe.prime2, Ee = le.redPow(oe.exponent1).fromRed(), Re = he.redPow(oe.exponent2).fromRed(), Ue = Ee.isub(Re).imul(me).umod(ye).imul(we);
    return Re.iadd(Ue).imul(se.unblinder).umod(oe.modulus).toArrayLike(Buffer$e, "be", ae);
  }
  return ne.getr = te, browserifyRsa = ne, browserifyRsa;
}
var elliptic = {};
const name = "elliptic", version$1 = "6.5.4", description = "EC cryptography", main = "lib/elliptic.js", files = [
  "lib"
], scripts = {
  lint: "eslint lib test",
  "lint:fix": "npm run lint -- --fix",
  unit: "istanbul test _mocha --reporter=spec test/index.js",
  test: "npm run lint && npm run unit",
  version: "grunt dist && git add dist/"
}, repository = {
  type: "git",
  url: "git@github.com:indutny/elliptic"
}, keywords = [
  "EC",
  "Elliptic",
  "curve",
  "Cryptography"
], author = "Fedor Indutny <fedor@indutny.com>", license = "MIT", bugs = {
  url: "https://github.com/indutny/elliptic/issues"
}, homepage = "https://github.com/indutny/elliptic", devDependencies = {
  brfs: "^2.0.2",
  coveralls: "^3.1.0",
  eslint: "^7.6.0",
  grunt: "^1.2.1",
  "grunt-browserify": "^5.3.0",
  "grunt-cli": "^1.3.2",
  "grunt-contrib-connect": "^3.0.0",
  "grunt-contrib-copy": "^1.0.0",
  "grunt-contrib-uglify": "^5.0.0",
  "grunt-mocha-istanbul": "^5.0.2",
  "grunt-saucelabs": "^9.0.1",
  istanbul: "^0.4.5",
  mocha: "^8.0.1"
}, dependencies = {
  "bn.js": "^4.11.9",
  brorand: "^1.1.0",
  "hash.js": "^1.0.0",
  "hmac-drbg": "^1.0.1",
  inherits: "^2.0.4",
  "minimalistic-assert": "^1.0.1",
  "minimalistic-crypto-utils": "^1.0.1"
}, require$$0$2 = {
  name,
  version: version$1,
  description,
  main,
  files,
  scripts,
  repository,
  keywords,
  author,
  license,
  bugs,
  homepage,
  devDependencies,
  dependencies
};
var utils$5 = {}, utils$4 = {}, hasRequiredUtils$3;
function requireUtils$3() {
  return hasRequiredUtils$3 || (hasRequiredUtils$3 = 1, function(Y) {
    var X = Y;
    function ee(ie, oe) {
      if (Array.isArray(ie))
        return ie.slice();
      if (!ie)
        return [];
      var se = [];
      if (typeof ie != "string") {
        for (var ae = 0; ae < ie.length; ae++)
          se[ae] = ie[ae] | 0;
        return se;
      }
      if (oe === "hex") {
        ie = ie.replace(/[^a-z0-9]+/ig, ""), ie.length % 2 !== 0 && (ie = "0" + ie);
        for (var ae = 0; ae < ie.length; ae += 2)
          se.push(parseInt(ie[ae] + ie[ae + 1], 16));
      } else
        for (var ae = 0; ae < ie.length; ae++) {
          var ue = ie.charCodeAt(ae), le = ue >> 8, he = ue & 255;
          le ? se.push(le, he) : se.push(he);
        }
      return se;
    }
    X.toArray = ee;
    function te(ie) {
      return ie.length === 1 ? "0" + ie : ie;
    }
    X.zero2 = te;
    function ne(ie) {
      for (var oe = "", se = 0; se < ie.length; se++)
        oe += te(ie[se].toString(16));
      return oe;
    }
    X.toHex = ne, X.encode = function(ie, oe) {
      return oe === "hex" ? ne(ie) : ie;
    };
  }(utils$4)), utils$4;
}
var hasRequiredUtils$2;
function requireUtils$2() {
  return hasRequiredUtils$2 || (hasRequiredUtils$2 = 1, function(Y) {
    var X = Y, ee = requireBn(), te = requireMinimalisticAssert(), ne = requireUtils$3();
    X.assert = te, X.toArray = ne.toArray, X.zero2 = ne.zero2, X.toHex = ne.toHex, X.encode = ne.encode;
    function ie(le, he, me) {
      var ye = new Array(Math.max(le.bitLength(), me) + 1);
      ye.fill(0);
      for (var we = 1 << he + 1, Ee = le.clone(), Re = 0; Re < ye.length; Re++) {
        var Ue, Me = Ee.andln(we - 1);
        Ee.isOdd() ? (Me > (we >> 1) - 1 ? Ue = (we >> 1) - Me : Ue = Me, Ee.isubn(Ue)) : Ue = 0, ye[Re] = Ue, Ee.iushrn(1);
      }
      return ye;
    }
    X.getNAF = ie;
    function oe(le, he) {
      var me = [
        [],
        []
      ];
      le = le.clone(), he = he.clone();
      for (var ye = 0, we = 0, Ee; le.cmpn(-ye) > 0 || he.cmpn(-we) > 0; ) {
        var Re = le.andln(3) + ye & 3, Ue = he.andln(3) + we & 3;
        Re === 3 && (Re = -1), Ue === 3 && (Ue = -1);
        var Me;
        Re & 1 ? (Ee = le.andln(7) + ye & 7, (Ee === 3 || Ee === 5) && Ue === 2 ? Me = -Re : Me = Re) : Me = 0, me[0].push(Me);
        var De;
        Ue & 1 ? (Ee = he.andln(7) + we & 7, (Ee === 3 || Ee === 5) && Re === 2 ? De = -Ue : De = Ue) : De = 0, me[1].push(De), 2 * ye === Me + 1 && (ye = 1 - ye), 2 * we === De + 1 && (we = 1 - we), le.iushrn(1), he.iushrn(1);
      }
      return me;
    }
    X.getJSF = oe;
    function se(le, he, me) {
      var ye = "_" + he;
      le.prototype[he] = function() {
        return this[ye] !== void 0 ? this[ye] : this[ye] = me.call(this);
      };
    }
    X.cachedProperty = se;
    function ae(le) {
      return typeof le == "string" ? X.toArray(le, "hex") : le;
    }
    X.parseBytes = ae;
    function ue(le) {
      return new ee(le, "hex", "le");
    }
    X.intFromLE = ue;
  }(utils$5)), utils$5;
}
var curve = {}, base$3, hasRequiredBase$1;
function requireBase$1() {
  if (hasRequiredBase$1)
    return base$3;
  hasRequiredBase$1 = 1;
  var Y = requireBn(), X = requireUtils$2(), ee = X.getNAF, te = X.getJSF, ne = X.assert;
  function ie(se, ae) {
    this.type = se, this.p = new Y(ae.p, 16), this.red = ae.prime ? Y.red(ae.prime) : Y.mont(this.p), this.zero = new Y(0).toRed(this.red), this.one = new Y(1).toRed(this.red), this.two = new Y(2).toRed(this.red), this.n = ae.n && new Y(ae.n, 16), this.g = ae.g && this.pointFromJSON(ae.g, ae.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
    var ue = this.n && this.p.div(this.n);
    !ue || ue.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = !0, this.redN = this.n.toRed(this.red));
  }
  base$3 = ie, ie.prototype.point = function() {
    throw new Error("Not implemented");
  }, ie.prototype.validate = function() {
    throw new Error("Not implemented");
  }, ie.prototype._fixedNafMul = function(se, ae) {
    ne(se.precomputed);
    var ue = se._getDoubles(), le = ee(ae, 1, this._bitLength), he = (1 << ue.step + 1) - (ue.step % 2 === 0 ? 2 : 1);
    he /= 3;
    var me = [], ye, we;
    for (ye = 0; ye < le.length; ye += ue.step) {
      we = 0;
      for (var Ee = ye + ue.step - 1; Ee >= ye; Ee--)
        we = (we << 1) + le[Ee];
      me.push(we);
    }
    for (var Re = this.jpoint(null, null, null), Ue = this.jpoint(null, null, null), Me = he; Me > 0; Me--) {
      for (ye = 0; ye < me.length; ye++)
        we = me[ye], we === Me ? Ue = Ue.mixedAdd(ue.points[ye]) : we === -Me && (Ue = Ue.mixedAdd(ue.points[ye].neg()));
      Re = Re.add(Ue);
    }
    return Re.toP();
  }, ie.prototype._wnafMul = function(se, ae) {
    var ue = 4, le = se._getNAFPoints(ue);
    ue = le.wnd;
    for (var he = le.points, me = ee(ae, ue, this._bitLength), ye = this.jpoint(null, null, null), we = me.length - 1; we >= 0; we--) {
      for (var Ee = 0; we >= 0 && me[we] === 0; we--)
        Ee++;
      if (we >= 0 && Ee++, ye = ye.dblp(Ee), we < 0)
        break;
      var Re = me[we];
      ne(Re !== 0), se.type === "affine" ? Re > 0 ? ye = ye.mixedAdd(he[Re - 1 >> 1]) : ye = ye.mixedAdd(he[-Re - 1 >> 1].neg()) : Re > 0 ? ye = ye.add(he[Re - 1 >> 1]) : ye = ye.add(he[-Re - 1 >> 1].neg());
    }
    return se.type === "affine" ? ye.toP() : ye;
  }, ie.prototype._wnafMulAdd = function(se, ae, ue, le, he) {
    var me = this._wnafT1, ye = this._wnafT2, we = this._wnafT3, Ee = 0, Re, Ue, Me;
    for (Re = 0; Re < le; Re++) {
      Me = ae[Re];
      var De = Me._getNAFPoints(se);
      me[Re] = De.wnd, ye[Re] = De.points;
    }
    for (Re = le - 1; Re >= 1; Re -= 2) {
      var Fe = Re - 1, Ke = Re;
      if (me[Fe] !== 1 || me[Ke] !== 1) {
        we[Fe] = ee(ue[Fe], me[Fe], this._bitLength), we[Ke] = ee(ue[Ke], me[Ke], this._bitLength), Ee = Math.max(we[Fe].length, Ee), Ee = Math.max(we[Ke].length, Ee);
        continue;
      }
      var tt = [
        ae[Fe],
        /* 1 */
        null,
        /* 3 */
        null,
        /* 5 */
        ae[Ke]
        /* 7 */
      ];
      ae[Fe].y.cmp(ae[Ke].y) === 0 ? (tt[1] = ae[Fe].add(ae[Ke]), tt[2] = ae[Fe].toJ().mixedAdd(ae[Ke].neg())) : ae[Fe].y.cmp(ae[Ke].y.redNeg()) === 0 ? (tt[1] = ae[Fe].toJ().mixedAdd(ae[Ke]), tt[2] = ae[Fe].add(ae[Ke].neg())) : (tt[1] = ae[Fe].toJ().mixedAdd(ae[Ke]), tt[2] = ae[Fe].toJ().mixedAdd(ae[Ke].neg()));
      var rt = [
        -3,
        /* -1 -1 */
        -1,
        /* -1 0 */
        -5,
        /* -1 1 */
        -7,
        /* 0 -1 */
        0,
        /* 0 0 */
        7,
        /* 0 1 */
        5,
        /* 1 -1 */
        1,
        /* 1 0 */
        3
        /* 1 1 */
      ], it = te(ue[Fe], ue[Ke]);
      for (Ee = Math.max(it[0].length, Ee), we[Fe] = new Array(Ee), we[Ke] = new Array(Ee), Ue = 0; Ue < Ee; Ue++) {
        var _t = it[0][Ue] | 0, Dt = it[1][Ue] | 0;
        we[Fe][Ue] = rt[(_t + 1) * 3 + (Dt + 1)], we[Ke][Ue] = 0, ye[Fe] = tt;
      }
    }
    var je = this.jpoint(null, null, null), ze = this._wnafT4;
    for (Re = Ee; Re >= 0; Re--) {
      for (var fe = 0; Re >= 0; ) {
        var de = !0;
        for (Ue = 0; Ue < le; Ue++)
          ze[Ue] = we[Ue][Re] | 0, ze[Ue] !== 0 && (de = !1);
        if (!de)
          break;
        fe++, Re--;
      }
      if (Re >= 0 && fe++, je = je.dblp(fe), Re < 0)
        break;
      for (Ue = 0; Ue < le; Ue++) {
        var be = ze[Ue];
        be !== 0 && (be > 0 ? Me = ye[Ue][be - 1 >> 1] : be < 0 && (Me = ye[Ue][-be - 1 >> 1].neg()), Me.type === "affine" ? je = je.mixedAdd(Me) : je = je.add(Me));
      }
    }
    for (Re = 0; Re < le; Re++)
      ye[Re] = null;
    return he ? je : je.toP();
  };
  function oe(se, ae) {
    this.curve = se, this.type = ae, this.precomputed = null;
  }
  return ie.BasePoint = oe, oe.prototype.eq = function() {
    throw new Error("Not implemented");
  }, oe.prototype.validate = function() {
    return this.curve.validate(this);
  }, ie.prototype.decodePoint = function(se, ae) {
    se = X.toArray(se, ae);
    var ue = this.p.byteLength();
    if ((se[0] === 4 || se[0] === 6 || se[0] === 7) && se.length - 1 === 2 * ue) {
      se[0] === 6 ? ne(se[se.length - 1] % 2 === 0) : se[0] === 7 && ne(se[se.length - 1] % 2 === 1);
      var le = this.point(
        se.slice(1, 1 + ue),
        se.slice(1 + ue, 1 + 2 * ue)
      );
      return le;
    } else if ((se[0] === 2 || se[0] === 3) && se.length - 1 === ue)
      return this.pointFromX(se.slice(1, 1 + ue), se[0] === 3);
    throw new Error("Unknown point format");
  }, oe.prototype.encodeCompressed = function(se) {
    return this.encode(se, !0);
  }, oe.prototype._encode = function(se) {
    var ae = this.curve.p.byteLength(), ue = this.getX().toArray("be", ae);
    return se ? [this.getY().isEven() ? 2 : 3].concat(ue) : [4].concat(ue, this.getY().toArray("be", ae));
  }, oe.prototype.encode = function(se, ae) {
    return X.encode(this._encode(ae), se);
  }, oe.prototype.precompute = function(se) {
    if (this.precomputed)
      return this;
    var ae = {
      doubles: null,
      naf: null,
      beta: null
    };
    return ae.naf = this._getNAFPoints(8), ae.doubles = this._getDoubles(4, se), ae.beta = this._getBeta(), this.precomputed = ae, this;
  }, oe.prototype._hasDoubles = function(se) {
    if (!this.precomputed)
      return !1;
    var ae = this.precomputed.doubles;
    return ae ? ae.points.length >= Math.ceil((se.bitLength() + 1) / ae.step) : !1;
  }, oe.prototype._getDoubles = function(se, ae) {
    if (this.precomputed && this.precomputed.doubles)
      return this.precomputed.doubles;
    for (var ue = [this], le = this, he = 0; he < ae; he += se) {
      for (var me = 0; me < se; me++)
        le = le.dbl();
      ue.push(le);
    }
    return {
      step: se,
      points: ue
    };
  }, oe.prototype._getNAFPoints = function(se) {
    if (this.precomputed && this.precomputed.naf)
      return this.precomputed.naf;
    for (var ae = [this], ue = (1 << se) - 1, le = ue === 1 ? null : this.dbl(), he = 1; he < ue; he++)
      ae[he] = ae[he - 1].add(le);
    return {
      wnd: se,
      points: ae
    };
  }, oe.prototype._getBeta = function() {
    return null;
  }, oe.prototype.dblp = function(se) {
    for (var ae = this, ue = 0; ue < se; ue++)
      ae = ae.dbl();
    return ae;
  }, base$3;
}
var short, hasRequiredShort;
function requireShort() {
  if (hasRequiredShort)
    return short;
  hasRequiredShort = 1;
  var Y = requireUtils$2(), X = requireBn(), ee = inherits_browserExports, te = requireBase$1(), ne = Y.assert;
  function ie(ae) {
    te.call(this, "short", ae), this.a = new X(ae.a, 16).toRed(this.red), this.b = new X(ae.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(ae), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);
  }
  ee(ie, te), short = ie, ie.prototype._getEndomorphism = function(ae) {
    if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
      var ue, le;
      if (ae.beta)
        ue = new X(ae.beta, 16).toRed(this.red);
      else {
        var he = this._getEndoRoots(this.p);
        ue = he[0].cmp(he[1]) < 0 ? he[0] : he[1], ue = ue.toRed(this.red);
      }
      if (ae.lambda)
        le = new X(ae.lambda, 16);
      else {
        var me = this._getEndoRoots(this.n);
        this.g.mul(me[0]).x.cmp(this.g.x.redMul(ue)) === 0 ? le = me[0] : (le = me[1], ne(this.g.mul(le).x.cmp(this.g.x.redMul(ue)) === 0));
      }
      var ye;
      return ae.basis ? ye = ae.basis.map(function(we) {
        return {
          a: new X(we.a, 16),
          b: new X(we.b, 16)
        };
      }) : ye = this._getEndoBasis(le), {
        beta: ue,
        lambda: le,
        basis: ye
      };
    }
  }, ie.prototype._getEndoRoots = function(ae) {
    var ue = ae === this.p ? this.red : X.mont(ae), le = new X(2).toRed(ue).redInvm(), he = le.redNeg(), me = new X(3).toRed(ue).redNeg().redSqrt().redMul(le), ye = he.redAdd(me).fromRed(), we = he.redSub(me).fromRed();
    return [ye, we];
  }, ie.prototype._getEndoBasis = function(ae) {
    for (var ue = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), le = ae, he = this.n.clone(), me = new X(1), ye = new X(0), we = new X(0), Ee = new X(1), Re, Ue, Me, De, Fe, Ke, tt, rt = 0, it, _t; le.cmpn(0) !== 0; ) {
      var Dt = he.div(le);
      it = he.sub(Dt.mul(le)), _t = we.sub(Dt.mul(me));
      var je = Ee.sub(Dt.mul(ye));
      if (!Me && it.cmp(ue) < 0)
        Re = tt.neg(), Ue = me, Me = it.neg(), De = _t;
      else if (Me && ++rt === 2)
        break;
      tt = it, he = le, le = it, we = me, me = _t, Ee = ye, ye = je;
    }
    Fe = it.neg(), Ke = _t;
    var ze = Me.sqr().add(De.sqr()), fe = Fe.sqr().add(Ke.sqr());
    return fe.cmp(ze) >= 0 && (Fe = Re, Ke = Ue), Me.negative && (Me = Me.neg(), De = De.neg()), Fe.negative && (Fe = Fe.neg(), Ke = Ke.neg()), [
      { a: Me, b: De },
      { a: Fe, b: Ke }
    ];
  }, ie.prototype._endoSplit = function(ae) {
    var ue = this.endo.basis, le = ue[0], he = ue[1], me = he.b.mul(ae).divRound(this.n), ye = le.b.neg().mul(ae).divRound(this.n), we = me.mul(le.a), Ee = ye.mul(he.a), Re = me.mul(le.b), Ue = ye.mul(he.b), Me = ae.sub(we).sub(Ee), De = Re.add(Ue).neg();
    return { k1: Me, k2: De };
  }, ie.prototype.pointFromX = function(ae, ue) {
    ae = new X(ae, 16), ae.red || (ae = ae.toRed(this.red));
    var le = ae.redSqr().redMul(ae).redIAdd(ae.redMul(this.a)).redIAdd(this.b), he = le.redSqrt();
    if (he.redSqr().redSub(le).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    var me = he.fromRed().isOdd();
    return (ue && !me || !ue && me) && (he = he.redNeg()), this.point(ae, he);
  }, ie.prototype.validate = function(ae) {
    if (ae.inf)
      return !0;
    var ue = ae.x, le = ae.y, he = this.a.redMul(ue), me = ue.redSqr().redMul(ue).redIAdd(he).redIAdd(this.b);
    return le.redSqr().redISub(me).cmpn(0) === 0;
  }, ie.prototype._endoWnafMulAdd = function(ae, ue, le) {
    for (var he = this._endoWnafT1, me = this._endoWnafT2, ye = 0; ye < ae.length; ye++) {
      var we = this._endoSplit(ue[ye]), Ee = ae[ye], Re = Ee._getBeta();
      we.k1.negative && (we.k1.ineg(), Ee = Ee.neg(!0)), we.k2.negative && (we.k2.ineg(), Re = Re.neg(!0)), he[ye * 2] = Ee, he[ye * 2 + 1] = Re, me[ye * 2] = we.k1, me[ye * 2 + 1] = we.k2;
    }
    for (var Ue = this._wnafMulAdd(1, he, me, ye * 2, le), Me = 0; Me < ye * 2; Me++)
      he[Me] = null, me[Me] = null;
    return Ue;
  };
  function oe(ae, ue, le, he) {
    te.BasePoint.call(this, ae, "affine"), ue === null && le === null ? (this.x = null, this.y = null, this.inf = !0) : (this.x = new X(ue, 16), this.y = new X(le, 16), he && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1);
  }
  ee(oe, te.BasePoint), ie.prototype.point = function(ae, ue, le) {
    return new oe(this, ae, ue, le);
  }, ie.prototype.pointFromJSON = function(ae, ue) {
    return oe.fromJSON(this, ae, ue);
  }, oe.prototype._getBeta = function() {
    if (this.curve.endo) {
      var ae = this.precomputed;
      if (ae && ae.beta)
        return ae.beta;
      var ue = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
      if (ae) {
        var le = this.curve, he = function(me) {
          return le.point(me.x.redMul(le.endo.beta), me.y);
        };
        ae.beta = ue, ue.precomputed = {
          beta: null,
          naf: ae.naf && {
            wnd: ae.naf.wnd,
            points: ae.naf.points.map(he)
          },
          doubles: ae.doubles && {
            step: ae.doubles.step,
            points: ae.doubles.points.map(he)
          }
        };
      }
      return ue;
    }
  }, oe.prototype.toJSON = function() {
    return this.precomputed ? [this.x, this.y, this.precomputed && {
      doubles: this.precomputed.doubles && {
        step: this.precomputed.doubles.step,
        points: this.precomputed.doubles.points.slice(1)
      },
      naf: this.precomputed.naf && {
        wnd: this.precomputed.naf.wnd,
        points: this.precomputed.naf.points.slice(1)
      }
    }] : [this.x, this.y];
  }, oe.fromJSON = function(ae, ue, le) {
    typeof ue == "string" && (ue = JSON.parse(ue));
    var he = ae.point(ue[0], ue[1], le);
    if (!ue[2])
      return he;
    function me(we) {
      return ae.point(we[0], we[1], le);
    }
    var ye = ue[2];
    return he.precomputed = {
      beta: null,
      doubles: ye.doubles && {
        step: ye.doubles.step,
        points: [he].concat(ye.doubles.points.map(me))
      },
      naf: ye.naf && {
        wnd: ye.naf.wnd,
        points: [he].concat(ye.naf.points.map(me))
      }
    }, he;
  }, oe.prototype.inspect = function() {
    return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
  }, oe.prototype.isInfinity = function() {
    return this.inf;
  }, oe.prototype.add = function(ae) {
    if (this.inf)
      return ae;
    if (ae.inf)
      return this;
    if (this.eq(ae))
      return this.dbl();
    if (this.neg().eq(ae))
      return this.curve.point(null, null);
    if (this.x.cmp(ae.x) === 0)
      return this.curve.point(null, null);
    var ue = this.y.redSub(ae.y);
    ue.cmpn(0) !== 0 && (ue = ue.redMul(this.x.redSub(ae.x).redInvm()));
    var le = ue.redSqr().redISub(this.x).redISub(ae.x), he = ue.redMul(this.x.redSub(le)).redISub(this.y);
    return this.curve.point(le, he);
  }, oe.prototype.dbl = function() {
    if (this.inf)
      return this;
    var ae = this.y.redAdd(this.y);
    if (ae.cmpn(0) === 0)
      return this.curve.point(null, null);
    var ue = this.curve.a, le = this.x.redSqr(), he = ae.redInvm(), me = le.redAdd(le).redIAdd(le).redIAdd(ue).redMul(he), ye = me.redSqr().redISub(this.x.redAdd(this.x)), we = me.redMul(this.x.redSub(ye)).redISub(this.y);
    return this.curve.point(ye, we);
  }, oe.prototype.getX = function() {
    return this.x.fromRed();
  }, oe.prototype.getY = function() {
    return this.y.fromRed();
  }, oe.prototype.mul = function(ae) {
    return ae = new X(ae, 16), this.isInfinity() ? this : this._hasDoubles(ae) ? this.curve._fixedNafMul(this, ae) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [ae]) : this.curve._wnafMul(this, ae);
  }, oe.prototype.mulAdd = function(ae, ue, le) {
    var he = [this, ue], me = [ae, le];
    return this.curve.endo ? this.curve._endoWnafMulAdd(he, me) : this.curve._wnafMulAdd(1, he, me, 2);
  }, oe.prototype.jmulAdd = function(ae, ue, le) {
    var he = [this, ue], me = [ae, le];
    return this.curve.endo ? this.curve._endoWnafMulAdd(he, me, !0) : this.curve._wnafMulAdd(1, he, me, 2, !0);
  }, oe.prototype.eq = function(ae) {
    return this === ae || this.inf === ae.inf && (this.inf || this.x.cmp(ae.x) === 0 && this.y.cmp(ae.y) === 0);
  }, oe.prototype.neg = function(ae) {
    if (this.inf)
      return this;
    var ue = this.curve.point(this.x, this.y.redNeg());
    if (ae && this.precomputed) {
      var le = this.precomputed, he = function(me) {
        return me.neg();
      };
      ue.precomputed = {
        naf: le.naf && {
          wnd: le.naf.wnd,
          points: le.naf.points.map(he)
        },
        doubles: le.doubles && {
          step: le.doubles.step,
          points: le.doubles.points.map(he)
        }
      };
    }
    return ue;
  }, oe.prototype.toJ = function() {
    if (this.inf)
      return this.curve.jpoint(null, null, null);
    var ae = this.curve.jpoint(this.x, this.y, this.curve.one);
    return ae;
  };
  function se(ae, ue, le, he) {
    te.BasePoint.call(this, ae, "jacobian"), ue === null && le === null && he === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new X(0)) : (this.x = new X(ue, 16), this.y = new X(le, 16), this.z = new X(he, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;
  }
  return ee(se, te.BasePoint), ie.prototype.jpoint = function(ae, ue, le) {
    return new se(this, ae, ue, le);
  }, se.prototype.toP = function() {
    if (this.isInfinity())
      return this.curve.point(null, null);
    var ae = this.z.redInvm(), ue = ae.redSqr(), le = this.x.redMul(ue), he = this.y.redMul(ue).redMul(ae);
    return this.curve.point(le, he);
  }, se.prototype.neg = function() {
    return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
  }, se.prototype.add = function(ae) {
    if (this.isInfinity())
      return ae;
    if (ae.isInfinity())
      return this;
    var ue = ae.z.redSqr(), le = this.z.redSqr(), he = this.x.redMul(ue), me = ae.x.redMul(le), ye = this.y.redMul(ue.redMul(ae.z)), we = ae.y.redMul(le.redMul(this.z)), Ee = he.redSub(me), Re = ye.redSub(we);
    if (Ee.cmpn(0) === 0)
      return Re.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
    var Ue = Ee.redSqr(), Me = Ue.redMul(Ee), De = he.redMul(Ue), Fe = Re.redSqr().redIAdd(Me).redISub(De).redISub(De), Ke = Re.redMul(De.redISub(Fe)).redISub(ye.redMul(Me)), tt = this.z.redMul(ae.z).redMul(Ee);
    return this.curve.jpoint(Fe, Ke, tt);
  }, se.prototype.mixedAdd = function(ae) {
    if (this.isInfinity())
      return ae.toJ();
    if (ae.isInfinity())
      return this;
    var ue = this.z.redSqr(), le = this.x, he = ae.x.redMul(ue), me = this.y, ye = ae.y.redMul(ue).redMul(this.z), we = le.redSub(he), Ee = me.redSub(ye);
    if (we.cmpn(0) === 0)
      return Ee.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
    var Re = we.redSqr(), Ue = Re.redMul(we), Me = le.redMul(Re), De = Ee.redSqr().redIAdd(Ue).redISub(Me).redISub(Me), Fe = Ee.redMul(Me.redISub(De)).redISub(me.redMul(Ue)), Ke = this.z.redMul(we);
    return this.curve.jpoint(De, Fe, Ke);
  }, se.prototype.dblp = function(ae) {
    if (ae === 0)
      return this;
    if (this.isInfinity())
      return this;
    if (!ae)
      return this.dbl();
    var ue;
    if (this.curve.zeroA || this.curve.threeA) {
      var le = this;
      for (ue = 0; ue < ae; ue++)
        le = le.dbl();
      return le;
    }
    var he = this.curve.a, me = this.curve.tinv, ye = this.x, we = this.y, Ee = this.z, Re = Ee.redSqr().redSqr(), Ue = we.redAdd(we);
    for (ue = 0; ue < ae; ue++) {
      var Me = ye.redSqr(), De = Ue.redSqr(), Fe = De.redSqr(), Ke = Me.redAdd(Me).redIAdd(Me).redIAdd(he.redMul(Re)), tt = ye.redMul(De), rt = Ke.redSqr().redISub(tt.redAdd(tt)), it = tt.redISub(rt), _t = Ke.redMul(it);
      _t = _t.redIAdd(_t).redISub(Fe);
      var Dt = Ue.redMul(Ee);
      ue + 1 < ae && (Re = Re.redMul(Fe)), ye = rt, Ee = Dt, Ue = _t;
    }
    return this.curve.jpoint(ye, Ue.redMul(me), Ee);
  }, se.prototype.dbl = function() {
    return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();
  }, se.prototype._zeroDbl = function() {
    var ae, ue, le;
    if (this.zOne) {
      var he = this.x.redSqr(), me = this.y.redSqr(), ye = me.redSqr(), we = this.x.redAdd(me).redSqr().redISub(he).redISub(ye);
      we = we.redIAdd(we);
      var Ee = he.redAdd(he).redIAdd(he), Re = Ee.redSqr().redISub(we).redISub(we), Ue = ye.redIAdd(ye);
      Ue = Ue.redIAdd(Ue), Ue = Ue.redIAdd(Ue), ae = Re, ue = Ee.redMul(we.redISub(Re)).redISub(Ue), le = this.y.redAdd(this.y);
    } else {
      var Me = this.x.redSqr(), De = this.y.redSqr(), Fe = De.redSqr(), Ke = this.x.redAdd(De).redSqr().redISub(Me).redISub(Fe);
      Ke = Ke.redIAdd(Ke);
      var tt = Me.redAdd(Me).redIAdd(Me), rt = tt.redSqr(), it = Fe.redIAdd(Fe);
      it = it.redIAdd(it), it = it.redIAdd(it), ae = rt.redISub(Ke).redISub(Ke), ue = tt.redMul(Ke.redISub(ae)).redISub(it), le = this.y.redMul(this.z), le = le.redIAdd(le);
    }
    return this.curve.jpoint(ae, ue, le);
  }, se.prototype._threeDbl = function() {
    var ae, ue, le;
    if (this.zOne) {
      var he = this.x.redSqr(), me = this.y.redSqr(), ye = me.redSqr(), we = this.x.redAdd(me).redSqr().redISub(he).redISub(ye);
      we = we.redIAdd(we);
      var Ee = he.redAdd(he).redIAdd(he).redIAdd(this.curve.a), Re = Ee.redSqr().redISub(we).redISub(we);
      ae = Re;
      var Ue = ye.redIAdd(ye);
      Ue = Ue.redIAdd(Ue), Ue = Ue.redIAdd(Ue), ue = Ee.redMul(we.redISub(Re)).redISub(Ue), le = this.y.redAdd(this.y);
    } else {
      var Me = this.z.redSqr(), De = this.y.redSqr(), Fe = this.x.redMul(De), Ke = this.x.redSub(Me).redMul(this.x.redAdd(Me));
      Ke = Ke.redAdd(Ke).redIAdd(Ke);
      var tt = Fe.redIAdd(Fe);
      tt = tt.redIAdd(tt);
      var rt = tt.redAdd(tt);
      ae = Ke.redSqr().redISub(rt), le = this.y.redAdd(this.z).redSqr().redISub(De).redISub(Me);
      var it = De.redSqr();
      it = it.redIAdd(it), it = it.redIAdd(it), it = it.redIAdd(it), ue = Ke.redMul(tt.redISub(ae)).redISub(it);
    }
    return this.curve.jpoint(ae, ue, le);
  }, se.prototype._dbl = function() {
    var ae = this.curve.a, ue = this.x, le = this.y, he = this.z, me = he.redSqr().redSqr(), ye = ue.redSqr(), we = le.redSqr(), Ee = ye.redAdd(ye).redIAdd(ye).redIAdd(ae.redMul(me)), Re = ue.redAdd(ue);
    Re = Re.redIAdd(Re);
    var Ue = Re.redMul(we), Me = Ee.redSqr().redISub(Ue.redAdd(Ue)), De = Ue.redISub(Me), Fe = we.redSqr();
    Fe = Fe.redIAdd(Fe), Fe = Fe.redIAdd(Fe), Fe = Fe.redIAdd(Fe);
    var Ke = Ee.redMul(De).redISub(Fe), tt = le.redAdd(le).redMul(he);
    return this.curve.jpoint(Me, Ke, tt);
  }, se.prototype.trpl = function() {
    if (!this.curve.zeroA)
      return this.dbl().add(this);
    var ae = this.x.redSqr(), ue = this.y.redSqr(), le = this.z.redSqr(), he = ue.redSqr(), me = ae.redAdd(ae).redIAdd(ae), ye = me.redSqr(), we = this.x.redAdd(ue).redSqr().redISub(ae).redISub(he);
    we = we.redIAdd(we), we = we.redAdd(we).redIAdd(we), we = we.redISub(ye);
    var Ee = we.redSqr(), Re = he.redIAdd(he);
    Re = Re.redIAdd(Re), Re = Re.redIAdd(Re), Re = Re.redIAdd(Re);
    var Ue = me.redIAdd(we).redSqr().redISub(ye).redISub(Ee).redISub(Re), Me = ue.redMul(Ue);
    Me = Me.redIAdd(Me), Me = Me.redIAdd(Me);
    var De = this.x.redMul(Ee).redISub(Me);
    De = De.redIAdd(De), De = De.redIAdd(De);
    var Fe = this.y.redMul(Ue.redMul(Re.redISub(Ue)).redISub(we.redMul(Ee)));
    Fe = Fe.redIAdd(Fe), Fe = Fe.redIAdd(Fe), Fe = Fe.redIAdd(Fe);
    var Ke = this.z.redAdd(we).redSqr().redISub(le).redISub(Ee);
    return this.curve.jpoint(De, Fe, Ke);
  }, se.prototype.mul = function(ae, ue) {
    return ae = new X(ae, ue), this.curve._wnafMul(this, ae);
  }, se.prototype.eq = function(ae) {
    if (ae.type === "affine")
      return this.eq(ae.toJ());
    if (this === ae)
      return !0;
    var ue = this.z.redSqr(), le = ae.z.redSqr();
    if (this.x.redMul(le).redISub(ae.x.redMul(ue)).cmpn(0) !== 0)
      return !1;
    var he = ue.redMul(this.z), me = le.redMul(ae.z);
    return this.y.redMul(me).redISub(ae.y.redMul(he)).cmpn(0) === 0;
  }, se.prototype.eqXToP = function(ae) {
    var ue = this.z.redSqr(), le = ae.toRed(this.curve.red).redMul(ue);
    if (this.x.cmp(le) === 0)
      return !0;
    for (var he = ae.clone(), me = this.curve.redN.redMul(ue); ; ) {
      if (he.iadd(this.curve.n), he.cmp(this.curve.p) >= 0)
        return !1;
      if (le.redIAdd(me), this.x.cmp(le) === 0)
        return !0;
    }
  }, se.prototype.inspect = function() {
    return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
  }, se.prototype.isInfinity = function() {
    return this.z.cmpn(0) === 0;
  }, short;
}
var mont, hasRequiredMont;
function requireMont() {
  if (hasRequiredMont)
    return mont;
  hasRequiredMont = 1;
  var Y = requireBn(), X = inherits_browserExports, ee = requireBase$1(), te = requireUtils$2();
  function ne(oe) {
    ee.call(this, "mont", oe), this.a = new Y(oe.a, 16).toRed(this.red), this.b = new Y(oe.b, 16).toRed(this.red), this.i4 = new Y(4).toRed(this.red).redInvm(), this.two = new Y(2).toRed(this.red), this.a24 = this.i4.redMul(this.a.redAdd(this.two));
  }
  X(ne, ee), mont = ne, ne.prototype.validate = function(oe) {
    var se = oe.normalize().x, ae = se.redSqr(), ue = ae.redMul(se).redAdd(ae.redMul(this.a)).redAdd(se), le = ue.redSqrt();
    return le.redSqr().cmp(ue) === 0;
  };
  function ie(oe, se, ae) {
    ee.BasePoint.call(this, oe, "projective"), se === null && ae === null ? (this.x = this.curve.one, this.z = this.curve.zero) : (this.x = new Y(se, 16), this.z = new Y(ae, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)));
  }
  return X(ie, ee.BasePoint), ne.prototype.decodePoint = function(oe, se) {
    return this.point(te.toArray(oe, se), 1);
  }, ne.prototype.point = function(oe, se) {
    return new ie(this, oe, se);
  }, ne.prototype.pointFromJSON = function(oe) {
    return ie.fromJSON(this, oe);
  }, ie.prototype.precompute = function() {
  }, ie.prototype._encode = function() {
    return this.getX().toArray("be", this.curve.p.byteLength());
  }, ie.fromJSON = function(oe, se) {
    return new ie(oe, se[0], se[1] || oe.one);
  }, ie.prototype.inspect = function() {
    return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
  }, ie.prototype.isInfinity = function() {
    return this.z.cmpn(0) === 0;
  }, ie.prototype.dbl = function() {
    var oe = this.x.redAdd(this.z), se = oe.redSqr(), ae = this.x.redSub(this.z), ue = ae.redSqr(), le = se.redSub(ue), he = se.redMul(ue), me = le.redMul(ue.redAdd(this.curve.a24.redMul(le)));
    return this.curve.point(he, me);
  }, ie.prototype.add = function() {
    throw new Error("Not supported on Montgomery curve");
  }, ie.prototype.diffAdd = function(oe, se) {
    var ae = this.x.redAdd(this.z), ue = this.x.redSub(this.z), le = oe.x.redAdd(oe.z), he = oe.x.redSub(oe.z), me = he.redMul(ae), ye = le.redMul(ue), we = se.z.redMul(me.redAdd(ye).redSqr()), Ee = se.x.redMul(me.redISub(ye).redSqr());
    return this.curve.point(we, Ee);
  }, ie.prototype.mul = function(oe) {
    for (var se = oe.clone(), ae = this, ue = this.curve.point(null, null), le = this, he = []; se.cmpn(0) !== 0; se.iushrn(1))
      he.push(se.andln(1));
    for (var me = he.length - 1; me >= 0; me--)
      he[me] === 0 ? (ae = ae.diffAdd(ue, le), ue = ue.dbl()) : (ue = ae.diffAdd(ue, le), ae = ae.dbl());
    return ue;
  }, ie.prototype.mulAdd = function() {
    throw new Error("Not supported on Montgomery curve");
  }, ie.prototype.jumlAdd = function() {
    throw new Error("Not supported on Montgomery curve");
  }, ie.prototype.eq = function(oe) {
    return this.getX().cmp(oe.getX()) === 0;
  }, ie.prototype.normalize = function() {
    return this.x = this.x.redMul(this.z.redInvm()), this.z = this.curve.one, this;
  }, ie.prototype.getX = function() {
    return this.normalize(), this.x.fromRed();
  }, mont;
}
var edwards, hasRequiredEdwards;
function requireEdwards() {
  if (hasRequiredEdwards)
    return edwards;
  hasRequiredEdwards = 1;
  var Y = requireUtils$2(), X = requireBn(), ee = inherits_browserExports, te = requireBase$1(), ne = Y.assert;
  function ie(se) {
    this.twisted = (se.a | 0) !== 1, this.mOneA = this.twisted && (se.a | 0) === -1, this.extended = this.mOneA, te.call(this, "edwards", se), this.a = new X(se.a, 16).umod(this.red.m), this.a = this.a.toRed(this.red), this.c = new X(se.c, 16).toRed(this.red), this.c2 = this.c.redSqr(), this.d = new X(se.d, 16).toRed(this.red), this.dd = this.d.redAdd(this.d), ne(!this.twisted || this.c.fromRed().cmpn(1) === 0), this.oneC = (se.c | 0) === 1;
  }
  ee(ie, te), edwards = ie, ie.prototype._mulA = function(se) {
    return this.mOneA ? se.redNeg() : this.a.redMul(se);
  }, ie.prototype._mulC = function(se) {
    return this.oneC ? se : this.c.redMul(se);
  }, ie.prototype.jpoint = function(se, ae, ue, le) {
    return this.point(se, ae, ue, le);
  }, ie.prototype.pointFromX = function(se, ae) {
    se = new X(se, 16), se.red || (se = se.toRed(this.red));
    var ue = se.redSqr(), le = this.c2.redSub(this.a.redMul(ue)), he = this.one.redSub(this.c2.redMul(this.d).redMul(ue)), me = le.redMul(he.redInvm()), ye = me.redSqrt();
    if (ye.redSqr().redSub(me).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    var we = ye.fromRed().isOdd();
    return (ae && !we || !ae && we) && (ye = ye.redNeg()), this.point(se, ye);
  }, ie.prototype.pointFromY = function(se, ae) {
    se = new X(se, 16), se.red || (se = se.toRed(this.red));
    var ue = se.redSqr(), le = ue.redSub(this.c2), he = ue.redMul(this.d).redMul(this.c2).redSub(this.a), me = le.redMul(he.redInvm());
    if (me.cmp(this.zero) === 0) {
      if (ae)
        throw new Error("invalid point");
      return this.point(this.zero, se);
    }
    var ye = me.redSqrt();
    if (ye.redSqr().redSub(me).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    return ye.fromRed().isOdd() !== ae && (ye = ye.redNeg()), this.point(ye, se);
  }, ie.prototype.validate = function(se) {
    if (se.isInfinity())
      return !0;
    se.normalize();
    var ae = se.x.redSqr(), ue = se.y.redSqr(), le = ae.redMul(this.a).redAdd(ue), he = this.c2.redMul(this.one.redAdd(this.d.redMul(ae).redMul(ue)));
    return le.cmp(he) === 0;
  };
  function oe(se, ae, ue, le, he) {
    te.BasePoint.call(this, se, "projective"), ae === null && ue === null && le === null ? (this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = !0) : (this.x = new X(ae, 16), this.y = new X(ue, 16), this.z = le ? new X(le, 16) : this.curve.one, this.t = he && new X(he, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)), this.zOne = this.z === this.curve.one, this.curve.extended && !this.t && (this.t = this.x.redMul(this.y), this.zOne || (this.t = this.t.redMul(this.z.redInvm()))));
  }
  return ee(oe, te.BasePoint), ie.prototype.pointFromJSON = function(se) {
    return oe.fromJSON(this, se);
  }, ie.prototype.point = function(se, ae, ue, le) {
    return new oe(this, se, ae, ue, le);
  }, oe.fromJSON = function(se, ae) {
    return new oe(se, ae[0], ae[1], ae[2]);
  }, oe.prototype.inspect = function() {
    return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
  }, oe.prototype.isInfinity = function() {
    return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
  }, oe.prototype._extDbl = function() {
    var se = this.x.redSqr(), ae = this.y.redSqr(), ue = this.z.redSqr();
    ue = ue.redIAdd(ue);
    var le = this.curve._mulA(se), he = this.x.redAdd(this.y).redSqr().redISub(se).redISub(ae), me = le.redAdd(ae), ye = me.redSub(ue), we = le.redSub(ae), Ee = he.redMul(ye), Re = me.redMul(we), Ue = he.redMul(we), Me = ye.redMul(me);
    return this.curve.point(Ee, Re, Me, Ue);
  }, oe.prototype._projDbl = function() {
    var se = this.x.redAdd(this.y).redSqr(), ae = this.x.redSqr(), ue = this.y.redSqr(), le, he, me, ye, we, Ee;
    if (this.curve.twisted) {
      ye = this.curve._mulA(ae);
      var Re = ye.redAdd(ue);
      this.zOne ? (le = se.redSub(ae).redSub(ue).redMul(Re.redSub(this.curve.two)), he = Re.redMul(ye.redSub(ue)), me = Re.redSqr().redSub(Re).redSub(Re)) : (we = this.z.redSqr(), Ee = Re.redSub(we).redISub(we), le = se.redSub(ae).redISub(ue).redMul(Ee), he = Re.redMul(ye.redSub(ue)), me = Re.redMul(Ee));
    } else
      ye = ae.redAdd(ue), we = this.curve._mulC(this.z).redSqr(), Ee = ye.redSub(we).redSub(we), le = this.curve._mulC(se.redISub(ye)).redMul(Ee), he = this.curve._mulC(ye).redMul(ae.redISub(ue)), me = ye.redMul(Ee);
    return this.curve.point(le, he, me);
  }, oe.prototype.dbl = function() {
    return this.isInfinity() ? this : this.curve.extended ? this._extDbl() : this._projDbl();
  }, oe.prototype._extAdd = function(se) {
    var ae = this.y.redSub(this.x).redMul(se.y.redSub(se.x)), ue = this.y.redAdd(this.x).redMul(se.y.redAdd(se.x)), le = this.t.redMul(this.curve.dd).redMul(se.t), he = this.z.redMul(se.z.redAdd(se.z)), me = ue.redSub(ae), ye = he.redSub(le), we = he.redAdd(le), Ee = ue.redAdd(ae), Re = me.redMul(ye), Ue = we.redMul(Ee), Me = me.redMul(Ee), De = ye.redMul(we);
    return this.curve.point(Re, Ue, De, Me);
  }, oe.prototype._projAdd = function(se) {
    var ae = this.z.redMul(se.z), ue = ae.redSqr(), le = this.x.redMul(se.x), he = this.y.redMul(se.y), me = this.curve.d.redMul(le).redMul(he), ye = ue.redSub(me), we = ue.redAdd(me), Ee = this.x.redAdd(this.y).redMul(se.x.redAdd(se.y)).redISub(le).redISub(he), Re = ae.redMul(ye).redMul(Ee), Ue, Me;
    return this.curve.twisted ? (Ue = ae.redMul(we).redMul(he.redSub(this.curve._mulA(le))), Me = ye.redMul(we)) : (Ue = ae.redMul(we).redMul(he.redSub(le)), Me = this.curve._mulC(ye).redMul(we)), this.curve.point(Re, Ue, Me);
  }, oe.prototype.add = function(se) {
    return this.isInfinity() ? se : se.isInfinity() ? this : this.curve.extended ? this._extAdd(se) : this._projAdd(se);
  }, oe.prototype.mul = function(se) {
    return this._hasDoubles(se) ? this.curve._fixedNafMul(this, se) : this.curve._wnafMul(this, se);
  }, oe.prototype.mulAdd = function(se, ae, ue) {
    return this.curve._wnafMulAdd(1, [this, ae], [se, ue], 2, !1);
  }, oe.prototype.jmulAdd = function(se, ae, ue) {
    return this.curve._wnafMulAdd(1, [this, ae], [se, ue], 2, !0);
  }, oe.prototype.normalize = function() {
    if (this.zOne)
      return this;
    var se = this.z.redInvm();
    return this.x = this.x.redMul(se), this.y = this.y.redMul(se), this.t && (this.t = this.t.redMul(se)), this.z = this.curve.one, this.zOne = !0, this;
  }, oe.prototype.neg = function() {
    return this.curve.point(
      this.x.redNeg(),
      this.y,
      this.z,
      this.t && this.t.redNeg()
    );
  }, oe.prototype.getX = function() {
    return this.normalize(), this.x.fromRed();
  }, oe.prototype.getY = function() {
    return this.normalize(), this.y.fromRed();
  }, oe.prototype.eq = function(se) {
    return this === se || this.getX().cmp(se.getX()) === 0 && this.getY().cmp(se.getY()) === 0;
  }, oe.prototype.eqXToP = function(se) {
    var ae = se.toRed(this.curve.red).redMul(this.z);
    if (this.x.cmp(ae) === 0)
      return !0;
    for (var ue = se.clone(), le = this.curve.redN.redMul(this.z); ; ) {
      if (ue.iadd(this.curve.n), ue.cmp(this.curve.p) >= 0)
        return !1;
      if (ae.redIAdd(le), this.x.cmp(ae) === 0)
        return !0;
    }
  }, oe.prototype.toP = oe.prototype.normalize, oe.prototype.mixedAdd = oe.prototype.add, edwards;
}
var hasRequiredCurve;
function requireCurve() {
  return hasRequiredCurve || (hasRequiredCurve = 1, function(Y) {
    var X = Y;
    X.base = requireBase$1(), X.short = requireShort(), X.mont = requireMont(), X.edwards = requireEdwards();
  }(curve)), curve;
}
var curves = {}, hash$2 = {}, utils$3 = {}, hasRequiredUtils$1;
function requireUtils$1() {
  if (hasRequiredUtils$1)
    return utils$3;
  hasRequiredUtils$1 = 1;
  var Y = requireMinimalisticAssert(), X = inherits_browserExports;
  utils$3.inherits = X;
  function ee(ze, fe) {
    return (ze.charCodeAt(fe) & 64512) !== 55296 || fe < 0 || fe + 1 >= ze.length ? !1 : (ze.charCodeAt(fe + 1) & 64512) === 56320;
  }
  function te(ze, fe) {
    if (Array.isArray(ze))
      return ze.slice();
    if (!ze)
      return [];
    var de = [];
    if (typeof ze == "string")
      if (fe) {
        if (fe === "hex")
          for (ze = ze.replace(/[^a-z0-9]+/ig, ""), ze.length % 2 !== 0 && (ze = "0" + ze), Te = 0; Te < ze.length; Te += 2)
            de.push(parseInt(ze[Te] + ze[Te + 1], 16));
      } else
        for (var be = 0, Te = 0; Te < ze.length; Te++) {
          var Ce = ze.charCodeAt(Te);
          Ce < 128 ? de[be++] = Ce : Ce < 2048 ? (de[be++] = Ce >> 6 | 192, de[be++] = Ce & 63 | 128) : ee(ze, Te) ? (Ce = 65536 + ((Ce & 1023) << 10) + (ze.charCodeAt(++Te) & 1023), de[be++] = Ce >> 18 | 240, de[be++] = Ce >> 12 & 63 | 128, de[be++] = Ce >> 6 & 63 | 128, de[be++] = Ce & 63 | 128) : (de[be++] = Ce >> 12 | 224, de[be++] = Ce >> 6 & 63 | 128, de[be++] = Ce & 63 | 128);
        }
    else
      for (Te = 0; Te < ze.length; Te++)
        de[Te] = ze[Te] | 0;
    return de;
  }
  utils$3.toArray = te;
  function ne(ze) {
    for (var fe = "", de = 0; de < ze.length; de++)
      fe += se(ze[de].toString(16));
    return fe;
  }
  utils$3.toHex = ne;
  function ie(ze) {
    var fe = ze >>> 24 | ze >>> 8 & 65280 | ze << 8 & 16711680 | (ze & 255) << 24;
    return fe >>> 0;
  }
  utils$3.htonl = ie;
  function oe(ze, fe) {
    for (var de = "", be = 0; be < ze.length; be++) {
      var Te = ze[be];
      fe === "little" && (Te = ie(Te)), de += ae(Te.toString(16));
    }
    return de;
  }
  utils$3.toHex32 = oe;
  function se(ze) {
    return ze.length === 1 ? "0" + ze : ze;
  }
  utils$3.zero2 = se;
  function ae(ze) {
    return ze.length === 7 ? "0" + ze : ze.length === 6 ? "00" + ze : ze.length === 5 ? "000" + ze : ze.length === 4 ? "0000" + ze : ze.length === 3 ? "00000" + ze : ze.length === 2 ? "000000" + ze : ze.length === 1 ? "0000000" + ze : ze;
  }
  utils$3.zero8 = ae;
  function ue(ze, fe, de, be) {
    var Te = de - fe;
    Y(Te % 4 === 0);
    for (var Ce = new Array(Te / 4), Pe = 0, Se = fe; Pe < Ce.length; Pe++, Se += 4) {
      var ke;
      be === "big" ? ke = ze[Se] << 24 | ze[Se + 1] << 16 | ze[Se + 2] << 8 | ze[Se + 3] : ke = ze[Se + 3] << 24 | ze[Se + 2] << 16 | ze[Se + 1] << 8 | ze[Se], Ce[Pe] = ke >>> 0;
    }
    return Ce;
  }
  utils$3.join32 = ue;
  function le(ze, fe) {
    for (var de = new Array(ze.length * 4), be = 0, Te = 0; be < ze.length; be++, Te += 4) {
      var Ce = ze[be];
      fe === "big" ? (de[Te] = Ce >>> 24, de[Te + 1] = Ce >>> 16 & 255, de[Te + 2] = Ce >>> 8 & 255, de[Te + 3] = Ce & 255) : (de[Te + 3] = Ce >>> 24, de[Te + 2] = Ce >>> 16 & 255, de[Te + 1] = Ce >>> 8 & 255, de[Te] = Ce & 255);
    }
    return de;
  }
  utils$3.split32 = le;
  function he(ze, fe) {
    return ze >>> fe | ze << 32 - fe;
  }
  utils$3.rotr32 = he;
  function me(ze, fe) {
    return ze << fe | ze >>> 32 - fe;
  }
  utils$3.rotl32 = me;
  function ye(ze, fe) {
    return ze + fe >>> 0;
  }
  utils$3.sum32 = ye;
  function we(ze, fe, de) {
    return ze + fe + de >>> 0;
  }
  utils$3.sum32_3 = we;
  function Ee(ze, fe, de, be) {
    return ze + fe + de + be >>> 0;
  }
  utils$3.sum32_4 = Ee;
  function Re(ze, fe, de, be, Te) {
    return ze + fe + de + be + Te >>> 0;
  }
  utils$3.sum32_5 = Re;
  function Ue(ze, fe, de, be) {
    var Te = ze[fe], Ce = ze[fe + 1], Pe = be + Ce >>> 0, Se = (Pe < be ? 1 : 0) + de + Te;
    ze[fe] = Se >>> 0, ze[fe + 1] = Pe;
  }
  utils$3.sum64 = Ue;
  function Me(ze, fe, de, be) {
    var Te = fe + be >>> 0, Ce = (Te < fe ? 1 : 0) + ze + de;
    return Ce >>> 0;
  }
  utils$3.sum64_hi = Me;
  function De(ze, fe, de, be) {
    var Te = fe + be;
    return Te >>> 0;
  }
  utils$3.sum64_lo = De;
  function Fe(ze, fe, de, be, Te, Ce, Pe, Se) {
    var ke = 0, ge = fe;
    ge = ge + be >>> 0, ke += ge < fe ? 1 : 0, ge = ge + Ce >>> 0, ke += ge < Ce ? 1 : 0, ge = ge + Se >>> 0, ke += ge < Se ? 1 : 0;
    var Ae = ze + de + Te + Pe + ke;
    return Ae >>> 0;
  }
  utils$3.sum64_4_hi = Fe;
  function Ke(ze, fe, de, be, Te, Ce, Pe, Se) {
    var ke = fe + be + Ce + Se;
    return ke >>> 0;
  }
  utils$3.sum64_4_lo = Ke;
  function tt(ze, fe, de, be, Te, Ce, Pe, Se, ke, ge) {
    var Ae = 0, Ge = fe;
    Ge = Ge + be >>> 0, Ae += Ge < fe ? 1 : 0, Ge = Ge + Ce >>> 0, Ae += Ge < Ce ? 1 : 0, Ge = Ge + Se >>> 0, Ae += Ge < Se ? 1 : 0, Ge = Ge + ge >>> 0, Ae += Ge < ge ? 1 : 0;
    var Xe = ze + de + Te + Pe + ke + Ae;
    return Xe >>> 0;
  }
  utils$3.sum64_5_hi = tt;
  function rt(ze, fe, de, be, Te, Ce, Pe, Se, ke, ge) {
    var Ae = fe + be + Ce + Se + ge;
    return Ae >>> 0;
  }
  utils$3.sum64_5_lo = rt;
  function it(ze, fe, de) {
    var be = fe << 32 - de | ze >>> de;
    return be >>> 0;
  }
  utils$3.rotr64_hi = it;
  function _t(ze, fe, de) {
    var be = ze << 32 - de | fe >>> de;
    return be >>> 0;
  }
  utils$3.rotr64_lo = _t;
  function Dt(ze, fe, de) {
    return ze >>> de;
  }
  utils$3.shr64_hi = Dt;
  function je(ze, fe, de) {
    var be = ze << 32 - de | fe >>> de;
    return be >>> 0;
  }
  return utils$3.shr64_lo = je, utils$3;
}
var common$1 = {}, hasRequiredCommon$1;
function requireCommon$1() {
  if (hasRequiredCommon$1)
    return common$1;
  hasRequiredCommon$1 = 1;
  var Y = requireUtils$1(), X = requireMinimalisticAssert();
  function ee() {
    this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;
  }
  return common$1.BlockHash = ee, ee.prototype.update = function(te, ne) {
    if (te = Y.toArray(te, ne), this.pending ? this.pending = this.pending.concat(te) : this.pending = te, this.pendingTotal += te.length, this.pending.length >= this._delta8) {
      te = this.pending;
      var ie = te.length % this._delta8;
      this.pending = te.slice(te.length - ie, te.length), this.pending.length === 0 && (this.pending = null), te = Y.join32(te, 0, te.length - ie, this.endian);
      for (var oe = 0; oe < te.length; oe += this._delta32)
        this._update(te, oe, oe + this._delta32);
    }
    return this;
  }, ee.prototype.digest = function(te) {
    return this.update(this._pad()), X(this.pending === null), this._digest(te);
  }, ee.prototype._pad = function() {
    var te = this.pendingTotal, ne = this._delta8, ie = ne - (te + this.padLength) % ne, oe = new Array(ie + this.padLength);
    oe[0] = 128;
    for (var se = 1; se < ie; se++)
      oe[se] = 0;
    if (te <<= 3, this.endian === "big") {
      for (var ae = 8; ae < this.padLength; ae++)
        oe[se++] = 0;
      oe[se++] = 0, oe[se++] = 0, oe[se++] = 0, oe[se++] = 0, oe[se++] = te >>> 24 & 255, oe[se++] = te >>> 16 & 255, oe[se++] = te >>> 8 & 255, oe[se++] = te & 255;
    } else
      for (oe[se++] = te & 255, oe[se++] = te >>> 8 & 255, oe[se++] = te >>> 16 & 255, oe[se++] = te >>> 24 & 255, oe[se++] = 0, oe[se++] = 0, oe[se++] = 0, oe[se++] = 0, ae = 8; ae < this.padLength; ae++)
        oe[se++] = 0;
    return oe;
  }, common$1;
}
var sha = {}, common = {}, hasRequiredCommon;
function requireCommon() {
  if (hasRequiredCommon)
    return common;
  hasRequiredCommon = 1;
  var Y = requireUtils$1(), X = Y.rotr32;
  function ee(le, he, me, ye) {
    if (le === 0)
      return te(he, me, ye);
    if (le === 1 || le === 3)
      return ie(he, me, ye);
    if (le === 2)
      return ne(he, me, ye);
  }
  common.ft_1 = ee;
  function te(le, he, me) {
    return le & he ^ ~le & me;
  }
  common.ch32 = te;
  function ne(le, he, me) {
    return le & he ^ le & me ^ he & me;
  }
  common.maj32 = ne;
  function ie(le, he, me) {
    return le ^ he ^ me;
  }
  common.p32 = ie;
  function oe(le) {
    return X(le, 2) ^ X(le, 13) ^ X(le, 22);
  }
  common.s0_256 = oe;
  function se(le) {
    return X(le, 6) ^ X(le, 11) ^ X(le, 25);
  }
  common.s1_256 = se;
  function ae(le) {
    return X(le, 7) ^ X(le, 18) ^ le >>> 3;
  }
  common.g0_256 = ae;
  function ue(le) {
    return X(le, 17) ^ X(le, 19) ^ le >>> 10;
  }
  return common.g1_256 = ue, common;
}
var _1, hasRequired_1;
function require_1() {
  if (hasRequired_1)
    return _1;
  hasRequired_1 = 1;
  var Y = requireUtils$1(), X = requireCommon$1(), ee = requireCommon(), te = Y.rotl32, ne = Y.sum32, ie = Y.sum32_5, oe = ee.ft_1, se = X.BlockHash, ae = [
    1518500249,
    1859775393,
    2400959708,
    3395469782
  ];
  function ue() {
    if (!(this instanceof ue))
      return new ue();
    se.call(this), this.h = [
      1732584193,
      4023233417,
      2562383102,
      271733878,
      3285377520
    ], this.W = new Array(80);
  }
  return Y.inherits(ue, se), _1 = ue, ue.blockSize = 512, ue.outSize = 160, ue.hmacStrength = 80, ue.padLength = 64, ue.prototype._update = function(le, he) {
    for (var me = this.W, ye = 0; ye < 16; ye++)
      me[ye] = le[he + ye];
    for (; ye < me.length; ye++)
      me[ye] = te(me[ye - 3] ^ me[ye - 8] ^ me[ye - 14] ^ me[ye - 16], 1);
    var we = this.h[0], Ee = this.h[1], Re = this.h[2], Ue = this.h[3], Me = this.h[4];
    for (ye = 0; ye < me.length; ye++) {
      var De = ~~(ye / 20), Fe = ie(te(we, 5), oe(De, Ee, Re, Ue), Me, me[ye], ae[De]);
      Me = Ue, Ue = Re, Re = te(Ee, 30), Ee = we, we = Fe;
    }
    this.h[0] = ne(this.h[0], we), this.h[1] = ne(this.h[1], Ee), this.h[2] = ne(this.h[2], Re), this.h[3] = ne(this.h[3], Ue), this.h[4] = ne(this.h[4], Me);
  }, ue.prototype._digest = function(le) {
    return le === "hex" ? Y.toHex32(this.h, "big") : Y.split32(this.h, "big");
  }, _1;
}
var _256, hasRequired_256;
function require_256() {
  if (hasRequired_256)
    return _256;
  hasRequired_256 = 1;
  var Y = requireUtils$1(), X = requireCommon$1(), ee = requireCommon(), te = requireMinimalisticAssert(), ne = Y.sum32, ie = Y.sum32_4, oe = Y.sum32_5, se = ee.ch32, ae = ee.maj32, ue = ee.s0_256, le = ee.s1_256, he = ee.g0_256, me = ee.g1_256, ye = X.BlockHash, we = [
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ];
  function Ee() {
    if (!(this instanceof Ee))
      return new Ee();
    ye.call(this), this.h = [
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ], this.k = we, this.W = new Array(64);
  }
  return Y.inherits(Ee, ye), _256 = Ee, Ee.blockSize = 512, Ee.outSize = 256, Ee.hmacStrength = 192, Ee.padLength = 64, Ee.prototype._update = function(Re, Ue) {
    for (var Me = this.W, De = 0; De < 16; De++)
      Me[De] = Re[Ue + De];
    for (; De < Me.length; De++)
      Me[De] = ie(me(Me[De - 2]), Me[De - 7], he(Me[De - 15]), Me[De - 16]);
    var Fe = this.h[0], Ke = this.h[1], tt = this.h[2], rt = this.h[3], it = this.h[4], _t = this.h[5], Dt = this.h[6], je = this.h[7];
    for (te(this.k.length === Me.length), De = 0; De < Me.length; De++) {
      var ze = oe(je, le(it), se(it, _t, Dt), this.k[De], Me[De]), fe = ne(ue(Fe), ae(Fe, Ke, tt));
      je = Dt, Dt = _t, _t = it, it = ne(rt, ze), rt = tt, tt = Ke, Ke = Fe, Fe = ne(ze, fe);
    }
    this.h[0] = ne(this.h[0], Fe), this.h[1] = ne(this.h[1], Ke), this.h[2] = ne(this.h[2], tt), this.h[3] = ne(this.h[3], rt), this.h[4] = ne(this.h[4], it), this.h[5] = ne(this.h[5], _t), this.h[6] = ne(this.h[6], Dt), this.h[7] = ne(this.h[7], je);
  }, Ee.prototype._digest = function(Re) {
    return Re === "hex" ? Y.toHex32(this.h, "big") : Y.split32(this.h, "big");
  }, _256;
}
var _224, hasRequired_224;
function require_224() {
  if (hasRequired_224)
    return _224;
  hasRequired_224 = 1;
  var Y = requireUtils$1(), X = require_256();
  function ee() {
    if (!(this instanceof ee))
      return new ee();
    X.call(this), this.h = [
      3238371032,
      914150663,
      812702999,
      4144912697,
      4290775857,
      1750603025,
      1694076839,
      3204075428
    ];
  }
  return Y.inherits(ee, X), _224 = ee, ee.blockSize = 512, ee.outSize = 224, ee.hmacStrength = 192, ee.padLength = 64, ee.prototype._digest = function(te) {
    return te === "hex" ? Y.toHex32(this.h.slice(0, 7), "big") : Y.split32(this.h.slice(0, 7), "big");
  }, _224;
}
var _512, hasRequired_512;
function require_512() {
  if (hasRequired_512)
    return _512;
  hasRequired_512 = 1;
  var Y = requireUtils$1(), X = requireCommon$1(), ee = requireMinimalisticAssert(), te = Y.rotr64_hi, ne = Y.rotr64_lo, ie = Y.shr64_hi, oe = Y.shr64_lo, se = Y.sum64, ae = Y.sum64_hi, ue = Y.sum64_lo, le = Y.sum64_4_hi, he = Y.sum64_4_lo, me = Y.sum64_5_hi, ye = Y.sum64_5_lo, we = X.BlockHash, Ee = [
    1116352408,
    3609767458,
    1899447441,
    602891725,
    3049323471,
    3964484399,
    3921009573,
    2173295548,
    961987163,
    4081628472,
    1508970993,
    3053834265,
    2453635748,
    2937671579,
    2870763221,
    3664609560,
    3624381080,
    2734883394,
    310598401,
    1164996542,
    607225278,
    1323610764,
    1426881987,
    3590304994,
    1925078388,
    4068182383,
    2162078206,
    991336113,
    2614888103,
    633803317,
    3248222580,
    3479774868,
    3835390401,
    2666613458,
    4022224774,
    944711139,
    264347078,
    2341262773,
    604807628,
    2007800933,
    770255983,
    1495990901,
    1249150122,
    1856431235,
    1555081692,
    3175218132,
    1996064986,
    2198950837,
    2554220882,
    3999719339,
    2821834349,
    766784016,
    2952996808,
    2566594879,
    3210313671,
    3203337956,
    3336571891,
    1034457026,
    3584528711,
    2466948901,
    113926993,
    3758326383,
    338241895,
    168717936,
    666307205,
    1188179964,
    773529912,
    1546045734,
    1294757372,
    1522805485,
    1396182291,
    2643833823,
    1695183700,
    2343527390,
    1986661051,
    1014477480,
    2177026350,
    1206759142,
    2456956037,
    344077627,
    2730485921,
    1290863460,
    2820302411,
    3158454273,
    3259730800,
    3505952657,
    3345764771,
    106217008,
    3516065817,
    3606008344,
    3600352804,
    1432725776,
    4094571909,
    1467031594,
    275423344,
    851169720,
    430227734,
    3100823752,
    506948616,
    1363258195,
    659060556,
    3750685593,
    883997877,
    3785050280,
    958139571,
    3318307427,
    1322822218,
    3812723403,
    1537002063,
    2003034995,
    1747873779,
    3602036899,
    1955562222,
    1575990012,
    2024104815,
    1125592928,
    2227730452,
    2716904306,
    2361852424,
    442776044,
    2428436474,
    593698344,
    2756734187,
    3733110249,
    3204031479,
    2999351573,
    3329325298,
    3815920427,
    3391569614,
    3928383900,
    3515267271,
    566280711,
    3940187606,
    3454069534,
    4118630271,
    4000239992,
    116418474,
    1914138554,
    174292421,
    2731055270,
    289380356,
    3203993006,
    460393269,
    320620315,
    685471733,
    587496836,
    852142971,
    1086792851,
    1017036298,
    365543100,
    1126000580,
    2618297676,
    1288033470,
    3409855158,
    1501505948,
    4234509866,
    1607167915,
    987167468,
    1816402316,
    1246189591
  ];
  function Re() {
    if (!(this instanceof Re))
      return new Re();
    we.call(this), this.h = [
      1779033703,
      4089235720,
      3144134277,
      2227873595,
      1013904242,
      4271175723,
      2773480762,
      1595750129,
      1359893119,
      2917565137,
      2600822924,
      725511199,
      528734635,
      4215389547,
      1541459225,
      327033209
    ], this.k = Ee, this.W = new Array(160);
  }
  Y.inherits(Re, we), _512 = Re, Re.blockSize = 1024, Re.outSize = 512, Re.hmacStrength = 192, Re.padLength = 128, Re.prototype._prepareBlock = function(fe, de) {
    for (var be = this.W, Te = 0; Te < 32; Te++)
      be[Te] = fe[de + Te];
    for (; Te < be.length; Te += 2) {
      var Ce = je(be[Te - 4], be[Te - 3]), Pe = ze(be[Te - 4], be[Te - 3]), Se = be[Te - 14], ke = be[Te - 13], ge = _t(be[Te - 30], be[Te - 29]), Ae = Dt(be[Te - 30], be[Te - 29]), Ge = be[Te - 32], Xe = be[Te - 31];
      be[Te] = le(
        Ce,
        Pe,
        Se,
        ke,
        ge,
        Ae,
        Ge,
        Xe
      ), be[Te + 1] = he(
        Ce,
        Pe,
        Se,
        ke,
        ge,
        Ae,
        Ge,
        Xe
      );
    }
  }, Re.prototype._update = function(fe, de) {
    this._prepareBlock(fe, de);
    var be = this.W, Te = this.h[0], Ce = this.h[1], Pe = this.h[2], Se = this.h[3], ke = this.h[4], ge = this.h[5], Ae = this.h[6], Ge = this.h[7], Xe = this.h[8], $e = this.h[9], Ze = this.h[10], ot = this.h[11], ct = this.h[12], At = this.h[13], Tt = this.h[14], dt = this.h[15];
    ee(this.k.length === be.length);
    for (var vt = 0; vt < be.length; vt += 2) {
      var Ut = Tt, It = dt, Er = rt(Xe, $e), Fr = it(Xe, $e), an = Ue(Xe, $e, Ze, ot, ct), wX = Me(Xe, $e, Ze, ot, ct, At), Ct = this.k[vt], w_ = this.k[vt + 1], hX = be[vt], oX = be[vt + 1], Nn = me(
        Ut,
        It,
        Er,
        Fr,
        an,
        wX,
        Ct,
        w_,
        hX,
        oX
      ), SX = ye(
        Ut,
        It,
        Er,
        Fr,
        an,
        wX,
        Ct,
        w_,
        hX,
        oX
      );
      Ut = Ke(Te, Ce), It = tt(Te, Ce), Er = De(Te, Ce, Pe, Se, ke), Fr = Fe(Te, Ce, Pe, Se, ke, ge);
      var sX = ae(Ut, It, Er, Fr), nX = ue(Ut, It, Er, Fr);
      Tt = ct, dt = At, ct = Ze, At = ot, Ze = Xe, ot = $e, Xe = ae(Ae, Ge, Nn, SX), $e = ue(Ge, Ge, Nn, SX), Ae = ke, Ge = ge, ke = Pe, ge = Se, Pe = Te, Se = Ce, Te = ae(Nn, SX, sX, nX), Ce = ue(Nn, SX, sX, nX);
    }
    se(this.h, 0, Te, Ce), se(this.h, 2, Pe, Se), se(this.h, 4, ke, ge), se(this.h, 6, Ae, Ge), se(this.h, 8, Xe, $e), se(this.h, 10, Ze, ot), se(this.h, 12, ct, At), se(this.h, 14, Tt, dt);
  }, Re.prototype._digest = function(fe) {
    return fe === "hex" ? Y.toHex32(this.h, "big") : Y.split32(this.h, "big");
  };
  function Ue(fe, de, be, Te, Ce) {
    var Pe = fe & be ^ ~fe & Ce;
    return Pe < 0 && (Pe += 4294967296), Pe;
  }
  function Me(fe, de, be, Te, Ce, Pe) {
    var Se = de & Te ^ ~de & Pe;
    return Se < 0 && (Se += 4294967296), Se;
  }
  function De(fe, de, be, Te, Ce) {
    var Pe = fe & be ^ fe & Ce ^ be & Ce;
    return Pe < 0 && (Pe += 4294967296), Pe;
  }
  function Fe(fe, de, be, Te, Ce, Pe) {
    var Se = de & Te ^ de & Pe ^ Te & Pe;
    return Se < 0 && (Se += 4294967296), Se;
  }
  function Ke(fe, de) {
    var be = te(fe, de, 28), Te = te(de, fe, 2), Ce = te(de, fe, 7), Pe = be ^ Te ^ Ce;
    return Pe < 0 && (Pe += 4294967296), Pe;
  }
  function tt(fe, de) {
    var be = ne(fe, de, 28), Te = ne(de, fe, 2), Ce = ne(de, fe, 7), Pe = be ^ Te ^ Ce;
    return Pe < 0 && (Pe += 4294967296), Pe;
  }
  function rt(fe, de) {
    var be = te(fe, de, 14), Te = te(fe, de, 18), Ce = te(de, fe, 9), Pe = be ^ Te ^ Ce;
    return Pe < 0 && (Pe += 4294967296), Pe;
  }
  function it(fe, de) {
    var be = ne(fe, de, 14), Te = ne(fe, de, 18), Ce = ne(de, fe, 9), Pe = be ^ Te ^ Ce;
    return Pe < 0 && (Pe += 4294967296), Pe;
  }
  function _t(fe, de) {
    var be = te(fe, de, 1), Te = te(fe, de, 8), Ce = ie(fe, de, 7), Pe = be ^ Te ^ Ce;
    return Pe < 0 && (Pe += 4294967296), Pe;
  }
  function Dt(fe, de) {
    var be = ne(fe, de, 1), Te = ne(fe, de, 8), Ce = oe(fe, de, 7), Pe = be ^ Te ^ Ce;
    return Pe < 0 && (Pe += 4294967296), Pe;
  }
  function je(fe, de) {
    var be = te(fe, de, 19), Te = te(de, fe, 29), Ce = ie(fe, de, 6), Pe = be ^ Te ^ Ce;
    return Pe < 0 && (Pe += 4294967296), Pe;
  }
  function ze(fe, de) {
    var be = ne(fe, de, 19), Te = ne(de, fe, 29), Ce = oe(fe, de, 6), Pe = be ^ Te ^ Ce;
    return Pe < 0 && (Pe += 4294967296), Pe;
  }
  return _512;
}
var _384, hasRequired_384;
function require_384() {
  if (hasRequired_384)
    return _384;
  hasRequired_384 = 1;
  var Y = requireUtils$1(), X = require_512();
  function ee() {
    if (!(this instanceof ee))
      return new ee();
    X.call(this), this.h = [
      3418070365,
      3238371032,
      1654270250,
      914150663,
      2438529370,
      812702999,
      355462360,
      4144912697,
      1731405415,
      4290775857,
      2394180231,
      1750603025,
      3675008525,
      1694076839,
      1203062813,
      3204075428
    ];
  }
  return Y.inherits(ee, X), _384 = ee, ee.blockSize = 1024, ee.outSize = 384, ee.hmacStrength = 192, ee.padLength = 128, ee.prototype._digest = function(te) {
    return te === "hex" ? Y.toHex32(this.h.slice(0, 12), "big") : Y.split32(this.h.slice(0, 12), "big");
  }, _384;
}
var hasRequiredSha;
function requireSha() {
  return hasRequiredSha || (hasRequiredSha = 1, sha.sha1 = require_1(), sha.sha224 = require_224(), sha.sha256 = require_256(), sha.sha384 = require_384(), sha.sha512 = require_512()), sha;
}
var ripemd = {}, hasRequiredRipemd;
function requireRipemd() {
  if (hasRequiredRipemd)
    return ripemd;
  hasRequiredRipemd = 1;
  var Y = requireUtils$1(), X = requireCommon$1(), ee = Y.rotl32, te = Y.sum32, ne = Y.sum32_3, ie = Y.sum32_4, oe = X.BlockHash;
  function se() {
    if (!(this instanceof se))
      return new se();
    oe.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little";
  }
  Y.inherits(se, oe), ripemd.ripemd160 = se, se.blockSize = 512, se.outSize = 160, se.hmacStrength = 192, se.padLength = 64, se.prototype._update = function(Ee, Re) {
    for (var Ue = this.h[0], Me = this.h[1], De = this.h[2], Fe = this.h[3], Ke = this.h[4], tt = Ue, rt = Me, it = De, _t = Fe, Dt = Ke, je = 0; je < 80; je++) {
      var ze = te(
        ee(
          ie(Ue, ae(je, Me, De, Fe), Ee[he[je] + Re], ue(je)),
          ye[je]
        ),
        Ke
      );
      Ue = Ke, Ke = Fe, Fe = ee(De, 10), De = Me, Me = ze, ze = te(
        ee(
          ie(tt, ae(79 - je, rt, it, _t), Ee[me[je] + Re], le(je)),
          we[je]
        ),
        Dt
      ), tt = Dt, Dt = _t, _t = ee(it, 10), it = rt, rt = ze;
    }
    ze = ne(this.h[1], De, _t), this.h[1] = ne(this.h[2], Fe, Dt), this.h[2] = ne(this.h[3], Ke, tt), this.h[3] = ne(this.h[4], Ue, rt), this.h[4] = ne(this.h[0], Me, it), this.h[0] = ze;
  }, se.prototype._digest = function(Ee) {
    return Ee === "hex" ? Y.toHex32(this.h, "little") : Y.split32(this.h, "little");
  };
  function ae(Ee, Re, Ue, Me) {
    return Ee <= 15 ? Re ^ Ue ^ Me : Ee <= 31 ? Re & Ue | ~Re & Me : Ee <= 47 ? (Re | ~Ue) ^ Me : Ee <= 63 ? Re & Me | Ue & ~Me : Re ^ (Ue | ~Me);
  }
  function ue(Ee) {
    return Ee <= 15 ? 0 : Ee <= 31 ? 1518500249 : Ee <= 47 ? 1859775393 : Ee <= 63 ? 2400959708 : 2840853838;
  }
  function le(Ee) {
    return Ee <= 15 ? 1352829926 : Ee <= 31 ? 1548603684 : Ee <= 47 ? 1836072691 : Ee <= 63 ? 2053994217 : 0;
  }
  var he = [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    7,
    4,
    13,
    1,
    10,
    6,
    15,
    3,
    12,
    0,
    9,
    5,
    2,
    14,
    11,
    8,
    3,
    10,
    14,
    4,
    9,
    15,
    8,
    1,
    2,
    7,
    0,
    6,
    13,
    11,
    5,
    12,
    1,
    9,
    11,
    10,
    0,
    8,
    12,
    4,
    13,
    3,
    7,
    15,
    14,
    5,
    6,
    2,
    4,
    0,
    5,
    9,
    7,
    12,
    2,
    10,
    14,
    1,
    3,
    8,
    11,
    6,
    15,
    13
  ], me = [
    5,
    14,
    7,
    0,
    9,
    2,
    11,
    4,
    13,
    6,
    15,
    8,
    1,
    10,
    3,
    12,
    6,
    11,
    3,
    7,
    0,
    13,
    5,
    10,
    14,
    15,
    8,
    12,
    4,
    9,
    1,
    2,
    15,
    5,
    1,
    3,
    7,
    14,
    6,
    9,
    11,
    8,
    12,
    2,
    10,
    0,
    4,
    13,
    8,
    6,
    4,
    1,
    3,
    11,
    15,
    0,
    5,
    12,
    2,
    13,
    9,
    7,
    10,
    14,
    12,
    15,
    10,
    4,
    1,
    5,
    8,
    7,
    6,
    2,
    13,
    14,
    0,
    3,
    9,
    11
  ], ye = [
    11,
    14,
    15,
    12,
    5,
    8,
    7,
    9,
    11,
    13,
    14,
    15,
    6,
    7,
    9,
    8,
    7,
    6,
    8,
    13,
    11,
    9,
    7,
    15,
    7,
    12,
    15,
    9,
    11,
    7,
    13,
    12,
    11,
    13,
    6,
    7,
    14,
    9,
    13,
    15,
    14,
    8,
    13,
    6,
    5,
    12,
    7,
    5,
    11,
    12,
    14,
    15,
    14,
    15,
    9,
    8,
    9,
    14,
    5,
    6,
    8,
    6,
    5,
    12,
    9,
    15,
    5,
    11,
    6,
    8,
    13,
    12,
    5,
    12,
    13,
    14,
    11,
    8,
    5,
    6
  ], we = [
    8,
    9,
    9,
    11,
    13,
    15,
    15,
    5,
    7,
    7,
    8,
    11,
    14,
    14,
    12,
    6,
    9,
    13,
    15,
    7,
    12,
    8,
    9,
    11,
    7,
    7,
    12,
    7,
    6,
    15,
    13,
    11,
    9,
    7,
    15,
    11,
    8,
    6,
    6,
    14,
    12,
    13,
    5,
    14,
    13,
    13,
    7,
    5,
    15,
    5,
    8,
    11,
    14,
    14,
    6,
    14,
    6,
    9,
    12,
    9,
    12,
    5,
    15,
    8,
    8,
    5,
    12,
    9,
    12,
    5,
    14,
    6,
    8,
    13,
    6,
    5,
    15,
    13,
    11,
    11
  ];
  return ripemd;
}
var hmac$2, hasRequiredHmac;
function requireHmac() {
  if (hasRequiredHmac)
    return hmac$2;
  hasRequiredHmac = 1;
  var Y = requireUtils$1(), X = requireMinimalisticAssert();
  function ee(te, ne, ie) {
    if (!(this instanceof ee))
      return new ee(te, ne, ie);
    this.Hash = te, this.blockSize = te.blockSize / 8, this.outSize = te.outSize / 8, this.inner = null, this.outer = null, this._init(Y.toArray(ne, ie));
  }
  return hmac$2 = ee, ee.prototype._init = function(te) {
    te.length > this.blockSize && (te = new this.Hash().update(te).digest()), X(te.length <= this.blockSize);
    for (var ne = te.length; ne < this.blockSize; ne++)
      te.push(0);
    for (ne = 0; ne < te.length; ne++)
      te[ne] ^= 54;
    for (this.inner = new this.Hash().update(te), ne = 0; ne < te.length; ne++)
      te[ne] ^= 106;
    this.outer = new this.Hash().update(te);
  }, ee.prototype.update = function(te, ne) {
    return this.inner.update(te, ne), this;
  }, ee.prototype.digest = function(te) {
    return this.outer.update(this.inner.digest()), this.outer.digest(te);
  }, hmac$2;
}
var hasRequiredHash;
function requireHash() {
  return hasRequiredHash || (hasRequiredHash = 1, function(Y) {
    var X = Y;
    X.utils = requireUtils$1(), X.common = requireCommon$1(), X.sha = requireSha(), X.ripemd = requireRipemd(), X.hmac = requireHmac(), X.sha1 = X.sha.sha1, X.sha256 = X.sha.sha256, X.sha224 = X.sha.sha224, X.sha384 = X.sha.sha384, X.sha512 = X.sha.sha512, X.ripemd160 = X.ripemd.ripemd160;
  }(hash$2)), hash$2;
}
var secp256k1$1, hasRequiredSecp256k1;
function requireSecp256k1() {
  return hasRequiredSecp256k1 || (hasRequiredSecp256k1 = 1, secp256k1$1 = {
    doubles: {
      step: 4,
      points: [
        [
          "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
          "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
        ],
        [
          "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
          "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
        ],
        [
          "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
          "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
        ],
        [
          "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
          "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
        ],
        [
          "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
          "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
        ],
        [
          "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
          "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
        ],
        [
          "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
          "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
        ],
        [
          "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
          "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
        ],
        [
          "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
          "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
        ],
        [
          "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
          "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
        ],
        [
          "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
          "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
        ],
        [
          "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
          "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
        ],
        [
          "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
          "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
        ],
        [
          "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
          "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
        ],
        [
          "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
          "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
        ],
        [
          "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
          "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
        ],
        [
          "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
          "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
        ],
        [
          "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
          "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
        ],
        [
          "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
          "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
        ],
        [
          "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
          "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
        ],
        [
          "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
          "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
        ],
        [
          "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
          "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
        ],
        [
          "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
          "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
        ],
        [
          "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
          "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
        ],
        [
          "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
          "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
        ],
        [
          "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
          "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
        ],
        [
          "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
          "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
        ],
        [
          "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
          "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
        ],
        [
          "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
          "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
        ],
        [
          "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
          "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
        ],
        [
          "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
          "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
        ],
        [
          "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
          "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
        ],
        [
          "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
          "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
        ],
        [
          "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
          "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
        ],
        [
          "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
          "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
        ],
        [
          "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
          "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
        ],
        [
          "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
          "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
        ],
        [
          "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
          "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
        ],
        [
          "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
          "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
        ],
        [
          "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
          "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
        ],
        [
          "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
          "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
        ],
        [
          "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
          "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
        ],
        [
          "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
          "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
        ],
        [
          "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
          "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
        ],
        [
          "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
          "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
        ],
        [
          "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
          "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
        ],
        [
          "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
          "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
        ],
        [
          "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
          "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
        ],
        [
          "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
          "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
        ],
        [
          "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
          "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
        ],
        [
          "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
          "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
        ],
        [
          "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
          "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
        ],
        [
          "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
          "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
        ],
        [
          "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
          "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
        ],
        [
          "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
          "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
        ],
        [
          "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
          "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
        ],
        [
          "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
          "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
        ],
        [
          "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
          "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
        ],
        [
          "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
          "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
        ],
        [
          "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
          "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
        ],
        [
          "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
          "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
        ],
        [
          "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
          "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
        ],
        [
          "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
          "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
        ],
        [
          "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
          "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
        ],
        [
          "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
          "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
        ]
      ]
    },
    naf: {
      wnd: 7,
      points: [
        [
          "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
          "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
        ],
        [
          "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
          "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
        ],
        [
          "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
          "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
        ],
        [
          "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
          "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
        ],
        [
          "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
          "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
        ],
        [
          "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
          "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
        ],
        [
          "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
          "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
        ],
        [
          "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
          "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
        ],
        [
          "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
          "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
        ],
        [
          "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
          "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
        ],
        [
          "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
          "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
        ],
        [
          "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
          "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
        ],
        [
          "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
          "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
        ],
        [
          "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
          "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
        ],
        [
          "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
          "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
        ],
        [
          "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
          "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
        ],
        [
          "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
          "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
        ],
        [
          "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
          "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
        ],
        [
          "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
          "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
        ],
        [
          "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
          "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
        ],
        [
          "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
          "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
        ],
        [
          "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
          "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
        ],
        [
          "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
          "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
        ],
        [
          "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
          "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
        ],
        [
          "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
          "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
        ],
        [
          "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
          "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
        ],
        [
          "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
          "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
        ],
        [
          "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
          "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
        ],
        [
          "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
          "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
        ],
        [
          "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
          "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
        ],
        [
          "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
          "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
        ],
        [
          "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
          "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
        ],
        [
          "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
          "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
        ],
        [
          "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
          "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
        ],
        [
          "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
          "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
        ],
        [
          "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
          "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
        ],
        [
          "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
          "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
        ],
        [
          "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
          "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
        ],
        [
          "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
          "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
        ],
        [
          "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
          "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
        ],
        [
          "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
          "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
        ],
        [
          "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
          "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
        ],
        [
          "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
          "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
        ],
        [
          "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
          "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
        ],
        [
          "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
          "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
        ],
        [
          "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
          "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
        ],
        [
          "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
          "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
        ],
        [
          "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
          "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
        ],
        [
          "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
          "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
        ],
        [
          "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
          "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
        ],
        [
          "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
          "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
        ],
        [
          "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
          "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
        ],
        [
          "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
          "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
        ],
        [
          "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
          "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
        ],
        [
          "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
          "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
        ],
        [
          "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
          "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
        ],
        [
          "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
          "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
        ],
        [
          "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
          "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
        ],
        [
          "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
          "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
        ],
        [
          "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
          "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
        ],
        [
          "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
          "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
        ],
        [
          "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
          "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
        ],
        [
          "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
          "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
        ],
        [
          "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
          "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
        ],
        [
          "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
          "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
        ],
        [
          "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
          "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
        ],
        [
          "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
          "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
        ],
        [
          "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
          "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
        ],
        [
          "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
          "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
        ],
        [
          "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
          "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
        ],
        [
          "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
          "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
        ],
        [
          "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
          "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
        ],
        [
          "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
          "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
        ],
        [
          "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
          "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
        ],
        [
          "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
          "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
        ],
        [
          "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
          "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
        ],
        [
          "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
          "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
        ],
        [
          "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
          "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
        ],
        [
          "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
          "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
        ],
        [
          "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
          "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
        ],
        [
          "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
          "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
        ],
        [
          "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
          "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
        ],
        [
          "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
          "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
        ],
        [
          "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
          "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
        ],
        [
          "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
          "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
        ],
        [
          "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
          "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
        ],
        [
          "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
          "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
        ],
        [
          "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
          "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
        ],
        [
          "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
          "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
        ],
        [
          "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
          "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
        ],
        [
          "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
          "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
        ],
        [
          "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
          "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
        ],
        [
          "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
          "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
        ],
        [
          "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
          "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
        ],
        [
          "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
          "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
        ],
        [
          "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
          "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
        ],
        [
          "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
          "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
        ],
        [
          "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
          "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
        ],
        [
          "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
          "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
        ],
        [
          "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
          "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
        ],
        [
          "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
          "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
        ],
        [
          "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
          "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
        ],
        [
          "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
          "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
        ],
        [
          "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
          "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
        ],
        [
          "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
          "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
        ],
        [
          "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
          "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
        ],
        [
          "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
          "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
        ],
        [
          "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
          "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
        ],
        [
          "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
          "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
        ],
        [
          "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
          "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
        ],
        [
          "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
          "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
        ],
        [
          "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
          "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
        ],
        [
          "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
          "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
        ],
        [
          "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
          "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
        ],
        [
          "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
          "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
        ],
        [
          "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
          "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
        ],
        [
          "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
          "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
        ],
        [
          "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
          "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
        ],
        [
          "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
          "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
        ],
        [
          "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
          "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
        ],
        [
          "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
          "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
        ],
        [
          "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
          "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
        ],
        [
          "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
          "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
        ],
        [
          "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
          "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
        ],
        [
          "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
          "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
        ],
        [
          "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
          "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
        ],
        [
          "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
          "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
        ]
      ]
    }
  }), secp256k1$1;
}
var hasRequiredCurves;
function requireCurves() {
  return hasRequiredCurves || (hasRequiredCurves = 1, function(Y) {
    var X = Y, ee = requireHash(), te = requireCurve(), ne = requireUtils$2(), ie = ne.assert;
    function oe(ue) {
      ue.type === "short" ? this.curve = new te.short(ue) : ue.type === "edwards" ? this.curve = new te.edwards(ue) : this.curve = new te.mont(ue), this.g = this.curve.g, this.n = this.curve.n, this.hash = ue.hash, ie(this.g.validate(), "Invalid curve"), ie(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
    }
    X.PresetCurve = oe;
    function se(ue, le) {
      Object.defineProperty(X, ue, {
        configurable: !0,
        enumerable: !0,
        get: function() {
          var he = new oe(le);
          return Object.defineProperty(X, ue, {
            configurable: !0,
            enumerable: !0,
            value: he
          }), he;
        }
      });
    }
    se("p192", {
      type: "short",
      prime: "p192",
      p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
      b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
      n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
      hash: ee.sha256,
      gRed: !1,
      g: [
        "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
        "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
      ]
    }), se("p224", {
      type: "short",
      prime: "p224",
      p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
      b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
      n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
      hash: ee.sha256,
      gRed: !1,
      g: [
        "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
        "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
      ]
    }), se("p256", {
      type: "short",
      prime: null,
      p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
      a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
      b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
      n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
      hash: ee.sha256,
      gRed: !1,
      g: [
        "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
        "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
      ]
    }), se("p384", {
      type: "short",
      prime: null,
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
      a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
      b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
      n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
      hash: ee.sha384,
      gRed: !1,
      g: [
        "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
        "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
      ]
    }), se("p521", {
      type: "short",
      prime: null,
      p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
      a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
      b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
      n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
      hash: ee.sha512,
      gRed: !1,
      g: [
        "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
        "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
      ]
    }), se("curve25519", {
      type: "mont",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "76d06",
      b: "1",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: ee.sha256,
      gRed: !1,
      g: [
        "9"
      ]
    }), se("ed25519", {
      type: "edwards",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "-1",
      c: "1",
      // -121665 * (121666^(-1)) (mod P)
      d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: ee.sha256,
      gRed: !1,
      g: [
        "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
        // 4/5
        "6666666666666666666666666666666666666666666666666666666666666658"
      ]
    });
    var ae;
    try {
      ae = requireSecp256k1();
    } catch {
      ae = void 0;
    }
    se("secp256k1", {
      type: "short",
      prime: "k256",
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
      a: "0",
      b: "7",
      n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
      h: "1",
      hash: ee.sha256,
      // Precomputed endomorphism
      beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
      lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
      basis: [
        {
          a: "3086d221a7d46bcde86c90e49284eb15",
          b: "-e4437ed6010e88286f547fa90abfe4c3"
        },
        {
          a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
          b: "3086d221a7d46bcde86c90e49284eb15"
        }
      ],
      gRed: !1,
      g: [
        "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
        "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
        ae
      ]
    });
  }(curves)), curves;
}
var hmacDrbg, hasRequiredHmacDrbg;
function requireHmacDrbg() {
  if (hasRequiredHmacDrbg)
    return hmacDrbg;
  hasRequiredHmacDrbg = 1;
  var Y = requireHash(), X = requireUtils$3(), ee = requireMinimalisticAssert();
  function te(ne) {
    if (!(this instanceof te))
      return new te(ne);
    this.hash = ne.hash, this.predResist = !!ne.predResist, this.outLen = this.hash.outSize, this.minEntropy = ne.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
    var ie = X.toArray(ne.entropy, ne.entropyEnc || "hex"), oe = X.toArray(ne.nonce, ne.nonceEnc || "hex"), se = X.toArray(ne.pers, ne.persEnc || "hex");
    ee(
      ie.length >= this.minEntropy / 8,
      "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
    ), this._init(ie, oe, se);
  }
  return hmacDrbg = te, te.prototype._init = function(ne, ie, oe) {
    var se = ne.concat(ie).concat(oe);
    this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
    for (var ae = 0; ae < this.V.length; ae++)
      this.K[ae] = 0, this.V[ae] = 1;
    this._update(se), this._reseed = 1, this.reseedInterval = 281474976710656;
  }, te.prototype._hmac = function() {
    return new Y.hmac(this.hash, this.K);
  }, te.prototype._update = function(ne) {
    var ie = this._hmac().update(this.V).update([0]);
    ne && (ie = ie.update(ne)), this.K = ie.digest(), this.V = this._hmac().update(this.V).digest(), ne && (this.K = this._hmac().update(this.V).update([1]).update(ne).digest(), this.V = this._hmac().update(this.V).digest());
  }, te.prototype.reseed = function(ne, ie, oe, se) {
    typeof ie != "string" && (se = oe, oe = ie, ie = null), ne = X.toArray(ne, ie), oe = X.toArray(oe, se), ee(
      ne.length >= this.minEntropy / 8,
      "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
    ), this._update(ne.concat(oe || [])), this._reseed = 1;
  }, te.prototype.generate = function(ne, ie, oe, se) {
    if (this._reseed > this.reseedInterval)
      throw new Error("Reseed is required");
    typeof ie != "string" && (se = oe, oe = ie, ie = null), oe && (oe = X.toArray(oe, se || "hex"), this._update(oe));
    for (var ae = []; ae.length < ne; )
      this.V = this._hmac().update(this.V).digest(), ae = ae.concat(this.V);
    var ue = ae.slice(0, ne);
    return this._update(oe), this._reseed++, X.encode(ue, ie);
  }, hmacDrbg;
}
var key$1, hasRequiredKey$1;
function requireKey$1() {
  if (hasRequiredKey$1)
    return key$1;
  hasRequiredKey$1 = 1;
  var Y = requireBn(), X = requireUtils$2(), ee = X.assert;
  function te(ne, ie) {
    this.ec = ne, this.priv = null, this.pub = null, ie.priv && this._importPrivate(ie.priv, ie.privEnc), ie.pub && this._importPublic(ie.pub, ie.pubEnc);
  }
  return key$1 = te, te.fromPublic = function(ne, ie, oe) {
    return ie instanceof te ? ie : new te(ne, {
      pub: ie,
      pubEnc: oe
    });
  }, te.fromPrivate = function(ne, ie, oe) {
    return ie instanceof te ? ie : new te(ne, {
      priv: ie,
      privEnc: oe
    });
  }, te.prototype.validate = function() {
    var ne = this.getPublic();
    return ne.isInfinity() ? { result: !1, reason: "Invalid public key" } : ne.validate() ? ne.mul(this.ec.curve.n).isInfinity() ? { result: !0, reason: null } : { result: !1, reason: "Public key * N != O" } : { result: !1, reason: "Public key is not a point" };
  }, te.prototype.getPublic = function(ne, ie) {
    return typeof ne == "string" && (ie = ne, ne = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), ie ? this.pub.encode(ie, ne) : this.pub;
  }, te.prototype.getPrivate = function(ne) {
    return ne === "hex" ? this.priv.toString(16, 2) : this.priv;
  }, te.prototype._importPrivate = function(ne, ie) {
    this.priv = new Y(ne, ie || 16), this.priv = this.priv.umod(this.ec.curve.n);
  }, te.prototype._importPublic = function(ne, ie) {
    if (ne.x || ne.y) {
      this.ec.curve.type === "mont" ? ee(ne.x, "Need x coordinate") : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") && ee(ne.x && ne.y, "Need both x and y coordinate"), this.pub = this.ec.curve.point(ne.x, ne.y);
      return;
    }
    this.pub = this.ec.curve.decodePoint(ne, ie);
  }, te.prototype.derive = function(ne) {
    return ne.validate() || ee(ne.validate(), "public point not validated"), ne.mul(this.priv).getX();
  }, te.prototype.sign = function(ne, ie, oe) {
    return this.ec.sign(ne, this, ie, oe);
  }, te.prototype.verify = function(ne, ie) {
    return this.ec.verify(ne, ie, this);
  }, te.prototype.inspect = function() {
    return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
  }, key$1;
}
var signature$1, hasRequiredSignature$1;
function requireSignature$1() {
  if (hasRequiredSignature$1)
    return signature$1;
  hasRequiredSignature$1 = 1;
  var Y = requireBn(), X = requireUtils$2(), ee = X.assert;
  function te(ae, ue) {
    if (ae instanceof te)
      return ae;
    this._importDER(ae, ue) || (ee(ae.r && ae.s, "Signature without r or s"), this.r = new Y(ae.r, 16), this.s = new Y(ae.s, 16), ae.recoveryParam === void 0 ? this.recoveryParam = null : this.recoveryParam = ae.recoveryParam);
  }
  signature$1 = te;
  function ne() {
    this.place = 0;
  }
  function ie(ae, ue) {
    var le = ae[ue.place++];
    if (!(le & 128))
      return le;
    var he = le & 15;
    if (he === 0 || he > 4)
      return !1;
    for (var me = 0, ye = 0, we = ue.place; ye < he; ye++, we++)
      me <<= 8, me |= ae[we], me >>>= 0;
    return me <= 127 ? !1 : (ue.place = we, me);
  }
  function oe(ae) {
    for (var ue = 0, le = ae.length - 1; !ae[ue] && !(ae[ue + 1] & 128) && ue < le; )
      ue++;
    return ue === 0 ? ae : ae.slice(ue);
  }
  te.prototype._importDER = function(ae, ue) {
    ae = X.toArray(ae, ue);
    var le = new ne();
    if (ae[le.place++] !== 48)
      return !1;
    var he = ie(ae, le);
    if (he === !1 || he + le.place !== ae.length || ae[le.place++] !== 2)
      return !1;
    var me = ie(ae, le);
    if (me === !1)
      return !1;
    var ye = ae.slice(le.place, me + le.place);
    if (le.place += me, ae[le.place++] !== 2)
      return !1;
    var we = ie(ae, le);
    if (we === !1 || ae.length !== we + le.place)
      return !1;
    var Ee = ae.slice(le.place, we + le.place);
    if (ye[0] === 0)
      if (ye[1] & 128)
        ye = ye.slice(1);
      else
        return !1;
    if (Ee[0] === 0)
      if (Ee[1] & 128)
        Ee = Ee.slice(1);
      else
        return !1;
    return this.r = new Y(ye), this.s = new Y(Ee), this.recoveryParam = null, !0;
  };
  function se(ae, ue) {
    if (ue < 128) {
      ae.push(ue);
      return;
    }
    var le = 1 + (Math.log(ue) / Math.LN2 >>> 3);
    for (ae.push(le | 128); --le; )
      ae.push(ue >>> (le << 3) & 255);
    ae.push(ue);
  }
  return te.prototype.toDER = function(ae) {
    var ue = this.r.toArray(), le = this.s.toArray();
    for (ue[0] & 128 && (ue = [0].concat(ue)), le[0] & 128 && (le = [0].concat(le)), ue = oe(ue), le = oe(le); !le[0] && !(le[1] & 128); )
      le = le.slice(1);
    var he = [2];
    se(he, ue.length), he = he.concat(ue), he.push(2), se(he, le.length);
    var me = he.concat(le), ye = [48];
    return se(ye, me.length), ye = ye.concat(me), X.encode(ye, ae);
  }, signature$1;
}
var ec, hasRequiredEc;
function requireEc() {
  if (hasRequiredEc)
    return ec;
  hasRequiredEc = 1;
  var Y = requireBn(), X = requireHmacDrbg(), ee = requireUtils$2(), te = requireCurves(), ne = requireBrorand(), ie = ee.assert, oe = requireKey$1(), se = requireSignature$1();
  function ae(ue) {
    if (!(this instanceof ae))
      return new ae(ue);
    typeof ue == "string" && (ie(
      Object.prototype.hasOwnProperty.call(te, ue),
      "Unknown curve " + ue
    ), ue = te[ue]), ue instanceof te.PresetCurve && (ue = { curve: ue }), this.curve = ue.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = ue.curve.g, this.g.precompute(ue.curve.n.bitLength() + 1), this.hash = ue.hash || ue.curve.hash;
  }
  return ec = ae, ae.prototype.keyPair = function(ue) {
    return new oe(this, ue);
  }, ae.prototype.keyFromPrivate = function(ue, le) {
    return oe.fromPrivate(this, ue, le);
  }, ae.prototype.keyFromPublic = function(ue, le) {
    return oe.fromPublic(this, ue, le);
  }, ae.prototype.genKeyPair = function(ue) {
    ue || (ue = {});
    for (var le = new X({
      hash: this.hash,
      pers: ue.pers,
      persEnc: ue.persEnc || "utf8",
      entropy: ue.entropy || ne(this.hash.hmacStrength),
      entropyEnc: ue.entropy && ue.entropyEnc || "utf8",
      nonce: this.n.toArray()
    }), he = this.n.byteLength(), me = this.n.sub(new Y(2)); ; ) {
      var ye = new Y(le.generate(he));
      if (!(ye.cmp(me) > 0))
        return ye.iaddn(1), this.keyFromPrivate(ye);
    }
  }, ae.prototype._truncateToN = function(ue, le) {
    var he = ue.byteLength() * 8 - this.n.bitLength();
    return he > 0 && (ue = ue.ushrn(he)), !le && ue.cmp(this.n) >= 0 ? ue.sub(this.n) : ue;
  }, ae.prototype.sign = function(ue, le, he, me) {
    typeof he == "object" && (me = he, he = null), me || (me = {}), le = this.keyFromPrivate(le, he), ue = this._truncateToN(new Y(ue, 16));
    for (var ye = this.n.byteLength(), we = le.getPrivate().toArray("be", ye), Ee = ue.toArray("be", ye), Re = new X({
      hash: this.hash,
      entropy: we,
      nonce: Ee,
      pers: me.pers,
      persEnc: me.persEnc || "utf8"
    }), Ue = this.n.sub(new Y(1)), Me = 0; ; Me++) {
      var De = me.k ? me.k(Me) : new Y(Re.generate(this.n.byteLength()));
      if (De = this._truncateToN(De, !0), !(De.cmpn(1) <= 0 || De.cmp(Ue) >= 0)) {
        var Fe = this.g.mul(De);
        if (!Fe.isInfinity()) {
          var Ke = Fe.getX(), tt = Ke.umod(this.n);
          if (tt.cmpn(0) !== 0) {
            var rt = De.invm(this.n).mul(tt.mul(le.getPrivate()).iadd(ue));
            if (rt = rt.umod(this.n), rt.cmpn(0) !== 0) {
              var it = (Fe.getY().isOdd() ? 1 : 0) | (Ke.cmp(tt) !== 0 ? 2 : 0);
              return me.canonical && rt.cmp(this.nh) > 0 && (rt = this.n.sub(rt), it ^= 1), new se({ r: tt, s: rt, recoveryParam: it });
            }
          }
        }
      }
    }
  }, ae.prototype.verify = function(ue, le, he, me) {
    ue = this._truncateToN(new Y(ue, 16)), he = this.keyFromPublic(he, me), le = new se(le, "hex");
    var ye = le.r, we = le.s;
    if (ye.cmpn(1) < 0 || ye.cmp(this.n) >= 0 || we.cmpn(1) < 0 || we.cmp(this.n) >= 0)
      return !1;
    var Ee = we.invm(this.n), Re = Ee.mul(ue).umod(this.n), Ue = Ee.mul(ye).umod(this.n), Me;
    return this.curve._maxwellTrick ? (Me = this.g.jmulAdd(Re, he.getPublic(), Ue), Me.isInfinity() ? !1 : Me.eqXToP(ye)) : (Me = this.g.mulAdd(Re, he.getPublic(), Ue), Me.isInfinity() ? !1 : Me.getX().umod(this.n).cmp(ye) === 0);
  }, ae.prototype.recoverPubKey = function(ue, le, he, me) {
    ie((3 & he) === he, "The recovery param is more than two bits"), le = new se(le, me);
    var ye = this.n, we = new Y(ue), Ee = le.r, Re = le.s, Ue = he & 1, Me = he >> 1;
    if (Ee.cmp(this.curve.p.umod(this.curve.n)) >= 0 && Me)
      throw new Error("Unable to find sencond key candinate");
    Me ? Ee = this.curve.pointFromX(Ee.add(this.curve.n), Ue) : Ee = this.curve.pointFromX(Ee, Ue);
    var De = le.r.invm(ye), Fe = ye.sub(we).mul(De).umod(ye), Ke = Re.mul(De).umod(ye);
    return this.g.mulAdd(Fe, Ee, Ke);
  }, ae.prototype.getKeyRecoveryParam = function(ue, le, he, me) {
    if (le = new se(le, me), le.recoveryParam !== null)
      return le.recoveryParam;
    for (var ye = 0; ye < 4; ye++) {
      var we;
      try {
        we = this.recoverPubKey(ue, le, ye);
      } catch {
        continue;
      }
      if (we.eq(he))
        return ye;
    }
    throw new Error("Unable to find valid recovery factor");
  }, ec;
}
var key, hasRequiredKey;
function requireKey() {
  if (hasRequiredKey)
    return key;
  hasRequiredKey = 1;
  var Y = requireUtils$2(), X = Y.assert, ee = Y.parseBytes, te = Y.cachedProperty;
  function ne(ie, oe) {
    this.eddsa = ie, this._secret = ee(oe.secret), ie.isPoint(oe.pub) ? this._pub = oe.pub : this._pubBytes = ee(oe.pub);
  }
  return ne.fromPublic = function(ie, oe) {
    return oe instanceof ne ? oe : new ne(ie, { pub: oe });
  }, ne.fromSecret = function(ie, oe) {
    return oe instanceof ne ? oe : new ne(ie, { secret: oe });
  }, ne.prototype.secret = function() {
    return this._secret;
  }, te(ne, "pubBytes", function() {
    return this.eddsa.encodePoint(this.pub());
  }), te(ne, "pub", function() {
    return this._pubBytes ? this.eddsa.decodePoint(this._pubBytes) : this.eddsa.g.mul(this.priv());
  }), te(ne, "privBytes", function() {
    var ie = this.eddsa, oe = this.hash(), se = ie.encodingLength - 1, ae = oe.slice(0, ie.encodingLength);
    return ae[0] &= 248, ae[se] &= 127, ae[se] |= 64, ae;
  }), te(ne, "priv", function() {
    return this.eddsa.decodeInt(this.privBytes());
  }), te(ne, "hash", function() {
    return this.eddsa.hash().update(this.secret()).digest();
  }), te(ne, "messagePrefix", function() {
    return this.hash().slice(this.eddsa.encodingLength);
  }), ne.prototype.sign = function(ie) {
    return X(this._secret, "KeyPair can only verify"), this.eddsa.sign(ie, this);
  }, ne.prototype.verify = function(ie, oe) {
    return this.eddsa.verify(ie, oe, this);
  }, ne.prototype.getSecret = function(ie) {
    return X(this._secret, "KeyPair is public only"), Y.encode(this.secret(), ie);
  }, ne.prototype.getPublic = function(ie) {
    return Y.encode(this.pubBytes(), ie);
  }, key = ne, key;
}
var signature, hasRequiredSignature;
function requireSignature() {
  if (hasRequiredSignature)
    return signature;
  hasRequiredSignature = 1;
  var Y = requireBn(), X = requireUtils$2(), ee = X.assert, te = X.cachedProperty, ne = X.parseBytes;
  function ie(oe, se) {
    this.eddsa = oe, typeof se != "object" && (se = ne(se)), Array.isArray(se) && (se = {
      R: se.slice(0, oe.encodingLength),
      S: se.slice(oe.encodingLength)
    }), ee(se.R && se.S, "Signature without R or S"), oe.isPoint(se.R) && (this._R = se.R), se.S instanceof Y && (this._S = se.S), this._Rencoded = Array.isArray(se.R) ? se.R : se.Rencoded, this._Sencoded = Array.isArray(se.S) ? se.S : se.Sencoded;
  }
  return te(ie, "S", function() {
    return this.eddsa.decodeInt(this.Sencoded());
  }), te(ie, "R", function() {
    return this.eddsa.decodePoint(this.Rencoded());
  }), te(ie, "Rencoded", function() {
    return this.eddsa.encodePoint(this.R());
  }), te(ie, "Sencoded", function() {
    return this.eddsa.encodeInt(this.S());
  }), ie.prototype.toBytes = function() {
    return this.Rencoded().concat(this.Sencoded());
  }, ie.prototype.toHex = function() {
    return X.encode(this.toBytes(), "hex").toUpperCase();
  }, signature = ie, signature;
}
var eddsa, hasRequiredEddsa;
function requireEddsa() {
  if (hasRequiredEddsa)
    return eddsa;
  hasRequiredEddsa = 1;
  var Y = requireHash(), X = requireCurves(), ee = requireUtils$2(), te = ee.assert, ne = ee.parseBytes, ie = requireKey(), oe = requireSignature();
  function se(ae) {
    if (te(ae === "ed25519", "only tested with ed25519 so far"), !(this instanceof se))
      return new se(ae);
    ae = X[ae].curve, this.curve = ae, this.g = ae.g, this.g.precompute(ae.n.bitLength() + 1), this.pointClass = ae.point().constructor, this.encodingLength = Math.ceil(ae.n.bitLength() / 8), this.hash = Y.sha512;
  }
  return eddsa = se, se.prototype.sign = function(ae, ue) {
    ae = ne(ae);
    var le = this.keyFromSecret(ue), he = this.hashInt(le.messagePrefix(), ae), me = this.g.mul(he), ye = this.encodePoint(me), we = this.hashInt(ye, le.pubBytes(), ae).mul(le.priv()), Ee = he.add(we).umod(this.curve.n);
    return this.makeSignature({ R: me, S: Ee, Rencoded: ye });
  }, se.prototype.verify = function(ae, ue, le) {
    ae = ne(ae), ue = this.makeSignature(ue);
    var he = this.keyFromPublic(le), me = this.hashInt(ue.Rencoded(), he.pubBytes(), ae), ye = this.g.mul(ue.S()), we = ue.R().add(he.pub().mul(me));
    return we.eq(ye);
  }, se.prototype.hashInt = function() {
    for (var ae = this.hash(), ue = 0; ue < arguments.length; ue++)
      ae.update(arguments[ue]);
    return ee.intFromLE(ae.digest()).umod(this.curve.n);
  }, se.prototype.keyFromPublic = function(ae) {
    return ie.fromPublic(this, ae);
  }, se.prototype.keyFromSecret = function(ae) {
    return ie.fromSecret(this, ae);
  }, se.prototype.makeSignature = function(ae) {
    return ae instanceof oe ? ae : new oe(this, ae);
  }, se.prototype.encodePoint = function(ae) {
    var ue = ae.getY().toArray("le", this.encodingLength);
    return ue[this.encodingLength - 1] |= ae.getX().isOdd() ? 128 : 0, ue;
  }, se.prototype.decodePoint = function(ae) {
    ae = ee.parseBytes(ae);
    var ue = ae.length - 1, le = ae.slice(0, ue).concat(ae[ue] & -129), he = (ae[ue] & 128) !== 0, me = ee.intFromLE(le);
    return this.curve.pointFromY(me, he);
  }, se.prototype.encodeInt = function(ae) {
    return ae.toArray("le", this.encodingLength);
  }, se.prototype.decodeInt = function(ae) {
    return ee.intFromLE(ae);
  }, se.prototype.isPoint = function(ae) {
    return ae instanceof this.pointClass;
  }, eddsa;
}
var hasRequiredElliptic;
function requireElliptic() {
  return hasRequiredElliptic || (hasRequiredElliptic = 1, function(Y) {
    var X = Y;
    X.version = require$$0$2.version, X.utils = requireUtils$2(), X.rand = requireBrorand(), X.curve = requireCurve(), X.curves = requireCurves(), X.ec = requireEc(), X.eddsa = requireEddsa();
  }(elliptic)), elliptic;
}
var asn1$1 = {}, asn1 = {}, api = {}, vmBrowserify = {}, hasRequiredVmBrowserify;
function requireVmBrowserify() {
  return hasRequiredVmBrowserify || (hasRequiredVmBrowserify = 1, function(exports) {
    var indexOf = function(Y, X) {
      if (Y.indexOf)
        return Y.indexOf(X);
      for (var ee = 0; ee < Y.length; ee++)
        if (Y[ee] === X)
          return ee;
      return -1;
    }, Object_keys = function(Y) {
      if (Object.keys)
        return Object.keys(Y);
      var X = [];
      for (var ee in Y)
        X.push(ee);
      return X;
    }, forEach = function(Y, X) {
      if (Y.forEach)
        return Y.forEach(X);
      for (var ee = 0; ee < Y.length; ee++)
        X(Y[ee], ee, Y);
    }, defineProp = function() {
      try {
        return Object.defineProperty({}, "_", {}), function(Y, X, ee) {
          Object.defineProperty(Y, X, {
            writable: !0,
            enumerable: !1,
            configurable: !0,
            value: ee
          });
        };
      } catch {
        return function(Y, X, ee) {
          Y[X] = ee;
        };
      }
    }(), globals = [
      "Array",
      "Boolean",
      "Date",
      "Error",
      "EvalError",
      "Function",
      "Infinity",
      "JSON",
      "Math",
      "NaN",
      "Number",
      "Object",
      "RangeError",
      "ReferenceError",
      "RegExp",
      "String",
      "SyntaxError",
      "TypeError",
      "URIError",
      "decodeURI",
      "decodeURIComponent",
      "encodeURI",
      "encodeURIComponent",
      "escape",
      "eval",
      "isFinite",
      "isNaN",
      "parseFloat",
      "parseInt",
      "undefined",
      "unescape"
    ];
    function Context() {
    }
    Context.prototype = {};
    var Script = exports.Script = function(Y) {
      if (!(this instanceof Script))
        return new Script(Y);
      this.code = Y;
    };
    Script.prototype.runInContext = function(Y) {
      if (!(Y instanceof Context))
        throw new TypeError("needs a 'context' argument.");
      var X = document.createElement("iframe");
      X.style || (X.style = {}), X.style.display = "none", document.body.appendChild(X);
      var ee = X.contentWindow, te = ee.eval, ne = ee.execScript;
      !te && ne && (ne.call(ee, "null"), te = ee.eval), forEach(Object_keys(Y), function(se) {
        ee[se] = Y[se];
      }), forEach(globals, function(se) {
        Y[se] && (ee[se] = Y[se]);
      });
      var ie = Object_keys(ee), oe = te.call(ee, this.code);
      return forEach(Object_keys(ee), function(se) {
        (se in Y || indexOf(ie, se) === -1) && (Y[se] = ee[se]);
      }), forEach(globals, function(se) {
        se in Y || defineProp(Y, se, ee[se]);
      }), document.body.removeChild(X), oe;
    }, Script.prototype.runInThisContext = function() {
      return eval(this.code);
    }, Script.prototype.runInNewContext = function(Y) {
      var X = Script.createContext(Y), ee = this.runInContext(X);
      return Y && forEach(Object_keys(X), function(te) {
        Y[te] = X[te];
      }), ee;
    }, forEach(Object_keys(Script.prototype), function(Y) {
      exports[Y] = Script[Y] = function(X) {
        var ee = Script(X);
        return ee[Y].apply(ee, [].slice.call(arguments, 1));
      };
    }), exports.isContext = function(Y) {
      return Y instanceof Context;
    }, exports.createScript = function(Y) {
      return exports.Script(Y);
    }, exports.createContext = Script.createContext = function(Y) {
      var X = new Context();
      return typeof Y == "object" && forEach(Object_keys(Y), function(ee) {
        X[ee] = Y[ee];
      }), X;
    };
  }(vmBrowserify)), vmBrowserify;
}
var hasRequiredApi;
function requireApi() {
  return hasRequiredApi || (hasRequiredApi = 1, function(Y) {
    var X = requireAsn1$1(), ee = inherits_browserExports, te = Y;
    te.define = function(ie, oe) {
      return new ne(ie, oe);
    };
    function ne(ie, oe) {
      this.name = ie, this.body = oe, this.decoders = {}, this.encoders = {};
    }
    ne.prototype._createNamed = function(ie) {
      var oe;
      try {
        oe = requireVmBrowserify().runInThisContext(
          "(function " + this.name + `(entity) {
  this._initNamed(entity);
})`
        );
      } catch {
        oe = function(se) {
          this._initNamed(se);
        };
      }
      return ee(oe, ie), oe.prototype._initNamed = function(se) {
        ie.call(this, se);
      }, new oe(this);
    }, ne.prototype._getDecoder = function(ie) {
      return ie = ie || "der", this.decoders.hasOwnProperty(ie) || (this.decoders[ie] = this._createNamed(X.decoders[ie])), this.decoders[ie];
    }, ne.prototype.decode = function(ie, oe, se) {
      return this._getDecoder(oe).decode(ie, se);
    }, ne.prototype._getEncoder = function(ie) {
      return ie = ie || "der", this.encoders.hasOwnProperty(ie) || (this.encoders[ie] = this._createNamed(X.encoders[ie])), this.encoders[ie];
    }, ne.prototype.encode = function(ie, oe, se) {
      return this._getEncoder(oe).encode(ie, se);
    };
  }(api)), api;
}
var base$2 = {}, reporter = {}, hasRequiredReporter;
function requireReporter() {
  if (hasRequiredReporter)
    return reporter;
  hasRequiredReporter = 1;
  var Y = inherits_browserExports;
  function X(te) {
    this._reporterState = {
      obj: null,
      path: [],
      options: te || {},
      errors: []
    };
  }
  reporter.Reporter = X, X.prototype.isError = function(te) {
    return te instanceof ee;
  }, X.prototype.save = function() {
    var te = this._reporterState;
    return { obj: te.obj, pathLen: te.path.length };
  }, X.prototype.restore = function(te) {
    var ne = this._reporterState;
    ne.obj = te.obj, ne.path = ne.path.slice(0, te.pathLen);
  }, X.prototype.enterKey = function(te) {
    return this._reporterState.path.push(te);
  }, X.prototype.exitKey = function(te) {
    var ne = this._reporterState;
    ne.path = ne.path.slice(0, te - 1);
  }, X.prototype.leaveKey = function(te, ne, ie) {
    var oe = this._reporterState;
    this.exitKey(te), oe.obj !== null && (oe.obj[ne] = ie);
  }, X.prototype.path = function() {
    return this._reporterState.path.join("/");
  }, X.prototype.enterObject = function() {
    var te = this._reporterState, ne = te.obj;
    return te.obj = {}, ne;
  }, X.prototype.leaveObject = function(te) {
    var ne = this._reporterState, ie = ne.obj;
    return ne.obj = te, ie;
  }, X.prototype.error = function(te) {
    var ne, ie = this._reporterState, oe = te instanceof ee;
    if (oe ? ne = te : ne = new ee(ie.path.map(function(se) {
      return "[" + JSON.stringify(se) + "]";
    }).join(""), te.message || te, te.stack), !ie.options.partial)
      throw ne;
    return oe || ie.errors.push(ne), ne;
  }, X.prototype.wrapResult = function(te) {
    var ne = this._reporterState;
    return ne.options.partial ? {
      result: this.isError(te) ? null : te,
      errors: ne.errors
    } : te;
  };
  function ee(te, ne) {
    this.path = te, this.rethrow(ne);
  }
  return Y(ee, Error), ee.prototype.rethrow = function(te) {
    if (this.message = te + " at: " + (this.path || "(shallow)"), Error.captureStackTrace && Error.captureStackTrace(this, ee), !this.stack)
      try {
        throw new Error(this.message);
      } catch (ne) {
        this.stack = ne.stack;
      }
    return this;
  }, reporter;
}
var buffer = {}, hasRequiredBuffer;
function requireBuffer() {
  if (hasRequiredBuffer)
    return buffer;
  hasRequiredBuffer = 1;
  var Y = inherits_browserExports, X = requireBase().Reporter, ee = require$$0$3.Buffer;
  function te(ie, oe) {
    if (X.call(this, oe), !ee.isBuffer(ie)) {
      this.error("Input not Buffer");
      return;
    }
    this.base = ie, this.offset = 0, this.length = ie.length;
  }
  Y(te, X), buffer.DecoderBuffer = te, te.prototype.save = function() {
    return { offset: this.offset, reporter: X.prototype.save.call(this) };
  }, te.prototype.restore = function(ie) {
    var oe = new te(this.base);
    return oe.offset = ie.offset, oe.length = this.offset, this.offset = ie.offset, X.prototype.restore.call(this, ie.reporter), oe;
  }, te.prototype.isEmpty = function() {
    return this.offset === this.length;
  }, te.prototype.readUInt8 = function(ie) {
    return this.offset + 1 <= this.length ? this.base.readUInt8(this.offset++, !0) : this.error(ie || "DecoderBuffer overrun");
  }, te.prototype.skip = function(ie, oe) {
    if (!(this.offset + ie <= this.length))
      return this.error(oe || "DecoderBuffer overrun");
    var se = new te(this.base);
    return se._reporterState = this._reporterState, se.offset = this.offset, se.length = this.offset + ie, this.offset += ie, se;
  }, te.prototype.raw = function(ie) {
    return this.base.slice(ie ? ie.offset : this.offset, this.length);
  };
  function ne(ie, oe) {
    if (Array.isArray(ie))
      this.length = 0, this.value = ie.map(function(se) {
        return se instanceof ne || (se = new ne(se, oe)), this.length += se.length, se;
      }, this);
    else if (typeof ie == "number") {
      if (!(0 <= ie && ie <= 255))
        return oe.error("non-byte EncoderBuffer value");
      this.value = ie, this.length = 1;
    } else if (typeof ie == "string")
      this.value = ie, this.length = ee.byteLength(ie);
    else if (ee.isBuffer(ie))
      this.value = ie, this.length = ie.length;
    else
      return oe.error("Unsupported type: " + typeof ie);
  }
  return buffer.EncoderBuffer = ne, ne.prototype.join = function(ie, oe) {
    return ie || (ie = new ee(this.length)), oe || (oe = 0), this.length === 0 || (Array.isArray(this.value) ? this.value.forEach(function(se) {
      se.join(ie, oe), oe += se.length;
    }) : (typeof this.value == "number" ? ie[oe] = this.value : typeof this.value == "string" ? ie.write(this.value, oe) : ee.isBuffer(this.value) && this.value.copy(ie, oe), oe += this.length)), ie;
  }, buffer;
}
var node, hasRequiredNode;
function requireNode() {
  if (hasRequiredNode)
    return node;
  hasRequiredNode = 1;
  var Y = requireBase().Reporter, X = requireBase().EncoderBuffer, ee = requireBase().DecoderBuffer, te = requireMinimalisticAssert(), ne = [
    "seq",
    "seqof",
    "set",
    "setof",
    "objid",
    "bool",
    "gentime",
    "utctime",
    "null_",
    "enum",
    "int",
    "objDesc",
    "bitstr",
    "bmpstr",
    "charstr",
    "genstr",
    "graphstr",
    "ia5str",
    "iso646str",
    "numstr",
    "octstr",
    "printstr",
    "t61str",
    "unistr",
    "utf8str",
    "videostr"
  ], ie = [
    "key",
    "obj",
    "use",
    "optional",
    "explicit",
    "implicit",
    "def",
    "choice",
    "any",
    "contains"
  ].concat(ne), oe = [
    "_peekTag",
    "_decodeTag",
    "_use",
    "_decodeStr",
    "_decodeObjid",
    "_decodeTime",
    "_decodeNull",
    "_decodeInt",
    "_decodeBool",
    "_decodeList",
    "_encodeComposite",
    "_encodeStr",
    "_encodeObjid",
    "_encodeTime",
    "_encodeNull",
    "_encodeInt",
    "_encodeBool"
  ];
  function se(ue, le) {
    var he = {};
    this._baseState = he, he.enc = ue, he.parent = le || null, he.children = null, he.tag = null, he.args = null, he.reverseArgs = null, he.choice = null, he.optional = !1, he.any = !1, he.obj = !1, he.use = null, he.useDecoder = null, he.key = null, he.default = null, he.explicit = null, he.implicit = null, he.contains = null, he.parent || (he.children = [], this._wrap());
  }
  node = se;
  var ae = [
    "enc",
    "parent",
    "children",
    "tag",
    "args",
    "reverseArgs",
    "choice",
    "optional",
    "any",
    "obj",
    "use",
    "alteredUse",
    "key",
    "default",
    "explicit",
    "implicit",
    "contains"
  ];
  return se.prototype.clone = function() {
    var ue = this._baseState, le = {};
    ae.forEach(function(me) {
      le[me] = ue[me];
    });
    var he = new this.constructor(le.parent);
    return he._baseState = le, he;
  }, se.prototype._wrap = function() {
    var ue = this._baseState;
    ie.forEach(function(le) {
      this[le] = function() {
        var he = new this.constructor(this);
        return ue.children.push(he), he[le].apply(he, arguments);
      };
    }, this);
  }, se.prototype._init = function(ue) {
    var le = this._baseState;
    te(le.parent === null), ue.call(this), le.children = le.children.filter(function(he) {
      return he._baseState.parent === this;
    }, this), te.equal(le.children.length, 1, "Root node can have only one child");
  }, se.prototype._useArgs = function(ue) {
    var le = this._baseState, he = ue.filter(function(me) {
      return me instanceof this.constructor;
    }, this);
    ue = ue.filter(function(me) {
      return !(me instanceof this.constructor);
    }, this), he.length !== 0 && (te(le.children === null), le.children = he, he.forEach(function(me) {
      me._baseState.parent = this;
    }, this)), ue.length !== 0 && (te(le.args === null), le.args = ue, le.reverseArgs = ue.map(function(me) {
      if (typeof me != "object" || me.constructor !== Object)
        return me;
      var ye = {};
      return Object.keys(me).forEach(function(we) {
        we == (we | 0) && (we |= 0);
        var Ee = me[we];
        ye[Ee] = we;
      }), ye;
    }));
  }, oe.forEach(function(ue) {
    se.prototype[ue] = function() {
      var le = this._baseState;
      throw new Error(ue + " not implemented for encoding: " + le.enc);
    };
  }), ne.forEach(function(ue) {
    se.prototype[ue] = function() {
      var le = this._baseState, he = Array.prototype.slice.call(arguments);
      return te(le.tag === null), le.tag = ue, this._useArgs(he), this;
    };
  }), se.prototype.use = function(ue) {
    te(ue);
    var le = this._baseState;
    return te(le.use === null), le.use = ue, this;
  }, se.prototype.optional = function() {
    var ue = this._baseState;
    return ue.optional = !0, this;
  }, se.prototype.def = function(ue) {
    var le = this._baseState;
    return te(le.default === null), le.default = ue, le.optional = !0, this;
  }, se.prototype.explicit = function(ue) {
    var le = this._baseState;
    return te(le.explicit === null && le.implicit === null), le.explicit = ue, this;
  }, se.prototype.implicit = function(ue) {
    var le = this._baseState;
    return te(le.explicit === null && le.implicit === null), le.implicit = ue, this;
  }, se.prototype.obj = function() {
    var ue = this._baseState, le = Array.prototype.slice.call(arguments);
    return ue.obj = !0, le.length !== 0 && this._useArgs(le), this;
  }, se.prototype.key = function(ue) {
    var le = this._baseState;
    return te(le.key === null), le.key = ue, this;
  }, se.prototype.any = function() {
    var ue = this._baseState;
    return ue.any = !0, this;
  }, se.prototype.choice = function(ue) {
    var le = this._baseState;
    return te(le.choice === null), le.choice = ue, this._useArgs(Object.keys(ue).map(function(he) {
      return ue[he];
    })), this;
  }, se.prototype.contains = function(ue) {
    var le = this._baseState;
    return te(le.use === null), le.contains = ue, this;
  }, se.prototype._decode = function(ue, le) {
    var he = this._baseState;
    if (he.parent === null)
      return ue.wrapResult(he.children[0]._decode(ue, le));
    var me = he.default, ye = !0, we = null;
    if (he.key !== null && (we = ue.enterKey(he.key)), he.optional) {
      var Ee = null;
      if (he.explicit !== null ? Ee = he.explicit : he.implicit !== null ? Ee = he.implicit : he.tag !== null && (Ee = he.tag), Ee === null && !he.any) {
        var Re = ue.save();
        try {
          he.choice === null ? this._decodeGeneric(he.tag, ue, le) : this._decodeChoice(ue, le), ye = !0;
        } catch {
          ye = !1;
        }
        ue.restore(Re);
      } else if (ye = this._peekTag(ue, Ee, he.any), ue.isError(ye))
        return ye;
    }
    var Ue;
    if (he.obj && ye && (Ue = ue.enterObject()), ye) {
      if (he.explicit !== null) {
        var Me = this._decodeTag(ue, he.explicit);
        if (ue.isError(Me))
          return Me;
        ue = Me;
      }
      var De = ue.offset;
      if (he.use === null && he.choice === null) {
        if (he.any)
          var Re = ue.save();
        var Fe = this._decodeTag(
          ue,
          he.implicit !== null ? he.implicit : he.tag,
          he.any
        );
        if (ue.isError(Fe))
          return Fe;
        he.any ? me = ue.raw(Re) : ue = Fe;
      }
      if (le && le.track && he.tag !== null && le.track(ue.path(), De, ue.length, "tagged"), le && le.track && he.tag !== null && le.track(ue.path(), ue.offset, ue.length, "content"), he.any ? me = me : he.choice === null ? me = this._decodeGeneric(he.tag, ue, le) : me = this._decodeChoice(ue, le), ue.isError(me))
        return me;
      if (!he.any && he.choice === null && he.children !== null && he.children.forEach(function(tt) {
        tt._decode(ue, le);
      }), he.contains && (he.tag === "octstr" || he.tag === "bitstr")) {
        var Ke = new ee(me);
        me = this._getUse(he.contains, ue._reporterState.obj)._decode(Ke, le);
      }
    }
    return he.obj && ye && (me = ue.leaveObject(Ue)), he.key !== null && (me !== null || ye === !0) ? ue.leaveKey(we, he.key, me) : we !== null && ue.exitKey(we), me;
  }, se.prototype._decodeGeneric = function(ue, le, he) {
    var me = this._baseState;
    return ue === "seq" || ue === "set" ? null : ue === "seqof" || ue === "setof" ? this._decodeList(le, ue, me.args[0], he) : /str$/.test(ue) ? this._decodeStr(le, ue, he) : ue === "objid" && me.args ? this._decodeObjid(le, me.args[0], me.args[1], he) : ue === "objid" ? this._decodeObjid(le, null, null, he) : ue === "gentime" || ue === "utctime" ? this._decodeTime(le, ue, he) : ue === "null_" ? this._decodeNull(le, he) : ue === "bool" ? this._decodeBool(le, he) : ue === "objDesc" ? this._decodeStr(le, ue, he) : ue === "int" || ue === "enum" ? this._decodeInt(le, me.args && me.args[0], he) : me.use !== null ? this._getUse(me.use, le._reporterState.obj)._decode(le, he) : le.error("unknown tag: " + ue);
  }, se.prototype._getUse = function(ue, le) {
    var he = this._baseState;
    return he.useDecoder = this._use(ue, le), te(he.useDecoder._baseState.parent === null), he.useDecoder = he.useDecoder._baseState.children[0], he.implicit !== he.useDecoder._baseState.implicit && (he.useDecoder = he.useDecoder.clone(), he.useDecoder._baseState.implicit = he.implicit), he.useDecoder;
  }, se.prototype._decodeChoice = function(ue, le) {
    var he = this._baseState, me = null, ye = !1;
    return Object.keys(he.choice).some(function(we) {
      var Ee = ue.save(), Re = he.choice[we];
      try {
        var Ue = Re._decode(ue, le);
        if (ue.isError(Ue))
          return !1;
        me = { type: we, value: Ue }, ye = !0;
      } catch {
        return ue.restore(Ee), !1;
      }
      return !0;
    }, this), ye ? me : ue.error("Choice not matched");
  }, se.prototype._createEncoderBuffer = function(ue) {
    return new X(ue, this.reporter);
  }, se.prototype._encode = function(ue, le, he) {
    var me = this._baseState;
    if (!(me.default !== null && me.default === ue)) {
      var ye = this._encodeValue(ue, le, he);
      if (ye !== void 0 && !this._skipDefault(ye, le, he))
        return ye;
    }
  }, se.prototype._encodeValue = function(ue, le, he) {
    var me = this._baseState;
    if (me.parent === null)
      return me.children[0]._encode(ue, le || new Y());
    var Re = null;
    if (this.reporter = le, me.optional && ue === void 0)
      if (me.default !== null)
        ue = me.default;
      else
        return;
    var ye = null, we = !1;
    if (me.any)
      Re = this._createEncoderBuffer(ue);
    else if (me.choice)
      Re = this._encodeChoice(ue, le);
    else if (me.contains)
      ye = this._getUse(me.contains, he)._encode(ue, le), we = !0;
    else if (me.children)
      ye = me.children.map(function(De) {
        if (De._baseState.tag === "null_")
          return De._encode(null, le, ue);
        if (De._baseState.key === null)
          return le.error("Child should have a key");
        var Fe = le.enterKey(De._baseState.key);
        if (typeof ue != "object")
          return le.error("Child expected, but input is not object");
        var Ke = De._encode(ue[De._baseState.key], le, ue);
        return le.leaveKey(Fe), Ke;
      }, this).filter(function(De) {
        return De;
      }), ye = this._createEncoderBuffer(ye);
    else if (me.tag === "seqof" || me.tag === "setof") {
      if (!(me.args && me.args.length === 1))
        return le.error("Too many args for : " + me.tag);
      if (!Array.isArray(ue))
        return le.error("seqof/setof, but data is not Array");
      var Ee = this.clone();
      Ee._baseState.implicit = null, ye = this._createEncoderBuffer(ue.map(function(De) {
        var Fe = this._baseState;
        return this._getUse(Fe.args[0], ue)._encode(De, le);
      }, Ee));
    } else
      me.use !== null ? Re = this._getUse(me.use, he)._encode(ue, le) : (ye = this._encodePrimitive(me.tag, ue), we = !0);
    var Re;
    if (!me.any && me.choice === null) {
      var Ue = me.implicit !== null ? me.implicit : me.tag, Me = me.implicit === null ? "universal" : "context";
      Ue === null ? me.use === null && le.error("Tag could be omitted only for .use()") : me.use === null && (Re = this._encodeComposite(Ue, we, Me, ye));
    }
    return me.explicit !== null && (Re = this._encodeComposite(me.explicit, !1, "context", Re)), Re;
  }, se.prototype._encodeChoice = function(ue, le) {
    var he = this._baseState, me = he.choice[ue.type];
    return me || te(
      !1,
      ue.type + " not found in " + JSON.stringify(Object.keys(he.choice))
    ), me._encode(ue.value, le);
  }, se.prototype._encodePrimitive = function(ue, le) {
    var he = this._baseState;
    if (/str$/.test(ue))
      return this._encodeStr(le, ue);
    if (ue === "objid" && he.args)
      return this._encodeObjid(le, he.reverseArgs[0], he.args[1]);
    if (ue === "objid")
      return this._encodeObjid(le, null, null);
    if (ue === "gentime" || ue === "utctime")
      return this._encodeTime(le, ue);
    if (ue === "null_")
      return this._encodeNull();
    if (ue === "int" || ue === "enum")
      return this._encodeInt(le, he.args && he.reverseArgs[0]);
    if (ue === "bool")
      return this._encodeBool(le);
    if (ue === "objDesc")
      return this._encodeStr(le, ue);
    throw new Error("Unsupported tag: " + ue);
  }, se.prototype._isNumstr = function(ue) {
    return /^[0-9 ]*$/.test(ue);
  }, se.prototype._isPrintstr = function(ue) {
    return /^[A-Za-z0-9 '\(\)\+,\-\.\/:=\?]*$/.test(ue);
  }, node;
}
var hasRequiredBase;
function requireBase() {
  return hasRequiredBase || (hasRequiredBase = 1, function(Y) {
    var X = Y;
    X.Reporter = requireReporter().Reporter, X.DecoderBuffer = requireBuffer().DecoderBuffer, X.EncoderBuffer = requireBuffer().EncoderBuffer, X.Node = requireNode();
  }(base$2)), base$2;
}
var constants = {}, der = {}, hasRequiredDer$2;
function requireDer$2() {
  return hasRequiredDer$2 || (hasRequiredDer$2 = 1, function(Y) {
    var X = requireConstants();
    Y.tagClass = {
      0: "universal",
      1: "application",
      2: "context",
      3: "private"
    }, Y.tagClassByName = X._reverse(Y.tagClass), Y.tag = {
      0: "end",
      1: "bool",
      2: "int",
      3: "bitstr",
      4: "octstr",
      5: "null_",
      6: "objid",
      7: "objDesc",
      8: "external",
      9: "real",
      10: "enum",
      11: "embed",
      12: "utf8str",
      13: "relativeOid",
      16: "seq",
      17: "set",
      18: "numstr",
      19: "printstr",
      20: "t61str",
      21: "videostr",
      22: "ia5str",
      23: "utctime",
      24: "gentime",
      25: "graphstr",
      26: "iso646str",
      27: "genstr",
      28: "unistr",
      29: "charstr",
      30: "bmpstr"
    }, Y.tagByName = X._reverse(Y.tag);
  }(der)), der;
}
var hasRequiredConstants;
function requireConstants() {
  return hasRequiredConstants || (hasRequiredConstants = 1, function(Y) {
    var X = Y;
    X._reverse = function(ee) {
      var te = {};
      return Object.keys(ee).forEach(function(ne) {
        (ne | 0) == ne && (ne = ne | 0);
        var ie = ee[ne];
        te[ie] = ne;
      }), te;
    }, X.der = requireDer$2();
  }(constants)), constants;
}
var decoders = {}, der_1$1, hasRequiredDer$1;
function requireDer$1() {
  if (hasRequiredDer$1)
    return der_1$1;
  hasRequiredDer$1 = 1;
  var Y = inherits_browserExports, X = requireAsn1$1(), ee = X.base, te = X.bignum, ne = X.constants.der;
  function ie(ue) {
    this.enc = "der", this.name = ue.name, this.entity = ue, this.tree = new oe(), this.tree._init(ue.body);
  }
  der_1$1 = ie, ie.prototype.decode = function(ue, le) {
    return ue instanceof ee.DecoderBuffer || (ue = new ee.DecoderBuffer(ue, le)), this.tree._decode(ue, le);
  };
  function oe(ue) {
    ee.Node.call(this, "der", ue);
  }
  Y(oe, ee.Node), oe.prototype._peekTag = function(ue, le, he) {
    if (ue.isEmpty())
      return !1;
    var me = ue.save(), ye = se(ue, 'Failed to peek tag: "' + le + '"');
    return ue.isError(ye) ? ye : (ue.restore(me), ye.tag === le || ye.tagStr === le || ye.tagStr + "of" === le || he);
  }, oe.prototype._decodeTag = function(ue, le, he) {
    var me = se(
      ue,
      'Failed to decode tag of "' + le + '"'
    );
    if (ue.isError(me))
      return me;
    var ye = ae(
      ue,
      me.primitive,
      'Failed to get length of "' + le + '"'
    );
    if (ue.isError(ye))
      return ye;
    if (!he && me.tag !== le && me.tagStr !== le && me.tagStr + "of" !== le)
      return ue.error('Failed to match tag: "' + le + '"');
    if (me.primitive || ye !== null)
      return ue.skip(ye, 'Failed to match body of: "' + le + '"');
    var we = ue.save(), Ee = this._skipUntilEnd(
      ue,
      'Failed to skip indefinite length body: "' + this.tag + '"'
    );
    return ue.isError(Ee) ? Ee : (ye = ue.offset - we.offset, ue.restore(we), ue.skip(ye, 'Failed to match body of: "' + le + '"'));
  }, oe.prototype._skipUntilEnd = function(ue, le) {
    for (; ; ) {
      var he = se(ue, le);
      if (ue.isError(he))
        return he;
      var me = ae(ue, he.primitive, le);
      if (ue.isError(me))
        return me;
      var ye;
      if (he.primitive || me !== null ? ye = ue.skip(me) : ye = this._skipUntilEnd(ue, le), ue.isError(ye))
        return ye;
      if (he.tagStr === "end")
        break;
    }
  }, oe.prototype._decodeList = function(ue, le, he, me) {
    for (var ye = []; !ue.isEmpty(); ) {
      var we = this._peekTag(ue, "end");
      if (ue.isError(we))
        return we;
      var Ee = he.decode(ue, "der", me);
      if (ue.isError(Ee) && we)
        break;
      ye.push(Ee);
    }
    return ye;
  }, oe.prototype._decodeStr = function(ue, le) {
    if (le === "bitstr") {
      var he = ue.readUInt8();
      return ue.isError(he) ? he : { unused: he, data: ue.raw() };
    } else if (le === "bmpstr") {
      var me = ue.raw();
      if (me.length % 2 === 1)
        return ue.error("Decoding of string type: bmpstr length mismatch");
      for (var ye = "", we = 0; we < me.length / 2; we++)
        ye += String.fromCharCode(me.readUInt16BE(we * 2));
      return ye;
    } else if (le === "numstr") {
      var Ee = ue.raw().toString("ascii");
      return this._isNumstr(Ee) ? Ee : ue.error("Decoding of string type: numstr unsupported characters");
    } else {
      if (le === "octstr" || le === "objDesc")
        return ue.raw();
      if (le === "printstr") {
        var Re = ue.raw().toString("ascii");
        return this._isPrintstr(Re) ? Re : ue.error("Decoding of string type: printstr unsupported characters");
      } else
        return /str$/.test(le) ? ue.raw().toString() : ue.error("Decoding of string type: " + le + " unsupported");
    }
  }, oe.prototype._decodeObjid = function(ue, le, he) {
    for (var me, ye = [], we = 0; !ue.isEmpty(); ) {
      var Ee = ue.readUInt8();
      we <<= 7, we |= Ee & 127, Ee & 128 || (ye.push(we), we = 0);
    }
    Ee & 128 && ye.push(we);
    var Re = ye[0] / 40 | 0, Ue = ye[0] % 40;
    if (he ? me = ye : me = [Re, Ue].concat(ye.slice(1)), le) {
      var Me = le[me.join(" ")];
      Me === void 0 && (Me = le[me.join(".")]), Me !== void 0 && (me = Me);
    }
    return me;
  }, oe.prototype._decodeTime = function(ue, le) {
    var he = ue.raw().toString();
    if (le === "gentime")
      var me = he.slice(0, 4) | 0, ye = he.slice(4, 6) | 0, we = he.slice(6, 8) | 0, Ee = he.slice(8, 10) | 0, Re = he.slice(10, 12) | 0, Ue = he.slice(12, 14) | 0;
    else if (le === "utctime") {
      var me = he.slice(0, 2) | 0, ye = he.slice(2, 4) | 0, we = he.slice(4, 6) | 0, Ee = he.slice(6, 8) | 0, Re = he.slice(8, 10) | 0, Ue = he.slice(10, 12) | 0;
      me < 70 ? me = 2e3 + me : me = 1900 + me;
    } else
      return ue.error("Decoding " + le + " time is not supported yet");
    return Date.UTC(me, ye - 1, we, Ee, Re, Ue, 0);
  }, oe.prototype._decodeNull = function(ue) {
    return null;
  }, oe.prototype._decodeBool = function(ue) {
    var le = ue.readUInt8();
    return ue.isError(le) ? le : le !== 0;
  }, oe.prototype._decodeInt = function(ue, le) {
    var he = ue.raw(), me = new te(he);
    return le && (me = le[me.toString(10)] || me), me;
  }, oe.prototype._use = function(ue, le) {
    return typeof ue == "function" && (ue = ue(le)), ue._getDecoder("der").tree;
  };
  function se(ue, le) {
    var he = ue.readUInt8(le);
    if (ue.isError(he))
      return he;
    var me = ne.tagClass[he >> 6], ye = (he & 32) === 0;
    if ((he & 31) === 31) {
      var we = he;
      for (he = 0; (we & 128) === 128; ) {
        if (we = ue.readUInt8(le), ue.isError(we))
          return we;
        he <<= 7, he |= we & 127;
      }
    } else
      he &= 31;
    var Ee = ne.tag[he];
    return {
      cls: me,
      primitive: ye,
      tag: he,
      tagStr: Ee
    };
  }
  function ae(ue, le, he) {
    var me = ue.readUInt8(he);
    if (ue.isError(me))
      return me;
    if (!le && me === 128)
      return null;
    if (!(me & 128))
      return me;
    var ye = me & 127;
    if (ye > 4)
      return ue.error("length octect is too long");
    me = 0;
    for (var we = 0; we < ye; we++) {
      me <<= 8;
      var Ee = ue.readUInt8(he);
      if (ue.isError(Ee))
        return Ee;
      me |= Ee;
    }
    return me;
  }
  return der_1$1;
}
var pem$1, hasRequiredPem$1;
function requirePem$1() {
  if (hasRequiredPem$1)
    return pem$1;
  hasRequiredPem$1 = 1;
  var Y = inherits_browserExports, X = require$$0$3.Buffer, ee = requireDer$1();
  function te(ne) {
    ee.call(this, ne), this.enc = "pem";
  }
  return Y(te, ee), pem$1 = te, te.prototype.decode = function(ne, ie) {
    for (var oe = ne.toString().split(/[\r\n]+/g), se = ie.label.toUpperCase(), ae = /^-----(BEGIN|END) ([^-]+)-----$/, ue = -1, le = -1, he = 0; he < oe.length; he++) {
      var me = oe[he].match(ae);
      if (me !== null && me[2] === se)
        if (ue === -1) {
          if (me[1] !== "BEGIN")
            break;
          ue = he;
        } else {
          if (me[1] !== "END")
            break;
          le = he;
          break;
        }
    }
    if (ue === -1 || le === -1)
      throw new Error("PEM section not found for: " + se);
    var ye = oe.slice(ue + 1, le).join("");
    ye.replace(/[^a-z0-9\+\/=]+/gi, "");
    var we = new X(ye, "base64");
    return ee.prototype.decode.call(this, we, ie);
  }, pem$1;
}
var hasRequiredDecoders;
function requireDecoders() {
  return hasRequiredDecoders || (hasRequiredDecoders = 1, function(Y) {
    var X = Y;
    X.der = requireDer$1(), X.pem = requirePem$1();
  }(decoders)), decoders;
}
var encoders = {}, der_1, hasRequiredDer;
function requireDer() {
  if (hasRequiredDer)
    return der_1;
  hasRequiredDer = 1;
  var Y = inherits_browserExports, X = require$$0$3.Buffer, ee = requireAsn1$1(), te = ee.base, ne = ee.constants.der;
  function ie(ue) {
    this.enc = "der", this.name = ue.name, this.entity = ue, this.tree = new oe(), this.tree._init(ue.body);
  }
  der_1 = ie, ie.prototype.encode = function(ue, le) {
    return this.tree._encode(ue, le).join();
  };
  function oe(ue) {
    te.Node.call(this, "der", ue);
  }
  Y(oe, te.Node), oe.prototype._encodeComposite = function(ue, le, he, me) {
    var ye = ae(ue, le, he, this.reporter);
    if (me.length < 128) {
      var Re = new X(2);
      return Re[0] = ye, Re[1] = me.length, this._createEncoderBuffer([Re, me]);
    }
    for (var we = 1, Ee = me.length; Ee >= 256; Ee >>= 8)
      we++;
    var Re = new X(2 + we);
    Re[0] = ye, Re[1] = 128 | we;
    for (var Ee = 1 + we, Ue = me.length; Ue > 0; Ee--, Ue >>= 8)
      Re[Ee] = Ue & 255;
    return this._createEncoderBuffer([Re, me]);
  }, oe.prototype._encodeStr = function(ue, le) {
    if (le === "bitstr")
      return this._createEncoderBuffer([ue.unused | 0, ue.data]);
    if (le === "bmpstr") {
      for (var he = new X(ue.length * 2), me = 0; me < ue.length; me++)
        he.writeUInt16BE(ue.charCodeAt(me), me * 2);
      return this._createEncoderBuffer(he);
    } else
      return le === "numstr" ? this._isNumstr(ue) ? this._createEncoderBuffer(ue) : this.reporter.error("Encoding of string type: numstr supports only digits and space") : le === "printstr" ? this._isPrintstr(ue) ? this._createEncoderBuffer(ue) : this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark") : /str$/.test(le) ? this._createEncoderBuffer(ue) : le === "objDesc" ? this._createEncoderBuffer(ue) : this.reporter.error("Encoding of string type: " + le + " unsupported");
  }, oe.prototype._encodeObjid = function(ue, le, he) {
    if (typeof ue == "string") {
      if (!le)
        return this.reporter.error("string objid given, but no values map found");
      if (!le.hasOwnProperty(ue))
        return this.reporter.error("objid not found in values map");
      ue = le[ue].split(/[\s\.]+/g);
      for (var me = 0; me < ue.length; me++)
        ue[me] |= 0;
    } else if (Array.isArray(ue)) {
      ue = ue.slice();
      for (var me = 0; me < ue.length; me++)
        ue[me] |= 0;
    }
    if (!Array.isArray(ue))
      return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(ue));
    if (!he) {
      if (ue[1] >= 40)
        return this.reporter.error("Second objid identifier OOB");
      ue.splice(0, 2, ue[0] * 40 + ue[1]);
    }
    for (var ye = 0, me = 0; me < ue.length; me++) {
      var we = ue[me];
      for (ye++; we >= 128; we >>= 7)
        ye++;
    }
    for (var Ee = new X(ye), Re = Ee.length - 1, me = ue.length - 1; me >= 0; me--) {
      var we = ue[me];
      for (Ee[Re--] = we & 127; (we >>= 7) > 0; )
        Ee[Re--] = 128 | we & 127;
    }
    return this._createEncoderBuffer(Ee);
  };
  function se(ue) {
    return ue < 10 ? "0" + ue : ue;
  }
  oe.prototype._encodeTime = function(ue, le) {
    var he, me = new Date(ue);
    return le === "gentime" ? he = [
      se(me.getFullYear()),
      se(me.getUTCMonth() + 1),
      se(me.getUTCDate()),
      se(me.getUTCHours()),
      se(me.getUTCMinutes()),
      se(me.getUTCSeconds()),
      "Z"
    ].join("") : le === "utctime" ? he = [
      se(me.getFullYear() % 100),
      se(me.getUTCMonth() + 1),
      se(me.getUTCDate()),
      se(me.getUTCHours()),
      se(me.getUTCMinutes()),
      se(me.getUTCSeconds()),
      "Z"
    ].join("") : this.reporter.error("Encoding " + le + " time is not supported yet"), this._encodeStr(he, "octstr");
  }, oe.prototype._encodeNull = function() {
    return this._createEncoderBuffer("");
  }, oe.prototype._encodeInt = function(ue, le) {
    if (typeof ue == "string") {
      if (!le)
        return this.reporter.error("String int or enum given, but no values map");
      if (!le.hasOwnProperty(ue))
        return this.reporter.error("Values map doesn't contain: " + JSON.stringify(ue));
      ue = le[ue];
    }
    if (typeof ue != "number" && !X.isBuffer(ue)) {
      var he = ue.toArray();
      !ue.sign && he[0] & 128 && he.unshift(0), ue = new X(he);
    }
    if (X.isBuffer(ue)) {
      var me = ue.length;
      ue.length === 0 && me++;
      var ye = new X(me);
      return ue.copy(ye), ue.length === 0 && (ye[0] = 0), this._createEncoderBuffer(ye);
    }
    if (ue < 128)
      return this._createEncoderBuffer(ue);
    if (ue < 256)
      return this._createEncoderBuffer([0, ue]);
    for (var me = 1, we = ue; we >= 256; we >>= 8)
      me++;
    for (var ye = new Array(me), we = ye.length - 1; we >= 0; we--)
      ye[we] = ue & 255, ue >>= 8;
    return ye[0] & 128 && ye.unshift(0), this._createEncoderBuffer(new X(ye));
  }, oe.prototype._encodeBool = function(ue) {
    return this._createEncoderBuffer(ue ? 255 : 0);
  }, oe.prototype._use = function(ue, le) {
    return typeof ue == "function" && (ue = ue(le)), ue._getEncoder("der").tree;
  }, oe.prototype._skipDefault = function(ue, le, he) {
    var me = this._baseState, ye;
    if (me.default === null)
      return !1;
    var we = ue.join();
    if (me.defaultBuffer === void 0 && (me.defaultBuffer = this._encodeValue(me.default, le, he).join()), we.length !== me.defaultBuffer.length)
      return !1;
    for (ye = 0; ye < we.length; ye++)
      if (we[ye] !== me.defaultBuffer[ye])
        return !1;
    return !0;
  };
  function ae(ue, le, he, me) {
    var ye;
    if (ue === "seqof" ? ue = "seq" : ue === "setof" && (ue = "set"), ne.tagByName.hasOwnProperty(ue))
      ye = ne.tagByName[ue];
    else if (typeof ue == "number" && (ue | 0) === ue)
      ye = ue;
    else
      return me.error("Unknown tag: " + ue);
    return ye >= 31 ? me.error("Multi-octet tag encoding unsupported") : (le || (ye |= 32), ye |= ne.tagClassByName[he || "universal"] << 6, ye);
  }
  return der_1;
}
var pem, hasRequiredPem;
function requirePem() {
  if (hasRequiredPem)
    return pem;
  hasRequiredPem = 1;
  var Y = inherits_browserExports, X = requireDer();
  function ee(te) {
    X.call(this, te), this.enc = "pem";
  }
  return Y(ee, X), pem = ee, ee.prototype.encode = function(te, ne) {
    for (var ie = X.prototype.encode.call(this, te), oe = ie.toString("base64"), se = ["-----BEGIN " + ne.label + "-----"], ae = 0; ae < oe.length; ae += 64)
      se.push(oe.slice(ae, ae + 64));
    return se.push("-----END " + ne.label + "-----"), se.join(`
`);
  }, pem;
}
var hasRequiredEncoders;
function requireEncoders() {
  return hasRequiredEncoders || (hasRequiredEncoders = 1, function(Y) {
    var X = Y;
    X.der = requireDer(), X.pem = requirePem();
  }(encoders)), encoders;
}
var hasRequiredAsn1$1;
function requireAsn1$1() {
  return hasRequiredAsn1$1 || (hasRequiredAsn1$1 = 1, function(Y) {
    var X = Y;
    X.bignum = requireBn(), X.define = requireApi().define, X.base = requireBase(), X.constants = requireConstants(), X.decoders = requireDecoders(), X.encoders = requireEncoders();
  }(asn1)), asn1;
}
var certificate, hasRequiredCertificate;
function requireCertificate() {
  if (hasRequiredCertificate)
    return certificate;
  hasRequiredCertificate = 1;
  var Y = requireAsn1$1(), X = Y.define("Time", function() {
    this.choice({
      utcTime: this.utctime(),
      generalTime: this.gentime()
    });
  }), ee = Y.define("AttributeTypeValue", function() {
    this.seq().obj(
      this.key("type").objid(),
      this.key("value").any()
    );
  }), te = Y.define("AlgorithmIdentifier", function() {
    this.seq().obj(
      this.key("algorithm").objid(),
      this.key("parameters").optional(),
      this.key("curve").objid().optional()
    );
  }), ne = Y.define("SubjectPublicKeyInfo", function() {
    this.seq().obj(
      this.key("algorithm").use(te),
      this.key("subjectPublicKey").bitstr()
    );
  }), ie = Y.define("RelativeDistinguishedName", function() {
    this.setof(ee);
  }), oe = Y.define("RDNSequence", function() {
    this.seqof(ie);
  }), se = Y.define("Name", function() {
    this.choice({
      rdnSequence: this.use(oe)
    });
  }), ae = Y.define("Validity", function() {
    this.seq().obj(
      this.key("notBefore").use(X),
      this.key("notAfter").use(X)
    );
  }), ue = Y.define("Extension", function() {
    this.seq().obj(
      this.key("extnID").objid(),
      this.key("critical").bool().def(!1),
      this.key("extnValue").octstr()
    );
  }), le = Y.define("TBSCertificate", function() {
    this.seq().obj(
      this.key("version").explicit(0).int().optional(),
      this.key("serialNumber").int(),
      this.key("signature").use(te),
      this.key("issuer").use(se),
      this.key("validity").use(ae),
      this.key("subject").use(se),
      this.key("subjectPublicKeyInfo").use(ne),
      this.key("issuerUniqueID").implicit(1).bitstr().optional(),
      this.key("subjectUniqueID").implicit(2).bitstr().optional(),
      this.key("extensions").explicit(3).seqof(ue).optional()
    );
  }), he = Y.define("X509Certificate", function() {
    this.seq().obj(
      this.key("tbsCertificate").use(le),
      this.key("signatureAlgorithm").use(te),
      this.key("signatureValue").bitstr()
    );
  });
  return certificate = he, certificate;
}
var hasRequiredAsn1;
function requireAsn1() {
  if (hasRequiredAsn1)
    return asn1$1;
  hasRequiredAsn1 = 1;
  var Y = requireAsn1$1();
  asn1$1.certificate = requireCertificate();
  var X = Y.define("RSAPrivateKey", function() {
    this.seq().obj(
      this.key("version").int(),
      this.key("modulus").int(),
      this.key("publicExponent").int(),
      this.key("privateExponent").int(),
      this.key("prime1").int(),
      this.key("prime2").int(),
      this.key("exponent1").int(),
      this.key("exponent2").int(),
      this.key("coefficient").int()
    );
  });
  asn1$1.RSAPrivateKey = X;
  var ee = Y.define("RSAPublicKey", function() {
    this.seq().obj(
      this.key("modulus").int(),
      this.key("publicExponent").int()
    );
  });
  asn1$1.RSAPublicKey = ee;
  var te = Y.define("AlgorithmIdentifier", function() {
    this.seq().obj(
      this.key("algorithm").objid(),
      this.key("none").null_().optional(),
      this.key("curve").objid().optional(),
      this.key("params").seq().obj(
        this.key("p").int(),
        this.key("q").int(),
        this.key("g").int()
      ).optional()
    );
  }), ne = Y.define("SubjectPublicKeyInfo", function() {
    this.seq().obj(
      this.key("algorithm").use(te),
      this.key("subjectPublicKey").bitstr()
    );
  });
  asn1$1.PublicKey = ne;
  var ie = Y.define("PrivateKeyInfo", function() {
    this.seq().obj(
      this.key("version").int(),
      this.key("algorithm").use(te),
      this.key("subjectPrivateKey").octstr()
    );
  });
  asn1$1.PrivateKey = ie;
  var oe = Y.define("EncryptedPrivateKeyInfo", function() {
    this.seq().obj(
      this.key("algorithm").seq().obj(
        this.key("id").objid(),
        this.key("decrypt").seq().obj(
          this.key("kde").seq().obj(
            this.key("id").objid(),
            this.key("kdeparams").seq().obj(
              this.key("salt").octstr(),
              this.key("iters").int()
            )
          ),
          this.key("cipher").seq().obj(
            this.key("algo").objid(),
            this.key("iv").octstr()
          )
        )
      ),
      this.key("subjectPrivateKey").octstr()
    );
  });
  asn1$1.EncryptedPrivateKey = oe;
  var se = Y.define("DSAPrivateKey", function() {
    this.seq().obj(
      this.key("version").int(),
      this.key("p").int(),
      this.key("q").int(),
      this.key("g").int(),
      this.key("pub_key").int(),
      this.key("priv_key").int()
    );
  });
  asn1$1.DSAPrivateKey = se, asn1$1.DSAparam = Y.define("DSAparam", function() {
    this.int();
  });
  var ae = Y.define("ECParameters", function() {
    this.choice({
      namedCurve: this.objid()
    });
  }), ue = Y.define("ECPrivateKey", function() {
    this.seq().obj(
      this.key("version").int(),
      this.key("privateKey").octstr(),
      this.key("parameters").optional().explicit(0).use(ae),
      this.key("publicKey").optional().explicit(1).bitstr()
    );
  });
  return asn1$1.ECPrivateKey = ue, asn1$1.signature = Y.define("signature", function() {
    this.seq().obj(
      this.key("r").int(),
      this.key("s").int()
    );
  }), asn1$1;
}
const require$$1$1 = {
  "2.16.840.1.101.3.4.1.1": "aes-128-ecb",
  "2.16.840.1.101.3.4.1.2": "aes-128-cbc",
  "2.16.840.1.101.3.4.1.3": "aes-128-ofb",
  "2.16.840.1.101.3.4.1.4": "aes-128-cfb",
  "2.16.840.1.101.3.4.1.21": "aes-192-ecb",
  "2.16.840.1.101.3.4.1.22": "aes-192-cbc",
  "2.16.840.1.101.3.4.1.23": "aes-192-ofb",
  "2.16.840.1.101.3.4.1.24": "aes-192-cfb",
  "2.16.840.1.101.3.4.1.41": "aes-256-ecb",
  "2.16.840.1.101.3.4.1.42": "aes-256-cbc",
  "2.16.840.1.101.3.4.1.43": "aes-256-ofb",
  "2.16.840.1.101.3.4.1.44": "aes-256-cfb"
};
var fixProc, hasRequiredFixProc;
function requireFixProc() {
  if (hasRequiredFixProc)
    return fixProc;
  hasRequiredFixProc = 1;
  var Y = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m, X = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m, ee = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m, te = requireEvp_bytestokey(), ne = requireBrowser$6(), ie = safeBufferExports.Buffer;
  return fixProc = function(oe, se) {
    var ae = oe.toString(), ue = ae.match(Y), le;
    if (ue) {
      var he = "aes" + ue[1], me = ie.from(ue[2], "hex"), ye = ie.from(ue[3].replace(/[\r\n]/g, ""), "base64"), we = te(se, me.slice(0, 8), parseInt(ue[1], 10)).key, Ee = [], Re = ne.createDecipheriv(he, we, me);
      Ee.push(Re.update(ye)), Ee.push(Re.final()), le = ie.concat(Ee);
    } else {
      var Ue = ae.match(ee);
      le = ie.from(Ue[2].replace(/[\r\n]/g, ""), "base64");
    }
    var Me = ae.match(X)[1];
    return {
      tag: Me,
      data: le
    };
  }, fixProc;
}
var parseAsn1, hasRequiredParseAsn1;
function requireParseAsn1() {
  if (hasRequiredParseAsn1)
    return parseAsn1;
  hasRequiredParseAsn1 = 1;
  var Y = requireAsn1(), X = require$$1$1, ee = requireFixProc(), te = requireBrowser$6(), ne = requireBrowser$7(), ie = safeBufferExports.Buffer;
  function oe(ae, ue) {
    var le = ae.algorithm.decrypt.kde.kdeparams.salt, he = parseInt(ae.algorithm.decrypt.kde.kdeparams.iters.toString(), 10), me = X[ae.algorithm.decrypt.cipher.algo.join(".")], ye = ae.algorithm.decrypt.cipher.iv, we = ae.subjectPrivateKey, Ee = parseInt(me.split("-")[1], 10) / 8, Re = ne.pbkdf2Sync(ue, le, he, Ee, "sha1"), Ue = te.createDecipheriv(me, Re, ye), Me = [];
    return Me.push(Ue.update(we)), Me.push(Ue.final()), ie.concat(Me);
  }
  function se(ae) {
    var ue;
    typeof ae == "object" && !ie.isBuffer(ae) && (ue = ae.passphrase, ae = ae.key), typeof ae == "string" && (ae = ie.from(ae));
    var le = ee(ae, ue), he = le.tag, me = le.data, ye, we;
    switch (he) {
      case "CERTIFICATE":
        we = Y.certificate.decode(me, "der").tbsCertificate.subjectPublicKeyInfo;
      case "PUBLIC KEY":
        switch (we || (we = Y.PublicKey.decode(me, "der")), ye = we.algorithm.algorithm.join("."), ye) {
          case "1.2.840.113549.1.1.1":
            return Y.RSAPublicKey.decode(we.subjectPublicKey.data, "der");
          case "1.2.840.10045.2.1":
            return we.subjectPrivateKey = we.subjectPublicKey, {
              type: "ec",
              data: we
            };
          case "1.2.840.10040.4.1":
            return we.algorithm.params.pub_key = Y.DSAparam.decode(we.subjectPublicKey.data, "der"), {
              type: "dsa",
              data: we.algorithm.params
            };
          default:
            throw new Error("unknown key id " + ye);
        }
      case "ENCRYPTED PRIVATE KEY":
        me = Y.EncryptedPrivateKey.decode(me, "der"), me = oe(me, ue);
      case "PRIVATE KEY":
        switch (we = Y.PrivateKey.decode(me, "der"), ye = we.algorithm.algorithm.join("."), ye) {
          case "1.2.840.113549.1.1.1":
            return Y.RSAPrivateKey.decode(we.subjectPrivateKey, "der");
          case "1.2.840.10045.2.1":
            return {
              curve: we.algorithm.curve,
              privateKey: Y.ECPrivateKey.decode(we.subjectPrivateKey, "der").privateKey
            };
          case "1.2.840.10040.4.1":
            return we.algorithm.params.priv_key = Y.DSAparam.decode(we.subjectPrivateKey, "der"), {
              type: "dsa",
              params: we.algorithm.params
            };
          default:
            throw new Error("unknown key id " + ye);
        }
      case "RSA PUBLIC KEY":
        return Y.RSAPublicKey.decode(me, "der");
      case "RSA PRIVATE KEY":
        return Y.RSAPrivateKey.decode(me, "der");
      case "DSA PRIVATE KEY":
        return {
          type: "dsa",
          params: Y.DSAPrivateKey.decode(me, "der")
        };
      case "EC PRIVATE KEY":
        return me = Y.ECPrivateKey.decode(me, "der"), {
          curve: me.parameters.value,
          privateKey: me.privateKey
        };
      default:
        throw new Error("unknown key type " + he);
    }
  }
  return se.signature = Y.signature, parseAsn1 = se, parseAsn1;
}
const require$$4$1 = {
  "1.3.132.0.10": "secp256k1",
  "1.3.132.0.33": "p224",
  "1.2.840.10045.3.1.1": "p192",
  "1.2.840.10045.3.1.7": "p256",
  "1.3.132.0.34": "p384",
  "1.3.132.0.35": "p521"
};
var hasRequiredSign;
function requireSign() {
  if (hasRequiredSign)
    return sign$1.exports;
  hasRequiredSign = 1;
  var Y = safeBufferExports.Buffer, X = browser$c, ee = requireBrowserifyRsa(), te = requireElliptic().ec, ne = bnExports, ie = requireParseAsn1(), oe = require$$4$1, se = 1;
  function ae(Ue, Me, De, Fe, Ke) {
    var tt = ie(Me);
    if (tt.curve) {
      if (Fe !== "ecdsa" && Fe !== "ecdsa/rsa")
        throw new Error("wrong private key type");
      return ue(Ue, tt);
    } else if (tt.type === "dsa") {
      if (Fe !== "dsa")
        throw new Error("wrong private key type");
      return le(Ue, tt, De);
    }
    if (Fe !== "rsa" && Fe !== "ecdsa/rsa")
      throw new Error("wrong private key type");
    if (Me.padding !== void 0 && Me.padding !== se)
      throw new Error("illegal or unsupported padding mode");
    Ue = Y.concat([Ke, Ue]);
    for (var rt = tt.modulus.byteLength(), it = [0, 1]; Ue.length + it.length + 1 < rt; )
      it.push(255);
    it.push(0);
    for (var _t = -1; ++_t < Ue.length; )
      it.push(Ue[_t]);
    var Dt = ee(it, tt);
    return Dt;
  }
  function ue(Ue, Me) {
    var De = oe[Me.curve.join(".")];
    if (!De)
      throw new Error("unknown curve " + Me.curve.join("."));
    var Fe = new te(De), Ke = Fe.keyFromPrivate(Me.privateKey), tt = Ke.sign(Ue);
    return Y.from(tt.toDER());
  }
  function le(Ue, Me, De) {
    for (var Fe = Me.params.priv_key, Ke = Me.params.p, tt = Me.params.q, rt = Me.params.g, it = new ne(0), _t, Dt = ye(Ue, tt).mod(tt), je = !1, ze = me(Fe, tt, Ue, De); je === !1; )
      _t = Ee(tt, ze, De), it = Re(rt, _t, Ke, tt), je = _t.invm(tt).imul(Dt.add(Fe.mul(it))).mod(tt), je.cmpn(0) === 0 && (je = !1, it = new ne(0));
    return he(it, je);
  }
  function he(Ue, Me) {
    Ue = Ue.toArray(), Me = Me.toArray(), Ue[0] & 128 && (Ue = [0].concat(Ue)), Me[0] & 128 && (Me = [0].concat(Me));
    var De = Ue.length + Me.length + 4, Fe = [
      48,
      De,
      2,
      Ue.length
    ];
    return Fe = Fe.concat(Ue, [2, Me.length], Me), Y.from(Fe);
  }
  function me(Ue, Me, De, Fe) {
    if (Ue = Y.from(Ue.toArray()), Ue.length < Me.byteLength()) {
      var Ke = Y.alloc(Me.byteLength() - Ue.length);
      Ue = Y.concat([Ke, Ue]);
    }
    var tt = De.length, rt = we(De, Me), it = Y.alloc(tt);
    it.fill(1);
    var _t = Y.alloc(tt);
    return _t = X(Fe, _t).update(it).update(Y.from([0])).update(Ue).update(rt).digest(), it = X(Fe, _t).update(it).digest(), _t = X(Fe, _t).update(it).update(Y.from([1])).update(Ue).update(rt).digest(), it = X(Fe, _t).update(it).digest(), { k: _t, v: it };
  }
  function ye(Ue, Me) {
    var De = new ne(Ue), Fe = (Ue.length << 3) - Me.bitLength();
    return Fe > 0 && De.ishrn(Fe), De;
  }
  function we(Ue, Me) {
    Ue = ye(Ue, Me), Ue = Ue.mod(Me);
    var De = Y.from(Ue.toArray());
    if (De.length < Me.byteLength()) {
      var Fe = Y.alloc(Me.byteLength() - De.length);
      De = Y.concat([Fe, De]);
    }
    return De;
  }
  function Ee(Ue, Me, De) {
    var Fe, Ke;
    do {
      for (Fe = Y.alloc(0); Fe.length * 8 < Ue.bitLength(); )
        Me.v = X(De, Me.k).update(Me.v).digest(), Fe = Y.concat([Fe, Me.v]);
      Ke = ye(Fe, Ue), Me.k = X(De, Me.k).update(Me.v).update(Y.from([0])).digest(), Me.v = X(De, Me.k).update(Me.v).digest();
    } while (Ke.cmp(Ue) !== -1);
    return Ke;
  }
  function Re(Ue, Me, De, Fe) {
    return Ue.toRed(ne.mont(De)).redPow(Me).fromRed().mod(Fe);
  }
  return sign$1.exports = ae, sign$1.exports.getKey = me, sign$1.exports.makeKey = Ee, sign$1.exports;
}
var verify_1, hasRequiredVerify;
function requireVerify() {
  if (hasRequiredVerify)
    return verify_1;
  hasRequiredVerify = 1;
  var Y = safeBufferExports.Buffer, X = bnExports, ee = requireElliptic().ec, te = requireParseAsn1(), ne = require$$4$1;
  function ie(ue, le, he, me, ye) {
    var we = te(he);
    if (we.type === "ec") {
      if (me !== "ecdsa" && me !== "ecdsa/rsa")
        throw new Error("wrong public key type");
      return oe(ue, le, we);
    } else if (we.type === "dsa") {
      if (me !== "dsa")
        throw new Error("wrong public key type");
      return se(ue, le, we);
    }
    if (me !== "rsa" && me !== "ecdsa/rsa")
      throw new Error("wrong public key type");
    le = Y.concat([ye, le]);
    for (var Ee = we.modulus.byteLength(), Re = [1], Ue = 0; le.length + Re.length + 2 < Ee; )
      Re.push(255), Ue += 1;
    Re.push(0);
    for (var Me = -1; ++Me < le.length; )
      Re.push(le[Me]);
    Re = Y.from(Re);
    var De = X.mont(we.modulus);
    ue = new X(ue).toRed(De), ue = ue.redPow(new X(we.publicExponent)), ue = Y.from(ue.fromRed().toArray());
    var Fe = Ue < 8 ? 1 : 0;
    for (Ee = Math.min(ue.length, Re.length), ue.length !== Re.length && (Fe = 1), Me = -1; ++Me < Ee; )
      Fe |= ue[Me] ^ Re[Me];
    return Fe === 0;
  }
  function oe(ue, le, he) {
    var me = ne[he.data.algorithm.curve.join(".")];
    if (!me)
      throw new Error("unknown curve " + he.data.algorithm.curve.join("."));
    var ye = new ee(me), we = he.data.subjectPrivateKey.data;
    return ye.verify(le, ue, we);
  }
  function se(ue, le, he) {
    var me = he.data.p, ye = he.data.q, we = he.data.g, Ee = he.data.pub_key, Re = te.signature.decode(ue, "der"), Ue = Re.s, Me = Re.r;
    ae(Ue, ye), ae(Me, ye);
    var De = X.mont(me), Fe = Ue.invm(ye), Ke = we.toRed(De).redPow(new X(le).mul(Fe).mod(ye)).fromRed().mul(Ee.toRed(De).redPow(Me.mul(Fe).mod(ye)).fromRed()).mod(me).mod(ye);
    return Ke.cmp(Me) === 0;
  }
  function ae(ue, le) {
    if (ue.cmpn(0) <= 0)
      throw new Error("invalid sig");
    if (ue.cmp(le) >= 0)
      throw new Error("invalid sig");
  }
  return verify_1 = ie, verify_1;
}
var browser$5, hasRequiredBrowser$3;
function requireBrowser$3() {
  if (hasRequiredBrowser$3)
    return browser$5;
  hasRequiredBrowser$3 = 1;
  var Y = safeBufferExports.Buffer, X = requireBrowser$8(), ee = readableBrowserExports, te = inherits_browserExports, ne = requireSign(), ie = requireVerify(), oe = require$$6$1;
  Object.keys(oe).forEach(function(he) {
    oe[he].id = Y.from(oe[he].id, "hex"), oe[he.toLowerCase()] = oe[he];
  });
  function se(he) {
    ee.Writable.call(this);
    var me = oe[he];
    if (!me)
      throw new Error("Unknown message digest");
    this._hashType = me.hash, this._hash = X(me.hash), this._tag = me.id, this._signType = me.sign;
  }
  te(se, ee.Writable), se.prototype._write = function(he, me, ye) {
    this._hash.update(he), ye();
  }, se.prototype.update = function(he, me) {
    return this._hash.update(typeof he == "string" ? Y.from(he, me) : he), this;
  }, se.prototype.sign = function(he, me) {
    this.end();
    var ye = this._hash.digest(), we = ne(ye, he, this._hashType, this._signType, this._tag);
    return me ? we.toString(me) : we;
  };
  function ae(he) {
    ee.Writable.call(this);
    var me = oe[he];
    if (!me)
      throw new Error("Unknown message digest");
    this._hash = X(me.hash), this._tag = me.id, this._signType = me.sign;
  }
  te(ae, ee.Writable), ae.prototype._write = function(he, me, ye) {
    this._hash.update(he), ye();
  }, ae.prototype.update = function(he, me) {
    return this._hash.update(typeof he == "string" ? Y.from(he, me) : he), this;
  }, ae.prototype.verify = function(he, me, ye) {
    var we = typeof me == "string" ? Y.from(me, ye) : me;
    this.end();
    var Ee = this._hash.digest();
    return ie(we, Ee, he, this._signType, this._tag);
  };
  function ue(he) {
    return new se(he);
  }
  function le(he) {
    return new ae(he);
  }
  return browser$5 = {
    Sign: ue,
    Verify: le,
    createSign: ue,
    createVerify: le
  }, browser$5;
}
var browser$4, hasRequiredBrowser$2;
function requireBrowser$2() {
  if (hasRequiredBrowser$2)
    return browser$4;
  hasRequiredBrowser$2 = 1;
  var Y = requireElliptic(), X = requireBn();
  browser$4 = function(ie) {
    return new te(ie);
  };
  var ee = {
    secp256k1: {
      name: "secp256k1",
      byteLength: 32
    },
    secp224r1: {
      name: "p224",
      byteLength: 28
    },
    prime256v1: {
      name: "p256",
      byteLength: 32
    },
    prime192v1: {
      name: "p192",
      byteLength: 24
    },
    ed25519: {
      name: "ed25519",
      byteLength: 32
    },
    secp384r1: {
      name: "p384",
      byteLength: 48
    },
    secp521r1: {
      name: "p521",
      byteLength: 66
    }
  };
  ee.p224 = ee.secp224r1, ee.p256 = ee.secp256r1 = ee.prime256v1, ee.p192 = ee.secp192r1 = ee.prime192v1, ee.p384 = ee.secp384r1, ee.p521 = ee.secp521r1;
  function te(ie) {
    this.curveType = ee[ie], this.curveType || (this.curveType = {
      name: ie
    }), this.curve = new Y.ec(this.curveType.name), this.keys = void 0;
  }
  te.prototype.generateKeys = function(ie, oe) {
    return this.keys = this.curve.genKeyPair(), this.getPublicKey(ie, oe);
  }, te.prototype.computeSecret = function(ie, oe, se) {
    oe = oe || "utf8", Buffer$e.isBuffer(ie) || (ie = new Buffer$e(ie, oe));
    var ae = this.curve.keyFromPublic(ie).getPublic(), ue = ae.mul(this.keys.getPrivate()).getX();
    return ne(ue, se, this.curveType.byteLength);
  }, te.prototype.getPublicKey = function(ie, oe) {
    var se = this.keys.getPublic(oe === "compressed", !0);
    return oe === "hybrid" && (se[se.length - 1] % 2 ? se[0] = 7 : se[0] = 6), ne(se, ie);
  }, te.prototype.getPrivateKey = function(ie) {
    return ne(this.keys.getPrivate(), ie);
  }, te.prototype.setPublicKey = function(ie, oe) {
    return oe = oe || "utf8", Buffer$e.isBuffer(ie) || (ie = new Buffer$e(ie, oe)), this.keys._importPublic(ie), this;
  }, te.prototype.setPrivateKey = function(ie, oe) {
    oe = oe || "utf8", Buffer$e.isBuffer(ie) || (ie = new Buffer$e(ie, oe));
    var se = new X(ie);
    return se = se.toString(16), this.keys = this.curve.genKeyPair(), this.keys._importPrivate(se), this;
  };
  function ne(ie, oe, se) {
    Array.isArray(ie) || (ie = ie.toArray());
    var ae = new Buffer$e(ie);
    if (se && ae.length < se) {
      var ue = new Buffer$e(se - ae.length);
      ue.fill(0), ae = Buffer$e.concat([ue, ae]);
    }
    return oe ? ae.toString(oe) : ae;
  }
  return browser$4;
}
var browser$3 = {}, mgf, hasRequiredMgf;
function requireMgf() {
  if (hasRequiredMgf)
    return mgf;
  hasRequiredMgf = 1;
  var Y = requireBrowser$8(), X = safeBufferExports.Buffer;
  mgf = function(te, ne) {
    for (var ie = X.alloc(0), oe = 0, se; ie.length < ne; )
      se = ee(oe++), ie = X.concat([ie, Y("sha1").update(te).update(se).digest()]);
    return ie.slice(0, ne);
  };
  function ee(te) {
    var ne = X.allocUnsafe(4);
    return ne.writeUInt32BE(te, 0), ne;
  }
  return mgf;
}
var xor, hasRequiredXor;
function requireXor() {
  return hasRequiredXor || (hasRequiredXor = 1, xor = function(Y, X) {
    for (var ee = Y.length, te = -1; ++te < ee; )
      Y[te] ^= X[te];
    return Y;
  }), xor;
}
var withPublic_1, hasRequiredWithPublic;
function requireWithPublic() {
  if (hasRequiredWithPublic)
    return withPublic_1;
  hasRequiredWithPublic = 1;
  var Y = requireBn(), X = safeBufferExports.Buffer;
  function ee(te, ne) {
    return X.from(te.toRed(Y.mont(ne.modulus)).redPow(new Y(ne.publicExponent)).fromRed().toArray());
  }
  return withPublic_1 = ee, withPublic_1;
}
var publicEncrypt, hasRequiredPublicEncrypt;
function requirePublicEncrypt() {
  if (hasRequiredPublicEncrypt)
    return publicEncrypt;
  hasRequiredPublicEncrypt = 1;
  var Y = requireParseAsn1(), X = requireBrowser$9(), ee = requireBrowser$8(), te = requireMgf(), ne = requireXor(), ie = requireBn(), oe = requireWithPublic(), se = requireBrowserifyRsa(), ae = safeBufferExports.Buffer;
  publicEncrypt = function(me, ye, we) {
    var Ee;
    me.padding ? Ee = me.padding : we ? Ee = 1 : Ee = 4;
    var Re = Y(me), Ue;
    if (Ee === 4)
      Ue = ue(Re, ye);
    else if (Ee === 1)
      Ue = le(Re, ye, we);
    else if (Ee === 3) {
      if (Ue = new ie(ye), Ue.cmp(Re.modulus) >= 0)
        throw new Error("data too long for modulus");
    } else
      throw new Error("unknown padding");
    return we ? se(Ue, Re) : oe(Ue, Re);
  };
  function ue(me, ye) {
    var we = me.modulus.byteLength(), Ee = ye.length, Re = ee("sha1").update(ae.alloc(0)).digest(), Ue = Re.length, Me = 2 * Ue;
    if (Ee > we - Me - 2)
      throw new Error("message too long");
    var De = ae.alloc(we - Ee - Me - 2), Fe = we - Ue - 1, Ke = X(Ue), tt = ne(ae.concat([Re, De, ae.alloc(1, 1), ye], Fe), te(Ke, Fe)), rt = ne(Ke, te(tt, Ue));
    return new ie(ae.concat([ae.alloc(1), rt, tt], we));
  }
  function le(me, ye, we) {
    var Ee = ye.length, Re = me.modulus.byteLength();
    if (Ee > Re - 11)
      throw new Error("message too long");
    var Ue;
    return we ? Ue = ae.alloc(Re - Ee - 3, 255) : Ue = he(Re - Ee - 3), new ie(ae.concat([ae.from([0, we ? 1 : 2]), Ue, ae.alloc(1), ye], Re));
  }
  function he(me) {
    for (var ye = ae.allocUnsafe(me), we = 0, Ee = X(me * 2), Re = 0, Ue; we < me; )
      Re === Ee.length && (Ee = X(me * 2), Re = 0), Ue = Ee[Re++], Ue && (ye[we++] = Ue);
    return ye;
  }
  return publicEncrypt;
}
var privateDecrypt, hasRequiredPrivateDecrypt;
function requirePrivateDecrypt() {
  if (hasRequiredPrivateDecrypt)
    return privateDecrypt;
  hasRequiredPrivateDecrypt = 1;
  var Y = requireParseAsn1(), X = requireMgf(), ee = requireXor(), te = requireBn(), ne = requireBrowserifyRsa(), ie = requireBrowser$8(), oe = requireWithPublic(), se = safeBufferExports.Buffer;
  privateDecrypt = function(he, me, ye) {
    var we;
    he.padding ? we = he.padding : ye ? we = 1 : we = 4;
    var Ee = Y(he), Re = Ee.modulus.byteLength();
    if (me.length > Re || new te(me).cmp(Ee.modulus) >= 0)
      throw new Error("decryption error");
    var Ue;
    ye ? Ue = oe(new te(me), Ee) : Ue = ne(me, Ee);
    var Me = se.alloc(Re - Ue.length);
    if (Ue = se.concat([Me, Ue], Re), we === 4)
      return ae(Ee, Ue);
    if (we === 1)
      return ue(Ee, Ue, ye);
    if (we === 3)
      return Ue;
    throw new Error("unknown padding");
  };
  function ae(he, me) {
    var ye = he.modulus.byteLength(), we = ie("sha1").update(se.alloc(0)).digest(), Ee = we.length;
    if (me[0] !== 0)
      throw new Error("decryption error");
    var Re = me.slice(1, Ee + 1), Ue = me.slice(Ee + 1), Me = ee(Re, X(Ue, Ee)), De = ee(Ue, X(Me, ye - Ee - 1));
    if (le(we, De.slice(0, Ee)))
      throw new Error("decryption error");
    for (var Fe = Ee; De[Fe] === 0; )
      Fe++;
    if (De[Fe++] !== 1)
      throw new Error("decryption error");
    return De.slice(Fe);
  }
  function ue(he, me, ye) {
    for (var we = me.slice(0, 2), Ee = 2, Re = 0; me[Ee++] !== 0; )
      if (Ee >= me.length) {
        Re++;
        break;
      }
    var Ue = me.slice(2, Ee - 1);
    if ((we.toString("hex") !== "0002" && !ye || we.toString("hex") !== "0001" && ye) && Re++, Ue.length < 8 && Re++, Re)
      throw new Error("decryption error");
    return me.slice(Ee);
  }
  function le(he, me) {
    he = se.from(he), me = se.from(me);
    var ye = 0, we = he.length;
    he.length !== me.length && (ye++, we = Math.min(he.length, me.length));
    for (var Ee = -1; ++Ee < we; )
      ye += he[Ee] ^ me[Ee];
    return ye;
  }
  return privateDecrypt;
}
var hasRequiredBrowser$1;
function requireBrowser$1() {
  return hasRequiredBrowser$1 || (hasRequiredBrowser$1 = 1, function(Y) {
    Y.publicEncrypt = requirePublicEncrypt(), Y.privateDecrypt = requirePrivateDecrypt(), Y.privateEncrypt = function(X, ee) {
      return Y.publicEncrypt(X, ee, !0);
    }, Y.publicDecrypt = function(X, ee) {
      return Y.privateDecrypt(X, ee, !0);
    };
  }(browser$3)), browser$3;
}
var browser$2 = {}, hasRequiredBrowser;
function requireBrowser() {
  if (hasRequiredBrowser)
    return browser$2;
  hasRequiredBrowser = 1;
  function Y() {
    throw new Error(`secure random number generation not supported by this browser
use chrome, FireFox or Internet Explorer 11`);
  }
  var X = safeBufferExports, ee = requireBrowser$9(), te = X.Buffer, ne = X.kMaxLength, ie = commonjsGlobal.crypto || commonjsGlobal.msCrypto, oe = Math.pow(2, 32) - 1;
  function se(me, ye) {
    if (typeof me != "number" || me !== me)
      throw new TypeError("offset must be a number");
    if (me > oe || me < 0)
      throw new TypeError("offset must be a uint32");
    if (me > ne || me > ye)
      throw new RangeError("offset out of range");
  }
  function ae(me, ye, we) {
    if (typeof me != "number" || me !== me)
      throw new TypeError("size must be a number");
    if (me > oe || me < 0)
      throw new TypeError("size must be a uint32");
    if (me + ye > we || me > ne)
      throw new RangeError("buffer too small");
  }
  ie && ie.getRandomValues || !process$1$1.browser ? (browser$2.randomFill = ue, browser$2.randomFillSync = he) : (browser$2.randomFill = Y, browser$2.randomFillSync = Y);
  function ue(me, ye, we, Ee) {
    if (!te.isBuffer(me) && !(me instanceof commonjsGlobal.Uint8Array))
      throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
    if (typeof ye == "function")
      Ee = ye, ye = 0, we = me.length;
    else if (typeof we == "function")
      Ee = we, we = me.length - ye;
    else if (typeof Ee != "function")
      throw new TypeError('"cb" argument must be a function');
    return se(ye, me.length), ae(we, ye, me.length), le(me, ye, we, Ee);
  }
  function le(me, ye, we, Ee) {
    if (process$1$1.browser) {
      var Re = me.buffer, Ue = new Uint8Array(Re, ye, we);
      if (ie.getRandomValues(Ue), Ee) {
        process$1$1.nextTick(function() {
          Ee(null, me);
        });
        return;
      }
      return me;
    }
    if (Ee) {
      ee(we, function(De, Fe) {
        if (De)
          return Ee(De);
        Fe.copy(me, ye), Ee(null, me);
      });
      return;
    }
    var Me = ee(we);
    return Me.copy(me, ye), me;
  }
  function he(me, ye, we) {
    if (typeof ye > "u" && (ye = 0), !te.isBuffer(me) && !(me instanceof commonjsGlobal.Uint8Array))
      throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
    return se(ye, me.length), we === void 0 && (we = me.length - ye), ae(we, ye, me.length), le(me, ye, we);
  }
  return browser$2;
}
var hasRequiredCryptoBrowserify;
function requireCryptoBrowserify() {
  if (hasRequiredCryptoBrowserify)
    return cryptoBrowserify;
  hasRequiredCryptoBrowserify = 1, cryptoBrowserify.randomBytes = cryptoBrowserify.rng = cryptoBrowserify.pseudoRandomBytes = cryptoBrowserify.prng = requireBrowser$9(), cryptoBrowserify.createHash = cryptoBrowserify.Hash = requireBrowser$8(), cryptoBrowserify.createHmac = cryptoBrowserify.Hmac = browser$c;
  var Y = requireAlgos(), X = Object.keys(Y), ee = ["sha1", "sha224", "sha256", "sha384", "sha512", "md5", "rmd160"].concat(X);
  cryptoBrowserify.getHashes = function() {
    return ee;
  };
  var te = requireBrowser$7();
  cryptoBrowserify.pbkdf2 = te.pbkdf2, cryptoBrowserify.pbkdf2Sync = te.pbkdf2Sync;
  var ne = requireBrowser$5();
  cryptoBrowserify.Cipher = ne.Cipher, cryptoBrowserify.createCipher = ne.createCipher, cryptoBrowserify.Cipheriv = ne.Cipheriv, cryptoBrowserify.createCipheriv = ne.createCipheriv, cryptoBrowserify.Decipher = ne.Decipher, cryptoBrowserify.createDecipher = ne.createDecipher, cryptoBrowserify.Decipheriv = ne.Decipheriv, cryptoBrowserify.createDecipheriv = ne.createDecipheriv, cryptoBrowserify.getCiphers = ne.getCiphers, cryptoBrowserify.listCiphers = ne.listCiphers;
  var ie = requireBrowser$4();
  cryptoBrowserify.DiffieHellmanGroup = ie.DiffieHellmanGroup, cryptoBrowserify.createDiffieHellmanGroup = ie.createDiffieHellmanGroup, cryptoBrowserify.getDiffieHellman = ie.getDiffieHellman, cryptoBrowserify.createDiffieHellman = ie.createDiffieHellman, cryptoBrowserify.DiffieHellman = ie.DiffieHellman;
  var oe = requireBrowser$3();
  cryptoBrowserify.createSign = oe.createSign, cryptoBrowserify.Sign = oe.Sign, cryptoBrowserify.createVerify = oe.createVerify, cryptoBrowserify.Verify = oe.Verify, cryptoBrowserify.createECDH = requireBrowser$2();
  var se = requireBrowser$1();
  cryptoBrowserify.publicEncrypt = se.publicEncrypt, cryptoBrowserify.privateEncrypt = se.privateEncrypt, cryptoBrowserify.publicDecrypt = se.publicDecrypt, cryptoBrowserify.privateDecrypt = se.privateDecrypt;
  var ae = requireBrowser();
  return cryptoBrowserify.randomFill = ae.randomFill, cryptoBrowserify.randomFillSync = ae.randomFillSync, cryptoBrowserify.createCredentials = function() {
    throw new Error([
      "sorry, createCredentials is not implemented yet",
      "we accept pull requests",
      "https://github.com/crypto-browserify/crypto-browserify"
    ].join(`
`));
  }, cryptoBrowserify.constants = {
    DH_CHECK_P_NOT_SAFE_PRIME: 2,
    DH_CHECK_P_NOT_PRIME: 1,
    DH_UNABLE_TO_CHECK_GENERATOR: 4,
    DH_NOT_SUITABLE_GENERATOR: 8,
    NPN_ENABLED: 1,
    ALPN_ENABLED: 1,
    RSA_PKCS1_PADDING: 1,
    RSA_SSLV23_PADDING: 2,
    RSA_NO_PADDING: 3,
    RSA_PKCS1_OAEP_PADDING: 4,
    RSA_X931_PADDING: 5,
    RSA_PKCS1_PSS_PADDING: 6,
    POINT_CONVERSION_COMPRESSED: 2,
    POINT_CONVERSION_UNCOMPRESSED: 4,
    POINT_CONVERSION_HYBRID: 6
  }, cryptoBrowserify;
}
(function(Y) {
  (function(X) {
    var ee = function(qe) {
      var Qe, Ve = new Float64Array(16);
      if (qe)
        for (Qe = 0; Qe < qe.length; Qe++)
          Ve[Qe] = qe[Qe];
      return Ve;
    }, te = function() {
      throw new Error("no PRNG");
    }, ne = new Uint8Array(16), ie = new Uint8Array(32);
    ie[0] = 9;
    var oe = ee(), se = ee([1]), ae = ee([56129, 1]), ue = ee([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), le = ee([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]), he = ee([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]), me = ee([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]), ye = ee([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
    function we(qe, Qe, Ve, Ie) {
      qe[Qe] = Ve >> 24 & 255, qe[Qe + 1] = Ve >> 16 & 255, qe[Qe + 2] = Ve >> 8 & 255, qe[Qe + 3] = Ve & 255, qe[Qe + 4] = Ie >> 24 & 255, qe[Qe + 5] = Ie >> 16 & 255, qe[Qe + 6] = Ie >> 8 & 255, qe[Qe + 7] = Ie & 255;
    }
    function Ee(qe, Qe, Ve, Ie, nt) {
      var Et, xt = 0;
      for (Et = 0; Et < nt; Et++)
        xt |= qe[Qe + Et] ^ Ve[Ie + Et];
      return (1 & xt - 1 >>> 8) - 1;
    }
    function Re(qe, Qe, Ve, Ie) {
      return Ee(qe, Qe, Ve, Ie, 16);
    }
    function Ue(qe, Qe, Ve, Ie) {
      return Ee(qe, Qe, Ve, Ie, 32);
    }
    function Me(qe, Qe, Ve, Ie) {
      for (var nt = Ie[0] & 255 | (Ie[1] & 255) << 8 | (Ie[2] & 255) << 16 | (Ie[3] & 255) << 24, Et = Ve[0] & 255 | (Ve[1] & 255) << 8 | (Ve[2] & 255) << 16 | (Ve[3] & 255) << 24, xt = Ve[4] & 255 | (Ve[5] & 255) << 8 | (Ve[6] & 255) << 16 | (Ve[7] & 255) << 24, Jt = Ve[8] & 255 | (Ve[9] & 255) << 8 | (Ve[10] & 255) << 16 | (Ve[11] & 255) << 24, Yt = Ve[12] & 255 | (Ve[13] & 255) << 8 | (Ve[14] & 255) << 16 | (Ve[15] & 255) << 24, _r = Ie[4] & 255 | (Ie[5] & 255) << 8 | (Ie[6] & 255) << 16 | (Ie[7] & 255) << 24, cn = Qe[0] & 255 | (Qe[1] & 255) << 8 | (Qe[2] & 255) << 16 | (Qe[3] & 255) << 24, _X = Qe[4] & 255 | (Qe[5] & 255) << 8 | (Qe[6] & 255) << 16 | (Qe[7] & 255) << 24, un = Qe[8] & 255 | (Qe[9] & 255) << 8 | (Qe[10] & 255) << 16 | (Qe[11] & 255) << 24, aX = Qe[12] & 255 | (Qe[13] & 255) << 8 | (Qe[14] & 255) << 16 | (Qe[15] & 255) << 24, uX = Ie[8] & 255 | (Ie[9] & 255) << 8 | (Ie[10] & 255) << 16 | (Ie[11] & 255) << 24, fX = Ve[16] & 255 | (Ve[17] & 255) << 8 | (Ve[18] & 255) << 16 | (Ve[19] & 255) << 24, bX = Ve[20] & 255 | (Ve[21] & 255) << 8 | (Ve[22] & 255) << 16 | (Ve[23] & 255) << 24, dX = Ve[24] & 255 | (Ve[25] & 255) << 8 | (Ve[26] & 255) << 16 | (Ve[27] & 255) << 24, mX = Ve[28] & 255 | (Ve[29] & 255) << 8 | (Ve[30] & 255) << 16 | (Ve[31] & 255) << 24, pX = Ie[12] & 255 | (Ie[13] & 255) << 8 | (Ie[14] & 255) << 16 | (Ie[15] & 255) << 24, G_ = nt, iX = Et, og = xt, eX = Jt, tX = Yt, An = _r, Gt = cn, Wt = _X, vr = un, Qt = aX, rr = uX, Ir = fX, gX = bX, TX = dX, IX = mX, RX = pX, wt, CX = 0; CX < 20; CX += 2)
        wt = G_ + gX | 0, tX ^= wt << 7 | wt >>> 25, wt = tX + G_ | 0, vr ^= wt << 9 | wt >>> 23, wt = vr + tX | 0, gX ^= wt << 13 | wt >>> 19, wt = gX + vr | 0, G_ ^= wt << 18 | wt >>> 14, wt = An + iX | 0, Qt ^= wt << 7 | wt >>> 25, wt = Qt + An | 0, TX ^= wt << 9 | wt >>> 23, wt = TX + Qt | 0, iX ^= wt << 13 | wt >>> 19, wt = iX + TX | 0, An ^= wt << 18 | wt >>> 14, wt = rr + Gt | 0, IX ^= wt << 7 | wt >>> 25, wt = IX + rr | 0, og ^= wt << 9 | wt >>> 23, wt = og + IX | 0, Gt ^= wt << 13 | wt >>> 19, wt = Gt + og | 0, rr ^= wt << 18 | wt >>> 14, wt = RX + Ir | 0, eX ^= wt << 7 | wt >>> 25, wt = eX + RX | 0, Wt ^= wt << 9 | wt >>> 23, wt = Wt + eX | 0, Ir ^= wt << 13 | wt >>> 19, wt = Ir + Wt | 0, RX ^= wt << 18 | wt >>> 14, wt = G_ + eX | 0, iX ^= wt << 7 | wt >>> 25, wt = iX + G_ | 0, og ^= wt << 9 | wt >>> 23, wt = og + iX | 0, eX ^= wt << 13 | wt >>> 19, wt = eX + og | 0, G_ ^= wt << 18 | wt >>> 14, wt = An + tX | 0, Gt ^= wt << 7 | wt >>> 25, wt = Gt + An | 0, Wt ^= wt << 9 | wt >>> 23, wt = Wt + Gt | 0, tX ^= wt << 13 | wt >>> 19, wt = tX + Wt | 0, An ^= wt << 18 | wt >>> 14, wt = rr + Qt | 0, Ir ^= wt << 7 | wt >>> 25, wt = Ir + rr | 0, vr ^= wt << 9 | wt >>> 23, wt = vr + Ir | 0, Qt ^= wt << 13 | wt >>> 19, wt = Qt + vr | 0, rr ^= wt << 18 | wt >>> 14, wt = RX + IX | 0, gX ^= wt << 7 | wt >>> 25, wt = gX + RX | 0, TX ^= wt << 9 | wt >>> 23, wt = TX + gX | 0, IX ^= wt << 13 | wt >>> 19, wt = IX + TX | 0, RX ^= wt << 18 | wt >>> 14;
      G_ = G_ + nt | 0, iX = iX + Et | 0, og = og + xt | 0, eX = eX + Jt | 0, tX = tX + Yt | 0, An = An + _r | 0, Gt = Gt + cn | 0, Wt = Wt + _X | 0, vr = vr + un | 0, Qt = Qt + aX | 0, rr = rr + uX | 0, Ir = Ir + fX | 0, gX = gX + bX | 0, TX = TX + dX | 0, IX = IX + mX | 0, RX = RX + pX | 0, qe[0] = G_ >>> 0 & 255, qe[1] = G_ >>> 8 & 255, qe[2] = G_ >>> 16 & 255, qe[3] = G_ >>> 24 & 255, qe[4] = iX >>> 0 & 255, qe[5] = iX >>> 8 & 255, qe[6] = iX >>> 16 & 255, qe[7] = iX >>> 24 & 255, qe[8] = og >>> 0 & 255, qe[9] = og >>> 8 & 255, qe[10] = og >>> 16 & 255, qe[11] = og >>> 24 & 255, qe[12] = eX >>> 0 & 255, qe[13] = eX >>> 8 & 255, qe[14] = eX >>> 16 & 255, qe[15] = eX >>> 24 & 255, qe[16] = tX >>> 0 & 255, qe[17] = tX >>> 8 & 255, qe[18] = tX >>> 16 & 255, qe[19] = tX >>> 24 & 255, qe[20] = An >>> 0 & 255, qe[21] = An >>> 8 & 255, qe[22] = An >>> 16 & 255, qe[23] = An >>> 24 & 255, qe[24] = Gt >>> 0 & 255, qe[25] = Gt >>> 8 & 255, qe[26] = Gt >>> 16 & 255, qe[27] = Gt >>> 24 & 255, qe[28] = Wt >>> 0 & 255, qe[29] = Wt >>> 8 & 255, qe[30] = Wt >>> 16 & 255, qe[31] = Wt >>> 24 & 255, qe[32] = vr >>> 0 & 255, qe[33] = vr >>> 8 & 255, qe[34] = vr >>> 16 & 255, qe[35] = vr >>> 24 & 255, qe[36] = Qt >>> 0 & 255, qe[37] = Qt >>> 8 & 255, qe[38] = Qt >>> 16 & 255, qe[39] = Qt >>> 24 & 255, qe[40] = rr >>> 0 & 255, qe[41] = rr >>> 8 & 255, qe[42] = rr >>> 16 & 255, qe[43] = rr >>> 24 & 255, qe[44] = Ir >>> 0 & 255, qe[45] = Ir >>> 8 & 255, qe[46] = Ir >>> 16 & 255, qe[47] = Ir >>> 24 & 255, qe[48] = gX >>> 0 & 255, qe[49] = gX >>> 8 & 255, qe[50] = gX >>> 16 & 255, qe[51] = gX >>> 24 & 255, qe[52] = TX >>> 0 & 255, qe[53] = TX >>> 8 & 255, qe[54] = TX >>> 16 & 255, qe[55] = TX >>> 24 & 255, qe[56] = IX >>> 0 & 255, qe[57] = IX >>> 8 & 255, qe[58] = IX >>> 16 & 255, qe[59] = IX >>> 24 & 255, qe[60] = RX >>> 0 & 255, qe[61] = RX >>> 8 & 255, qe[62] = RX >>> 16 & 255, qe[63] = RX >>> 24 & 255;
    }
    function De(qe, Qe, Ve, Ie) {
      for (var nt = Ie[0] & 255 | (Ie[1] & 255) << 8 | (Ie[2] & 255) << 16 | (Ie[3] & 255) << 24, Et = Ve[0] & 255 | (Ve[1] & 255) << 8 | (Ve[2] & 255) << 16 | (Ve[3] & 255) << 24, xt = Ve[4] & 255 | (Ve[5] & 255) << 8 | (Ve[6] & 255) << 16 | (Ve[7] & 255) << 24, Jt = Ve[8] & 255 | (Ve[9] & 255) << 8 | (Ve[10] & 255) << 16 | (Ve[11] & 255) << 24, Yt = Ve[12] & 255 | (Ve[13] & 255) << 8 | (Ve[14] & 255) << 16 | (Ve[15] & 255) << 24, _r = Ie[4] & 255 | (Ie[5] & 255) << 8 | (Ie[6] & 255) << 16 | (Ie[7] & 255) << 24, cn = Qe[0] & 255 | (Qe[1] & 255) << 8 | (Qe[2] & 255) << 16 | (Qe[3] & 255) << 24, _X = Qe[4] & 255 | (Qe[5] & 255) << 8 | (Qe[6] & 255) << 16 | (Qe[7] & 255) << 24, un = Qe[8] & 255 | (Qe[9] & 255) << 8 | (Qe[10] & 255) << 16 | (Qe[11] & 255) << 24, aX = Qe[12] & 255 | (Qe[13] & 255) << 8 | (Qe[14] & 255) << 16 | (Qe[15] & 255) << 24, uX = Ie[8] & 255 | (Ie[9] & 255) << 8 | (Ie[10] & 255) << 16 | (Ie[11] & 255) << 24, fX = Ve[16] & 255 | (Ve[17] & 255) << 8 | (Ve[18] & 255) << 16 | (Ve[19] & 255) << 24, bX = Ve[20] & 255 | (Ve[21] & 255) << 8 | (Ve[22] & 255) << 16 | (Ve[23] & 255) << 24, dX = Ve[24] & 255 | (Ve[25] & 255) << 8 | (Ve[26] & 255) << 16 | (Ve[27] & 255) << 24, mX = Ve[28] & 255 | (Ve[29] & 255) << 8 | (Ve[30] & 255) << 16 | (Ve[31] & 255) << 24, pX = Ie[12] & 255 | (Ie[13] & 255) << 8 | (Ie[14] & 255) << 16 | (Ie[15] & 255) << 24, G_ = nt, iX = Et, og = xt, eX = Jt, tX = Yt, An = _r, Gt = cn, Wt = _X, vr = un, Qt = aX, rr = uX, Ir = fX, gX = bX, TX = dX, IX = mX, RX = pX, wt, CX = 0; CX < 20; CX += 2)
        wt = G_ + gX | 0, tX ^= wt << 7 | wt >>> 25, wt = tX + G_ | 0, vr ^= wt << 9 | wt >>> 23, wt = vr + tX | 0, gX ^= wt << 13 | wt >>> 19, wt = gX + vr | 0, G_ ^= wt << 18 | wt >>> 14, wt = An + iX | 0, Qt ^= wt << 7 | wt >>> 25, wt = Qt + An | 0, TX ^= wt << 9 | wt >>> 23, wt = TX + Qt | 0, iX ^= wt << 13 | wt >>> 19, wt = iX + TX | 0, An ^= wt << 18 | wt >>> 14, wt = rr + Gt | 0, IX ^= wt << 7 | wt >>> 25, wt = IX + rr | 0, og ^= wt << 9 | wt >>> 23, wt = og + IX | 0, Gt ^= wt << 13 | wt >>> 19, wt = Gt + og | 0, rr ^= wt << 18 | wt >>> 14, wt = RX + Ir | 0, eX ^= wt << 7 | wt >>> 25, wt = eX + RX | 0, Wt ^= wt << 9 | wt >>> 23, wt = Wt + eX | 0, Ir ^= wt << 13 | wt >>> 19, wt = Ir + Wt | 0, RX ^= wt << 18 | wt >>> 14, wt = G_ + eX | 0, iX ^= wt << 7 | wt >>> 25, wt = iX + G_ | 0, og ^= wt << 9 | wt >>> 23, wt = og + iX | 0, eX ^= wt << 13 | wt >>> 19, wt = eX + og | 0, G_ ^= wt << 18 | wt >>> 14, wt = An + tX | 0, Gt ^= wt << 7 | wt >>> 25, wt = Gt + An | 0, Wt ^= wt << 9 | wt >>> 23, wt = Wt + Gt | 0, tX ^= wt << 13 | wt >>> 19, wt = tX + Wt | 0, An ^= wt << 18 | wt >>> 14, wt = rr + Qt | 0, Ir ^= wt << 7 | wt >>> 25, wt = Ir + rr | 0, vr ^= wt << 9 | wt >>> 23, wt = vr + Ir | 0, Qt ^= wt << 13 | wt >>> 19, wt = Qt + vr | 0, rr ^= wt << 18 | wt >>> 14, wt = RX + IX | 0, gX ^= wt << 7 | wt >>> 25, wt = gX + RX | 0, TX ^= wt << 9 | wt >>> 23, wt = TX + gX | 0, IX ^= wt << 13 | wt >>> 19, wt = IX + TX | 0, RX ^= wt << 18 | wt >>> 14;
      qe[0] = G_ >>> 0 & 255, qe[1] = G_ >>> 8 & 255, qe[2] = G_ >>> 16 & 255, qe[3] = G_ >>> 24 & 255, qe[4] = An >>> 0 & 255, qe[5] = An >>> 8 & 255, qe[6] = An >>> 16 & 255, qe[7] = An >>> 24 & 255, qe[8] = rr >>> 0 & 255, qe[9] = rr >>> 8 & 255, qe[10] = rr >>> 16 & 255, qe[11] = rr >>> 24 & 255, qe[12] = RX >>> 0 & 255, qe[13] = RX >>> 8 & 255, qe[14] = RX >>> 16 & 255, qe[15] = RX >>> 24 & 255, qe[16] = Gt >>> 0 & 255, qe[17] = Gt >>> 8 & 255, qe[18] = Gt >>> 16 & 255, qe[19] = Gt >>> 24 & 255, qe[20] = Wt >>> 0 & 255, qe[21] = Wt >>> 8 & 255, qe[22] = Wt >>> 16 & 255, qe[23] = Wt >>> 24 & 255, qe[24] = vr >>> 0 & 255, qe[25] = vr >>> 8 & 255, qe[26] = vr >>> 16 & 255, qe[27] = vr >>> 24 & 255, qe[28] = Qt >>> 0 & 255, qe[29] = Qt >>> 8 & 255, qe[30] = Qt >>> 16 & 255, qe[31] = Qt >>> 24 & 255;
    }
    function Fe(qe, Qe, Ve, Ie) {
      Me(qe, Qe, Ve, Ie);
    }
    function Ke(qe, Qe, Ve, Ie) {
      De(qe, Qe, Ve, Ie);
    }
    var tt = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
    function rt(qe, Qe, Ve, Ie, nt, Et, xt) {
      var Jt = new Uint8Array(16), Yt = new Uint8Array(64), _r, cn;
      for (cn = 0; cn < 16; cn++)
        Jt[cn] = 0;
      for (cn = 0; cn < 8; cn++)
        Jt[cn] = Et[cn];
      for (; nt >= 64; ) {
        for (Fe(Yt, Jt, xt, tt), cn = 0; cn < 64; cn++)
          qe[Qe + cn] = Ve[Ie + cn] ^ Yt[cn];
        for (_r = 1, cn = 8; cn < 16; cn++)
          _r = _r + (Jt[cn] & 255) | 0, Jt[cn] = _r & 255, _r >>>= 8;
        nt -= 64, Qe += 64, Ie += 64;
      }
      if (nt > 0)
        for (Fe(Yt, Jt, xt, tt), cn = 0; cn < nt; cn++)
          qe[Qe + cn] = Ve[Ie + cn] ^ Yt[cn];
      return 0;
    }
    function it(qe, Qe, Ve, Ie, nt) {
      var Et = new Uint8Array(16), xt = new Uint8Array(64), Jt, Yt;
      for (Yt = 0; Yt < 16; Yt++)
        Et[Yt] = 0;
      for (Yt = 0; Yt < 8; Yt++)
        Et[Yt] = Ie[Yt];
      for (; Ve >= 64; ) {
        for (Fe(xt, Et, nt, tt), Yt = 0; Yt < 64; Yt++)
          qe[Qe + Yt] = xt[Yt];
        for (Jt = 1, Yt = 8; Yt < 16; Yt++)
          Jt = Jt + (Et[Yt] & 255) | 0, Et[Yt] = Jt & 255, Jt >>>= 8;
        Ve -= 64, Qe += 64;
      }
      if (Ve > 0)
        for (Fe(xt, Et, nt, tt), Yt = 0; Yt < Ve; Yt++)
          qe[Qe + Yt] = xt[Yt];
      return 0;
    }
    function _t(qe, Qe, Ve, Ie, nt) {
      var Et = new Uint8Array(32);
      Ke(Et, Ie, nt, tt);
      for (var xt = new Uint8Array(8), Jt = 0; Jt < 8; Jt++)
        xt[Jt] = Ie[Jt + 16];
      return it(qe, Qe, Ve, xt, Et);
    }
    function Dt(qe, Qe, Ve, Ie, nt, Et, xt) {
      var Jt = new Uint8Array(32);
      Ke(Jt, Et, xt, tt);
      for (var Yt = new Uint8Array(8), _r = 0; _r < 8; _r++)
        Yt[_r] = Et[_r + 16];
      return rt(qe, Qe, Ve, Ie, nt, Yt, Jt);
    }
    var je = function(qe) {
      this.buffer = new Uint8Array(16), this.r = new Uint16Array(10), this.h = new Uint16Array(10), this.pad = new Uint16Array(8), this.leftover = 0, this.fin = 0;
      var Qe, Ve, Ie, nt, Et, xt, Jt, Yt;
      Qe = qe[0] & 255 | (qe[1] & 255) << 8, this.r[0] = Qe & 8191, Ve = qe[2] & 255 | (qe[3] & 255) << 8, this.r[1] = (Qe >>> 13 | Ve << 3) & 8191, Ie = qe[4] & 255 | (qe[5] & 255) << 8, this.r[2] = (Ve >>> 10 | Ie << 6) & 7939, nt = qe[6] & 255 | (qe[7] & 255) << 8, this.r[3] = (Ie >>> 7 | nt << 9) & 8191, Et = qe[8] & 255 | (qe[9] & 255) << 8, this.r[4] = (nt >>> 4 | Et << 12) & 255, this.r[5] = Et >>> 1 & 8190, xt = qe[10] & 255 | (qe[11] & 255) << 8, this.r[6] = (Et >>> 14 | xt << 2) & 8191, Jt = qe[12] & 255 | (qe[13] & 255) << 8, this.r[7] = (xt >>> 11 | Jt << 5) & 8065, Yt = qe[14] & 255 | (qe[15] & 255) << 8, this.r[8] = (Jt >>> 8 | Yt << 8) & 8191, this.r[9] = Yt >>> 5 & 127, this.pad[0] = qe[16] & 255 | (qe[17] & 255) << 8, this.pad[1] = qe[18] & 255 | (qe[19] & 255) << 8, this.pad[2] = qe[20] & 255 | (qe[21] & 255) << 8, this.pad[3] = qe[22] & 255 | (qe[23] & 255) << 8, this.pad[4] = qe[24] & 255 | (qe[25] & 255) << 8, this.pad[5] = qe[26] & 255 | (qe[27] & 255) << 8, this.pad[6] = qe[28] & 255 | (qe[29] & 255) << 8, this.pad[7] = qe[30] & 255 | (qe[31] & 255) << 8;
    };
    je.prototype.blocks = function(qe, Qe, Ve) {
      for (var Ie = this.fin ? 0 : 2048, nt, Et, xt, Jt, Yt, _r, cn, _X, un, aX, uX, fX, bX, dX, mX, pX, G_, iX, og, eX = this.h[0], tX = this.h[1], An = this.h[2], Gt = this.h[3], Wt = this.h[4], vr = this.h[5], Qt = this.h[6], rr = this.h[7], Ir = this.h[8], gX = this.h[9], TX = this.r[0], IX = this.r[1], RX = this.r[2], wt = this.r[3], CX = this.r[4], LX = this.r[5], UX = this.r[6], $X = this.r[7], OX = this.r[8], NX = this.r[9]; Ve >= 16; )
        nt = qe[Qe + 0] & 255 | (qe[Qe + 1] & 255) << 8, eX += nt & 8191, Et = qe[Qe + 2] & 255 | (qe[Qe + 3] & 255) << 8, tX += (nt >>> 13 | Et << 3) & 8191, xt = qe[Qe + 4] & 255 | (qe[Qe + 5] & 255) << 8, An += (Et >>> 10 | xt << 6) & 8191, Jt = qe[Qe + 6] & 255 | (qe[Qe + 7] & 255) << 8, Gt += (xt >>> 7 | Jt << 9) & 8191, Yt = qe[Qe + 8] & 255 | (qe[Qe + 9] & 255) << 8, Wt += (Jt >>> 4 | Yt << 12) & 8191, vr += Yt >>> 1 & 8191, _r = qe[Qe + 10] & 255 | (qe[Qe + 11] & 255) << 8, Qt += (Yt >>> 14 | _r << 2) & 8191, cn = qe[Qe + 12] & 255 | (qe[Qe + 13] & 255) << 8, rr += (_r >>> 11 | cn << 5) & 8191, _X = qe[Qe + 14] & 255 | (qe[Qe + 15] & 255) << 8, Ir += (cn >>> 8 | _X << 8) & 8191, gX += _X >>> 5 | Ie, un = 0, aX = un, aX += eX * TX, aX += tX * (5 * NX), aX += An * (5 * OX), aX += Gt * (5 * $X), aX += Wt * (5 * UX), un = aX >>> 13, aX &= 8191, aX += vr * (5 * LX), aX += Qt * (5 * CX), aX += rr * (5 * wt), aX += Ir * (5 * RX), aX += gX * (5 * IX), un += aX >>> 13, aX &= 8191, uX = un, uX += eX * IX, uX += tX * TX, uX += An * (5 * NX), uX += Gt * (5 * OX), uX += Wt * (5 * $X), un = uX >>> 13, uX &= 8191, uX += vr * (5 * UX), uX += Qt * (5 * LX), uX += rr * (5 * CX), uX += Ir * (5 * wt), uX += gX * (5 * RX), un += uX >>> 13, uX &= 8191, fX = un, fX += eX * RX, fX += tX * IX, fX += An * TX, fX += Gt * (5 * NX), fX += Wt * (5 * OX), un = fX >>> 13, fX &= 8191, fX += vr * (5 * $X), fX += Qt * (5 * UX), fX += rr * (5 * LX), fX += Ir * (5 * CX), fX += gX * (5 * wt), un += fX >>> 13, fX &= 8191, bX = un, bX += eX * wt, bX += tX * RX, bX += An * IX, bX += Gt * TX, bX += Wt * (5 * NX), un = bX >>> 13, bX &= 8191, bX += vr * (5 * OX), bX += Qt * (5 * $X), bX += rr * (5 * UX), bX += Ir * (5 * LX), bX += gX * (5 * CX), un += bX >>> 13, bX &= 8191, dX = un, dX += eX * CX, dX += tX * wt, dX += An * RX, dX += Gt * IX, dX += Wt * TX, un = dX >>> 13, dX &= 8191, dX += vr * (5 * NX), dX += Qt * (5 * OX), dX += rr * (5 * $X), dX += Ir * (5 * UX), dX += gX * (5 * LX), un += dX >>> 13, dX &= 8191, mX = un, mX += eX * LX, mX += tX * CX, mX += An * wt, mX += Gt * RX, mX += Wt * IX, un = mX >>> 13, mX &= 8191, mX += vr * TX, mX += Qt * (5 * NX), mX += rr * (5 * OX), mX += Ir * (5 * $X), mX += gX * (5 * UX), un += mX >>> 13, mX &= 8191, pX = un, pX += eX * UX, pX += tX * LX, pX += An * CX, pX += Gt * wt, pX += Wt * RX, un = pX >>> 13, pX &= 8191, pX += vr * IX, pX += Qt * TX, pX += rr * (5 * NX), pX += Ir * (5 * OX), pX += gX * (5 * $X), un += pX >>> 13, pX &= 8191, G_ = un, G_ += eX * $X, G_ += tX * UX, G_ += An * LX, G_ += Gt * CX, G_ += Wt * wt, un = G_ >>> 13, G_ &= 8191, G_ += vr * RX, G_ += Qt * IX, G_ += rr * TX, G_ += Ir * (5 * NX), G_ += gX * (5 * OX), un += G_ >>> 13, G_ &= 8191, iX = un, iX += eX * OX, iX += tX * $X, iX += An * UX, iX += Gt * LX, iX += Wt * CX, un = iX >>> 13, iX &= 8191, iX += vr * wt, iX += Qt * RX, iX += rr * IX, iX += Ir * TX, iX += gX * (5 * NX), un += iX >>> 13, iX &= 8191, og = un, og += eX * NX, og += tX * OX, og += An * $X, og += Gt * UX, og += Wt * LX, un = og >>> 13, og &= 8191, og += vr * CX, og += Qt * wt, og += rr * RX, og += Ir * IX, og += gX * TX, un += og >>> 13, og &= 8191, un = (un << 2) + un | 0, un = un + aX | 0, aX = un & 8191, un = un >>> 13, uX += un, eX = aX, tX = uX, An = fX, Gt = bX, Wt = dX, vr = mX, Qt = pX, rr = G_, Ir = iX, gX = og, Qe += 16, Ve -= 16;
      this.h[0] = eX, this.h[1] = tX, this.h[2] = An, this.h[3] = Gt, this.h[4] = Wt, this.h[5] = vr, this.h[6] = Qt, this.h[7] = rr, this.h[8] = Ir, this.h[9] = gX;
    }, je.prototype.finish = function(qe, Qe) {
      var Ve = new Uint16Array(10), Ie, nt, Et, xt;
      if (this.leftover) {
        for (xt = this.leftover, this.buffer[xt++] = 1; xt < 16; xt++)
          this.buffer[xt] = 0;
        this.fin = 1, this.blocks(this.buffer, 0, 16);
      }
      for (Ie = this.h[1] >>> 13, this.h[1] &= 8191, xt = 2; xt < 10; xt++)
        this.h[xt] += Ie, Ie = this.h[xt] >>> 13, this.h[xt] &= 8191;
      for (this.h[0] += Ie * 5, Ie = this.h[0] >>> 13, this.h[0] &= 8191, this.h[1] += Ie, Ie = this.h[1] >>> 13, this.h[1] &= 8191, this.h[2] += Ie, Ve[0] = this.h[0] + 5, Ie = Ve[0] >>> 13, Ve[0] &= 8191, xt = 1; xt < 10; xt++)
        Ve[xt] = this.h[xt] + Ie, Ie = Ve[xt] >>> 13, Ve[xt] &= 8191;
      for (Ve[9] -= 8192, nt = (Ie ^ 1) - 1, xt = 0; xt < 10; xt++)
        Ve[xt] &= nt;
      for (nt = ~nt, xt = 0; xt < 10; xt++)
        this.h[xt] = this.h[xt] & nt | Ve[xt];
      for (this.h[0] = (this.h[0] | this.h[1] << 13) & 65535, this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 65535, this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 65535, this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 65535, this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 65535, this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 65535, this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 65535, this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 65535, Et = this.h[0] + this.pad[0], this.h[0] = Et & 65535, xt = 1; xt < 8; xt++)
        Et = (this.h[xt] + this.pad[xt] | 0) + (Et >>> 16) | 0, this.h[xt] = Et & 65535;
      qe[Qe + 0] = this.h[0] >>> 0 & 255, qe[Qe + 1] = this.h[0] >>> 8 & 255, qe[Qe + 2] = this.h[1] >>> 0 & 255, qe[Qe + 3] = this.h[1] >>> 8 & 255, qe[Qe + 4] = this.h[2] >>> 0 & 255, qe[Qe + 5] = this.h[2] >>> 8 & 255, qe[Qe + 6] = this.h[3] >>> 0 & 255, qe[Qe + 7] = this.h[3] >>> 8 & 255, qe[Qe + 8] = this.h[4] >>> 0 & 255, qe[Qe + 9] = this.h[4] >>> 8 & 255, qe[Qe + 10] = this.h[5] >>> 0 & 255, qe[Qe + 11] = this.h[5] >>> 8 & 255, qe[Qe + 12] = this.h[6] >>> 0 & 255, qe[Qe + 13] = this.h[6] >>> 8 & 255, qe[Qe + 14] = this.h[7] >>> 0 & 255, qe[Qe + 15] = this.h[7] >>> 8 & 255;
    }, je.prototype.update = function(qe, Qe, Ve) {
      var Ie, nt;
      if (this.leftover) {
        for (nt = 16 - this.leftover, nt > Ve && (nt = Ve), Ie = 0; Ie < nt; Ie++)
          this.buffer[this.leftover + Ie] = qe[Qe + Ie];
        if (Ve -= nt, Qe += nt, this.leftover += nt, this.leftover < 16)
          return;
        this.blocks(this.buffer, 0, 16), this.leftover = 0;
      }
      if (Ve >= 16 && (nt = Ve - Ve % 16, this.blocks(qe, Qe, nt), Qe += nt, Ve -= nt), Ve) {
        for (Ie = 0; Ie < Ve; Ie++)
          this.buffer[this.leftover + Ie] = qe[Qe + Ie];
        this.leftover += Ve;
      }
    };
    function ze(qe, Qe, Ve, Ie, nt, Et) {
      var xt = new je(Et);
      return xt.update(Ve, Ie, nt), xt.finish(qe, Qe), 0;
    }
    function fe(qe, Qe, Ve, Ie, nt, Et) {
      var xt = new Uint8Array(16);
      return ze(xt, 0, Ve, Ie, nt, Et), Re(qe, Qe, xt, 0);
    }
    function de(qe, Qe, Ve, Ie, nt) {
      var Et;
      if (Ve < 32)
        return -1;
      for (Dt(qe, 0, Qe, 0, Ve, Ie, nt), ze(qe, 16, qe, 32, Ve - 32, qe), Et = 0; Et < 16; Et++)
        qe[Et] = 0;
      return 0;
    }
    function be(qe, Qe, Ve, Ie, nt) {
      var Et, xt = new Uint8Array(32);
      if (Ve < 32 || (_t(xt, 0, 32, Ie, nt), fe(Qe, 16, Qe, 32, Ve - 32, xt) !== 0))
        return -1;
      for (Dt(qe, 0, Qe, 0, Ve, Ie, nt), Et = 0; Et < 32; Et++)
        qe[Et] = 0;
      return 0;
    }
    function Te(qe, Qe) {
      var Ve;
      for (Ve = 0; Ve < 16; Ve++)
        qe[Ve] = Qe[Ve] | 0;
    }
    function Ce(qe) {
      var Qe, Ve, Ie = 1;
      for (Qe = 0; Qe < 16; Qe++)
        Ve = qe[Qe] + Ie + 65535, Ie = Math.floor(Ve / 65536), qe[Qe] = Ve - Ie * 65536;
      qe[0] += Ie - 1 + 37 * (Ie - 1);
    }
    function Pe(qe, Qe, Ve) {
      for (var Ie, nt = ~(Ve - 1), Et = 0; Et < 16; Et++)
        Ie = nt & (qe[Et] ^ Qe[Et]), qe[Et] ^= Ie, Qe[Et] ^= Ie;
    }
    function Se(qe, Qe) {
      var Ve, Ie, nt, Et = ee(), xt = ee();
      for (Ve = 0; Ve < 16; Ve++)
        xt[Ve] = Qe[Ve];
      for (Ce(xt), Ce(xt), Ce(xt), Ie = 0; Ie < 2; Ie++) {
        for (Et[0] = xt[0] - 65517, Ve = 1; Ve < 15; Ve++)
          Et[Ve] = xt[Ve] - 65535 - (Et[Ve - 1] >> 16 & 1), Et[Ve - 1] &= 65535;
        Et[15] = xt[15] - 32767 - (Et[14] >> 16 & 1), nt = Et[15] >> 16 & 1, Et[14] &= 65535, Pe(xt, Et, 1 - nt);
      }
      for (Ve = 0; Ve < 16; Ve++)
        qe[2 * Ve] = xt[Ve] & 255, qe[2 * Ve + 1] = xt[Ve] >> 8;
    }
    function ke(qe, Qe) {
      var Ve = new Uint8Array(32), Ie = new Uint8Array(32);
      return Se(Ve, qe), Se(Ie, Qe), Ue(Ve, 0, Ie, 0);
    }
    function ge(qe) {
      var Qe = new Uint8Array(32);
      return Se(Qe, qe), Qe[0] & 1;
    }
    function Ae(qe, Qe) {
      var Ve;
      for (Ve = 0; Ve < 16; Ve++)
        qe[Ve] = Qe[2 * Ve] + (Qe[2 * Ve + 1] << 8);
      qe[15] &= 32767;
    }
    function Ge(qe, Qe, Ve) {
      for (var Ie = 0; Ie < 16; Ie++)
        qe[Ie] = Qe[Ie] + Ve[Ie];
    }
    function Xe(qe, Qe, Ve) {
      for (var Ie = 0; Ie < 16; Ie++)
        qe[Ie] = Qe[Ie] - Ve[Ie];
    }
    function $e(qe, Qe, Ve) {
      var Ie, nt, Et = 0, xt = 0, Jt = 0, Yt = 0, _r = 0, cn = 0, _X = 0, un = 0, aX = 0, uX = 0, fX = 0, bX = 0, dX = 0, mX = 0, pX = 0, G_ = 0, iX = 0, og = 0, eX = 0, tX = 0, An = 0, Gt = 0, Wt = 0, vr = 0, Qt = 0, rr = 0, Ir = 0, gX = 0, TX = 0, IX = 0, RX = 0, wt = Ve[0], CX = Ve[1], LX = Ve[2], UX = Ve[3], $X = Ve[4], OX = Ve[5], NX = Ve[6], GX = Ve[7], zX = Ve[8], qX = Ve[9], DX = Ve[10], HX = Ve[11], KX = Ve[12], WX = Ve[13], VX = Ve[14], JX = Ve[15];
      Ie = Qe[0], Et += Ie * wt, xt += Ie * CX, Jt += Ie * LX, Yt += Ie * UX, _r += Ie * $X, cn += Ie * OX, _X += Ie * NX, un += Ie * GX, aX += Ie * zX, uX += Ie * qX, fX += Ie * DX, bX += Ie * HX, dX += Ie * KX, mX += Ie * WX, pX += Ie * VX, G_ += Ie * JX, Ie = Qe[1], xt += Ie * wt, Jt += Ie * CX, Yt += Ie * LX, _r += Ie * UX, cn += Ie * $X, _X += Ie * OX, un += Ie * NX, aX += Ie * GX, uX += Ie * zX, fX += Ie * qX, bX += Ie * DX, dX += Ie * HX, mX += Ie * KX, pX += Ie * WX, G_ += Ie * VX, iX += Ie * JX, Ie = Qe[2], Jt += Ie * wt, Yt += Ie * CX, _r += Ie * LX, cn += Ie * UX, _X += Ie * $X, un += Ie * OX, aX += Ie * NX, uX += Ie * GX, fX += Ie * zX, bX += Ie * qX, dX += Ie * DX, mX += Ie * HX, pX += Ie * KX, G_ += Ie * WX, iX += Ie * VX, og += Ie * JX, Ie = Qe[3], Yt += Ie * wt, _r += Ie * CX, cn += Ie * LX, _X += Ie * UX, un += Ie * $X, aX += Ie * OX, uX += Ie * NX, fX += Ie * GX, bX += Ie * zX, dX += Ie * qX, mX += Ie * DX, pX += Ie * HX, G_ += Ie * KX, iX += Ie * WX, og += Ie * VX, eX += Ie * JX, Ie = Qe[4], _r += Ie * wt, cn += Ie * CX, _X += Ie * LX, un += Ie * UX, aX += Ie * $X, uX += Ie * OX, fX += Ie * NX, bX += Ie * GX, dX += Ie * zX, mX += Ie * qX, pX += Ie * DX, G_ += Ie * HX, iX += Ie * KX, og += Ie * WX, eX += Ie * VX, tX += Ie * JX, Ie = Qe[5], cn += Ie * wt, _X += Ie * CX, un += Ie * LX, aX += Ie * UX, uX += Ie * $X, fX += Ie * OX, bX += Ie * NX, dX += Ie * GX, mX += Ie * zX, pX += Ie * qX, G_ += Ie * DX, iX += Ie * HX, og += Ie * KX, eX += Ie * WX, tX += Ie * VX, An += Ie * JX, Ie = Qe[6], _X += Ie * wt, un += Ie * CX, aX += Ie * LX, uX += Ie * UX, fX += Ie * $X, bX += Ie * OX, dX += Ie * NX, mX += Ie * GX, pX += Ie * zX, G_ += Ie * qX, iX += Ie * DX, og += Ie * HX, eX += Ie * KX, tX += Ie * WX, An += Ie * VX, Gt += Ie * JX, Ie = Qe[7], un += Ie * wt, aX += Ie * CX, uX += Ie * LX, fX += Ie * UX, bX += Ie * $X, dX += Ie * OX, mX += Ie * NX, pX += Ie * GX, G_ += Ie * zX, iX += Ie * qX, og += Ie * DX, eX += Ie * HX, tX += Ie * KX, An += Ie * WX, Gt += Ie * VX, Wt += Ie * JX, Ie = Qe[8], aX += Ie * wt, uX += Ie * CX, fX += Ie * LX, bX += Ie * UX, dX += Ie * $X, mX += Ie * OX, pX += Ie * NX, G_ += Ie * GX, iX += Ie * zX, og += Ie * qX, eX += Ie * DX, tX += Ie * HX, An += Ie * KX, Gt += Ie * WX, Wt += Ie * VX, vr += Ie * JX, Ie = Qe[9], uX += Ie * wt, fX += Ie * CX, bX += Ie * LX, dX += Ie * UX, mX += Ie * $X, pX += Ie * OX, G_ += Ie * NX, iX += Ie * GX, og += Ie * zX, eX += Ie * qX, tX += Ie * DX, An += Ie * HX, Gt += Ie * KX, Wt += Ie * WX, vr += Ie * VX, Qt += Ie * JX, Ie = Qe[10], fX += Ie * wt, bX += Ie * CX, dX += Ie * LX, mX += Ie * UX, pX += Ie * $X, G_ += Ie * OX, iX += Ie * NX, og += Ie * GX, eX += Ie * zX, tX += Ie * qX, An += Ie * DX, Gt += Ie * HX, Wt += Ie * KX, vr += Ie * WX, Qt += Ie * VX, rr += Ie * JX, Ie = Qe[11], bX += Ie * wt, dX += Ie * CX, mX += Ie * LX, pX += Ie * UX, G_ += Ie * $X, iX += Ie * OX, og += Ie * NX, eX += Ie * GX, tX += Ie * zX, An += Ie * qX, Gt += Ie * DX, Wt += Ie * HX, vr += Ie * KX, Qt += Ie * WX, rr += Ie * VX, Ir += Ie * JX, Ie = Qe[12], dX += Ie * wt, mX += Ie * CX, pX += Ie * LX, G_ += Ie * UX, iX += Ie * $X, og += Ie * OX, eX += Ie * NX, tX += Ie * GX, An += Ie * zX, Gt += Ie * qX, Wt += Ie * DX, vr += Ie * HX, Qt += Ie * KX, rr += Ie * WX, Ir += Ie * VX, gX += Ie * JX, Ie = Qe[13], mX += Ie * wt, pX += Ie * CX, G_ += Ie * LX, iX += Ie * UX, og += Ie * $X, eX += Ie * OX, tX += Ie * NX, An += Ie * GX, Gt += Ie * zX, Wt += Ie * qX, vr += Ie * DX, Qt += Ie * HX, rr += Ie * KX, Ir += Ie * WX, gX += Ie * VX, TX += Ie * JX, Ie = Qe[14], pX += Ie * wt, G_ += Ie * CX, iX += Ie * LX, og += Ie * UX, eX += Ie * $X, tX += Ie * OX, An += Ie * NX, Gt += Ie * GX, Wt += Ie * zX, vr += Ie * qX, Qt += Ie * DX, rr += Ie * HX, Ir += Ie * KX, gX += Ie * WX, TX += Ie * VX, IX += Ie * JX, Ie = Qe[15], G_ += Ie * wt, iX += Ie * CX, og += Ie * LX, eX += Ie * UX, tX += Ie * $X, An += Ie * OX, Gt += Ie * NX, Wt += Ie * GX, vr += Ie * zX, Qt += Ie * qX, rr += Ie * DX, Ir += Ie * HX, gX += Ie * KX, TX += Ie * WX, IX += Ie * VX, RX += Ie * JX, Et += 38 * iX, xt += 38 * og, Jt += 38 * eX, Yt += 38 * tX, _r += 38 * An, cn += 38 * Gt, _X += 38 * Wt, un += 38 * vr, aX += 38 * Qt, uX += 38 * rr, fX += 38 * Ir, bX += 38 * gX, dX += 38 * TX, mX += 38 * IX, pX += 38 * RX, nt = 1, Ie = Et + nt + 65535, nt = Math.floor(Ie / 65536), Et = Ie - nt * 65536, Ie = xt + nt + 65535, nt = Math.floor(Ie / 65536), xt = Ie - nt * 65536, Ie = Jt + nt + 65535, nt = Math.floor(Ie / 65536), Jt = Ie - nt * 65536, Ie = Yt + nt + 65535, nt = Math.floor(Ie / 65536), Yt = Ie - nt * 65536, Ie = _r + nt + 65535, nt = Math.floor(Ie / 65536), _r = Ie - nt * 65536, Ie = cn + nt + 65535, nt = Math.floor(Ie / 65536), cn = Ie - nt * 65536, Ie = _X + nt + 65535, nt = Math.floor(Ie / 65536), _X = Ie - nt * 65536, Ie = un + nt + 65535, nt = Math.floor(Ie / 65536), un = Ie - nt * 65536, Ie = aX + nt + 65535, nt = Math.floor(Ie / 65536), aX = Ie - nt * 65536, Ie = uX + nt + 65535, nt = Math.floor(Ie / 65536), uX = Ie - nt * 65536, Ie = fX + nt + 65535, nt = Math.floor(Ie / 65536), fX = Ie - nt * 65536, Ie = bX + nt + 65535, nt = Math.floor(Ie / 65536), bX = Ie - nt * 65536, Ie = dX + nt + 65535, nt = Math.floor(Ie / 65536), dX = Ie - nt * 65536, Ie = mX + nt + 65535, nt = Math.floor(Ie / 65536), mX = Ie - nt * 65536, Ie = pX + nt + 65535, nt = Math.floor(Ie / 65536), pX = Ie - nt * 65536, Ie = G_ + nt + 65535, nt = Math.floor(Ie / 65536), G_ = Ie - nt * 65536, Et += nt - 1 + 37 * (nt - 1), nt = 1, Ie = Et + nt + 65535, nt = Math.floor(Ie / 65536), Et = Ie - nt * 65536, Ie = xt + nt + 65535, nt = Math.floor(Ie / 65536), xt = Ie - nt * 65536, Ie = Jt + nt + 65535, nt = Math.floor(Ie / 65536), Jt = Ie - nt * 65536, Ie = Yt + nt + 65535, nt = Math.floor(Ie / 65536), Yt = Ie - nt * 65536, Ie = _r + nt + 65535, nt = Math.floor(Ie / 65536), _r = Ie - nt * 65536, Ie = cn + nt + 65535, nt = Math.floor(Ie / 65536), cn = Ie - nt * 65536, Ie = _X + nt + 65535, nt = Math.floor(Ie / 65536), _X = Ie - nt * 65536, Ie = un + nt + 65535, nt = Math.floor(Ie / 65536), un = Ie - nt * 65536, Ie = aX + nt + 65535, nt = Math.floor(Ie / 65536), aX = Ie - nt * 65536, Ie = uX + nt + 65535, nt = Math.floor(Ie / 65536), uX = Ie - nt * 65536, Ie = fX + nt + 65535, nt = Math.floor(Ie / 65536), fX = Ie - nt * 65536, Ie = bX + nt + 65535, nt = Math.floor(Ie / 65536), bX = Ie - nt * 65536, Ie = dX + nt + 65535, nt = Math.floor(Ie / 65536), dX = Ie - nt * 65536, Ie = mX + nt + 65535, nt = Math.floor(Ie / 65536), mX = Ie - nt * 65536, Ie = pX + nt + 65535, nt = Math.floor(Ie / 65536), pX = Ie - nt * 65536, Ie = G_ + nt + 65535, nt = Math.floor(Ie / 65536), G_ = Ie - nt * 65536, Et += nt - 1 + 37 * (nt - 1), qe[0] = Et, qe[1] = xt, qe[2] = Jt, qe[3] = Yt, qe[4] = _r, qe[5] = cn, qe[6] = _X, qe[7] = un, qe[8] = aX, qe[9] = uX, qe[10] = fX, qe[11] = bX, qe[12] = dX, qe[13] = mX, qe[14] = pX, qe[15] = G_;
    }
    function Ze(qe, Qe) {
      $e(qe, Qe, Qe);
    }
    function ot(qe, Qe) {
      var Ve = ee(), Ie;
      for (Ie = 0; Ie < 16; Ie++)
        Ve[Ie] = Qe[Ie];
      for (Ie = 253; Ie >= 0; Ie--)
        Ze(Ve, Ve), Ie !== 2 && Ie !== 4 && $e(Ve, Ve, Qe);
      for (Ie = 0; Ie < 16; Ie++)
        qe[Ie] = Ve[Ie];
    }
    function ct(qe, Qe) {
      var Ve = ee(), Ie;
      for (Ie = 0; Ie < 16; Ie++)
        Ve[Ie] = Qe[Ie];
      for (Ie = 250; Ie >= 0; Ie--)
        Ze(Ve, Ve), Ie !== 1 && $e(Ve, Ve, Qe);
      for (Ie = 0; Ie < 16; Ie++)
        qe[Ie] = Ve[Ie];
    }
    function At(qe, Qe, Ve) {
      var Ie = new Uint8Array(32), nt = new Float64Array(80), Et, xt, Jt = ee(), Yt = ee(), _r = ee(), cn = ee(), _X = ee(), un = ee();
      for (xt = 0; xt < 31; xt++)
        Ie[xt] = Qe[xt];
      for (Ie[31] = Qe[31] & 127 | 64, Ie[0] &= 248, Ae(nt, Ve), xt = 0; xt < 16; xt++)
        Yt[xt] = nt[xt], cn[xt] = Jt[xt] = _r[xt] = 0;
      for (Jt[0] = cn[0] = 1, xt = 254; xt >= 0; --xt)
        Et = Ie[xt >>> 3] >>> (xt & 7) & 1, Pe(Jt, Yt, Et), Pe(_r, cn, Et), Ge(_X, Jt, _r), Xe(Jt, Jt, _r), Ge(_r, Yt, cn), Xe(Yt, Yt, cn), Ze(cn, _X), Ze(un, Jt), $e(Jt, _r, Jt), $e(_r, Yt, _X), Ge(_X, Jt, _r), Xe(Jt, Jt, _r), Ze(Yt, Jt), Xe(_r, cn, un), $e(Jt, _r, ae), Ge(Jt, Jt, cn), $e(_r, _r, Jt), $e(Jt, cn, un), $e(cn, Yt, nt), Ze(Yt, _X), Pe(Jt, Yt, Et), Pe(_r, cn, Et);
      for (xt = 0; xt < 16; xt++)
        nt[xt + 16] = Jt[xt], nt[xt + 32] = _r[xt], nt[xt + 48] = Yt[xt], nt[xt + 64] = cn[xt];
      var aX = nt.subarray(32), uX = nt.subarray(16);
      return ot(aX, aX), $e(uX, uX, aX), Se(qe, uX), 0;
    }
    function Tt(qe, Qe) {
      return At(qe, Qe, ie);
    }
    function dt(qe, Qe) {
      return te(Qe, 32), Tt(qe, Qe);
    }
    function vt(qe, Qe, Ve) {
      var Ie = new Uint8Array(32);
      return At(Ie, Ve, Qe), Ke(qe, ne, Ie, tt);
    }
    var Ut = de, It = be;
    function Er(qe, Qe, Ve, Ie, nt, Et) {
      var xt = new Uint8Array(32);
      return vt(xt, nt, Et), Ut(qe, Qe, Ve, Ie, xt);
    }
    function Fr(qe, Qe, Ve, Ie, nt, Et) {
      var xt = new Uint8Array(32);
      return vt(xt, nt, Et), It(qe, Qe, Ve, Ie, xt);
    }
    var an = [
      1116352408,
      3609767458,
      1899447441,
      602891725,
      3049323471,
      3964484399,
      3921009573,
      2173295548,
      961987163,
      4081628472,
      1508970993,
      3053834265,
      2453635748,
      2937671579,
      2870763221,
      3664609560,
      3624381080,
      2734883394,
      310598401,
      1164996542,
      607225278,
      1323610764,
      1426881987,
      3590304994,
      1925078388,
      4068182383,
      2162078206,
      991336113,
      2614888103,
      633803317,
      3248222580,
      3479774868,
      3835390401,
      2666613458,
      4022224774,
      944711139,
      264347078,
      2341262773,
      604807628,
      2007800933,
      770255983,
      1495990901,
      1249150122,
      1856431235,
      1555081692,
      3175218132,
      1996064986,
      2198950837,
      2554220882,
      3999719339,
      2821834349,
      766784016,
      2952996808,
      2566594879,
      3210313671,
      3203337956,
      3336571891,
      1034457026,
      3584528711,
      2466948901,
      113926993,
      3758326383,
      338241895,
      168717936,
      666307205,
      1188179964,
      773529912,
      1546045734,
      1294757372,
      1522805485,
      1396182291,
      2643833823,
      1695183700,
      2343527390,
      1986661051,
      1014477480,
      2177026350,
      1206759142,
      2456956037,
      344077627,
      2730485921,
      1290863460,
      2820302411,
      3158454273,
      3259730800,
      3505952657,
      3345764771,
      106217008,
      3516065817,
      3606008344,
      3600352804,
      1432725776,
      4094571909,
      1467031594,
      275423344,
      851169720,
      430227734,
      3100823752,
      506948616,
      1363258195,
      659060556,
      3750685593,
      883997877,
      3785050280,
      958139571,
      3318307427,
      1322822218,
      3812723403,
      1537002063,
      2003034995,
      1747873779,
      3602036899,
      1955562222,
      1575990012,
      2024104815,
      1125592928,
      2227730452,
      2716904306,
      2361852424,
      442776044,
      2428436474,
      593698344,
      2756734187,
      3733110249,
      3204031479,
      2999351573,
      3329325298,
      3815920427,
      3391569614,
      3928383900,
      3515267271,
      566280711,
      3940187606,
      3454069534,
      4118630271,
      4000239992,
      116418474,
      1914138554,
      174292421,
      2731055270,
      289380356,
      3203993006,
      460393269,
      320620315,
      685471733,
      587496836,
      852142971,
      1086792851,
      1017036298,
      365543100,
      1126000580,
      2618297676,
      1288033470,
      3409855158,
      1501505948,
      4234509866,
      1607167915,
      987167468,
      1816402316,
      1246189591
    ];
    function wX(qe, Qe, Ve, Ie) {
      for (var nt = new Int32Array(16), Et = new Int32Array(16), xt, Jt, Yt, _r, cn, _X, un, aX, uX, fX, bX, dX, mX, pX, G_, iX, og, eX, tX, An, Gt, Wt, vr, Qt, rr, Ir, gX = qe[0], TX = qe[1], IX = qe[2], RX = qe[3], wt = qe[4], CX = qe[5], LX = qe[6], UX = qe[7], $X = Qe[0], OX = Qe[1], NX = Qe[2], GX = Qe[3], zX = Qe[4], qX = Qe[5], DX = Qe[6], HX = Qe[7], KX = 0; Ie >= 128; ) {
        for (tX = 0; tX < 16; tX++)
          An = 8 * tX + KX, nt[tX] = Ve[An + 0] << 24 | Ve[An + 1] << 16 | Ve[An + 2] << 8 | Ve[An + 3], Et[tX] = Ve[An + 4] << 24 | Ve[An + 5] << 16 | Ve[An + 6] << 8 | Ve[An + 7];
        for (tX = 0; tX < 80; tX++)
          if (xt = gX, Jt = TX, Yt = IX, _r = RX, cn = wt, _X = CX, un = LX, aX = UX, uX = $X, fX = OX, bX = NX, dX = GX, mX = zX, pX = qX, G_ = DX, iX = HX, Gt = UX, Wt = HX, vr = Wt & 65535, Qt = Wt >>> 16, rr = Gt & 65535, Ir = Gt >>> 16, Gt = (wt >>> 14 | zX << 18) ^ (wt >>> 18 | zX << 14) ^ (zX >>> 9 | wt << 23), Wt = (zX >>> 14 | wt << 18) ^ (zX >>> 18 | wt << 14) ^ (wt >>> 9 | zX << 23), vr += Wt & 65535, Qt += Wt >>> 16, rr += Gt & 65535, Ir += Gt >>> 16, Gt = wt & CX ^ ~wt & LX, Wt = zX & qX ^ ~zX & DX, vr += Wt & 65535, Qt += Wt >>> 16, rr += Gt & 65535, Ir += Gt >>> 16, Gt = an[tX * 2], Wt = an[tX * 2 + 1], vr += Wt & 65535, Qt += Wt >>> 16, rr += Gt & 65535, Ir += Gt >>> 16, Gt = nt[tX % 16], Wt = Et[tX % 16], vr += Wt & 65535, Qt += Wt >>> 16, rr += Gt & 65535, Ir += Gt >>> 16, Qt += vr >>> 16, rr += Qt >>> 16, Ir += rr >>> 16, og = rr & 65535 | Ir << 16, eX = vr & 65535 | Qt << 16, Gt = og, Wt = eX, vr = Wt & 65535, Qt = Wt >>> 16, rr = Gt & 65535, Ir = Gt >>> 16, Gt = (gX >>> 28 | $X << 4) ^ ($X >>> 2 | gX << 30) ^ ($X >>> 7 | gX << 25), Wt = ($X >>> 28 | gX << 4) ^ (gX >>> 2 | $X << 30) ^ (gX >>> 7 | $X << 25), vr += Wt & 65535, Qt += Wt >>> 16, rr += Gt & 65535, Ir += Gt >>> 16, Gt = gX & TX ^ gX & IX ^ TX & IX, Wt = $X & OX ^ $X & NX ^ OX & NX, vr += Wt & 65535, Qt += Wt >>> 16, rr += Gt & 65535, Ir += Gt >>> 16, Qt += vr >>> 16, rr += Qt >>> 16, Ir += rr >>> 16, aX = rr & 65535 | Ir << 16, iX = vr & 65535 | Qt << 16, Gt = _r, Wt = dX, vr = Wt & 65535, Qt = Wt >>> 16, rr = Gt & 65535, Ir = Gt >>> 16, Gt = og, Wt = eX, vr += Wt & 65535, Qt += Wt >>> 16, rr += Gt & 65535, Ir += Gt >>> 16, Qt += vr >>> 16, rr += Qt >>> 16, Ir += rr >>> 16, _r = rr & 65535 | Ir << 16, dX = vr & 65535 | Qt << 16, TX = xt, IX = Jt, RX = Yt, wt = _r, CX = cn, LX = _X, UX = un, gX = aX, OX = uX, NX = fX, GX = bX, zX = dX, qX = mX, DX = pX, HX = G_, $X = iX, tX % 16 === 15)
            for (An = 0; An < 16; An++)
              Gt = nt[An], Wt = Et[An], vr = Wt & 65535, Qt = Wt >>> 16, rr = Gt & 65535, Ir = Gt >>> 16, Gt = nt[(An + 9) % 16], Wt = Et[(An + 9) % 16], vr += Wt & 65535, Qt += Wt >>> 16, rr += Gt & 65535, Ir += Gt >>> 16, og = nt[(An + 1) % 16], eX = Et[(An + 1) % 16], Gt = (og >>> 1 | eX << 31) ^ (og >>> 8 | eX << 24) ^ og >>> 7, Wt = (eX >>> 1 | og << 31) ^ (eX >>> 8 | og << 24) ^ (eX >>> 7 | og << 25), vr += Wt & 65535, Qt += Wt >>> 16, rr += Gt & 65535, Ir += Gt >>> 16, og = nt[(An + 14) % 16], eX = Et[(An + 14) % 16], Gt = (og >>> 19 | eX << 13) ^ (eX >>> 29 | og << 3) ^ og >>> 6, Wt = (eX >>> 19 | og << 13) ^ (og >>> 29 | eX << 3) ^ (eX >>> 6 | og << 26), vr += Wt & 65535, Qt += Wt >>> 16, rr += Gt & 65535, Ir += Gt >>> 16, Qt += vr >>> 16, rr += Qt >>> 16, Ir += rr >>> 16, nt[An] = rr & 65535 | Ir << 16, Et[An] = vr & 65535 | Qt << 16;
        Gt = gX, Wt = $X, vr = Wt & 65535, Qt = Wt >>> 16, rr = Gt & 65535, Ir = Gt >>> 16, Gt = qe[0], Wt = Qe[0], vr += Wt & 65535, Qt += Wt >>> 16, rr += Gt & 65535, Ir += Gt >>> 16, Qt += vr >>> 16, rr += Qt >>> 16, Ir += rr >>> 16, qe[0] = gX = rr & 65535 | Ir << 16, Qe[0] = $X = vr & 65535 | Qt << 16, Gt = TX, Wt = OX, vr = Wt & 65535, Qt = Wt >>> 16, rr = Gt & 65535, Ir = Gt >>> 16, Gt = qe[1], Wt = Qe[1], vr += Wt & 65535, Qt += Wt >>> 16, rr += Gt & 65535, Ir += Gt >>> 16, Qt += vr >>> 16, rr += Qt >>> 16, Ir += rr >>> 16, qe[1] = TX = rr & 65535 | Ir << 16, Qe[1] = OX = vr & 65535 | Qt << 16, Gt = IX, Wt = NX, vr = Wt & 65535, Qt = Wt >>> 16, rr = Gt & 65535, Ir = Gt >>> 16, Gt = qe[2], Wt = Qe[2], vr += Wt & 65535, Qt += Wt >>> 16, rr += Gt & 65535, Ir += Gt >>> 16, Qt += vr >>> 16, rr += Qt >>> 16, Ir += rr >>> 16, qe[2] = IX = rr & 65535 | Ir << 16, Qe[2] = NX = vr & 65535 | Qt << 16, Gt = RX, Wt = GX, vr = Wt & 65535, Qt = Wt >>> 16, rr = Gt & 65535, Ir = Gt >>> 16, Gt = qe[3], Wt = Qe[3], vr += Wt & 65535, Qt += Wt >>> 16, rr += Gt & 65535, Ir += Gt >>> 16, Qt += vr >>> 16, rr += Qt >>> 16, Ir += rr >>> 16, qe[3] = RX = rr & 65535 | Ir << 16, Qe[3] = GX = vr & 65535 | Qt << 16, Gt = wt, Wt = zX, vr = Wt & 65535, Qt = Wt >>> 16, rr = Gt & 65535, Ir = Gt >>> 16, Gt = qe[4], Wt = Qe[4], vr += Wt & 65535, Qt += Wt >>> 16, rr += Gt & 65535, Ir += Gt >>> 16, Qt += vr >>> 16, rr += Qt >>> 16, Ir += rr >>> 16, qe[4] = wt = rr & 65535 | Ir << 16, Qe[4] = zX = vr & 65535 | Qt << 16, Gt = CX, Wt = qX, vr = Wt & 65535, Qt = Wt >>> 16, rr = Gt & 65535, Ir = Gt >>> 16, Gt = qe[5], Wt = Qe[5], vr += Wt & 65535, Qt += Wt >>> 16, rr += Gt & 65535, Ir += Gt >>> 16, Qt += vr >>> 16, rr += Qt >>> 16, Ir += rr >>> 16, qe[5] = CX = rr & 65535 | Ir << 16, Qe[5] = qX = vr & 65535 | Qt << 16, Gt = LX, Wt = DX, vr = Wt & 65535, Qt = Wt >>> 16, rr = Gt & 65535, Ir = Gt >>> 16, Gt = qe[6], Wt = Qe[6], vr += Wt & 65535, Qt += Wt >>> 16, rr += Gt & 65535, Ir += Gt >>> 16, Qt += vr >>> 16, rr += Qt >>> 16, Ir += rr >>> 16, qe[6] = LX = rr & 65535 | Ir << 16, Qe[6] = DX = vr & 65535 | Qt << 16, Gt = UX, Wt = HX, vr = Wt & 65535, Qt = Wt >>> 16, rr = Gt & 65535, Ir = Gt >>> 16, Gt = qe[7], Wt = Qe[7], vr += Wt & 65535, Qt += Wt >>> 16, rr += Gt & 65535, Ir += Gt >>> 16, Qt += vr >>> 16, rr += Qt >>> 16, Ir += rr >>> 16, qe[7] = UX = rr & 65535 | Ir << 16, Qe[7] = HX = vr & 65535 | Qt << 16, KX += 128, Ie -= 128;
      }
      return Ie;
    }
    function Ct(qe, Qe, Ve) {
      var Ie = new Int32Array(8), nt = new Int32Array(8), Et = new Uint8Array(256), xt, Jt = Ve;
      for (Ie[0] = 1779033703, Ie[1] = 3144134277, Ie[2] = 1013904242, Ie[3] = 2773480762, Ie[4] = 1359893119, Ie[5] = 2600822924, Ie[6] = 528734635, Ie[7] = 1541459225, nt[0] = 4089235720, nt[1] = 2227873595, nt[2] = 4271175723, nt[3] = 1595750129, nt[4] = 2917565137, nt[5] = 725511199, nt[6] = 4215389547, nt[7] = 327033209, wX(Ie, nt, Qe, Ve), Ve %= 128, xt = 0; xt < Ve; xt++)
        Et[xt] = Qe[Jt - Ve + xt];
      for (Et[Ve] = 128, Ve = 256 - 128 * (Ve < 112 ? 1 : 0), Et[Ve - 9] = 0, we(Et, Ve - 8, Jt / 536870912 | 0, Jt << 3), wX(Ie, nt, Et, Ve), xt = 0; xt < 8; xt++)
        we(qe, 8 * xt, Ie[xt], nt[xt]);
      return 0;
    }
    function w_(qe, Qe) {
      var Ve = ee(), Ie = ee(), nt = ee(), Et = ee(), xt = ee(), Jt = ee(), Yt = ee(), _r = ee(), cn = ee();
      Xe(Ve, qe[1], qe[0]), Xe(cn, Qe[1], Qe[0]), $e(Ve, Ve, cn), Ge(Ie, qe[0], qe[1]), Ge(cn, Qe[0], Qe[1]), $e(Ie, Ie, cn), $e(nt, qe[3], Qe[3]), $e(nt, nt, le), $e(Et, qe[2], Qe[2]), Ge(Et, Et, Et), Xe(xt, Ie, Ve), Xe(Jt, Et, nt), Ge(Yt, Et, nt), Ge(_r, Ie, Ve), $e(qe[0], xt, Jt), $e(qe[1], _r, Yt), $e(qe[2], Yt, Jt), $e(qe[3], xt, _r);
    }
    function hX(qe, Qe, Ve) {
      var Ie;
      for (Ie = 0; Ie < 4; Ie++)
        Pe(qe[Ie], Qe[Ie], Ve);
    }
    function oX(qe, Qe) {
      var Ve = ee(), Ie = ee(), nt = ee();
      ot(nt, Qe[2]), $e(Ve, Qe[0], nt), $e(Ie, Qe[1], nt), Se(qe, Ie), qe[31] ^= ge(Ve) << 7;
    }
    function Nn(qe, Qe, Ve) {
      var Ie, nt;
      for (Te(qe[0], oe), Te(qe[1], se), Te(qe[2], se), Te(qe[3], oe), nt = 255; nt >= 0; --nt)
        Ie = Ve[nt / 8 | 0] >> (nt & 7) & 1, hX(qe, Qe, Ie), w_(Qe, qe), w_(qe, qe), hX(qe, Qe, Ie);
    }
    function SX(qe, Qe) {
      var Ve = [ee(), ee(), ee(), ee()];
      Te(Ve[0], he), Te(Ve[1], me), Te(Ve[2], se), $e(Ve[3], he, me), Nn(qe, Ve, Qe);
    }
    function sX(qe, Qe, Ve) {
      var Ie = new Uint8Array(64), nt = [ee(), ee(), ee(), ee()], Et;
      for (Ve || te(Qe, 32), Ct(Ie, Qe, 32), Ie[0] &= 248, Ie[31] &= 127, Ie[31] |= 64, SX(nt, Ie), oX(qe, nt), Et = 0; Et < 32; Et++)
        Qe[Et + 32] = qe[Et];
      return 0;
    }
    var nX = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
    function Ye(qe, Qe) {
      var Ve, Ie, nt, Et;
      for (Ie = 63; Ie >= 32; --Ie) {
        for (Ve = 0, nt = Ie - 32, Et = Ie - 12; nt < Et; ++nt)
          Qe[nt] += Ve - 16 * Qe[Ie] * nX[nt - (Ie - 32)], Ve = Math.floor((Qe[nt] + 128) / 256), Qe[nt] -= Ve * 256;
        Qe[nt] += Ve, Qe[Ie] = 0;
      }
      for (Ve = 0, nt = 0; nt < 32; nt++)
        Qe[nt] += Ve - (Qe[31] >> 4) * nX[nt], Ve = Qe[nt] >> 8, Qe[nt] &= 255;
      for (nt = 0; nt < 32; nt++)
        Qe[nt] -= Ve * nX[nt];
      for (Ie = 0; Ie < 32; Ie++)
        Qe[Ie + 1] += Qe[Ie] >> 8, qe[Ie] = Qe[Ie] & 255;
    }
    function lt(qe) {
      var Qe = new Float64Array(64), Ve;
      for (Ve = 0; Ve < 64; Ve++)
        Qe[Ve] = qe[Ve];
      for (Ve = 0; Ve < 64; Ve++)
        qe[Ve] = 0;
      Ye(qe, Qe);
    }
    function pt(qe, Qe, Ve, Ie) {
      var nt = new Uint8Array(64), Et = new Uint8Array(64), xt = new Uint8Array(64), Jt, Yt, _r = new Float64Array(64), cn = [ee(), ee(), ee(), ee()];
      Ct(nt, Ie, 32), nt[0] &= 248, nt[31] &= 127, nt[31] |= 64;
      var _X = Ve + 64;
      for (Jt = 0; Jt < Ve; Jt++)
        qe[64 + Jt] = Qe[Jt];
      for (Jt = 0; Jt < 32; Jt++)
        qe[32 + Jt] = nt[32 + Jt];
      for (Ct(xt, qe.subarray(32), Ve + 32), lt(xt), SX(cn, xt), oX(qe, cn), Jt = 32; Jt < 64; Jt++)
        qe[Jt] = Ie[Jt];
      for (Ct(Et, qe, Ve + 64), lt(Et), Jt = 0; Jt < 64; Jt++)
        _r[Jt] = 0;
      for (Jt = 0; Jt < 32; Jt++)
        _r[Jt] = xt[Jt];
      for (Jt = 0; Jt < 32; Jt++)
        for (Yt = 0; Yt < 32; Yt++)
          _r[Jt + Yt] += Et[Jt] * nt[Yt];
      return Ye(qe.subarray(32), _r), _X;
    }
    function He(qe, Qe) {
      var Ve = ee(), Ie = ee(), nt = ee(), Et = ee(), xt = ee(), Jt = ee(), Yt = ee();
      return Te(qe[2], se), Ae(qe[1], Qe), Ze(nt, qe[1]), $e(Et, nt, ue), Xe(nt, nt, qe[2]), Ge(Et, qe[2], Et), Ze(xt, Et), Ze(Jt, xt), $e(Yt, Jt, xt), $e(Ve, Yt, nt), $e(Ve, Ve, Et), ct(Ve, Ve), $e(Ve, Ve, nt), $e(Ve, Ve, Et), $e(Ve, Ve, Et), $e(qe[0], Ve, Et), Ze(Ie, qe[0]), $e(Ie, Ie, Et), ke(Ie, nt) && $e(qe[0], qe[0], ye), Ze(Ie, qe[0]), $e(Ie, Ie, Et), ke(Ie, nt) ? -1 : (ge(qe[0]) === Qe[31] >> 7 && Xe(qe[0], oe, qe[0]), $e(qe[3], qe[0], qe[1]), 0);
    }
    function Je(qe, Qe, Ve, Ie) {
      var nt, Et = new Uint8Array(32), xt = new Uint8Array(64), Jt = [ee(), ee(), ee(), ee()], Yt = [ee(), ee(), ee(), ee()];
      if (Ve < 64 || He(Yt, Ie))
        return -1;
      for (nt = 0; nt < Ve; nt++)
        qe[nt] = Qe[nt];
      for (nt = 0; nt < 32; nt++)
        qe[nt + 32] = Ie[nt];
      if (Ct(xt, qe, Ve), lt(xt), Nn(Jt, Yt, xt), SX(Yt, Qe.subarray(32)), w_(Jt, Yt), oX(Et, Jt), Ve -= 64, Ue(Qe, 0, Et, 0)) {
        for (nt = 0; nt < Ve; nt++)
          qe[nt] = 0;
        return -1;
      }
      for (nt = 0; nt < Ve; nt++)
        qe[nt] = Qe[nt + 64];
      return Ve;
    }
    var st = 32, gt = 24, kt = 32, Vt = 16, Lr = 32, Ci = 32, Qr = 32, xX = 32, lX = 32, rX = gt, FX = kt, BX = Vt, cX = 64, MX = 32, EX = 64, yX = 32, jX = 64;
    X.lowlevel = {
      crypto_core_hsalsa20: Ke,
      crypto_stream_xor: Dt,
      crypto_stream: _t,
      crypto_stream_salsa20_xor: rt,
      crypto_stream_salsa20: it,
      crypto_onetimeauth: ze,
      crypto_onetimeauth_verify: fe,
      crypto_verify_16: Re,
      crypto_verify_32: Ue,
      crypto_secretbox: de,
      crypto_secretbox_open: be,
      crypto_scalarmult: At,
      crypto_scalarmult_base: Tt,
      crypto_box_beforenm: vt,
      crypto_box_afternm: Ut,
      crypto_box: Er,
      crypto_box_open: Fr,
      crypto_box_keypair: dt,
      crypto_hash: Ct,
      crypto_sign: pt,
      crypto_sign_keypair: sX,
      crypto_sign_open: Je,
      crypto_secretbox_KEYBYTES: st,
      crypto_secretbox_NONCEBYTES: gt,
      crypto_secretbox_ZEROBYTES: kt,
      crypto_secretbox_BOXZEROBYTES: Vt,
      crypto_scalarmult_BYTES: Lr,
      crypto_scalarmult_SCALARBYTES: Ci,
      crypto_box_PUBLICKEYBYTES: Qr,
      crypto_box_SECRETKEYBYTES: xX,
      crypto_box_BEFORENMBYTES: lX,
      crypto_box_NONCEBYTES: rX,
      crypto_box_ZEROBYTES: FX,
      crypto_box_BOXZEROBYTES: BX,
      crypto_sign_BYTES: cX,
      crypto_sign_PUBLICKEYBYTES: MX,
      crypto_sign_SECRETKEYBYTES: EX,
      crypto_sign_SEEDBYTES: yX,
      crypto_hash_BYTES: jX,
      gf: ee,
      D: ue,
      L: nX,
      pack25519: Se,
      unpack25519: Ae,
      M: $e,
      A: Ge,
      S: Ze,
      Z: Xe,
      pow2523: ct,
      add: w_,
      set25519: Te,
      modL: Ye,
      scalarmult: Nn,
      scalarbase: SX
    };
    function AX(qe, Qe) {
      if (qe.length !== st)
        throw new Error("bad key size");
      if (Qe.length !== gt)
        throw new Error("bad nonce size");
    }
    function vX(qe, Qe) {
      if (qe.length !== Qr)
        throw new Error("bad public key size");
      if (Qe.length !== xX)
        throw new Error("bad secret key size");
    }
    function PX() {
      for (var qe = 0; qe < arguments.length; qe++)
        if (!(arguments[qe] instanceof Uint8Array))
          throw new TypeError("unexpected type, use Uint8Array");
    }
    function kX(qe) {
      for (var Qe = 0; Qe < qe.length; Qe++)
        qe[Qe] = 0;
    }
    X.randomBytes = function(qe) {
      var Qe = new Uint8Array(qe);
      return te(Qe, qe), Qe;
    }, X.secretbox = function(qe, Qe, Ve) {
      PX(qe, Qe, Ve), AX(Ve, Qe);
      for (var Ie = new Uint8Array(kt + qe.length), nt = new Uint8Array(Ie.length), Et = 0; Et < qe.length; Et++)
        Ie[Et + kt] = qe[Et];
      return de(nt, Ie, Ie.length, Qe, Ve), nt.subarray(Vt);
    }, X.secretbox.open = function(qe, Qe, Ve) {
      PX(qe, Qe, Ve), AX(Ve, Qe);
      for (var Ie = new Uint8Array(Vt + qe.length), nt = new Uint8Array(Ie.length), Et = 0; Et < qe.length; Et++)
        Ie[Et + Vt] = qe[Et];
      return Ie.length < 32 || be(nt, Ie, Ie.length, Qe, Ve) !== 0 ? null : nt.subarray(kt);
    }, X.secretbox.keyLength = st, X.secretbox.nonceLength = gt, X.secretbox.overheadLength = Vt, X.scalarMult = function(qe, Qe) {
      if (PX(qe, Qe), qe.length !== Ci)
        throw new Error("bad n size");
      if (Qe.length !== Lr)
        throw new Error("bad p size");
      var Ve = new Uint8Array(Lr);
      return At(Ve, qe, Qe), Ve;
    }, X.scalarMult.base = function(qe) {
      if (PX(qe), qe.length !== Ci)
        throw new Error("bad n size");
      var Qe = new Uint8Array(Lr);
      return Tt(Qe, qe), Qe;
    }, X.scalarMult.scalarLength = Ci, X.scalarMult.groupElementLength = Lr, X.box = function(qe, Qe, Ve, Ie) {
      var nt = X.box.before(Ve, Ie);
      return X.secretbox(qe, Qe, nt);
    }, X.box.before = function(qe, Qe) {
      PX(qe, Qe), vX(qe, Qe);
      var Ve = new Uint8Array(lX);
      return vt(Ve, qe, Qe), Ve;
    }, X.box.after = X.secretbox, X.box.open = function(qe, Qe, Ve, Ie) {
      var nt = X.box.before(Ve, Ie);
      return X.secretbox.open(qe, Qe, nt);
    }, X.box.open.after = X.secretbox.open, X.box.keyPair = function() {
      var qe = new Uint8Array(Qr), Qe = new Uint8Array(xX);
      return dt(qe, Qe), { publicKey: qe, secretKey: Qe };
    }, X.box.keyPair.fromSecretKey = function(qe) {
      if (PX(qe), qe.length !== xX)
        throw new Error("bad secret key size");
      var Qe = new Uint8Array(Qr);
      return Tt(Qe, qe), { publicKey: Qe, secretKey: new Uint8Array(qe) };
    }, X.box.publicKeyLength = Qr, X.box.secretKeyLength = xX, X.box.sharedKeyLength = lX, X.box.nonceLength = rX, X.box.overheadLength = X.secretbox.overheadLength, X.sign = function(qe, Qe) {
      if (PX(qe, Qe), Qe.length !== EX)
        throw new Error("bad secret key size");
      var Ve = new Uint8Array(cX + qe.length);
      return pt(Ve, qe, qe.length, Qe), Ve;
    }, X.sign.open = function(qe, Qe) {
      if (PX(qe, Qe), Qe.length !== MX)
        throw new Error("bad public key size");
      var Ve = new Uint8Array(qe.length), Ie = Je(Ve, qe, qe.length, Qe);
      if (Ie < 0)
        return null;
      for (var nt = new Uint8Array(Ie), Et = 0; Et < nt.length; Et++)
        nt[Et] = Ve[Et];
      return nt;
    }, X.sign.detached = function(qe, Qe) {
      for (var Ve = X.sign(qe, Qe), Ie = new Uint8Array(cX), nt = 0; nt < Ie.length; nt++)
        Ie[nt] = Ve[nt];
      return Ie;
    }, X.sign.detached.verify = function(qe, Qe, Ve) {
      if (PX(qe, Qe, Ve), Qe.length !== cX)
        throw new Error("bad signature size");
      if (Ve.length !== MX)
        throw new Error("bad public key size");
      var Ie = new Uint8Array(cX + qe.length), nt = new Uint8Array(cX + qe.length), Et;
      for (Et = 0; Et < cX; Et++)
        Ie[Et] = Qe[Et];
      for (Et = 0; Et < qe.length; Et++)
        Ie[Et + cX] = qe[Et];
      return Je(nt, Ie, Ie.length, Ve) >= 0;
    }, X.sign.keyPair = function() {
      var qe = new Uint8Array(MX), Qe = new Uint8Array(EX);
      return sX(qe, Qe), { publicKey: qe, secretKey: Qe };
    }, X.sign.keyPair.fromSecretKey = function(qe) {
      if (PX(qe), qe.length !== EX)
        throw new Error("bad secret key size");
      for (var Qe = new Uint8Array(MX), Ve = 0; Ve < Qe.length; Ve++)
        Qe[Ve] = qe[32 + Ve];
      return { publicKey: Qe, secretKey: new Uint8Array(qe) };
    }, X.sign.keyPair.fromSeed = function(qe) {
      if (PX(qe), qe.length !== yX)
        throw new Error("bad seed size");
      for (var Qe = new Uint8Array(MX), Ve = new Uint8Array(EX), Ie = 0; Ie < 32; Ie++)
        Ve[Ie] = qe[Ie];
      return sX(Qe, Ve, !0), { publicKey: Qe, secretKey: Ve };
    }, X.sign.publicKeyLength = MX, X.sign.secretKeyLength = EX, X.sign.seedLength = yX, X.sign.signatureLength = cX, X.hash = function(qe) {
      PX(qe);
      var Qe = new Uint8Array(jX);
      return Ct(Qe, qe, qe.length), Qe;
    }, X.hash.hashLength = jX, X.verify = function(qe, Qe) {
      return PX(qe, Qe), qe.length === 0 || Qe.length === 0 || qe.length !== Qe.length ? !1 : Ee(qe, 0, Qe, 0, qe.length) === 0;
    }, X.setPRNG = function(qe) {
      te = qe;
    }, function() {
      var qe = typeof self < "u" ? self.crypto || self.msCrypto : null;
      if (qe && qe.getRandomValues) {
        var Qe = 65536;
        X.setPRNG(function(Ve, Ie) {
          var nt, Et = new Uint8Array(Ie);
          for (nt = 0; nt < Ie; nt += Qe)
            qe.getRandomValues(Et.subarray(nt, nt + Math.min(Ie - nt, Qe)));
          for (nt = 0; nt < Ie; nt++)
            Ve[nt] = Et[nt];
          kX(Et);
        });
      } else
        typeof commonjsRequire < "u" && (qe = requireCryptoBrowserify(), qe && qe.randomBytes && X.setPRNG(function(Ve, Ie) {
          var nt, Et = qe.randomBytes(Ie);
          for (nt = 0; nt < Ie; nt++)
            Ve[nt] = Et[nt];
          kX(Et);
        }));
    }();
  })(Y.exports ? Y.exports : self.nacl = self.nacl || {});
})(naclFast);
var naclFastExports = naclFast.exports;
const nacl = /* @__PURE__ */ getDefaultExportFromCjs$2(naclFastExports);
var utils$2 = {};
Object.defineProperty(utils$2, "__esModule", { value: !0 });
utils$2.replaceDerive = utils$2.pathRegex = void 0;
utils$2.pathRegex = new RegExp("^m(\\/[0-9]+')+$");
utils$2.replaceDerive = (Y) => Y.replace("'", "");
(function(Y) {
  Object.defineProperty(Y, "__esModule", { value: !0 }), Y.derivePath = Y.isValidPath = Y.getPublicKey = Y.CKDPriv = Y.getMasterKeyFromSeed = void 0;
  const X = browser$c, ee = naclFastExports, te = utils$2, ne = "ed25519 seed", ie = 2147483648;
  Y.getMasterKeyFromSeed = (oe) => {
    const se = X("sha512", ne).update(Buffer$e.from(oe, "hex")).digest(), ae = se.slice(0, 32), ue = se.slice(32);
    return {
      key: ae,
      chainCode: ue
    };
  }, Y.CKDPriv = ({ key: oe, chainCode: se }, ae) => {
    const ue = Buffer$e.allocUnsafe(4);
    ue.writeUInt32BE(ae, 0);
    const le = Buffer$e.concat([Buffer$e.alloc(1, 0), oe, ue]), he = X("sha512", se).update(le).digest(), me = he.slice(0, 32), ye = he.slice(32);
    return {
      key: me,
      chainCode: ye
    };
  }, Y.getPublicKey = (oe, se = !0) => {
    const ae = ee.sign.keyPair.fromSeed(oe).secretKey.subarray(32), ue = Buffer$e.alloc(1, 0);
    return se ? Buffer$e.concat([ue, Buffer$e.from(ae)]) : Buffer$e.from(ae);
  }, Y.isValidPath = (oe) => te.pathRegex.test(oe) ? !oe.split("/").slice(1).map(te.replaceDerive).some(isNaN) : !1, Y.derivePath = (oe, se, ae = ie) => {
    if (!Y.isValidPath(oe))
      throw new Error("Invalid derivation path");
    const { key: ue, chainCode: le } = Y.getMasterKeyFromSeed(se);
    return oe.split("/").slice(1).map(te.replaceDerive).map((he) => parseInt(he, 10)).reduce((he, me) => Y.CKDPriv(he, me + ae), { key: ue, chainCode: le });
  };
})(dist);
var src$2 = {}, sha256$1 = {}, _sha2 = {}, _assert = {};
Object.defineProperty(_assert, "__esModule", { value: !0 });
_assert.output = _assert.exists = _assert.hash = _assert.bytes = _assert.bool = _assert.number = void 0;
function number$2(Y) {
  if (!Number.isSafeInteger(Y) || Y < 0)
    throw new Error(`Wrong positive integer: ${Y}`);
}
_assert.number = number$2;
function bool$1(Y) {
  if (typeof Y != "boolean")
    throw new Error(`Expected boolean, not ${Y}`);
}
_assert.bool = bool$1;
function isBytes$3(Y) {
  return Y instanceof Uint8Array || Y != null && typeof Y == "object" && Y.constructor.name === "Uint8Array";
}
function bytes$1(Y, ...X) {
  if (!isBytes$3(Y))
    throw new Error("Expected Uint8Array");
  if (X.length > 0 && !X.includes(Y.length))
    throw new Error(`Expected Uint8Array of length ${X}, not of length=${Y.length}`);
}
_assert.bytes = bytes$1;
function hash$1(Y) {
  if (typeof Y != "function" || typeof Y.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number$2(Y.outputLen), number$2(Y.blockLen);
}
_assert.hash = hash$1;
function exists$1(Y, X = !0) {
  if (Y.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (X && Y.finished)
    throw new Error("Hash#digest() has already been called");
}
_assert.exists = exists$1;
function output$1(Y, X) {
  bytes$1(Y);
  const ee = X.outputLen;
  if (Y.length < ee)
    throw new Error(`digestInto() expects output buffer of length at least ${ee}`);
}
_assert.output = output$1;
const assert$2 = { number: number$2, bool: bool$1, bytes: bytes$1, hash: hash$1, exists: exists$1, output: output$1 };
_assert.default = assert$2;
var utils$1 = {}, crypto$1 = {};
Object.defineProperty(crypto$1, "__esModule", { value: !0 });
var crypto_1 = crypto$1.crypto = void 0;
crypto_1 = crypto$1.crypto = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
(function(Y) {
  /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  Object.defineProperty(Y, "__esModule", { value: !0 }), Y.randomBytes = Y.wrapXOFConstructorWithOpts = Y.wrapConstructorWithOpts = Y.wrapConstructor = Y.checkOpts = Y.Hash = Y.concatBytes = Y.toBytes = Y.utf8ToBytes = Y.asyncLoop = Y.nextTick = Y.hexToBytes = Y.bytesToHex = Y.isLE = Y.rotr = Y.createView = Y.u32 = Y.u8 = void 0;
  const X = crypto$1, ee = (it) => new Uint8Array(it.buffer, it.byteOffset, it.byteLength);
  Y.u8 = ee;
  const te = (it) => new Uint32Array(it.buffer, it.byteOffset, Math.floor(it.byteLength / 4));
  Y.u32 = te;
  function ne(it) {
    return it instanceof Uint8Array || it != null && typeof it == "object" && it.constructor.name === "Uint8Array";
  }
  const ie = (it) => new DataView(it.buffer, it.byteOffset, it.byteLength);
  Y.createView = ie;
  const oe = (it, _t) => it << 32 - _t | it >>> _t;
  if (Y.rotr = oe, Y.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68, !Y.isLE)
    throw new Error("Non little-endian hardware is not supported");
  const se = /* @__PURE__ */ Array.from({ length: 256 }, (it, _t) => _t.toString(16).padStart(2, "0"));
  function ae(it) {
    if (!ne(it))
      throw new Error("Uint8Array expected");
    let _t = "";
    for (let Dt = 0; Dt < it.length; Dt++)
      _t += se[it[Dt]];
    return _t;
  }
  Y.bytesToHex = ae;
  const ue = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
  function le(it) {
    if (it >= ue._0 && it <= ue._9)
      return it - ue._0;
    if (it >= ue._A && it <= ue._F)
      return it - (ue._A - 10);
    if (it >= ue._a && it <= ue._f)
      return it - (ue._a - 10);
  }
  function he(it) {
    if (typeof it != "string")
      throw new Error("hex string expected, got " + typeof it);
    const _t = it.length, Dt = _t / 2;
    if (_t % 2)
      throw new Error("padded hex string expected, got unpadded hex of length " + _t);
    const je = new Uint8Array(Dt);
    for (let ze = 0, fe = 0; ze < Dt; ze++, fe += 2) {
      const de = le(it.charCodeAt(fe)), be = le(it.charCodeAt(fe + 1));
      if (de === void 0 || be === void 0) {
        const Te = it[fe] + it[fe + 1];
        throw new Error('hex string expected, got non-hex character "' + Te + '" at index ' + fe);
      }
      je[ze] = de * 16 + be;
    }
    return je;
  }
  Y.hexToBytes = he;
  const me = async () => {
  };
  Y.nextTick = me;
  async function ye(it, _t, Dt) {
    let je = Date.now();
    for (let ze = 0; ze < it; ze++) {
      Dt(ze);
      const fe = Date.now() - je;
      fe >= 0 && fe < _t || (await (0, Y.nextTick)(), je += fe);
    }
  }
  Y.asyncLoop = ye;
  function we(it) {
    if (typeof it != "string")
      throw new Error(`utf8ToBytes expected string, got ${typeof it}`);
    return new Uint8Array(new TextEncoder().encode(it));
  }
  Y.utf8ToBytes = we;
  function Ee(it) {
    if (typeof it == "string" && (it = we(it)), !ne(it))
      throw new Error(`expected Uint8Array, got ${typeof it}`);
    return it;
  }
  Y.toBytes = Ee;
  function Re(...it) {
    let _t = 0;
    for (let je = 0; je < it.length; je++) {
      const ze = it[je];
      if (!ne(ze))
        throw new Error("Uint8Array expected");
      _t += ze.length;
    }
    const Dt = new Uint8Array(_t);
    for (let je = 0, ze = 0; je < it.length; je++) {
      const fe = it[je];
      Dt.set(fe, ze), ze += fe.length;
    }
    return Dt;
  }
  Y.concatBytes = Re;
  class Ue {
    // Safe version that clones internal state
    clone() {
      return this._cloneInto();
    }
  }
  Y.Hash = Ue;
  const Me = {}.toString;
  function De(it, _t) {
    if (_t !== void 0 && Me.call(_t) !== "[object Object]")
      throw new Error("Options should be object or undefined");
    return Object.assign(it, _t);
  }
  Y.checkOpts = De;
  function Fe(it) {
    const _t = (je) => it().update(Ee(je)).digest(), Dt = it();
    return _t.outputLen = Dt.outputLen, _t.blockLen = Dt.blockLen, _t.create = () => it(), _t;
  }
  Y.wrapConstructor = Fe;
  function Ke(it) {
    const _t = (je, ze) => it(ze).update(Ee(je)).digest(), Dt = it({});
    return _t.outputLen = Dt.outputLen, _t.blockLen = Dt.blockLen, _t.create = (je) => it(je), _t;
  }
  Y.wrapConstructorWithOpts = Ke;
  function tt(it) {
    const _t = (je, ze) => it(ze).update(Ee(je)).digest(), Dt = it({});
    return _t.outputLen = Dt.outputLen, _t.blockLen = Dt.blockLen, _t.create = (je) => it(je), _t;
  }
  Y.wrapXOFConstructorWithOpts = tt;
  function rt(it = 32) {
    if (X.crypto && typeof X.crypto.getRandomValues == "function")
      return X.crypto.getRandomValues(new Uint8Array(it));
    throw new Error("crypto.getRandomValues must be defined");
  }
  Y.randomBytes = rt;
})(utils$1);
Object.defineProperty(_sha2, "__esModule", { value: !0 });
_sha2.SHA2 = void 0;
const _assert_js_1$1 = _assert, utils_js_1$3 = utils$1;
function setBigUint64$1(Y, X, ee, te) {
  if (typeof Y.setBigUint64 == "function")
    return Y.setBigUint64(X, ee, te);
  const ne = BigInt(32), ie = BigInt(4294967295), oe = Number(ee >> ne & ie), se = Number(ee & ie), ae = te ? 4 : 0, ue = te ? 0 : 4;
  Y.setUint32(X + ae, oe, te), Y.setUint32(X + ue, se, te);
}
let SHA2$1 = class extends utils_js_1$3.Hash {
  constructor(Y, X, ee, te) {
    super(), this.blockLen = Y, this.outputLen = X, this.padOffset = ee, this.isLE = te, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(Y), this.view = (0, utils_js_1$3.createView)(this.buffer);
  }
  update(Y) {
    (0, _assert_js_1$1.exists)(this);
    const { view: X, buffer: ee, blockLen: te } = this;
    Y = (0, utils_js_1$3.toBytes)(Y);
    const ne = Y.length;
    for (let ie = 0; ie < ne; ) {
      const oe = Math.min(te - this.pos, ne - ie);
      if (oe === te) {
        const se = (0, utils_js_1$3.createView)(Y);
        for (; te <= ne - ie; ie += te)
          this.process(se, ie);
        continue;
      }
      ee.set(Y.subarray(ie, ie + oe), this.pos), this.pos += oe, ie += oe, this.pos === te && (this.process(X, 0), this.pos = 0);
    }
    return this.length += Y.length, this.roundClean(), this;
  }
  digestInto(Y) {
    (0, _assert_js_1$1.exists)(this), (0, _assert_js_1$1.output)(Y, this), this.finished = !0;
    const { buffer: X, view: ee, blockLen: te, isLE: ne } = this;
    let { pos: ie } = this;
    X[ie++] = 128, this.buffer.subarray(ie).fill(0), this.padOffset > te - ie && (this.process(ee, 0), ie = 0);
    for (let le = ie; le < te; le++)
      X[le] = 0;
    setBigUint64$1(ee, te - 8, BigInt(this.length * 8), ne), this.process(ee, 0);
    const oe = (0, utils_js_1$3.createView)(Y), se = this.outputLen;
    if (se % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const ae = se / 4, ue = this.get();
    if (ae > ue.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let le = 0; le < ae; le++)
      oe.setUint32(4 * le, ue[le], ne);
  }
  digest() {
    const { buffer: Y, outputLen: X } = this;
    this.digestInto(Y);
    const ee = Y.slice(0, X);
    return this.destroy(), ee;
  }
  _cloneInto(Y) {
    Y || (Y = new this.constructor()), Y.set(...this.get());
    const { blockLen: X, buffer: ee, length: te, finished: ne, destroyed: ie, pos: oe } = this;
    return Y.length = te, Y.pos = oe, Y.finished = ne, Y.destroyed = ie, te % X && Y.buffer.set(ee), Y;
  }
};
_sha2.SHA2 = SHA2$1;
Object.defineProperty(sha256$1, "__esModule", { value: !0 });
sha256$1.sha224 = sha256$1.sha256 = void 0;
const _sha2_js_1$1 = _sha2, utils_js_1$2 = utils$1, Chi$1 = (Y, X, ee) => Y & X ^ ~Y & ee, Maj$1 = (Y, X, ee) => Y & X ^ Y & ee ^ X & ee, SHA256_K$1 = /* @__PURE__ */ new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), IV$1 = /* @__PURE__ */ new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), SHA256_W$1 = /* @__PURE__ */ new Uint32Array(64);
let SHA256$1 = class extends _sha2_js_1$1.SHA2 {
  constructor() {
    super(64, 32, 8, !1), this.A = IV$1[0] | 0, this.B = IV$1[1] | 0, this.C = IV$1[2] | 0, this.D = IV$1[3] | 0, this.E = IV$1[4] | 0, this.F = IV$1[5] | 0, this.G = IV$1[6] | 0, this.H = IV$1[7] | 0;
  }
  get() {
    const { A: Y, B: X, C: ee, D: te, E: ne, F: ie, G: oe, H: se } = this;
    return [Y, X, ee, te, ne, ie, oe, se];
  }
  // prettier-ignore
  set(Y, X, ee, te, ne, ie, oe, se) {
    this.A = Y | 0, this.B = X | 0, this.C = ee | 0, this.D = te | 0, this.E = ne | 0, this.F = ie | 0, this.G = oe | 0, this.H = se | 0;
  }
  process(Y, X) {
    for (let le = 0; le < 16; le++, X += 4)
      SHA256_W$1[le] = Y.getUint32(X, !1);
    for (let le = 16; le < 64; le++) {
      const he = SHA256_W$1[le - 15], me = SHA256_W$1[le - 2], ye = (0, utils_js_1$2.rotr)(he, 7) ^ (0, utils_js_1$2.rotr)(he, 18) ^ he >>> 3, we = (0, utils_js_1$2.rotr)(me, 17) ^ (0, utils_js_1$2.rotr)(me, 19) ^ me >>> 10;
      SHA256_W$1[le] = we + SHA256_W$1[le - 7] + ye + SHA256_W$1[le - 16] | 0;
    }
    let { A: ee, B: te, C: ne, D: ie, E: oe, F: se, G: ae, H: ue } = this;
    for (let le = 0; le < 64; le++) {
      const he = (0, utils_js_1$2.rotr)(oe, 6) ^ (0, utils_js_1$2.rotr)(oe, 11) ^ (0, utils_js_1$2.rotr)(oe, 25), me = ue + he + Chi$1(oe, se, ae) + SHA256_K$1[le] + SHA256_W$1[le] | 0, ye = ((0, utils_js_1$2.rotr)(ee, 2) ^ (0, utils_js_1$2.rotr)(ee, 13) ^ (0, utils_js_1$2.rotr)(ee, 22)) + Maj$1(ee, te, ne) | 0;
      ue = ae, ae = se, se = oe, oe = ie + me | 0, ie = ne, ne = te, te = ee, ee = me + ye | 0;
    }
    ee = ee + this.A | 0, te = te + this.B | 0, ne = ne + this.C | 0, ie = ie + this.D | 0, oe = oe + this.E | 0, se = se + this.F | 0, ae = ae + this.G | 0, ue = ue + this.H | 0, this.set(ee, te, ne, ie, oe, se, ae, ue);
  }
  roundClean() {
    SHA256_W$1.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
};
class SHA224 extends SHA256$1 {
  constructor() {
    super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28;
  }
}
sha256$1.sha256 = (0, utils_js_1$2.wrapConstructor)(() => new SHA256$1());
sha256$1.sha224 = (0, utils_js_1$2.wrapConstructor)(() => new SHA224());
var sha512$1 = {}, _u64 = {};
Object.defineProperty(_u64, "__esModule", { value: !0 });
_u64.add5L = _u64.add5H = _u64.add4H = _u64.add4L = _u64.add3H = _u64.add3L = _u64.add = _u64.rotlBL = _u64.rotlBH = _u64.rotlSL = _u64.rotlSH = _u64.rotr32L = _u64.rotr32H = _u64.rotrBL = _u64.rotrBH = _u64.rotrSL = _u64.rotrSH = _u64.shrSL = _u64.shrSH = _u64.toBig = _u64.split = _u64.fromBig = void 0;
const U32_MASK64$1 = /* @__PURE__ */ BigInt(2 ** 32 - 1), _32n$1 = /* @__PURE__ */ BigInt(32);
function fromBig$1(Y, X = !1) {
  return X ? { h: Number(Y & U32_MASK64$1), l: Number(Y >> _32n$1 & U32_MASK64$1) } : { h: Number(Y >> _32n$1 & U32_MASK64$1) | 0, l: Number(Y & U32_MASK64$1) | 0 };
}
_u64.fromBig = fromBig$1;
function split$1(Y, X = !1) {
  let ee = new Uint32Array(Y.length), te = new Uint32Array(Y.length);
  for (let ne = 0; ne < Y.length; ne++) {
    const { h: ie, l: oe } = fromBig$1(Y[ne], X);
    [ee[ne], te[ne]] = [ie, oe];
  }
  return [ee, te];
}
_u64.split = split$1;
const toBig$1 = (Y, X) => BigInt(Y >>> 0) << _32n$1 | BigInt(X >>> 0);
_u64.toBig = toBig$1;
const shrSH$1 = (Y, X, ee) => Y >>> ee;
_u64.shrSH = shrSH$1;
const shrSL$1 = (Y, X, ee) => Y << 32 - ee | X >>> ee;
_u64.shrSL = shrSL$1;
const rotrSH$1 = (Y, X, ee) => Y >>> ee | X << 32 - ee;
_u64.rotrSH = rotrSH$1;
const rotrSL$1 = (Y, X, ee) => Y << 32 - ee | X >>> ee;
_u64.rotrSL = rotrSL$1;
const rotrBH$1 = (Y, X, ee) => Y << 64 - ee | X >>> ee - 32;
_u64.rotrBH = rotrBH$1;
const rotrBL$1 = (Y, X, ee) => Y >>> ee - 32 | X << 64 - ee;
_u64.rotrBL = rotrBL$1;
const rotr32H$1 = (Y, X) => X;
_u64.rotr32H = rotr32H$1;
const rotr32L$1 = (Y, X) => Y;
_u64.rotr32L = rotr32L$1;
const rotlSH$1 = (Y, X, ee) => Y << ee | X >>> 32 - ee;
_u64.rotlSH = rotlSH$1;
const rotlSL$1 = (Y, X, ee) => X << ee | Y >>> 32 - ee;
_u64.rotlSL = rotlSL$1;
const rotlBH$1 = (Y, X, ee) => X << ee - 32 | Y >>> 64 - ee;
_u64.rotlBH = rotlBH$1;
const rotlBL$1 = (Y, X, ee) => Y << ee - 32 | X >>> 64 - ee;
_u64.rotlBL = rotlBL$1;
function add$1(Y, X, ee, te) {
  const ne = (X >>> 0) + (te >>> 0);
  return { h: Y + ee + (ne / 2 ** 32 | 0) | 0, l: ne | 0 };
}
_u64.add = add$1;
const add3L$1 = (Y, X, ee) => (Y >>> 0) + (X >>> 0) + (ee >>> 0);
_u64.add3L = add3L$1;
const add3H$1 = (Y, X, ee, te) => X + ee + te + (Y / 2 ** 32 | 0) | 0;
_u64.add3H = add3H$1;
const add4L$1 = (Y, X, ee, te) => (Y >>> 0) + (X >>> 0) + (ee >>> 0) + (te >>> 0);
_u64.add4L = add4L$1;
const add4H$1 = (Y, X, ee, te, ne) => X + ee + te + ne + (Y / 2 ** 32 | 0) | 0;
_u64.add4H = add4H$1;
const add5L$1 = (Y, X, ee, te, ne) => (Y >>> 0) + (X >>> 0) + (ee >>> 0) + (te >>> 0) + (ne >>> 0);
_u64.add5L = add5L$1;
const add5H$1 = (Y, X, ee, te, ne, ie) => X + ee + te + ne + ie + (Y / 2 ** 32 | 0) | 0;
_u64.add5H = add5H$1;
const u64$3 = {
  fromBig: fromBig$1,
  split: split$1,
  toBig: toBig$1,
  shrSH: shrSH$1,
  shrSL: shrSL$1,
  rotrSH: rotrSH$1,
  rotrSL: rotrSL$1,
  rotrBH: rotrBH$1,
  rotrBL: rotrBL$1,
  rotr32H: rotr32H$1,
  rotr32L: rotr32L$1,
  rotlSH: rotlSH$1,
  rotlSL: rotlSL$1,
  rotlBH: rotlBH$1,
  rotlBL: rotlBL$1,
  add: add$1,
  add3L: add3L$1,
  add3H: add3H$1,
  add4L: add4L$1,
  add4H: add4H$1,
  add5H: add5H$1,
  add5L: add5L$1
};
_u64.default = u64$3;
Object.defineProperty(sha512$1, "__esModule", { value: !0 });
sha512$1.sha384 = sha512$1.sha512_256 = sha512$1.sha512_224 = sha512$1.sha512 = sha512$1.SHA512 = void 0;
const _sha2_js_1 = _sha2, _u64_js_1 = _u64, utils_js_1$1 = utils$1, [SHA512_Kh$1, SHA512_Kl$1] = _u64_js_1.default.split([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((Y) => BigInt(Y))), SHA512_W_H$1 = /* @__PURE__ */ new Uint32Array(80), SHA512_W_L$1 = /* @__PURE__ */ new Uint32Array(80);
let SHA512$1 = class extends _sha2_js_1.SHA2 {
  constructor() {
    super(128, 64, 16, !1), this.Ah = 1779033703, this.Al = -205731576, this.Bh = -1150833019, this.Bl = -2067093701, this.Ch = 1013904242, this.Cl = -23791573, this.Dh = -1521486534, this.Dl = 1595750129, this.Eh = 1359893119, this.El = -1377402159, this.Fh = -1694144372, this.Fl = 725511199, this.Gh = 528734635, this.Gl = -79577749, this.Hh = 1541459225, this.Hl = 327033209;
  }
  // prettier-ignore
  get() {
    const { Ah: Y, Al: X, Bh: ee, Bl: te, Ch: ne, Cl: ie, Dh: oe, Dl: se, Eh: ae, El: ue, Fh: le, Fl: he, Gh: me, Gl: ye, Hh: we, Hl: Ee } = this;
    return [Y, X, ee, te, ne, ie, oe, se, ae, ue, le, he, me, ye, we, Ee];
  }
  // prettier-ignore
  set(Y, X, ee, te, ne, ie, oe, se, ae, ue, le, he, me, ye, we, Ee) {
    this.Ah = Y | 0, this.Al = X | 0, this.Bh = ee | 0, this.Bl = te | 0, this.Ch = ne | 0, this.Cl = ie | 0, this.Dh = oe | 0, this.Dl = se | 0, this.Eh = ae | 0, this.El = ue | 0, this.Fh = le | 0, this.Fl = he | 0, this.Gh = me | 0, this.Gl = ye | 0, this.Hh = we | 0, this.Hl = Ee | 0;
  }
  process(Y, X) {
    for (let Me = 0; Me < 16; Me++, X += 4)
      SHA512_W_H$1[Me] = Y.getUint32(X), SHA512_W_L$1[Me] = Y.getUint32(X += 4);
    for (let Me = 16; Me < 80; Me++) {
      const De = SHA512_W_H$1[Me - 15] | 0, Fe = SHA512_W_L$1[Me - 15] | 0, Ke = _u64_js_1.default.rotrSH(De, Fe, 1) ^ _u64_js_1.default.rotrSH(De, Fe, 8) ^ _u64_js_1.default.shrSH(De, Fe, 7), tt = _u64_js_1.default.rotrSL(De, Fe, 1) ^ _u64_js_1.default.rotrSL(De, Fe, 8) ^ _u64_js_1.default.shrSL(De, Fe, 7), rt = SHA512_W_H$1[Me - 2] | 0, it = SHA512_W_L$1[Me - 2] | 0, _t = _u64_js_1.default.rotrSH(rt, it, 19) ^ _u64_js_1.default.rotrBH(rt, it, 61) ^ _u64_js_1.default.shrSH(rt, it, 6), Dt = _u64_js_1.default.rotrSL(rt, it, 19) ^ _u64_js_1.default.rotrBL(rt, it, 61) ^ _u64_js_1.default.shrSL(rt, it, 6), je = _u64_js_1.default.add4L(tt, Dt, SHA512_W_L$1[Me - 7], SHA512_W_L$1[Me - 16]), ze = _u64_js_1.default.add4H(je, Ke, _t, SHA512_W_H$1[Me - 7], SHA512_W_H$1[Me - 16]);
      SHA512_W_H$1[Me] = ze | 0, SHA512_W_L$1[Me] = je | 0;
    }
    let { Ah: ee, Al: te, Bh: ne, Bl: ie, Ch: oe, Cl: se, Dh: ae, Dl: ue, Eh: le, El: he, Fh: me, Fl: ye, Gh: we, Gl: Ee, Hh: Re, Hl: Ue } = this;
    for (let Me = 0; Me < 80; Me++) {
      const De = _u64_js_1.default.rotrSH(le, he, 14) ^ _u64_js_1.default.rotrSH(le, he, 18) ^ _u64_js_1.default.rotrBH(le, he, 41), Fe = _u64_js_1.default.rotrSL(le, he, 14) ^ _u64_js_1.default.rotrSL(le, he, 18) ^ _u64_js_1.default.rotrBL(le, he, 41), Ke = le & me ^ ~le & we, tt = he & ye ^ ~he & Ee, rt = _u64_js_1.default.add5L(Ue, Fe, tt, SHA512_Kl$1[Me], SHA512_W_L$1[Me]), it = _u64_js_1.default.add5H(rt, Re, De, Ke, SHA512_Kh$1[Me], SHA512_W_H$1[Me]), _t = rt | 0, Dt = _u64_js_1.default.rotrSH(ee, te, 28) ^ _u64_js_1.default.rotrBH(ee, te, 34) ^ _u64_js_1.default.rotrBH(ee, te, 39), je = _u64_js_1.default.rotrSL(ee, te, 28) ^ _u64_js_1.default.rotrBL(ee, te, 34) ^ _u64_js_1.default.rotrBL(ee, te, 39), ze = ee & ne ^ ee & oe ^ ne & oe, fe = te & ie ^ te & se ^ ie & se;
      Re = we | 0, Ue = Ee | 0, we = me | 0, Ee = ye | 0, me = le | 0, ye = he | 0, { h: le, l: he } = _u64_js_1.default.add(ae | 0, ue | 0, it | 0, _t | 0), ae = oe | 0, ue = se | 0, oe = ne | 0, se = ie | 0, ne = ee | 0, ie = te | 0;
      const de = _u64_js_1.default.add3L(_t, je, fe);
      ee = _u64_js_1.default.add3H(de, it, Dt, ze), te = de | 0;
    }
    ({ h: ee, l: te } = _u64_js_1.default.add(this.Ah | 0, this.Al | 0, ee | 0, te | 0)), { h: ne, l: ie } = _u64_js_1.default.add(this.Bh | 0, this.Bl | 0, ne | 0, ie | 0), { h: oe, l: se } = _u64_js_1.default.add(this.Ch | 0, this.Cl | 0, oe | 0, se | 0), { h: ae, l: ue } = _u64_js_1.default.add(this.Dh | 0, this.Dl | 0, ae | 0, ue | 0), { h: le, l: he } = _u64_js_1.default.add(this.Eh | 0, this.El | 0, le | 0, he | 0), { h: me, l: ye } = _u64_js_1.default.add(this.Fh | 0, this.Fl | 0, me | 0, ye | 0), { h: we, l: Ee } = _u64_js_1.default.add(this.Gh | 0, this.Gl | 0, we | 0, Ee | 0), { h: Re, l: Ue } = _u64_js_1.default.add(this.Hh | 0, this.Hl | 0, Re | 0, Ue | 0), this.set(ee, te, ne, ie, oe, se, ae, ue, le, he, me, ye, we, Ee, Re, Ue);
  }
  roundClean() {
    SHA512_W_H$1.fill(0), SHA512_W_L$1.fill(0);
  }
  destroy() {
    this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
sha512$1.SHA512 = SHA512$1;
class SHA512_224 extends SHA512$1 {
  constructor() {
    super(), this.Ah = -1942145080, this.Al = 424955298, this.Bh = 1944164710, this.Bl = -1982016298, this.Ch = 502970286, this.Cl = 855612546, this.Dh = 1738396948, this.Dl = 1479516111, this.Eh = 258812777, this.El = 2077511080, this.Fh = 2011393907, this.Fl = 79989058, this.Gh = 1067287976, this.Gl = 1780299464, this.Hh = 286451373, this.Hl = -1848208735, this.outputLen = 28;
  }
}
class SHA512_256 extends SHA512$1 {
  constructor() {
    super(), this.Ah = 573645204, this.Al = -64227540, this.Bh = -1621794909, this.Bl = -934517566, this.Ch = 596883563, this.Cl = 1867755857, this.Dh = -1774684391, this.Dl = 1497426621, this.Eh = -1775747358, this.El = -1467023389, this.Fh = -1101128155, this.Fl = 1401305490, this.Gh = 721525244, this.Gl = 746961066, this.Hh = 246885852, this.Hl = -2117784414, this.outputLen = 32;
  }
}
class SHA384 extends SHA512$1 {
  constructor() {
    super(), this.Ah = -876896931, this.Al = -1056596264, this.Bh = 1654270250, this.Bl = 914150663, this.Ch = -1856437926, this.Cl = 812702999, this.Dh = 355462360, this.Dl = -150054599, this.Eh = 1731405415, this.El = -4191439, this.Fh = -1900787065, this.Fl = 1750603025, this.Gh = -619958771, this.Gl = 1694076839, this.Hh = 1203062813, this.Hl = -1090891868, this.outputLen = 48;
  }
}
sha512$1.sha512 = (0, utils_js_1$1.wrapConstructor)(() => new SHA512$1());
sha512$1.sha512_224 = (0, utils_js_1$1.wrapConstructor)(() => new SHA512_224());
sha512$1.sha512_256 = (0, utils_js_1$1.wrapConstructor)(() => new SHA512_256());
sha512$1.sha384 = (0, utils_js_1$1.wrapConstructor)(() => new SHA384());
var pbkdf2$1 = {}, hmac$1 = {};
(function(Y) {
  Object.defineProperty(Y, "__esModule", { value: !0 }), Y.hmac = Y.HMAC = void 0;
  const X = _assert, ee = utils$1;
  class te extends ee.Hash {
    constructor(oe, se) {
      super(), this.finished = !1, this.destroyed = !1, (0, X.hash)(oe);
      const ae = (0, ee.toBytes)(se);
      if (this.iHash = oe.create(), typeof this.iHash.update != "function")
        throw new Error("Expected instance of class which extends utils.Hash");
      this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
      const ue = this.blockLen, le = new Uint8Array(ue);
      le.set(ae.length > ue ? oe.create().update(ae).digest() : ae);
      for (let he = 0; he < le.length; he++)
        le[he] ^= 54;
      this.iHash.update(le), this.oHash = oe.create();
      for (let he = 0; he < le.length; he++)
        le[he] ^= 106;
      this.oHash.update(le), le.fill(0);
    }
    update(oe) {
      return (0, X.exists)(this), this.iHash.update(oe), this;
    }
    digestInto(oe) {
      (0, X.exists)(this), (0, X.bytes)(oe, this.outputLen), this.finished = !0, this.iHash.digestInto(oe), this.oHash.update(oe), this.oHash.digestInto(oe), this.destroy();
    }
    digest() {
      const oe = new Uint8Array(this.oHash.outputLen);
      return this.digestInto(oe), oe;
    }
    _cloneInto(oe) {
      oe || (oe = Object.create(Object.getPrototypeOf(this), {}));
      const { oHash: se, iHash: ae, finished: ue, destroyed: le, blockLen: he, outputLen: me } = this;
      return oe = oe, oe.finished = ue, oe.destroyed = le, oe.blockLen = he, oe.outputLen = me, oe.oHash = se._cloneInto(oe.oHash), oe.iHash = ae._cloneInto(oe.iHash), oe;
    }
    destroy() {
      this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
    }
  }
  Y.HMAC = te;
  const ne = (ie, oe, se) => new te(ie, oe).update(se).digest();
  Y.hmac = ne, Y.hmac.create = (ie, oe) => new te(ie, oe);
})(hmac$1);
Object.defineProperty(pbkdf2$1, "__esModule", { value: !0 });
pbkdf2$1.pbkdf2Async = pbkdf2$1.pbkdf2 = void 0;
const _assert_js_1 = _assert, hmac_js_1 = hmac$1, utils_js_1 = utils$1;
function pbkdf2Init(Y, X, ee, te) {
  (0, _assert_js_1.hash)(Y);
  const ne = (0, utils_js_1.checkOpts)({ dkLen: 32, asyncTick: 10 }, te), { c: ie, dkLen: oe, asyncTick: se } = ne;
  if ((0, _assert_js_1.number)(ie), (0, _assert_js_1.number)(oe), (0, _assert_js_1.number)(se), ie < 1)
    throw new Error("PBKDF2: iterations (c) should be >= 1");
  const ae = (0, utils_js_1.toBytes)(X), ue = (0, utils_js_1.toBytes)(ee), le = new Uint8Array(oe), he = hmac_js_1.hmac.create(Y, ae), me = he._cloneInto().update(ue);
  return { c: ie, dkLen: oe, asyncTick: se, DK: le, PRF: he, PRFSalt: me };
}
function pbkdf2Output(Y, X, ee, te, ne) {
  return Y.destroy(), X.destroy(), te && te.destroy(), ne.fill(0), ee;
}
function pbkdf2(Y, X, ee, te) {
  const { c: ne, dkLen: ie, DK: oe, PRF: se, PRFSalt: ae } = pbkdf2Init(Y, X, ee, te);
  let ue;
  const le = new Uint8Array(4), he = (0, utils_js_1.createView)(le), me = new Uint8Array(se.outputLen);
  for (let ye = 1, we = 0; we < ie; ye++, we += se.outputLen) {
    const Ee = oe.subarray(we, we + se.outputLen);
    he.setInt32(0, ye, !1), (ue = ae._cloneInto(ue)).update(le).digestInto(me), Ee.set(me.subarray(0, Ee.length));
    for (let Re = 1; Re < ne; Re++) {
      se._cloneInto(ue).update(me).digestInto(me);
      for (let Ue = 0; Ue < Ee.length; Ue++)
        Ee[Ue] ^= me[Ue];
    }
  }
  return pbkdf2Output(se, ae, oe, ue, me);
}
pbkdf2$1.pbkdf2 = pbkdf2;
async function pbkdf2Async(Y, X, ee, te) {
  const { c: ne, dkLen: ie, asyncTick: oe, DK: se, PRF: ae, PRFSalt: ue } = pbkdf2Init(Y, X, ee, te);
  let le;
  const he = new Uint8Array(4), me = (0, utils_js_1.createView)(he), ye = new Uint8Array(ae.outputLen);
  for (let we = 1, Ee = 0; Ee < ie; we++, Ee += ae.outputLen) {
    const Re = se.subarray(Ee, Ee + ae.outputLen);
    me.setInt32(0, we, !1), (le = ue._cloneInto(le)).update(he).digestInto(ye), Re.set(ye.subarray(0, Re.length)), await (0, utils_js_1.asyncLoop)(ne - 1, oe, () => {
      ae._cloneInto(le).update(ye).digestInto(ye);
      for (let Ue = 0; Ue < Re.length; Ue++)
        Re[Ue] ^= ye[Ue];
    });
  }
  return pbkdf2Output(ae, ue, se, le, ye);
}
pbkdf2$1.pbkdf2Async = pbkdf2Async;
var _wordlists = {};
const require$$0$1 = [
  "abdikace",
  "abeceda",
  "adresa",
  "agrese",
  "akce",
  "aktovka",
  "alej",
  "alkohol",
  "amputace",
  "ananas",
  "andulka",
  "anekdota",
  "anketa",
  "antika",
  "anulovat",
  "archa",
  "arogance",
  "asfalt",
  "asistent",
  "aspirace",
  "astma",
  "astronom",
  "atlas",
  "atletika",
  "atol",
  "autobus",
  "azyl",
  "babka",
  "bachor",
  "bacil",
  "baculka",
  "badatel",
  "bageta",
  "bagr",
  "bahno",
  "bakterie",
  "balada",
  "baletka",
  "balkon",
  "balonek",
  "balvan",
  "balza",
  "bambus",
  "bankomat",
  "barbar",
  "baret",
  "barman",
  "baroko",
  "barva",
  "baterka",
  "batoh",
  "bavlna",
  "bazalka",
  "bazilika",
  "bazuka",
  "bedna",
  "beran",
  "beseda",
  "bestie",
  "beton",
  "bezinka",
  "bezmoc",
  "beztak",
  "bicykl",
  "bidlo",
  "biftek",
  "bikiny",
  "bilance",
  "biograf",
  "biolog",
  "bitva",
  "bizon",
  "blahobyt",
  "blatouch",
  "blecha",
  "bledule",
  "blesk",
  "blikat",
  "blizna",
  "blokovat",
  "bloudit",
  "blud",
  "bobek",
  "bobr",
  "bodlina",
  "bodnout",
  "bohatost",
  "bojkot",
  "bojovat",
  "bokorys",
  "bolest",
  "borec",
  "borovice",
  "bota",
  "boubel",
  "bouchat",
  "bouda",
  "boule",
  "bourat",
  "boxer",
  "bradavka",
  "brambora",
  "branka",
  "bratr",
  "brepta",
  "briketa",
  "brko",
  "brloh",
  "bronz",
  "broskev",
  "brunetka",
  "brusinka",
  "brzda",
  "brzy",
  "bublina",
  "bubnovat",
  "buchta",
  "buditel",
  "budka",
  "budova",
  "bufet",
  "bujarost",
  "bukvice",
  "buldok",
  "bulva",
  "bunda",
  "bunkr",
  "burza",
  "butik",
  "buvol",
  "buzola",
  "bydlet",
  "bylina",
  "bytovka",
  "bzukot",
  "capart",
  "carevna",
  "cedr",
  "cedule",
  "cejch",
  "cejn",
  "cela",
  "celer",
  "celkem",
  "celnice",
  "cenina",
  "cennost",
  "cenovka",
  "centrum",
  "cenzor",
  "cestopis",
  "cetka",
  "chalupa",
  "chapadlo",
  "charita",
  "chata",
  "chechtat",
  "chemie",
  "chichot",
  "chirurg",
  "chlad",
  "chleba",
  "chlubit",
  "chmel",
  "chmura",
  "chobot",
  "chochol",
  "chodba",
  "cholera",
  "chomout",
  "chopit",
  "choroba",
  "chov",
  "chrapot",
  "chrlit",
  "chrt",
  "chrup",
  "chtivost",
  "chudina",
  "chutnat",
  "chvat",
  "chvilka",
  "chvost",
  "chyba",
  "chystat",
  "chytit",
  "cibule",
  "cigareta",
  "cihelna",
  "cihla",
  "cinkot",
  "cirkus",
  "cisterna",
  "citace",
  "citrus",
  "cizinec",
  "cizost",
  "clona",
  "cokoliv",
  "couvat",
  "ctitel",
  "ctnost",
  "cudnost",
  "cuketa",
  "cukr",
  "cupot",
  "cvaknout",
  "cval",
  "cvik",
  "cvrkot",
  "cyklista",
  "daleko",
  "dareba",
  "datel",
  "datum",
  "dcera",
  "debata",
  "dechovka",
  "decibel",
  "deficit",
  "deflace",
  "dekl",
  "dekret",
  "demokrat",
  "deprese",
  "derby",
  "deska",
  "detektiv",
  "dikobraz",
  "diktovat",
  "dioda",
  "diplom",
  "disk",
  "displej",
  "divadlo",
  "divoch",
  "dlaha",
  "dlouho",
  "dluhopis",
  "dnes",
  "dobro",
  "dobytek",
  "docent",
  "dochutit",
  "dodnes",
  "dohled",
  "dohoda",
  "dohra",
  "dojem",
  "dojnice",
  "doklad",
  "dokola",
  "doktor",
  "dokument",
  "dolar",
  "doleva",
  "dolina",
  "doma",
  "dominant",
  "domluvit",
  "domov",
  "donutit",
  "dopad",
  "dopis",
  "doplnit",
  "doposud",
  "doprovod",
  "dopustit",
  "dorazit",
  "dorost",
  "dort",
  "dosah",
  "doslov",
  "dostatek",
  "dosud",
  "dosyta",
  "dotaz",
  "dotek",
  "dotknout",
  "doufat",
  "doutnat",
  "dovozce",
  "dozadu",
  "doznat",
  "dozorce",
  "drahota",
  "drak",
  "dramatik",
  "dravec",
  "draze",
  "drdol",
  "drobnost",
  "drogerie",
  "drozd",
  "drsnost",
  "drtit",
  "drzost",
  "duben",
  "duchovno",
  "dudek",
  "duha",
  "duhovka",
  "dusit",
  "dusno",
  "dutost",
  "dvojice",
  "dvorec",
  "dynamit",
  "ekolog",
  "ekonomie",
  "elektron",
  "elipsa",
  "email",
  "emise",
  "emoce",
  "empatie",
  "epizoda",
  "epocha",
  "epopej",
  "epos",
  "esej",
  "esence",
  "eskorta",
  "eskymo",
  "etiketa",
  "euforie",
  "evoluce",
  "exekuce",
  "exkurze",
  "expedice",
  "exploze",
  "export",
  "extrakt",
  "facka",
  "fajfka",
  "fakulta",
  "fanatik",
  "fantazie",
  "farmacie",
  "favorit",
  "fazole",
  "federace",
  "fejeton",
  "fenka",
  "fialka",
  "figurant",
  "filozof",
  "filtr",
  "finance",
  "finta",
  "fixace",
  "fjord",
  "flanel",
  "flirt",
  "flotila",
  "fond",
  "fosfor",
  "fotbal",
  "fotka",
  "foton",
  "frakce",
  "freska",
  "fronta",
  "fukar",
  "funkce",
  "fyzika",
  "galeje",
  "garant",
  "genetika",
  "geolog",
  "gilotina",
  "glazura",
  "glejt",
  "golem",
  "golfista",
  "gotika",
  "graf",
  "gramofon",
  "granule",
  "grep",
  "gril",
  "grog",
  "groteska",
  "guma",
  "hadice",
  "hadr",
  "hala",
  "halenka",
  "hanba",
  "hanopis",
  "harfa",
  "harpuna",
  "havran",
  "hebkost",
  "hejkal",
  "hejno",
  "hejtman",
  "hektar",
  "helma",
  "hematom",
  "herec",
  "herna",
  "heslo",
  "hezky",
  "historik",
  "hladovka",
  "hlasivky",
  "hlava",
  "hledat",
  "hlen",
  "hlodavec",
  "hloh",
  "hloupost",
  "hltat",
  "hlubina",
  "hluchota",
  "hmat",
  "hmota",
  "hmyz",
  "hnis",
  "hnojivo",
  "hnout",
  "hoblina",
  "hoboj",
  "hoch",
  "hodiny",
  "hodlat",
  "hodnota",
  "hodovat",
  "hojnost",
  "hokej",
  "holinka",
  "holka",
  "holub",
  "homole",
  "honitba",
  "honorace",
  "horal",
  "horda",
  "horizont",
  "horko",
  "horlivec",
  "hormon",
  "hornina",
  "horoskop",
  "horstvo",
  "hospoda",
  "hostina",
  "hotovost",
  "houba",
  "houf",
  "houpat",
  "houska",
  "hovor",
  "hradba",
  "hranice",
  "hravost",
  "hrazda",
  "hrbolek",
  "hrdina",
  "hrdlo",
  "hrdost",
  "hrnek",
  "hrobka",
  "hromada",
  "hrot",
  "hrouda",
  "hrozen",
  "hrstka",
  "hrubost",
  "hryzat",
  "hubenost",
  "hubnout",
  "hudba",
  "hukot",
  "humr",
  "husita",
  "hustota",
  "hvozd",
  "hybnost",
  "hydrant",
  "hygiena",
  "hymna",
  "hysterik",
  "idylka",
  "ihned",
  "ikona",
  "iluze",
  "imunita",
  "infekce",
  "inflace",
  "inkaso",
  "inovace",
  "inspekce",
  "internet",
  "invalida",
  "investor",
  "inzerce",
  "ironie",
  "jablko",
  "jachta",
  "jahoda",
  "jakmile",
  "jakost",
  "jalovec",
  "jantar",
  "jarmark",
  "jaro",
  "jasan",
  "jasno",
  "jatka",
  "javor",
  "jazyk",
  "jedinec",
  "jedle",
  "jednatel",
  "jehlan",
  "jekot",
  "jelen",
  "jelito",
  "jemnost",
  "jenom",
  "jepice",
  "jeseter",
  "jevit",
  "jezdec",
  "jezero",
  "jinak",
  "jindy",
  "jinoch",
  "jiskra",
  "jistota",
  "jitrnice",
  "jizva",
  "jmenovat",
  "jogurt",
  "jurta",
  "kabaret",
  "kabel",
  "kabinet",
  "kachna",
  "kadet",
  "kadidlo",
  "kahan",
  "kajak",
  "kajuta",
  "kakao",
  "kaktus",
  "kalamita",
  "kalhoty",
  "kalibr",
  "kalnost",
  "kamera",
  "kamkoliv",
  "kamna",
  "kanibal",
  "kanoe",
  "kantor",
  "kapalina",
  "kapela",
  "kapitola",
  "kapka",
  "kaple",
  "kapota",
  "kapr",
  "kapusta",
  "kapybara",
  "karamel",
  "karotka",
  "karton",
  "kasa",
  "katalog",
  "katedra",
  "kauce",
  "kauza",
  "kavalec",
  "kazajka",
  "kazeta",
  "kazivost",
  "kdekoliv",
  "kdesi",
  "kedluben",
  "kemp",
  "keramika",
  "kino",
  "klacek",
  "kladivo",
  "klam",
  "klapot",
  "klasika",
  "klaun",
  "klec",
  "klenba",
  "klepat",
  "klesnout",
  "klid",
  "klima",
  "klisna",
  "klobouk",
  "klokan",
  "klopa",
  "kloub",
  "klubovna",
  "klusat",
  "kluzkost",
  "kmen",
  "kmitat",
  "kmotr",
  "kniha",
  "knot",
  "koalice",
  "koberec",
  "kobka",
  "kobliha",
  "kobyla",
  "kocour",
  "kohout",
  "kojenec",
  "kokos",
  "koktejl",
  "kolaps",
  "koleda",
  "kolize",
  "kolo",
  "komando",
  "kometa",
  "komik",
  "komnata",
  "komora",
  "kompas",
  "komunita",
  "konat",
  "koncept",
  "kondice",
  "konec",
  "konfese",
  "kongres",
  "konina",
  "konkurs",
  "kontakt",
  "konzerva",
  "kopanec",
  "kopie",
  "kopnout",
  "koprovka",
  "korbel",
  "korektor",
  "kormidlo",
  "koroptev",
  "korpus",
  "koruna",
  "koryto",
  "korzet",
  "kosatec",
  "kostka",
  "kotel",
  "kotleta",
  "kotoul",
  "koukat",
  "koupelna",
  "kousek",
  "kouzlo",
  "kovboj",
  "koza",
  "kozoroh",
  "krabice",
  "krach",
  "krajina",
  "kralovat",
  "krasopis",
  "kravata",
  "kredit",
  "krejcar",
  "kresba",
  "kreveta",
  "kriket",
  "kritik",
  "krize",
  "krkavec",
  "krmelec",
  "krmivo",
  "krocan",
  "krok",
  "kronika",
  "kropit",
  "kroupa",
  "krovka",
  "krtek",
  "kruhadlo",
  "krupice",
  "krutost",
  "krvinka",
  "krychle",
  "krypta",
  "krystal",
  "kryt",
  "kudlanka",
  "kufr",
  "kujnost",
  "kukla",
  "kulajda",
  "kulich",
  "kulka",
  "kulomet",
  "kultura",
  "kuna",
  "kupodivu",
  "kurt",
  "kurzor",
  "kutil",
  "kvalita",
  "kvasinka",
  "kvestor",
  "kynolog",
  "kyselina",
  "kytara",
  "kytice",
  "kytka",
  "kytovec",
  "kyvadlo",
  "labrador",
  "lachtan",
  "ladnost",
  "laik",
  "lakomec",
  "lamela",
  "lampa",
  "lanovka",
  "lasice",
  "laso",
  "lastura",
  "latinka",
  "lavina",
  "lebka",
  "leckdy",
  "leden",
  "lednice",
  "ledovka",
  "ledvina",
  "legenda",
  "legie",
  "legrace",
  "lehce",
  "lehkost",
  "lehnout",
  "lektvar",
  "lenochod",
  "lentilka",
  "lepenka",
  "lepidlo",
  "letadlo",
  "letec",
  "letmo",
  "letokruh",
  "levhart",
  "levitace",
  "levobok",
  "libra",
  "lichotka",
  "lidojed",
  "lidskost",
  "lihovina",
  "lijavec",
  "lilek",
  "limetka",
  "linie",
  "linka",
  "linoleum",
  "listopad",
  "litina",
  "litovat",
  "lobista",
  "lodivod",
  "logika",
  "logoped",
  "lokalita",
  "loket",
  "lomcovat",
  "lopata",
  "lopuch",
  "lord",
  "losos",
  "lotr",
  "loudal",
  "louh",
  "louka",
  "louskat",
  "lovec",
  "lstivost",
  "lucerna",
  "lucifer",
  "lump",
  "lusk",
  "lustrace",
  "lvice",
  "lyra",
  "lyrika",
  "lysina",
  "madam",
  "madlo",
  "magistr",
  "mahagon",
  "majetek",
  "majitel",
  "majorita",
  "makak",
  "makovice",
  "makrela",
  "malba",
  "malina",
  "malovat",
  "malvice",
  "maminka",
  "mandle",
  "manko",
  "marnost",
  "masakr",
  "maskot",
  "masopust",
  "matice",
  "matrika",
  "maturita",
  "mazanec",
  "mazivo",
  "mazlit",
  "mazurka",
  "mdloba",
  "mechanik",
  "meditace",
  "medovina",
  "melasa",
  "meloun",
  "mentolka",
  "metla",
  "metoda",
  "metr",
  "mezera",
  "migrace",
  "mihnout",
  "mihule",
  "mikina",
  "mikrofon",
  "milenec",
  "milimetr",
  "milost",
  "mimika",
  "mincovna",
  "minibar",
  "minomet",
  "minulost",
  "miska",
  "mistr",
  "mixovat",
  "mladost",
  "mlha",
  "mlhovina",
  "mlok",
  "mlsat",
  "mluvit",
  "mnich",
  "mnohem",
  "mobil",
  "mocnost",
  "modelka",
  "modlitba",
  "mohyla",
  "mokro",
  "molekula",
  "momentka",
  "monarcha",
  "monokl",
  "monstrum",
  "montovat",
  "monzun",
  "mosaz",
  "moskyt",
  "most",
  "motivace",
  "motorka",
  "motyka",
  "moucha",
  "moudrost",
  "mozaika",
  "mozek",
  "mozol",
  "mramor",
  "mravenec",
  "mrkev",
  "mrtvola",
  "mrzet",
  "mrzutost",
  "mstitel",
  "mudrc",
  "muflon",
  "mulat",
  "mumie",
  "munice",
  "muset",
  "mutace",
  "muzeum",
  "muzikant",
  "myslivec",
  "mzda",
  "nabourat",
  "nachytat",
  "nadace",
  "nadbytek",
  "nadhoz",
  "nadobro",
  "nadpis",
  "nahlas",
  "nahnat",
  "nahodile",
  "nahradit",
  "naivita",
  "najednou",
  "najisto",
  "najmout",
  "naklonit",
  "nakonec",
  "nakrmit",
  "nalevo",
  "namazat",
  "namluvit",
  "nanometr",
  "naoko",
  "naopak",
  "naostro",
  "napadat",
  "napevno",
  "naplnit",
  "napnout",
  "naposled",
  "naprosto",
  "narodit",
  "naruby",
  "narychlo",
  "nasadit",
  "nasekat",
  "naslepo",
  "nastat",
  "natolik",
  "navenek",
  "navrch",
  "navzdory",
  "nazvat",
  "nebe",
  "nechat",
  "necky",
  "nedaleko",
  "nedbat",
  "neduh",
  "negace",
  "nehet",
  "nehoda",
  "nejen",
  "nejprve",
  "neklid",
  "nelibost",
  "nemilost",
  "nemoc",
  "neochota",
  "neonka",
  "nepokoj",
  "nerost",
  "nerv",
  "nesmysl",
  "nesoulad",
  "netvor",
  "neuron",
  "nevina",
  "nezvykle",
  "nicota",
  "nijak",
  "nikam",
  "nikdy",
  "nikl",
  "nikterak",
  "nitro",
  "nocleh",
  "nohavice",
  "nominace",
  "nora",
  "norek",
  "nositel",
  "nosnost",
  "nouze",
  "noviny",
  "novota",
  "nozdra",
  "nuda",
  "nudle",
  "nuget",
  "nutit",
  "nutnost",
  "nutrie",
  "nymfa",
  "obal",
  "obarvit",
  "obava",
  "obdiv",
  "obec",
  "obehnat",
  "obejmout",
  "obezita",
  "obhajoba",
  "obilnice",
  "objasnit",
  "objekt",
  "obklopit",
  "oblast",
  "oblek",
  "obliba",
  "obloha",
  "obluda",
  "obnos",
  "obohatit",
  "obojek",
  "obout",
  "obrazec",
  "obrna",
  "obruba",
  "obrys",
  "obsah",
  "obsluha",
  "obstarat",
  "obuv",
  "obvaz",
  "obvinit",
  "obvod",
  "obvykle",
  "obyvatel",
  "obzor",
  "ocas",
  "ocel",
  "ocenit",
  "ochladit",
  "ochota",
  "ochrana",
  "ocitnout",
  "odboj",
  "odbyt",
  "odchod",
  "odcizit",
  "odebrat",
  "odeslat",
  "odevzdat",
  "odezva",
  "odhadce",
  "odhodit",
  "odjet",
  "odjinud",
  "odkaz",
  "odkoupit",
  "odliv",
  "odluka",
  "odmlka",
  "odolnost",
  "odpad",
  "odpis",
  "odplout",
  "odpor",
  "odpustit",
  "odpykat",
  "odrazka",
  "odsoudit",
  "odstup",
  "odsun",
  "odtok",
  "odtud",
  "odvaha",
  "odveta",
  "odvolat",
  "odvracet",
  "odznak",
  "ofina",
  "ofsajd",
  "ohlas",
  "ohnisko",
  "ohrada",
  "ohrozit",
  "ohryzek",
  "okap",
  "okenice",
  "oklika",
  "okno",
  "okouzlit",
  "okovy",
  "okrasa",
  "okres",
  "okrsek",
  "okruh",
  "okupant",
  "okurka",
  "okusit",
  "olejnina",
  "olizovat",
  "omak",
  "omeleta",
  "omezit",
  "omladina",
  "omlouvat",
  "omluva",
  "omyl",
  "onehdy",
  "opakovat",
  "opasek",
  "operace",
  "opice",
  "opilost",
  "opisovat",
  "opora",
  "opozice",
  "opravdu",
  "oproti",
  "orbital",
  "orchestr",
  "orgie",
  "orlice",
  "orloj",
  "ortel",
  "osada",
  "oschnout",
  "osika",
  "osivo",
  "oslava",
  "oslepit",
  "oslnit",
  "oslovit",
  "osnova",
  "osoba",
  "osolit",
  "ospalec",
  "osten",
  "ostraha",
  "ostuda",
  "ostych",
  "osvojit",
  "oteplit",
  "otisk",
  "otop",
  "otrhat",
  "otrlost",
  "otrok",
  "otruby",
  "otvor",
  "ovanout",
  "ovar",
  "oves",
  "ovlivnit",
  "ovoce",
  "oxid",
  "ozdoba",
  "pachatel",
  "pacient",
  "padouch",
  "pahorek",
  "pakt",
  "palanda",
  "palec",
  "palivo",
  "paluba",
  "pamflet",
  "pamlsek",
  "panenka",
  "panika",
  "panna",
  "panovat",
  "panstvo",
  "pantofle",
  "paprika",
  "parketa",
  "parodie",
  "parta",
  "paruka",
  "paryba",
  "paseka",
  "pasivita",
  "pastelka",
  "patent",
  "patrona",
  "pavouk",
  "pazneht",
  "pazourek",
  "pecka",
  "pedagog",
  "pejsek",
  "peklo",
  "peloton",
  "penalta",
  "pendrek",
  "penze",
  "periskop",
  "pero",
  "pestrost",
  "petarda",
  "petice",
  "petrolej",
  "pevnina",
  "pexeso",
  "pianista",
  "piha",
  "pijavice",
  "pikle",
  "piknik",
  "pilina",
  "pilnost",
  "pilulka",
  "pinzeta",
  "pipeta",
  "pisatel",
  "pistole",
  "pitevna",
  "pivnice",
  "pivovar",
  "placenta",
  "plakat",
  "plamen",
  "planeta",
  "plastika",
  "platit",
  "plavidlo",
  "plaz",
  "plech",
  "plemeno",
  "plenta",
  "ples",
  "pletivo",
  "plevel",
  "plivat",
  "plnit",
  "plno",
  "plocha",
  "plodina",
  "plomba",
  "plout",
  "pluk",
  "plyn",
  "pobavit",
  "pobyt",
  "pochod",
  "pocit",
  "poctivec",
  "podat",
  "podcenit",
  "podepsat",
  "podhled",
  "podivit",
  "podklad",
  "podmanit",
  "podnik",
  "podoba",
  "podpora",
  "podraz",
  "podstata",
  "podvod",
  "podzim",
  "poezie",
  "pohanka",
  "pohnutka",
  "pohovor",
  "pohroma",
  "pohyb",
  "pointa",
  "pojistka",
  "pojmout",
  "pokazit",
  "pokles",
  "pokoj",
  "pokrok",
  "pokuta",
  "pokyn",
  "poledne",
  "polibek",
  "polknout",
  "poloha",
  "polynom",
  "pomalu",
  "pominout",
  "pomlka",
  "pomoc",
  "pomsta",
  "pomyslet",
  "ponechat",
  "ponorka",
  "ponurost",
  "popadat",
  "popel",
  "popisek",
  "poplach",
  "poprosit",
  "popsat",
  "popud",
  "poradce",
  "porce",
  "porod",
  "porucha",
  "poryv",
  "posadit",
  "posed",
  "posila",
  "poskok",
  "poslanec",
  "posoudit",
  "pospolu",
  "postava",
  "posudek",
  "posyp",
  "potah",
  "potkan",
  "potlesk",
  "potomek",
  "potrava",
  "potupa",
  "potvora",
  "poukaz",
  "pouto",
  "pouzdro",
  "povaha",
  "povidla",
  "povlak",
  "povoz",
  "povrch",
  "povstat",
  "povyk",
  "povzdech",
  "pozdrav",
  "pozemek",
  "poznatek",
  "pozor",
  "pozvat",
  "pracovat",
  "prahory",
  "praktika",
  "prales",
  "praotec",
  "praporek",
  "prase",
  "pravda",
  "princip",
  "prkno",
  "probudit",
  "procento",
  "prodej",
  "profese",
  "prohra",
  "projekt",
  "prolomit",
  "promile",
  "pronikat",
  "propad",
  "prorok",
  "prosba",
  "proton",
  "proutek",
  "provaz",
  "prskavka",
  "prsten",
  "prudkost",
  "prut",
  "prvek",
  "prvohory",
  "psanec",
  "psovod",
  "pstruh",
  "ptactvo",
  "puberta",
  "puch",
  "pudl",
  "pukavec",
  "puklina",
  "pukrle",
  "pult",
  "pumpa",
  "punc",
  "pupen",
  "pusa",
  "pusinka",
  "pustina",
  "putovat",
  "putyka",
  "pyramida",
  "pysk",
  "pytel",
  "racek",
  "rachot",
  "radiace",
  "radnice",
  "radon",
  "raft",
  "ragby",
  "raketa",
  "rakovina",
  "rameno",
  "rampouch",
  "rande",
  "rarach",
  "rarita",
  "rasovna",
  "rastr",
  "ratolest",
  "razance",
  "razidlo",
  "reagovat",
  "reakce",
  "recept",
  "redaktor",
  "referent",
  "reflex",
  "rejnok",
  "reklama",
  "rekord",
  "rekrut",
  "rektor",
  "reputace",
  "revize",
  "revma",
  "revolver",
  "rezerva",
  "riskovat",
  "riziko",
  "robotika",
  "rodokmen",
  "rohovka",
  "rokle",
  "rokoko",
  "romaneto",
  "ropovod",
  "ropucha",
  "rorejs",
  "rosol",
  "rostlina",
  "rotmistr",
  "rotoped",
  "rotunda",
  "roubenka",
  "roucho",
  "roup",
  "roura",
  "rovina",
  "rovnice",
  "rozbor",
  "rozchod",
  "rozdat",
  "rozeznat",
  "rozhodce",
  "rozinka",
  "rozjezd",
  "rozkaz",
  "rozloha",
  "rozmar",
  "rozpad",
  "rozruch",
  "rozsah",
  "roztok",
  "rozum",
  "rozvod",
  "rubrika",
  "ruchadlo",
  "rukavice",
  "rukopis",
  "ryba",
  "rybolov",
  "rychlost",
  "rydlo",
  "rypadlo",
  "rytina",
  "ryzost",
  "sadista",
  "sahat",
  "sako",
  "samec",
  "samizdat",
  "samota",
  "sanitka",
  "sardinka",
  "sasanka",
  "satelit",
  "sazba",
  "sazenice",
  "sbor",
  "schovat",
  "sebranka",
  "secese",
  "sedadlo",
  "sediment",
  "sedlo",
  "sehnat",
  "sejmout",
  "sekera",
  "sekta",
  "sekunda",
  "sekvoje",
  "semeno",
  "seno",
  "servis",
  "sesadit",
  "seshora",
  "seskok",
  "seslat",
  "sestra",
  "sesuv",
  "sesypat",
  "setba",
  "setina",
  "setkat",
  "setnout",
  "setrvat",
  "sever",
  "seznam",
  "shoda",
  "shrnout",
  "sifon",
  "silnice",
  "sirka",
  "sirotek",
  "sirup",
  "situace",
  "skafandr",
  "skalisko",
  "skanzen",
  "skaut",
  "skeptik",
  "skica",
  "skladba",
  "sklenice",
  "sklo",
  "skluz",
  "skoba",
  "skokan",
  "skoro",
  "skripta",
  "skrz",
  "skupina",
  "skvost",
  "skvrna",
  "slabika",
  "sladidlo",
  "slanina",
  "slast",
  "slavnost",
  "sledovat",
  "slepec",
  "sleva",
  "slezina",
  "slib",
  "slina",
  "sliznice",
  "slon",
  "sloupek",
  "slovo",
  "sluch",
  "sluha",
  "slunce",
  "slupka",
  "slza",
  "smaragd",
  "smetana",
  "smilstvo",
  "smlouva",
  "smog",
  "smrad",
  "smrk",
  "smrtka",
  "smutek",
  "smysl",
  "snad",
  "snaha",
  "snob",
  "sobota",
  "socha",
  "sodovka",
  "sokol",
  "sopka",
  "sotva",
  "souboj",
  "soucit",
  "soudce",
  "souhlas",
  "soulad",
  "soumrak",
  "souprava",
  "soused",
  "soutok",
  "souviset",
  "spalovna",
  "spasitel",
  "spis",
  "splav",
  "spodek",
  "spojenec",
  "spolu",
  "sponzor",
  "spornost",
  "spousta",
  "sprcha",
  "spustit",
  "sranda",
  "sraz",
  "srdce",
  "srna",
  "srnec",
  "srovnat",
  "srpen",
  "srst",
  "srub",
  "stanice",
  "starosta",
  "statika",
  "stavba",
  "stehno",
  "stezka",
  "stodola",
  "stolek",
  "stopa",
  "storno",
  "stoupat",
  "strach",
  "stres",
  "strhnout",
  "strom",
  "struna",
  "studna",
  "stupnice",
  "stvol",
  "styk",
  "subjekt",
  "subtropy",
  "suchar",
  "sudost",
  "sukno",
  "sundat",
  "sunout",
  "surikata",
  "surovina",
  "svah",
  "svalstvo",
  "svetr",
  "svatba",
  "svazek",
  "svisle",
  "svitek",
  "svoboda",
  "svodidlo",
  "svorka",
  "svrab",
  "sykavka",
  "sykot",
  "synek",
  "synovec",
  "sypat",
  "sypkost",
  "syrovost",
  "sysel",
  "sytost",
  "tabletka",
  "tabule",
  "tahoun",
  "tajemno",
  "tajfun",
  "tajga",
  "tajit",
  "tajnost",
  "taktika",
  "tamhle",
  "tampon",
  "tancovat",
  "tanec",
  "tanker",
  "tapeta",
  "tavenina",
  "tazatel",
  "technika",
  "tehdy",
  "tekutina",
  "telefon",
  "temnota",
  "tendence",
  "tenista",
  "tenor",
  "teplota",
  "tepna",
  "teprve",
  "terapie",
  "termoska",
  "textil",
  "ticho",
  "tiskopis",
  "titulek",
  "tkadlec",
  "tkanina",
  "tlapka",
  "tleskat",
  "tlukot",
  "tlupa",
  "tmel",
  "toaleta",
  "topinka",
  "topol",
  "torzo",
  "touha",
  "toulec",
  "tradice",
  "traktor",
  "tramp",
  "trasa",
  "traverza",
  "trefit",
  "trest",
  "trezor",
  "trhavina",
  "trhlina",
  "trochu",
  "trojice",
  "troska",
  "trouba",
  "trpce",
  "trpitel",
  "trpkost",
  "trubec",
  "truchlit",
  "truhlice",
  "trus",
  "trvat",
  "tudy",
  "tuhnout",
  "tuhost",
  "tundra",
  "turista",
  "turnaj",
  "tuzemsko",
  "tvaroh",
  "tvorba",
  "tvrdost",
  "tvrz",
  "tygr",
  "tykev",
  "ubohost",
  "uboze",
  "ubrat",
  "ubrousek",
  "ubrus",
  "ubytovna",
  "ucho",
  "uctivost",
  "udivit",
  "uhradit",
  "ujednat",
  "ujistit",
  "ujmout",
  "ukazatel",
  "uklidnit",
  "uklonit",
  "ukotvit",
  "ukrojit",
  "ulice",
  "ulita",
  "ulovit",
  "umyvadlo",
  "unavit",
  "uniforma",
  "uniknout",
  "upadnout",
  "uplatnit",
  "uplynout",
  "upoutat",
  "upravit",
  "uran",
  "urazit",
  "usednout",
  "usilovat",
  "usmrtit",
  "usnadnit",
  "usnout",
  "usoudit",
  "ustlat",
  "ustrnout",
  "utahovat",
  "utkat",
  "utlumit",
  "utonout",
  "utopenec",
  "utrousit",
  "uvalit",
  "uvolnit",
  "uvozovka",
  "uzdravit",
  "uzel",
  "uzenina",
  "uzlina",
  "uznat",
  "vagon",
  "valcha",
  "valoun",
  "vana",
  "vandal",
  "vanilka",
  "varan",
  "varhany",
  "varovat",
  "vcelku",
  "vchod",
  "vdova",
  "vedro",
  "vegetace",
  "vejce",
  "velbloud",
  "veletrh",
  "velitel",
  "velmoc",
  "velryba",
  "venkov",
  "veranda",
  "verze",
  "veselka",
  "veskrze",
  "vesnice",
  "vespodu",
  "vesta",
  "veterina",
  "veverka",
  "vibrace",
  "vichr",
  "videohra",
  "vidina",
  "vidle",
  "vila",
  "vinice",
  "viset",
  "vitalita",
  "vize",
  "vizitka",
  "vjezd",
  "vklad",
  "vkus",
  "vlajka",
  "vlak",
  "vlasec",
  "vlevo",
  "vlhkost",
  "vliv",
  "vlnovka",
  "vloupat",
  "vnucovat",
  "vnuk",
  "voda",
  "vodivost",
  "vodoznak",
  "vodstvo",
  "vojensky",
  "vojna",
  "vojsko",
  "volant",
  "volba",
  "volit",
  "volno",
  "voskovka",
  "vozidlo",
  "vozovna",
  "vpravo",
  "vrabec",
  "vracet",
  "vrah",
  "vrata",
  "vrba",
  "vrcholek",
  "vrhat",
  "vrstva",
  "vrtule",
  "vsadit",
  "vstoupit",
  "vstup",
  "vtip",
  "vybavit",
  "vybrat",
  "vychovat",
  "vydat",
  "vydra",
  "vyfotit",
  "vyhledat",
  "vyhnout",
  "vyhodit",
  "vyhradit",
  "vyhubit",
  "vyjasnit",
  "vyjet",
  "vyjmout",
  "vyklopit",
  "vykonat",
  "vylekat",
  "vymazat",
  "vymezit",
  "vymizet",
  "vymyslet",
  "vynechat",
  "vynikat",
  "vynutit",
  "vypadat",
  "vyplatit",
  "vypravit",
  "vypustit",
  "vyrazit",
  "vyrovnat",
  "vyrvat",
  "vyslovit",
  "vysoko",
  "vystavit",
  "vysunout",
  "vysypat",
  "vytasit",
  "vytesat",
  "vytratit",
  "vyvinout",
  "vyvolat",
  "vyvrhel",
  "vyzdobit",
  "vyznat",
  "vzadu",
  "vzbudit",
  "vzchopit",
  "vzdor",
  "vzduch",
  "vzdychat",
  "vzestup",
  "vzhledem",
  "vzkaz",
  "vzlykat",
  "vznik",
  "vzorek",
  "vzpoura",
  "vztah",
  "vztek",
  "xylofon",
  "zabrat",
  "zabydlet",
  "zachovat",
  "zadarmo",
  "zadusit",
  "zafoukat",
  "zahltit",
  "zahodit",
  "zahrada",
  "zahynout",
  "zajatec",
  "zajet",
  "zajistit",
  "zaklepat",
  "zakoupit",
  "zalepit",
  "zamezit",
  "zamotat",
  "zamyslet",
  "zanechat",
  "zanikat",
  "zaplatit",
  "zapojit",
  "zapsat",
  "zarazit",
  "zastavit",
  "zasunout",
  "zatajit",
  "zatemnit",
  "zatknout",
  "zaujmout",
  "zavalit",
  "zavelet",
  "zavinit",
  "zavolat",
  "zavrtat",
  "zazvonit",
  "zbavit",
  "zbrusu",
  "zbudovat",
  "zbytek",
  "zdaleka",
  "zdarma",
  "zdatnost",
  "zdivo",
  "zdobit",
  "zdroj",
  "zdvih",
  "zdymadlo",
  "zelenina",
  "zeman",
  "zemina",
  "zeptat",
  "zezadu",
  "zezdola",
  "zhatit",
  "zhltnout",
  "zhluboka",
  "zhotovit",
  "zhruba",
  "zima",
  "zimnice",
  "zjemnit",
  "zklamat",
  "zkoumat",
  "zkratka",
  "zkumavka",
  "zlato",
  "zlehka",
  "zloba",
  "zlom",
  "zlost",
  "zlozvyk",
  "zmapovat",
  "zmar",
  "zmatek",
  "zmije",
  "zmizet",
  "zmocnit",
  "zmodrat",
  "zmrzlina",
  "zmutovat",
  "znak",
  "znalost",
  "znamenat",
  "znovu",
  "zobrazit",
  "zotavit",
  "zoubek",
  "zoufale",
  "zplodit",
  "zpomalit",
  "zprava",
  "zprostit",
  "zprudka",
  "zprvu",
  "zrada",
  "zranit",
  "zrcadlo",
  "zrnitost",
  "zrno",
  "zrovna",
  "zrychlit",
  "zrzavost",
  "zticha",
  "ztratit",
  "zubovina",
  "zubr",
  "zvednout",
  "zvenku",
  "zvesela",
  "zvon",
  "zvrat",
  "zvukovod",
  "zvyk"
], require$$1 = [
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  ""
], require$$2$1 = [
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  ""
], require$$3 = [
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  ""
], require$$4 = [
  "abaisser",
  "abandon",
  "abdiquer",
  "abeille",
  "abolir",
  "aborder",
  "aboutir",
  "aboyer",
  "abrasif",
  "abreuver",
  "abriter",
  "abroger",
  "abrupt",
  "absence",
  "absolu",
  "absurde",
  "abusif",
  "abyssal",
  "academie",
  "acajou",
  "acarien",
  "accabler",
  "accepter",
  "acclamer",
  "accolade",
  "accroche",
  "accuser",
  "acerbe",
  "achat",
  "acheter",
  "aciduler",
  "acier",
  "acompte",
  "acquerir",
  "acronyme",
  "acteur",
  "actif",
  "actuel",
  "adepte",
  "adequat",
  "adhesif",
  "adjectif",
  "adjuger",
  "admettre",
  "admirer",
  "adopter",
  "adorer",
  "adoucir",
  "adresse",
  "adroit",
  "adulte",
  "adverbe",
  "aerer",
  "aeronef",
  "affaire",
  "affecter",
  "affiche",
  "affreux",
  "affubler",
  "agacer",
  "agencer",
  "agile",
  "agiter",
  "agrafer",
  "agreable",
  "agrume",
  "aider",
  "aiguille",
  "ailier",
  "aimable",
  "aisance",
  "ajouter",
  "ajuster",
  "alarmer",
  "alchimie",
  "alerte",
  "algebre",
  "algue",
  "aliener",
  "aliment",
  "alleger",
  "alliage",
  "allouer",
  "allumer",
  "alourdir",
  "alpaga",
  "altesse",
  "alveole",
  "amateur",
  "ambigu",
  "ambre",
  "amenager",
  "amertume",
  "amidon",
  "amiral",
  "amorcer",
  "amour",
  "amovible",
  "amphibie",
  "ampleur",
  "amusant",
  "analyse",
  "anaphore",
  "anarchie",
  "anatomie",
  "ancien",
  "aneantir",
  "angle",
  "angoisse",
  "anguleux",
  "animal",
  "annexer",
  "annonce",
  "annuel",
  "anodin",
  "anomalie",
  "anonyme",
  "anormal",
  "antenne",
  "antidote",
  "anxieux",
  "apaiser",
  "aperitif",
  "aplanir",
  "apologie",
  "appareil",
  "appeler",
  "apporter",
  "appuyer",
  "aquarium",
  "aqueduc",
  "arbitre",
  "arbuste",
  "ardeur",
  "ardoise",
  "argent",
  "arlequin",
  "armature",
  "armement",
  "armoire",
  "armure",
  "arpenter",
  "arracher",
  "arriver",
  "arroser",
  "arsenic",
  "arteriel",
  "article",
  "aspect",
  "asphalte",
  "aspirer",
  "assaut",
  "asservir",
  "assiette",
  "associer",
  "assurer",
  "asticot",
  "astre",
  "astuce",
  "atelier",
  "atome",
  "atrium",
  "atroce",
  "attaque",
  "attentif",
  "attirer",
  "attraper",
  "aubaine",
  "auberge",
  "audace",
  "audible",
  "augurer",
  "aurore",
  "automne",
  "autruche",
  "avaler",
  "avancer",
  "avarice",
  "avenir",
  "averse",
  "aveugle",
  "aviateur",
  "avide",
  "avion",
  "aviser",
  "avoine",
  "avouer",
  "avril",
  "axial",
  "axiome",
  "badge",
  "bafouer",
  "bagage",
  "baguette",
  "baignade",
  "balancer",
  "balcon",
  "baleine",
  "balisage",
  "bambin",
  "bancaire",
  "bandage",
  "banlieue",
  "banniere",
  "banquier",
  "barbier",
  "baril",
  "baron",
  "barque",
  "barrage",
  "bassin",
  "bastion",
  "bataille",
  "bateau",
  "batterie",
  "baudrier",
  "bavarder",
  "belette",
  "belier",
  "belote",
  "benefice",
  "berceau",
  "berger",
  "berline",
  "bermuda",
  "besace",
  "besogne",
  "betail",
  "beurre",
  "biberon",
  "bicycle",
  "bidule",
  "bijou",
  "bilan",
  "bilingue",
  "billard",
  "binaire",
  "biologie",
  "biopsie",
  "biotype",
  "biscuit",
  "bison",
  "bistouri",
  "bitume",
  "bizarre",
  "blafard",
  "blague",
  "blanchir",
  "blessant",
  "blinder",
  "blond",
  "bloquer",
  "blouson",
  "bobard",
  "bobine",
  "boire",
  "boiser",
  "bolide",
  "bonbon",
  "bondir",
  "bonheur",
  "bonifier",
  "bonus",
  "bordure",
  "borne",
  "botte",
  "boucle",
  "boueux",
  "bougie",
  "boulon",
  "bouquin",
  "bourse",
  "boussole",
  "boutique",
  "boxeur",
  "branche",
  "brasier",
  "brave",
  "brebis",
  "breche",
  "breuvage",
  "bricoler",
  "brigade",
  "brillant",
  "brioche",
  "brique",
  "brochure",
  "broder",
  "bronzer",
  "brousse",
  "broyeur",
  "brume",
  "brusque",
  "brutal",
  "bruyant",
  "buffle",
  "buisson",
  "bulletin",
  "bureau",
  "burin",
  "bustier",
  "butiner",
  "butoir",
  "buvable",
  "buvette",
  "cabanon",
  "cabine",
  "cachette",
  "cadeau",
  "cadre",
  "cafeine",
  "caillou",
  "caisson",
  "calculer",
  "calepin",
  "calibre",
  "calmer",
  "calomnie",
  "calvaire",
  "camarade",
  "camera",
  "camion",
  "campagne",
  "canal",
  "caneton",
  "canon",
  "cantine",
  "canular",
  "capable",
  "caporal",
  "caprice",
  "capsule",
  "capter",
  "capuche",
  "carabine",
  "carbone",
  "caresser",
  "caribou",
  "carnage",
  "carotte",
  "carreau",
  "carton",
  "cascade",
  "casier",
  "casque",
  "cassure",
  "causer",
  "caution",
  "cavalier",
  "caverne",
  "caviar",
  "cedille",
  "ceinture",
  "celeste",
  "cellule",
  "cendrier",
  "censurer",
  "central",
  "cercle",
  "cerebral",
  "cerise",
  "cerner",
  "cerveau",
  "cesser",
  "chagrin",
  "chaise",
  "chaleur",
  "chambre",
  "chance",
  "chapitre",
  "charbon",
  "chasseur",
  "chaton",
  "chausson",
  "chavirer",
  "chemise",
  "chenille",
  "chequier",
  "chercher",
  "cheval",
  "chien",
  "chiffre",
  "chignon",
  "chimere",
  "chiot",
  "chlorure",
  "chocolat",
  "choisir",
  "chose",
  "chouette",
  "chrome",
  "chute",
  "cigare",
  "cigogne",
  "cimenter",
  "cinema",
  "cintrer",
  "circuler",
  "cirer",
  "cirque",
  "citerne",
  "citoyen",
  "citron",
  "civil",
  "clairon",
  "clameur",
  "claquer",
  "classe",
  "clavier",
  "client",
  "cligner",
  "climat",
  "clivage",
  "cloche",
  "clonage",
  "cloporte",
  "cobalt",
  "cobra",
  "cocasse",
  "cocotier",
  "coder",
  "codifier",
  "coffre",
  "cogner",
  "cohesion",
  "coiffer",
  "coincer",
  "colere",
  "colibri",
  "colline",
  "colmater",
  "colonel",
  "combat",
  "comedie",
  "commande",
  "compact",
  "concert",
  "conduire",
  "confier",
  "congeler",
  "connoter",
  "consonne",
  "contact",
  "convexe",
  "copain",
  "copie",
  "corail",
  "corbeau",
  "cordage",
  "corniche",
  "corpus",
  "correct",
  "cortege",
  "cosmique",
  "costume",
  "coton",
  "coude",
  "coupure",
  "courage",
  "couteau",
  "couvrir",
  "coyote",
  "crabe",
  "crainte",
  "cravate",
  "crayon",
  "creature",
  "crediter",
  "cremeux",
  "creuser",
  "crevette",
  "cribler",
  "crier",
  "cristal",
  "critere",
  "croire",
  "croquer",
  "crotale",
  "crucial",
  "cruel",
  "crypter",
  "cubique",
  "cueillir",
  "cuillere",
  "cuisine",
  "cuivre",
  "culminer",
  "cultiver",
  "cumuler",
  "cupide",
  "curatif",
  "curseur",
  "cyanure",
  "cycle",
  "cylindre",
  "cynique",
  "daigner",
  "damier",
  "danger",
  "danseur",
  "dauphin",
  "debattre",
  "debiter",
  "deborder",
  "debrider",
  "debutant",
  "decaler",
  "decembre",
  "dechirer",
  "decider",
  "declarer",
  "decorer",
  "decrire",
  "decupler",
  "dedale",
  "deductif",
  "deesse",
  "defensif",
  "defiler",
  "defrayer",
  "degager",
  "degivrer",
  "deglutir",
  "degrafer",
  "dejeuner",
  "delice",
  "deloger",
  "demander",
  "demeurer",
  "demolir",
  "denicher",
  "denouer",
  "dentelle",
  "denuder",
  "depart",
  "depenser",
  "dephaser",
  "deplacer",
  "deposer",
  "deranger",
  "derober",
  "desastre",
  "descente",
  "desert",
  "designer",
  "desobeir",
  "dessiner",
  "destrier",
  "detacher",
  "detester",
  "detourer",
  "detresse",
  "devancer",
  "devenir",
  "deviner",
  "devoir",
  "diable",
  "dialogue",
  "diamant",
  "dicter",
  "differer",
  "digerer",
  "digital",
  "digne",
  "diluer",
  "dimanche",
  "diminuer",
  "dioxyde",
  "directif",
  "diriger",
  "discuter",
  "disposer",
  "dissiper",
  "distance",
  "divertir",
  "diviser",
  "docile",
  "docteur",
  "dogme",
  "doigt",
  "domaine",
  "domicile",
  "dompter",
  "donateur",
  "donjon",
  "donner",
  "dopamine",
  "dortoir",
  "dorure",
  "dosage",
  "doseur",
  "dossier",
  "dotation",
  "douanier",
  "double",
  "douceur",
  "douter",
  "doyen",
  "dragon",
  "draper",
  "dresser",
  "dribbler",
  "droiture",
  "duperie",
  "duplexe",
  "durable",
  "durcir",
  "dynastie",
  "eblouir",
  "ecarter",
  "echarpe",
  "echelle",
  "eclairer",
  "eclipse",
  "eclore",
  "ecluse",
  "ecole",
  "economie",
  "ecorce",
  "ecouter",
  "ecraser",
  "ecremer",
  "ecrivain",
  "ecrou",
  "ecume",
  "ecureuil",
  "edifier",
  "eduquer",
  "effacer",
  "effectif",
  "effigie",
  "effort",
  "effrayer",
  "effusion",
  "egaliser",
  "egarer",
  "ejecter",
  "elaborer",
  "elargir",
  "electron",
  "elegant",
  "elephant",
  "eleve",
  "eligible",
  "elitisme",
  "eloge",
  "elucider",
  "eluder",
  "emballer",
  "embellir",
  "embryon",
  "emeraude",
  "emission",
  "emmener",
  "emotion",
  "emouvoir",
  "empereur",
  "employer",
  "emporter",
  "emprise",
  "emulsion",
  "encadrer",
  "enchere",
  "enclave",
  "encoche",
  "endiguer",
  "endosser",
  "endroit",
  "enduire",
  "energie",
  "enfance",
  "enfermer",
  "enfouir",
  "engager",
  "engin",
  "englober",
  "enigme",
  "enjamber",
  "enjeu",
  "enlever",
  "ennemi",
  "ennuyeux",
  "enrichir",
  "enrobage",
  "enseigne",
  "entasser",
  "entendre",
  "entier",
  "entourer",
  "entraver",
  "enumerer",
  "envahir",
  "enviable",
  "envoyer",
  "enzyme",
  "eolien",
  "epaissir",
  "epargne",
  "epatant",
  "epaule",
  "epicerie",
  "epidemie",
  "epier",
  "epilogue",
  "epine",
  "episode",
  "epitaphe",
  "epoque",
  "epreuve",
  "eprouver",
  "epuisant",
  "equerre",
  "equipe",
  "eriger",
  "erosion",
  "erreur",
  "eruption",
  "escalier",
  "espadon",
  "espece",
  "espiegle",
  "espoir",
  "esprit",
  "esquiver",
  "essayer",
  "essence",
  "essieu",
  "essorer",
  "estime",
  "estomac",
  "estrade",
  "etagere",
  "etaler",
  "etanche",
  "etatique",
  "eteindre",
  "etendoir",
  "eternel",
  "ethanol",
  "ethique",
  "ethnie",
  "etirer",
  "etoffer",
  "etoile",
  "etonnant",
  "etourdir",
  "etrange",
  "etroit",
  "etude",
  "euphorie",
  "evaluer",
  "evasion",
  "eventail",
  "evidence",
  "eviter",
  "evolutif",
  "evoquer",
  "exact",
  "exagerer",
  "exaucer",
  "exceller",
  "excitant",
  "exclusif",
  "excuse",
  "executer",
  "exemple",
  "exercer",
  "exhaler",
  "exhorter",
  "exigence",
  "exiler",
  "exister",
  "exotique",
  "expedier",
  "explorer",
  "exposer",
  "exprimer",
  "exquis",
  "extensif",
  "extraire",
  "exulter",
  "fable",
  "fabuleux",
  "facette",
  "facile",
  "facture",
  "faiblir",
  "falaise",
  "fameux",
  "famille",
  "farceur",
  "farfelu",
  "farine",
  "farouche",
  "fasciner",
  "fatal",
  "fatigue",
  "faucon",
  "fautif",
  "faveur",
  "favori",
  "febrile",
  "feconder",
  "federer",
  "felin",
  "femme",
  "femur",
  "fendoir",
  "feodal",
  "fermer",
  "feroce",
  "ferveur",
  "festival",
  "feuille",
  "feutre",
  "fevrier",
  "fiasco",
  "ficeler",
  "fictif",
  "fidele",
  "figure",
  "filature",
  "filetage",
  "filiere",
  "filleul",
  "filmer",
  "filou",
  "filtrer",
  "financer",
  "finir",
  "fiole",
  "firme",
  "fissure",
  "fixer",
  "flairer",
  "flamme",
  "flasque",
  "flatteur",
  "fleau",
  "fleche",
  "fleur",
  "flexion",
  "flocon",
  "flore",
  "fluctuer",
  "fluide",
  "fluvial",
  "folie",
  "fonderie",
  "fongible",
  "fontaine",
  "forcer",
  "forgeron",
  "formuler",
  "fortune",
  "fossile",
  "foudre",
  "fougere",
  "fouiller",
  "foulure",
  "fourmi",
  "fragile",
  "fraise",
  "franchir",
  "frapper",
  "frayeur",
  "fregate",
  "freiner",
  "frelon",
  "fremir",
  "frenesie",
  "frere",
  "friable",
  "friction",
  "frisson",
  "frivole",
  "froid",
  "fromage",
  "frontal",
  "frotter",
  "fruit",
  "fugitif",
  "fuite",
  "fureur",
  "furieux",
  "furtif",
  "fusion",
  "futur",
  "gagner",
  "galaxie",
  "galerie",
  "gambader",
  "garantir",
  "gardien",
  "garnir",
  "garrigue",
  "gazelle",
  "gazon",
  "geant",
  "gelatine",
  "gelule",
  "gendarme",
  "general",
  "genie",
  "genou",
  "gentil",
  "geologie",
  "geometre",
  "geranium",
  "germe",
  "gestuel",
  "geyser",
  "gibier",
  "gicler",
  "girafe",
  "givre",
  "glace",
  "glaive",
  "glisser",
  "globe",
  "gloire",
  "glorieux",
  "golfeur",
  "gomme",
  "gonfler",
  "gorge",
  "gorille",
  "goudron",
  "gouffre",
  "goulot",
  "goupille",
  "gourmand",
  "goutte",
  "graduel",
  "graffiti",
  "graine",
  "grand",
  "grappin",
  "gratuit",
  "gravir",
  "grenat",
  "griffure",
  "griller",
  "grimper",
  "grogner",
  "gronder",
  "grotte",
  "groupe",
  "gruger",
  "grutier",
  "gruyere",
  "guepard",
  "guerrier",
  "guide",
  "guimauve",
  "guitare",
  "gustatif",
  "gymnaste",
  "gyrostat",
  "habitude",
  "hachoir",
  "halte",
  "hameau",
  "hangar",
  "hanneton",
  "haricot",
  "harmonie",
  "harpon",
  "hasard",
  "helium",
  "hematome",
  "herbe",
  "herisson",
  "hermine",
  "heron",
  "hesiter",
  "heureux",
  "hiberner",
  "hibou",
  "hilarant",
  "histoire",
  "hiver",
  "homard",
  "hommage",
  "homogene",
  "honneur",
  "honorer",
  "honteux",
  "horde",
  "horizon",
  "horloge",
  "hormone",
  "horrible",
  "houleux",
  "housse",
  "hublot",
  "huileux",
  "humain",
  "humble",
  "humide",
  "humour",
  "hurler",
  "hydromel",
  "hygiene",
  "hymne",
  "hypnose",
  "idylle",
  "ignorer",
  "iguane",
  "illicite",
  "illusion",
  "image",
  "imbiber",
  "imiter",
  "immense",
  "immobile",
  "immuable",
  "impact",
  "imperial",
  "implorer",
  "imposer",
  "imprimer",
  "imputer",
  "incarner",
  "incendie",
  "incident",
  "incliner",
  "incolore",
  "indexer",
  "indice",
  "inductif",
  "inedit",
  "ineptie",
  "inexact",
  "infini",
  "infliger",
  "informer",
  "infusion",
  "ingerer",
  "inhaler",
  "inhiber",
  "injecter",
  "injure",
  "innocent",
  "inoculer",
  "inonder",
  "inscrire",
  "insecte",
  "insigne",
  "insolite",
  "inspirer",
  "instinct",
  "insulter",
  "intact",
  "intense",
  "intime",
  "intrigue",
  "intuitif",
  "inutile",
  "invasion",
  "inventer",
  "inviter",
  "invoquer",
  "ironique",
  "irradier",
  "irreel",
  "irriter",
  "isoler",
  "ivoire",
  "ivresse",
  "jaguar",
  "jaillir",
  "jambe",
  "janvier",
  "jardin",
  "jauger",
  "jaune",
  "javelot",
  "jetable",
  "jeton",
  "jeudi",
  "jeunesse",
  "joindre",
  "joncher",
  "jongler",
  "joueur",
  "jouissif",
  "journal",
  "jovial",
  "joyau",
  "joyeux",
  "jubiler",
  "jugement",
  "junior",
  "jupon",
  "juriste",
  "justice",
  "juteux",
  "juvenile",
  "kayak",
  "kimono",
  "kiosque",
  "label",
  "labial",
  "labourer",
  "lacerer",
  "lactose",
  "lagune",
  "laine",
  "laisser",
  "laitier",
  "lambeau",
  "lamelle",
  "lampe",
  "lanceur",
  "langage",
  "lanterne",
  "lapin",
  "largeur",
  "larme",
  "laurier",
  "lavabo",
  "lavoir",
  "lecture",
  "legal",
  "leger",
  "legume",
  "lessive",
  "lettre",
  "levier",
  "lexique",
  "lezard",
  "liasse",
  "liberer",
  "libre",
  "licence",
  "licorne",
  "liege",
  "lievre",
  "ligature",
  "ligoter",
  "ligue",
  "limer",
  "limite",
  "limonade",
  "limpide",
  "lineaire",
  "lingot",
  "lionceau",
  "liquide",
  "lisiere",
  "lister",
  "lithium",
  "litige",
  "littoral",
  "livreur",
  "logique",
  "lointain",
  "loisir",
  "lombric",
  "loterie",
  "louer",
  "lourd",
  "loutre",
  "louve",
  "loyal",
  "lubie",
  "lucide",
  "lucratif",
  "lueur",
  "lugubre",
  "luisant",
  "lumiere",
  "lunaire",
  "lundi",
  "luron",
  "lutter",
  "luxueux",
  "machine",
  "magasin",
  "magenta",
  "magique",
  "maigre",
  "maillon",
  "maintien",
  "mairie",
  "maison",
  "majorer",
  "malaxer",
  "malefice",
  "malheur",
  "malice",
  "mallette",
  "mammouth",
  "mandater",
  "maniable",
  "manquant",
  "manteau",
  "manuel",
  "marathon",
  "marbre",
  "marchand",
  "mardi",
  "maritime",
  "marqueur",
  "marron",
  "marteler",
  "mascotte",
  "massif",
  "materiel",
  "matiere",
  "matraque",
  "maudire",
  "maussade",
  "mauve",
  "maximal",
  "mechant",
  "meconnu",
  "medaille",
  "medecin",
  "mediter",
  "meduse",
  "meilleur",
  "melange",
  "melodie",
  "membre",
  "memoire",
  "menacer",
  "mener",
  "menhir",
  "mensonge",
  "mentor",
  "mercredi",
  "merite",
  "merle",
  "messager",
  "mesure",
  "metal",
  "meteore",
  "methode",
  "metier",
  "meuble",
  "miauler",
  "microbe",
  "miette",
  "mignon",
  "migrer",
  "milieu",
  "million",
  "mimique",
  "mince",
  "mineral",
  "minimal",
  "minorer",
  "minute",
  "miracle",
  "miroiter",
  "missile",
  "mixte",
  "mobile",
  "moderne",
  "moelleux",
  "mondial",
  "moniteur",
  "monnaie",
  "monotone",
  "monstre",
  "montagne",
  "monument",
  "moqueur",
  "morceau",
  "morsure",
  "mortier",
  "moteur",
  "motif",
  "mouche",
  "moufle",
  "moulin",
  "mousson",
  "mouton",
  "mouvant",
  "multiple",
  "munition",
  "muraille",
  "murene",
  "murmure",
  "muscle",
  "museum",
  "musicien",
  "mutation",
  "muter",
  "mutuel",
  "myriade",
  "myrtille",
  "mystere",
  "mythique",
  "nageur",
  "nappe",
  "narquois",
  "narrer",
  "natation",
  "nation",
  "nature",
  "naufrage",
  "nautique",
  "navire",
  "nebuleux",
  "nectar",
  "nefaste",
  "negation",
  "negliger",
  "negocier",
  "neige",
  "nerveux",
  "nettoyer",
  "neurone",
  "neutron",
  "neveu",
  "niche",
  "nickel",
  "nitrate",
  "niveau",
  "noble",
  "nocif",
  "nocturne",
  "noirceur",
  "noisette",
  "nomade",
  "nombreux",
  "nommer",
  "normatif",
  "notable",
  "notifier",
  "notoire",
  "nourrir",
  "nouveau",
  "novateur",
  "novembre",
  "novice",
  "nuage",
  "nuancer",
  "nuire",
  "nuisible",
  "numero",
  "nuptial",
  "nuque",
  "nutritif",
  "obeir",
  "objectif",
  "obliger",
  "obscur",
  "observer",
  "obstacle",
  "obtenir",
  "obturer",
  "occasion",
  "occuper",
  "ocean",
  "octobre",
  "octroyer",
  "octupler",
  "oculaire",
  "odeur",
  "odorant",
  "offenser",
  "officier",
  "offrir",
  "ogive",
  "oiseau",
  "oisillon",
  "olfactif",
  "olivier",
  "ombrage",
  "omettre",
  "onctueux",
  "onduler",
  "onereux",
  "onirique",
  "opale",
  "opaque",
  "operer",
  "opinion",
  "opportun",
  "opprimer",
  "opter",
  "optique",
  "orageux",
  "orange",
  "orbite",
  "ordonner",
  "oreille",
  "organe",
  "orgueil",
  "orifice",
  "ornement",
  "orque",
  "ortie",
  "osciller",
  "osmose",
  "ossature",
  "otarie",
  "ouragan",
  "ourson",
  "outil",
  "outrager",
  "ouvrage",
  "ovation",
  "oxyde",
  "oxygene",
  "ozone",
  "paisible",
  "palace",
  "palmares",
  "palourde",
  "palper",
  "panache",
  "panda",
  "pangolin",
  "paniquer",
  "panneau",
  "panorama",
  "pantalon",
  "papaye",
  "papier",
  "papoter",
  "papyrus",
  "paradoxe",
  "parcelle",
  "paresse",
  "parfumer",
  "parler",
  "parole",
  "parrain",
  "parsemer",
  "partager",
  "parure",
  "parvenir",
  "passion",
  "pasteque",
  "paternel",
  "patience",
  "patron",
  "pavillon",
  "pavoiser",
  "payer",
  "paysage",
  "peigne",
  "peintre",
  "pelage",
  "pelican",
  "pelle",
  "pelouse",
  "peluche",
  "pendule",
  "penetrer",
  "penible",
  "pensif",
  "penurie",
  "pepite",
  "peplum",
  "perdrix",
  "perforer",
  "periode",
  "permuter",
  "perplexe",
  "persil",
  "perte",
  "peser",
  "petale",
  "petit",
  "petrir",
  "peuple",
  "pharaon",
  "phobie",
  "phoque",
  "photon",
  "phrase",
  "physique",
  "piano",
  "pictural",
  "piece",
  "pierre",
  "pieuvre",
  "pilote",
  "pinceau",
  "pipette",
  "piquer",
  "pirogue",
  "piscine",
  "piston",
  "pivoter",
  "pixel",
  "pizza",
  "placard",
  "plafond",
  "plaisir",
  "planer",
  "plaque",
  "plastron",
  "plateau",
  "pleurer",
  "plexus",
  "pliage",
  "plomb",
  "plonger",
  "pluie",
  "plumage",
  "pochette",
  "poesie",
  "poete",
  "pointe",
  "poirier",
  "poisson",
  "poivre",
  "polaire",
  "policier",
  "pollen",
  "polygone",
  "pommade",
  "pompier",
  "ponctuel",
  "ponderer",
  "poney",
  "portique",
  "position",
  "posseder",
  "posture",
  "potager",
  "poteau",
  "potion",
  "pouce",
  "poulain",
  "poumon",
  "pourpre",
  "poussin",
  "pouvoir",
  "prairie",
  "pratique",
  "precieux",
  "predire",
  "prefixe",
  "prelude",
  "prenom",
  "presence",
  "pretexte",
  "prevoir",
  "primitif",
  "prince",
  "prison",
  "priver",
  "probleme",
  "proceder",
  "prodige",
  "profond",
  "progres",
  "proie",
  "projeter",
  "prologue",
  "promener",
  "propre",
  "prospere",
  "proteger",
  "prouesse",
  "proverbe",
  "prudence",
  "pruneau",
  "psychose",
  "public",
  "puceron",
  "puiser",
  "pulpe",
  "pulsar",
  "punaise",
  "punitif",
  "pupitre",
  "purifier",
  "puzzle",
  "pyramide",
  "quasar",
  "querelle",
  "question",
  "quietude",
  "quitter",
  "quotient",
  "racine",
  "raconter",
  "radieux",
  "ragondin",
  "raideur",
  "raisin",
  "ralentir",
  "rallonge",
  "ramasser",
  "rapide",
  "rasage",
  "ratisser",
  "ravager",
  "ravin",
  "rayonner",
  "reactif",
  "reagir",
  "realiser",
  "reanimer",
  "recevoir",
  "reciter",
  "reclamer",
  "recolter",
  "recruter",
  "reculer",
  "recycler",
  "rediger",
  "redouter",
  "refaire",
  "reflexe",
  "reformer",
  "refrain",
  "refuge",
  "regalien",
  "region",
  "reglage",
  "regulier",
  "reiterer",
  "rejeter",
  "rejouer",
  "relatif",
  "relever",
  "relief",
  "remarque",
  "remede",
  "remise",
  "remonter",
  "remplir",
  "remuer",
  "renard",
  "renfort",
  "renifler",
  "renoncer",
  "rentrer",
  "renvoi",
  "replier",
  "reporter",
  "reprise",
  "reptile",
  "requin",
  "reserve",
  "resineux",
  "resoudre",
  "respect",
  "rester",
  "resultat",
  "retablir",
  "retenir",
  "reticule",
  "retomber",
  "retracer",
  "reunion",
  "reussir",
  "revanche",
  "revivre",
  "revolte",
  "revulsif",
  "richesse",
  "rideau",
  "rieur",
  "rigide",
  "rigoler",
  "rincer",
  "riposter",
  "risible",
  "risque",
  "rituel",
  "rival",
  "riviere",
  "rocheux",
  "romance",
  "rompre",
  "ronce",
  "rondin",
  "roseau",
  "rosier",
  "rotatif",
  "rotor",
  "rotule",
  "rouge",
  "rouille",
  "rouleau",
  "routine",
  "royaume",
  "ruban",
  "rubis",
  "ruche",
  "ruelle",
  "rugueux",
  "ruiner",
  "ruisseau",
  "ruser",
  "rustique",
  "rythme",
  "sabler",
  "saboter",
  "sabre",
  "sacoche",
  "safari",
  "sagesse",
  "saisir",
  "salade",
  "salive",
  "salon",
  "saluer",
  "samedi",
  "sanction",
  "sanglier",
  "sarcasme",
  "sardine",
  "saturer",
  "saugrenu",
  "saumon",
  "sauter",
  "sauvage",
  "savant",
  "savonner",
  "scalpel",
  "scandale",
  "scelerat",
  "scenario",
  "sceptre",
  "schema",
  "science",
  "scinder",
  "score",
  "scrutin",
  "sculpter",
  "seance",
  "secable",
  "secher",
  "secouer",
  "secreter",
  "sedatif",
  "seduire",
  "seigneur",
  "sejour",
  "selectif",
  "semaine",
  "sembler",
  "semence",
  "seminal",
  "senateur",
  "sensible",
  "sentence",
  "separer",
  "sequence",
  "serein",
  "sergent",
  "serieux",
  "serrure",
  "serum",
  "service",
  "sesame",
  "sevir",
  "sevrage",
  "sextuple",
  "sideral",
  "siecle",
  "sieger",
  "siffler",
  "sigle",
  "signal",
  "silence",
  "silicium",
  "simple",
  "sincere",
  "sinistre",
  "siphon",
  "sirop",
  "sismique",
  "situer",
  "skier",
  "social",
  "socle",
  "sodium",
  "soigneux",
  "soldat",
  "soleil",
  "solitude",
  "soluble",
  "sombre",
  "sommeil",
  "somnoler",
  "sonde",
  "songeur",
  "sonnette",
  "sonore",
  "sorcier",
  "sortir",
  "sosie",
  "sottise",
  "soucieux",
  "soudure",
  "souffle",
  "soulever",
  "soupape",
  "source",
  "soutirer",
  "souvenir",
  "spacieux",
  "spatial",
  "special",
  "sphere",
  "spiral",
  "stable",
  "station",
  "sternum",
  "stimulus",
  "stipuler",
  "strict",
  "studieux",
  "stupeur",
  "styliste",
  "sublime",
  "substrat",
  "subtil",
  "subvenir",
  "succes",
  "sucre",
  "suffixe",
  "suggerer",
  "suiveur",
  "sulfate",
  "superbe",
  "supplier",
  "surface",
  "suricate",
  "surmener",
  "surprise",
  "sursaut",
  "survie",
  "suspect",
  "syllabe",
  "symbole",
  "symetrie",
  "synapse",
  "syntaxe",
  "systeme",
  "tabac",
  "tablier",
  "tactile",
  "tailler",
  "talent",
  "talisman",
  "talonner",
  "tambour",
  "tamiser",
  "tangible",
  "tapis",
  "taquiner",
  "tarder",
  "tarif",
  "tartine",
  "tasse",
  "tatami",
  "tatouage",
  "taupe",
  "taureau",
  "taxer",
  "temoin",
  "temporel",
  "tenaille",
  "tendre",
  "teneur",
  "tenir",
  "tension",
  "terminer",
  "terne",
  "terrible",
  "tetine",
  "texte",
  "theme",
  "theorie",
  "therapie",
  "thorax",
  "tibia",
  "tiede",
  "timide",
  "tirelire",
  "tiroir",
  "tissu",
  "titane",
  "titre",
  "tituber",
  "toboggan",
  "tolerant",
  "tomate",
  "tonique",
  "tonneau",
  "toponyme",
  "torche",
  "tordre",
  "tornade",
  "torpille",
  "torrent",
  "torse",
  "tortue",
  "totem",
  "toucher",
  "tournage",
  "tousser",
  "toxine",
  "traction",
  "trafic",
  "tragique",
  "trahir",
  "train",
  "trancher",
  "travail",
  "trefle",
  "tremper",
  "tresor",
  "treuil",
  "triage",
  "tribunal",
  "tricoter",
  "trilogie",
  "triomphe",
  "tripler",
  "triturer",
  "trivial",
  "trombone",
  "tronc",
  "tropical",
  "troupeau",
  "tuile",
  "tulipe",
  "tumulte",
  "tunnel",
  "turbine",
  "tuteur",
  "tutoyer",
  "tuyau",
  "tympan",
  "typhon",
  "typique",
  "tyran",
  "ubuesque",
  "ultime",
  "ultrason",
  "unanime",
  "unifier",
  "union",
  "unique",
  "unitaire",
  "univers",
  "uranium",
  "urbain",
  "urticant",
  "usage",
  "usine",
  "usuel",
  "usure",
  "utile",
  "utopie",
  "vacarme",
  "vaccin",
  "vagabond",
  "vague",
  "vaillant",
  "vaincre",
  "vaisseau",
  "valable",
  "valise",
  "vallon",
  "valve",
  "vampire",
  "vanille",
  "vapeur",
  "varier",
  "vaseux",
  "vassal",
  "vaste",
  "vecteur",
  "vedette",
  "vegetal",
  "vehicule",
  "veinard",
  "veloce",
  "vendredi",
  "venerer",
  "venger",
  "venimeux",
  "ventouse",
  "verdure",
  "verin",
  "vernir",
  "verrou",
  "verser",
  "vertu",
  "veston",
  "veteran",
  "vetuste",
  "vexant",
  "vexer",
  "viaduc",
  "viande",
  "victoire",
  "vidange",
  "video",
  "vignette",
  "vigueur",
  "vilain",
  "village",
  "vinaigre",
  "violon",
  "vipere",
  "virement",
  "virtuose",
  "virus",
  "visage",
  "viseur",
  "vision",
  "visqueux",
  "visuel",
  "vital",
  "vitesse",
  "viticole",
  "vitrine",
  "vivace",
  "vivipare",
  "vocation",
  "voguer",
  "voile",
  "voisin",
  "voiture",
  "volaille",
  "volcan",
  "voltiger",
  "volume",
  "vorace",
  "vortex",
  "voter",
  "vouloir",
  "voyage",
  "voyelle",
  "wagon",
  "xenon",
  "yacht",
  "zebre",
  "zenith",
  "zeste",
  "zoologie"
], require$$5 = [
  "abaco",
  "abbaglio",
  "abbinato",
  "abete",
  "abisso",
  "abolire",
  "abrasivo",
  "abrogato",
  "accadere",
  "accenno",
  "accusato",
  "acetone",
  "achille",
  "acido",
  "acqua",
  "acre",
  "acrilico",
  "acrobata",
  "acuto",
  "adagio",
  "addebito",
  "addome",
  "adeguato",
  "aderire",
  "adipe",
  "adottare",
  "adulare",
  "affabile",
  "affetto",
  "affisso",
  "affranto",
  "aforisma",
  "afoso",
  "africano",
  "agave",
  "agente",
  "agevole",
  "aggancio",
  "agire",
  "agitare",
  "agonismo",
  "agricolo",
  "agrumeto",
  "aguzzo",
  "alabarda",
  "alato",
  "albatro",
  "alberato",
  "albo",
  "albume",
  "alce",
  "alcolico",
  "alettone",
  "alfa",
  "algebra",
  "aliante",
  "alibi",
  "alimento",
  "allagato",
  "allegro",
  "allievo",
  "allodola",
  "allusivo",
  "almeno",
  "alogeno",
  "alpaca",
  "alpestre",
  "altalena",
  "alterno",
  "alticcio",
  "altrove",
  "alunno",
  "alveolo",
  "alzare",
  "amalgama",
  "amanita",
  "amarena",
  "ambito",
  "ambrato",
  "ameba",
  "america",
  "ametista",
  "amico",
  "ammasso",
  "ammenda",
  "ammirare",
  "ammonito",
  "amore",
  "ampio",
  "ampliare",
  "amuleto",
  "anacardo",
  "anagrafe",
  "analista",
  "anarchia",
  "anatra",
  "anca",
  "ancella",
  "ancora",
  "andare",
  "andrea",
  "anello",
  "angelo",
  "angolare",
  "angusto",
  "anima",
  "annegare",
  "annidato",
  "anno",
  "annuncio",
  "anonimo",
  "anticipo",
  "anzi",
  "apatico",
  "apertura",
  "apode",
  "apparire",
  "appetito",
  "appoggio",
  "approdo",
  "appunto",
  "aprile",
  "arabica",
  "arachide",
  "aragosta",
  "araldica",
  "arancio",
  "aratura",
  "arazzo",
  "arbitro",
  "archivio",
  "ardito",
  "arenile",
  "argento",
  "argine",
  "arguto",
  "aria",
  "armonia",
  "arnese",
  "arredato",
  "arringa",
  "arrosto",
  "arsenico",
  "arso",
  "artefice",
  "arzillo",
  "asciutto",
  "ascolto",
  "asepsi",
  "asettico",
  "asfalto",
  "asino",
  "asola",
  "aspirato",
  "aspro",
  "assaggio",
  "asse",
  "assoluto",
  "assurdo",
  "asta",
  "astenuto",
  "astice",
  "astratto",
  "atavico",
  "ateismo",
  "atomico",
  "atono",
  "attesa",
  "attivare",
  "attorno",
  "attrito",
  "attuale",
  "ausilio",
  "austria",
  "autista",
  "autonomo",
  "autunno",
  "avanzato",
  "avere",
  "avvenire",
  "avviso",
  "avvolgere",
  "azione",
  "azoto",
  "azzimo",
  "azzurro",
  "babele",
  "baccano",
  "bacino",
  "baco",
  "badessa",
  "badilata",
  "bagnato",
  "baita",
  "balcone",
  "baldo",
  "balena",
  "ballata",
  "balzano",
  "bambino",
  "bandire",
  "baraonda",
  "barbaro",
  "barca",
  "baritono",
  "barlume",
  "barocco",
  "basilico",
  "basso",
  "batosta",
  "battuto",
  "baule",
  "bava",
  "bavosa",
  "becco",
  "beffa",
  "belgio",
  "belva",
  "benda",
  "benevole",
  "benigno",
  "benzina",
  "bere",
  "berlina",
  "beta",
  "bibita",
  "bici",
  "bidone",
  "bifido",
  "biga",
  "bilancia",
  "bimbo",
  "binocolo",
  "biologo",
  "bipede",
  "bipolare",
  "birbante",
  "birra",
  "biscotto",
  "bisesto",
  "bisnonno",
  "bisonte",
  "bisturi",
  "bizzarro",
  "blando",
  "blatta",
  "bollito",
  "bonifico",
  "bordo",
  "bosco",
  "botanico",
  "bottino",
  "bozzolo",
  "braccio",
  "bradipo",
  "brama",
  "branca",
  "bravura",
  "bretella",
  "brevetto",
  "brezza",
  "briglia",
  "brillante",
  "brindare",
  "broccolo",
  "brodo",
  "bronzina",
  "brullo",
  "bruno",
  "bubbone",
  "buca",
  "budino",
  "buffone",
  "buio",
  "bulbo",
  "buono",
  "burlone",
  "burrasca",
  "bussola",
  "busta",
  "cadetto",
  "caduco",
  "calamaro",
  "calcolo",
  "calesse",
  "calibro",
  "calmo",
  "caloria",
  "cambusa",
  "camerata",
  "camicia",
  "cammino",
  "camola",
  "campale",
  "canapa",
  "candela",
  "cane",
  "canino",
  "canotto",
  "cantina",
  "capace",
  "capello",
  "capitolo",
  "capogiro",
  "cappero",
  "capra",
  "capsula",
  "carapace",
  "carcassa",
  "cardo",
  "carisma",
  "carovana",
  "carretto",
  "cartolina",
  "casaccio",
  "cascata",
  "caserma",
  "caso",
  "cassone",
  "castello",
  "casuale",
  "catasta",
  "catena",
  "catrame",
  "cauto",
  "cavillo",
  "cedibile",
  "cedrata",
  "cefalo",
  "celebre",
  "cellulare",
  "cena",
  "cenone",
  "centesimo",
  "ceramica",
  "cercare",
  "certo",
  "cerume",
  "cervello",
  "cesoia",
  "cespo",
  "ceto",
  "chela",
  "chiaro",
  "chicca",
  "chiedere",
  "chimera",
  "china",
  "chirurgo",
  "chitarra",
  "ciao",
  "ciclismo",
  "cifrare",
  "cigno",
  "cilindro",
  "ciottolo",
  "circa",
  "cirrosi",
  "citrico",
  "cittadino",
  "ciuffo",
  "civetta",
  "civile",
  "classico",
  "clinica",
  "cloro",
  "cocco",
  "codardo",
  "codice",
  "coerente",
  "cognome",
  "collare",
  "colmato",
  "colore",
  "colposo",
  "coltivato",
  "colza",
  "coma",
  "cometa",
  "commando",
  "comodo",
  "computer",
  "comune",
  "conciso",
  "condurre",
  "conferma",
  "congelare",
  "coniuge",
  "connesso",
  "conoscere",
  "consumo",
  "continuo",
  "convegno",
  "coperto",
  "copione",
  "coppia",
  "copricapo",
  "corazza",
  "cordata",
  "coricato",
  "cornice",
  "corolla",
  "corpo",
  "corredo",
  "corsia",
  "cortese",
  "cosmico",
  "costante",
  "cottura",
  "covato",
  "cratere",
  "cravatta",
  "creato",
  "credere",
  "cremoso",
  "crescita",
  "creta",
  "criceto",
  "crinale",
  "crisi",
  "critico",
  "croce",
  "cronaca",
  "crostata",
  "cruciale",
  "crusca",
  "cucire",
  "cuculo",
  "cugino",
  "cullato",
  "cupola",
  "curatore",
  "cursore",
  "curvo",
  "cuscino",
  "custode",
  "dado",
  "daino",
  "dalmata",
  "damerino",
  "daniela",
  "dannoso",
  "danzare",
  "datato",
  "davanti",
  "davvero",
  "debutto",
  "decennio",
  "deciso",
  "declino",
  "decollo",
  "decreto",
  "dedicato",
  "definito",
  "deforme",
  "degno",
  "delegare",
  "delfino",
  "delirio",
  "delta",
  "demenza",
  "denotato",
  "dentro",
  "deposito",
  "derapata",
  "derivare",
  "deroga",
  "descritto",
  "deserto",
  "desiderio",
  "desumere",
  "detersivo",
  "devoto",
  "diametro",
  "dicembre",
  "diedro",
  "difeso",
  "diffuso",
  "digerire",
  "digitale",
  "diluvio",
  "dinamico",
  "dinnanzi",
  "dipinto",
  "diploma",
  "dipolo",
  "diradare",
  "dire",
  "dirotto",
  "dirupo",
  "disagio",
  "discreto",
  "disfare",
  "disgelo",
  "disposto",
  "distanza",
  "disumano",
  "dito",
  "divano",
  "divelto",
  "dividere",
  "divorato",
  "doblone",
  "docente",
  "doganale",
  "dogma",
  "dolce",
  "domato",
  "domenica",
  "dominare",
  "dondolo",
  "dono",
  "dormire",
  "dote",
  "dottore",
  "dovuto",
  "dozzina",
  "drago",
  "druido",
  "dubbio",
  "dubitare",
  "ducale",
  "duna",
  "duomo",
  "duplice",
  "duraturo",
  "ebano",
  "eccesso",
  "ecco",
  "eclissi",
  "economia",
  "edera",
  "edicola",
  "edile",
  "editoria",
  "educare",
  "egemonia",
  "egli",
  "egoismo",
  "egregio",
  "elaborato",
  "elargire",
  "elegante",
  "elencato",
  "eletto",
  "elevare",
  "elfico",
  "elica",
  "elmo",
  "elsa",
  "eluso",
  "emanato",
  "emblema",
  "emesso",
  "emiro",
  "emotivo",
  "emozione",
  "empirico",
  "emulo",
  "endemico",
  "enduro",
  "energia",
  "enfasi",
  "enoteca",
  "entrare",
  "enzima",
  "epatite",
  "epilogo",
  "episodio",
  "epocale",
  "eppure",
  "equatore",
  "erario",
  "erba",
  "erboso",
  "erede",
  "eremita",
  "erigere",
  "ermetico",
  "eroe",
  "erosivo",
  "errante",
  "esagono",
  "esame",
  "esanime",
  "esaudire",
  "esca",
  "esempio",
  "esercito",
  "esibito",
  "esigente",
  "esistere",
  "esito",
  "esofago",
  "esortato",
  "esoso",
  "espanso",
  "espresso",
  "essenza",
  "esso",
  "esteso",
  "estimare",
  "estonia",
  "estroso",
  "esultare",
  "etilico",
  "etnico",
  "etrusco",
  "etto",
  "euclideo",
  "europa",
  "evaso",
  "evidenza",
  "evitato",
  "evoluto",
  "evviva",
  "fabbrica",
  "faccenda",
  "fachiro",
  "falco",
  "famiglia",
  "fanale",
  "fanfara",
  "fango",
  "fantasma",
  "fare",
  "farfalla",
  "farinoso",
  "farmaco",
  "fascia",
  "fastoso",
  "fasullo",
  "faticare",
  "fato",
  "favoloso",
  "febbre",
  "fecola",
  "fede",
  "fegato",
  "felpa",
  "feltro",
  "femmina",
  "fendere",
  "fenomeno",
  "fermento",
  "ferro",
  "fertile",
  "fessura",
  "festivo",
  "fetta",
  "feudo",
  "fiaba",
  "fiducia",
  "fifa",
  "figurato",
  "filo",
  "finanza",
  "finestra",
  "finire",
  "fiore",
  "fiscale",
  "fisico",
  "fiume",
  "flacone",
  "flamenco",
  "flebo",
  "flemma",
  "florido",
  "fluente",
  "fluoro",
  "fobico",
  "focaccia",
  "focoso",
  "foderato",
  "foglio",
  "folata",
  "folclore",
  "folgore",
  "fondente",
  "fonetico",
  "fonia",
  "fontana",
  "forbito",
  "forchetta",
  "foresta",
  "formica",
  "fornaio",
  "foro",
  "fortezza",
  "forzare",
  "fosfato",
  "fosso",
  "fracasso",
  "frana",
  "frassino",
  "fratello",
  "freccetta",
  "frenata",
  "fresco",
  "frigo",
  "frollino",
  "fronde",
  "frugale",
  "frutta",
  "fucilata",
  "fucsia",
  "fuggente",
  "fulmine",
  "fulvo",
  "fumante",
  "fumetto",
  "fumoso",
  "fune",
  "funzione",
  "fuoco",
  "furbo",
  "furgone",
  "furore",
  "fuso",
  "futile",
  "gabbiano",
  "gaffe",
  "galateo",
  "gallina",
  "galoppo",
  "gambero",
  "gamma",
  "garanzia",
  "garbo",
  "garofano",
  "garzone",
  "gasdotto",
  "gasolio",
  "gastrico",
  "gatto",
  "gaudio",
  "gazebo",
  "gazzella",
  "geco",
  "gelatina",
  "gelso",
  "gemello",
  "gemmato",
  "gene",
  "genitore",
  "gennaio",
  "genotipo",
  "gergo",
  "ghepardo",
  "ghiaccio",
  "ghisa",
  "giallo",
  "gilda",
  "ginepro",
  "giocare",
  "gioiello",
  "giorno",
  "giove",
  "girato",
  "girone",
  "gittata",
  "giudizio",
  "giurato",
  "giusto",
  "globulo",
  "glutine",
  "gnomo",
  "gobba",
  "golf",
  "gomito",
  "gommone",
  "gonfio",
  "gonna",
  "governo",
  "gracile",
  "grado",
  "grafico",
  "grammo",
  "grande",
  "grattare",
  "gravoso",
  "grazia",
  "greca",
  "gregge",
  "grifone",
  "grigio",
  "grinza",
  "grotta",
  "gruppo",
  "guadagno",
  "guaio",
  "guanto",
  "guardare",
  "gufo",
  "guidare",
  "ibernato",
  "icona",
  "identico",
  "idillio",
  "idolo",
  "idra",
  "idrico",
  "idrogeno",
  "igiene",
  "ignaro",
  "ignorato",
  "ilare",
  "illeso",
  "illogico",
  "illudere",
  "imballo",
  "imbevuto",
  "imbocco",
  "imbuto",
  "immane",
  "immerso",
  "immolato",
  "impacco",
  "impeto",
  "impiego",
  "importo",
  "impronta",
  "inalare",
  "inarcare",
  "inattivo",
  "incanto",
  "incendio",
  "inchino",
  "incisivo",
  "incluso",
  "incontro",
  "incrocio",
  "incubo",
  "indagine",
  "india",
  "indole",
  "inedito",
  "infatti",
  "infilare",
  "inflitto",
  "ingaggio",
  "ingegno",
  "inglese",
  "ingordo",
  "ingrosso",
  "innesco",
  "inodore",
  "inoltrare",
  "inondato",
  "insano",
  "insetto",
  "insieme",
  "insonnia",
  "insulina",
  "intasato",
  "intero",
  "intonaco",
  "intuito",
  "inumidire",
  "invalido",
  "invece",
  "invito",
  "iperbole",
  "ipnotico",
  "ipotesi",
  "ippica",
  "iride",
  "irlanda",
  "ironico",
  "irrigato",
  "irrorare",
  "isolato",
  "isotopo",
  "isterico",
  "istituto",
  "istrice",
  "italia",
  "iterare",
  "labbro",
  "labirinto",
  "lacca",
  "lacerato",
  "lacrima",
  "lacuna",
  "laddove",
  "lago",
  "lampo",
  "lancetta",
  "lanterna",
  "lardoso",
  "larga",
  "laringe",
  "lastra",
  "latenza",
  "latino",
  "lattuga",
  "lavagna",
  "lavoro",
  "legale",
  "leggero",
  "lembo",
  "lentezza",
  "lenza",
  "leone",
  "lepre",
  "lesivo",
  "lessato",
  "lesto",
  "letterale",
  "leva",
  "levigato",
  "libero",
  "lido",
  "lievito",
  "lilla",
  "limatura",
  "limitare",
  "limpido",
  "lineare",
  "lingua",
  "liquido",
  "lira",
  "lirica",
  "lisca",
  "lite",
  "litigio",
  "livrea",
  "locanda",
  "lode",
  "logica",
  "lombare",
  "londra",
  "longevo",
  "loquace",
  "lorenzo",
  "loto",
  "lotteria",
  "luce",
  "lucidato",
  "lumaca",
  "luminoso",
  "lungo",
  "lupo",
  "luppolo",
  "lusinga",
  "lusso",
  "lutto",
  "macabro",
  "macchina",
  "macero",
  "macinato",
  "madama",
  "magico",
  "maglia",
  "magnete",
  "magro",
  "maiolica",
  "malafede",
  "malgrado",
  "malinteso",
  "malsano",
  "malto",
  "malumore",
  "mana",
  "mancia",
  "mandorla",
  "mangiare",
  "manifesto",
  "mannaro",
  "manovra",
  "mansarda",
  "mantide",
  "manubrio",
  "mappa",
  "maratona",
  "marcire",
  "maretta",
  "marmo",
  "marsupio",
  "maschera",
  "massaia",
  "mastino",
  "materasso",
  "matricola",
  "mattone",
  "maturo",
  "mazurca",
  "meandro",
  "meccanico",
  "mecenate",
  "medesimo",
  "meditare",
  "mega",
  "melassa",
  "melis",
  "melodia",
  "meninge",
  "meno",
  "mensola",
  "mercurio",
  "merenda",
  "merlo",
  "meschino",
  "mese",
  "messere",
  "mestolo",
  "metallo",
  "metodo",
  "mettere",
  "miagolare",
  "mica",
  "micelio",
  "michele",
  "microbo",
  "midollo",
  "miele",
  "migliore",
  "milano",
  "milite",
  "mimosa",
  "minerale",
  "mini",
  "minore",
  "mirino",
  "mirtillo",
  "miscela",
  "missiva",
  "misto",
  "misurare",
  "mitezza",
  "mitigare",
  "mitra",
  "mittente",
  "mnemonico",
  "modello",
  "modifica",
  "modulo",
  "mogano",
  "mogio",
  "mole",
  "molosso",
  "monastero",
  "monco",
  "mondina",
  "monetario",
  "monile",
  "monotono",
  "monsone",
  "montato",
  "monviso",
  "mora",
  "mordere",
  "morsicato",
  "mostro",
  "motivato",
  "motosega",
  "motto",
  "movenza",
  "movimento",
  "mozzo",
  "mucca",
  "mucosa",
  "muffa",
  "mughetto",
  "mugnaio",
  "mulatto",
  "mulinello",
  "multiplo",
  "mummia",
  "munto",
  "muovere",
  "murale",
  "musa",
  "muscolo",
  "musica",
  "mutevole",
  "muto",
  "nababbo",
  "nafta",
  "nanometro",
  "narciso",
  "narice",
  "narrato",
  "nascere",
  "nastrare",
  "naturale",
  "nautica",
  "naviglio",
  "nebulosa",
  "necrosi",
  "negativo",
  "negozio",
  "nemmeno",
  "neofita",
  "neretto",
  "nervo",
  "nessuno",
  "nettuno",
  "neutrale",
  "neve",
  "nevrotico",
  "nicchia",
  "ninfa",
  "nitido",
  "nobile",
  "nocivo",
  "nodo",
  "nome",
  "nomina",
  "nordico",
  "normale",
  "norvegese",
  "nostrano",
  "notare",
  "notizia",
  "notturno",
  "novella",
  "nucleo",
  "nulla",
  "numero",
  "nuovo",
  "nutrire",
  "nuvola",
  "nuziale",
  "oasi",
  "obbedire",
  "obbligo",
  "obelisco",
  "oblio",
  "obolo",
  "obsoleto",
  "occasione",
  "occhio",
  "occidente",
  "occorrere",
  "occultare",
  "ocra",
  "oculato",
  "odierno",
  "odorare",
  "offerta",
  "offrire",
  "offuscato",
  "oggetto",
  "oggi",
  "ognuno",
  "olandese",
  "olfatto",
  "oliato",
  "oliva",
  "ologramma",
  "oltre",
  "omaggio",
  "ombelico",
  "ombra",
  "omega",
  "omissione",
  "ondoso",
  "onere",
  "onice",
  "onnivoro",
  "onorevole",
  "onta",
  "operato",
  "opinione",
  "opposto",
  "oracolo",
  "orafo",
  "ordine",
  "orecchino",
  "orefice",
  "orfano",
  "organico",
  "origine",
  "orizzonte",
  "orma",
  "ormeggio",
  "ornativo",
  "orologio",
  "orrendo",
  "orribile",
  "ortensia",
  "ortica",
  "orzata",
  "orzo",
  "osare",
  "oscurare",
  "osmosi",
  "ospedale",
  "ospite",
  "ossa",
  "ossidare",
  "ostacolo",
  "oste",
  "otite",
  "otre",
  "ottagono",
  "ottimo",
  "ottobre",
  "ovale",
  "ovest",
  "ovino",
  "oviparo",
  "ovocito",
  "ovunque",
  "ovviare",
  "ozio",
  "pacchetto",
  "pace",
  "pacifico",
  "padella",
  "padrone",
  "paese",
  "paga",
  "pagina",
  "palazzina",
  "palesare",
  "pallido",
  "palo",
  "palude",
  "pandoro",
  "pannello",
  "paolo",
  "paonazzo",
  "paprica",
  "parabola",
  "parcella",
  "parere",
  "pargolo",
  "pari",
  "parlato",
  "parola",
  "partire",
  "parvenza",
  "parziale",
  "passivo",
  "pasticca",
  "patacca",
  "patologia",
  "pattume",
  "pavone",
  "peccato",
  "pedalare",
  "pedonale",
  "peggio",
  "peloso",
  "penare",
  "pendice",
  "penisola",
  "pennuto",
  "penombra",
  "pensare",
  "pentola",
  "pepe",
  "pepita",
  "perbene",
  "percorso",
  "perdonato",
  "perforare",
  "pergamena",
  "periodo",
  "permesso",
  "perno",
  "perplesso",
  "persuaso",
  "pertugio",
  "pervaso",
  "pesatore",
  "pesista",
  "peso",
  "pestifero",
  "petalo",
  "pettine",
  "petulante",
  "pezzo",
  "piacere",
  "pianta",
  "piattino",
  "piccino",
  "picozza",
  "piega",
  "pietra",
  "piffero",
  "pigiama",
  "pigolio",
  "pigro",
  "pila",
  "pilifero",
  "pillola",
  "pilota",
  "pimpante",
  "pineta",
  "pinna",
  "pinolo",
  "pioggia",
  "piombo",
  "piramide",
  "piretico",
  "pirite",
  "pirolisi",
  "pitone",
  "pizzico",
  "placebo",
  "planare",
  "plasma",
  "platano",
  "plenario",
  "pochezza",
  "poderoso",
  "podismo",
  "poesia",
  "poggiare",
  "polenta",
  "poligono",
  "pollice",
  "polmonite",
  "polpetta",
  "polso",
  "poltrona",
  "polvere",
  "pomice",
  "pomodoro",
  "ponte",
  "popoloso",
  "porfido",
  "poroso",
  "porpora",
  "porre",
  "portata",
  "posa",
  "positivo",
  "possesso",
  "postulato",
  "potassio",
  "potere",
  "pranzo",
  "prassi",
  "pratica",
  "precluso",
  "predica",
  "prefisso",
  "pregiato",
  "prelievo",
  "premere",
  "prenotare",
  "preparato",
  "presenza",
  "pretesto",
  "prevalso",
  "prima",
  "principe",
  "privato",
  "problema",
  "procura",
  "produrre",
  "profumo",
  "progetto",
  "prolunga",
  "promessa",
  "pronome",
  "proposta",
  "proroga",
  "proteso",
  "prova",
  "prudente",
  "prugna",
  "prurito",
  "psiche",
  "pubblico",
  "pudica",
  "pugilato",
  "pugno",
  "pulce",
  "pulito",
  "pulsante",
  "puntare",
  "pupazzo",
  "pupilla",
  "puro",
  "quadro",
  "qualcosa",
  "quasi",
  "querela",
  "quota",
  "raccolto",
  "raddoppio",
  "radicale",
  "radunato",
  "raffica",
  "ragazzo",
  "ragione",
  "ragno",
  "ramarro",
  "ramingo",
  "ramo",
  "randagio",
  "rantolare",
  "rapato",
  "rapina",
  "rappreso",
  "rasatura",
  "raschiato",
  "rasente",
  "rassegna",
  "rastrello",
  "rata",
  "ravveduto",
  "reale",
  "recepire",
  "recinto",
  "recluta",
  "recondito",
  "recupero",
  "reddito",
  "redimere",
  "regalato",
  "registro",
  "regola",
  "regresso",
  "relazione",
  "remare",
  "remoto",
  "renna",
  "replica",
  "reprimere",
  "reputare",
  "resa",
  "residente",
  "responso",
  "restauro",
  "rete",
  "retina",
  "retorica",
  "rettifica",
  "revocato",
  "riassunto",
  "ribadire",
  "ribelle",
  "ribrezzo",
  "ricarica",
  "ricco",
  "ricevere",
  "riciclato",
  "ricordo",
  "ricreduto",
  "ridicolo",
  "ridurre",
  "rifasare",
  "riflesso",
  "riforma",
  "rifugio",
  "rigare",
  "rigettato",
  "righello",
  "rilassato",
  "rilevato",
  "rimanere",
  "rimbalzo",
  "rimedio",
  "rimorchio",
  "rinascita",
  "rincaro",
  "rinforzo",
  "rinnovo",
  "rinomato",
  "rinsavito",
  "rintocco",
  "rinuncia",
  "rinvenire",
  "riparato",
  "ripetuto",
  "ripieno",
  "riportare",
  "ripresa",
  "ripulire",
  "risata",
  "rischio",
  "riserva",
  "risibile",
  "riso",
  "rispetto",
  "ristoro",
  "risultato",
  "risvolto",
  "ritardo",
  "ritegno",
  "ritmico",
  "ritrovo",
  "riunione",
  "riva",
  "riverso",
  "rivincita",
  "rivolto",
  "rizoma",
  "roba",
  "robotico",
  "robusto",
  "roccia",
  "roco",
  "rodaggio",
  "rodere",
  "roditore",
  "rogito",
  "rollio",
  "romantico",
  "rompere",
  "ronzio",
  "rosolare",
  "rospo",
  "rotante",
  "rotondo",
  "rotula",
  "rovescio",
  "rubizzo",
  "rubrica",
  "ruga",
  "rullino",
  "rumine",
  "rumoroso",
  "ruolo",
  "rupe",
  "russare",
  "rustico",
  "sabato",
  "sabbiare",
  "sabotato",
  "sagoma",
  "salasso",
  "saldatura",
  "salgemma",
  "salivare",
  "salmone",
  "salone",
  "saltare",
  "saluto",
  "salvo",
  "sapere",
  "sapido",
  "saporito",
  "saraceno",
  "sarcasmo",
  "sarto",
  "sassoso",
  "satellite",
  "satira",
  "satollo",
  "saturno",
  "savana",
  "savio",
  "saziato",
  "sbadiglio",
  "sbalzo",
  "sbancato",
  "sbarra",
  "sbattere",
  "sbavare",
  "sbendare",
  "sbirciare",
  "sbloccato",
  "sbocciato",
  "sbrinare",
  "sbruffone",
  "sbuffare",
  "scabroso",
  "scadenza",
  "scala",
  "scambiare",
  "scandalo",
  "scapola",
  "scarso",
  "scatenare",
  "scavato",
  "scelto",
  "scenico",
  "scettro",
  "scheda",
  "schiena",
  "sciarpa",
  "scienza",
  "scindere",
  "scippo",
  "sciroppo",
  "scivolo",
  "sclerare",
  "scodella",
  "scolpito",
  "scomparto",
  "sconforto",
  "scoprire",
  "scorta",
  "scossone",
  "scozzese",
  "scriba",
  "scrollare",
  "scrutinio",
  "scuderia",
  "scultore",
  "scuola",
  "scuro",
  "scusare",
  "sdebitare",
  "sdoganare",
  "seccatura",
  "secondo",
  "sedano",
  "seggiola",
  "segnalato",
  "segregato",
  "seguito",
  "selciato",
  "selettivo",
  "sella",
  "selvaggio",
  "semaforo",
  "sembrare",
  "seme",
  "seminato",
  "sempre",
  "senso",
  "sentire",
  "sepolto",
  "sequenza",
  "serata",
  "serbato",
  "sereno",
  "serio",
  "serpente",
  "serraglio",
  "servire",
  "sestina",
  "setola",
  "settimana",
  "sfacelo",
  "sfaldare",
  "sfamato",
  "sfarzoso",
  "sfaticato",
  "sfera",
  "sfida",
  "sfilato",
  "sfinge",
  "sfocato",
  "sfoderare",
  "sfogo",
  "sfoltire",
  "sforzato",
  "sfratto",
  "sfruttato",
  "sfuggito",
  "sfumare",
  "sfuso",
  "sgabello",
  "sgarbato",
  "sgonfiare",
  "sgorbio",
  "sgrassato",
  "sguardo",
  "sibilo",
  "siccome",
  "sierra",
  "sigla",
  "signore",
  "silenzio",
  "sillaba",
  "simbolo",
  "simpatico",
  "simulato",
  "sinfonia",
  "singolo",
  "sinistro",
  "sino",
  "sintesi",
  "sinusoide",
  "sipario",
  "sisma",
  "sistole",
  "situato",
  "slitta",
  "slogatura",
  "sloveno",
  "smarrito",
  "smemorato",
  "smentito",
  "smeraldo",
  "smilzo",
  "smontare",
  "smottato",
  "smussato",
  "snellire",
  "snervato",
  "snodo",
  "sobbalzo",
  "sobrio",
  "soccorso",
  "sociale",
  "sodale",
  "soffitto",
  "sogno",
  "soldato",
  "solenne",
  "solido",
  "sollazzo",
  "solo",
  "solubile",
  "solvente",
  "somatico",
  "somma",
  "sonda",
  "sonetto",
  "sonnifero",
  "sopire",
  "soppeso",
  "sopra",
  "sorgere",
  "sorpasso",
  "sorriso",
  "sorso",
  "sorteggio",
  "sorvolato",
  "sospiro",
  "sosta",
  "sottile",
  "spada",
  "spalla",
  "spargere",
  "spatola",
  "spavento",
  "spazzola",
  "specie",
  "spedire",
  "spegnere",
  "spelatura",
  "speranza",
  "spessore",
  "spettrale",
  "spezzato",
  "spia",
  "spigoloso",
  "spillato",
  "spinoso",
  "spirale",
  "splendido",
  "sportivo",
  "sposo",
  "spranga",
  "sprecare",
  "spronato",
  "spruzzo",
  "spuntino",
  "squillo",
  "sradicare",
  "srotolato",
  "stabile",
  "stacco",
  "staffa",
  "stagnare",
  "stampato",
  "stantio",
  "starnuto",
  "stasera",
  "statuto",
  "stelo",
  "steppa",
  "sterzo",
  "stiletto",
  "stima",
  "stirpe",
  "stivale",
  "stizzoso",
  "stonato",
  "storico",
  "strappo",
  "stregato",
  "stridulo",
  "strozzare",
  "strutto",
  "stuccare",
  "stufo",
  "stupendo",
  "subentro",
  "succoso",
  "sudore",
  "suggerito",
  "sugo",
  "sultano",
  "suonare",
  "superbo",
  "supporto",
  "surgelato",
  "surrogato",
  "sussurro",
  "sutura",
  "svagare",
  "svedese",
  "sveglio",
  "svelare",
  "svenuto",
  "svezia",
  "sviluppo",
  "svista",
  "svizzera",
  "svolta",
  "svuotare",
  "tabacco",
  "tabulato",
  "tacciare",
  "taciturno",
  "tale",
  "talismano",
  "tampone",
  "tannino",
  "tara",
  "tardivo",
  "targato",
  "tariffa",
  "tarpare",
  "tartaruga",
  "tasto",
  "tattico",
  "taverna",
  "tavolata",
  "tazza",
  "teca",
  "tecnico",
  "telefono",
  "temerario",
  "tempo",
  "temuto",
  "tendone",
  "tenero",
  "tensione",
  "tentacolo",
  "teorema",
  "terme",
  "terrazzo",
  "terzetto",
  "tesi",
  "tesserato",
  "testato",
  "tetro",
  "tettoia",
  "tifare",
  "tigella",
  "timbro",
  "tinto",
  "tipico",
  "tipografo",
  "tiraggio",
  "tiro",
  "titanio",
  "titolo",
  "titubante",
  "tizio",
  "tizzone",
  "toccare",
  "tollerare",
  "tolto",
  "tombola",
  "tomo",
  "tonfo",
  "tonsilla",
  "topazio",
  "topologia",
  "toppa",
  "torba",
  "tornare",
  "torrone",
  "tortora",
  "toscano",
  "tossire",
  "tostatura",
  "totano",
  "trabocco",
  "trachea",
  "trafila",
  "tragedia",
  "tralcio",
  "tramonto",
  "transito",
  "trapano",
  "trarre",
  "trasloco",
  "trattato",
  "trave",
  "treccia",
  "tremolio",
  "trespolo",
  "tributo",
  "tricheco",
  "trifoglio",
  "trillo",
  "trincea",
  "trio",
  "tristezza",
  "triturato",
  "trivella",
  "tromba",
  "trono",
  "troppo",
  "trottola",
  "trovare",
  "truccato",
  "tubatura",
  "tuffato",
  "tulipano",
  "tumulto",
  "tunisia",
  "turbare",
  "turchino",
  "tuta",
  "tutela",
  "ubicato",
  "uccello",
  "uccisore",
  "udire",
  "uditivo",
  "uffa",
  "ufficio",
  "uguale",
  "ulisse",
  "ultimato",
  "umano",
  "umile",
  "umorismo",
  "uncinetto",
  "ungere",
  "ungherese",
  "unicorno",
  "unificato",
  "unisono",
  "unitario",
  "unte",
  "uovo",
  "upupa",
  "uragano",
  "urgenza",
  "urlo",
  "usanza",
  "usato",
  "uscito",
  "usignolo",
  "usuraio",
  "utensile",
  "utilizzo",
  "utopia",
  "vacante",
  "vaccinato",
  "vagabondo",
  "vagliato",
  "valanga",
  "valgo",
  "valico",
  "valletta",
  "valoroso",
  "valutare",
  "valvola",
  "vampata",
  "vangare",
  "vanitoso",
  "vano",
  "vantaggio",
  "vanvera",
  "vapore",
  "varano",
  "varcato",
  "variante",
  "vasca",
  "vedetta",
  "vedova",
  "veduto",
  "vegetale",
  "veicolo",
  "velcro",
  "velina",
  "velluto",
  "veloce",
  "venato",
  "vendemmia",
  "vento",
  "verace",
  "verbale",
  "vergogna",
  "verifica",
  "vero",
  "verruca",
  "verticale",
  "vescica",
  "vessillo",
  "vestale",
  "veterano",
  "vetrina",
  "vetusto",
  "viandante",
  "vibrante",
  "vicenda",
  "vichingo",
  "vicinanza",
  "vidimare",
  "vigilia",
  "vigneto",
  "vigore",
  "vile",
  "villano",
  "vimini",
  "vincitore",
  "viola",
  "vipera",
  "virgola",
  "virologo",
  "virulento",
  "viscoso",
  "visione",
  "vispo",
  "vissuto",
  "visura",
  "vita",
  "vitello",
  "vittima",
  "vivanda",
  "vivido",
  "viziare",
  "voce",
  "voga",
  "volatile",
  "volere",
  "volpe",
  "voragine",
  "vulcano",
  "zampogna",
  "zanna",
  "zappato",
  "zattera",
  "zavorra",
  "zefiro",
  "zelante",
  "zelo",
  "zenzero",
  "zerbino",
  "zibetto",
  "zinco",
  "zircone",
  "zitto",
  "zolla",
  "zotico",
  "zucchero",
  "zufolo",
  "zulu",
  "zuppa"
], require$$6 = [
  "abaco",
  "abdomen",
  "abeja",
  "abierto",
  "abogado",
  "abono",
  "aborto",
  "abrazo",
  "abrir",
  "abuelo",
  "abuso",
  "acabar",
  "academia",
  "acceso",
  "accion",
  "aceite",
  "acelga",
  "acento",
  "aceptar",
  "acido",
  "aclarar",
  "acne",
  "acoger",
  "acoso",
  "activo",
  "acto",
  "actriz",
  "actuar",
  "acudir",
  "acuerdo",
  "acusar",
  "adicto",
  "admitir",
  "adoptar",
  "adorno",
  "aduana",
  "adulto",
  "aereo",
  "afectar",
  "aficion",
  "afinar",
  "afirmar",
  "agil",
  "agitar",
  "agonia",
  "agosto",
  "agotar",
  "agregar",
  "agrio",
  "agua",
  "agudo",
  "aguila",
  "aguja",
  "ahogo",
  "ahorro",
  "aire",
  "aislar",
  "ajedrez",
  "ajeno",
  "ajuste",
  "alacran",
  "alambre",
  "alarma",
  "alba",
  "album",
  "alcalde",
  "aldea",
  "alegre",
  "alejar",
  "alerta",
  "aleta",
  "alfiler",
  "alga",
  "algodon",
  "aliado",
  "aliento",
  "alivio",
  "alma",
  "almeja",
  "almibar",
  "altar",
  "alteza",
  "altivo",
  "alto",
  "altura",
  "alumno",
  "alzar",
  "amable",
  "amante",
  "amapola",
  "amargo",
  "amasar",
  "ambar",
  "ambito",
  "ameno",
  "amigo",
  "amistad",
  "amor",
  "amparo",
  "amplio",
  "ancho",
  "anciano",
  "ancla",
  "andar",
  "anden",
  "anemia",
  "angulo",
  "anillo",
  "animo",
  "anis",
  "anotar",
  "antena",
  "antiguo",
  "antojo",
  "anual",
  "anular",
  "anuncio",
  "anadir",
  "anejo",
  "ano",
  "apagar",
  "aparato",
  "apetito",
  "apio",
  "aplicar",
  "apodo",
  "aporte",
  "apoyo",
  "aprender",
  "aprobar",
  "apuesta",
  "apuro",
  "arado",
  "arana",
  "arar",
  "arbitro",
  "arbol",
  "arbusto",
  "archivo",
  "arco",
  "arder",
  "ardilla",
  "arduo",
  "area",
  "arido",
  "aries",
  "armonia",
  "arnes",
  "aroma",
  "arpa",
  "arpon",
  "arreglo",
  "arroz",
  "arruga",
  "arte",
  "artista",
  "asa",
  "asado",
  "asalto",
  "ascenso",
  "asegurar",
  "aseo",
  "asesor",
  "asiento",
  "asilo",
  "asistir",
  "asno",
  "asombro",
  "aspero",
  "astilla",
  "astro",
  "astuto",
  "asumir",
  "asunto",
  "atajo",
  "ataque",
  "atar",
  "atento",
  "ateo",
  "atico",
  "atleta",
  "atomo",
  "atraer",
  "atroz",
  "atun",
  "audaz",
  "audio",
  "auge",
  "aula",
  "aumento",
  "ausente",
  "autor",
  "aval",
  "avance",
  "avaro",
  "ave",
  "avellana",
  "avena",
  "avestruz",
  "avion",
  "aviso",
  "ayer",
  "ayuda",
  "ayuno",
  "azafran",
  "azar",
  "azote",
  "azucar",
  "azufre",
  "azul",
  "baba",
  "babor",
  "bache",
  "bahia",
  "baile",
  "bajar",
  "balanza",
  "balcon",
  "balde",
  "bambu",
  "banco",
  "banda",
  "bano",
  "barba",
  "barco",
  "barniz",
  "barro",
  "bascula",
  "baston",
  "basura",
  "batalla",
  "bateria",
  "batir",
  "batuta",
  "baul",
  "bazar",
  "bebe",
  "bebida",
  "bello",
  "besar",
  "beso",
  "bestia",
  "bicho",
  "bien",
  "bingo",
  "blanco",
  "bloque",
  "blusa",
  "boa",
  "bobina",
  "bobo",
  "boca",
  "bocina",
  "boda",
  "bodega",
  "boina",
  "bola",
  "bolero",
  "bolsa",
  "bomba",
  "bondad",
  "bonito",
  "bono",
  "bonsai",
  "borde",
  "borrar",
  "bosque",
  "bote",
  "botin",
  "boveda",
  "bozal",
  "bravo",
  "brazo",
  "brecha",
  "breve",
  "brillo",
  "brinco",
  "brisa",
  "broca",
  "broma",
  "bronce",
  "brote",
  "bruja",
  "brusco",
  "bruto",
  "buceo",
  "bucle",
  "bueno",
  "buey",
  "bufanda",
  "bufon",
  "buho",
  "buitre",
  "bulto",
  "burbuja",
  "burla",
  "burro",
  "buscar",
  "butaca",
  "buzon",
  "caballo",
  "cabeza",
  "cabina",
  "cabra",
  "cacao",
  "cadaver",
  "cadena",
  "caer",
  "cafe",
  "caida",
  "caiman",
  "caja",
  "cajon",
  "cal",
  "calamar",
  "calcio",
  "caldo",
  "calidad",
  "calle",
  "calma",
  "calor",
  "calvo",
  "cama",
  "cambio",
  "camello",
  "camino",
  "campo",
  "cancer",
  "candil",
  "canela",
  "canguro",
  "canica",
  "canto",
  "cana",
  "canon",
  "caoba",
  "caos",
  "capaz",
  "capitan",
  "capote",
  "captar",
  "capucha",
  "cara",
  "carbon",
  "carcel",
  "careta",
  "carga",
  "carino",
  "carne",
  "carpeta",
  "carro",
  "carta",
  "casa",
  "casco",
  "casero",
  "caspa",
  "castor",
  "catorce",
  "catre",
  "caudal",
  "causa",
  "cazo",
  "cebolla",
  "ceder",
  "cedro",
  "celda",
  "celebre",
  "celoso",
  "celula",
  "cemento",
  "ceniza",
  "centro",
  "cerca",
  "cerdo",
  "cereza",
  "cero",
  "cerrar",
  "certeza",
  "cesped",
  "cetro",
  "chacal",
  "chaleco",
  "champu",
  "chancla",
  "chapa",
  "charla",
  "chico",
  "chiste",
  "chivo",
  "choque",
  "choza",
  "chuleta",
  "chupar",
  "ciclon",
  "ciego",
  "cielo",
  "cien",
  "cierto",
  "cifra",
  "cigarro",
  "cima",
  "cinco",
  "cine",
  "cinta",
  "cipres",
  "circo",
  "ciruela",
  "cisne",
  "cita",
  "ciudad",
  "clamor",
  "clan",
  "claro",
  "clase",
  "clave",
  "cliente",
  "clima",
  "clinica",
  "cobre",
  "coccion",
  "cochino",
  "cocina",
  "coco",
  "codigo",
  "codo",
  "cofre",
  "coger",
  "cohete",
  "cojin",
  "cojo",
  "cola",
  "colcha",
  "colegio",
  "colgar",
  "colina",
  "collar",
  "colmo",
  "columna",
  "combate",
  "comer",
  "comida",
  "comodo",
  "compra",
  "conde",
  "conejo",
  "conga",
  "conocer",
  "consejo",
  "contar",
  "copa",
  "copia",
  "corazon",
  "corbata",
  "corcho",
  "cordon",
  "corona",
  "correr",
  "coser",
  "cosmos",
  "costa",
  "craneo",
  "crater",
  "crear",
  "crecer",
  "creido",
  "crema",
  "cria",
  "crimen",
  "cripta",
  "crisis",
  "cromo",
  "cronica",
  "croqueta",
  "crudo",
  "cruz",
  "cuadro",
  "cuarto",
  "cuatro",
  "cubo",
  "cubrir",
  "cuchara",
  "cuello",
  "cuento",
  "cuerda",
  "cuesta",
  "cueva",
  "cuidar",
  "culebra",
  "culpa",
  "culto",
  "cumbre",
  "cumplir",
  "cuna",
  "cuneta",
  "cuota",
  "cupon",
  "cupula",
  "curar",
  "curioso",
  "curso",
  "curva",
  "cutis",
  "dama",
  "danza",
  "dar",
  "dardo",
  "datil",
  "deber",
  "debil",
  "decada",
  "decir",
  "dedo",
  "defensa",
  "definir",
  "dejar",
  "delfin",
  "delgado",
  "delito",
  "demora",
  "denso",
  "dental",
  "deporte",
  "derecho",
  "derrota",
  "desayuno",
  "deseo",
  "desfile",
  "desnudo",
  "destino",
  "desvio",
  "detalle",
  "detener",
  "deuda",
  "dia",
  "diablo",
  "diadema",
  "diamante",
  "diana",
  "diario",
  "dibujo",
  "dictar",
  "diente",
  "dieta",
  "diez",
  "dificil",
  "digno",
  "dilema",
  "diluir",
  "dinero",
  "directo",
  "dirigir",
  "disco",
  "diseno",
  "disfraz",
  "diva",
  "divino",
  "doble",
  "doce",
  "dolor",
  "domingo",
  "don",
  "donar",
  "dorado",
  "dormir",
  "dorso",
  "dos",
  "dosis",
  "dragon",
  "droga",
  "ducha",
  "duda",
  "duelo",
  "dueno",
  "dulce",
  "duo",
  "duque",
  "durar",
  "dureza",
  "duro",
  "ebano",
  "ebrio",
  "echar",
  "eco",
  "ecuador",
  "edad",
  "edicion",
  "edificio",
  "editor",
  "educar",
  "efecto",
  "eficaz",
  "eje",
  "ejemplo",
  "elefante",
  "elegir",
  "elemento",
  "elevar",
  "elipse",
  "elite",
  "elixir",
  "elogio",
  "eludir",
  "embudo",
  "emitir",
  "emocion",
  "empate",
  "empeno",
  "empleo",
  "empresa",
  "enano",
  "encargo",
  "enchufe",
  "encia",
  "enemigo",
  "enero",
  "enfado",
  "enfermo",
  "engano",
  "enigma",
  "enlace",
  "enorme",
  "enredo",
  "ensayo",
  "ensenar",
  "entero",
  "entrar",
  "envase",
  "envio",
  "epoca",
  "equipo",
  "erizo",
  "escala",
  "escena",
  "escolar",
  "escribir",
  "escudo",
  "esencia",
  "esfera",
  "esfuerzo",
  "espada",
  "espejo",
  "espia",
  "esposa",
  "espuma",
  "esqui",
  "estar",
  "este",
  "estilo",
  "estufa",
  "etapa",
  "eterno",
  "etica",
  "etnia",
  "evadir",
  "evaluar",
  "evento",
  "evitar",
  "exacto",
  "examen",
  "exceso",
  "excusa",
  "exento",
  "exigir",
  "exilio",
  "existir",
  "exito",
  "experto",
  "explicar",
  "exponer",
  "extremo",
  "fabrica",
  "fabula",
  "fachada",
  "facil",
  "factor",
  "faena",
  "faja",
  "falda",
  "fallo",
  "falso",
  "faltar",
  "fama",
  "familia",
  "famoso",
  "faraon",
  "farmacia",
  "farol",
  "farsa",
  "fase",
  "fatiga",
  "fauna",
  "favor",
  "fax",
  "febrero",
  "fecha",
  "feliz",
  "feo",
  "feria",
  "feroz",
  "fertil",
  "fervor",
  "festin",
  "fiable",
  "fianza",
  "fiar",
  "fibra",
  "ficcion",
  "ficha",
  "fideo",
  "fiebre",
  "fiel",
  "fiera",
  "fiesta",
  "figura",
  "fijar",
  "fijo",
  "fila",
  "filete",
  "filial",
  "filtro",
  "fin",
  "finca",
  "fingir",
  "finito",
  "firma",
  "flaco",
  "flauta",
  "flecha",
  "flor",
  "flota",
  "fluir",
  "flujo",
  "fluor",
  "fobia",
  "foca",
  "fogata",
  "fogon",
  "folio",
  "folleto",
  "fondo",
  "forma",
  "forro",
  "fortuna",
  "forzar",
  "fosa",
  "foto",
  "fracaso",
  "fragil",
  "franja",
  "frase",
  "fraude",
  "freir",
  "freno",
  "fresa",
  "frio",
  "frito",
  "fruta",
  "fuego",
  "fuente",
  "fuerza",
  "fuga",
  "fumar",
  "funcion",
  "funda",
  "furgon",
  "furia",
  "fusil",
  "futbol",
  "futuro",
  "gacela",
  "gafas",
  "gaita",
  "gajo",
  "gala",
  "galeria",
  "gallo",
  "gamba",
  "ganar",
  "gancho",
  "ganga",
  "ganso",
  "garaje",
  "garza",
  "gasolina",
  "gastar",
  "gato",
  "gavilan",
  "gemelo",
  "gemir",
  "gen",
  "genero",
  "genio",
  "gente",
  "geranio",
  "gerente",
  "germen",
  "gesto",
  "gigante",
  "gimnasio",
  "girar",
  "giro",
  "glaciar",
  "globo",
  "gloria",
  "gol",
  "golfo",
  "goloso",
  "golpe",
  "goma",
  "gordo",
  "gorila",
  "gorra",
  "gota",
  "goteo",
  "gozar",
  "grada",
  "grafico",
  "grano",
  "grasa",
  "gratis",
  "grave",
  "grieta",
  "grillo",
  "gripe",
  "gris",
  "grito",
  "grosor",
  "grua",
  "grueso",
  "grumo",
  "grupo",
  "guante",
  "guapo",
  "guardia",
  "guerra",
  "guia",
  "guino",
  "guion",
  "guiso",
  "guitarra",
  "gusano",
  "gustar",
  "haber",
  "habil",
  "hablar",
  "hacer",
  "hacha",
  "hada",
  "hallar",
  "hamaca",
  "harina",
  "haz",
  "hazana",
  "hebilla",
  "hebra",
  "hecho",
  "helado",
  "helio",
  "hembra",
  "herir",
  "hermano",
  "heroe",
  "hervir",
  "hielo",
  "hierro",
  "higado",
  "higiene",
  "hijo",
  "himno",
  "historia",
  "hocico",
  "hogar",
  "hoguera",
  "hoja",
  "hombre",
  "hongo",
  "honor",
  "honra",
  "hora",
  "hormiga",
  "horno",
  "hostil",
  "hoyo",
  "hueco",
  "huelga",
  "huerta",
  "hueso",
  "huevo",
  "huida",
  "huir",
  "humano",
  "humedo",
  "humilde",
  "humo",
  "hundir",
  "huracan",
  "hurto",
  "icono",
  "ideal",
  "idioma",
  "idolo",
  "iglesia",
  "iglu",
  "igual",
  "ilegal",
  "ilusion",
  "imagen",
  "iman",
  "imitar",
  "impar",
  "imperio",
  "imponer",
  "impulso",
  "incapaz",
  "indice",
  "inerte",
  "infiel",
  "informe",
  "ingenio",
  "inicio",
  "inmenso",
  "inmune",
  "innato",
  "insecto",
  "instante",
  "interes",
  "intimo",
  "intuir",
  "inutil",
  "invierno",
  "ira",
  "iris",
  "ironia",
  "isla",
  "islote",
  "jabali",
  "jabon",
  "jamon",
  "jarabe",
  "jardin",
  "jarra",
  "jaula",
  "jazmin",
  "jefe",
  "jeringa",
  "jinete",
  "jornada",
  "joroba",
  "joven",
  "joya",
  "juerga",
  "jueves",
  "juez",
  "jugador",
  "jugo",
  "juguete",
  "juicio",
  "junco",
  "jungla",
  "junio",
  "juntar",
  "jupiter",
  "jurar",
  "justo",
  "juvenil",
  "juzgar",
  "kilo",
  "koala",
  "labio",
  "lacio",
  "lacra",
  "lado",
  "ladron",
  "lagarto",
  "lagrima",
  "laguna",
  "laico",
  "lamer",
  "lamina",
  "lampara",
  "lana",
  "lancha",
  "langosta",
  "lanza",
  "lapiz",
  "largo",
  "larva",
  "lastima",
  "lata",
  "latex",
  "latir",
  "laurel",
  "lavar",
  "lazo",
  "leal",
  "leccion",
  "leche",
  "lector",
  "leer",
  "legion",
  "legumbre",
  "lejano",
  "lengua",
  "lento",
  "lena",
  "leon",
  "leopardo",
  "lesion",
  "letal",
  "letra",
  "leve",
  "leyenda",
  "libertad",
  "libro",
  "licor",
  "lider",
  "lidiar",
  "lienzo",
  "liga",
  "ligero",
  "lima",
  "limite",
  "limon",
  "limpio",
  "lince",
  "lindo",
  "linea",
  "lingote",
  "lino",
  "linterna",
  "liquido",
  "liso",
  "lista",
  "litera",
  "litio",
  "litro",
  "llaga",
  "llama",
  "llanto",
  "llave",
  "llegar",
  "llenar",
  "llevar",
  "llorar",
  "llover",
  "lluvia",
  "lobo",
  "locion",
  "loco",
  "locura",
  "logica",
  "logro",
  "lombriz",
  "lomo",
  "lonja",
  "lote",
  "lucha",
  "lucir",
  "lugar",
  "lujo",
  "luna",
  "lunes",
  "lupa",
  "lustro",
  "luto",
  "luz",
  "maceta",
  "macho",
  "madera",
  "madre",
  "maduro",
  "maestro",
  "mafia",
  "magia",
  "mago",
  "maiz",
  "maldad",
  "maleta",
  "malla",
  "malo",
  "mama",
  "mambo",
  "mamut",
  "manco",
  "mando",
  "manejar",
  "manga",
  "maniqui",
  "manjar",
  "mano",
  "manso",
  "manta",
  "manana",
  "mapa",
  "maquina",
  "mar",
  "marco",
  "marea",
  "marfil",
  "margen",
  "marido",
  "marmol",
  "marron",
  "martes",
  "marzo",
  "masa",
  "mascara",
  "masivo",
  "matar",
  "materia",
  "matiz",
  "matriz",
  "maximo",
  "mayor",
  "mazorca",
  "mecha",
  "medalla",
  "medio",
  "medula",
  "mejilla",
  "mejor",
  "melena",
  "melon",
  "memoria",
  "menor",
  "mensaje",
  "mente",
  "menu",
  "mercado",
  "merengue",
  "merito",
  "mes",
  "meson",
  "meta",
  "meter",
  "metodo",
  "metro",
  "mezcla",
  "miedo",
  "miel",
  "miembro",
  "miga",
  "mil",
  "milagro",
  "militar",
  "millon",
  "mimo",
  "mina",
  "minero",
  "minimo",
  "minuto",
  "miope",
  "mirar",
  "misa",
  "miseria",
  "misil",
  "mismo",
  "mitad",
  "mito",
  "mochila",
  "mocion",
  "moda",
  "modelo",
  "moho",
  "mojar",
  "molde",
  "moler",
  "molino",
  "momento",
  "momia",
  "monarca",
  "moneda",
  "monja",
  "monto",
  "mono",
  "morada",
  "morder",
  "moreno",
  "morir",
  "morro",
  "morsa",
  "mortal",
  "mosca",
  "mostrar",
  "motivo",
  "mover",
  "movil",
  "mozo",
  "mucho",
  "mudar",
  "mueble",
  "muela",
  "muerte",
  "muestra",
  "mugre",
  "mujer",
  "mula",
  "muleta",
  "multa",
  "mundo",
  "muneca",
  "mural",
  "muro",
  "musculo",
  "museo",
  "musgo",
  "musica",
  "muslo",
  "nacar",
  "nacion",
  "nadar",
  "naipe",
  "naranja",
  "nariz",
  "narrar",
  "nasal",
  "natal",
  "nativo",
  "natural",
  "nausea",
  "naval",
  "nave",
  "navidad",
  "necio",
  "nectar",
  "negar",
  "negocio",
  "negro",
  "neon",
  "nervio",
  "neto",
  "neutro",
  "nevar",
  "nevera",
  "nicho",
  "nido",
  "niebla",
  "nieto",
  "ninez",
  "nino",
  "nitido",
  "nivel",
  "nobleza",
  "noche",
  "nomina",
  "noria",
  "norma",
  "norte",
  "nota",
  "noticia",
  "novato",
  "novela",
  "novio",
  "nube",
  "nuca",
  "nucleo",
  "nudillo",
  "nudo",
  "nuera",
  "nueve",
  "nuez",
  "nulo",
  "numero",
  "nutria",
  "oasis",
  "obeso",
  "obispo",
  "objeto",
  "obra",
  "obrero",
  "observar",
  "obtener",
  "obvio",
  "oca",
  "ocaso",
  "oceano",
  "ochenta",
  "ocho",
  "ocio",
  "ocre",
  "octavo",
  "octubre",
  "oculto",
  "ocupar",
  "ocurrir",
  "odiar",
  "odio",
  "odisea",
  "oeste",
  "ofensa",
  "oferta",
  "oficio",
  "ofrecer",
  "ogro",
  "oido",
  "oir",
  "ojo",
  "ola",
  "oleada",
  "olfato",
  "olivo",
  "olla",
  "olmo",
  "olor",
  "olvido",
  "ombligo",
  "onda",
  "onza",
  "opaco",
  "opcion",
  "opera",
  "opinar",
  "oponer",
  "optar",
  "optica",
  "opuesto",
  "oracion",
  "orador",
  "oral",
  "orbita",
  "orca",
  "orden",
  "oreja",
  "organo",
  "orgia",
  "orgullo",
  "oriente",
  "origen",
  "orilla",
  "oro",
  "orquesta",
  "oruga",
  "osadia",
  "oscuro",
  "osezno",
  "oso",
  "ostra",
  "otono",
  "otro",
  "oveja",
  "ovulo",
  "oxido",
  "oxigeno",
  "oyente",
  "ozono",
  "pacto",
  "padre",
  "paella",
  "pagina",
  "pago",
  "pais",
  "pajaro",
  "palabra",
  "palco",
  "paleta",
  "palido",
  "palma",
  "paloma",
  "palpar",
  "pan",
  "panal",
  "panico",
  "pantera",
  "panuelo",
  "papa",
  "papel",
  "papilla",
  "paquete",
  "parar",
  "parcela",
  "pared",
  "parir",
  "paro",
  "parpado",
  "parque",
  "parrafo",
  "parte",
  "pasar",
  "paseo",
  "pasion",
  "paso",
  "pasta",
  "pata",
  "patio",
  "patria",
  "pausa",
  "pauta",
  "pavo",
  "payaso",
  "peaton",
  "pecado",
  "pecera",
  "pecho",
  "pedal",
  "pedir",
  "pegar",
  "peine",
  "pelar",
  "peldano",
  "pelea",
  "peligro",
  "pellejo",
  "pelo",
  "peluca",
  "pena",
  "pensar",
  "penon",
  "peon",
  "peor",
  "pepino",
  "pequeno",
  "pera",
  "percha",
  "perder",
  "pereza",
  "perfil",
  "perico",
  "perla",
  "permiso",
  "perro",
  "persona",
  "pesa",
  "pesca",
  "pesimo",
  "pestana",
  "petalo",
  "petroleo",
  "pez",
  "pezuna",
  "picar",
  "pichon",
  "pie",
  "piedra",
  "pierna",
  "pieza",
  "pijama",
  "pilar",
  "piloto",
  "pimienta",
  "pino",
  "pintor",
  "pinza",
  "pina",
  "piojo",
  "pipa",
  "pirata",
  "pisar",
  "piscina",
  "piso",
  "pista",
  "piton",
  "pizca",
  "placa",
  "plan",
  "plata",
  "playa",
  "plaza",
  "pleito",
  "pleno",
  "plomo",
  "pluma",
  "plural",
  "pobre",
  "poco",
  "poder",
  "podio",
  "poema",
  "poesia",
  "poeta",
  "polen",
  "policia",
  "pollo",
  "polvo",
  "pomada",
  "pomelo",
  "pomo",
  "pompa",
  "poner",
  "porcion",
  "portal",
  "posada",
  "poseer",
  "posible",
  "poste",
  "potencia",
  "potro",
  "pozo",
  "prado",
  "precoz",
  "pregunta",
  "premio",
  "prensa",
  "preso",
  "previo",
  "primo",
  "principe",
  "prision",
  "privar",
  "proa",
  "probar",
  "proceso",
  "producto",
  "proeza",
  "profesor",
  "programa",
  "prole",
  "promesa",
  "pronto",
  "propio",
  "proximo",
  "prueba",
  "publico",
  "puchero",
  "pudor",
  "pueblo",
  "puerta",
  "puesto",
  "pulga",
  "pulir",
  "pulmon",
  "pulpo",
  "pulso",
  "puma",
  "punto",
  "punal",
  "puno",
  "pupa",
  "pupila",
  "pure",
  "quedar",
  "queja",
  "quemar",
  "querer",
  "queso",
  "quieto",
  "quimica",
  "quince",
  "quitar",
  "rabano",
  "rabia",
  "rabo",
  "racion",
  "radical",
  "raiz",
  "rama",
  "rampa",
  "rancho",
  "rango",
  "rapaz",
  "rapido",
  "rapto",
  "rasgo",
  "raspa",
  "rato",
  "rayo",
  "raza",
  "razon",
  "reaccion",
  "realidad",
  "rebano",
  "rebote",
  "recaer",
  "receta",
  "rechazo",
  "recoger",
  "recreo",
  "recto",
  "recurso",
  "red",
  "redondo",
  "reducir",
  "reflejo",
  "reforma",
  "refran",
  "refugio",
  "regalo",
  "regir",
  "regla",
  "regreso",
  "rehen",
  "reino",
  "reir",
  "reja",
  "relato",
  "relevo",
  "relieve",
  "relleno",
  "reloj",
  "remar",
  "remedio",
  "remo",
  "rencor",
  "rendir",
  "renta",
  "reparto",
  "repetir",
  "reposo",
  "reptil",
  "res",
  "rescate",
  "resina",
  "respeto",
  "resto",
  "resumen",
  "retiro",
  "retorno",
  "retrato",
  "reunir",
  "reves",
  "revista",
  "rey",
  "rezar",
  "rico",
  "riego",
  "rienda",
  "riesgo",
  "rifa",
  "rigido",
  "rigor",
  "rincon",
  "rinon",
  "rio",
  "riqueza",
  "risa",
  "ritmo",
  "rito",
  "rizo",
  "roble",
  "roce",
  "rociar",
  "rodar",
  "rodeo",
  "rodilla",
  "roer",
  "rojizo",
  "rojo",
  "romero",
  "romper",
  "ron",
  "ronco",
  "ronda",
  "ropa",
  "ropero",
  "rosa",
  "rosca",
  "rostro",
  "rotar",
  "rubi",
  "rubor",
  "rudo",
  "rueda",
  "rugir",
  "ruido",
  "ruina",
  "ruleta",
  "rulo",
  "rumbo",
  "rumor",
  "ruptura",
  "ruta",
  "rutina",
  "sabado",
  "saber",
  "sabio",
  "sable",
  "sacar",
  "sagaz",
  "sagrado",
  "sala",
  "saldo",
  "salero",
  "salir",
  "salmon",
  "salon",
  "salsa",
  "salto",
  "salud",
  "salvar",
  "samba",
  "sancion",
  "sandia",
  "sanear",
  "sangre",
  "sanidad",
  "sano",
  "santo",
  "sapo",
  "saque",
  "sardina",
  "sarten",
  "sastre",
  "satan",
  "sauna",
  "saxofon",
  "seccion",
  "seco",
  "secreto",
  "secta",
  "sed",
  "seguir",
  "seis",
  "sello",
  "selva",
  "semana",
  "semilla",
  "senda",
  "sensor",
  "senal",
  "senor",
  "separar",
  "sepia",
  "sequia",
  "ser",
  "serie",
  "sermon",
  "servir",
  "sesenta",
  "sesion",
  "seta",
  "setenta",
  "severo",
  "sexo",
  "sexto",
  "sidra",
  "siesta",
  "siete",
  "siglo",
  "signo",
  "silaba",
  "silbar",
  "silencio",
  "silla",
  "simbolo",
  "simio",
  "sirena",
  "sistema",
  "sitio",
  "situar",
  "sobre",
  "socio",
  "sodio",
  "sol",
  "solapa",
  "soldado",
  "soledad",
  "solido",
  "soltar",
  "solucion",
  "sombra",
  "sondeo",
  "sonido",
  "sonoro",
  "sonrisa",
  "sopa",
  "soplar",
  "soporte",
  "sordo",
  "sorpresa",
  "sorteo",
  "sosten",
  "sotano",
  "suave",
  "subir",
  "suceso",
  "sudor",
  "suegra",
  "suelo",
  "sueno",
  "suerte",
  "sufrir",
  "sujeto",
  "sultan",
  "sumar",
  "superar",
  "suplir",
  "suponer",
  "supremo",
  "sur",
  "surco",
  "sureno",
  "surgir",
  "susto",
  "sutil",
  "tabaco",
  "tabique",
  "tabla",
  "tabu",
  "taco",
  "tacto",
  "tajo",
  "talar",
  "talco",
  "talento",
  "talla",
  "talon",
  "tamano",
  "tambor",
  "tango",
  "tanque",
  "tapa",
  "tapete",
  "tapia",
  "tapon",
  "taquilla",
  "tarde",
  "tarea",
  "tarifa",
  "tarjeta",
  "tarot",
  "tarro",
  "tarta",
  "tatuaje",
  "tauro",
  "taza",
  "tazon",
  "teatro",
  "techo",
  "tecla",
  "tecnica",
  "tejado",
  "tejer",
  "tejido",
  "tela",
  "telefono",
  "tema",
  "temor",
  "templo",
  "tenaz",
  "tender",
  "tener",
  "tenis",
  "tenso",
  "teoria",
  "terapia",
  "terco",
  "termino",
  "ternura",
  "terror",
  "tesis",
  "tesoro",
  "testigo",
  "tetera",
  "texto",
  "tez",
  "tibio",
  "tiburon",
  "tiempo",
  "tienda",
  "tierra",
  "tieso",
  "tigre",
  "tijera",
  "tilde",
  "timbre",
  "timido",
  "timo",
  "tinta",
  "tio",
  "tipico",
  "tipo",
  "tira",
  "tiron",
  "titan",
  "titere",
  "titulo",
  "tiza",
  "toalla",
  "tobillo",
  "tocar",
  "tocino",
  "todo",
  "toga",
  "toldo",
  "tomar",
  "tono",
  "tonto",
  "topar",
  "tope",
  "toque",
  "torax",
  "torero",
  "tormenta",
  "torneo",
  "toro",
  "torpedo",
  "torre",
  "torso",
  "tortuga",
  "tos",
  "tosco",
  "toser",
  "toxico",
  "trabajo",
  "tractor",
  "traer",
  "trafico",
  "trago",
  "traje",
  "tramo",
  "trance",
  "trato",
  "trauma",
  "trazar",
  "trebol",
  "tregua",
  "treinta",
  "tren",
  "trepar",
  "tres",
  "tribu",
  "trigo",
  "tripa",
  "triste",
  "triunfo",
  "trofeo",
  "trompa",
  "tronco",
  "tropa",
  "trote",
  "trozo",
  "truco",
  "trueno",
  "trufa",
  "tuberia",
  "tubo",
  "tuerto",
  "tumba",
  "tumor",
  "tunel",
  "tunica",
  "turbina",
  "turismo",
  "turno",
  "tutor",
  "ubicar",
  "ulcera",
  "umbral",
  "unidad",
  "unir",
  "universo",
  "uno",
  "untar",
  "una",
  "urbano",
  "urbe",
  "urgente",
  "urna",
  "usar",
  "usuario",
  "util",
  "utopia",
  "uva",
  "vaca",
  "vacio",
  "vacuna",
  "vagar",
  "vago",
  "vaina",
  "vajilla",
  "vale",
  "valido",
  "valle",
  "valor",
  "valvula",
  "vampiro",
  "vara",
  "variar",
  "varon",
  "vaso",
  "vecino",
  "vector",
  "vehiculo",
  "veinte",
  "vejez",
  "vela",
  "velero",
  "veloz",
  "vena",
  "vencer",
  "venda",
  "veneno",
  "vengar",
  "venir",
  "venta",
  "venus",
  "ver",
  "verano",
  "verbo",
  "verde",
  "vereda",
  "verja",
  "verso",
  "verter",
  "via",
  "viaje",
  "vibrar",
  "vicio",
  "victima",
  "vida",
  "video",
  "vidrio",
  "viejo",
  "viernes",
  "vigor",
  "vil",
  "villa",
  "vinagre",
  "vino",
  "vinedo",
  "violin",
  "viral",
  "virgo",
  "virtud",
  "visor",
  "vispera",
  "vista",
  "vitamina",
  "viudo",
  "vivaz",
  "vivero",
  "vivir",
  "vivo",
  "volcan",
  "volumen",
  "volver",
  "voraz",
  "votar",
  "voto",
  "voz",
  "vuelo",
  "vulgar",
  "yacer",
  "yate",
  "yegua",
  "yema",
  "yerno",
  "yeso",
  "yodo",
  "yoga",
  "yogur",
  "zafiro",
  "zanja",
  "zapato",
  "zarza",
  "zona",
  "zorro",
  "zumo",
  "zurdo"
], require$$7 = [
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  ""
], require$$8 = [
  "abacate",
  "abaixo",
  "abalar",
  "abater",
  "abduzir",
  "abelha",
  "aberto",
  "abismo",
  "abotoar",
  "abranger",
  "abreviar",
  "abrigar",
  "abrupto",
  "absinto",
  "absoluto",
  "absurdo",
  "abutre",
  "acabado",
  "acalmar",
  "acampar",
  "acanhar",
  "acaso",
  "aceitar",
  "acelerar",
  "acenar",
  "acervo",
  "acessar",
  "acetona",
  "achatar",
  "acidez",
  "acima",
  "acionado",
  "acirrar",
  "aclamar",
  "aclive",
  "acolhida",
  "acomodar",
  "acoplar",
  "acordar",
  "acumular",
  "acusador",
  "adaptar",
  "adega",
  "adentro",
  "adepto",
  "adequar",
  "aderente",
  "adesivo",
  "adeus",
  "adiante",
  "aditivo",
  "adjetivo",
  "adjunto",
  "admirar",
  "adorar",
  "adquirir",
  "adubo",
  "adverso",
  "advogado",
  "aeronave",
  "afastar",
  "aferir",
  "afetivo",
  "afinador",
  "afivelar",
  "aflito",
  "afluente",
  "afrontar",
  "agachar",
  "agarrar",
  "agasalho",
  "agenciar",
  "agilizar",
  "agiota",
  "agitado",
  "agora",
  "agradar",
  "agreste",
  "agrupar",
  "aguardar",
  "agulha",
  "ajoelhar",
  "ajudar",
  "ajustar",
  "alameda",
  "alarme",
  "alastrar",
  "alavanca",
  "albergue",
  "albino",
  "alcatra",
  "aldeia",
  "alecrim",
  "alegria",
  "alertar",
  "alface",
  "alfinete",
  "algum",
  "alheio",
  "aliar",
  "alicate",
  "alienar",
  "alinhar",
  "aliviar",
  "almofada",
  "alocar",
  "alpiste",
  "alterar",
  "altitude",
  "alucinar",
  "alugar",
  "aluno",
  "alusivo",
  "alvo",
  "amaciar",
  "amador",
  "amarelo",
  "amassar",
  "ambas",
  "ambiente",
  "ameixa",
  "amenizar",
  "amido",
  "amistoso",
  "amizade",
  "amolador",
  "amontoar",
  "amoroso",
  "amostra",
  "amparar",
  "ampliar",
  "ampola",
  "anagrama",
  "analisar",
  "anarquia",
  "anatomia",
  "andaime",
  "anel",
  "anexo",
  "angular",
  "animar",
  "anjo",
  "anomalia",
  "anotado",
  "ansioso",
  "anterior",
  "anuidade",
  "anunciar",
  "anzol",
  "apagador",
  "apalpar",
  "apanhado",
  "apego",
  "apelido",
  "apertada",
  "apesar",
  "apetite",
  "apito",
  "aplauso",
  "aplicada",
  "apoio",
  "apontar",
  "aposta",
  "aprendiz",
  "aprovar",
  "aquecer",
  "arame",
  "aranha",
  "arara",
  "arcada",
  "ardente",
  "areia",
  "arejar",
  "arenito",
  "aresta",
  "argiloso",
  "argola",
  "arma",
  "arquivo",
  "arraial",
  "arrebate",
  "arriscar",
  "arroba",
  "arrumar",
  "arsenal",
  "arterial",
  "artigo",
  "arvoredo",
  "asfaltar",
  "asilado",
  "aspirar",
  "assador",
  "assinar",
  "assoalho",
  "assunto",
  "astral",
  "atacado",
  "atadura",
  "atalho",
  "atarefar",
  "atear",
  "atender",
  "aterro",
  "ateu",
  "atingir",
  "atirador",
  "ativo",
  "atoleiro",
  "atracar",
  "atrevido",
  "atriz",
  "atual",
  "atum",
  "auditor",
  "aumentar",
  "aura",
  "aurora",
  "autismo",
  "autoria",
  "autuar",
  "avaliar",
  "avante",
  "avaria",
  "avental",
  "avesso",
  "aviador",
  "avisar",
  "avulso",
  "axila",
  "azarar",
  "azedo",
  "azeite",
  "azulejo",
  "babar",
  "babosa",
  "bacalhau",
  "bacharel",
  "bacia",
  "bagagem",
  "baiano",
  "bailar",
  "baioneta",
  "bairro",
  "baixista",
  "bajular",
  "baleia",
  "baliza",
  "balsa",
  "banal",
  "bandeira",
  "banho",
  "banir",
  "banquete",
  "barato",
  "barbado",
  "baronesa",
  "barraca",
  "barulho",
  "baseado",
  "bastante",
  "batata",
  "batedor",
  "batida",
  "batom",
  "batucar",
  "baunilha",
  "beber",
  "beijo",
  "beirada",
  "beisebol",
  "beldade",
  "beleza",
  "belga",
  "beliscar",
  "bendito",
  "bengala",
  "benzer",
  "berimbau",
  "berlinda",
  "berro",
  "besouro",
  "bexiga",
  "bezerro",
  "bico",
  "bicudo",
  "bienal",
  "bifocal",
  "bifurcar",
  "bigorna",
  "bilhete",
  "bimestre",
  "bimotor",
  "biologia",
  "biombo",
  "biosfera",
  "bipolar",
  "birrento",
  "biscoito",
  "bisneto",
  "bispo",
  "bissexto",
  "bitola",
  "bizarro",
  "blindado",
  "bloco",
  "bloquear",
  "boato",
  "bobagem",
  "bocado",
  "bocejo",
  "bochecha",
  "boicotar",
  "bolada",
  "boletim",
  "bolha",
  "bolo",
  "bombeiro",
  "bonde",
  "boneco",
  "bonita",
  "borbulha",
  "borda",
  "boreal",
  "borracha",
  "bovino",
  "boxeador",
  "branco",
  "brasa",
  "braveza",
  "breu",
  "briga",
  "brilho",
  "brincar",
  "broa",
  "brochura",
  "bronzear",
  "broto",
  "bruxo",
  "bucha",
  "budismo",
  "bufar",
  "bule",
  "buraco",
  "busca",
  "busto",
  "buzina",
  "cabana",
  "cabelo",
  "cabide",
  "cabo",
  "cabrito",
  "cacau",
  "cacetada",
  "cachorro",
  "cacique",
  "cadastro",
  "cadeado",
  "cafezal",
  "caiaque",
  "caipira",
  "caixote",
  "cajado",
  "caju",
  "calafrio",
  "calcular",
  "caldeira",
  "calibrar",
  "calmante",
  "calota",
  "camada",
  "cambista",
  "camisa",
  "camomila",
  "campanha",
  "camuflar",
  "canavial",
  "cancelar",
  "caneta",
  "canguru",
  "canhoto",
  "canivete",
  "canoa",
  "cansado",
  "cantar",
  "canudo",
  "capacho",
  "capela",
  "capinar",
  "capotar",
  "capricho",
  "captador",
  "capuz",
  "caracol",
  "carbono",
  "cardeal",
  "careca",
  "carimbar",
  "carneiro",
  "carpete",
  "carreira",
  "cartaz",
  "carvalho",
  "casaco",
  "casca",
  "casebre",
  "castelo",
  "casulo",
  "catarata",
  "cativar",
  "caule",
  "causador",
  "cautelar",
  "cavalo",
  "caverna",
  "cebola",
  "cedilha",
  "cegonha",
  "celebrar",
  "celular",
  "cenoura",
  "censo",
  "centeio",
  "cercar",
  "cerrado",
  "certeiro",
  "cerveja",
  "cetim",
  "cevada",
  "chacota",
  "chaleira",
  "chamado",
  "chapada",
  "charme",
  "chatice",
  "chave",
  "chefe",
  "chegada",
  "cheiro",
  "cheque",
  "chicote",
  "chifre",
  "chinelo",
  "chocalho",
  "chover",
  "chumbo",
  "chutar",
  "chuva",
  "cicatriz",
  "ciclone",
  "cidade",
  "cidreira",
  "ciente",
  "cigana",
  "cimento",
  "cinto",
  "cinza",
  "ciranda",
  "circuito",
  "cirurgia",
  "citar",
  "clareza",
  "clero",
  "clicar",
  "clone",
  "clube",
  "coado",
  "coagir",
  "cobaia",
  "cobertor",
  "cobrar",
  "cocada",
  "coelho",
  "coentro",
  "coeso",
  "cogumelo",
  "coibir",
  "coifa",
  "coiote",
  "colar",
  "coleira",
  "colher",
  "colidir",
  "colmeia",
  "colono",
  "coluna",
  "comando",
  "combinar",
  "comentar",
  "comitiva",
  "comover",
  "complexo",
  "comum",
  "concha",
  "condor",
  "conectar",
  "confuso",
  "congelar",
  "conhecer",
  "conjugar",
  "consumir",
  "contrato",
  "convite",
  "cooperar",
  "copeiro",
  "copiador",
  "copo",
  "coquetel",
  "coragem",
  "cordial",
  "corneta",
  "coronha",
  "corporal",
  "correio",
  "cortejo",
  "coruja",
  "corvo",
  "cosseno",
  "costela",
  "cotonete",
  "couro",
  "couve",
  "covil",
  "cozinha",
  "cratera",
  "cravo",
  "creche",
  "credor",
  "creme",
  "crer",
  "crespo",
  "criada",
  "criminal",
  "crioulo",
  "crise",
  "criticar",
  "crosta",
  "crua",
  "cruzeiro",
  "cubano",
  "cueca",
  "cuidado",
  "cujo",
  "culatra",
  "culminar",
  "culpar",
  "cultura",
  "cumprir",
  "cunhado",
  "cupido",
  "curativo",
  "curral",
  "cursar",
  "curto",
  "cuspir",
  "custear",
  "cutelo",
  "damasco",
  "datar",
  "debater",
  "debitar",
  "deboche",
  "debulhar",
  "decalque",
  "decimal",
  "declive",
  "decote",
  "decretar",
  "dedal",
  "dedicado",
  "deduzir",
  "defesa",
  "defumar",
  "degelo",
  "degrau",
  "degustar",
  "deitado",
  "deixar",
  "delator",
  "delegado",
  "delinear",
  "delonga",
  "demanda",
  "demitir",
  "demolido",
  "dentista",
  "depenado",
  "depilar",
  "depois",
  "depressa",
  "depurar",
  "deriva",
  "derramar",
  "desafio",
  "desbotar",
  "descanso",
  "desenho",
  "desfiado",
  "desgaste",
  "desigual",
  "deslize",
  "desmamar",
  "desova",
  "despesa",
  "destaque",
  "desviar",
  "detalhar",
  "detentor",
  "detonar",
  "detrito",
  "deusa",
  "dever",
  "devido",
  "devotado",
  "dezena",
  "diagrama",
  "dialeto",
  "didata",
  "difuso",
  "digitar",
  "dilatado",
  "diluente",
  "diminuir",
  "dinastia",
  "dinheiro",
  "diocese",
  "direto",
  "discreta",
  "disfarce",
  "disparo",
  "disquete",
  "dissipar",
  "distante",
  "ditador",
  "diurno",
  "diverso",
  "divisor",
  "divulgar",
  "dizer",
  "dobrador",
  "dolorido",
  "domador",
  "dominado",
  "donativo",
  "donzela",
  "dormente",
  "dorsal",
  "dosagem",
  "dourado",
  "doutor",
  "drenagem",
  "drible",
  "drogaria",
  "duelar",
  "duende",
  "dueto",
  "duplo",
  "duquesa",
  "durante",
  "duvidoso",
  "eclodir",
  "ecoar",
  "ecologia",
  "edificar",
  "edital",
  "educado",
  "efeito",
  "efetivar",
  "ejetar",
  "elaborar",
  "eleger",
  "eleitor",
  "elenco",
  "elevador",
  "eliminar",
  "elogiar",
  "embargo",
  "embolado",
  "embrulho",
  "embutido",
  "emenda",
  "emergir",
  "emissor",
  "empatia",
  "empenho",
  "empinado",
  "empolgar",
  "emprego",
  "empurrar",
  "emulador",
  "encaixe",
  "encenado",
  "enchente",
  "encontro",
  "endeusar",
  "endossar",
  "enfaixar",
  "enfeite",
  "enfim",
  "engajado",
  "engenho",
  "englobar",
  "engomado",
  "engraxar",
  "enguia",
  "enjoar",
  "enlatar",
  "enquanto",
  "enraizar",
  "enrolado",
  "enrugar",
  "ensaio",
  "enseada",
  "ensino",
  "ensopado",
  "entanto",
  "enteado",
  "entidade",
  "entortar",
  "entrada",
  "entulho",
  "envergar",
  "enviado",
  "envolver",
  "enxame",
  "enxerto",
  "enxofre",
  "enxuto",
  "epiderme",
  "equipar",
  "ereto",
  "erguido",
  "errata",
  "erva",
  "ervilha",
  "esbanjar",
  "esbelto",
  "escama",
  "escola",
  "escrita",
  "escuta",
  "esfinge",
  "esfolar",
  "esfregar",
  "esfumado",
  "esgrima",
  "esmalte",
  "espanto",
  "espelho",
  "espiga",
  "esponja",
  "espreita",
  "espumar",
  "esquerda",
  "estaca",
  "esteira",
  "esticar",
  "estofado",
  "estrela",
  "estudo",
  "esvaziar",
  "etanol",
  "etiqueta",
  "euforia",
  "europeu",
  "evacuar",
  "evaporar",
  "evasivo",
  "eventual",
  "evidente",
  "evoluir",
  "exagero",
  "exalar",
  "examinar",
  "exato",
  "exausto",
  "excesso",
  "excitar",
  "exclamar",
  "executar",
  "exemplo",
  "exibir",
  "exigente",
  "exonerar",
  "expandir",
  "expelir",
  "expirar",
  "explanar",
  "exposto",
  "expresso",
  "expulsar",
  "externo",
  "extinto",
  "extrato",
  "fabricar",
  "fabuloso",
  "faceta",
  "facial",
  "fada",
  "fadiga",
  "faixa",
  "falar",
  "falta",
  "familiar",
  "fandango",
  "fanfarra",
  "fantoche",
  "fardado",
  "farelo",
  "farinha",
  "farofa",
  "farpa",
  "fartura",
  "fatia",
  "fator",
  "favorita",
  "faxina",
  "fazenda",
  "fechado",
  "feijoada",
  "feirante",
  "felino",
  "feminino",
  "fenda",
  "feno",
  "fera",
  "feriado",
  "ferrugem",
  "ferver",
  "festejar",
  "fetal",
  "feudal",
  "fiapo",
  "fibrose",
  "ficar",
  "ficheiro",
  "figurado",
  "fileira",
  "filho",
  "filme",
  "filtrar",
  "firmeza",
  "fisgada",
  "fissura",
  "fita",
  "fivela",
  "fixador",
  "fixo",
  "flacidez",
  "flamingo",
  "flanela",
  "flechada",
  "flora",
  "flutuar",
  "fluxo",
  "focal",
  "focinho",
  "fofocar",
  "fogo",
  "foguete",
  "foice",
  "folgado",
  "folheto",
  "forjar",
  "formiga",
  "forno",
  "forte",
  "fosco",
  "fossa",
  "fragata",
  "fralda",
  "frango",
  "frasco",
  "fraterno",
  "freira",
  "frente",
  "fretar",
  "frieza",
  "friso",
  "fritura",
  "fronha",
  "frustrar",
  "fruteira",
  "fugir",
  "fulano",
  "fuligem",
  "fundar",
  "fungo",
  "funil",
  "furador",
  "furioso",
  "futebol",
  "gabarito",
  "gabinete",
  "gado",
  "gaiato",
  "gaiola",
  "gaivota",
  "galega",
  "galho",
  "galinha",
  "galocha",
  "ganhar",
  "garagem",
  "garfo",
  "gargalo",
  "garimpo",
  "garoupa",
  "garrafa",
  "gasoduto",
  "gasto",
  "gata",
  "gatilho",
  "gaveta",
  "gazela",
  "gelado",
  "geleia",
  "gelo",
  "gemada",
  "gemer",
  "gemido",
  "generoso",
  "gengiva",
  "genial",
  "genoma",
  "genro",
  "geologia",
  "gerador",
  "germinar",
  "gesso",
  "gestor",
  "ginasta",
  "gincana",
  "gingado",
  "girafa",
  "girino",
  "glacial",
  "glicose",
  "global",
  "glorioso",
  "goela",
  "goiaba",
  "golfe",
  "golpear",
  "gordura",
  "gorjeta",
  "gorro",
  "gostoso",
  "goteira",
  "governar",
  "gracejo",
  "gradual",
  "grafite",
  "gralha",
  "grampo",
  "granada",
  "gratuito",
  "graveto",
  "graxa",
  "grego",
  "grelhar",
  "greve",
  "grilo",
  "grisalho",
  "gritaria",
  "grosso",
  "grotesco",
  "grudado",
  "grunhido",
  "gruta",
  "guache",
  "guarani",
  "guaxinim",
  "guerrear",
  "guiar",
  "guincho",
  "guisado",
  "gula",
  "guloso",
  "guru",
  "habitar",
  "harmonia",
  "haste",
  "haver",
  "hectare",
  "herdar",
  "heresia",
  "hesitar",
  "hiato",
  "hibernar",
  "hidratar",
  "hiena",
  "hino",
  "hipismo",
  "hipnose",
  "hipoteca",
  "hoje",
  "holofote",
  "homem",
  "honesto",
  "honrado",
  "hormonal",
  "hospedar",
  "humorado",
  "iate",
  "ideia",
  "idoso",
  "ignorado",
  "igreja",
  "iguana",
  "ileso",
  "ilha",
  "iludido",
  "iluminar",
  "ilustrar",
  "imagem",
  "imediato",
  "imenso",
  "imersivo",
  "iminente",
  "imitador",
  "imortal",
  "impacto",
  "impedir",
  "implante",
  "impor",
  "imprensa",
  "impune",
  "imunizar",
  "inalador",
  "inapto",
  "inativo",
  "incenso",
  "inchar",
  "incidir",
  "incluir",
  "incolor",
  "indeciso",
  "indireto",
  "indutor",
  "ineficaz",
  "inerente",
  "infantil",
  "infestar",
  "infinito",
  "inflamar",
  "informal",
  "infrator",
  "ingerir",
  "inibido",
  "inicial",
  "inimigo",
  "injetar",
  "inocente",
  "inodoro",
  "inovador",
  "inox",
  "inquieto",
  "inscrito",
  "inseto",
  "insistir",
  "inspetor",
  "instalar",
  "insulto",
  "intacto",
  "integral",
  "intimar",
  "intocado",
  "intriga",
  "invasor",
  "inverno",
  "invicto",
  "invocar",
  "iogurte",
  "iraniano",
  "ironizar",
  "irreal",
  "irritado",
  "isca",
  "isento",
  "isolado",
  "isqueiro",
  "italiano",
  "janeiro",
  "jangada",
  "janta",
  "jararaca",
  "jardim",
  "jarro",
  "jasmim",
  "jato",
  "javali",
  "jazida",
  "jejum",
  "joaninha",
  "joelhada",
  "jogador",
  "joia",
  "jornal",
  "jorrar",
  "jovem",
  "juba",
  "judeu",
  "judoca",
  "juiz",
  "julgador",
  "julho",
  "jurado",
  "jurista",
  "juro",
  "justa",
  "labareda",
  "laboral",
  "lacre",
  "lactante",
  "ladrilho",
  "lagarta",
  "lagoa",
  "laje",
  "lamber",
  "lamentar",
  "laminar",
  "lampejo",
  "lanche",
  "lapidar",
  "lapso",
  "laranja",
  "lareira",
  "largura",
  "lasanha",
  "lastro",
  "lateral",
  "latido",
  "lavanda",
  "lavoura",
  "lavrador",
  "laxante",
  "lazer",
  "lealdade",
  "lebre",
  "legado",
  "legendar",
  "legista",
  "leigo",
  "leiloar",
  "leitura",
  "lembrete",
  "leme",
  "lenhador",
  "lentilha",
  "leoa",
  "lesma",
  "leste",
  "letivo",
  "letreiro",
  "levar",
  "leveza",
  "levitar",
  "liberal",
  "libido",
  "liderar",
  "ligar",
  "ligeiro",
  "limitar",
  "limoeiro",
  "limpador",
  "linda",
  "linear",
  "linhagem",
  "liquidez",
  "listagem",
  "lisura",
  "litoral",
  "livro",
  "lixa",
  "lixeira",
  "locador",
  "locutor",
  "lojista",
  "lombo",
  "lona",
  "longe",
  "lontra",
  "lorde",
  "lotado",
  "loteria",
  "loucura",
  "lousa",
  "louvar",
  "luar",
  "lucidez",
  "lucro",
  "luneta",
  "lustre",
  "lutador",
  "luva",
  "macaco",
  "macete",
  "machado",
  "macio",
  "madeira",
  "madrinha",
  "magnata",
  "magreza",
  "maior",
  "mais",
  "malandro",
  "malha",
  "malote",
  "maluco",
  "mamilo",
  "mamoeiro",
  "mamute",
  "manada",
  "mancha",
  "mandato",
  "manequim",
  "manhoso",
  "manivela",
  "manobrar",
  "mansa",
  "manter",
  "manusear",
  "mapeado",
  "maquinar",
  "marcador",
  "maresia",
  "marfim",
  "margem",
  "marinho",
  "marmita",
  "maroto",
  "marquise",
  "marreco",
  "martelo",
  "marujo",
  "mascote",
  "masmorra",
  "massagem",
  "mastigar",
  "matagal",
  "materno",
  "matinal",
  "matutar",
  "maxilar",
  "medalha",
  "medida",
  "medusa",
  "megafone",
  "meiga",
  "melancia",
  "melhor",
  "membro",
  "memorial",
  "menino",
  "menos",
  "mensagem",
  "mental",
  "merecer",
  "mergulho",
  "mesada",
  "mesclar",
  "mesmo",
  "mesquita",
  "mestre",
  "metade",
  "meteoro",
  "metragem",
  "mexer",
  "mexicano",
  "micro",
  "migalha",
  "migrar",
  "milagre",
  "milenar",
  "milhar",
  "mimado",
  "minerar",
  "minhoca",
  "ministro",
  "minoria",
  "miolo",
  "mirante",
  "mirtilo",
  "misturar",
  "mocidade",
  "moderno",
  "modular",
  "moeda",
  "moer",
  "moinho",
  "moita",
  "moldura",
  "moleza",
  "molho",
  "molinete",
  "molusco",
  "montanha",
  "moqueca",
  "morango",
  "morcego",
  "mordomo",
  "morena",
  "mosaico",
  "mosquete",
  "mostarda",
  "motel",
  "motim",
  "moto",
  "motriz",
  "muda",
  "muito",
  "mulata",
  "mulher",
  "multar",
  "mundial",
  "munido",
  "muralha",
  "murcho",
  "muscular",
  "museu",
  "musical",
  "nacional",
  "nadador",
  "naja",
  "namoro",
  "narina",
  "narrado",
  "nascer",
  "nativa",
  "natureza",
  "navalha",
  "navegar",
  "navio",
  "neblina",
  "nebuloso",
  "negativa",
  "negociar",
  "negrito",
  "nervoso",
  "neta",
  "neural",
  "nevasca",
  "nevoeiro",
  "ninar",
  "ninho",
  "nitidez",
  "nivelar",
  "nobreza",
  "noite",
  "noiva",
  "nomear",
  "nominal",
  "nordeste",
  "nortear",
  "notar",
  "noticiar",
  "noturno",
  "novelo",
  "novilho",
  "novo",
  "nublado",
  "nudez",
  "numeral",
  "nupcial",
  "nutrir",
  "nuvem",
  "obcecado",
  "obedecer",
  "objetivo",
  "obrigado",
  "obscuro",
  "obstetra",
  "obter",
  "obturar",
  "ocidente",
  "ocioso",
  "ocorrer",
  "oculista",
  "ocupado",
  "ofegante",
  "ofensiva",
  "oferenda",
  "oficina",
  "ofuscado",
  "ogiva",
  "olaria",
  "oleoso",
  "olhar",
  "oliveira",
  "ombro",
  "omelete",
  "omisso",
  "omitir",
  "ondulado",
  "oneroso",
  "ontem",
  "opcional",
  "operador",
  "oponente",
  "oportuno",
  "oposto",
  "orar",
  "orbitar",
  "ordem",
  "ordinal",
  "orfanato",
  "orgasmo",
  "orgulho",
  "oriental",
  "origem",
  "oriundo",
  "orla",
  "ortodoxo",
  "orvalho",
  "oscilar",
  "ossada",
  "osso",
  "ostentar",
  "otimismo",
  "ousadia",
  "outono",
  "outubro",
  "ouvido",
  "ovelha",
  "ovular",
  "oxidar",
  "oxigenar",
  "pacato",
  "paciente",
  "pacote",
  "pactuar",
  "padaria",
  "padrinho",
  "pagar",
  "pagode",
  "painel",
  "pairar",
  "paisagem",
  "palavra",
  "palestra",
  "palheta",
  "palito",
  "palmada",
  "palpitar",
  "pancada",
  "panela",
  "panfleto",
  "panqueca",
  "pantanal",
  "papagaio",
  "papelada",
  "papiro",
  "parafina",
  "parcial",
  "pardal",
  "parede",
  "partida",
  "pasmo",
  "passado",
  "pastel",
  "patamar",
  "patente",
  "patinar",
  "patrono",
  "paulada",
  "pausar",
  "peculiar",
  "pedalar",
  "pedestre",
  "pediatra",
  "pedra",
  "pegada",
  "peitoral",
  "peixe",
  "pele",
  "pelicano",
  "penca",
  "pendurar",
  "peneira",
  "penhasco",
  "pensador",
  "pente",
  "perceber",
  "perfeito",
  "pergunta",
  "perito",
  "permitir",
  "perna",
  "perplexo",
  "persiana",
  "pertence",
  "peruca",
  "pescado",
  "pesquisa",
  "pessoa",
  "petiscar",
  "piada",
  "picado",
  "piedade",
  "pigmento",
  "pilastra",
  "pilhado",
  "pilotar",
  "pimenta",
  "pincel",
  "pinguim",
  "pinha",
  "pinote",
  "pintar",
  "pioneiro",
  "pipoca",
  "piquete",
  "piranha",
  "pires",
  "pirueta",
  "piscar",
  "pistola",
  "pitanga",
  "pivete",
  "planta",
  "plaqueta",
  "platina",
  "plebeu",
  "plumagem",
  "pluvial",
  "pneu",
  "poda",
  "poeira",
  "poetisa",
  "polegada",
  "policiar",
  "poluente",
  "polvilho",
  "pomar",
  "pomba",
  "ponderar",
  "pontaria",
  "populoso",
  "porta",
  "possuir",
  "postal",
  "pote",
  "poupar",
  "pouso",
  "povoar",
  "praia",
  "prancha",
  "prato",
  "praxe",
  "prece",
  "predador",
  "prefeito",
  "premiar",
  "prensar",
  "preparar",
  "presilha",
  "pretexto",
  "prevenir",
  "prezar",
  "primata",
  "princesa",
  "prisma",
  "privado",
  "processo",
  "produto",
  "profeta",
  "proibido",
  "projeto",
  "prometer",
  "propagar",
  "prosa",
  "protetor",
  "provador",
  "publicar",
  "pudim",
  "pular",
  "pulmonar",
  "pulseira",
  "punhal",
  "punir",
  "pupilo",
  "pureza",
  "puxador",
  "quadra",
  "quantia",
  "quarto",
  "quase",
  "quebrar",
  "queda",
  "queijo",
  "quente",
  "querido",
  "quimono",
  "quina",
  "quiosque",
  "rabanada",
  "rabisco",
  "rachar",
  "racionar",
  "radial",
  "raiar",
  "rainha",
  "raio",
  "raiva",
  "rajada",
  "ralado",
  "ramal",
  "ranger",
  "ranhura",
  "rapadura",
  "rapel",
  "rapidez",
  "raposa",
  "raquete",
  "raridade",
  "rasante",
  "rascunho",
  "rasgar",
  "raspador",
  "rasteira",
  "rasurar",
  "ratazana",
  "ratoeira",
  "realeza",
  "reanimar",
  "reaver",
  "rebaixar",
  "rebelde",
  "rebolar",
  "recado",
  "recente",
  "recheio",
  "recibo",
  "recordar",
  "recrutar",
  "recuar",
  "rede",
  "redimir",
  "redonda",
  "reduzida",
  "reenvio",
  "refinar",
  "refletir",
  "refogar",
  "refresco",
  "refugiar",
  "regalia",
  "regime",
  "regra",
  "reinado",
  "reitor",
  "rejeitar",
  "relativo",
  "remador",
  "remendo",
  "remorso",
  "renovado",
  "reparo",
  "repelir",
  "repleto",
  "repolho",
  "represa",
  "repudiar",
  "requerer",
  "resenha",
  "resfriar",
  "resgatar",
  "residir",
  "resolver",
  "respeito",
  "ressaca",
  "restante",
  "resumir",
  "retalho",
  "reter",
  "retirar",
  "retomada",
  "retratar",
  "revelar",
  "revisor",
  "revolta",
  "riacho",
  "rica",
  "rigidez",
  "rigoroso",
  "rimar",
  "ringue",
  "risada",
  "risco",
  "risonho",
  "robalo",
  "rochedo",
  "rodada",
  "rodeio",
  "rodovia",
  "roedor",
  "roleta",
  "romano",
  "roncar",
  "rosado",
  "roseira",
  "rosto",
  "rota",
  "roteiro",
  "rotina",
  "rotular",
  "rouco",
  "roupa",
  "roxo",
  "rubro",
  "rugido",
  "rugoso",
  "ruivo",
  "rumo",
  "rupestre",
  "russo",
  "sabor",
  "saciar",
  "sacola",
  "sacudir",
  "sadio",
  "safira",
  "saga",
  "sagrada",
  "saibro",
  "salada",
  "saleiro",
  "salgado",
  "saliva",
  "salpicar",
  "salsicha",
  "saltar",
  "salvador",
  "sambar",
  "samurai",
  "sanar",
  "sanfona",
  "sangue",
  "sanidade",
  "sapato",
  "sarda",
  "sargento",
  "sarjeta",
  "saturar",
  "saudade",
  "saxofone",
  "sazonal",
  "secar",
  "secular",
  "seda",
  "sedento",
  "sediado",
  "sedoso",
  "sedutor",
  "segmento",
  "segredo",
  "segundo",
  "seiva",
  "seleto",
  "selvagem",
  "semanal",
  "semente",
  "senador",
  "senhor",
  "sensual",
  "sentado",
  "separado",
  "sereia",
  "seringa",
  "serra",
  "servo",
  "setembro",
  "setor",
  "sigilo",
  "silhueta",
  "silicone",
  "simetria",
  "simpatia",
  "simular",
  "sinal",
  "sincero",
  "singular",
  "sinopse",
  "sintonia",
  "sirene",
  "siri",
  "situado",
  "soberano",
  "sobra",
  "socorro",
  "sogro",
  "soja",
  "solda",
  "soletrar",
  "solteiro",
  "sombrio",
  "sonata",
  "sondar",
  "sonegar",
  "sonhador",
  "sono",
  "soprano",
  "soquete",
  "sorrir",
  "sorteio",
  "sossego",
  "sotaque",
  "soterrar",
  "sovado",
  "sozinho",
  "suavizar",
  "subida",
  "submerso",
  "subsolo",
  "subtrair",
  "sucata",
  "sucesso",
  "suco",
  "sudeste",
  "sufixo",
  "sugador",
  "sugerir",
  "sujeito",
  "sulfato",
  "sumir",
  "suor",
  "superior",
  "suplicar",
  "suposto",
  "suprimir",
  "surdina",
  "surfista",
  "surpresa",
  "surreal",
  "surtir",
  "suspiro",
  "sustento",
  "tabela",
  "tablete",
  "tabuada",
  "tacho",
  "tagarela",
  "talher",
  "talo",
  "talvez",
  "tamanho",
  "tamborim",
  "tampa",
  "tangente",
  "tanto",
  "tapar",
  "tapioca",
  "tardio",
  "tarefa",
  "tarja",
  "tarraxa",
  "tatuagem",
  "taurino",
  "taxativo",
  "taxista",
  "teatral",
  "tecer",
  "tecido",
  "teclado",
  "tedioso",
  "teia",
  "teimar",
  "telefone",
  "telhado",
  "tempero",
  "tenente",
  "tensor",
  "tentar",
  "termal",
  "terno",
  "terreno",
  "tese",
  "tesoura",
  "testado",
  "teto",
  "textura",
  "texugo",
  "tiara",
  "tigela",
  "tijolo",
  "timbrar",
  "timidez",
  "tingido",
  "tinteiro",
  "tiragem",
  "titular",
  "toalha",
  "tocha",
  "tolerar",
  "tolice",
  "tomada",
  "tomilho",
  "tonel",
  "tontura",
  "topete",
  "tora",
  "torcido",
  "torneio",
  "torque",
  "torrada",
  "torto",
  "tostar",
  "touca",
  "toupeira",
  "toxina",
  "trabalho",
  "tracejar",
  "tradutor",
  "trafegar",
  "trajeto",
  "trama",
  "trancar",
  "trapo",
  "traseiro",
  "tratador",
  "travar",
  "treino",
  "tremer",
  "trepidar",
  "trevo",
  "triagem",
  "tribo",
  "triciclo",
  "tridente",
  "trilogia",
  "trindade",
  "triplo",
  "triturar",
  "triunfal",
  "trocar",
  "trombeta",
  "trova",
  "trunfo",
  "truque",
  "tubular",
  "tucano",
  "tudo",
  "tulipa",
  "tupi",
  "turbo",
  "turma",
  "turquesa",
  "tutelar",
  "tutorial",
  "uivar",
  "umbigo",
  "unha",
  "unidade",
  "uniforme",
  "urologia",
  "urso",
  "urtiga",
  "urubu",
  "usado",
  "usina",
  "usufruir",
  "vacina",
  "vadiar",
  "vagaroso",
  "vaidoso",
  "vala",
  "valente",
  "validade",
  "valores",
  "vantagem",
  "vaqueiro",
  "varanda",
  "vareta",
  "varrer",
  "vascular",
  "vasilha",
  "vassoura",
  "vazar",
  "vazio",
  "veado",
  "vedar",
  "vegetar",
  "veicular",
  "veleiro",
  "velhice",
  "veludo",
  "vencedor",
  "vendaval",
  "venerar",
  "ventre",
  "verbal",
  "verdade",
  "vereador",
  "vergonha",
  "vermelho",
  "verniz",
  "versar",
  "vertente",
  "vespa",
  "vestido",
  "vetorial",
  "viaduto",
  "viagem",
  "viajar",
  "viatura",
  "vibrador",
  "videira",
  "vidraria",
  "viela",
  "viga",
  "vigente",
  "vigiar",
  "vigorar",
  "vilarejo",
  "vinco",
  "vinheta",
  "vinil",
  "violeta",
  "virada",
  "virtude",
  "visitar",
  "visto",
  "vitral",
  "viveiro",
  "vizinho",
  "voador",
  "voar",
  "vogal",
  "volante",
  "voleibol",
  "voltagem",
  "volumoso",
  "vontade",
  "vulto",
  "vuvuzela",
  "xadrez",
  "xarope",
  "xeque",
  "xeretar",
  "xerife",
  "xingar",
  "zangado",
  "zarpar",
  "zebu",
  "zelador",
  "zombar",
  "zoologia",
  "zumbido"
], require$$9 = [
  "abandon",
  "ability",
  "able",
  "about",
  "above",
  "absent",
  "absorb",
  "abstract",
  "absurd",
  "abuse",
  "access",
  "accident",
  "account",
  "accuse",
  "achieve",
  "acid",
  "acoustic",
  "acquire",
  "across",
  "act",
  "action",
  "actor",
  "actress",
  "actual",
  "adapt",
  "add",
  "addict",
  "address",
  "adjust",
  "admit",
  "adult",
  "advance",
  "advice",
  "aerobic",
  "affair",
  "afford",
  "afraid",
  "again",
  "age",
  "agent",
  "agree",
  "ahead",
  "aim",
  "air",
  "airport",
  "aisle",
  "alarm",
  "album",
  "alcohol",
  "alert",
  "alien",
  "all",
  "alley",
  "allow",
  "almost",
  "alone",
  "alpha",
  "already",
  "also",
  "alter",
  "always",
  "amateur",
  "amazing",
  "among",
  "amount",
  "amused",
  "analyst",
  "anchor",
  "ancient",
  "anger",
  "angle",
  "angry",
  "animal",
  "ankle",
  "announce",
  "annual",
  "another",
  "answer",
  "antenna",
  "antique",
  "anxiety",
  "any",
  "apart",
  "apology",
  "appear",
  "apple",
  "approve",
  "april",
  "arch",
  "arctic",
  "area",
  "arena",
  "argue",
  "arm",
  "armed",
  "armor",
  "army",
  "around",
  "arrange",
  "arrest",
  "arrive",
  "arrow",
  "art",
  "artefact",
  "artist",
  "artwork",
  "ask",
  "aspect",
  "assault",
  "asset",
  "assist",
  "assume",
  "asthma",
  "athlete",
  "atom",
  "attack",
  "attend",
  "attitude",
  "attract",
  "auction",
  "audit",
  "august",
  "aunt",
  "author",
  "auto",
  "autumn",
  "average",
  "avocado",
  "avoid",
  "awake",
  "aware",
  "away",
  "awesome",
  "awful",
  "awkward",
  "axis",
  "baby",
  "bachelor",
  "bacon",
  "badge",
  "bag",
  "balance",
  "balcony",
  "ball",
  "bamboo",
  "banana",
  "banner",
  "bar",
  "barely",
  "bargain",
  "barrel",
  "base",
  "basic",
  "basket",
  "battle",
  "beach",
  "bean",
  "beauty",
  "because",
  "become",
  "beef",
  "before",
  "begin",
  "behave",
  "behind",
  "believe",
  "below",
  "belt",
  "bench",
  "benefit",
  "best",
  "betray",
  "better",
  "between",
  "beyond",
  "bicycle",
  "bid",
  "bike",
  "bind",
  "biology",
  "bird",
  "birth",
  "bitter",
  "black",
  "blade",
  "blame",
  "blanket",
  "blast",
  "bleak",
  "bless",
  "blind",
  "blood",
  "blossom",
  "blouse",
  "blue",
  "blur",
  "blush",
  "board",
  "boat",
  "body",
  "boil",
  "bomb",
  "bone",
  "bonus",
  "book",
  "boost",
  "border",
  "boring",
  "borrow",
  "boss",
  "bottom",
  "bounce",
  "box",
  "boy",
  "bracket",
  "brain",
  "brand",
  "brass",
  "brave",
  "bread",
  "breeze",
  "brick",
  "bridge",
  "brief",
  "bright",
  "bring",
  "brisk",
  "broccoli",
  "broken",
  "bronze",
  "broom",
  "brother",
  "brown",
  "brush",
  "bubble",
  "buddy",
  "budget",
  "buffalo",
  "build",
  "bulb",
  "bulk",
  "bullet",
  "bundle",
  "bunker",
  "burden",
  "burger",
  "burst",
  "bus",
  "business",
  "busy",
  "butter",
  "buyer",
  "buzz",
  "cabbage",
  "cabin",
  "cable",
  "cactus",
  "cage",
  "cake",
  "call",
  "calm",
  "camera",
  "camp",
  "can",
  "canal",
  "cancel",
  "candy",
  "cannon",
  "canoe",
  "canvas",
  "canyon",
  "capable",
  "capital",
  "captain",
  "car",
  "carbon",
  "card",
  "cargo",
  "carpet",
  "carry",
  "cart",
  "case",
  "cash",
  "casino",
  "castle",
  "casual",
  "cat",
  "catalog",
  "catch",
  "category",
  "cattle",
  "caught",
  "cause",
  "caution",
  "cave",
  "ceiling",
  "celery",
  "cement",
  "census",
  "century",
  "cereal",
  "certain",
  "chair",
  "chalk",
  "champion",
  "change",
  "chaos",
  "chapter",
  "charge",
  "chase",
  "chat",
  "cheap",
  "check",
  "cheese",
  "chef",
  "cherry",
  "chest",
  "chicken",
  "chief",
  "child",
  "chimney",
  "choice",
  "choose",
  "chronic",
  "chuckle",
  "chunk",
  "churn",
  "cigar",
  "cinnamon",
  "circle",
  "citizen",
  "city",
  "civil",
  "claim",
  "clap",
  "clarify",
  "claw",
  "clay",
  "clean",
  "clerk",
  "clever",
  "click",
  "client",
  "cliff",
  "climb",
  "clinic",
  "clip",
  "clock",
  "clog",
  "close",
  "cloth",
  "cloud",
  "clown",
  "club",
  "clump",
  "cluster",
  "clutch",
  "coach",
  "coast",
  "coconut",
  "code",
  "coffee",
  "coil",
  "coin",
  "collect",
  "color",
  "column",
  "combine",
  "come",
  "comfort",
  "comic",
  "common",
  "company",
  "concert",
  "conduct",
  "confirm",
  "congress",
  "connect",
  "consider",
  "control",
  "convince",
  "cook",
  "cool",
  "copper",
  "copy",
  "coral",
  "core",
  "corn",
  "correct",
  "cost",
  "cotton",
  "couch",
  "country",
  "couple",
  "course",
  "cousin",
  "cover",
  "coyote",
  "crack",
  "cradle",
  "craft",
  "cram",
  "crane",
  "crash",
  "crater",
  "crawl",
  "crazy",
  "cream",
  "credit",
  "creek",
  "crew",
  "cricket",
  "crime",
  "crisp",
  "critic",
  "crop",
  "cross",
  "crouch",
  "crowd",
  "crucial",
  "cruel",
  "cruise",
  "crumble",
  "crunch",
  "crush",
  "cry",
  "crystal",
  "cube",
  "culture",
  "cup",
  "cupboard",
  "curious",
  "current",
  "curtain",
  "curve",
  "cushion",
  "custom",
  "cute",
  "cycle",
  "dad",
  "damage",
  "damp",
  "dance",
  "danger",
  "daring",
  "dash",
  "daughter",
  "dawn",
  "day",
  "deal",
  "debate",
  "debris",
  "decade",
  "december",
  "decide",
  "decline",
  "decorate",
  "decrease",
  "deer",
  "defense",
  "define",
  "defy",
  "degree",
  "delay",
  "deliver",
  "demand",
  "demise",
  "denial",
  "dentist",
  "deny",
  "depart",
  "depend",
  "deposit",
  "depth",
  "deputy",
  "derive",
  "describe",
  "desert",
  "design",
  "desk",
  "despair",
  "destroy",
  "detail",
  "detect",
  "develop",
  "device",
  "devote",
  "diagram",
  "dial",
  "diamond",
  "diary",
  "dice",
  "diesel",
  "diet",
  "differ",
  "digital",
  "dignity",
  "dilemma",
  "dinner",
  "dinosaur",
  "direct",
  "dirt",
  "disagree",
  "discover",
  "disease",
  "dish",
  "dismiss",
  "disorder",
  "display",
  "distance",
  "divert",
  "divide",
  "divorce",
  "dizzy",
  "doctor",
  "document",
  "dog",
  "doll",
  "dolphin",
  "domain",
  "donate",
  "donkey",
  "donor",
  "door",
  "dose",
  "double",
  "dove",
  "draft",
  "dragon",
  "drama",
  "drastic",
  "draw",
  "dream",
  "dress",
  "drift",
  "drill",
  "drink",
  "drip",
  "drive",
  "drop",
  "drum",
  "dry",
  "duck",
  "dumb",
  "dune",
  "during",
  "dust",
  "dutch",
  "duty",
  "dwarf",
  "dynamic",
  "eager",
  "eagle",
  "early",
  "earn",
  "earth",
  "easily",
  "east",
  "easy",
  "echo",
  "ecology",
  "economy",
  "edge",
  "edit",
  "educate",
  "effort",
  "egg",
  "eight",
  "either",
  "elbow",
  "elder",
  "electric",
  "elegant",
  "element",
  "elephant",
  "elevator",
  "elite",
  "else",
  "embark",
  "embody",
  "embrace",
  "emerge",
  "emotion",
  "employ",
  "empower",
  "empty",
  "enable",
  "enact",
  "end",
  "endless",
  "endorse",
  "enemy",
  "energy",
  "enforce",
  "engage",
  "engine",
  "enhance",
  "enjoy",
  "enlist",
  "enough",
  "enrich",
  "enroll",
  "ensure",
  "enter",
  "entire",
  "entry",
  "envelope",
  "episode",
  "equal",
  "equip",
  "era",
  "erase",
  "erode",
  "erosion",
  "error",
  "erupt",
  "escape",
  "essay",
  "essence",
  "estate",
  "eternal",
  "ethics",
  "evidence",
  "evil",
  "evoke",
  "evolve",
  "exact",
  "example",
  "excess",
  "exchange",
  "excite",
  "exclude",
  "excuse",
  "execute",
  "exercise",
  "exhaust",
  "exhibit",
  "exile",
  "exist",
  "exit",
  "exotic",
  "expand",
  "expect",
  "expire",
  "explain",
  "expose",
  "express",
  "extend",
  "extra",
  "eye",
  "eyebrow",
  "fabric",
  "face",
  "faculty",
  "fade",
  "faint",
  "faith",
  "fall",
  "false",
  "fame",
  "family",
  "famous",
  "fan",
  "fancy",
  "fantasy",
  "farm",
  "fashion",
  "fat",
  "fatal",
  "father",
  "fatigue",
  "fault",
  "favorite",
  "feature",
  "february",
  "federal",
  "fee",
  "feed",
  "feel",
  "female",
  "fence",
  "festival",
  "fetch",
  "fever",
  "few",
  "fiber",
  "fiction",
  "field",
  "figure",
  "file",
  "film",
  "filter",
  "final",
  "find",
  "fine",
  "finger",
  "finish",
  "fire",
  "firm",
  "first",
  "fiscal",
  "fish",
  "fit",
  "fitness",
  "fix",
  "flag",
  "flame",
  "flash",
  "flat",
  "flavor",
  "flee",
  "flight",
  "flip",
  "float",
  "flock",
  "floor",
  "flower",
  "fluid",
  "flush",
  "fly",
  "foam",
  "focus",
  "fog",
  "foil",
  "fold",
  "follow",
  "food",
  "foot",
  "force",
  "forest",
  "forget",
  "fork",
  "fortune",
  "forum",
  "forward",
  "fossil",
  "foster",
  "found",
  "fox",
  "fragile",
  "frame",
  "frequent",
  "fresh",
  "friend",
  "fringe",
  "frog",
  "front",
  "frost",
  "frown",
  "frozen",
  "fruit",
  "fuel",
  "fun",
  "funny",
  "furnace",
  "fury",
  "future",
  "gadget",
  "gain",
  "galaxy",
  "gallery",
  "game",
  "gap",
  "garage",
  "garbage",
  "garden",
  "garlic",
  "garment",
  "gas",
  "gasp",
  "gate",
  "gather",
  "gauge",
  "gaze",
  "general",
  "genius",
  "genre",
  "gentle",
  "genuine",
  "gesture",
  "ghost",
  "giant",
  "gift",
  "giggle",
  "ginger",
  "giraffe",
  "girl",
  "give",
  "glad",
  "glance",
  "glare",
  "glass",
  "glide",
  "glimpse",
  "globe",
  "gloom",
  "glory",
  "glove",
  "glow",
  "glue",
  "goat",
  "goddess",
  "gold",
  "good",
  "goose",
  "gorilla",
  "gospel",
  "gossip",
  "govern",
  "gown",
  "grab",
  "grace",
  "grain",
  "grant",
  "grape",
  "grass",
  "gravity",
  "great",
  "green",
  "grid",
  "grief",
  "grit",
  "grocery",
  "group",
  "grow",
  "grunt",
  "guard",
  "guess",
  "guide",
  "guilt",
  "guitar",
  "gun",
  "gym",
  "habit",
  "hair",
  "half",
  "hammer",
  "hamster",
  "hand",
  "happy",
  "harbor",
  "hard",
  "harsh",
  "harvest",
  "hat",
  "have",
  "hawk",
  "hazard",
  "head",
  "health",
  "heart",
  "heavy",
  "hedgehog",
  "height",
  "hello",
  "helmet",
  "help",
  "hen",
  "hero",
  "hidden",
  "high",
  "hill",
  "hint",
  "hip",
  "hire",
  "history",
  "hobby",
  "hockey",
  "hold",
  "hole",
  "holiday",
  "hollow",
  "home",
  "honey",
  "hood",
  "hope",
  "horn",
  "horror",
  "horse",
  "hospital",
  "host",
  "hotel",
  "hour",
  "hover",
  "hub",
  "huge",
  "human",
  "humble",
  "humor",
  "hundred",
  "hungry",
  "hunt",
  "hurdle",
  "hurry",
  "hurt",
  "husband",
  "hybrid",
  "ice",
  "icon",
  "idea",
  "identify",
  "idle",
  "ignore",
  "ill",
  "illegal",
  "illness",
  "image",
  "imitate",
  "immense",
  "immune",
  "impact",
  "impose",
  "improve",
  "impulse",
  "inch",
  "include",
  "income",
  "increase",
  "index",
  "indicate",
  "indoor",
  "industry",
  "infant",
  "inflict",
  "inform",
  "inhale",
  "inherit",
  "initial",
  "inject",
  "injury",
  "inmate",
  "inner",
  "innocent",
  "input",
  "inquiry",
  "insane",
  "insect",
  "inside",
  "inspire",
  "install",
  "intact",
  "interest",
  "into",
  "invest",
  "invite",
  "involve",
  "iron",
  "island",
  "isolate",
  "issue",
  "item",
  "ivory",
  "jacket",
  "jaguar",
  "jar",
  "jazz",
  "jealous",
  "jeans",
  "jelly",
  "jewel",
  "job",
  "join",
  "joke",
  "journey",
  "joy",
  "judge",
  "juice",
  "jump",
  "jungle",
  "junior",
  "junk",
  "just",
  "kangaroo",
  "keen",
  "keep",
  "ketchup",
  "key",
  "kick",
  "kid",
  "kidney",
  "kind",
  "kingdom",
  "kiss",
  "kit",
  "kitchen",
  "kite",
  "kitten",
  "kiwi",
  "knee",
  "knife",
  "knock",
  "know",
  "lab",
  "label",
  "labor",
  "ladder",
  "lady",
  "lake",
  "lamp",
  "language",
  "laptop",
  "large",
  "later",
  "latin",
  "laugh",
  "laundry",
  "lava",
  "law",
  "lawn",
  "lawsuit",
  "layer",
  "lazy",
  "leader",
  "leaf",
  "learn",
  "leave",
  "lecture",
  "left",
  "leg",
  "legal",
  "legend",
  "leisure",
  "lemon",
  "lend",
  "length",
  "lens",
  "leopard",
  "lesson",
  "letter",
  "level",
  "liar",
  "liberty",
  "library",
  "license",
  "life",
  "lift",
  "light",
  "like",
  "limb",
  "limit",
  "link",
  "lion",
  "liquid",
  "list",
  "little",
  "live",
  "lizard",
  "load",
  "loan",
  "lobster",
  "local",
  "lock",
  "logic",
  "lonely",
  "long",
  "loop",
  "lottery",
  "loud",
  "lounge",
  "love",
  "loyal",
  "lucky",
  "luggage",
  "lumber",
  "lunar",
  "lunch",
  "luxury",
  "lyrics",
  "machine",
  "mad",
  "magic",
  "magnet",
  "maid",
  "mail",
  "main",
  "major",
  "make",
  "mammal",
  "man",
  "manage",
  "mandate",
  "mango",
  "mansion",
  "manual",
  "maple",
  "marble",
  "march",
  "margin",
  "marine",
  "market",
  "marriage",
  "mask",
  "mass",
  "master",
  "match",
  "material",
  "math",
  "matrix",
  "matter",
  "maximum",
  "maze",
  "meadow",
  "mean",
  "measure",
  "meat",
  "mechanic",
  "medal",
  "media",
  "melody",
  "melt",
  "member",
  "memory",
  "mention",
  "menu",
  "mercy",
  "merge",
  "merit",
  "merry",
  "mesh",
  "message",
  "metal",
  "method",
  "middle",
  "midnight",
  "milk",
  "million",
  "mimic",
  "mind",
  "minimum",
  "minor",
  "minute",
  "miracle",
  "mirror",
  "misery",
  "miss",
  "mistake",
  "mix",
  "mixed",
  "mixture",
  "mobile",
  "model",
  "modify",
  "mom",
  "moment",
  "monitor",
  "monkey",
  "monster",
  "month",
  "moon",
  "moral",
  "more",
  "morning",
  "mosquito",
  "mother",
  "motion",
  "motor",
  "mountain",
  "mouse",
  "move",
  "movie",
  "much",
  "muffin",
  "mule",
  "multiply",
  "muscle",
  "museum",
  "mushroom",
  "music",
  "must",
  "mutual",
  "myself",
  "mystery",
  "myth",
  "naive",
  "name",
  "napkin",
  "narrow",
  "nasty",
  "nation",
  "nature",
  "near",
  "neck",
  "need",
  "negative",
  "neglect",
  "neither",
  "nephew",
  "nerve",
  "nest",
  "net",
  "network",
  "neutral",
  "never",
  "news",
  "next",
  "nice",
  "night",
  "noble",
  "noise",
  "nominee",
  "noodle",
  "normal",
  "north",
  "nose",
  "notable",
  "note",
  "nothing",
  "notice",
  "novel",
  "now",
  "nuclear",
  "number",
  "nurse",
  "nut",
  "oak",
  "obey",
  "object",
  "oblige",
  "obscure",
  "observe",
  "obtain",
  "obvious",
  "occur",
  "ocean",
  "october",
  "odor",
  "off",
  "offer",
  "office",
  "often",
  "oil",
  "okay",
  "old",
  "olive",
  "olympic",
  "omit",
  "once",
  "one",
  "onion",
  "online",
  "only",
  "open",
  "opera",
  "opinion",
  "oppose",
  "option",
  "orange",
  "orbit",
  "orchard",
  "order",
  "ordinary",
  "organ",
  "orient",
  "original",
  "orphan",
  "ostrich",
  "other",
  "outdoor",
  "outer",
  "output",
  "outside",
  "oval",
  "oven",
  "over",
  "own",
  "owner",
  "oxygen",
  "oyster",
  "ozone",
  "pact",
  "paddle",
  "page",
  "pair",
  "palace",
  "palm",
  "panda",
  "panel",
  "panic",
  "panther",
  "paper",
  "parade",
  "parent",
  "park",
  "parrot",
  "party",
  "pass",
  "patch",
  "path",
  "patient",
  "patrol",
  "pattern",
  "pause",
  "pave",
  "payment",
  "peace",
  "peanut",
  "pear",
  "peasant",
  "pelican",
  "pen",
  "penalty",
  "pencil",
  "people",
  "pepper",
  "perfect",
  "permit",
  "person",
  "pet",
  "phone",
  "photo",
  "phrase",
  "physical",
  "piano",
  "picnic",
  "picture",
  "piece",
  "pig",
  "pigeon",
  "pill",
  "pilot",
  "pink",
  "pioneer",
  "pipe",
  "pistol",
  "pitch",
  "pizza",
  "place",
  "planet",
  "plastic",
  "plate",
  "play",
  "please",
  "pledge",
  "pluck",
  "plug",
  "plunge",
  "poem",
  "poet",
  "point",
  "polar",
  "pole",
  "police",
  "pond",
  "pony",
  "pool",
  "popular",
  "portion",
  "position",
  "possible",
  "post",
  "potato",
  "pottery",
  "poverty",
  "powder",
  "power",
  "practice",
  "praise",
  "predict",
  "prefer",
  "prepare",
  "present",
  "pretty",
  "prevent",
  "price",
  "pride",
  "primary",
  "print",
  "priority",
  "prison",
  "private",
  "prize",
  "problem",
  "process",
  "produce",
  "profit",
  "program",
  "project",
  "promote",
  "proof",
  "property",
  "prosper",
  "protect",
  "proud",
  "provide",
  "public",
  "pudding",
  "pull",
  "pulp",
  "pulse",
  "pumpkin",
  "punch",
  "pupil",
  "puppy",
  "purchase",
  "purity",
  "purpose",
  "purse",
  "push",
  "put",
  "puzzle",
  "pyramid",
  "quality",
  "quantum",
  "quarter",
  "question",
  "quick",
  "quit",
  "quiz",
  "quote",
  "rabbit",
  "raccoon",
  "race",
  "rack",
  "radar",
  "radio",
  "rail",
  "rain",
  "raise",
  "rally",
  "ramp",
  "ranch",
  "random",
  "range",
  "rapid",
  "rare",
  "rate",
  "rather",
  "raven",
  "raw",
  "razor",
  "ready",
  "real",
  "reason",
  "rebel",
  "rebuild",
  "recall",
  "receive",
  "recipe",
  "record",
  "recycle",
  "reduce",
  "reflect",
  "reform",
  "refuse",
  "region",
  "regret",
  "regular",
  "reject",
  "relax",
  "release",
  "relief",
  "rely",
  "remain",
  "remember",
  "remind",
  "remove",
  "render",
  "renew",
  "rent",
  "reopen",
  "repair",
  "repeat",
  "replace",
  "report",
  "require",
  "rescue",
  "resemble",
  "resist",
  "resource",
  "response",
  "result",
  "retire",
  "retreat",
  "return",
  "reunion",
  "reveal",
  "review",
  "reward",
  "rhythm",
  "rib",
  "ribbon",
  "rice",
  "rich",
  "ride",
  "ridge",
  "rifle",
  "right",
  "rigid",
  "ring",
  "riot",
  "ripple",
  "risk",
  "ritual",
  "rival",
  "river",
  "road",
  "roast",
  "robot",
  "robust",
  "rocket",
  "romance",
  "roof",
  "rookie",
  "room",
  "rose",
  "rotate",
  "rough",
  "round",
  "route",
  "royal",
  "rubber",
  "rude",
  "rug",
  "rule",
  "run",
  "runway",
  "rural",
  "sad",
  "saddle",
  "sadness",
  "safe",
  "sail",
  "salad",
  "salmon",
  "salon",
  "salt",
  "salute",
  "same",
  "sample",
  "sand",
  "satisfy",
  "satoshi",
  "sauce",
  "sausage",
  "save",
  "say",
  "scale",
  "scan",
  "scare",
  "scatter",
  "scene",
  "scheme",
  "school",
  "science",
  "scissors",
  "scorpion",
  "scout",
  "scrap",
  "screen",
  "script",
  "scrub",
  "sea",
  "search",
  "season",
  "seat",
  "second",
  "secret",
  "section",
  "security",
  "seed",
  "seek",
  "segment",
  "select",
  "sell",
  "seminar",
  "senior",
  "sense",
  "sentence",
  "series",
  "service",
  "session",
  "settle",
  "setup",
  "seven",
  "shadow",
  "shaft",
  "shallow",
  "share",
  "shed",
  "shell",
  "sheriff",
  "shield",
  "shift",
  "shine",
  "ship",
  "shiver",
  "shock",
  "shoe",
  "shoot",
  "shop",
  "short",
  "shoulder",
  "shove",
  "shrimp",
  "shrug",
  "shuffle",
  "shy",
  "sibling",
  "sick",
  "side",
  "siege",
  "sight",
  "sign",
  "silent",
  "silk",
  "silly",
  "silver",
  "similar",
  "simple",
  "since",
  "sing",
  "siren",
  "sister",
  "situate",
  "six",
  "size",
  "skate",
  "sketch",
  "ski",
  "skill",
  "skin",
  "skirt",
  "skull",
  "slab",
  "slam",
  "sleep",
  "slender",
  "slice",
  "slide",
  "slight",
  "slim",
  "slogan",
  "slot",
  "slow",
  "slush",
  "small",
  "smart",
  "smile",
  "smoke",
  "smooth",
  "snack",
  "snake",
  "snap",
  "sniff",
  "snow",
  "soap",
  "soccer",
  "social",
  "sock",
  "soda",
  "soft",
  "solar",
  "soldier",
  "solid",
  "solution",
  "solve",
  "someone",
  "song",
  "soon",
  "sorry",
  "sort",
  "soul",
  "sound",
  "soup",
  "source",
  "south",
  "space",
  "spare",
  "spatial",
  "spawn",
  "speak",
  "special",
  "speed",
  "spell",
  "spend",
  "sphere",
  "spice",
  "spider",
  "spike",
  "spin",
  "spirit",
  "split",
  "spoil",
  "sponsor",
  "spoon",
  "sport",
  "spot",
  "spray",
  "spread",
  "spring",
  "spy",
  "square",
  "squeeze",
  "squirrel",
  "stable",
  "stadium",
  "staff",
  "stage",
  "stairs",
  "stamp",
  "stand",
  "start",
  "state",
  "stay",
  "steak",
  "steel",
  "stem",
  "step",
  "stereo",
  "stick",
  "still",
  "sting",
  "stock",
  "stomach",
  "stone",
  "stool",
  "story",
  "stove",
  "strategy",
  "street",
  "strike",
  "strong",
  "struggle",
  "student",
  "stuff",
  "stumble",
  "style",
  "subject",
  "submit",
  "subway",
  "success",
  "such",
  "sudden",
  "suffer",
  "sugar",
  "suggest",
  "suit",
  "summer",
  "sun",
  "sunny",
  "sunset",
  "super",
  "supply",
  "supreme",
  "sure",
  "surface",
  "surge",
  "surprise",
  "surround",
  "survey",
  "suspect",
  "sustain",
  "swallow",
  "swamp",
  "swap",
  "swarm",
  "swear",
  "sweet",
  "swift",
  "swim",
  "swing",
  "switch",
  "sword",
  "symbol",
  "symptom",
  "syrup",
  "system",
  "table",
  "tackle",
  "tag",
  "tail",
  "talent",
  "talk",
  "tank",
  "tape",
  "target",
  "task",
  "taste",
  "tattoo",
  "taxi",
  "teach",
  "team",
  "tell",
  "ten",
  "tenant",
  "tennis",
  "tent",
  "term",
  "test",
  "text",
  "thank",
  "that",
  "theme",
  "then",
  "theory",
  "there",
  "they",
  "thing",
  "this",
  "thought",
  "three",
  "thrive",
  "throw",
  "thumb",
  "thunder",
  "ticket",
  "tide",
  "tiger",
  "tilt",
  "timber",
  "time",
  "tiny",
  "tip",
  "tired",
  "tissue",
  "title",
  "toast",
  "tobacco",
  "today",
  "toddler",
  "toe",
  "together",
  "toilet",
  "token",
  "tomato",
  "tomorrow",
  "tone",
  "tongue",
  "tonight",
  "tool",
  "tooth",
  "top",
  "topic",
  "topple",
  "torch",
  "tornado",
  "tortoise",
  "toss",
  "total",
  "tourist",
  "toward",
  "tower",
  "town",
  "toy",
  "track",
  "trade",
  "traffic",
  "tragic",
  "train",
  "transfer",
  "trap",
  "trash",
  "travel",
  "tray",
  "treat",
  "tree",
  "trend",
  "trial",
  "tribe",
  "trick",
  "trigger",
  "trim",
  "trip",
  "trophy",
  "trouble",
  "truck",
  "true",
  "truly",
  "trumpet",
  "trust",
  "truth",
  "try",
  "tube",
  "tuition",
  "tumble",
  "tuna",
  "tunnel",
  "turkey",
  "turn",
  "turtle",
  "twelve",
  "twenty",
  "twice",
  "twin",
  "twist",
  "two",
  "type",
  "typical",
  "ugly",
  "umbrella",
  "unable",
  "unaware",
  "uncle",
  "uncover",
  "under",
  "undo",
  "unfair",
  "unfold",
  "unhappy",
  "uniform",
  "unique",
  "unit",
  "universe",
  "unknown",
  "unlock",
  "until",
  "unusual",
  "unveil",
  "update",
  "upgrade",
  "uphold",
  "upon",
  "upper",
  "upset",
  "urban",
  "urge",
  "usage",
  "use",
  "used",
  "useful",
  "useless",
  "usual",
  "utility",
  "vacant",
  "vacuum",
  "vague",
  "valid",
  "valley",
  "valve",
  "van",
  "vanish",
  "vapor",
  "various",
  "vast",
  "vault",
  "vehicle",
  "velvet",
  "vendor",
  "venture",
  "venue",
  "verb",
  "verify",
  "version",
  "very",
  "vessel",
  "veteran",
  "viable",
  "vibrant",
  "vicious",
  "victory",
  "video",
  "view",
  "village",
  "vintage",
  "violin",
  "virtual",
  "virus",
  "visa",
  "visit",
  "visual",
  "vital",
  "vivid",
  "vocal",
  "voice",
  "void",
  "volcano",
  "volume",
  "vote",
  "voyage",
  "wage",
  "wagon",
  "wait",
  "walk",
  "wall",
  "walnut",
  "want",
  "warfare",
  "warm",
  "warrior",
  "wash",
  "wasp",
  "waste",
  "water",
  "wave",
  "way",
  "wealth",
  "weapon",
  "wear",
  "weasel",
  "weather",
  "web",
  "wedding",
  "weekend",
  "weird",
  "welcome",
  "west",
  "wet",
  "whale",
  "what",
  "wheat",
  "wheel",
  "when",
  "where",
  "whip",
  "whisper",
  "wide",
  "width",
  "wife",
  "wild",
  "will",
  "win",
  "window",
  "wine",
  "wing",
  "wink",
  "winner",
  "winter",
  "wire",
  "wisdom",
  "wise",
  "wish",
  "witness",
  "wolf",
  "woman",
  "wonder",
  "wood",
  "wool",
  "word",
  "work",
  "world",
  "worry",
  "worth",
  "wrap",
  "wreck",
  "wrestle",
  "wrist",
  "write",
  "wrong",
  "yard",
  "year",
  "yellow",
  "you",
  "young",
  "youth",
  "zebra",
  "zero",
  "zone",
  "zoo"
];
Object.defineProperty(_wordlists, "__esModule", { value: !0 });
const wordlists = {};
_wordlists.wordlists = wordlists;
let _default;
var _default_1 = _wordlists._default = _default;
try {
  _default_1 = _wordlists._default = _default = require$$0$1, wordlists.czech = _default;
} catch (Y) {
}
try {
  _default_1 = _wordlists._default = _default = require$$1, wordlists.chinese_simplified = _default;
} catch (Y) {
}
try {
  _default_1 = _wordlists._default = _default = require$$2$1, wordlists.chinese_traditional = _default;
} catch (Y) {
}
try {
  _default_1 = _wordlists._default = _default = require$$3, wordlists.korean = _default;
} catch (Y) {
}
try {
  _default_1 = _wordlists._default = _default = require$$4, wordlists.french = _default;
} catch (Y) {
}
try {
  _default_1 = _wordlists._default = _default = require$$5, wordlists.italian = _default;
} catch (Y) {
}
try {
  _default_1 = _wordlists._default = _default = require$$6, wordlists.spanish = _default;
} catch (Y) {
}
try {
  _default_1 = _wordlists._default = _default = require$$7, wordlists.japanese = _default, wordlists.JA = _default;
} catch (Y) {
}
try {
  _default_1 = _wordlists._default = _default = require$$8, wordlists.portuguese = _default;
} catch (Y) {
}
try {
  _default_1 = _wordlists._default = _default = require$$9, wordlists.english = _default, wordlists.EN = _default;
} catch (Y) {
}
Object.defineProperty(src$2, "__esModule", { value: !0 });
const sha256_1 = sha256$1, sha512_1 = sha512$1, pbkdf2_1 = pbkdf2$1, utils_1 = utils$1, _wordlists_1 = _wordlists;
let DEFAULT_WORDLIST = _wordlists_1._default;
const INVALID_MNEMONIC = "Invalid mnemonic", INVALID_ENTROPY = "Invalid entropy", INVALID_CHECKSUM = "Invalid mnemonic checksum", WORDLIST_REQUIRED = `A wordlist is required but a default could not be found.
Please pass a 2048 word array explicitly.`;
function normalize(Y) {
  return (Y || "").normalize("NFKD");
}
function lpad(Y, X, ee) {
  for (; Y.length < ee; )
    Y = X + Y;
  return Y;
}
function binaryToByte(Y) {
  return parseInt(Y, 2);
}
function bytesToBinary(Y) {
  return Y.map((X) => lpad(X.toString(2), "0", 8)).join("");
}
function deriveChecksumBits(Y) {
  const X = Y.length * 8 / 32, ee = sha256_1.sha256(Uint8Array.from(Y));
  return bytesToBinary(Array.from(ee)).slice(0, X);
}
function salt(Y) {
  return "mnemonic" + (Y || "");
}
function mnemonicToSeedSync(Y, X) {
  const ee = Uint8Array.from(Buffer$e.from(normalize(Y), "utf8")), te = Uint8Array.from(Buffer$e.from(salt(normalize(X)), "utf8")), ne = pbkdf2_1.pbkdf2(sha512_1.sha512, ee, te, {
    c: 2048,
    dkLen: 64
  });
  return Buffer$e.from(ne);
}
var mnemonicToSeedSync_1 = src$2.mnemonicToSeedSync = mnemonicToSeedSync;
function mnemonicToSeed(Y, X) {
  const ee = Uint8Array.from(Buffer$e.from(normalize(Y), "utf8")), te = Uint8Array.from(Buffer$e.from(salt(normalize(X)), "utf8"));
  return pbkdf2_1.pbkdf2Async(sha512_1.sha512, ee, te, {
    c: 2048,
    dkLen: 64
  }).then((ne) => Buffer$e.from(ne));
}
src$2.mnemonicToSeed = mnemonicToSeed;
function mnemonicToEntropy(Y, X) {
  if (X = X || DEFAULT_WORDLIST, !X)
    throw new Error(WORDLIST_REQUIRED);
  const ee = normalize(Y).split(" ");
  if (ee.length % 3 !== 0)
    throw new Error(INVALID_MNEMONIC);
  const te = ee.map((ue) => {
    const le = X.indexOf(ue);
    if (le === -1)
      throw new Error(INVALID_MNEMONIC);
    return lpad(le.toString(2), "0", 11);
  }).join(""), ne = Math.floor(te.length / 33) * 32, ie = te.slice(0, ne), oe = te.slice(ne), se = ie.match(/(.{1,8})/g).map(binaryToByte);
  if (se.length < 16)
    throw new Error(INVALID_ENTROPY);
  if (se.length > 32)
    throw new Error(INVALID_ENTROPY);
  if (se.length % 4 !== 0)
    throw new Error(INVALID_ENTROPY);
  const ae = Buffer$e.from(se);
  if (deriveChecksumBits(ae) !== oe)
    throw new Error(INVALID_CHECKSUM);
  return ae.toString("hex");
}
src$2.mnemonicToEntropy = mnemonicToEntropy;
function entropyToMnemonic(Y, X) {
  if (Buffer$e.isBuffer(Y) || (Y = Buffer$e.from(Y, "hex")), X = X || DEFAULT_WORDLIST, !X)
    throw new Error(WORDLIST_REQUIRED);
  if (Y.length < 16)
    throw new TypeError(INVALID_ENTROPY);
  if (Y.length > 32)
    throw new TypeError(INVALID_ENTROPY);
  if (Y.length % 4 !== 0)
    throw new TypeError(INVALID_ENTROPY);
  const ee = bytesToBinary(Array.from(Y)), te = deriveChecksumBits(Y), ne = (ee + te).match(/(.{1,11})/g).map((ie) => {
    const oe = binaryToByte(ie);
    return X[oe];
  });
  return X[0] === "" ? ne.join("") : ne.join(" ");
}
src$2.entropyToMnemonic = entropyToMnemonic;
function generateMnemonic(Y, X, ee) {
  if (Y = Y || 128, Y % 32 !== 0)
    throw new TypeError(INVALID_ENTROPY);
  return X = X || ((te) => Buffer$e.from(utils_1.randomBytes(te))), entropyToMnemonic(X(Y / 8), ee);
}
src$2.generateMnemonic = generateMnemonic;
function validateMnemonic(Y, X) {
  try {
    mnemonicToEntropy(Y, X);
  } catch {
    return !1;
  }
  return !0;
}
src$2.validateMnemonic = validateMnemonic;
function setDefaultWordlist(Y) {
  const X = _wordlists_1.wordlists[Y];
  if (X)
    DEFAULT_WORDLIST = X;
  else
    throw new Error('Could not find wordlist for language "' + Y + '"');
}
src$2.setDefaultWordlist = setDefaultWordlist;
function getDefaultWordlist() {
  if (!DEFAULT_WORDLIST)
    throw new Error("No Default Wordlist set");
  return Object.keys(_wordlists_1.wordlists).filter((Y) => Y === "JA" || Y === "EN" ? !1 : _wordlists_1.wordlists[Y].every((X, ee) => X === DEFAULT_WORDLIST[ee]))[0];
}
src$2.getDefaultWordlist = getDefaultWordlist;
var _wordlists_2 = _wordlists;
src$2.wordlists = _wordlists_2.wordlists;
function number$1(Y) {
  if (!Number.isSafeInteger(Y) || Y < 0)
    throw new Error(`Wrong positive integer: ${Y}`);
}
function isBytes$2(Y) {
  return Y instanceof Uint8Array || Y != null && typeof Y == "object" && Y.constructor.name === "Uint8Array";
}
function bytes(Y, ...X) {
  if (!isBytes$2(Y))
    throw new Error("Expected Uint8Array");
  if (X.length > 0 && !X.includes(Y.length))
    throw new Error(`Expected Uint8Array of length ${X}, not of length=${Y.length}`);
}
function hash(Y) {
  if (typeof Y != "function" || typeof Y.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number$1(Y.outputLen), number$1(Y.blockLen);
}
function exists(Y, X = !0) {
  if (Y.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (X && Y.finished)
    throw new Error("Hash#digest() has already been called");
}
function output(Y, X) {
  bytes(Y);
  const ee = X.outputLen;
  if (Y.length < ee)
    throw new Error(`digestInto() expects output buffer of length at least ${ee}`);
}
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function isBytes$1(Y) {
  return Y instanceof Uint8Array || Y != null && typeof Y == "object" && Y.constructor.name === "Uint8Array";
}
const createView = (Y) => new DataView(Y.buffer, Y.byteOffset, Y.byteLength), rotr = (Y, X) => Y << 32 - X | Y >>> X, isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!isLE)
  throw new Error("Non little-endian hardware is not supported");
function utf8ToBytes$1(Y) {
  if (typeof Y != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof Y}`);
  return new Uint8Array(new TextEncoder().encode(Y));
}
function toBytes(Y) {
  if (typeof Y == "string" && (Y = utf8ToBytes$1(Y)), !isBytes$1(Y))
    throw new Error(`expected Uint8Array, got ${typeof Y}`);
  return Y;
}
function concatBytes$1(...Y) {
  let X = 0;
  for (let te = 0; te < Y.length; te++) {
    const ne = Y[te];
    if (!isBytes$1(ne))
      throw new Error("Uint8Array expected");
    X += ne.length;
  }
  const ee = new Uint8Array(X);
  for (let te = 0, ne = 0; te < Y.length; te++) {
    const ie = Y[te];
    ee.set(ie, ne), ne += ie.length;
  }
  return ee;
}
class Hash {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
}
function wrapConstructor(Y) {
  const X = (te) => Y().update(toBytes(te)).digest(), ee = Y();
  return X.outputLen = ee.outputLen, X.blockLen = ee.blockLen, X.create = () => Y(), X;
}
function randomBytes(Y = 32) {
  if (crypto_1 && typeof crypto_1.getRandomValues == "function")
    return crypto_1.getRandomValues(new Uint8Array(Y));
  throw new Error("crypto.getRandomValues must be defined");
}
function setBigUint64(Y, X, ee, te) {
  if (typeof Y.setBigUint64 == "function")
    return Y.setBigUint64(X, ee, te);
  const ne = BigInt(32), ie = BigInt(4294967295), oe = Number(ee >> ne & ie), se = Number(ee & ie), ae = te ? 4 : 0, ue = te ? 0 : 4;
  Y.setUint32(X + ae, oe, te), Y.setUint32(X + ue, se, te);
}
class SHA2 extends Hash {
  constructor(X, ee, te, ne) {
    super(), this.blockLen = X, this.outputLen = ee, this.padOffset = te, this.isLE = ne, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(X), this.view = createView(this.buffer);
  }
  update(X) {
    exists(this);
    const { view: ee, buffer: te, blockLen: ne } = this;
    X = toBytes(X);
    const ie = X.length;
    for (let oe = 0; oe < ie; ) {
      const se = Math.min(ne - this.pos, ie - oe);
      if (se === ne) {
        const ae = createView(X);
        for (; ne <= ie - oe; oe += ne)
          this.process(ae, oe);
        continue;
      }
      te.set(X.subarray(oe, oe + se), this.pos), this.pos += se, oe += se, this.pos === ne && (this.process(ee, 0), this.pos = 0);
    }
    return this.length += X.length, this.roundClean(), this;
  }
  digestInto(X) {
    exists(this), output(X, this), this.finished = !0;
    const { buffer: ee, view: te, blockLen: ne, isLE: ie } = this;
    let { pos: oe } = this;
    ee[oe++] = 128, this.buffer.subarray(oe).fill(0), this.padOffset > ne - oe && (this.process(te, 0), oe = 0);
    for (let he = oe; he < ne; he++)
      ee[he] = 0;
    setBigUint64(te, ne - 8, BigInt(this.length * 8), ie), this.process(te, 0);
    const se = createView(X), ae = this.outputLen;
    if (ae % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const ue = ae / 4, le = this.get();
    if (ue > le.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let he = 0; he < ue; he++)
      se.setUint32(4 * he, le[he], ie);
  }
  digest() {
    const { buffer: X, outputLen: ee } = this;
    this.digestInto(X);
    const te = X.slice(0, ee);
    return this.destroy(), te;
  }
  _cloneInto(X) {
    X || (X = new this.constructor()), X.set(...this.get());
    const { blockLen: ee, buffer: te, length: ne, finished: ie, destroyed: oe, pos: se } = this;
    return X.length = ne, X.pos = se, X.finished = ie, X.destroyed = oe, ne % ee && X.buffer.set(te), X;
  }
}
const U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1), _32n = /* @__PURE__ */ BigInt(32);
function fromBig(Y, X = !1) {
  return X ? { h: Number(Y & U32_MASK64), l: Number(Y >> _32n & U32_MASK64) } : { h: Number(Y >> _32n & U32_MASK64) | 0, l: Number(Y & U32_MASK64) | 0 };
}
function split(Y, X = !1) {
  let ee = new Uint32Array(Y.length), te = new Uint32Array(Y.length);
  for (let ne = 0; ne < Y.length; ne++) {
    const { h: ie, l: oe } = fromBig(Y[ne], X);
    [ee[ne], te[ne]] = [ie, oe];
  }
  return [ee, te];
}
const toBig = (Y, X) => BigInt(Y >>> 0) << _32n | BigInt(X >>> 0), shrSH = (Y, X, ee) => Y >>> ee, shrSL = (Y, X, ee) => Y << 32 - ee | X >>> ee, rotrSH = (Y, X, ee) => Y >>> ee | X << 32 - ee, rotrSL = (Y, X, ee) => Y << 32 - ee | X >>> ee, rotrBH = (Y, X, ee) => Y << 64 - ee | X >>> ee - 32, rotrBL = (Y, X, ee) => Y >>> ee - 32 | X << 64 - ee, rotr32H = (Y, X) => X, rotr32L = (Y, X) => Y, rotlSH = (Y, X, ee) => Y << ee | X >>> 32 - ee, rotlSL = (Y, X, ee) => X << ee | Y >>> 32 - ee, rotlBH = (Y, X, ee) => X << ee - 32 | Y >>> 64 - ee, rotlBL = (Y, X, ee) => Y << ee - 32 | X >>> 64 - ee;
function add(Y, X, ee, te) {
  const ne = (X >>> 0) + (te >>> 0);
  return { h: Y + ee + (ne / 2 ** 32 | 0) | 0, l: ne | 0 };
}
const add3L = (Y, X, ee) => (Y >>> 0) + (X >>> 0) + (ee >>> 0), add3H = (Y, X, ee, te) => X + ee + te + (Y / 2 ** 32 | 0) | 0, add4L = (Y, X, ee, te) => (Y >>> 0) + (X >>> 0) + (ee >>> 0) + (te >>> 0), add4H = (Y, X, ee, te, ne) => X + ee + te + ne + (Y / 2 ** 32 | 0) | 0, add5L = (Y, X, ee, te, ne) => (Y >>> 0) + (X >>> 0) + (ee >>> 0) + (te >>> 0) + (ne >>> 0), add5H = (Y, X, ee, te, ne, ie) => X + ee + te + ne + ie + (Y / 2 ** 32 | 0) | 0, u64$2 = {
  fromBig,
  split,
  toBig,
  shrSH,
  shrSL,
  rotrSH,
  rotrSL,
  rotrBH,
  rotrBL,
  rotr32H,
  rotr32L,
  rotlSH,
  rotlSL,
  rotlBH,
  rotlBL,
  add,
  add3L,
  add3H,
  add4L,
  add4H,
  add5H,
  add5L
}, [SHA512_Kh, SHA512_Kl] = u64$2.split([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((Y) => BigInt(Y))), SHA512_W_H = /* @__PURE__ */ new Uint32Array(80), SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);
class SHA512 extends SHA2 {
  constructor() {
    super(128, 64, 16, !1), this.Ah = 1779033703, this.Al = -205731576, this.Bh = -1150833019, this.Bl = -2067093701, this.Ch = 1013904242, this.Cl = -23791573, this.Dh = -1521486534, this.Dl = 1595750129, this.Eh = 1359893119, this.El = -1377402159, this.Fh = -1694144372, this.Fl = 725511199, this.Gh = 528734635, this.Gl = -79577749, this.Hh = 1541459225, this.Hl = 327033209;
  }
  // prettier-ignore
  get() {
    const { Ah: X, Al: ee, Bh: te, Bl: ne, Ch: ie, Cl: oe, Dh: se, Dl: ae, Eh: ue, El: le, Fh: he, Fl: me, Gh: ye, Gl: we, Hh: Ee, Hl: Re } = this;
    return [X, ee, te, ne, ie, oe, se, ae, ue, le, he, me, ye, we, Ee, Re];
  }
  // prettier-ignore
  set(X, ee, te, ne, ie, oe, se, ae, ue, le, he, me, ye, we, Ee, Re) {
    this.Ah = X | 0, this.Al = ee | 0, this.Bh = te | 0, this.Bl = ne | 0, this.Ch = ie | 0, this.Cl = oe | 0, this.Dh = se | 0, this.Dl = ae | 0, this.Eh = ue | 0, this.El = le | 0, this.Fh = he | 0, this.Fl = me | 0, this.Gh = ye | 0, this.Gl = we | 0, this.Hh = Ee | 0, this.Hl = Re | 0;
  }
  process(X, ee) {
    for (let De = 0; De < 16; De++, ee += 4)
      SHA512_W_H[De] = X.getUint32(ee), SHA512_W_L[De] = X.getUint32(ee += 4);
    for (let De = 16; De < 80; De++) {
      const Fe = SHA512_W_H[De - 15] | 0, Ke = SHA512_W_L[De - 15] | 0, tt = u64$2.rotrSH(Fe, Ke, 1) ^ u64$2.rotrSH(Fe, Ke, 8) ^ u64$2.shrSH(Fe, Ke, 7), rt = u64$2.rotrSL(Fe, Ke, 1) ^ u64$2.rotrSL(Fe, Ke, 8) ^ u64$2.shrSL(Fe, Ke, 7), it = SHA512_W_H[De - 2] | 0, _t = SHA512_W_L[De - 2] | 0, Dt = u64$2.rotrSH(it, _t, 19) ^ u64$2.rotrBH(it, _t, 61) ^ u64$2.shrSH(it, _t, 6), je = u64$2.rotrSL(it, _t, 19) ^ u64$2.rotrBL(it, _t, 61) ^ u64$2.shrSL(it, _t, 6), ze = u64$2.add4L(rt, je, SHA512_W_L[De - 7], SHA512_W_L[De - 16]), fe = u64$2.add4H(ze, tt, Dt, SHA512_W_H[De - 7], SHA512_W_H[De - 16]);
      SHA512_W_H[De] = fe | 0, SHA512_W_L[De] = ze | 0;
    }
    let { Ah: te, Al: ne, Bh: ie, Bl: oe, Ch: se, Cl: ae, Dh: ue, Dl: le, Eh: he, El: me, Fh: ye, Fl: we, Gh: Ee, Gl: Re, Hh: Ue, Hl: Me } = this;
    for (let De = 0; De < 80; De++) {
      const Fe = u64$2.rotrSH(he, me, 14) ^ u64$2.rotrSH(he, me, 18) ^ u64$2.rotrBH(he, me, 41), Ke = u64$2.rotrSL(he, me, 14) ^ u64$2.rotrSL(he, me, 18) ^ u64$2.rotrBL(he, me, 41), tt = he & ye ^ ~he & Ee, rt = me & we ^ ~me & Re, it = u64$2.add5L(Me, Ke, rt, SHA512_Kl[De], SHA512_W_L[De]), _t = u64$2.add5H(it, Ue, Fe, tt, SHA512_Kh[De], SHA512_W_H[De]), Dt = it | 0, je = u64$2.rotrSH(te, ne, 28) ^ u64$2.rotrBH(te, ne, 34) ^ u64$2.rotrBH(te, ne, 39), ze = u64$2.rotrSL(te, ne, 28) ^ u64$2.rotrBL(te, ne, 34) ^ u64$2.rotrBL(te, ne, 39), fe = te & ie ^ te & se ^ ie & se, de = ne & oe ^ ne & ae ^ oe & ae;
      Ue = Ee | 0, Me = Re | 0, Ee = ye | 0, Re = we | 0, ye = he | 0, we = me | 0, { h: he, l: me } = u64$2.add(ue | 0, le | 0, _t | 0, Dt | 0), ue = se | 0, le = ae | 0, se = ie | 0, ae = oe | 0, ie = te | 0, oe = ne | 0;
      const be = u64$2.add3L(Dt, ze, de);
      te = u64$2.add3H(be, _t, je, fe), ne = be | 0;
    }
    ({ h: te, l: ne } = u64$2.add(this.Ah | 0, this.Al | 0, te | 0, ne | 0)), { h: ie, l: oe } = u64$2.add(this.Bh | 0, this.Bl | 0, ie | 0, oe | 0), { h: se, l: ae } = u64$2.add(this.Ch | 0, this.Cl | 0, se | 0, ae | 0), { h: ue, l: le } = u64$2.add(this.Dh | 0, this.Dl | 0, ue | 0, le | 0), { h: he, l: me } = u64$2.add(this.Eh | 0, this.El | 0, he | 0, me | 0), { h: ye, l: we } = u64$2.add(this.Fh | 0, this.Fl | 0, ye | 0, we | 0), { h: Ee, l: Re } = u64$2.add(this.Gh | 0, this.Gl | 0, Ee | 0, Re | 0), { h: Ue, l: Me } = u64$2.add(this.Hh | 0, this.Hl | 0, Ue | 0, Me | 0), this.set(te, ne, ie, oe, se, ae, ue, le, he, me, ye, we, Ee, Re, Ue, Me);
  }
  roundClean() {
    SHA512_W_H.fill(0), SHA512_W_L.fill(0);
  }
  destroy() {
    this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
}
const sha512 = /* @__PURE__ */ wrapConstructor(() => new SHA512());
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$4 = BigInt(0), _1n$6 = BigInt(1), _2n$4 = BigInt(2);
function isBytes(Y) {
  return Y instanceof Uint8Array || Y != null && typeof Y == "object" && Y.constructor.name === "Uint8Array";
}
const hexes = /* @__PURE__ */ Array.from({ length: 256 }, (Y, X) => X.toString(16).padStart(2, "0"));
function bytesToHex(Y) {
  if (!isBytes(Y))
    throw new Error("Uint8Array expected");
  let X = "";
  for (let ee = 0; ee < Y.length; ee++)
    X += hexes[Y[ee]];
  return X;
}
function numberToHexUnpadded(Y) {
  const X = Y.toString(16);
  return X.length & 1 ? `0${X}` : X;
}
function hexToNumber(Y) {
  if (typeof Y != "string")
    throw new Error("hex string expected, got " + typeof Y);
  return BigInt(Y === "" ? "0" : `0x${Y}`);
}
const asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
function asciiToBase16(Y) {
  if (Y >= asciis._0 && Y <= asciis._9)
    return Y - asciis._0;
  if (Y >= asciis._A && Y <= asciis._F)
    return Y - (asciis._A - 10);
  if (Y >= asciis._a && Y <= asciis._f)
    return Y - (asciis._a - 10);
}
function hexToBytes(Y) {
  if (typeof Y != "string")
    throw new Error("hex string expected, got " + typeof Y);
  const X = Y.length, ee = X / 2;
  if (X % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + X);
  const te = new Uint8Array(ee);
  for (let ne = 0, ie = 0; ne < ee; ne++, ie += 2) {
    const oe = asciiToBase16(Y.charCodeAt(ie)), se = asciiToBase16(Y.charCodeAt(ie + 1));
    if (oe === void 0 || se === void 0) {
      const ae = Y[ie] + Y[ie + 1];
      throw new Error('hex string expected, got non-hex character "' + ae + '" at index ' + ie);
    }
    te[ne] = oe * 16 + se;
  }
  return te;
}
function bytesToNumberBE(Y) {
  return hexToNumber(bytesToHex(Y));
}
function bytesToNumberLE(Y) {
  if (!isBytes(Y))
    throw new Error("Uint8Array expected");
  return hexToNumber(bytesToHex(Uint8Array.from(Y).reverse()));
}
function numberToBytesBE(Y, X) {
  return hexToBytes(Y.toString(16).padStart(X * 2, "0"));
}
function numberToBytesLE(Y, X) {
  return numberToBytesBE(Y, X).reverse();
}
function numberToVarBytesBE(Y) {
  return hexToBytes(numberToHexUnpadded(Y));
}
function ensureBytes(Y, X, ee) {
  let te;
  if (typeof X == "string")
    try {
      te = hexToBytes(X);
    } catch (ie) {
      throw new Error(`${Y} must be valid hex string, got "${X}". Cause: ${ie}`);
    }
  else if (isBytes(X))
    te = Uint8Array.from(X);
  else
    throw new Error(`${Y} must be hex string or Uint8Array`);
  const ne = te.length;
  if (typeof ee == "number" && ne !== ee)
    throw new Error(`${Y} expected ${ee} bytes, got ${ne}`);
  return te;
}
function concatBytes(...Y) {
  let X = 0;
  for (let ne = 0; ne < Y.length; ne++) {
    const ie = Y[ne];
    if (!isBytes(ie))
      throw new Error("Uint8Array expected");
    X += ie.length;
  }
  let ee = new Uint8Array(X), te = 0;
  for (let ne = 0; ne < Y.length; ne++) {
    const ie = Y[ne];
    ee.set(ie, te), te += ie.length;
  }
  return ee;
}
function equalBytes(Y, X) {
  if (Y.length !== X.length)
    return !1;
  let ee = 0;
  for (let te = 0; te < Y.length; te++)
    ee |= Y[te] ^ X[te];
  return ee === 0;
}
function utf8ToBytes(Y) {
  if (typeof Y != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof Y}`);
  return new Uint8Array(new TextEncoder().encode(Y));
}
function bitLen(Y) {
  let X;
  for (X = 0; Y > _0n$4; Y >>= _1n$6, X += 1)
    ;
  return X;
}
function bitGet(Y, X) {
  return Y >> BigInt(X) & _1n$6;
}
const bitSet = (Y, X, ee) => Y | (ee ? _1n$6 : _0n$4) << BigInt(X), bitMask = (Y) => (_2n$4 << BigInt(Y - 1)) - _1n$6, u8n = (Y) => new Uint8Array(Y), u8fr = (Y) => Uint8Array.from(Y);
function createHmacDrbg(Y, X, ee) {
  if (typeof Y != "number" || Y < 2)
    throw new Error("hashLen must be a number");
  if (typeof X != "number" || X < 2)
    throw new Error("qByteLen must be a number");
  if (typeof ee != "function")
    throw new Error("hmacFn must be a function");
  let te = u8n(Y), ne = u8n(Y), ie = 0;
  const oe = () => {
    te.fill(1), ne.fill(0), ie = 0;
  }, se = (...le) => ee(ne, te, ...le), ae = (le = u8n()) => {
    ne = se(u8fr([0]), le), te = se(), le.length !== 0 && (ne = se(u8fr([1]), le), te = se());
  }, ue = () => {
    if (ie++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let le = 0;
    const he = [];
    for (; le < X; ) {
      te = se();
      const me = te.slice();
      he.push(me), le += te.length;
    }
    return concatBytes(...he);
  };
  return (le, he) => {
    oe(), ae(le);
    let me;
    for (; !(me = he(ue())); )
      ae();
    return oe(), me;
  };
}
const validatorFns = {
  bigint: (Y) => typeof Y == "bigint",
  function: (Y) => typeof Y == "function",
  boolean: (Y) => typeof Y == "boolean",
  string: (Y) => typeof Y == "string",
  stringOrUint8Array: (Y) => typeof Y == "string" || isBytes(Y),
  isSafeInteger: (Y) => Number.isSafeInteger(Y),
  array: (Y) => Array.isArray(Y),
  field: (Y, X) => X.Fp.isValid(Y),
  hash: (Y) => typeof Y == "function" && Number.isSafeInteger(Y.outputLen)
};
function validateObject(Y, X, ee = {}) {
  const te = (ne, ie, oe) => {
    const se = validatorFns[ie];
    if (typeof se != "function")
      throw new Error(`Invalid validator "${ie}", expected function`);
    const ae = Y[ne];
    if (!(oe && ae === void 0) && !se(ae, Y))
      throw new Error(`Invalid param ${String(ne)}=${ae} (${typeof ae}), expected ${ie}`);
  };
  for (const [ne, ie] of Object.entries(X))
    te(ne, ie, !1);
  for (const [ne, ie] of Object.entries(ee))
    te(ne, ie, !0);
  return Y;
}
const ut = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  bitGet,
  bitLen,
  bitMask,
  bitSet,
  bytesToHex,
  bytesToNumberBE,
  bytesToNumberLE,
  concatBytes,
  createHmacDrbg,
  ensureBytes,
  equalBytes,
  hexToBytes,
  hexToNumber,
  isBytes,
  numberToBytesBE,
  numberToBytesLE,
  numberToHexUnpadded,
  numberToVarBytesBE,
  utf8ToBytes,
  validateObject
}, Symbol.toStringTag, { value: "Module" }));
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$3 = BigInt(0), _1n$5 = BigInt(1), _2n$3 = BigInt(2), _3n$1 = BigInt(3), _4n = BigInt(4), _5n$1 = BigInt(5), _8n$1 = BigInt(8);
BigInt(9);
BigInt(16);
function mod(Y, X) {
  const ee = Y % X;
  return ee >= _0n$3 ? ee : X + ee;
}
function pow(Y, X, ee) {
  if (ee <= _0n$3 || X < _0n$3)
    throw new Error("Expected power/modulo > 0");
  if (ee === _1n$5)
    return _0n$3;
  let te = _1n$5;
  for (; X > _0n$3; )
    X & _1n$5 && (te = te * Y % ee), Y = Y * Y % ee, X >>= _1n$5;
  return te;
}
function pow2(Y, X, ee) {
  let te = Y;
  for (; X-- > _0n$3; )
    te *= te, te %= ee;
  return te;
}
function invert(Y, X) {
  if (Y === _0n$3 || X <= _0n$3)
    throw new Error(`invert: expected positive integers, got n=${Y} mod=${X}`);
  let ee = mod(Y, X), te = X, ne = _0n$3, ie = _1n$5;
  for (; ee !== _0n$3; ) {
    const oe = te / ee, se = te % ee, ae = ne - ie * oe;
    te = ee, ee = se, ne = ie, ie = ae;
  }
  if (te !== _1n$5)
    throw new Error("invert: does not exist");
  return mod(ne, X);
}
function tonelliShanks(Y) {
  const X = (Y - _1n$5) / _2n$3;
  let ee, te, ne;
  for (ee = Y - _1n$5, te = 0; ee % _2n$3 === _0n$3; ee /= _2n$3, te++)
    ;
  for (ne = _2n$3; ne < Y && pow(ne, X, Y) !== Y - _1n$5; ne++)
    ;
  if (te === 1) {
    const oe = (Y + _1n$5) / _4n;
    return function(se, ae) {
      const ue = se.pow(ae, oe);
      if (!se.eql(se.sqr(ue), ae))
        throw new Error("Cannot find square root");
      return ue;
    };
  }
  const ie = (ee + _1n$5) / _2n$3;
  return function(oe, se) {
    if (oe.pow(se, X) === oe.neg(oe.ONE))
      throw new Error("Cannot find square root");
    let ae = te, ue = oe.pow(oe.mul(oe.ONE, ne), ee), le = oe.pow(se, ie), he = oe.pow(se, ee);
    for (; !oe.eql(he, oe.ONE); ) {
      if (oe.eql(he, oe.ZERO))
        return oe.ZERO;
      let me = 1;
      for (let we = oe.sqr(he); me < ae && !oe.eql(we, oe.ONE); me++)
        we = oe.sqr(we);
      const ye = oe.pow(ue, _1n$5 << BigInt(ae - me - 1));
      ue = oe.sqr(ye), le = oe.mul(le, ye), he = oe.mul(he, ue), ae = me;
    }
    return le;
  };
}
function FpSqrt(Y) {
  if (Y % _4n === _3n$1) {
    const X = (Y + _1n$5) / _4n;
    return function(ee, te) {
      const ne = ee.pow(te, X);
      if (!ee.eql(ee.sqr(ne), te))
        throw new Error("Cannot find square root");
      return ne;
    };
  }
  if (Y % _8n$1 === _5n$1) {
    const X = (Y - _5n$1) / _8n$1;
    return function(ee, te) {
      const ne = ee.mul(te, _2n$3), ie = ee.pow(ne, X), oe = ee.mul(te, ie), se = ee.mul(ee.mul(oe, _2n$3), ie), ae = ee.mul(oe, ee.sub(se, ee.ONE));
      if (!ee.eql(ee.sqr(ae), te))
        throw new Error("Cannot find square root");
      return ae;
    };
  }
  return tonelliShanks(Y);
}
const isNegativeLE = (Y, X) => (mod(Y, X) & _1n$5) === _1n$5, FIELD_FIELDS = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function validateField(Y) {
  const X = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  }, ee = FIELD_FIELDS.reduce((te, ne) => (te[ne] = "function", te), X);
  return validateObject(Y, ee);
}
function FpPow(Y, X, ee) {
  if (ee < _0n$3)
    throw new Error("Expected power > 0");
  if (ee === _0n$3)
    return Y.ONE;
  if (ee === _1n$5)
    return X;
  let te = Y.ONE, ne = X;
  for (; ee > _0n$3; )
    ee & _1n$5 && (te = Y.mul(te, ne)), ne = Y.sqr(ne), ee >>= _1n$5;
  return te;
}
function FpInvertBatch(Y, X) {
  const ee = new Array(X.length), te = X.reduce((ie, oe, se) => Y.is0(oe) ? ie : (ee[se] = ie, Y.mul(ie, oe)), Y.ONE), ne = Y.inv(te);
  return X.reduceRight((ie, oe, se) => Y.is0(oe) ? ie : (ee[se] = Y.mul(ie, ee[se]), Y.mul(ie, oe)), ne), ee;
}
function nLength(Y, X) {
  const ee = X !== void 0 ? X : Y.toString(2).length, te = Math.ceil(ee / 8);
  return { nBitLength: ee, nByteLength: te };
}
function Field(Y, X, ee = !1, te = {}) {
  if (Y <= _0n$3)
    throw new Error(`Expected Field ORDER > 0, got ${Y}`);
  const { nBitLength: ne, nByteLength: ie } = nLength(Y, X);
  if (ie > 2048)
    throw new Error("Field lengths over 2048 bytes are not supported");
  const oe = FpSqrt(Y), se = Object.freeze({
    ORDER: Y,
    BITS: ne,
    BYTES: ie,
    MASK: bitMask(ne),
    ZERO: _0n$3,
    ONE: _1n$5,
    create: (ae) => mod(ae, Y),
    isValid: (ae) => {
      if (typeof ae != "bigint")
        throw new Error(`Invalid field element: expected bigint, got ${typeof ae}`);
      return _0n$3 <= ae && ae < Y;
    },
    is0: (ae) => ae === _0n$3,
    isOdd: (ae) => (ae & _1n$5) === _1n$5,
    neg: (ae) => mod(-ae, Y),
    eql: (ae, ue) => ae === ue,
    sqr: (ae) => mod(ae * ae, Y),
    add: (ae, ue) => mod(ae + ue, Y),
    sub: (ae, ue) => mod(ae - ue, Y),
    mul: (ae, ue) => mod(ae * ue, Y),
    pow: (ae, ue) => FpPow(se, ae, ue),
    div: (ae, ue) => mod(ae * invert(ue, Y), Y),
    // Same as above, but doesn't normalize
    sqrN: (ae) => ae * ae,
    addN: (ae, ue) => ae + ue,
    subN: (ae, ue) => ae - ue,
    mulN: (ae, ue) => ae * ue,
    inv: (ae) => invert(ae, Y),
    sqrt: te.sqrt || ((ae) => oe(se, ae)),
    invertBatch: (ae) => FpInvertBatch(se, ae),
    // TODO: do we really need constant cmov?
    // We don't have const-time bigints anyway, so probably will be not very useful
    cmov: (ae, ue, le) => le ? ue : ae,
    toBytes: (ae) => ee ? numberToBytesLE(ae, ie) : numberToBytesBE(ae, ie),
    fromBytes: (ae) => {
      if (ae.length !== ie)
        throw new Error(`Fp.fromBytes: expected ${ie}, got ${ae.length}`);
      return ee ? bytesToNumberLE(ae) : bytesToNumberBE(ae);
    }
  });
  return Object.freeze(se);
}
function FpSqrtEven(Y, X) {
  if (!Y.isOdd)
    throw new Error("Field doesn't have isOdd");
  const ee = Y.sqrt(X);
  return Y.isOdd(ee) ? Y.neg(ee) : ee;
}
function getFieldBytesLength(Y) {
  if (typeof Y != "bigint")
    throw new Error("field order must be bigint");
  const X = Y.toString(2).length;
  return Math.ceil(X / 8);
}
function getMinHashLength(Y) {
  const X = getFieldBytesLength(Y);
  return X + Math.ceil(X / 2);
}
function mapHashToField(Y, X, ee = !1) {
  const te = Y.length, ne = getFieldBytesLength(X), ie = getMinHashLength(X);
  if (te < 16 || te < ie || te > 1024)
    throw new Error(`expected ${ie}-1024 bytes of input, got ${te}`);
  const oe = ee ? bytesToNumberBE(Y) : bytesToNumberLE(Y), se = mod(oe, X - _1n$5) + _1n$5;
  return ee ? numberToBytesLE(se, ne) : numberToBytesBE(se, ne);
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$2 = BigInt(0), _1n$4 = BigInt(1);
function wNAF(Y, X) {
  const ee = (ne, ie) => {
    const oe = ie.negate();
    return ne ? oe : ie;
  }, te = (ne) => {
    const ie = Math.ceil(X / ne) + 1, oe = 2 ** (ne - 1);
    return { windows: ie, windowSize: oe };
  };
  return {
    constTimeNegate: ee,
    // non-const time multiplication ladder
    unsafeLadder(ne, ie) {
      let oe = Y.ZERO, se = ne;
      for (; ie > _0n$2; )
        ie & _1n$4 && (oe = oe.add(se)), se = se.double(), ie >>= _1n$4;
      return oe;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(1) * (Math.ceil( / ) + 1), where:
     * -  is the window size
     * -  is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(ne, ie) {
      const { windows: oe, windowSize: se } = te(ie), ae = [];
      let ue = ne, le = ue;
      for (let he = 0; he < oe; he++) {
        le = ue, ae.push(le);
        for (let me = 1; me < se; me++)
          le = le.add(ue), ae.push(le);
        ue = le.double();
      }
      return ae;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(ne, ie, oe) {
      const { windows: se, windowSize: ae } = te(ne);
      let ue = Y.ZERO, le = Y.BASE;
      const he = BigInt(2 ** ne - 1), me = 2 ** ne, ye = BigInt(ne);
      for (let we = 0; we < se; we++) {
        const Ee = we * ae;
        let Re = Number(oe & he);
        oe >>= ye, Re > ae && (Re -= me, oe += _1n$4);
        const Ue = Ee, Me = Ee + Math.abs(Re) - 1, De = we % 2 !== 0, Fe = Re < 0;
        Re === 0 ? le = le.add(ee(De, ie[Ue])) : ue = ue.add(ee(Fe, ie[Me]));
      }
      return { p: ue, f: le };
    },
    wNAFCached(ne, ie, oe, se) {
      const ae = ne._WINDOW_SIZE || 1;
      let ue = ie.get(ne);
      return ue || (ue = this.precomputeWindow(ne, ae), ae !== 1 && ie.set(ne, se(ue))), this.wNAF(ae, ue, oe);
    }
  };
}
function validateBasic(Y) {
  return validateField(Y.Fp), validateObject(Y, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  }), Object.freeze({
    ...nLength(Y.n, Y.nBitLength),
    ...Y,
    p: Y.Fp.ORDER
  });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$1 = BigInt(0), _1n$3 = BigInt(1), _2n$2 = BigInt(2), _8n = BigInt(8), VERIFY_DEFAULT = { zip215: !0 };
function validateOpts$1(Y) {
  const X = validateBasic(Y);
  return validateObject(Y, {
    hash: "function",
    a: "bigint",
    d: "bigint",
    randomBytes: "function"
  }, {
    adjustScalarBytes: "function",
    domain: "function",
    uvRatio: "function",
    mapToCurve: "function"
  }), Object.freeze({ ...X });
}
function twistedEdwards(Y) {
  const X = validateOpts$1(Y), { Fp: ee, n: te, prehash: ne, hash: ie, randomBytes: oe, nByteLength: se, h: ae } = X, ue = _2n$2 << BigInt(se * 8) - _1n$3, le = ee.create, he = X.uvRatio || ((Ce, Pe) => {
    try {
      return { isValid: !0, value: ee.sqrt(Ce * ee.inv(Pe)) };
    } catch {
      return { isValid: !1, value: _0n$1 };
    }
  }), me = X.adjustScalarBytes || ((Ce) => Ce), ye = X.domain || ((Ce, Pe, Se) => {
    if (Pe.length || Se)
      throw new Error("Contexts/pre-hash are not supported");
    return Ce;
  }), we = (Ce) => typeof Ce == "bigint" && _0n$1 < Ce, Ee = (Ce, Pe) => we(Ce) && we(Pe) && Ce < Pe, Re = (Ce) => Ce === _0n$1 || Ee(Ce, ue);
  function Ue(Ce, Pe) {
    if (Ee(Ce, Pe))
      return Ce;
    throw new Error(`Expected valid scalar < ${Pe}, got ${typeof Ce} ${Ce}`);
  }
  function Me(Ce) {
    return Ce === _0n$1 ? Ce : Ue(Ce, te);
  }
  const De = /* @__PURE__ */ new Map();
  function Fe(Ce) {
    if (!(Ce instanceof Ke))
      throw new Error("ExtendedPoint expected");
  }
  class Ke {
    constructor(Pe, Se, ke, ge) {
      if (this.ex = Pe, this.ey = Se, this.ez = ke, this.et = ge, !Re(Pe))
        throw new Error("x required");
      if (!Re(Se))
        throw new Error("y required");
      if (!Re(ke))
        throw new Error("z required");
      if (!Re(ge))
        throw new Error("t required");
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    static fromAffine(Pe) {
      if (Pe instanceof Ke)
        throw new Error("extended point not allowed");
      const { x: Se, y: ke } = Pe || {};
      if (!Re(Se) || !Re(ke))
        throw new Error("invalid affine point");
      return new Ke(Se, ke, _1n$3, le(Se * ke));
    }
    static normalizeZ(Pe) {
      const Se = ee.invertBatch(Pe.map((ke) => ke.ez));
      return Pe.map((ke, ge) => ke.toAffine(Se[ge])).map(Ke.fromAffine);
    }
    // "Private method", don't use it directly
    _setWindowSize(Pe) {
      this._WINDOW_SIZE = Pe, De.delete(this);
    }
    // Not required for fromHex(), which always creates valid points.
    // Could be useful for fromAffine().
    assertValidity() {
      const { a: Pe, d: Se } = X;
      if (this.is0())
        throw new Error("bad point: ZERO");
      const { ex: ke, ey: ge, ez: Ae, et: Ge } = this, Xe = le(ke * ke), $e = le(ge * ge), Ze = le(Ae * Ae), ot = le(Ze * Ze), ct = le(Xe * Pe), At = le(Ze * le(ct + $e)), Tt = le(ot + le(Se * le(Xe * $e)));
      if (At !== Tt)
        throw new Error("bad point: equation left != right (1)");
      const dt = le(ke * ge), vt = le(Ae * Ge);
      if (dt !== vt)
        throw new Error("bad point: equation left != right (2)");
    }
    // Compare one point to another.
    equals(Pe) {
      Fe(Pe);
      const { ex: Se, ey: ke, ez: ge } = this, { ex: Ae, ey: Ge, ez: Xe } = Pe, $e = le(Se * Xe), Ze = le(Ae * ge), ot = le(ke * Xe), ct = le(Ge * ge);
      return $e === Ze && ot === ct;
    }
    is0() {
      return this.equals(Ke.ZERO);
    }
    negate() {
      return new Ke(le(-this.ex), this.ey, this.ez, le(-this.et));
    }
    // Fast algo for doubling Extended Point.
    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd
    // Cost: 4M + 4S + 1*a + 6add + 1*2.
    double() {
      const { a: Pe } = X, { ex: Se, ey: ke, ez: ge } = this, Ae = le(Se * Se), Ge = le(ke * ke), Xe = le(_2n$2 * le(ge * ge)), $e = le(Pe * Ae), Ze = Se + ke, ot = le(le(Ze * Ze) - Ae - Ge), ct = $e + Ge, At = ct - Xe, Tt = $e - Ge, dt = le(ot * At), vt = le(ct * Tt), Ut = le(ot * Tt), It = le(At * ct);
      return new Ke(dt, vt, It, Ut);
    }
    // Fast algo for adding 2 Extended Points.
    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd
    // Cost: 9M + 1*a + 1*d + 7add.
    add(Pe) {
      Fe(Pe);
      const { a: Se, d: ke } = X, { ex: ge, ey: Ae, ez: Ge, et: Xe } = this, { ex: $e, ey: Ze, ez: ot, et: ct } = Pe;
      if (Se === BigInt(-1)) {
        const hX = le((Ae - ge) * (Ze + $e)), oX = le((Ae + ge) * (Ze - $e)), Nn = le(oX - hX);
        if (Nn === _0n$1)
          return this.double();
        const SX = le(Ge * _2n$2 * ct), sX = le(Xe * _2n$2 * ot), nX = sX + SX, Ye = oX + hX, lt = sX - SX, pt = le(nX * Nn), He = le(Ye * lt), Je = le(nX * lt), st = le(Nn * Ye);
        return new Ke(pt, He, st, Je);
      }
      const At = le(ge * $e), Tt = le(Ae * Ze), dt = le(Xe * ke * ct), vt = le(Ge * ot), Ut = le((ge + Ae) * ($e + Ze) - At - Tt), It = vt - dt, Er = vt + dt, Fr = le(Tt - Se * At), an = le(Ut * It), wX = le(Er * Fr), Ct = le(Ut * Fr), w_ = le(It * Er);
      return new Ke(an, wX, w_, Ct);
    }
    subtract(Pe) {
      return this.add(Pe.negate());
    }
    wNAF(Pe) {
      return it.wNAFCached(this, De, Pe, Ke.normalizeZ);
    }
    // Constant-time multiplication.
    multiply(Pe) {
      const { p: Se, f: ke } = this.wNAF(Ue(Pe, te));
      return Ke.normalizeZ([Se, ke])[0];
    }
    // Non-constant-time multiplication. Uses double-and-add algorithm.
    // It's faster, but should only be used when you don't care about
    // an exposed private key e.g. sig verification.
    // Does NOT allow scalars higher than CURVE.n.
    multiplyUnsafe(Pe) {
      let Se = Me(Pe);
      return Se === _0n$1 ? rt : this.equals(rt) || Se === _1n$3 ? this : this.equals(tt) ? this.wNAF(Se).p : it.unsafeLadder(this, Se);
    }
    // Checks if point is of small order.
    // If you add something to small order point, you will have "dirty"
    // point with torsion component.
    // Multiplies point by cofactor and checks if the result is 0.
    isSmallOrder() {
      return this.multiplyUnsafe(ae).is0();
    }
    // Multiplies point by curve order and checks if the result is 0.
    // Returns `false` is the point is dirty.
    isTorsionFree() {
      return it.unsafeLadder(this, te).is0();
    }
    // Converts Extended point to default (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    toAffine(Pe) {
      const { ex: Se, ey: ke, ez: ge } = this, Ae = this.is0();
      Pe == null && (Pe = Ae ? _8n : ee.inv(ge));
      const Ge = le(Se * Pe), Xe = le(ke * Pe), $e = le(ge * Pe);
      if (Ae)
        return { x: _0n$1, y: _1n$3 };
      if ($e !== _1n$3)
        throw new Error("invZ was invalid");
      return { x: Ge, y: Xe };
    }
    clearCofactor() {
      const { h: Pe } = X;
      return Pe === _1n$3 ? this : this.multiplyUnsafe(Pe);
    }
    // Converts hash string or Uint8Array to Point.
    // Uses algo from RFC8032 5.1.3.
    static fromHex(Pe, Se = !1) {
      const { d: ke, a: ge } = X, Ae = ee.BYTES;
      Pe = ensureBytes("pointHex", Pe, Ae);
      const Ge = Pe.slice(), Xe = Pe[Ae - 1];
      Ge[Ae - 1] = Xe & -129;
      const $e = bytesToNumberLE(Ge);
      $e === _0n$1 || (Se ? Ue($e, ue) : Ue($e, ee.ORDER));
      const Ze = le($e * $e), ot = le(Ze - _1n$3), ct = le(ke * Ze - ge);
      let { isValid: At, value: Tt } = he(ot, ct);
      if (!At)
        throw new Error("Point.fromHex: invalid y coordinate");
      const dt = (Tt & _1n$3) === _1n$3, vt = (Xe & 128) !== 0;
      if (!Se && Tt === _0n$1 && vt)
        throw new Error("Point.fromHex: x=0 and x_0=1");
      return vt !== dt && (Tt = le(-Tt)), Ke.fromAffine({ x: Tt, y: $e });
    }
    static fromPrivateKey(Pe) {
      return je(Pe).point;
    }
    toRawBytes() {
      const { x: Pe, y: Se } = this.toAffine(), ke = numberToBytesLE(Se, ee.BYTES);
      return ke[ke.length - 1] |= Pe & _1n$3 ? 128 : 0, ke;
    }
    toHex() {
      return bytesToHex(this.toRawBytes());
    }
  }
  Ke.BASE = new Ke(X.Gx, X.Gy, _1n$3, le(X.Gx * X.Gy)), Ke.ZERO = new Ke(_0n$1, _1n$3, _1n$3, _0n$1);
  const { BASE: tt, ZERO: rt } = Ke, it = wNAF(Ke, se * 8);
  function _t(Ce) {
    return mod(Ce, te);
  }
  function Dt(Ce) {
    return _t(bytesToNumberLE(Ce));
  }
  function je(Ce) {
    const Pe = se;
    Ce = ensureBytes("private key", Ce, Pe);
    const Se = ensureBytes("hashed private key", ie(Ce), 2 * Pe), ke = me(Se.slice(0, Pe)), ge = Se.slice(Pe, 2 * Pe), Ae = Dt(ke), Ge = tt.multiply(Ae), Xe = Ge.toRawBytes();
    return { head: ke, prefix: ge, scalar: Ae, point: Ge, pointBytes: Xe };
  }
  function ze(Ce) {
    return je(Ce).pointBytes;
  }
  function fe(Ce = new Uint8Array(), ...Pe) {
    const Se = concatBytes(...Pe);
    return Dt(ie(ye(Se, ensureBytes("context", Ce), !!ne)));
  }
  function de(Ce, Pe, Se = {}) {
    Ce = ensureBytes("message", Ce), ne && (Ce = ne(Ce));
    const { prefix: ke, scalar: ge, pointBytes: Ae } = je(Pe), Ge = fe(Se.context, ke, Ce), Xe = tt.multiply(Ge).toRawBytes(), $e = fe(Se.context, Xe, Ae, Ce), Ze = _t(Ge + $e * ge);
    Me(Ze);
    const ot = concatBytes(Xe, numberToBytesLE(Ze, ee.BYTES));
    return ensureBytes("result", ot, se * 2);
  }
  const be = VERIFY_DEFAULT;
  function Te(Ce, Pe, Se, ke = be) {
    const { context: ge, zip215: Ae } = ke, Ge = ee.BYTES;
    Ce = ensureBytes("signature", Ce, 2 * Ge), Pe = ensureBytes("message", Pe), ne && (Pe = ne(Pe));
    const Xe = bytesToNumberLE(Ce.slice(Ge, 2 * Ge));
    let $e, Ze, ot;
    try {
      $e = Ke.fromHex(Se, Ae), Ze = Ke.fromHex(Ce.slice(0, Ge), Ae), ot = tt.multiplyUnsafe(Xe);
    } catch {
      return !1;
    }
    if (!Ae && $e.isSmallOrder())
      return !1;
    const ct = fe(ge, Ze.toRawBytes(), $e.toRawBytes(), Pe);
    return Ze.add($e.multiplyUnsafe(ct)).subtract(ot).clearCofactor().equals(Ke.ZERO);
  }
  return tt._setWindowSize(8), {
    CURVE: X,
    getPublicKey: ze,
    sign: de,
    verify: Te,
    ExtendedPoint: Ke,
    utils: {
      getExtendedPublicKey: je,
      // ed25519 private keys are uniform 32b. No need to check for modulo bias, like in secp256k1.
      randomPrivateKey: () => oe(ee.BYTES),
      /**
       * We're doing scalar multiplication (used in getPublicKey etc) with precomputed BASE_POINT
       * values. This slows down first getPublicKey() by milliseconds (see Speed section),
       * but allows to speed-up subsequent getPublicKey() calls up to 20x.
       * @param windowSize 2, 4, 8, 16
       */
      precompute(Ce = 8, Pe = Ke.BASE) {
        return Pe._setWindowSize(Ce), Pe.multiply(BigInt(3)), Pe;
      }
    }
  };
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const ED25519_P = BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"), ED25519_SQRT_M1 = BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
BigInt(0);
const _1n$2 = BigInt(1), _2n$1 = BigInt(2), _5n = BigInt(5), _10n = BigInt(10), _20n = BigInt(20), _40n = BigInt(40), _80n = BigInt(80);
function ed25519_pow_2_252_3(Y) {
  const X = ED25519_P, ee = Y * Y % X * Y % X, te = pow2(ee, _2n$1, X) * ee % X, ne = pow2(te, _1n$2, X) * Y % X, ie = pow2(ne, _5n, X) * ne % X, oe = pow2(ie, _10n, X) * ie % X, se = pow2(oe, _20n, X) * oe % X, ae = pow2(se, _40n, X) * se % X, ue = pow2(ae, _80n, X) * ae % X, le = pow2(ue, _80n, X) * ae % X, he = pow2(le, _10n, X) * ie % X;
  return { pow_p_5_8: pow2(he, _2n$1, X) * Y % X, b2: ee };
}
function adjustScalarBytes(Y) {
  return Y[0] &= 248, Y[31] &= 127, Y[31] |= 64, Y;
}
function uvRatio(Y, X) {
  const ee = ED25519_P, te = mod(X * X * X, ee), ne = mod(te * te * X, ee), ie = ed25519_pow_2_252_3(Y * ne).pow_p_5_8;
  let oe = mod(Y * te * ie, ee);
  const se = mod(X * oe * oe, ee), ae = oe, ue = mod(oe * ED25519_SQRT_M1, ee), le = se === Y, he = se === mod(-Y, ee), me = se === mod(-Y * ED25519_SQRT_M1, ee);
  return le && (oe = ae), (he || me) && (oe = ue), isNegativeLE(oe, ee) && (oe = mod(-oe, ee)), { isValid: le || he, value: oe };
}
const Fp$1 = Field(ED25519_P, void 0, !0), ed25519Defaults = {
  // Param: a
  a: BigInt(-1),
  // Fp.create(-1) is proper; our way still works and is faster
  // d is equal to -121665/121666 over finite field.
  // Negative number is P - number, and division is invert(number, P)
  d: BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),
  // Finite field p over which we'll do calculations; 2n**255n - 19n
  Fp: Fp$1,
  // Subgroup order: how many points curve has
  // 2n**252n + 27742317777372353535851937790883648493n;
  n: BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),
  // Cofactor
  h: BigInt(8),
  // Base point (x, y) aka generator point
  Gx: BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),
  Gy: BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),
  hash: sha512,
  randomBytes,
  adjustScalarBytes,
  // dom2
  // Ratio of u to v. Allows us to combine inversion and square root. Uses algo from RFC8032 5.1.3.
  // Constant-time, u/v
  uvRatio
}, ed25519 = /* @__PURE__ */ twistedEdwards(ed25519Defaults);
({
  ...ed25519Defaults
});
({
  ...ed25519Defaults
});
const ELL2_C1 = (Fp$1.ORDER + BigInt(3)) / BigInt(8);
Fp$1.pow(_2n$1, ELL2_C1);
Fp$1.sqrt(Fp$1.neg(Fp$1.ONE));
(Fp$1.ORDER - BigInt(5)) / BigInt(8);
BigInt(486662);
FpSqrtEven(Fp$1, Fp$1.neg(BigInt(486664)));
BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235");
BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578");
BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838");
BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952");
BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
var _Buffer = safeBufferExports.Buffer;
function base$1(Y) {
  if (Y.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var X = new Uint8Array(256), ee = 0; ee < X.length; ee++)
    X[ee] = 255;
  for (var te = 0; te < Y.length; te++) {
    var ne = Y.charAt(te), ie = ne.charCodeAt(0);
    if (X[ie] !== 255)
      throw new TypeError(ne + " is ambiguous");
    X[ie] = te;
  }
  var oe = Y.length, se = Y.charAt(0), ae = Math.log(oe) / Math.log(256), ue = Math.log(256) / Math.log(oe);
  function le(ye) {
    if ((Array.isArray(ye) || ye instanceof Uint8Array) && (ye = _Buffer.from(ye)), !_Buffer.isBuffer(ye))
      throw new TypeError("Expected Buffer");
    if (ye.length === 0)
      return "";
    for (var we = 0, Ee = 0, Re = 0, Ue = ye.length; Re !== Ue && ye[Re] === 0; )
      Re++, we++;
    for (var Me = (Ue - Re) * ue + 1 >>> 0, De = new Uint8Array(Me); Re !== Ue; ) {
      for (var Fe = ye[Re], Ke = 0, tt = Me - 1; (Fe !== 0 || Ke < Ee) && tt !== -1; tt--, Ke++)
        Fe += 256 * De[tt] >>> 0, De[tt] = Fe % oe >>> 0, Fe = Fe / oe >>> 0;
      if (Fe !== 0)
        throw new Error("Non-zero carry");
      Ee = Ke, Re++;
    }
    for (var rt = Me - Ee; rt !== Me && De[rt] === 0; )
      rt++;
    for (var it = se.repeat(we); rt < Me; ++rt)
      it += Y.charAt(De[rt]);
    return it;
  }
  function he(ye) {
    if (typeof ye != "string")
      throw new TypeError("Expected String");
    if (ye.length === 0)
      return _Buffer.alloc(0);
    for (var we = 0, Ee = 0, Re = 0; ye[we] === se; )
      Ee++, we++;
    for (var Ue = (ye.length - we) * ae + 1 >>> 0, Me = new Uint8Array(Ue); ye[we]; ) {
      var De = X[ye.charCodeAt(we)];
      if (De === 255)
        return;
      for (var Fe = 0, Ke = Ue - 1; (De !== 0 || Fe < Re) && Ke !== -1; Ke--, Fe++)
        De += oe * Me[Ke] >>> 0, Me[Ke] = De % 256 >>> 0, De = De / 256 >>> 0;
      if (De !== 0)
        throw new Error("Non-zero carry");
      Re = Fe, we++;
    }
    for (var tt = Ue - Re; tt !== Ue && Me[tt] === 0; )
      tt++;
    var rt = _Buffer.allocUnsafe(Ee + (Ue - tt));
    rt.fill(0, 0, Ee);
    for (var it = Ee; tt !== Ue; )
      rt[it++] = Me[tt++];
    return rt;
  }
  function me(ye) {
    var we = he(ye);
    if (we)
      return we;
    throw new Error("Non-base" + oe + " character");
  }
  return {
    encode: le,
    decodeUnsafe: he,
    decode: me
  };
}
var src$1 = base$1, basex$1 = src$1, ALPHABET$1 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz", bs58$2 = basex$1(ALPHABET$1);
const bs58$3 = /* @__PURE__ */ getDefaultExportFromCjs$2(bs58$2), Chi = (Y, X, ee) => Y & X ^ ~Y & ee, Maj = (Y, X, ee) => Y & X ^ Y & ee ^ X & ee, SHA256_K = /* @__PURE__ */ new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), IV = /* @__PURE__ */ new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), SHA256_W = /* @__PURE__ */ new Uint32Array(64);
class SHA256 extends SHA2 {
  constructor() {
    super(64, 32, 8, !1), this.A = IV[0] | 0, this.B = IV[1] | 0, this.C = IV[2] | 0, this.D = IV[3] | 0, this.E = IV[4] | 0, this.F = IV[5] | 0, this.G = IV[6] | 0, this.H = IV[7] | 0;
  }
  get() {
    const { A: X, B: ee, C: te, D: ne, E: ie, F: oe, G: se, H: ae } = this;
    return [X, ee, te, ne, ie, oe, se, ae];
  }
  // prettier-ignore
  set(X, ee, te, ne, ie, oe, se, ae) {
    this.A = X | 0, this.B = ee | 0, this.C = te | 0, this.D = ne | 0, this.E = ie | 0, this.F = oe | 0, this.G = se | 0, this.H = ae | 0;
  }
  process(X, ee) {
    for (let he = 0; he < 16; he++, ee += 4)
      SHA256_W[he] = X.getUint32(ee, !1);
    for (let he = 16; he < 64; he++) {
      const me = SHA256_W[he - 15], ye = SHA256_W[he - 2], we = rotr(me, 7) ^ rotr(me, 18) ^ me >>> 3, Ee = rotr(ye, 17) ^ rotr(ye, 19) ^ ye >>> 10;
      SHA256_W[he] = Ee + SHA256_W[he - 7] + we + SHA256_W[he - 16] | 0;
    }
    let { A: te, B: ne, C: ie, D: oe, E: se, F: ae, G: ue, H: le } = this;
    for (let he = 0; he < 64; he++) {
      const me = rotr(se, 6) ^ rotr(se, 11) ^ rotr(se, 25), ye = le + me + Chi(se, ae, ue) + SHA256_K[he] + SHA256_W[he] | 0, we = (rotr(te, 2) ^ rotr(te, 13) ^ rotr(te, 22)) + Maj(te, ne, ie) | 0;
      le = ue, ue = ae, ae = se, se = oe + ye | 0, oe = ie, ie = ne, ne = te, te = ye + we | 0;
    }
    te = te + this.A | 0, ne = ne + this.B | 0, ie = ie + this.C | 0, oe = oe + this.D | 0, se = se + this.E | 0, ae = ae + this.F | 0, ue = ue + this.G | 0, le = le + this.H | 0, this.set(te, ne, ie, oe, se, ae, ue, le);
  }
  roundClean() {
    SHA256_W.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
}
const sha256 = /* @__PURE__ */ wrapConstructor(() => new SHA256());
var lib = {};
function inRange(Y, X, ee) {
  return X <= Y && Y <= ee;
}
function ToDictionary(Y) {
  if (Y === void 0)
    return {};
  if (Y === Object(Y))
    return Y;
  throw TypeError("Could not convert argument to dictionary");
}
function stringToCodePoints(Y) {
  for (var X = String(Y), ee = X.length, te = 0, ne = []; te < ee; ) {
    var ie = X.charCodeAt(te);
    if (ie < 55296 || ie > 57343)
      ne.push(ie);
    else if (56320 <= ie && ie <= 57343)
      ne.push(65533);
    else if (55296 <= ie && ie <= 56319)
      if (te === ee - 1)
        ne.push(65533);
      else {
        var oe = Y.charCodeAt(te + 1);
        if (56320 <= oe && oe <= 57343) {
          var se = ie & 1023, ae = oe & 1023;
          ne.push(65536 + (se << 10) + ae), te += 1;
        } else
          ne.push(65533);
      }
    te += 1;
  }
  return ne;
}
function codePointsToString(Y) {
  for (var X = "", ee = 0; ee < Y.length; ++ee) {
    var te = Y[ee];
    te <= 65535 ? X += String.fromCharCode(te) : (te -= 65536, X += String.fromCharCode(
      (te >> 10) + 55296,
      (te & 1023) + 56320
    ));
  }
  return X;
}
var end_of_stream = -1;
function Stream(Y) {
  this.tokens = [].slice.call(Y);
}
Stream.prototype = {
  /**
   * @return {boolean} True if end-of-stream has been hit.
   */
  endOfStream: function() {
    return !this.tokens.length;
  },
  /**
   * When a token is read from a stream, the first token in the
   * stream must be returned and subsequently removed, and
   * end-of-stream must be returned otherwise.
   *
   * @return {number} Get the next token from the stream, or
   * end_of_stream.
   */
  read: function() {
    return this.tokens.length ? this.tokens.shift() : end_of_stream;
  },
  /**
   * When one or more tokens are prepended to a stream, those tokens
   * must be inserted, in given order, before the first token in the
   * stream.
   *
   * @param {(number|!Array.<number>)} token The token(s) to prepend to the stream.
   */
  prepend: function(Y) {
    if (Array.isArray(Y))
      for (var X = (
        /**@type {!Array.<number>}*/
        Y
      ); X.length; )
        this.tokens.unshift(X.pop());
    else
      this.tokens.unshift(Y);
  },
  /**
   * When one or more tokens are pushed to a stream, those tokens
   * must be inserted, in given order, after the last token in the
   * stream.
   *
   * @param {(number|!Array.<number>)} token The tokens(s) to prepend to the stream.
   */
  push: function(Y) {
    if (Array.isArray(Y))
      for (var X = (
        /**@type {!Array.<number>}*/
        Y
      ); X.length; )
        this.tokens.push(X.shift());
    else
      this.tokens.push(Y);
  }
};
var finished = -1;
function decoderError(Y, X) {
  if (Y)
    throw TypeError("Decoder error");
  return X || 65533;
}
var DEFAULT_ENCODING = "utf-8";
function TextDecoder$1(Y, X) {
  if (!(this instanceof TextDecoder$1))
    return new TextDecoder$1(Y, X);
  if (Y = Y !== void 0 ? String(Y).toLowerCase() : DEFAULT_ENCODING, Y !== DEFAULT_ENCODING)
    throw new Error("Encoding not supported. Only utf-8 is supported");
  X = ToDictionary(X), this._streaming = !1, this._BOMseen = !1, this._decoder = null, this._fatal = !!X.fatal, this._ignoreBOM = !!X.ignoreBOM, Object.defineProperty(this, "encoding", { value: "utf-8" }), Object.defineProperty(this, "fatal", { value: this._fatal }), Object.defineProperty(this, "ignoreBOM", { value: this._ignoreBOM });
}
TextDecoder$1.prototype = {
  /**
   * @param {ArrayBufferView=} input The buffer of bytes to decode.
   * @param {Object=} options
   * @return {string} The decoded string.
   */
  decode: function Y(X, ee) {
    var te;
    typeof X == "object" && X instanceof ArrayBuffer ? te = new Uint8Array(X) : typeof X == "object" && "buffer" in X && X.buffer instanceof ArrayBuffer ? te = new Uint8Array(
      X.buffer,
      X.byteOffset,
      X.byteLength
    ) : te = new Uint8Array(0), ee = ToDictionary(ee), this._streaming || (this._decoder = new UTF8Decoder({ fatal: this._fatal }), this._BOMseen = !1), this._streaming = !!ee.stream;
    for (var ne = new Stream(te), ie = [], oe; !ne.endOfStream() && (oe = this._decoder.handler(ne, ne.read()), oe !== finished); )
      oe !== null && (Array.isArray(oe) ? ie.push.apply(
        ie,
        /**@type {!Array.<number>}*/
        oe
      ) : ie.push(oe));
    if (!this._streaming) {
      do {
        if (oe = this._decoder.handler(ne, ne.read()), oe === finished)
          break;
        oe !== null && (Array.isArray(oe) ? ie.push.apply(
          ie,
          /**@type {!Array.<number>}*/
          oe
        ) : ie.push(oe));
      } while (!ne.endOfStream());
      this._decoder = null;
    }
    return ie.length && ["utf-8"].indexOf(this.encoding) !== -1 && !this._ignoreBOM && !this._BOMseen && (ie[0] === 65279 ? (this._BOMseen = !0, ie.shift()) : this._BOMseen = !0), codePointsToString(ie);
  }
};
function TextEncoder$1(Y, X) {
  if (!(this instanceof TextEncoder$1))
    return new TextEncoder$1(Y, X);
  if (Y = Y !== void 0 ? String(Y).toLowerCase() : DEFAULT_ENCODING, Y !== DEFAULT_ENCODING)
    throw new Error("Encoding not supported. Only utf-8 is supported");
  X = ToDictionary(X), this._streaming = !1, this._encoder = null, this._options = { fatal: !!X.fatal }, Object.defineProperty(this, "encoding", { value: "utf-8" });
}
TextEncoder$1.prototype = {
  /**
   * @param {string=} opt_string The string to encode.
   * @param {Object=} options
   * @return {Uint8Array} Encoded bytes, as a Uint8Array.
   */
  encode: function Y(X, ee) {
    X = X ? String(X) : "", ee = ToDictionary(ee), this._streaming || (this._encoder = new UTF8Encoder(this._options)), this._streaming = !!ee.stream;
    for (var te = [], ne = new Stream(stringToCodePoints(X)), ie; !ne.endOfStream() && (ie = this._encoder.handler(ne, ne.read()), ie !== finished); )
      Array.isArray(ie) ? te.push.apply(
        te,
        /**@type {!Array.<number>}*/
        ie
      ) : te.push(ie);
    if (!this._streaming) {
      for (; ie = this._encoder.handler(ne, ne.read()), ie !== finished; )
        Array.isArray(ie) ? te.push.apply(
          te,
          /**@type {!Array.<number>}*/
          ie
        ) : te.push(ie);
      this._encoder = null;
    }
    return new Uint8Array(te);
  }
};
function UTF8Decoder(Y) {
  var X = Y.fatal, ee = 0, te = 0, ne = 0, ie = 128, oe = 191;
  this.handler = function(se, ae) {
    if (ae === end_of_stream && ne !== 0)
      return ne = 0, decoderError(X);
    if (ae === end_of_stream)
      return finished;
    if (ne === 0) {
      if (inRange(ae, 0, 127))
        return ae;
      if (inRange(ae, 194, 223))
        ne = 1, ee = ae - 192;
      else if (inRange(ae, 224, 239))
        ae === 224 && (ie = 160), ae === 237 && (oe = 159), ne = 2, ee = ae - 224;
      else if (inRange(ae, 240, 244))
        ae === 240 && (ie = 144), ae === 244 && (oe = 143), ne = 3, ee = ae - 240;
      else
        return decoderError(X);
      return ee = ee << 6 * ne, null;
    }
    if (!inRange(ae, ie, oe))
      return ee = ne = te = 0, ie = 128, oe = 191, se.prepend(ae), decoderError(X);
    if (ie = 128, oe = 191, te += 1, ee += ae - 128 << 6 * (ne - te), te !== ne)
      return null;
    var ue = ee;
    return ee = ne = te = 0, ue;
  };
}
function UTF8Encoder(Y) {
  Y.fatal, this.handler = function(X, ee) {
    if (ee === end_of_stream)
      return finished;
    if (inRange(ee, 0, 127))
      return ee;
    var te, ne;
    inRange(ee, 128, 2047) ? (te = 1, ne = 192) : inRange(ee, 2048, 65535) ? (te = 2, ne = 224) : inRange(ee, 65536, 1114111) && (te = 3, ne = 240);
    for (var ie = [(ee >> 6 * te) + ne]; te > 0; ) {
      var oe = ee >> 6 * (te - 1);
      ie.push(128 | oe & 63), te -= 1;
    }
    return ie;
  };
}
const encoding$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  TextDecoder: TextDecoder$1,
  TextEncoder: TextEncoder$1
}, Symbol.toStringTag, { value: "Module" })), require$$2 = /* @__PURE__ */ getAugmentedNamespace(encoding$1);
var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(Y, X, ee, te) {
  te === void 0 && (te = ee), Object.defineProperty(Y, te, { enumerable: !0, get: function() {
    return X[ee];
  } });
} : function(Y, X, ee, te) {
  te === void 0 && (te = ee), Y[te] = X[ee];
}), __setModuleDefault = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(Y, X) {
  Object.defineProperty(Y, "default", { enumerable: !0, value: X });
} : function(Y, X) {
  Y.default = X;
}), __decorate = commonjsGlobal && commonjsGlobal.__decorate || function(Y, X, ee, te) {
  var ne = arguments.length, ie = ne < 3 ? X : te === null ? te = Object.getOwnPropertyDescriptor(X, ee) : te, oe;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    ie = Reflect.decorate(Y, X, ee, te);
  else
    for (var se = Y.length - 1; se >= 0; se--)
      (oe = Y[se]) && (ie = (ne < 3 ? oe(ie) : ne > 3 ? oe(X, ee, ie) : oe(X, ee)) || ie);
  return ne > 3 && ie && Object.defineProperty(X, ee, ie), ie;
}, __importStar = commonjsGlobal && commonjsGlobal.__importStar || function(Y) {
  if (Y && Y.__esModule)
    return Y;
  var X = {};
  if (Y != null)
    for (var ee in Y)
      ee !== "default" && Object.hasOwnProperty.call(Y, ee) && __createBinding(X, Y, ee);
  return __setModuleDefault(X, Y), X;
}, __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(Y) {
  return Y && Y.__esModule ? Y : { default: Y };
};
Object.defineProperty(lib, "__esModule", { value: !0 });
var deserializeUnchecked_1 = lib.deserializeUnchecked = deserialize_1 = lib.deserialize = serialize_1 = lib.serialize = lib.BinaryReader = lib.BinaryWriter = lib.BorshError = lib.baseDecode = lib.baseEncode = void 0;
const bn_js_1 = __importDefault(bnExports), bs58_1 = __importDefault(bs58$2), encoding = __importStar(require$$2), ResolvedTextDecoder = typeof TextDecoder != "function" ? encoding.TextDecoder : TextDecoder, textDecoder = new ResolvedTextDecoder("utf-8", { fatal: !0 });
function baseEncode(Y) {
  return typeof Y == "string" && (Y = Buffer$e.from(Y, "utf8")), bs58_1.default.encode(Buffer$e.from(Y));
}
lib.baseEncode = baseEncode;
function baseDecode(Y) {
  return Buffer$e.from(bs58_1.default.decode(Y));
}
lib.baseDecode = baseDecode;
const INITIAL_LENGTH = 1024;
class BorshError extends Error {
  constructor(X) {
    super(X), this.fieldPath = [], this.originalMessage = X;
  }
  addToFieldPath(X) {
    this.fieldPath.splice(0, 0, X), this.message = this.originalMessage + ": " + this.fieldPath.join(".");
  }
}
lib.BorshError = BorshError;
class BinaryWriter {
  constructor() {
    this.buf = Buffer$e.alloc(INITIAL_LENGTH), this.length = 0;
  }
  maybeResize() {
    this.buf.length < 16 + this.length && (this.buf = Buffer$e.concat([this.buf, Buffer$e.alloc(INITIAL_LENGTH)]));
  }
  writeU8(X) {
    this.maybeResize(), this.buf.writeUInt8(X, this.length), this.length += 1;
  }
  writeU16(X) {
    this.maybeResize(), this.buf.writeUInt16LE(X, this.length), this.length += 2;
  }
  writeU32(X) {
    this.maybeResize(), this.buf.writeUInt32LE(X, this.length), this.length += 4;
  }
  writeU64(X) {
    this.maybeResize(), this.writeBuffer(Buffer$e.from(new bn_js_1.default(X).toArray("le", 8)));
  }
  writeU128(X) {
    this.maybeResize(), this.writeBuffer(Buffer$e.from(new bn_js_1.default(X).toArray("le", 16)));
  }
  writeU256(X) {
    this.maybeResize(), this.writeBuffer(Buffer$e.from(new bn_js_1.default(X).toArray("le", 32)));
  }
  writeU512(X) {
    this.maybeResize(), this.writeBuffer(Buffer$e.from(new bn_js_1.default(X).toArray("le", 64)));
  }
  writeBuffer(X) {
    this.buf = Buffer$e.concat([
      Buffer$e.from(this.buf.subarray(0, this.length)),
      X,
      Buffer$e.alloc(INITIAL_LENGTH)
    ]), this.length += X.length;
  }
  writeString(X) {
    this.maybeResize();
    const ee = Buffer$e.from(X, "utf8");
    this.writeU32(ee.length), this.writeBuffer(ee);
  }
  writeFixedArray(X) {
    this.writeBuffer(Buffer$e.from(X));
  }
  writeArray(X, ee) {
    this.maybeResize(), this.writeU32(X.length);
    for (const te of X)
      this.maybeResize(), ee(te);
  }
  toArray() {
    return this.buf.subarray(0, this.length);
  }
}
lib.BinaryWriter = BinaryWriter;
function handlingRangeError(Y, X, ee) {
  const te = ee.value;
  ee.value = function(...ne) {
    try {
      return te.apply(this, ne);
    } catch (ie) {
      if (ie instanceof RangeError) {
        const oe = ie.code;
        if (["ERR_BUFFER_OUT_OF_BOUNDS", "ERR_OUT_OF_RANGE"].indexOf(oe) >= 0)
          throw new BorshError("Reached the end of buffer when deserializing");
      }
      throw ie;
    }
  };
}
class BinaryReader {
  constructor(X) {
    this.buf = X, this.offset = 0;
  }
  readU8() {
    const X = this.buf.readUInt8(this.offset);
    return this.offset += 1, X;
  }
  readU16() {
    const X = this.buf.readUInt16LE(this.offset);
    return this.offset += 2, X;
  }
  readU32() {
    const X = this.buf.readUInt32LE(this.offset);
    return this.offset += 4, X;
  }
  readU64() {
    const X = this.readBuffer(8);
    return new bn_js_1.default(X, "le");
  }
  readU128() {
    const X = this.readBuffer(16);
    return new bn_js_1.default(X, "le");
  }
  readU256() {
    const X = this.readBuffer(32);
    return new bn_js_1.default(X, "le");
  }
  readU512() {
    const X = this.readBuffer(64);
    return new bn_js_1.default(X, "le");
  }
  readBuffer(X) {
    if (this.offset + X > this.buf.length)
      throw new BorshError(`Expected buffer length ${X} isn't within bounds`);
    const ee = this.buf.slice(this.offset, this.offset + X);
    return this.offset += X, ee;
  }
  readString() {
    const X = this.readU32(), ee = this.readBuffer(X);
    try {
      return textDecoder.decode(ee);
    } catch (te) {
      throw new BorshError(`Error decoding UTF-8 string: ${te}`);
    }
  }
  readFixedArray(X) {
    return new Uint8Array(this.readBuffer(X));
  }
  readArray(X) {
    const ee = this.readU32(), te = Array();
    for (let ne = 0; ne < ee; ++ne)
      te.push(X());
    return te;
  }
}
__decorate([
  handlingRangeError
], BinaryReader.prototype, "readU8", null);
__decorate([
  handlingRangeError
], BinaryReader.prototype, "readU16", null);
__decorate([
  handlingRangeError
], BinaryReader.prototype, "readU32", null);
__decorate([
  handlingRangeError
], BinaryReader.prototype, "readU64", null);
__decorate([
  handlingRangeError
], BinaryReader.prototype, "readU128", null);
__decorate([
  handlingRangeError
], BinaryReader.prototype, "readU256", null);
__decorate([
  handlingRangeError
], BinaryReader.prototype, "readU512", null);
__decorate([
  handlingRangeError
], BinaryReader.prototype, "readString", null);
__decorate([
  handlingRangeError
], BinaryReader.prototype, "readFixedArray", null);
__decorate([
  handlingRangeError
], BinaryReader.prototype, "readArray", null);
lib.BinaryReader = BinaryReader;
function capitalizeFirstLetter(Y) {
  return Y.charAt(0).toUpperCase() + Y.slice(1);
}
function serializeField(Y, X, ee, te, ne) {
  try {
    if (typeof te == "string")
      ne[`write${capitalizeFirstLetter(te)}`](ee);
    else if (te instanceof Array)
      if (typeof te[0] == "number") {
        if (ee.length !== te[0])
          throw new BorshError(`Expecting byte array of length ${te[0]}, but got ${ee.length} bytes`);
        ne.writeFixedArray(ee);
      } else if (te.length === 2 && typeof te[1] == "number") {
        if (ee.length !== te[1])
          throw new BorshError(`Expecting byte array of length ${te[1]}, but got ${ee.length} bytes`);
        for (let ie = 0; ie < te[1]; ie++)
          serializeField(Y, null, ee[ie], te[0], ne);
      } else
        ne.writeArray(ee, (ie) => {
          serializeField(Y, X, ie, te[0], ne);
        });
    else if (te.kind !== void 0)
      switch (te.kind) {
        case "option": {
          ee == null ? ne.writeU8(0) : (ne.writeU8(1), serializeField(Y, X, ee, te.type, ne));
          break;
        }
        case "map": {
          ne.writeU32(ee.size), ee.forEach((ie, oe) => {
            serializeField(Y, X, oe, te.key, ne), serializeField(Y, X, ie, te.value, ne);
          });
          break;
        }
        default:
          throw new BorshError(`FieldType ${te} unrecognized`);
      }
    else
      serializeStruct(Y, ee, ne);
  } catch (ie) {
    throw ie instanceof BorshError && ie.addToFieldPath(X), ie;
  }
}
function serializeStruct(Y, X, ee) {
  if (typeof X.borshSerialize == "function") {
    X.borshSerialize(ee);
    return;
  }
  const te = Y.get(X.constructor);
  if (!te)
    throw new BorshError(`Class ${X.constructor.name} is missing in schema`);
  if (te.kind === "struct")
    te.fields.map(([ne, ie]) => {
      serializeField(Y, ne, X[ne], ie, ee);
    });
  else if (te.kind === "enum") {
    const ne = X[te.field];
    for (let ie = 0; ie < te.values.length; ++ie) {
      const [oe, se] = te.values[ie];
      if (oe === ne) {
        ee.writeU8(ie), serializeField(Y, oe, X[oe], se, ee);
        break;
      }
    }
  } else
    throw new BorshError(`Unexpected schema kind: ${te.kind} for ${X.constructor.name}`);
}
function serialize(Y, X, ee = BinaryWriter) {
  const te = new ee();
  return serializeStruct(Y, X, te), te.toArray();
}
var serialize_1 = lib.serialize = serialize;
function deserializeField(Y, X, ee, te) {
  try {
    if (typeof ee == "string")
      return te[`read${capitalizeFirstLetter(ee)}`]();
    if (ee instanceof Array) {
      if (typeof ee[0] == "number")
        return te.readFixedArray(ee[0]);
      if (typeof ee[1] == "number") {
        const ne = [];
        for (let ie = 0; ie < ee[1]; ie++)
          ne.push(deserializeField(Y, null, ee[0], te));
        return ne;
      } else
        return te.readArray(() => deserializeField(Y, X, ee[0], te));
    }
    if (ee.kind === "option")
      return te.readU8() ? deserializeField(Y, X, ee.type, te) : void 0;
    if (ee.kind === "map") {
      let ne = /* @__PURE__ */ new Map();
      const ie = te.readU32();
      for (let oe = 0; oe < ie; oe++) {
        const se = deserializeField(Y, X, ee.key, te), ae = deserializeField(Y, X, ee.value, te);
        ne.set(se, ae);
      }
      return ne;
    }
    return deserializeStruct(Y, ee, te);
  } catch (ne) {
    throw ne instanceof BorshError && ne.addToFieldPath(X), ne;
  }
}
function deserializeStruct(Y, X, ee) {
  if (typeof X.borshDeserialize == "function")
    return X.borshDeserialize(ee);
  const te = Y.get(X);
  if (!te)
    throw new BorshError(`Class ${X.name} is missing in schema`);
  if (te.kind === "struct") {
    const ne = {};
    for (const [ie, oe] of Y.get(X).fields)
      ne[ie] = deserializeField(Y, ie, oe, ee);
    return new X(ne);
  }
  if (te.kind === "enum") {
    const ne = ee.readU8();
    if (ne >= te.values.length)
      throw new BorshError(`Enum index: ${ne} is out of range`);
    const [ie, oe] = te.values[ne], se = deserializeField(Y, ie, oe, ee);
    return new X({ [ie]: se });
  }
  throw new BorshError(`Unexpected schema kind: ${te.kind} for ${X.constructor.name}`);
}
function deserialize(Y, X, ee, te = BinaryReader) {
  const ne = new te(ee), ie = deserializeStruct(Y, X, ne);
  if (ne.offset < ee.length)
    throw new BorshError(`Unexpected ${ee.length - ne.offset} bytes after deserialized data`);
  return ie;
}
var deserialize_1 = lib.deserialize = deserialize;
function deserializeUnchecked(Y, X, ee, te = BinaryReader) {
  const ne = new te(ee);
  return deserializeStruct(Y, X, ne);
}
deserializeUnchecked_1 = lib.deserializeUnchecked = deserializeUnchecked;
var Layout$2 = {};
Object.defineProperty(Layout$2, "__esModule", { value: !0 });
Layout$2.s16 = Layout$2.s8 = Layout$2.nu64be = Layout$2.u48be = Layout$2.u40be = Layout$2.u32be = Layout$2.u24be = Layout$2.u16be = nu64$1 = Layout$2.nu64 = Layout$2.u48 = Layout$2.u40 = u32 = Layout$2.u32 = Layout$2.u24 = u16 = Layout$2.u16 = u8 = Layout$2.u8 = offset = Layout$2.offset = Layout$2.greedy = Layout$2.Constant = Layout$2.UTF8 = Layout$2.CString = Layout$2.Blob = Layout$2.Boolean = Layout$2.BitField = Layout$2.BitStructure = Layout$2.VariantLayout = Layout$2.Union = Layout$2.UnionLayoutDiscriminator = Layout$2.UnionDiscriminator = Layout$2.Structure = Layout$2.Sequence = Layout$2.DoubleBE = Layout$2.Double = Layout$2.FloatBE = Layout$2.Float = Layout$2.NearInt64BE = Layout$2.NearInt64 = Layout$2.NearUInt64BE = Layout$2.NearUInt64 = Layout$2.IntBE = Layout$2.Int = Layout$2.UIntBE = Layout$2.UInt = Layout$2.OffsetLayout = Layout$2.GreedyCount = Layout$2.ExternalLayout = Layout$2.bindConstructorLayout = Layout$2.nameWithProperty = Layout$2.Layout = Layout$2.uint8ArrayToBuffer = Layout$2.checkUint8Array = void 0;
Layout$2.constant = Layout$2.utf8 = Layout$2.cstr = blob$1 = Layout$2.blob = Layout$2.unionLayoutDiscriminator = Layout$2.union = seq = Layout$2.seq = Layout$2.bits = struct$1 = Layout$2.struct = Layout$2.f64be = Layout$2.f64 = Layout$2.f32be = Layout$2.f32 = Layout$2.ns64be = Layout$2.s48be = Layout$2.s40be = Layout$2.s32be = Layout$2.s24be = Layout$2.s16be = ns64 = Layout$2.ns64 = Layout$2.s48 = Layout$2.s40 = Layout$2.s32 = Layout$2.s24 = void 0;
const buffer_1 = require$$0$3;
function checkUint8Array(Y) {
  if (!(Y instanceof Uint8Array))
    throw new TypeError("b must be a Uint8Array");
}
Layout$2.checkUint8Array = checkUint8Array;
function uint8ArrayToBuffer(Y) {
  return checkUint8Array(Y), buffer_1.Buffer.from(Y.buffer, Y.byteOffset, Y.length);
}
Layout$2.uint8ArrayToBuffer = uint8ArrayToBuffer;
let Layout$1 = class {
  constructor(Y, X) {
    if (!Number.isInteger(Y))
      throw new TypeError("span must be an integer");
    this.span = Y, this.property = X;
  }
  /** Function to create an Object into which decoded properties will
   * be written.
   *
   * Used only for layouts that {@link Layout#decode|decode} to Object
   * instances, which means:
   * * {@link Structure}
   * * {@link Union}
   * * {@link VariantLayout}
   * * {@link BitStructure}
   *
   * If left undefined the JavaScript representation of these layouts
   * will be Object instances.
   *
   * See {@link bindConstructorLayout}.
   */
  makeDestinationObject() {
    return {};
  }
  /**
   * Calculate the span of a specific instance of a layout.
   *
   * @param {Uint8Array} b - the buffer that contains an encoded instance.
   *
   * @param {Number} [offset] - the offset at which the encoded instance
   * starts.  If absent a zero offset is inferred.
   *
   * @return {Number} - the number of bytes covered by the layout
   * instance.  If this method is not overridden in a subclass the
   * definition-time constant {@link Layout#span|span} will be
   * returned.
   *
   * @throws {RangeError} - if the length of the value cannot be
   * determined.
   */
  getSpan(Y, X) {
    if (0 > this.span)
      throw new RangeError("indeterminate span");
    return this.span;
  }
  /**
   * Replicate the layout using a new property.
   *
   * This function must be used to get a structurally-equivalent layout
   * with a different name since all {@link Layout} instances are
   * immutable.
   *
   * **NOTE** This is a shallow copy.  All fields except {@link
   * Layout#property|property} are strictly equal to the origin layout.
   *
   * @param {String} property - the value for {@link
   * Layout#property|property} in the replica.
   *
   * @returns {Layout} - the copy with {@link Layout#property|property}
   * set to `property`.
   */
  replicate(Y) {
    const X = Object.create(this.constructor.prototype);
    return Object.assign(X, this), X.property = Y, X;
  }
  /**
   * Create an object from layout properties and an array of values.
   *
   * **NOTE** This function returns `undefined` if invoked on a layout
   * that does not return its value as an Object.  Objects are
   * returned for things that are a {@link Structure}, which includes
   * {@link VariantLayout|variant layouts} if they are structures, and
   * excludes {@link Union}s.  If you want this feature for a union
   * you must use {@link Union.getVariant|getVariant} to select the
   * desired layout.
   *
   * @param {Array} values - an array of values that correspond to the
   * default order for properties.  As with {@link Layout#decode|decode}
   * layout elements that have no property name are skipped when
   * iterating over the array values.  Only the top-level properties are
   * assigned; arguments are not assigned to properties of contained
   * layouts.  Any unused values are ignored.
   *
   * @return {(Object|undefined)}
   */
  fromArray(Y) {
  }
};
Layout$2.Layout = Layout$1;
function nameWithProperty$1(Y, X) {
  return X.property ? Y + "[" + X.property + "]" : Y;
}
Layout$2.nameWithProperty = nameWithProperty$1;
function bindConstructorLayout(Y, X) {
  if (typeof Y != "function")
    throw new TypeError("Class must be constructor");
  if (Object.prototype.hasOwnProperty.call(Y, "layout_"))
    throw new Error("Class is already bound to a layout");
  if (!(X && X instanceof Layout$1))
    throw new TypeError("layout must be a Layout");
  if (Object.prototype.hasOwnProperty.call(X, "boundConstructor_"))
    throw new Error("layout is already bound to a constructor");
  Y.layout_ = X, X.boundConstructor_ = Y, X.makeDestinationObject = () => new Y(), Object.defineProperty(Y.prototype, "encode", {
    value(ee, te) {
      return X.encode(this, ee, te);
    },
    writable: !0
  }), Object.defineProperty(Y, "decode", {
    value(ee, te) {
      return X.decode(ee, te);
    },
    writable: !0
  });
}
Layout$2.bindConstructorLayout = bindConstructorLayout;
let ExternalLayout$1 = class extends Layout$1 {
  /**
   * Return `true` iff the external layout decodes to an unsigned
   * integer layout.
   *
   * In that case it can be used as the source of {@link
   * Sequence#count|Sequence counts}, {@link Blob#length|Blob lengths},
   * or as {@link UnionLayoutDiscriminator#layout|external union
   * discriminators}.
   *
   * @abstract
   */
  isCount() {
    throw new Error("ExternalLayout is abstract");
  }
};
Layout$2.ExternalLayout = ExternalLayout$1;
class GreedyCount extends ExternalLayout$1 {
  constructor(X = 1, ee) {
    if (!Number.isInteger(X) || 0 >= X)
      throw new TypeError("elementSpan must be a (positive) integer");
    super(-1, ee), this.elementSpan = X;
  }
  /** @override */
  isCount() {
    return !0;
  }
  /** @override */
  decode(X, ee = 0) {
    checkUint8Array(X);
    const te = X.length - ee;
    return Math.floor(te / this.elementSpan);
  }
  /** @override */
  encode(X, ee, te) {
    return 0;
  }
}
Layout$2.GreedyCount = GreedyCount;
class OffsetLayout extends ExternalLayout$1 {
  constructor(X, ee = 0, te) {
    if (!(X instanceof Layout$1))
      throw new TypeError("layout must be a Layout");
    if (!Number.isInteger(ee))
      throw new TypeError("offset must be integer or undefined");
    super(X.span, te || X.property), this.layout = X, this.offset = ee;
  }
  /** @override */
  isCount() {
    return this.layout instanceof UInt || this.layout instanceof UIntBE;
  }
  /** @override */
  decode(X, ee = 0) {
    return this.layout.decode(X, ee + this.offset);
  }
  /** @override */
  encode(X, ee, te = 0) {
    return this.layout.encode(X, ee, te + this.offset);
  }
}
Layout$2.OffsetLayout = OffsetLayout;
class UInt extends Layout$1 {
  constructor(X, ee) {
    if (super(X, ee), 6 < this.span)
      throw new RangeError("span must not exceed 6 bytes");
  }
  /** @override */
  decode(X, ee = 0) {
    return uint8ArrayToBuffer(X).readUIntLE(ee, this.span);
  }
  /** @override */
  encode(X, ee, te = 0) {
    return uint8ArrayToBuffer(ee).writeUIntLE(X, te, this.span), this.span;
  }
}
Layout$2.UInt = UInt;
class UIntBE extends Layout$1 {
  constructor(X, ee) {
    if (super(X, ee), 6 < this.span)
      throw new RangeError("span must not exceed 6 bytes");
  }
  /** @override */
  decode(X, ee = 0) {
    return uint8ArrayToBuffer(X).readUIntBE(ee, this.span);
  }
  /** @override */
  encode(X, ee, te = 0) {
    return uint8ArrayToBuffer(ee).writeUIntBE(X, te, this.span), this.span;
  }
}
Layout$2.UIntBE = UIntBE;
class Int extends Layout$1 {
  constructor(X, ee) {
    if (super(X, ee), 6 < this.span)
      throw new RangeError("span must not exceed 6 bytes");
  }
  /** @override */
  decode(X, ee = 0) {
    return uint8ArrayToBuffer(X).readIntLE(ee, this.span);
  }
  /** @override */
  encode(X, ee, te = 0) {
    return uint8ArrayToBuffer(ee).writeIntLE(X, te, this.span), this.span;
  }
}
Layout$2.Int = Int;
class IntBE extends Layout$1 {
  constructor(X, ee) {
    if (super(X, ee), 6 < this.span)
      throw new RangeError("span must not exceed 6 bytes");
  }
  /** @override */
  decode(X, ee = 0) {
    return uint8ArrayToBuffer(X).readIntBE(ee, this.span);
  }
  /** @override */
  encode(X, ee, te = 0) {
    return uint8ArrayToBuffer(ee).writeIntBE(X, te, this.span), this.span;
  }
}
Layout$2.IntBE = IntBE;
const V2E32$1 = Math.pow(2, 32);
function divmodInt64$1(Y) {
  const X = Math.floor(Y / V2E32$1), ee = Y - X * V2E32$1;
  return { hi32: X, lo32: ee };
}
function roundedInt64$1(Y, X) {
  return Y * V2E32$1 + X;
}
let NearUInt64$1 = class extends Layout$1 {
  constructor(Y) {
    super(8, Y);
  }
  /** @override */
  decode(Y, X = 0) {
    const ee = uint8ArrayToBuffer(Y), te = ee.readUInt32LE(X), ne = ee.readUInt32LE(X + 4);
    return roundedInt64$1(ne, te);
  }
  /** @override */
  encode(Y, X, ee = 0) {
    const te = divmodInt64$1(Y), ne = uint8ArrayToBuffer(X);
    return ne.writeUInt32LE(te.lo32, ee), ne.writeUInt32LE(te.hi32, ee + 4), 8;
  }
};
Layout$2.NearUInt64 = NearUInt64$1;
class NearUInt64BE extends Layout$1 {
  constructor(X) {
    super(8, X);
  }
  /** @override */
  decode(X, ee = 0) {
    const te = uint8ArrayToBuffer(X), ne = te.readUInt32BE(ee), ie = te.readUInt32BE(ee + 4);
    return roundedInt64$1(ne, ie);
  }
  /** @override */
  encode(X, ee, te = 0) {
    const ne = divmodInt64$1(X), ie = uint8ArrayToBuffer(ee);
    return ie.writeUInt32BE(ne.hi32, te), ie.writeUInt32BE(ne.lo32, te + 4), 8;
  }
}
Layout$2.NearUInt64BE = NearUInt64BE;
class NearInt64 extends Layout$1 {
  constructor(X) {
    super(8, X);
  }
  /** @override */
  decode(X, ee = 0) {
    const te = uint8ArrayToBuffer(X), ne = te.readUInt32LE(ee), ie = te.readInt32LE(ee + 4);
    return roundedInt64$1(ie, ne);
  }
  /** @override */
  encode(X, ee, te = 0) {
    const ne = divmodInt64$1(X), ie = uint8ArrayToBuffer(ee);
    return ie.writeUInt32LE(ne.lo32, te), ie.writeInt32LE(ne.hi32, te + 4), 8;
  }
}
Layout$2.NearInt64 = NearInt64;
class NearInt64BE extends Layout$1 {
  constructor(X) {
    super(8, X);
  }
  /** @override */
  decode(X, ee = 0) {
    const te = uint8ArrayToBuffer(X), ne = te.readInt32BE(ee), ie = te.readUInt32BE(ee + 4);
    return roundedInt64$1(ne, ie);
  }
  /** @override */
  encode(X, ee, te = 0) {
    const ne = divmodInt64$1(X), ie = uint8ArrayToBuffer(ee);
    return ie.writeInt32BE(ne.hi32, te), ie.writeUInt32BE(ne.lo32, te + 4), 8;
  }
}
Layout$2.NearInt64BE = NearInt64BE;
class Float extends Layout$1 {
  constructor(X) {
    super(4, X);
  }
  /** @override */
  decode(X, ee = 0) {
    return uint8ArrayToBuffer(X).readFloatLE(ee);
  }
  /** @override */
  encode(X, ee, te = 0) {
    return uint8ArrayToBuffer(ee).writeFloatLE(X, te), 4;
  }
}
Layout$2.Float = Float;
class FloatBE extends Layout$1 {
  constructor(X) {
    super(4, X);
  }
  /** @override */
  decode(X, ee = 0) {
    return uint8ArrayToBuffer(X).readFloatBE(ee);
  }
  /** @override */
  encode(X, ee, te = 0) {
    return uint8ArrayToBuffer(ee).writeFloatBE(X, te), 4;
  }
}
Layout$2.FloatBE = FloatBE;
class Double extends Layout$1 {
  constructor(X) {
    super(8, X);
  }
  /** @override */
  decode(X, ee = 0) {
    return uint8ArrayToBuffer(X).readDoubleLE(ee);
  }
  /** @override */
  encode(X, ee, te = 0) {
    return uint8ArrayToBuffer(ee).writeDoubleLE(X, te), 8;
  }
}
Layout$2.Double = Double;
class DoubleBE extends Layout$1 {
  constructor(X) {
    super(8, X);
  }
  /** @override */
  decode(X, ee = 0) {
    return uint8ArrayToBuffer(X).readDoubleBE(ee);
  }
  /** @override */
  encode(X, ee, te = 0) {
    return uint8ArrayToBuffer(ee).writeDoubleBE(X, te), 8;
  }
}
Layout$2.DoubleBE = DoubleBE;
class Sequence extends Layout$1 {
  constructor(X, ee, te) {
    if (!(X instanceof Layout$1))
      throw new TypeError("elementLayout must be a Layout");
    if (!(ee instanceof ExternalLayout$1 && ee.isCount() || Number.isInteger(ee) && 0 <= ee))
      throw new TypeError("count must be non-negative integer or an unsigned integer ExternalLayout");
    let ne = -1;
    !(ee instanceof ExternalLayout$1) && 0 < X.span && (ne = ee * X.span), super(ne, te), this.elementLayout = X, this.count = ee;
  }
  /** @override */
  getSpan(X, ee = 0) {
    if (0 <= this.span)
      return this.span;
    let te = 0, ne = this.count;
    if (ne instanceof ExternalLayout$1 && (ne = ne.decode(X, ee)), 0 < this.elementLayout.span)
      te = ne * this.elementLayout.span;
    else {
      let ie = 0;
      for (; ie < ne; )
        te += this.elementLayout.getSpan(X, ee + te), ++ie;
    }
    return te;
  }
  /** @override */
  decode(X, ee = 0) {
    const te = [];
    let ne = 0, ie = this.count;
    for (ie instanceof ExternalLayout$1 && (ie = ie.decode(X, ee)); ne < ie; )
      te.push(this.elementLayout.decode(X, ee)), ee += this.elementLayout.getSpan(X, ee), ne += 1;
    return te;
  }
  /** Implement {@link Layout#encode|encode} for {@link Sequence}.
   *
   * **NOTE** If `src` is shorter than {@link Sequence#count|count} then
   * the unused space in the buffer is left unchanged.  If `src` is
   * longer than {@link Sequence#count|count} the unneeded elements are
   * ignored.
   *
   * **NOTE** If {@link Layout#count|count} is an instance of {@link
   * ExternalLayout} then the length of `src` will be encoded as the
   * count after `src` is encoded. */
  encode(X, ee, te = 0) {
    const ne = this.elementLayout, ie = X.reduce((oe, se) => oe + ne.encode(se, ee, te + oe), 0);
    return this.count instanceof ExternalLayout$1 && this.count.encode(X.length, ee, te), ie;
  }
}
Layout$2.Sequence = Sequence;
let Structure$1 = class extends Layout$1 {
  constructor(Y, X, ee) {
    if (!(Array.isArray(Y) && Y.reduce((ne, ie) => ne && ie instanceof Layout$1, !0)))
      throw new TypeError("fields must be array of Layout instances");
    typeof X == "boolean" && ee === void 0 && (ee = X, X = void 0);
    for (const ne of Y)
      if (0 > ne.span && ne.property === void 0)
        throw new Error("fields cannot contain unnamed variable-length layout");
    let te = -1;
    try {
      te = Y.reduce((ne, ie) => ne + ie.getSpan(), 0);
    } catch {
    }
    super(te, X), this.fields = Y, this.decodePrefixes = !!ee;
  }
  /** @override */
  getSpan(Y, X = 0) {
    if (0 <= this.span)
      return this.span;
    let ee = 0;
    try {
      ee = this.fields.reduce((te, ne) => {
        const ie = ne.getSpan(Y, X);
        return X += ie, te + ie;
      }, 0);
    } catch {
      throw new RangeError("indeterminate span");
    }
    return ee;
  }
  /** @override */
  decode(Y, X = 0) {
    checkUint8Array(Y);
    const ee = this.makeDestinationObject();
    for (const te of this.fields)
      if (te.property !== void 0 && (ee[te.property] = te.decode(Y, X)), X += te.getSpan(Y, X), this.decodePrefixes && Y.length === X)
        break;
    return ee;
  }
  /** Implement {@link Layout#encode|encode} for {@link Structure}.
   *
   * If `src` is missing a property for a member with a defined {@link
   * Layout#property|property} the corresponding region of the buffer is
   * left unmodified. */
  encode(Y, X, ee = 0) {
    const te = ee;
    let ne = 0, ie = 0;
    for (const oe of this.fields) {
      let se = oe.span;
      if (ie = 0 < se ? se : 0, oe.property !== void 0) {
        const ae = Y[oe.property];
        ae !== void 0 && (ie = oe.encode(ae, X, ee), 0 > se && (se = oe.getSpan(X, ee)));
      }
      ne = ee, ee += se;
    }
    return ne + ie - te;
  }
  /** @override */
  fromArray(Y) {
    const X = this.makeDestinationObject();
    for (const ee of this.fields)
      ee.property !== void 0 && 0 < Y.length && (X[ee.property] = Y.shift());
    return X;
  }
  /**
   * Get access to the layout of a given property.
   *
   * @param {String} property - the structure member of interest.
   *
   * @return {Layout} - the layout associated with `property`, or
   * undefined if there is no such property.
   */
  layoutFor(Y) {
    if (typeof Y != "string")
      throw new TypeError("property must be string");
    for (const X of this.fields)
      if (X.property === Y)
        return X;
  }
  /**
   * Get the offset of a structure member.
   *
   * @param {String} property - the structure member of interest.
   *
   * @return {Number} - the offset in bytes to the start of `property`
   * within the structure, or undefined if `property` is not a field
   * within the structure.  If the property is a member but follows a
   * variable-length structure member a negative number will be
   * returned.
   */
  offsetOf(Y) {
    if (typeof Y != "string")
      throw new TypeError("property must be string");
    let X = 0;
    for (const ee of this.fields) {
      if (ee.property === Y)
        return X;
      0 > ee.span ? X = -1 : 0 <= X && (X += ee.span);
    }
  }
};
Layout$2.Structure = Structure$1;
class UnionDiscriminator {
  constructor(X) {
    this.property = X;
  }
  /** Analog to {@link Layout#decode|Layout decode} for union discriminators.
   *
   * The implementation of this method need not reference the buffer if
   * variant information is available through other means. */
  decode(X, ee) {
    throw new Error("UnionDiscriminator is abstract");
  }
  /** Analog to {@link Layout#decode|Layout encode} for union discriminators.
   *
   * The implementation of this method need not store the value if
   * variant information is maintained through other means. */
  encode(X, ee, te) {
    throw new Error("UnionDiscriminator is abstract");
  }
}
Layout$2.UnionDiscriminator = UnionDiscriminator;
class UnionLayoutDiscriminator extends UnionDiscriminator {
  constructor(X, ee) {
    if (!(X instanceof ExternalLayout$1 && X.isCount()))
      throw new TypeError("layout must be an unsigned integer ExternalLayout");
    super(ee || X.property || "variant"), this.layout = X;
  }
  /** Delegate decoding to {@link UnionLayoutDiscriminator#layout|layout}. */
  decode(X, ee) {
    return this.layout.decode(X, ee);
  }
  /** Delegate encoding to {@link UnionLayoutDiscriminator#layout|layout}. */
  encode(X, ee, te) {
    return this.layout.encode(X, ee, te);
  }
}
Layout$2.UnionLayoutDiscriminator = UnionLayoutDiscriminator;
class Union extends Layout$1 {
  constructor(X, ee, te) {
    let ne;
    if (X instanceof UInt || X instanceof UIntBE)
      ne = new UnionLayoutDiscriminator(new OffsetLayout(X));
    else if (X instanceof ExternalLayout$1 && X.isCount())
      ne = new UnionLayoutDiscriminator(X);
    else if (X instanceof UnionDiscriminator)
      ne = X;
    else
      throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");
    if (ee === void 0 && (ee = null), !(ee === null || ee instanceof Layout$1))
      throw new TypeError("defaultLayout must be null or a Layout");
    if (ee !== null) {
      if (0 > ee.span)
        throw new Error("defaultLayout must have constant span");
      ee.property === void 0 && (ee = ee.replicate("content"));
    }
    let ie = -1;
    ee && (ie = ee.span, 0 <= ie && (X instanceof UInt || X instanceof UIntBE) && (ie += ne.layout.span)), super(ie, te), this.discriminator = ne, this.usesPrefixDiscriminator = X instanceof UInt || X instanceof UIntBE, this.defaultLayout = ee, this.registry = {};
    let oe = this.defaultGetSourceVariant.bind(this);
    this.getSourceVariant = function(se) {
      return oe(se);
    }, this.configGetSourceVariant = function(se) {
      oe = se.bind(this);
    };
  }
  /** @override */
  getSpan(X, ee = 0) {
    if (0 <= this.span)
      return this.span;
    const te = this.getVariant(X, ee);
    if (!te)
      throw new Error("unable to determine span for unrecognized variant");
    return te.getSpan(X, ee);
  }
  /**
   * Method to infer a registered Union variant compatible with `src`.
   *
   * The first satisfied rule in the following sequence defines the
   * return value:
   * * If `src` has properties matching the Union discriminator and
   *   the default layout, `undefined` is returned regardless of the
   *   value of the discriminator property (this ensures the default
   *   layout will be used);
   * * If `src` has a property matching the Union discriminator, the
   *   value of the discriminator identifies a registered variant, and
   *   either (a) the variant has no layout, or (b) `src` has the
   *   variant's property, then the variant is returned (because the
   *   source satisfies the constraints of the variant it identifies);
   * * If `src` does not have a property matching the Union
   *   discriminator, but does have a property matching a registered
   *   variant, then the variant is returned (because the source
   *   matches a variant without an explicit conflict);
   * * An error is thrown (because we either can't identify a variant,
   *   or we were explicitly told the variant but can't satisfy it).
   *
   * @param {Object} src - an object presumed to be compatible with
   * the content of the Union.
   *
   * @return {(undefined|VariantLayout)} - as described above.
   *
   * @throws {Error} - if `src` cannot be associated with a default or
   * registered variant.
   */
  defaultGetSourceVariant(X) {
    if (Object.prototype.hasOwnProperty.call(X, this.discriminator.property)) {
      if (this.defaultLayout && this.defaultLayout.property && Object.prototype.hasOwnProperty.call(X, this.defaultLayout.property))
        return;
      const ee = this.registry[X[this.discriminator.property]];
      if (ee && (!ee.layout || ee.property && Object.prototype.hasOwnProperty.call(X, ee.property)))
        return ee;
    } else
      for (const ee in this.registry) {
        const te = this.registry[ee];
        if (te.property && Object.prototype.hasOwnProperty.call(X, te.property))
          return te;
      }
    throw new Error("unable to infer src variant");
  }
  /** Implement {@link Layout#decode|decode} for {@link Union}.
   *
   * If the variant is {@link Union#addVariant|registered} the return
   * value is an instance of that variant, with no explicit
   * discriminator.  Otherwise the {@link Union#defaultLayout|default
   * layout} is used to decode the content. */
  decode(X, ee = 0) {
    let te;
    const ne = this.discriminator, ie = ne.decode(X, ee), oe = this.registry[ie];
    if (oe === void 0) {
      const se = this.defaultLayout;
      let ae = 0;
      this.usesPrefixDiscriminator && (ae = ne.layout.span), te = this.makeDestinationObject(), te[ne.property] = ie, te[se.property] = se.decode(X, ee + ae);
    } else
      te = oe.decode(X, ee);
    return te;
  }
  /** Implement {@link Layout#encode|encode} for {@link Union}.
   *
   * This API assumes the `src` object is consistent with the union's
   * {@link Union#defaultLayout|default layout}.  To encode variants
   * use the appropriate variant-specific {@link VariantLayout#encode}
   * method. */
  encode(X, ee, te = 0) {
    const ne = this.getSourceVariant(X);
    if (ne === void 0) {
      const ie = this.discriminator, oe = this.defaultLayout;
      let se = 0;
      return this.usesPrefixDiscriminator && (se = ie.layout.span), ie.encode(X[ie.property], ee, te), se + oe.encode(X[oe.property], ee, te + se);
    }
    return ne.encode(X, ee, te);
  }
  /** Register a new variant structure within a union.  The newly
   * created variant is returned.
   *
   * @param {Number} variant - initializer for {@link
   * VariantLayout#variant|variant}.
   *
   * @param {Layout} layout - initializer for {@link
   * VariantLayout#layout|layout}.
   *
   * @param {String} property - initializer for {@link
   * Layout#property|property}.
   *
   * @return {VariantLayout} */
  addVariant(X, ee, te) {
    const ne = new VariantLayout(this, X, ee, te);
    return this.registry[X] = ne, ne;
  }
  /**
   * Get the layout associated with a registered variant.
   *
   * If `vb` does not produce a registered variant the function returns
   * `undefined`.
   *
   * @param {(Number|Uint8Array)} vb - either the variant number, or a
   * buffer from which the discriminator is to be read.
   *
   * @param {Number} offset - offset into `vb` for the start of the
   * union.  Used only when `vb` is an instance of {Uint8Array}.
   *
   * @return {({VariantLayout}|undefined)}
   */
  getVariant(X, ee = 0) {
    let te;
    return X instanceof Uint8Array ? te = this.discriminator.decode(X, ee) : te = X, this.registry[te];
  }
}
Layout$2.Union = Union;
class VariantLayout extends Layout$1 {
  constructor(X, ee, te, ne) {
    if (!(X instanceof Union))
      throw new TypeError("union must be a Union");
    if (!Number.isInteger(ee) || 0 > ee)
      throw new TypeError("variant must be a (non-negative) integer");
    if (typeof te == "string" && ne === void 0 && (ne = te, te = null), te) {
      if (!(te instanceof Layout$1))
        throw new TypeError("layout must be a Layout");
      if (X.defaultLayout !== null && 0 <= te.span && te.span > X.defaultLayout.span)
        throw new Error("variant span exceeds span of containing union");
      if (typeof ne != "string")
        throw new TypeError("variant must have a String property");
    }
    let ie = X.span;
    0 > X.span && (ie = te ? te.span : 0, 0 <= ie && X.usesPrefixDiscriminator && (ie += X.discriminator.layout.span)), super(ie, ne), this.union = X, this.variant = ee, this.layout = te || null;
  }
  /** @override */
  getSpan(X, ee = 0) {
    if (0 <= this.span)
      return this.span;
    let te = 0;
    this.union.usesPrefixDiscriminator && (te = this.union.discriminator.layout.span);
    let ne = 0;
    return this.layout && (ne = this.layout.getSpan(X, ee + te)), te + ne;
  }
  /** @override */
  decode(X, ee = 0) {
    const te = this.makeDestinationObject();
    if (this !== this.union.getVariant(X, ee))
      throw new Error("variant mismatch");
    let ne = 0;
    return this.union.usesPrefixDiscriminator && (ne = this.union.discriminator.layout.span), this.layout ? te[this.property] = this.layout.decode(X, ee + ne) : this.property ? te[this.property] = !0 : this.union.usesPrefixDiscriminator && (te[this.union.discriminator.property] = this.variant), te;
  }
  /** @override */
  encode(X, ee, te = 0) {
    let ne = 0;
    if (this.union.usesPrefixDiscriminator && (ne = this.union.discriminator.layout.span), this.layout && !Object.prototype.hasOwnProperty.call(X, this.property))
      throw new TypeError("variant lacks property " + this.property);
    this.union.discriminator.encode(this.variant, ee, te);
    let ie = ne;
    if (this.layout && (this.layout.encode(X[this.property], ee, te + ne), ie += this.layout.getSpan(ee, te + ne), 0 <= this.union.span && ie > this.union.span))
      throw new Error("encoded variant overruns containing union");
    return ie;
  }
  /** Delegate {@link Layout#fromArray|fromArray} to {@link
   * VariantLayout#layout|layout}. */
  fromArray(X) {
    if (this.layout)
      return this.layout.fromArray(X);
  }
}
Layout$2.VariantLayout = VariantLayout;
function fixBitwiseResult(Y) {
  return 0 > Y && (Y += 4294967296), Y;
}
class BitStructure extends Layout$1 {
  constructor(X, ee, te) {
    if (!(X instanceof UInt || X instanceof UIntBE))
      throw new TypeError("word must be a UInt or UIntBE layout");
    if (typeof ee == "string" && te === void 0 && (te = ee, ee = !1), 4 < X.span)
      throw new RangeError("word cannot exceed 32 bits");
    super(X.span, te), this.word = X, this.msb = !!ee, this.fields = [];
    let ne = 0;
    this._packedSetValue = function(ie) {
      return ne = fixBitwiseResult(ie), this;
    }, this._packedGetValue = function() {
      return ne;
    };
  }
  /** @override */
  decode(X, ee = 0) {
    const te = this.makeDestinationObject(), ne = this.word.decode(X, ee);
    this._packedSetValue(ne);
    for (const ie of this.fields)
      ie.property !== void 0 && (te[ie.property] = ie.decode(X));
    return te;
  }
  /** Implement {@link Layout#encode|encode} for {@link BitStructure}.
   *
   * If `src` is missing a property for a member with a defined {@link
   * Layout#property|property} the corresponding region of the packed
   * value is left unmodified.  Unused bits are also left unmodified. */
  encode(X, ee, te = 0) {
    const ne = this.word.decode(ee, te);
    this._packedSetValue(ne);
    for (const ie of this.fields)
      if (ie.property !== void 0) {
        const oe = X[ie.property];
        oe !== void 0 && ie.encode(oe);
      }
    return this.word.encode(this._packedGetValue(), ee, te);
  }
  /** Register a new bitfield with a containing bit structure.  The
   * resulting bitfield is returned.
   *
   * @param {Number} bits - initializer for {@link BitField#bits|bits}.
   *
   * @param {string} property - initializer for {@link
   * Layout#property|property}.
   *
   * @return {BitField} */
  addField(X, ee) {
    const te = new BitField(this, X, ee);
    return this.fields.push(te), te;
  }
  /** As with {@link BitStructure#addField|addField} for single-bit
   * fields with `boolean` value representation.
   *
   * @param {string} property - initializer for {@link
   * Layout#property|property}.
   *
   * @return {Boolean} */
  // `Boolean` conflicts with the native primitive type
  // eslint-disable-next-line @typescript-eslint/ban-types
  addBoolean(X) {
    const ee = new Boolean$1(this, X);
    return this.fields.push(ee), ee;
  }
  /**
   * Get access to the bit field for a given property.
   *
   * @param {String} property - the bit field of interest.
   *
   * @return {BitField} - the field associated with `property`, or
   * undefined if there is no such property.
   */
  fieldFor(X) {
    if (typeof X != "string")
      throw new TypeError("property must be string");
    for (const ee of this.fields)
      if (ee.property === X)
        return ee;
  }
}
Layout$2.BitStructure = BitStructure;
class BitField {
  constructor(X, ee, te) {
    if (!(X instanceof BitStructure))
      throw new TypeError("container must be a BitStructure");
    if (!Number.isInteger(ee) || 0 >= ee)
      throw new TypeError("bits must be positive integer");
    const ne = 8 * X.span, ie = X.fields.reduce((oe, se) => oe + se.bits, 0);
    if (ee + ie > ne)
      throw new Error("bits too long for span remainder (" + (ne - ie) + " of " + ne + " remain)");
    this.container = X, this.bits = ee, this.valueMask = (1 << ee) - 1, ee === 32 && (this.valueMask = 4294967295), this.start = ie, this.container.msb && (this.start = ne - ie - ee), this.wordMask = fixBitwiseResult(this.valueMask << this.start), this.property = te;
  }
  /** Store a value into the corresponding subsequence of the containing
   * bit field. */
  decode(X, ee) {
    const te = this.container._packedGetValue();
    return fixBitwiseResult(te & this.wordMask) >>> this.start;
  }
  /** Store a value into the corresponding subsequence of the containing
   * bit field.
   *
   * **NOTE** This is not a specialization of {@link
   * Layout#encode|Layout.encode} and there is no return value. */
  encode(X) {
    if (typeof X != "number" || !Number.isInteger(X) || X !== fixBitwiseResult(X & this.valueMask))
      throw new TypeError(nameWithProperty$1("BitField.encode", this) + " value must be integer not exceeding " + this.valueMask);
    const ee = this.container._packedGetValue(), te = fixBitwiseResult(X << this.start);
    this.container._packedSetValue(fixBitwiseResult(ee & ~this.wordMask) | te);
  }
}
Layout$2.BitField = BitField;
let Boolean$1 = class extends BitField {
  constructor(Y, X) {
    super(Y, 1, X);
  }
  /** Override {@link BitField#decode|decode} for {@link Boolean|Boolean}.
   *
   * @returns {boolean} */
  decode(Y, X) {
    return !!super.decode(Y, X);
  }
  /** @override */
  encode(Y) {
    typeof Y == "boolean" && (Y = +Y), super.encode(Y);
  }
};
Layout$2.Boolean = Boolean$1;
let Blob$1 = class extends Layout$1 {
  constructor(Y, X) {
    if (!(Y instanceof ExternalLayout$1 && Y.isCount() || Number.isInteger(Y) && 0 <= Y))
      throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");
    let ee = -1;
    Y instanceof ExternalLayout$1 || (ee = Y), super(ee, X), this.length = Y;
  }
  /** @override */
  getSpan(Y, X) {
    let ee = this.span;
    return 0 > ee && (ee = this.length.decode(Y, X)), ee;
  }
  /** @override */
  decode(Y, X = 0) {
    let ee = this.span;
    return 0 > ee && (ee = this.length.decode(Y, X)), uint8ArrayToBuffer(Y).slice(X, X + ee);
  }
  /** Implement {@link Layout#encode|encode} for {@link Blob}.
   *
   * **NOTE** If {@link Layout#count|count} is an instance of {@link
   * ExternalLayout} then the length of `src` will be encoded as the
   * count after `src` is encoded. */
  encode(Y, X, ee) {
    let te = this.length;
    if (this.length instanceof ExternalLayout$1 && (te = Y.length), !(Y instanceof Uint8Array && te === Y.length))
      throw new TypeError(nameWithProperty$1("Blob.encode", this) + " requires (length " + te + ") Uint8Array as src");
    if (ee + te > X.length)
      throw new RangeError("encoding overruns Uint8Array");
    const ne = uint8ArrayToBuffer(Y);
    return uint8ArrayToBuffer(X).write(ne.toString("hex"), ee, te, "hex"), this.length instanceof ExternalLayout$1 && this.length.encode(te, X, ee), te;
  }
};
Layout$2.Blob = Blob$1;
class CString extends Layout$1 {
  constructor(X) {
    super(-1, X);
  }
  /** @override */
  getSpan(X, ee = 0) {
    checkUint8Array(X);
    let te = ee;
    for (; te < X.length && X[te] !== 0; )
      te += 1;
    return 1 + te - ee;
  }
  /** @override */
  decode(X, ee = 0) {
    const te = this.getSpan(X, ee);
    return uint8ArrayToBuffer(X).slice(ee, ee + te - 1).toString("utf-8");
  }
  /** @override */
  encode(X, ee, te = 0) {
    typeof X != "string" && (X = String(X));
    const ne = buffer_1.Buffer.from(X, "utf8"), ie = ne.length;
    if (te + ie > ee.length)
      throw new RangeError("encoding overruns Buffer");
    const oe = uint8ArrayToBuffer(ee);
    return ne.copy(oe, te), oe[te + ie] = 0, ie + 1;
  }
}
Layout$2.CString = CString;
class UTF8 extends Layout$1 {
  constructor(X, ee) {
    if (typeof X == "string" && ee === void 0 && (ee = X, X = void 0), X === void 0)
      X = -1;
    else if (!Number.isInteger(X))
      throw new TypeError("maxSpan must be an integer");
    super(-1, ee), this.maxSpan = X;
  }
  /** @override */
  getSpan(X, ee = 0) {
    return checkUint8Array(X), X.length - ee;
  }
  /** @override */
  decode(X, ee = 0) {
    const te = this.getSpan(X, ee);
    if (0 <= this.maxSpan && this.maxSpan < te)
      throw new RangeError("text length exceeds maxSpan");
    return uint8ArrayToBuffer(X).slice(ee, ee + te).toString("utf-8");
  }
  /** @override */
  encode(X, ee, te = 0) {
    typeof X != "string" && (X = String(X));
    const ne = buffer_1.Buffer.from(X, "utf8"), ie = ne.length;
    if (0 <= this.maxSpan && this.maxSpan < ie)
      throw new RangeError("text length exceeds maxSpan");
    if (te + ie > ee.length)
      throw new RangeError("encoding overruns Buffer");
    return ne.copy(uint8ArrayToBuffer(ee), te), ie;
  }
}
Layout$2.UTF8 = UTF8;
class Constant extends Layout$1 {
  constructor(X, ee) {
    super(0, ee), this.value = X;
  }
  /** @override */
  decode(X, ee) {
    return this.value;
  }
  /** @override */
  encode(X, ee, te) {
    return 0;
  }
}
Layout$2.Constant = Constant;
Layout$2.greedy = (Y, X) => new GreedyCount(Y, X);
var offset = Layout$2.offset = (Y, X, ee) => new OffsetLayout(Y, X, ee), u8 = Layout$2.u8 = (Y) => new UInt(1, Y), u16 = Layout$2.u16 = (Y) => new UInt(2, Y);
Layout$2.u24 = (Y) => new UInt(3, Y);
var u32 = Layout$2.u32 = (Y) => new UInt(4, Y);
Layout$2.u40 = (Y) => new UInt(5, Y);
Layout$2.u48 = (Y) => new UInt(6, Y);
var nu64$1 = Layout$2.nu64 = (Y) => new NearUInt64$1(Y);
Layout$2.u16be = (Y) => new UIntBE(2, Y);
Layout$2.u24be = (Y) => new UIntBE(3, Y);
Layout$2.u32be = (Y) => new UIntBE(4, Y);
Layout$2.u40be = (Y) => new UIntBE(5, Y);
Layout$2.u48be = (Y) => new UIntBE(6, Y);
Layout$2.nu64be = (Y) => new NearUInt64BE(Y);
Layout$2.s8 = (Y) => new Int(1, Y);
Layout$2.s16 = (Y) => new Int(2, Y);
Layout$2.s24 = (Y) => new Int(3, Y);
Layout$2.s32 = (Y) => new Int(4, Y);
Layout$2.s40 = (Y) => new Int(5, Y);
Layout$2.s48 = (Y) => new Int(6, Y);
var ns64 = Layout$2.ns64 = (Y) => new NearInt64(Y);
Layout$2.s16be = (Y) => new IntBE(2, Y);
Layout$2.s24be = (Y) => new IntBE(3, Y);
Layout$2.s32be = (Y) => new IntBE(4, Y);
Layout$2.s40be = (Y) => new IntBE(5, Y);
Layout$2.s48be = (Y) => new IntBE(6, Y);
Layout$2.ns64be = (Y) => new NearInt64BE(Y);
Layout$2.f32 = (Y) => new Float(Y);
Layout$2.f32be = (Y) => new FloatBE(Y);
Layout$2.f64 = (Y) => new Double(Y);
Layout$2.f64be = (Y) => new DoubleBE(Y);
var struct$1 = Layout$2.struct = (Y, X, ee) => new Structure$1(Y, X, ee);
Layout$2.bits = (Y, X, ee) => new BitStructure(Y, X, ee);
var seq = Layout$2.seq = (Y, X, ee) => new Sequence(Y, X, ee);
Layout$2.union = (Y, X, ee) => new Union(Y, X, ee);
Layout$2.unionLayoutDiscriminator = (Y, X) => new UnionLayoutDiscriminator(Y, X);
var blob$1 = Layout$2.blob = (Y, X) => new Blob$1(Y, X);
Layout$2.cstr = (Y) => new CString(Y);
Layout$2.utf8 = (Y, X) => new UTF8(Y, X);
Layout$2.constant = (Y, X) => new Constant(Y, X);
var browser$1 = {};
Object.defineProperty(browser$1, "__esModule", { value: !0 });
function toBigIntLE(Y) {
  {
    const X = Buffer$e.from(Y);
    X.reverse();
    const ee = X.toString("hex");
    return ee.length === 0 ? BigInt(0) : BigInt(`0x${ee}`);
  }
}
var toBigIntLE_1 = browser$1.toBigIntLE = toBigIntLE;
function toBigIntBE(Y) {
  {
    const X = Y.toString("hex");
    return X.length === 0 ? BigInt(0) : BigInt(`0x${X}`);
  }
}
browser$1.toBigIntBE = toBigIntBE;
function toBufferLE(Y, X) {
  {
    const ee = Y.toString(16), te = Buffer$e.from(ee.padStart(X * 2, "0").slice(0, X * 2), "hex");
    return te.reverse(), te;
  }
}
var toBufferLE_1 = browser$1.toBufferLE = toBufferLE;
function toBufferBE(Y, X) {
  {
    const ee = Y.toString(16);
    return Buffer$e.from(ee.padStart(X * 2, "0").slice(0, X * 2), "hex");
  }
}
browser$1.toBufferBE = toBufferBE;
class StructError extends TypeError {
  constructor(X, ee) {
    let te;
    const {
      message: ne,
      ...ie
    } = X, {
      path: oe
    } = X, se = oe.length === 0 ? ne : "At path: " + oe.join(".") + " -- " + ne;
    super(se), Object.assign(this, ie), this.name = this.constructor.name, this.failures = () => {
      var ae;
      return (ae = te) != null ? ae : te = [X, ...ee()];
    };
  }
}
function isIterable(Y) {
  return isObject(Y) && typeof Y[Symbol.iterator] == "function";
}
function isObject(Y) {
  return typeof Y == "object" && Y != null;
}
function print(Y) {
  return typeof Y == "string" ? JSON.stringify(Y) : "" + Y;
}
function shiftIterator(Y) {
  const {
    done: X,
    value: ee
  } = Y.next();
  return X ? void 0 : ee;
}
function toFailure(Y, X, ee, te) {
  if (Y === !0)
    return;
  Y === !1 ? Y = {} : typeof Y == "string" && (Y = {
    message: Y
  });
  const {
    path: ne,
    branch: ie
  } = X, {
    type: oe
  } = ee, {
    refinement: se,
    message: ae = "Expected a value of type `" + oe + "`" + (se ? " with refinement `" + se + "`" : "") + ", but received: `" + print(te) + "`"
  } = Y;
  return {
    value: te,
    type: oe,
    refinement: se,
    key: ne[ne.length - 1],
    path: ne,
    branch: ie,
    ...Y,
    message: ae
  };
}
function* toFailures(Y, X, ee, te) {
  isIterable(Y) || (Y = [Y]);
  for (const ne of Y) {
    const ie = toFailure(ne, X, ee, te);
    ie && (yield ie);
  }
}
function* run(Y, X, ee = {}) {
  const {
    path: te = [],
    branch: ne = [Y],
    coerce: ie = !1,
    mask: oe = !1
  } = ee, se = {
    path: te,
    branch: ne
  };
  if (ie && (Y = X.coercer(Y, se), oe && X.type !== "type" && isObject(X.schema) && isObject(Y) && !Array.isArray(Y)))
    for (const ue in Y)
      X.schema[ue] === void 0 && delete Y[ue];
  let ae = !0;
  for (const ue of X.validator(Y, se))
    ae = !1, yield [ue, void 0];
  for (let [ue, le, he] of X.entries(Y, se)) {
    const me = run(le, he, {
      path: ue === void 0 ? te : [...te, ue],
      branch: ue === void 0 ? ne : [...ne, le],
      coerce: ie,
      mask: oe
    });
    for (const ye of me)
      ye[0] ? (ae = !1, yield [ye[0], void 0]) : ie && (le = ye[1], ue === void 0 ? Y = le : Y instanceof Map ? Y.set(ue, le) : Y instanceof Set ? Y.add(le) : isObject(Y) && (Y[ue] = le));
  }
  if (ae)
    for (const ue of X.refiner(Y, se))
      ae = !1, yield [ue, void 0];
  ae && (yield [void 0, Y]);
}
let Struct$1 = class {
  constructor(Y) {
    const {
      type: X,
      schema: ee,
      validator: te,
      refiner: ne,
      coercer: ie = (se) => se,
      entries: oe = function* () {
      }
    } = Y;
    this.type = X, this.schema = ee, this.entries = oe, this.coercer = ie, te ? this.validator = (se, ae) => {
      const ue = te(se, ae);
      return toFailures(ue, ae, this, se);
    } : this.validator = () => [], ne ? this.refiner = (se, ae) => {
      const ue = ne(se, ae);
      return toFailures(ue, ae, this, se);
    } : this.refiner = () => [];
  }
  /**
   * Assert that a value passes the struct's validation, throwing if it doesn't.
   */
  assert(Y) {
    return assert$1(Y, this);
  }
  /**
   * Create a value with the struct's coercion logic, then validate it.
   */
  create(Y) {
    return create(Y, this);
  }
  /**
   * Check if a value passes the struct's validation.
   */
  is(Y) {
    return is(Y, this);
  }
  /**
   * Mask a value, coercing and validating it, but returning only the subset of
   * properties defined by the struct's schema.
   */
  mask(Y) {
    return mask(Y, this);
  }
  /**
   * Validate a value with the struct's validation logic, returning a tuple
   * representing the result.
   *
   * You may optionally pass `true` for the `withCoercion` argument to coerce
   * the value before attempting to validate it. If you do, the result will
   * contain the coerced result when successful.
   */
  validate(Y, X = {}) {
    return validate$1(Y, this, X);
  }
};
function assert$1(Y, X) {
  const ee = validate$1(Y, X);
  if (ee[0])
    throw ee[0];
}
function create(Y, X) {
  const ee = validate$1(Y, X, {
    coerce: !0
  });
  if (ee[0])
    throw ee[0];
  return ee[1];
}
function mask(Y, X) {
  const ee = validate$1(Y, X, {
    coerce: !0,
    mask: !0
  });
  if (ee[0])
    throw ee[0];
  return ee[1];
}
function is(Y, X) {
  return !validate$1(Y, X)[0];
}
function validate$1(Y, X, ee = {}) {
  const te = run(Y, X, ee), ne = shiftIterator(te);
  return ne[0] ? [new StructError(ne[0], function* () {
    for (const ie of te)
      ie[0] && (yield ie[0]);
  }), void 0] : [void 0, ne[1]];
}
function define(Y, X) {
  return new Struct$1({
    type: Y,
    schema: null,
    validator: X
  });
}
function any() {
  return define("any", () => !0);
}
function array(Y) {
  return new Struct$1({
    type: "array",
    schema: Y,
    *entries(X) {
      if (Y && Array.isArray(X))
        for (const [ee, te] of X.entries())
          yield [ee, te, Y];
    },
    coercer(X) {
      return Array.isArray(X) ? X.slice() : X;
    },
    validator(X) {
      return Array.isArray(X) || "Expected an array value, but received: " + print(X);
    }
  });
}
function boolean() {
  return define("boolean", (Y) => typeof Y == "boolean");
}
function instance(Y) {
  return define("instance", (X) => X instanceof Y || "Expected a `" + Y.name + "` instance, but received: " + print(X));
}
function literal(Y) {
  const X = print(Y), ee = typeof Y;
  return new Struct$1({
    type: "literal",
    schema: ee === "string" || ee === "number" || ee === "boolean" ? Y : null,
    validator(te) {
      return te === Y || "Expected the literal `" + X + "`, but received: " + print(te);
    }
  });
}
function never() {
  return define("never", () => !1);
}
function nullable(Y) {
  return new Struct$1({
    ...Y,
    validator: (X, ee) => X === null || Y.validator(X, ee),
    refiner: (X, ee) => X === null || Y.refiner(X, ee)
  });
}
function number() {
  return define("number", (Y) => typeof Y == "number" && !isNaN(Y) || "Expected a number, but received: " + print(Y));
}
function optional(Y) {
  return new Struct$1({
    ...Y,
    validator: (X, ee) => X === void 0 || Y.validator(X, ee),
    refiner: (X, ee) => X === void 0 || Y.refiner(X, ee)
  });
}
function record(Y, X) {
  return new Struct$1({
    type: "record",
    schema: null,
    *entries(ee) {
      if (isObject(ee))
        for (const te in ee) {
          const ne = ee[te];
          yield [te, te, Y], yield [te, ne, X];
        }
    },
    validator(ee) {
      return isObject(ee) || "Expected an object, but received: " + print(ee);
    }
  });
}
function string() {
  return define("string", (Y) => typeof Y == "string" || "Expected a string, but received: " + print(Y));
}
function tuple(Y) {
  const X = never();
  return new Struct$1({
    type: "tuple",
    schema: null,
    *entries(ee) {
      if (Array.isArray(ee)) {
        const te = Math.max(Y.length, ee.length);
        for (let ne = 0; ne < te; ne++)
          yield [ne, ee[ne], Y[ne] || X];
      }
    },
    validator(ee) {
      return Array.isArray(ee) || "Expected an array, but received: " + print(ee);
    }
  });
}
function type(Y) {
  const X = Object.keys(Y);
  return new Struct$1({
    type: "type",
    schema: Y,
    *entries(ee) {
      if (isObject(ee))
        for (const te of X)
          yield [te, ee[te], Y[te]];
    },
    validator(ee) {
      return isObject(ee) || "Expected an object, but received: " + print(ee);
    }
  });
}
function union(Y) {
  const X = Y.map((ee) => ee.type).join(" | ");
  return new Struct$1({
    type: "union",
    schema: null,
    validator(ee, te) {
      const ne = [];
      for (const ie of Y) {
        const [...oe] = run(ee, ie, te), [se] = oe;
        if (se[0])
          for (const [ae] of oe)
            ae && ne.push(ae);
        else
          return [];
      }
      return ["Expected the value to satisfy a union of `" + X + "`, but received: " + print(ee), ...ne];
    }
  });
}
function unknown() {
  return define("unknown", () => !0);
}
function coerce(Y, X, ee) {
  return new Struct$1({
    ...Y,
    coercer: (te, ne) => is(te, X) ? Y.coercer(ee(te, ne), ne) : Y.coercer(te, ne)
  });
}
var getRandomValues$1, rnds8$1 = new Uint8Array(16);
function rng$1() {
  if (!getRandomValues$1 && (getRandomValues$1 = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto < "u" && typeof msCrypto.getRandomValues == "function" && msCrypto.getRandomValues.bind(msCrypto), !getRandomValues$1))
    throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
  return getRandomValues$1(rnds8$1);
}
const REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
function validate(Y) {
  return typeof Y == "string" && REGEX.test(Y);
}
var byteToHex$1 = [];
for (var i = 0; i < 256; ++i)
  byteToHex$1.push((i + 256).toString(16).substr(1));
function stringify$1(Y) {
  var X = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, ee = (byteToHex$1[Y[X + 0]] + byteToHex$1[Y[X + 1]] + byteToHex$1[Y[X + 2]] + byteToHex$1[Y[X + 3]] + "-" + byteToHex$1[Y[X + 4]] + byteToHex$1[Y[X + 5]] + "-" + byteToHex$1[Y[X + 6]] + byteToHex$1[Y[X + 7]] + "-" + byteToHex$1[Y[X + 8]] + byteToHex$1[Y[X + 9]] + "-" + byteToHex$1[Y[X + 10]] + byteToHex$1[Y[X + 11]] + byteToHex$1[Y[X + 12]] + byteToHex$1[Y[X + 13]] + byteToHex$1[Y[X + 14]] + byteToHex$1[Y[X + 15]]).toLowerCase();
  if (!validate(ee))
    throw TypeError("Stringified UUID is invalid");
  return ee;
}
var _nodeId, _clockseq, _lastMSecs = 0, _lastNSecs = 0;
function v1(Y, X, ee) {
  var te = X && ee || 0, ne = X || new Array(16);
  Y = Y || {};
  var ie = Y.node || _nodeId, oe = Y.clockseq !== void 0 ? Y.clockseq : _clockseq;
  if (ie == null || oe == null) {
    var se = Y.random || (Y.rng || rng$1)();
    ie == null && (ie = _nodeId = [se[0] | 1, se[1], se[2], se[3], se[4], se[5]]), oe == null && (oe = _clockseq = (se[6] << 8 | se[7]) & 16383);
  }
  var ae = Y.msecs !== void 0 ? Y.msecs : Date.now(), ue = Y.nsecs !== void 0 ? Y.nsecs : _lastNSecs + 1, le = ae - _lastMSecs + (ue - _lastNSecs) / 1e4;
  if (le < 0 && Y.clockseq === void 0 && (oe = oe + 1 & 16383), (le < 0 || ae > _lastMSecs) && Y.nsecs === void 0 && (ue = 0), ue >= 1e4)
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  _lastMSecs = ae, _lastNSecs = ue, _clockseq = oe, ae += 122192928e5;
  var he = ((ae & 268435455) * 1e4 + ue) % 4294967296;
  ne[te++] = he >>> 24 & 255, ne[te++] = he >>> 16 & 255, ne[te++] = he >>> 8 & 255, ne[te++] = he & 255;
  var me = ae / 4294967296 * 1e4 & 268435455;
  ne[te++] = me >>> 8 & 255, ne[te++] = me & 255, ne[te++] = me >>> 24 & 15 | 16, ne[te++] = me >>> 16 & 255, ne[te++] = oe >>> 8 | 128, ne[te++] = oe & 255;
  for (var ye = 0; ye < 6; ++ye)
    ne[te + ye] = ie[ye];
  return X || stringify$1(ne);
}
function parse(Y) {
  if (!validate(Y))
    throw TypeError("Invalid UUID");
  var X, ee = new Uint8Array(16);
  return ee[0] = (X = parseInt(Y.slice(0, 8), 16)) >>> 24, ee[1] = X >>> 16 & 255, ee[2] = X >>> 8 & 255, ee[3] = X & 255, ee[4] = (X = parseInt(Y.slice(9, 13), 16)) >>> 8, ee[5] = X & 255, ee[6] = (X = parseInt(Y.slice(14, 18), 16)) >>> 8, ee[7] = X & 255, ee[8] = (X = parseInt(Y.slice(19, 23), 16)) >>> 8, ee[9] = X & 255, ee[10] = (X = parseInt(Y.slice(24, 36), 16)) / 1099511627776 & 255, ee[11] = X / 4294967296 & 255, ee[12] = X >>> 24 & 255, ee[13] = X >>> 16 & 255, ee[14] = X >>> 8 & 255, ee[15] = X & 255, ee;
}
function stringToBytes(Y) {
  Y = unescape(encodeURIComponent(Y));
  for (var X = [], ee = 0; ee < Y.length; ++ee)
    X.push(Y.charCodeAt(ee));
  return X;
}
var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8", URL$1 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
function v35(Y, X, ee) {
  function te(ne, ie, oe, se) {
    if (typeof ne == "string" && (ne = stringToBytes(ne)), typeof ie == "string" && (ie = parse(ie)), ie.length !== 16)
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    var ae = new Uint8Array(16 + ne.length);
    if (ae.set(ie), ae.set(ne, ie.length), ae = ee(ae), ae[6] = ae[6] & 15 | X, ae[8] = ae[8] & 63 | 128, oe) {
      se = se || 0;
      for (var ue = 0; ue < 16; ++ue)
        oe[se + ue] = ae[ue];
      return oe;
    }
    return stringify$1(ae);
  }
  try {
    te.name = Y;
  } catch {
  }
  return te.DNS = DNS, te.URL = URL$1, te;
}
function md5(Y) {
  if (typeof Y == "string") {
    var X = unescape(encodeURIComponent(Y));
    Y = new Uint8Array(X.length);
    for (var ee = 0; ee < X.length; ++ee)
      Y[ee] = X.charCodeAt(ee);
  }
  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(Y), Y.length * 8));
}
function md5ToHexEncodedArray(Y) {
  for (var X = [], ee = Y.length * 32, te = "0123456789abcdef", ne = 0; ne < ee; ne += 8) {
    var ie = Y[ne >> 5] >>> ne % 32 & 255, oe = parseInt(te.charAt(ie >>> 4 & 15) + te.charAt(ie & 15), 16);
    X.push(oe);
  }
  return X;
}
function getOutputLength(Y) {
  return (Y + 64 >>> 9 << 4) + 14 + 1;
}
function wordsToMd5(Y, X) {
  Y[X >> 5] |= 128 << X % 32, Y[getOutputLength(X) - 1] = X;
  for (var ee = 1732584193, te = -271733879, ne = -1732584194, ie = 271733878, oe = 0; oe < Y.length; oe += 16) {
    var se = ee, ae = te, ue = ne, le = ie;
    ee = md5ff(ee, te, ne, ie, Y[oe], 7, -680876936), ie = md5ff(ie, ee, te, ne, Y[oe + 1], 12, -389564586), ne = md5ff(ne, ie, ee, te, Y[oe + 2], 17, 606105819), te = md5ff(te, ne, ie, ee, Y[oe + 3], 22, -1044525330), ee = md5ff(ee, te, ne, ie, Y[oe + 4], 7, -176418897), ie = md5ff(ie, ee, te, ne, Y[oe + 5], 12, 1200080426), ne = md5ff(ne, ie, ee, te, Y[oe + 6], 17, -1473231341), te = md5ff(te, ne, ie, ee, Y[oe + 7], 22, -45705983), ee = md5ff(ee, te, ne, ie, Y[oe + 8], 7, 1770035416), ie = md5ff(ie, ee, te, ne, Y[oe + 9], 12, -1958414417), ne = md5ff(ne, ie, ee, te, Y[oe + 10], 17, -42063), te = md5ff(te, ne, ie, ee, Y[oe + 11], 22, -1990404162), ee = md5ff(ee, te, ne, ie, Y[oe + 12], 7, 1804603682), ie = md5ff(ie, ee, te, ne, Y[oe + 13], 12, -40341101), ne = md5ff(ne, ie, ee, te, Y[oe + 14], 17, -1502002290), te = md5ff(te, ne, ie, ee, Y[oe + 15], 22, 1236535329), ee = md5gg(ee, te, ne, ie, Y[oe + 1], 5, -165796510), ie = md5gg(ie, ee, te, ne, Y[oe + 6], 9, -1069501632), ne = md5gg(ne, ie, ee, te, Y[oe + 11], 14, 643717713), te = md5gg(te, ne, ie, ee, Y[oe], 20, -373897302), ee = md5gg(ee, te, ne, ie, Y[oe + 5], 5, -701558691), ie = md5gg(ie, ee, te, ne, Y[oe + 10], 9, 38016083), ne = md5gg(ne, ie, ee, te, Y[oe + 15], 14, -660478335), te = md5gg(te, ne, ie, ee, Y[oe + 4], 20, -405537848), ee = md5gg(ee, te, ne, ie, Y[oe + 9], 5, 568446438), ie = md5gg(ie, ee, te, ne, Y[oe + 14], 9, -1019803690), ne = md5gg(ne, ie, ee, te, Y[oe + 3], 14, -187363961), te = md5gg(te, ne, ie, ee, Y[oe + 8], 20, 1163531501), ee = md5gg(ee, te, ne, ie, Y[oe + 13], 5, -1444681467), ie = md5gg(ie, ee, te, ne, Y[oe + 2], 9, -51403784), ne = md5gg(ne, ie, ee, te, Y[oe + 7], 14, 1735328473), te = md5gg(te, ne, ie, ee, Y[oe + 12], 20, -1926607734), ee = md5hh(ee, te, ne, ie, Y[oe + 5], 4, -378558), ie = md5hh(ie, ee, te, ne, Y[oe + 8], 11, -2022574463), ne = md5hh(ne, ie, ee, te, Y[oe + 11], 16, 1839030562), te = md5hh(te, ne, ie, ee, Y[oe + 14], 23, -35309556), ee = md5hh(ee, te, ne, ie, Y[oe + 1], 4, -1530992060), ie = md5hh(ie, ee, te, ne, Y[oe + 4], 11, 1272893353), ne = md5hh(ne, ie, ee, te, Y[oe + 7], 16, -155497632), te = md5hh(te, ne, ie, ee, Y[oe + 10], 23, -1094730640), ee = md5hh(ee, te, ne, ie, Y[oe + 13], 4, 681279174), ie = md5hh(ie, ee, te, ne, Y[oe], 11, -358537222), ne = md5hh(ne, ie, ee, te, Y[oe + 3], 16, -722521979), te = md5hh(te, ne, ie, ee, Y[oe + 6], 23, 76029189), ee = md5hh(ee, te, ne, ie, Y[oe + 9], 4, -640364487), ie = md5hh(ie, ee, te, ne, Y[oe + 12], 11, -421815835), ne = md5hh(ne, ie, ee, te, Y[oe + 15], 16, 530742520), te = md5hh(te, ne, ie, ee, Y[oe + 2], 23, -995338651), ee = md5ii(ee, te, ne, ie, Y[oe], 6, -198630844), ie = md5ii(ie, ee, te, ne, Y[oe + 7], 10, 1126891415), ne = md5ii(ne, ie, ee, te, Y[oe + 14], 15, -1416354905), te = md5ii(te, ne, ie, ee, Y[oe + 5], 21, -57434055), ee = md5ii(ee, te, ne, ie, Y[oe + 12], 6, 1700485571), ie = md5ii(ie, ee, te, ne, Y[oe + 3], 10, -1894986606), ne = md5ii(ne, ie, ee, te, Y[oe + 10], 15, -1051523), te = md5ii(te, ne, ie, ee, Y[oe + 1], 21, -2054922799), ee = md5ii(ee, te, ne, ie, Y[oe + 8], 6, 1873313359), ie = md5ii(ie, ee, te, ne, Y[oe + 15], 10, -30611744), ne = md5ii(ne, ie, ee, te, Y[oe + 6], 15, -1560198380), te = md5ii(te, ne, ie, ee, Y[oe + 13], 21, 1309151649), ee = md5ii(ee, te, ne, ie, Y[oe + 4], 6, -145523070), ie = md5ii(ie, ee, te, ne, Y[oe + 11], 10, -1120210379), ne = md5ii(ne, ie, ee, te, Y[oe + 2], 15, 718787259), te = md5ii(te, ne, ie, ee, Y[oe + 9], 21, -343485551), ee = safeAdd(ee, se), te = safeAdd(te, ae), ne = safeAdd(ne, ue), ie = safeAdd(ie, le);
  }
  return [ee, te, ne, ie];
}
function bytesToWords(Y) {
  if (Y.length === 0)
    return [];
  for (var X = Y.length * 8, ee = new Uint32Array(getOutputLength(X)), te = 0; te < X; te += 8)
    ee[te >> 5] |= (Y[te / 8] & 255) << te % 32;
  return ee;
}
function safeAdd(Y, X) {
  var ee = (Y & 65535) + (X & 65535), te = (Y >> 16) + (X >> 16) + (ee >> 16);
  return te << 16 | ee & 65535;
}
function bitRotateLeft(Y, X) {
  return Y << X | Y >>> 32 - X;
}
function md5cmn(Y, X, ee, te, ne, ie) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(X, Y), safeAdd(te, ie)), ne), ee);
}
function md5ff(Y, X, ee, te, ne, ie, oe) {
  return md5cmn(X & ee | ~X & te, Y, X, ne, ie, oe);
}
function md5gg(Y, X, ee, te, ne, ie, oe) {
  return md5cmn(X & te | ee & ~te, Y, X, ne, ie, oe);
}
function md5hh(Y, X, ee, te, ne, ie, oe) {
  return md5cmn(X ^ ee ^ te, Y, X, ne, ie, oe);
}
function md5ii(Y, X, ee, te, ne, ie, oe) {
  return md5cmn(ee ^ (X | ~te), Y, X, ne, ie, oe);
}
var v3 = v35("v3", 48, md5);
const v3$1 = v3;
function v4$1(Y, X, ee) {
  Y = Y || {};
  var te = Y.random || (Y.rng || rng$1)();
  if (te[6] = te[6] & 15 | 64, te[8] = te[8] & 63 | 128, X) {
    ee = ee || 0;
    for (var ne = 0; ne < 16; ++ne)
      X[ee + ne] = te[ne];
    return X;
  }
  return stringify$1(te);
}
function f(Y, X, ee, te) {
  switch (Y) {
    case 0:
      return X & ee ^ ~X & te;
    case 1:
      return X ^ ee ^ te;
    case 2:
      return X & ee ^ X & te ^ ee & te;
    case 3:
      return X ^ ee ^ te;
  }
}
function ROTL(Y, X) {
  return Y << X | Y >>> 32 - X;
}
function sha1(Y) {
  var X = [1518500249, 1859775393, 2400959708, 3395469782], ee = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  if (typeof Y == "string") {
    var te = unescape(encodeURIComponent(Y));
    Y = [];
    for (var ne = 0; ne < te.length; ++ne)
      Y.push(te.charCodeAt(ne));
  } else
    Array.isArray(Y) || (Y = Array.prototype.slice.call(Y));
  Y.push(128);
  for (var ie = Y.length / 4 + 2, oe = Math.ceil(ie / 16), se = new Array(oe), ae = 0; ae < oe; ++ae) {
    for (var ue = new Uint32Array(16), le = 0; le < 16; ++le)
      ue[le] = Y[ae * 64 + le * 4] << 24 | Y[ae * 64 + le * 4 + 1] << 16 | Y[ae * 64 + le * 4 + 2] << 8 | Y[ae * 64 + le * 4 + 3];
    se[ae] = ue;
  }
  se[oe - 1][14] = (Y.length - 1) * 8 / Math.pow(2, 32), se[oe - 1][14] = Math.floor(se[oe - 1][14]), se[oe - 1][15] = (Y.length - 1) * 8 & 4294967295;
  for (var he = 0; he < oe; ++he) {
    for (var me = new Uint32Array(80), ye = 0; ye < 16; ++ye)
      me[ye] = se[he][ye];
    for (var we = 16; we < 80; ++we)
      me[we] = ROTL(me[we - 3] ^ me[we - 8] ^ me[we - 14] ^ me[we - 16], 1);
    for (var Ee = ee[0], Re = ee[1], Ue = ee[2], Me = ee[3], De = ee[4], Fe = 0; Fe < 80; ++Fe) {
      var Ke = Math.floor(Fe / 20), tt = ROTL(Ee, 5) + f(Ke, Re, Ue, Me) + De + X[Ke] + me[Fe] >>> 0;
      De = Me, Me = Ue, Ue = ROTL(Re, 30) >>> 0, Re = Ee, Ee = tt;
    }
    ee[0] = ee[0] + Ee >>> 0, ee[1] = ee[1] + Re >>> 0, ee[2] = ee[2] + Ue >>> 0, ee[3] = ee[3] + Me >>> 0, ee[4] = ee[4] + De >>> 0;
  }
  return [ee[0] >> 24 & 255, ee[0] >> 16 & 255, ee[0] >> 8 & 255, ee[0] & 255, ee[1] >> 24 & 255, ee[1] >> 16 & 255, ee[1] >> 8 & 255, ee[1] & 255, ee[2] >> 24 & 255, ee[2] >> 16 & 255, ee[2] >> 8 & 255, ee[2] & 255, ee[3] >> 24 & 255, ee[3] >> 16 & 255, ee[3] >> 8 & 255, ee[3] & 255, ee[4] >> 24 & 255, ee[4] >> 16 & 255, ee[4] >> 8 & 255, ee[4] & 255];
}
var v5 = v35("v5", 80, sha1);
const v5$1 = v5, nil = "00000000-0000-0000-0000-000000000000";
function version(Y) {
  if (!validate(Y))
    throw TypeError("Invalid UUID");
  return parseInt(Y.substr(14, 1), 16);
}
const esmBrowser = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  NIL: nil,
  parse,
  stringify: stringify$1,
  v1,
  v3: v3$1,
  v4: v4$1,
  v5: v5$1,
  validate,
  version
}, Symbol.toStringTag, { value: "Module" })), require$$0 = /* @__PURE__ */ getAugmentedNamespace(esmBrowser), uuid$1 = require$$0.v4, generateRequest$1 = function(Y, X, ee, te) {
  if (typeof Y != "string")
    throw new TypeError(Y + " must be a string");
  te = te || {};
  const ne = typeof te.version == "number" ? te.version : 2;
  if (ne !== 1 && ne !== 2)
    throw new TypeError(ne + " must be 1 or 2");
  const ie = {
    method: Y
  };
  if (ne === 2 && (ie.jsonrpc = "2.0"), X) {
    if (typeof X != "object" && !Array.isArray(X))
      throw new TypeError(X + " must be an object, array or omitted");
    ie.params = X;
  }
  if (typeof ee > "u") {
    const oe = typeof te.generator == "function" ? te.generator : function() {
      return uuid$1();
    };
    ie.id = oe(ie, te);
  } else
    ne === 2 && ee === null ? te.notificationIdNull && (ie.id = null) : ie.id = ee;
  return ie;
};
var generateRequest_1 = generateRequest$1;
const uuid = require$$0.v4, generateRequest = generateRequest_1, ClientBrowser = function(Y, X) {
  if (!(this instanceof ClientBrowser))
    return new ClientBrowser(Y, X);
  X || (X = {}), this.options = {
    reviver: typeof X.reviver < "u" ? X.reviver : null,
    replacer: typeof X.replacer < "u" ? X.replacer : null,
    generator: typeof X.generator < "u" ? X.generator : function() {
      return uuid();
    },
    version: typeof X.version < "u" ? X.version : 2,
    notificationIdNull: typeof X.notificationIdNull == "boolean" ? X.notificationIdNull : !1
  }, this.callServer = Y;
};
var browser = ClientBrowser;
ClientBrowser.prototype.request = function(Y, X, ee, te) {
  const ne = this;
  let ie = null;
  const oe = Array.isArray(Y) && typeof X == "function";
  if (this.options.version === 1 && oe)
    throw new TypeError("JSON-RPC 1.0 does not support batching");
  if (oe || !oe && Y && typeof Y == "object" && typeof X == "function")
    te = X, ie = Y;
  else {
    typeof ee == "function" && (te = ee, ee = void 0);
    const ae = typeof te == "function";
    try {
      ie = generateRequest(Y, X, ee, {
        generator: this.options.generator,
        version: this.options.version,
        notificationIdNull: this.options.notificationIdNull
      });
    } catch (ue) {
      if (ae)
        return te(ue);
      throw ue;
    }
    if (!ae)
      return ie;
  }
  let se;
  try {
    se = JSON.stringify(ie, this.options.replacer);
  } catch (ae) {
    return te(ae);
  }
  return this.callServer(se, function(ae, ue) {
    ne._parseResponse(ae, ue, te);
  }), ie;
};
ClientBrowser.prototype._parseResponse = function(Y, X, ee) {
  if (Y) {
    ee(Y);
    return;
  }
  if (!X)
    return ee();
  let te;
  try {
    te = JSON.parse(X, this.options.reviver);
  } catch (ne) {
    return ee(ne);
  }
  if (ee.length === 3)
    if (Array.isArray(te)) {
      const ne = function(oe) {
        return typeof oe.error < "u";
      }, ie = function(oe) {
        return !ne(oe);
      };
      return ee(null, te.filter(ne), te.filter(ie));
    } else
      return ee(null, te.error, te.result);
  ee(null, te);
};
const RpcClient = /* @__PURE__ */ getDefaultExportFromCjs$2(browser);
var client = {}, interopRequireDefault = { exports: {} };
(function(Y) {
  function X(ee) {
    return ee && ee.__esModule ? ee : {
      default: ee
    };
  }
  Y.exports = X, Y.exports.__esModule = !0, Y.exports.default = Y.exports;
})(interopRequireDefault);
var interopRequireDefaultExports = interopRequireDefault.exports, regeneratorRuntime$1 = { exports: {} }, _typeof = { exports: {} }, hasRequired_typeof;
function require_typeof() {
  return hasRequired_typeof || (hasRequired_typeof = 1, function(Y) {
    function X(ee) {
      "@babel/helpers - typeof";
      return Y.exports = X = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(te) {
        return typeof te;
      } : function(te) {
        return te && typeof Symbol == "function" && te.constructor === Symbol && te !== Symbol.prototype ? "symbol" : typeof te;
      }, Y.exports.__esModule = !0, Y.exports.default = Y.exports, X(ee);
    }
    Y.exports = X, Y.exports.__esModule = !0, Y.exports.default = Y.exports;
  }(_typeof)), _typeof.exports;
}
var hasRequiredRegeneratorRuntime;
function requireRegeneratorRuntime() {
  return hasRequiredRegeneratorRuntime || (hasRequiredRegeneratorRuntime = 1, function(Y) {
    var X = require_typeof().default;
    function ee() {
      Y.exports = ee = function() {
        return ne;
      }, Y.exports.__esModule = !0, Y.exports.default = Y.exports;
      var te, ne = {}, ie = Object.prototype, oe = ie.hasOwnProperty, se = Object.defineProperty || function(Se, ke, ge) {
        Se[ke] = ge.value;
      }, ae = typeof Symbol == "function" ? Symbol : {}, ue = ae.iterator || "@@iterator", le = ae.asyncIterator || "@@asyncIterator", he = ae.toStringTag || "@@toStringTag";
      function me(Se, ke, ge) {
        return Object.defineProperty(Se, ke, {
          value: ge,
          enumerable: !0,
          configurable: !0,
          writable: !0
        }), Se[ke];
      }
      try {
        me({}, "");
      } catch {
        me = function(Se, ke, ge) {
          return Se[ke] = ge;
        };
      }
      function ye(Se, ke, ge, Ae) {
        var Ge = ke && ke.prototype instanceof Fe ? ke : Fe, Xe = Object.create(Ge.prototype), $e = new Ce(Ae || []);
        return se(Xe, "_invoke", {
          value: fe(Se, ge, $e)
        }), Xe;
      }
      function we(Se, ke, ge) {
        try {
          return {
            type: "normal",
            arg: Se.call(ke, ge)
          };
        } catch (Ae) {
          return {
            type: "throw",
            arg: Ae
          };
        }
      }
      ne.wrap = ye;
      var Ee = "suspendedStart", Re = "suspendedYield", Ue = "executing", Me = "completed", De = {};
      function Fe() {
      }
      function Ke() {
      }
      function tt() {
      }
      var rt = {};
      me(rt, ue, function() {
        return this;
      });
      var it = Object.getPrototypeOf, _t = it && it(it(Pe([])));
      _t && _t !== ie && oe.call(_t, ue) && (rt = _t);
      var Dt = tt.prototype = Fe.prototype = Object.create(rt);
      function je(Se) {
        ["next", "throw", "return"].forEach(function(ke) {
          me(Se, ke, function(ge) {
            return this._invoke(ke, ge);
          });
        });
      }
      function ze(Se, ke) {
        function ge(Ge, Xe, $e, Ze) {
          var ot = we(Se[Ge], Se, Xe);
          if (ot.type !== "throw") {
            var ct = ot.arg, At = ct.value;
            return At && X(At) == "object" && oe.call(At, "__await") ? ke.resolve(At.__await).then(function(Tt) {
              ge("next", Tt, $e, Ze);
            }, function(Tt) {
              ge("throw", Tt, $e, Ze);
            }) : ke.resolve(At).then(function(Tt) {
              ct.value = Tt, $e(ct);
            }, function(Tt) {
              return ge("throw", Tt, $e, Ze);
            });
          }
          Ze(ot.arg);
        }
        var Ae;
        se(this, "_invoke", {
          value: function(Ge, Xe) {
            function $e() {
              return new ke(function(Ze, ot) {
                ge(Ge, Xe, Ze, ot);
              });
            }
            return Ae = Ae ? Ae.then($e, $e) : $e();
          }
        });
      }
      function fe(Se, ke, ge) {
        var Ae = Ee;
        return function(Ge, Xe) {
          if (Ae === Ue)
            throw new Error("Generator is already running");
          if (Ae === Me) {
            if (Ge === "throw")
              throw Xe;
            return {
              value: te,
              done: !0
            };
          }
          for (ge.method = Ge, ge.arg = Xe; ; ) {
            var $e = ge.delegate;
            if ($e) {
              var Ze = de($e, ge);
              if (Ze) {
                if (Ze === De)
                  continue;
                return Ze;
              }
            }
            if (ge.method === "next")
              ge.sent = ge._sent = ge.arg;
            else if (ge.method === "throw") {
              if (Ae === Ee)
                throw Ae = Me, ge.arg;
              ge.dispatchException(ge.arg);
            } else
              ge.method === "return" && ge.abrupt("return", ge.arg);
            Ae = Ue;
            var ot = we(Se, ke, ge);
            if (ot.type === "normal") {
              if (Ae = ge.done ? Me : Re, ot.arg === De)
                continue;
              return {
                value: ot.arg,
                done: ge.done
              };
            }
            ot.type === "throw" && (Ae = Me, ge.method = "throw", ge.arg = ot.arg);
          }
        };
      }
      function de(Se, ke) {
        var ge = ke.method, Ae = Se.iterator[ge];
        if (Ae === te)
          return ke.delegate = null, ge === "throw" && Se.iterator.return && (ke.method = "return", ke.arg = te, de(Se, ke), ke.method === "throw") || ge !== "return" && (ke.method = "throw", ke.arg = new TypeError("The iterator does not provide a '" + ge + "' method")), De;
        var Ge = we(Ae, Se.iterator, ke.arg);
        if (Ge.type === "throw")
          return ke.method = "throw", ke.arg = Ge.arg, ke.delegate = null, De;
        var Xe = Ge.arg;
        return Xe ? Xe.done ? (ke[Se.resultName] = Xe.value, ke.next = Se.nextLoc, ke.method !== "return" && (ke.method = "next", ke.arg = te), ke.delegate = null, De) : Xe : (ke.method = "throw", ke.arg = new TypeError("iterator result is not an object"), ke.delegate = null, De);
      }
      function be(Se) {
        var ke = {
          tryLoc: Se[0]
        };
        1 in Se && (ke.catchLoc = Se[1]), 2 in Se && (ke.finallyLoc = Se[2], ke.afterLoc = Se[3]), this.tryEntries.push(ke);
      }
      function Te(Se) {
        var ke = Se.completion || {};
        ke.type = "normal", delete ke.arg, Se.completion = ke;
      }
      function Ce(Se) {
        this.tryEntries = [{
          tryLoc: "root"
        }], Se.forEach(be, this), this.reset(!0);
      }
      function Pe(Se) {
        if (Se || Se === "") {
          var ke = Se[ue];
          if (ke)
            return ke.call(Se);
          if (typeof Se.next == "function")
            return Se;
          if (!isNaN(Se.length)) {
            var ge = -1, Ae = function Ge() {
              for (; ++ge < Se.length; )
                if (oe.call(Se, ge))
                  return Ge.value = Se[ge], Ge.done = !1, Ge;
              return Ge.value = te, Ge.done = !0, Ge;
            };
            return Ae.next = Ae;
          }
        }
        throw new TypeError(X(Se) + " is not iterable");
      }
      return Ke.prototype = tt, se(Dt, "constructor", {
        value: tt,
        configurable: !0
      }), se(tt, "constructor", {
        value: Ke,
        configurable: !0
      }), Ke.displayName = me(tt, he, "GeneratorFunction"), ne.isGeneratorFunction = function(Se) {
        var ke = typeof Se == "function" && Se.constructor;
        return !!ke && (ke === Ke || (ke.displayName || ke.name) === "GeneratorFunction");
      }, ne.mark = function(Se) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(Se, tt) : (Se.__proto__ = tt, me(Se, he, "GeneratorFunction")), Se.prototype = Object.create(Dt), Se;
      }, ne.awrap = function(Se) {
        return {
          __await: Se
        };
      }, je(ze.prototype), me(ze.prototype, le, function() {
        return this;
      }), ne.AsyncIterator = ze, ne.async = function(Se, ke, ge, Ae, Ge) {
        Ge === void 0 && (Ge = Promise);
        var Xe = new ze(ye(Se, ke, ge, Ae), Ge);
        return ne.isGeneratorFunction(ke) ? Xe : Xe.next().then(function($e) {
          return $e.done ? $e.value : Xe.next();
        });
      }, je(Dt), me(Dt, he, "Generator"), me(Dt, ue, function() {
        return this;
      }), me(Dt, "toString", function() {
        return "[object Generator]";
      }), ne.keys = function(Se) {
        var ke = Object(Se), ge = [];
        for (var Ae in ke)
          ge.push(Ae);
        return ge.reverse(), function Ge() {
          for (; ge.length; ) {
            var Xe = ge.pop();
            if (Xe in ke)
              return Ge.value = Xe, Ge.done = !1, Ge;
          }
          return Ge.done = !0, Ge;
        };
      }, ne.values = Pe, Ce.prototype = {
        constructor: Ce,
        reset: function(Se) {
          if (this.prev = 0, this.next = 0, this.sent = this._sent = te, this.done = !1, this.delegate = null, this.method = "next", this.arg = te, this.tryEntries.forEach(Te), !Se)
            for (var ke in this)
              ke.charAt(0) === "t" && oe.call(this, ke) && !isNaN(+ke.slice(1)) && (this[ke] = te);
        },
        stop: function() {
          this.done = !0;
          var Se = this.tryEntries[0].completion;
          if (Se.type === "throw")
            throw Se.arg;
          return this.rval;
        },
        dispatchException: function(Se) {
          if (this.done)
            throw Se;
          var ke = this;
          function ge(ot, ct) {
            return Xe.type = "throw", Xe.arg = Se, ke.next = ot, ct && (ke.method = "next", ke.arg = te), !!ct;
          }
          for (var Ae = this.tryEntries.length - 1; Ae >= 0; --Ae) {
            var Ge = this.tryEntries[Ae], Xe = Ge.completion;
            if (Ge.tryLoc === "root")
              return ge("end");
            if (Ge.tryLoc <= this.prev) {
              var $e = oe.call(Ge, "catchLoc"), Ze = oe.call(Ge, "finallyLoc");
              if ($e && Ze) {
                if (this.prev < Ge.catchLoc)
                  return ge(Ge.catchLoc, !0);
                if (this.prev < Ge.finallyLoc)
                  return ge(Ge.finallyLoc);
              } else if ($e) {
                if (this.prev < Ge.catchLoc)
                  return ge(Ge.catchLoc, !0);
              } else {
                if (!Ze)
                  throw new Error("try statement without catch or finally");
                if (this.prev < Ge.finallyLoc)
                  return ge(Ge.finallyLoc);
              }
            }
          }
        },
        abrupt: function(Se, ke) {
          for (var ge = this.tryEntries.length - 1; ge >= 0; --ge) {
            var Ae = this.tryEntries[ge];
            if (Ae.tryLoc <= this.prev && oe.call(Ae, "finallyLoc") && this.prev < Ae.finallyLoc) {
              var Ge = Ae;
              break;
            }
          }
          Ge && (Se === "break" || Se === "continue") && Ge.tryLoc <= ke && ke <= Ge.finallyLoc && (Ge = null);
          var Xe = Ge ? Ge.completion : {};
          return Xe.type = Se, Xe.arg = ke, Ge ? (this.method = "next", this.next = Ge.finallyLoc, De) : this.complete(Xe);
        },
        complete: function(Se, ke) {
          if (Se.type === "throw")
            throw Se.arg;
          return Se.type === "break" || Se.type === "continue" ? this.next = Se.arg : Se.type === "return" ? (this.rval = this.arg = Se.arg, this.method = "return", this.next = "end") : Se.type === "normal" && ke && (this.next = ke), De;
        },
        finish: function(Se) {
          for (var ke = this.tryEntries.length - 1; ke >= 0; --ke) {
            var ge = this.tryEntries[ke];
            if (ge.finallyLoc === Se)
              return this.complete(ge.completion, ge.afterLoc), Te(ge), De;
          }
        },
        catch: function(Se) {
          for (var ke = this.tryEntries.length - 1; ke >= 0; --ke) {
            var ge = this.tryEntries[ke];
            if (ge.tryLoc === Se) {
              var Ae = ge.completion;
              if (Ae.type === "throw") {
                var Ge = Ae.arg;
                Te(ge);
              }
              return Ge;
            }
          }
          throw new Error("illegal catch attempt");
        },
        delegateYield: function(Se, ke, ge) {
          return this.delegate = {
            iterator: Pe(Se),
            resultName: ke,
            nextLoc: ge
          }, this.method === "next" && (this.arg = te), De;
        }
      }, ne;
    }
    Y.exports = ee, Y.exports.__esModule = !0, Y.exports.default = Y.exports;
  }(regeneratorRuntime$1)), regeneratorRuntime$1.exports;
}
var regenerator, hasRequiredRegenerator;
function requireRegenerator() {
  if (hasRequiredRegenerator)
    return regenerator;
  hasRequiredRegenerator = 1;
  var Y = requireRegeneratorRuntime()();
  regenerator = Y;
  try {
    regeneratorRuntime = Y;
  } catch {
    typeof globalThis == "object" ? globalThis.regeneratorRuntime = Y : Function("r", "regeneratorRuntime = r")(Y);
  }
  return regenerator;
}
var asyncToGenerator = { exports: {} }, hasRequiredAsyncToGenerator;
function requireAsyncToGenerator() {
  return hasRequiredAsyncToGenerator || (hasRequiredAsyncToGenerator = 1, function(Y) {
    function X(te, ne, ie, oe, se, ae, ue) {
      try {
        var le = te[ae](ue), he = le.value;
      } catch (me) {
        ie(me);
        return;
      }
      le.done ? ne(he) : Promise.resolve(he).then(oe, se);
    }
    function ee(te) {
      return function() {
        var ne = this, ie = arguments;
        return new Promise(function(oe, se) {
          var ae = te.apply(ne, ie);
          function ue(he) {
            X(ae, oe, se, ue, le, "next", he);
          }
          function le(he) {
            X(ae, oe, se, ue, le, "throw", he);
          }
          ue(void 0);
        });
      };
    }
    Y.exports = ee, Y.exports.__esModule = !0, Y.exports.default = Y.exports;
  }(asyncToGenerator)), asyncToGenerator.exports;
}
var classCallCheck = { exports: {} }, hasRequiredClassCallCheck;
function requireClassCallCheck() {
  return hasRequiredClassCallCheck || (hasRequiredClassCallCheck = 1, function(Y) {
    function X(ee, te) {
      if (!(ee instanceof te))
        throw new TypeError("Cannot call a class as a function");
    }
    Y.exports = X, Y.exports.__esModule = !0, Y.exports.default = Y.exports;
  }(classCallCheck)), classCallCheck.exports;
}
var createClass = { exports: {} }, toPropertyKey = { exports: {} }, toPrimitive = { exports: {} }, hasRequiredToPrimitive;
function requireToPrimitive() {
  return hasRequiredToPrimitive || (hasRequiredToPrimitive = 1, function(Y) {
    var X = require_typeof().default;
    function ee(te, ne) {
      if (X(te) != "object" || !te)
        return te;
      var ie = te[Symbol.toPrimitive];
      if (ie !== void 0) {
        var oe = ie.call(te, ne || "default");
        if (X(oe) != "object")
          return oe;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (ne === "string" ? String : Number)(te);
    }
    Y.exports = ee, Y.exports.__esModule = !0, Y.exports.default = Y.exports;
  }(toPrimitive)), toPrimitive.exports;
}
var hasRequiredToPropertyKey;
function requireToPropertyKey() {
  return hasRequiredToPropertyKey || (hasRequiredToPropertyKey = 1, function(Y) {
    var X = require_typeof().default, ee = requireToPrimitive();
    function te(ne) {
      var ie = ee(ne, "string");
      return X(ie) == "symbol" ? ie : String(ie);
    }
    Y.exports = te, Y.exports.__esModule = !0, Y.exports.default = Y.exports;
  }(toPropertyKey)), toPropertyKey.exports;
}
var hasRequiredCreateClass;
function requireCreateClass() {
  return hasRequiredCreateClass || (hasRequiredCreateClass = 1, function(Y) {
    var X = requireToPropertyKey();
    function ee(ne, ie) {
      for (var oe = 0; oe < ie.length; oe++) {
        var se = ie[oe];
        se.enumerable = se.enumerable || !1, se.configurable = !0, "value" in se && (se.writable = !0), Object.defineProperty(ne, X(se.key), se);
      }
    }
    function te(ne, ie, oe) {
      return ie && ee(ne.prototype, ie), oe && ee(ne, oe), Object.defineProperty(ne, "prototype", {
        writable: !1
      }), ne;
    }
    Y.exports = te, Y.exports.__esModule = !0, Y.exports.default = Y.exports;
  }(createClass)), createClass.exports;
}
var inherits = { exports: {} }, setPrototypeOf = { exports: {} }, hasRequiredSetPrototypeOf;
function requireSetPrototypeOf() {
  return hasRequiredSetPrototypeOf || (hasRequiredSetPrototypeOf = 1, function(Y) {
    function X(ee, te) {
      return Y.exports = X = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(ne, ie) {
        return ne.__proto__ = ie, ne;
      }, Y.exports.__esModule = !0, Y.exports.default = Y.exports, X(ee, te);
    }
    Y.exports = X, Y.exports.__esModule = !0, Y.exports.default = Y.exports;
  }(setPrototypeOf)), setPrototypeOf.exports;
}
var hasRequiredInherits;
function requireInherits() {
  return hasRequiredInherits || (hasRequiredInherits = 1, function(Y) {
    var X = requireSetPrototypeOf();
    function ee(te, ne) {
      if (typeof ne != "function" && ne !== null)
        throw new TypeError("Super expression must either be null or a function");
      te.prototype = Object.create(ne && ne.prototype, {
        constructor: {
          value: te,
          writable: !0,
          configurable: !0
        }
      }), Object.defineProperty(te, "prototype", {
        writable: !1
      }), ne && X(te, ne);
    }
    Y.exports = ee, Y.exports.__esModule = !0, Y.exports.default = Y.exports;
  }(inherits)), inherits.exports;
}
var possibleConstructorReturn = { exports: {} }, assertThisInitialized = { exports: {} }, hasRequiredAssertThisInitialized;
function requireAssertThisInitialized() {
  return hasRequiredAssertThisInitialized || (hasRequiredAssertThisInitialized = 1, function(Y) {
    function X(ee) {
      if (ee === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return ee;
    }
    Y.exports = X, Y.exports.__esModule = !0, Y.exports.default = Y.exports;
  }(assertThisInitialized)), assertThisInitialized.exports;
}
var hasRequiredPossibleConstructorReturn;
function requirePossibleConstructorReturn() {
  return hasRequiredPossibleConstructorReturn || (hasRequiredPossibleConstructorReturn = 1, function(Y) {
    var X = require_typeof().default, ee = requireAssertThisInitialized();
    function te(ne, ie) {
      if (ie && (X(ie) === "object" || typeof ie == "function"))
        return ie;
      if (ie !== void 0)
        throw new TypeError("Derived constructors may only return object or undefined");
      return ee(ne);
    }
    Y.exports = te, Y.exports.__esModule = !0, Y.exports.default = Y.exports;
  }(possibleConstructorReturn)), possibleConstructorReturn.exports;
}
var getPrototypeOf = { exports: {} }, hasRequiredGetPrototypeOf;
function requireGetPrototypeOf() {
  return hasRequiredGetPrototypeOf || (hasRequiredGetPrototypeOf = 1, function(Y) {
    function X(ee) {
      return Y.exports = X = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(te) {
        return te.__proto__ || Object.getPrototypeOf(te);
      }, Y.exports.__esModule = !0, Y.exports.default = Y.exports, X(ee);
    }
    Y.exports = X, Y.exports.__esModule = !0, Y.exports.default = Y.exports;
  }(getPrototypeOf)), getPrototypeOf.exports;
}
var eventemitter3 = { exports: {} }, hasRequiredEventemitter3;
function requireEventemitter3() {
  return hasRequiredEventemitter3 || (hasRequiredEventemitter3 = 1, function(Y) {
    var X = Object.prototype.hasOwnProperty, ee = "~";
    function te() {
    }
    Object.create && (te.prototype = /* @__PURE__ */ Object.create(null), new te().__proto__ || (ee = !1));
    function ne(ae, ue, le) {
      this.fn = ae, this.context = ue, this.once = le || !1;
    }
    function ie(ae, ue, le, he, me) {
      if (typeof le != "function")
        throw new TypeError("The listener must be a function");
      var ye = new ne(le, he || ae, me), we = ee ? ee + ue : ue;
      return ae._events[we] ? ae._events[we].fn ? ae._events[we] = [ae._events[we], ye] : ae._events[we].push(ye) : (ae._events[we] = ye, ae._eventsCount++), ae;
    }
    function oe(ae, ue) {
      --ae._eventsCount === 0 ? ae._events = new te() : delete ae._events[ue];
    }
    function se() {
      this._events = new te(), this._eventsCount = 0;
    }
    se.prototype.eventNames = function() {
      var ae = [], ue, le;
      if (this._eventsCount === 0)
        return ae;
      for (le in ue = this._events)
        X.call(ue, le) && ae.push(ee ? le.slice(1) : le);
      return Object.getOwnPropertySymbols ? ae.concat(Object.getOwnPropertySymbols(ue)) : ae;
    }, se.prototype.listeners = function(ae) {
      var ue = ee ? ee + ae : ae, le = this._events[ue];
      if (!le)
        return [];
      if (le.fn)
        return [le.fn];
      for (var he = 0, me = le.length, ye = new Array(me); he < me; he++)
        ye[he] = le[he].fn;
      return ye;
    }, se.prototype.listenerCount = function(ae) {
      var ue = ee ? ee + ae : ae, le = this._events[ue];
      return le ? le.fn ? 1 : le.length : 0;
    }, se.prototype.emit = function(ae, ue, le, he, me, ye) {
      var we = ee ? ee + ae : ae;
      if (!this._events[we])
        return !1;
      var Ee = this._events[we], Re = arguments.length, Ue, Me;
      if (Ee.fn) {
        switch (Ee.once && this.removeListener(ae, Ee.fn, void 0, !0), Re) {
          case 1:
            return Ee.fn.call(Ee.context), !0;
          case 2:
            return Ee.fn.call(Ee.context, ue), !0;
          case 3:
            return Ee.fn.call(Ee.context, ue, le), !0;
          case 4:
            return Ee.fn.call(Ee.context, ue, le, he), !0;
          case 5:
            return Ee.fn.call(Ee.context, ue, le, he, me), !0;
          case 6:
            return Ee.fn.call(Ee.context, ue, le, he, me, ye), !0;
        }
        for (Me = 1, Ue = new Array(Re - 1); Me < Re; Me++)
          Ue[Me - 1] = arguments[Me];
        Ee.fn.apply(Ee.context, Ue);
      } else {
        var De = Ee.length, Fe;
        for (Me = 0; Me < De; Me++)
          switch (Ee[Me].once && this.removeListener(ae, Ee[Me].fn, void 0, !0), Re) {
            case 1:
              Ee[Me].fn.call(Ee[Me].context);
              break;
            case 2:
              Ee[Me].fn.call(Ee[Me].context, ue);
              break;
            case 3:
              Ee[Me].fn.call(Ee[Me].context, ue, le);
              break;
            case 4:
              Ee[Me].fn.call(Ee[Me].context, ue, le, he);
              break;
            default:
              if (!Ue)
                for (Fe = 1, Ue = new Array(Re - 1); Fe < Re; Fe++)
                  Ue[Fe - 1] = arguments[Fe];
              Ee[Me].fn.apply(Ee[Me].context, Ue);
          }
      }
      return !0;
    }, se.prototype.on = function(ae, ue, le) {
      return ie(this, ae, ue, le, !1);
    }, se.prototype.once = function(ae, ue, le) {
      return ie(this, ae, ue, le, !0);
    }, se.prototype.removeListener = function(ae, ue, le, he) {
      var me = ee ? ee + ae : ae;
      if (!this._events[me])
        return this;
      if (!ue)
        return oe(this, me), this;
      var ye = this._events[me];
      if (ye.fn)
        ye.fn === ue && (!he || ye.once) && (!le || ye.context === le) && oe(this, me);
      else {
        for (var we = 0, Ee = [], Re = ye.length; we < Re; we++)
          (ye[we].fn !== ue || he && !ye[we].once || le && ye[we].context !== le) && Ee.push(ye[we]);
        Ee.length ? this._events[me] = Ee.length === 1 ? Ee[0] : Ee : oe(this, me);
      }
      return this;
    }, se.prototype.removeAllListeners = function(ae) {
      var ue;
      return ae ? (ue = ee ? ee + ae : ae, this._events[ue] && oe(this, ue)) : (this._events = new te(), this._eventsCount = 0), this;
    }, se.prototype.off = se.prototype.removeListener, se.prototype.addListener = se.prototype.on, se.prefixed = ee, se.EventEmitter = se, Y.exports = se;
  }(eventemitter3)), eventemitter3.exports;
}
var utils = {}, hasRequiredUtils;
function requireUtils() {
  if (hasRequiredUtils)
    return utils;
  hasRequiredUtils = 1;
  var Y = interopRequireDefaultExports;
  Object.defineProperty(utils, "__esModule", {
    value: !0
  }), utils.DefaultDataPack = void 0, utils.createError = ie;
  var X = Y(requireClassCallCheck()), ee = Y(requireCreateClass()), te = /* @__PURE__ */ new Map([[-32e3, "Event not provided"], [-32600, "Invalid Request"], [-32601, "Method not found"], [-32602, "Invalid params"], [-32603, "Internal error"], [-32604, "Params not found"], [-32605, "Method forbidden"], [-32606, "Event forbidden"], [-32700, "Parse error"]]), ne = /* @__PURE__ */ function() {
    function oe() {
      (0, X.default)(this, oe);
    }
    return (0, ee.default)(oe, [{
      key: "encode",
      value: function(se) {
        return JSON.stringify(se);
      }
    }, {
      key: "decode",
      value: function(se) {
        return JSON.parse(se);
      }
    }]), oe;
  }();
  utils.DefaultDataPack = ne;
  function ie(oe, se) {
    var ae = {
      code: oe,
      message: te.get(oe) || "Internal Server Error"
    };
    return se && (ae.data = se), ae;
  }
  return utils;
}
(function(Y) {
  var X = interopRequireDefaultExports;
  Object.defineProperty(Y, "__esModule", {
    value: !0
  }), Y.default = void 0;
  var ee = X(requireRegenerator()), te = X(requireAsyncToGenerator()), ne = X(require_typeof()), ie = X(requireClassCallCheck()), oe = X(requireCreateClass()), se = X(requireInherits()), ae = X(requirePossibleConstructorReturn()), ue = X(requireGetPrototypeOf()), le = requireEventemitter3(), he = requireUtils();
  function me(Re) {
    var Ue = ye();
    return function() {
      var Me = (0, ue.default)(Re), De;
      if (Ue) {
        var Fe = (0, ue.default)(this).constructor;
        De = Reflect.construct(Me, arguments, Fe);
      } else
        De = Me.apply(this, arguments);
      return (0, ae.default)(this, De);
    };
  }
  function ye() {
    if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
      return !1;
    if (typeof Proxy == "function")
      return !0;
    try {
      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      })), !0;
    } catch {
      return !1;
    }
  }
  var we = function(Re, Ue) {
    var Me = {};
    for (var De in Re)
      Object.prototype.hasOwnProperty.call(Re, De) && Ue.indexOf(De) < 0 && (Me[De] = Re[De]);
    if (Re != null && typeof Object.getOwnPropertySymbols == "function")
      for (var Fe = 0, De = Object.getOwnPropertySymbols(Re); Fe < De.length; Fe++)
        Ue.indexOf(De[Fe]) < 0 && Object.prototype.propertyIsEnumerable.call(Re, De[Fe]) && (Me[De[Fe]] = Re[De[Fe]]);
    return Me;
  }, Ee = /* @__PURE__ */ function(Re) {
    (0, se.default)(Me, Re);
    var Ue = me(Me);
    function Me(De) {
      var Fe, Ke = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "ws://localhost:8080", tt = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, rt = arguments.length > 3 ? arguments[3] : void 0, it = arguments.length > 4 ? arguments[4] : void 0;
      (0, ie.default)(this, Me);
      var _t = tt.autoconnect, Dt = _t === void 0 ? !0 : _t, je = tt.reconnect, ze = je === void 0 ? !0 : je, fe = tt.reconnect_interval, de = fe === void 0 ? 1e3 : fe, be = tt.max_reconnects, Te = be === void 0 ? 5 : be, Ce = we(tt, ["autoconnect", "reconnect", "reconnect_interval", "max_reconnects"]);
      return Fe = Ue.call(this), Fe.webSocketFactory = De, Fe.queue = {}, Fe.rpc_id = 0, Fe.address = Ke, Fe.autoconnect = Dt, Fe.ready = !1, Fe.reconnect = ze, Fe.reconnect_timer_id = void 0, Fe.reconnect_interval = de, Fe.max_reconnects = Te, Fe.rest_options = Ce, Fe.current_reconnects = 0, Fe.generate_request_id = rt || function() {
        return ++Fe.rpc_id;
      }, it ? Fe.dataPack = it : Fe.dataPack = new he.DefaultDataPack(), Fe.autoconnect && Fe._connect(Fe.address, Object.assign({
        autoconnect: Fe.autoconnect,
        reconnect: Fe.reconnect,
        reconnect_interval: Fe.reconnect_interval,
        max_reconnects: Fe.max_reconnects
      }, Fe.rest_options)), Fe;
    }
    return (0, oe.default)(Me, [{
      key: "connect",
      value: function() {
        this.socket || this._connect(this.address, Object.assign({
          autoconnect: this.autoconnect,
          reconnect: this.reconnect,
          reconnect_interval: this.reconnect_interval,
          max_reconnects: this.max_reconnects
        }, this.rest_options));
      }
      /**
       * Calls a registered RPC method on server.
       * @method
       * @param {String} method - RPC method name
       * @param {Object|Array} params - optional method parameters
       * @param {Number} timeout - RPC reply timeout value
       * @param {Object} ws_opts - options passed to ws
       * @return {Promise}
       */
    }, {
      key: "call",
      value: function(De, Fe, Ke, tt) {
        var rt = this;
        return !tt && (0, ne.default)(Ke) === "object" && (tt = Ke, Ke = null), new Promise(function(it, _t) {
          if (!rt.ready)
            return _t(new Error("socket not ready"));
          var Dt = rt.generate_request_id(De, Fe), je = {
            jsonrpc: "2.0",
            method: De,
            params: Fe || void 0,
            id: Dt
          };
          rt.socket.send(rt.dataPack.encode(je), tt, function(ze) {
            if (ze)
              return _t(ze);
            rt.queue[Dt] = {
              promise: [it, _t]
            }, Ke && (rt.queue[Dt].timeout = setTimeout(function() {
              delete rt.queue[Dt], _t(new Error("reply timeout"));
            }, Ke));
          });
        });
      }
      /**
       * Logins with the other side of the connection.
       * @method
       * @param {Object} params - Login credentials object
       * @return {Promise}
       */
    }, {
      key: "login",
      value: function() {
        var De = (0, te.default)(/* @__PURE__ */ ee.default.mark(function Ke(tt) {
          var rt;
          return ee.default.wrap(function(it) {
            for (; ; )
              switch (it.prev = it.next) {
                case 0:
                  return it.next = 2, this.call("rpc.login", tt);
                case 2:
                  if (rt = it.sent, rt) {
                    it.next = 5;
                    break;
                  }
                  throw new Error("authentication failed");
                case 5:
                  return it.abrupt("return", rt);
                case 6:
                case "end":
                  return it.stop();
              }
          }, Ke, this);
        }));
        function Fe(Ke) {
          return De.apply(this, arguments);
        }
        return Fe;
      }()
      /**
       * Fetches a list of client's methods registered on server.
       * @method
       * @return {Array}
       */
    }, {
      key: "listMethods",
      value: function() {
        var De = (0, te.default)(/* @__PURE__ */ ee.default.mark(function Ke() {
          return ee.default.wrap(function(tt) {
            for (; ; )
              switch (tt.prev = tt.next) {
                case 0:
                  return tt.next = 2, this.call("__listMethods");
                case 2:
                  return tt.abrupt("return", tt.sent);
                case 3:
                case "end":
                  return tt.stop();
              }
          }, Ke, this);
        }));
        function Fe() {
          return De.apply(this, arguments);
        }
        return Fe;
      }()
      /**
       * Sends a JSON-RPC 2.0 notification to server.
       * @method
       * @param {String} method - RPC method name
       * @param {Object} params - optional method parameters
       * @return {Promise}
       */
    }, {
      key: "notify",
      value: function(De, Fe) {
        var Ke = this;
        return new Promise(function(tt, rt) {
          if (!Ke.ready)
            return rt(new Error("socket not ready"));
          var it = {
            jsonrpc: "2.0",
            method: De,
            params: Fe
          };
          Ke.socket.send(Ke.dataPack.encode(it), function(_t) {
            if (_t)
              return rt(_t);
            tt();
          });
        });
      }
      /**
       * Subscribes for a defined event.
       * @method
       * @param {String|Array} event - event name
       * @return {Undefined}
       * @throws {Error}
       */
    }, {
      key: "subscribe",
      value: function() {
        var De = (0, te.default)(/* @__PURE__ */ ee.default.mark(function Ke(tt) {
          var rt;
          return ee.default.wrap(function(it) {
            for (; ; )
              switch (it.prev = it.next) {
                case 0:
                  return typeof tt == "string" && (tt = [tt]), it.next = 3, this.call("rpc.on", tt);
                case 3:
                  if (rt = it.sent, !(typeof tt == "string" && rt[tt] !== "ok")) {
                    it.next = 6;
                    break;
                  }
                  throw new Error("Failed subscribing to an event '" + tt + "' with: " + rt[tt]);
                case 6:
                  return it.abrupt("return", rt);
                case 7:
                case "end":
                  return it.stop();
              }
          }, Ke, this);
        }));
        function Fe(Ke) {
          return De.apply(this, arguments);
        }
        return Fe;
      }()
      /**
       * Unsubscribes from a defined event.
       * @method
       * @param {String|Array} event - event name
       * @return {Undefined}
       * @throws {Error}
       */
    }, {
      key: "unsubscribe",
      value: function() {
        var De = (0, te.default)(/* @__PURE__ */ ee.default.mark(function Ke(tt) {
          var rt;
          return ee.default.wrap(function(it) {
            for (; ; )
              switch (it.prev = it.next) {
                case 0:
                  return typeof tt == "string" && (tt = [tt]), it.next = 3, this.call("rpc.off", tt);
                case 3:
                  if (rt = it.sent, !(typeof tt == "string" && rt[tt] !== "ok")) {
                    it.next = 6;
                    break;
                  }
                  throw new Error("Failed unsubscribing from an event with: " + rt);
                case 6:
                  return it.abrupt("return", rt);
                case 7:
                case "end":
                  return it.stop();
              }
          }, Ke, this);
        }));
        function Fe(Ke) {
          return De.apply(this, arguments);
        }
        return Fe;
      }()
      /**
       * Closes a WebSocket connection gracefully.
       * @method
       * @param {Number} code - socket close code
       * @param {String} data - optional data to be sent before closing
       * @return {Undefined}
       */
    }, {
      key: "close",
      value: function(De, Fe) {
        this.socket.close(De || 1e3, Fe);
      }
      /**
       * Connection/Message handler.
       * @method
       * @private
       * @param {String} address - WebSocket API address
       * @param {Object} options - ws options object
       * @return {Undefined}
       */
    }, {
      key: "_connect",
      value: function(De, Fe) {
        var Ke = this;
        clearTimeout(this.reconnect_timer_id), this.socket = this.webSocketFactory(De, Fe), this.socket.addEventListener("open", function() {
          Ke.ready = !0, Ke.emit("open"), Ke.current_reconnects = 0;
        }), this.socket.addEventListener("message", function(tt) {
          var rt = tt.data;
          rt instanceof ArrayBuffer && (rt = Buffer$e.from(rt).toString());
          try {
            rt = Ke.dataPack.decode(rt);
          } catch {
            return;
          }
          if (rt.notification && Ke.listeners(rt.notification).length) {
            if (!Object.keys(rt.params).length)
              return Ke.emit(rt.notification);
            var it = [rt.notification];
            if (rt.params.constructor === Object)
              it.push(rt.params);
            else
              for (var _t = 0; _t < rt.params.length; _t++)
                it.push(rt.params[_t]);
            return Promise.resolve().then(function() {
              Ke.emit.apply(Ke, it);
            });
          }
          if (!Ke.queue[rt.id])
            return rt.method ? Promise.resolve().then(function() {
              Ke.emit(rt.method, rt == null ? void 0 : rt.params);
            }) : void 0;
          "error" in rt == "result" in rt && Ke.queue[rt.id].promise[1](new Error('Server response malformed. Response must include either "result" or "error", but not both.')), Ke.queue[rt.id].timeout && clearTimeout(Ke.queue[rt.id].timeout), rt.error ? Ke.queue[rt.id].promise[1](rt.error) : Ke.queue[rt.id].promise[0](rt.result), delete Ke.queue[rt.id];
        }), this.socket.addEventListener("error", function(tt) {
          return Ke.emit("error", tt);
        }), this.socket.addEventListener("close", function(tt) {
          var rt = tt.code, it = tt.reason;
          Ke.ready && setTimeout(function() {
            return Ke.emit("close", rt, it);
          }, 0), Ke.ready = !1, Ke.socket = void 0, rt !== 1e3 && (Ke.current_reconnects++, Ke.reconnect && (Ke.max_reconnects > Ke.current_reconnects || Ke.max_reconnects === 0) && (Ke.reconnect_timer_id = setTimeout(function() {
            return Ke._connect(De, Fe);
          }, Ke.reconnect_interval)));
        });
      }
    }]), Me;
  }(le.EventEmitter);
  Y.default = Ee;
})(client);
const RpcWebSocketCommonClient = /* @__PURE__ */ getDefaultExportFromCjs$2(client);
var websocket_browser = {};
(function(Y) {
  var X = interopRequireDefaultExports;
  Object.defineProperty(Y, "__esModule", {
    value: !0
  }), Y.default = he;
  var ee = X(requireClassCallCheck()), te = X(requireCreateClass()), ne = X(requireInherits()), ie = X(requirePossibleConstructorReturn()), oe = X(requireGetPrototypeOf()), se = requireEventemitter3();
  function ae(me) {
    var ye = ue();
    return function() {
      var we = (0, oe.default)(me), Ee;
      if (ye) {
        var Re = (0, oe.default)(this).constructor;
        Ee = Reflect.construct(we, arguments, Re);
      } else
        Ee = we.apply(this, arguments);
      return (0, ie.default)(this, Ee);
    };
  }
  function ue() {
    if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
      return !1;
    if (typeof Proxy == "function")
      return !0;
    try {
      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      })), !0;
    } catch {
      return !1;
    }
  }
  var le = /* @__PURE__ */ function(me) {
    (0, ne.default)(we, me);
    var ye = ae(we);
    function we(Ee, Re, Ue) {
      var Me;
      return (0, ee.default)(this, we), Me = ye.call(this), Me.socket = new window.WebSocket(Ee, Ue), Me.socket.onopen = function() {
        return Me.emit("open");
      }, Me.socket.onmessage = function(De) {
        return Me.emit("message", De.data);
      }, Me.socket.onerror = function(De) {
        return Me.emit("error", De);
      }, Me.socket.onclose = function(De) {
        Me.emit("close", De.code, De.reason);
      }, Me;
    }
    return (0, te.default)(we, [{
      key: "send",
      value: function(Ee, Re, Ue) {
        var Me = Ue || Re;
        try {
          this.socket.send(Ee), Me();
        } catch (De) {
          Me(De);
        }
      }
      /**
       * Closes an underlying socket
       * @method
       * @param {Number} code - status code explaining why the connection is being closed
       * @param {String} reason - a description why the connection is closing
       * @return {Undefined}
       * @throws {Error}
       */
    }, {
      key: "close",
      value: function(Ee, Re) {
        this.socket.close(Ee, Re);
      }
    }, {
      key: "addEventListener",
      value: function(Ee, Re, Ue) {
        this.socket.addEventListener(Ee, Re, Ue);
      }
    }]), we;
  }(se.EventEmitter);
  function he(me, ye) {
    return new le(me, ye);
  }
})(websocket_browser);
const createRpc = /* @__PURE__ */ getDefaultExportFromCjs$2(websocket_browser);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function validatePointOpts(Y) {
  const X = validateBasic(Y);
  validateObject(X, {
    a: "field",
    b: "field"
  }, {
    allowedPrivateKeyLengths: "array",
    wrapPrivateKey: "boolean",
    isTorsionFree: "function",
    clearCofactor: "function",
    allowInfinityPoint: "boolean",
    fromBytes: "function",
    toBytes: "function"
  });
  const { endo: ee, Fp: te, a: ne } = X;
  if (ee) {
    if (!te.eql(ne, te.ZERO))
      throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
    if (typeof ee != "object" || typeof ee.beta != "bigint" || typeof ee.splitScalar != "function")
      throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
  }
  return Object.freeze({ ...X });
}
const { bytesToNumberBE: b2n, hexToBytes: h2b } = ut, DER = {
  // asn.1 DER encoding utils
  Err: class extends Error {
    constructor(Y = "") {
      super(Y);
    }
  },
  _parseInt(Y) {
    const { Err: X } = DER;
    if (Y.length < 2 || Y[0] !== 2)
      throw new X("Invalid signature integer tag");
    const ee = Y[1], te = Y.subarray(2, ee + 2);
    if (!ee || te.length !== ee)
      throw new X("Invalid signature integer: wrong length");
    if (te[0] & 128)
      throw new X("Invalid signature integer: negative");
    if (te[0] === 0 && !(te[1] & 128))
      throw new X("Invalid signature integer: unnecessary leading zero");
    return { d: b2n(te), l: Y.subarray(ee + 2) };
  },
  toSig(Y) {
    const { Err: X } = DER, ee = typeof Y == "string" ? h2b(Y) : Y;
    if (!isBytes(ee))
      throw new Error("ui8a expected");
    let te = ee.length;
    if (te < 2 || ee[0] != 48)
      throw new X("Invalid signature tag");
    if (ee[1] !== te - 2)
      throw new X("Invalid signature: incorrect length");
    const { d: ne, l: ie } = DER._parseInt(ee.subarray(2)), { d: oe, l: se } = DER._parseInt(ie);
    if (se.length)
      throw new X("Invalid signature: left bytes after parsing");
    return { r: ne, s: oe };
  },
  hexFromSig(Y) {
    const X = (ue) => Number.parseInt(ue[0], 16) & 8 ? "00" + ue : ue, ee = (ue) => {
      const le = ue.toString(16);
      return le.length & 1 ? `0${le}` : le;
    }, te = X(ee(Y.s)), ne = X(ee(Y.r)), ie = te.length / 2, oe = ne.length / 2, se = ee(ie), ae = ee(oe);
    return `30${ee(oe + ie + 4)}02${ae}${ne}02${se}${te}`;
  }
}, _0n = BigInt(0), _1n$1 = BigInt(1);
BigInt(2);
const _3n = BigInt(3);
BigInt(4);
function weierstrassPoints(Y) {
  const X = validatePointOpts(Y), { Fp: ee } = X, te = X.toBytes || ((we, Ee, Re) => {
    const Ue = Ee.toAffine();
    return concatBytes(Uint8Array.from([4]), ee.toBytes(Ue.x), ee.toBytes(Ue.y));
  }), ne = X.fromBytes || ((we) => {
    const Ee = we.subarray(1), Re = ee.fromBytes(Ee.subarray(0, ee.BYTES)), Ue = ee.fromBytes(Ee.subarray(ee.BYTES, 2 * ee.BYTES));
    return { x: Re, y: Ue };
  });
  function ie(we) {
    const { a: Ee, b: Re } = X, Ue = ee.sqr(we), Me = ee.mul(Ue, we);
    return ee.add(ee.add(Me, ee.mul(we, Ee)), Re);
  }
  if (!ee.eql(ee.sqr(X.Gy), ie(X.Gx)))
    throw new Error("bad generator point: equation left != right");
  function oe(we) {
    return typeof we == "bigint" && _0n < we && we < X.n;
  }
  function se(we) {
    if (!oe(we))
      throw new Error("Expected valid bigint: 0 < bigint < curve.n");
  }
  function ae(we) {
    const { allowedPrivateKeyLengths: Ee, nByteLength: Re, wrapPrivateKey: Ue, n: Me } = X;
    if (Ee && typeof we != "bigint") {
      if (isBytes(we) && (we = bytesToHex(we)), typeof we != "string" || !Ee.includes(we.length))
        throw new Error("Invalid key");
      we = we.padStart(Re * 2, "0");
    }
    let De;
    try {
      De = typeof we == "bigint" ? we : bytesToNumberBE(ensureBytes("private key", we, Re));
    } catch {
      throw new Error(`private key must be ${Re} bytes, hex or bigint, not ${typeof we}`);
    }
    return Ue && (De = mod(De, Me)), se(De), De;
  }
  const ue = /* @__PURE__ */ new Map();
  function le(we) {
    if (!(we instanceof he))
      throw new Error("ProjectivePoint expected");
  }
  class he {
    constructor(Ee, Re, Ue) {
      if (this.px = Ee, this.py = Re, this.pz = Ue, Ee == null || !ee.isValid(Ee))
        throw new Error("x required");
      if (Re == null || !ee.isValid(Re))
        throw new Error("y required");
      if (Ue == null || !ee.isValid(Ue))
        throw new Error("z required");
    }
    // Does not validate if the point is on-curve.
    // Use fromHex instead, or call assertValidity() later.
    static fromAffine(Ee) {
      const { x: Re, y: Ue } = Ee || {};
      if (!Ee || !ee.isValid(Re) || !ee.isValid(Ue))
        throw new Error("invalid affine point");
      if (Ee instanceof he)
        throw new Error("projective point not allowed");
      const Me = (De) => ee.eql(De, ee.ZERO);
      return Me(Re) && Me(Ue) ? he.ZERO : new he(Re, Ue, ee.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     * Takes a bunch of Projective Points but executes only one
     * inversion on all of them. Inversion is very slow operation,
     * so this improves performance massively.
     * Optimization: converts a list of projective points to a list of identical points with Z=1.
     */
    static normalizeZ(Ee) {
      const Re = ee.invertBatch(Ee.map((Ue) => Ue.pz));
      return Ee.map((Ue, Me) => Ue.toAffine(Re[Me])).map(he.fromAffine);
    }
    /**
     * Converts hash string or Uint8Array to Point.
     * @param hex short/long ECDSA hex
     */
    static fromHex(Ee) {
      const Re = he.fromAffine(ne(ensureBytes("pointHex", Ee)));
      return Re.assertValidity(), Re;
    }
    // Multiplies generator point by privateKey.
    static fromPrivateKey(Ee) {
      return he.BASE.multiply(ae(Ee));
    }
    // "Private method", don't use it directly
    _setWindowSize(Ee) {
      this._WINDOW_SIZE = Ee, ue.delete(this);
    }
    // A point on curve is valid if it conforms to equation.
    assertValidity() {
      if (this.is0()) {
        if (X.allowInfinityPoint && !ee.is0(this.py))
          return;
        throw new Error("bad point: ZERO");
      }
      const { x: Ee, y: Re } = this.toAffine();
      if (!ee.isValid(Ee) || !ee.isValid(Re))
        throw new Error("bad point: x or y not FE");
      const Ue = ee.sqr(Re), Me = ie(Ee);
      if (!ee.eql(Ue, Me))
        throw new Error("bad point: equation left != right");
      if (!this.isTorsionFree())
        throw new Error("bad point: not in prime-order subgroup");
    }
    hasEvenY() {
      const { y: Ee } = this.toAffine();
      if (ee.isOdd)
        return !ee.isOdd(Ee);
      throw new Error("Field doesn't support isOdd");
    }
    /**
     * Compare one point to another.
     */
    equals(Ee) {
      le(Ee);
      const { px: Re, py: Ue, pz: Me } = this, { px: De, py: Fe, pz: Ke } = Ee, tt = ee.eql(ee.mul(Re, Ke), ee.mul(De, Me)), rt = ee.eql(ee.mul(Ue, Ke), ee.mul(Fe, Me));
      return tt && rt;
    }
    /**
     * Flips point to one corresponding to (x, -y) in Affine coordinates.
     */
    negate() {
      return new he(this.px, ee.neg(this.py), this.pz);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a: Ee, b: Re } = X, Ue = ee.mul(Re, _3n), { px: Me, py: De, pz: Fe } = this;
      let Ke = ee.ZERO, tt = ee.ZERO, rt = ee.ZERO, it = ee.mul(Me, Me), _t = ee.mul(De, De), Dt = ee.mul(Fe, Fe), je = ee.mul(Me, De);
      return je = ee.add(je, je), rt = ee.mul(Me, Fe), rt = ee.add(rt, rt), Ke = ee.mul(Ee, rt), tt = ee.mul(Ue, Dt), tt = ee.add(Ke, tt), Ke = ee.sub(_t, tt), tt = ee.add(_t, tt), tt = ee.mul(Ke, tt), Ke = ee.mul(je, Ke), rt = ee.mul(Ue, rt), Dt = ee.mul(Ee, Dt), je = ee.sub(it, Dt), je = ee.mul(Ee, je), je = ee.add(je, rt), rt = ee.add(it, it), it = ee.add(rt, it), it = ee.add(it, Dt), it = ee.mul(it, je), tt = ee.add(tt, it), Dt = ee.mul(De, Fe), Dt = ee.add(Dt, Dt), it = ee.mul(Dt, je), Ke = ee.sub(Ke, it), rt = ee.mul(Dt, _t), rt = ee.add(rt, rt), rt = ee.add(rt, rt), new he(Ke, tt, rt);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(Ee) {
      le(Ee);
      const { px: Re, py: Ue, pz: Me } = this, { px: De, py: Fe, pz: Ke } = Ee;
      let tt = ee.ZERO, rt = ee.ZERO, it = ee.ZERO;
      const _t = X.a, Dt = ee.mul(X.b, _3n);
      let je = ee.mul(Re, De), ze = ee.mul(Ue, Fe), fe = ee.mul(Me, Ke), de = ee.add(Re, Ue), be = ee.add(De, Fe);
      de = ee.mul(de, be), be = ee.add(je, ze), de = ee.sub(de, be), be = ee.add(Re, Me);
      let Te = ee.add(De, Ke);
      return be = ee.mul(be, Te), Te = ee.add(je, fe), be = ee.sub(be, Te), Te = ee.add(Ue, Me), tt = ee.add(Fe, Ke), Te = ee.mul(Te, tt), tt = ee.add(ze, fe), Te = ee.sub(Te, tt), it = ee.mul(_t, be), tt = ee.mul(Dt, fe), it = ee.add(tt, it), tt = ee.sub(ze, it), it = ee.add(ze, it), rt = ee.mul(tt, it), ze = ee.add(je, je), ze = ee.add(ze, je), fe = ee.mul(_t, fe), be = ee.mul(Dt, be), ze = ee.add(ze, fe), fe = ee.sub(je, fe), fe = ee.mul(_t, fe), be = ee.add(be, fe), je = ee.mul(ze, be), rt = ee.add(rt, je), je = ee.mul(Te, be), tt = ee.mul(de, tt), tt = ee.sub(tt, je), je = ee.mul(de, ze), it = ee.mul(Te, it), it = ee.add(it, je), new he(tt, rt, it);
    }
    subtract(Ee) {
      return this.add(Ee.negate());
    }
    is0() {
      return this.equals(he.ZERO);
    }
    wNAF(Ee) {
      return ye.wNAFCached(this, ue, Ee, (Re) => {
        const Ue = ee.invertBatch(Re.map((Me) => Me.pz));
        return Re.map((Me, De) => Me.toAffine(Ue[De])).map(he.fromAffine);
      });
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(Ee) {
      const Re = he.ZERO;
      if (Ee === _0n)
        return Re;
      if (se(Ee), Ee === _1n$1)
        return this;
      const { endo: Ue } = X;
      if (!Ue)
        return ye.unsafeLadder(this, Ee);
      let { k1neg: Me, k1: De, k2neg: Fe, k2: Ke } = Ue.splitScalar(Ee), tt = Re, rt = Re, it = this;
      for (; De > _0n || Ke > _0n; )
        De & _1n$1 && (tt = tt.add(it)), Ke & _1n$1 && (rt = rt.add(it)), it = it.double(), De >>= _1n$1, Ke >>= _1n$1;
      return Me && (tt = tt.negate()), Fe && (rt = rt.negate()), rt = new he(ee.mul(rt.px, Ue.beta), rt.py, rt.pz), tt.add(rt);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(Ee) {
      se(Ee);
      let Re = Ee, Ue, Me;
      const { endo: De } = X;
      if (De) {
        const { k1neg: Fe, k1: Ke, k2neg: tt, k2: rt } = De.splitScalar(Re);
        let { p: it, f: _t } = this.wNAF(Ke), { p: Dt, f: je } = this.wNAF(rt);
        it = ye.constTimeNegate(Fe, it), Dt = ye.constTimeNegate(tt, Dt), Dt = new he(ee.mul(Dt.px, De.beta), Dt.py, Dt.pz), Ue = it.add(Dt), Me = _t.add(je);
      } else {
        const { p: Fe, f: Ke } = this.wNAF(Re);
        Ue = Fe, Me = Ke;
      }
      return he.normalizeZ([Ue, Me])[0];
    }
    /**
     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
     * Not using Strauss-Shamir trick: precomputation tables are faster.
     * The trick could be useful if both P and Q are not G (not in our case).
     * @returns non-zero affine point
     */
    multiplyAndAddUnsafe(Ee, Re, Ue) {
      const Me = he.BASE, De = (Ke, tt) => tt === _0n || tt === _1n$1 || !Ke.equals(Me) ? Ke.multiplyUnsafe(tt) : Ke.multiply(tt), Fe = De(this, Re).add(De(Ee, Ue));
      return Fe.is0() ? void 0 : Fe;
    }
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (x, y, z)  (x=x/z, y=y/z)
    toAffine(Ee) {
      const { px: Re, py: Ue, pz: Me } = this, De = this.is0();
      Ee == null && (Ee = De ? ee.ONE : ee.inv(Me));
      const Fe = ee.mul(Re, Ee), Ke = ee.mul(Ue, Ee), tt = ee.mul(Me, Ee);
      if (De)
        return { x: ee.ZERO, y: ee.ZERO };
      if (!ee.eql(tt, ee.ONE))
        throw new Error("invZ was invalid");
      return { x: Fe, y: Ke };
    }
    isTorsionFree() {
      const { h: Ee, isTorsionFree: Re } = X;
      if (Ee === _1n$1)
        return !0;
      if (Re)
        return Re(he, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: Ee, clearCofactor: Re } = X;
      return Ee === _1n$1 ? this : Re ? Re(he, this) : this.multiplyUnsafe(X.h);
    }
    toRawBytes(Ee = !0) {
      return this.assertValidity(), te(he, this, Ee);
    }
    toHex(Ee = !0) {
      return bytesToHex(this.toRawBytes(Ee));
    }
  }
  he.BASE = new he(X.Gx, X.Gy, ee.ONE), he.ZERO = new he(ee.ZERO, ee.ONE, ee.ZERO);
  const me = X.nBitLength, ye = wNAF(he, X.endo ? Math.ceil(me / 2) : me);
  return {
    CURVE: X,
    ProjectivePoint: he,
    normPrivateKeyToScalar: ae,
    weierstrassEquation: ie,
    isWithinCurveOrder: oe
  };
}
function validateOpts(Y) {
  const X = validateBasic(Y);
  return validateObject(X, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  }), Object.freeze({ lowS: !0, ...X });
}
function weierstrass(Y) {
  const X = validateOpts(Y), { Fp: ee, n: te } = X, ne = ee.BYTES + 1, ie = 2 * ee.BYTES + 1;
  function oe(be) {
    return _0n < be && be < ee.ORDER;
  }
  function se(be) {
    return mod(be, te);
  }
  function ae(be) {
    return invert(be, te);
  }
  const { ProjectivePoint: ue, normPrivateKeyToScalar: le, weierstrassEquation: he, isWithinCurveOrder: me } = weierstrassPoints({
    ...X,
    toBytes(be, Te, Ce) {
      const Pe = Te.toAffine(), Se = ee.toBytes(Pe.x), ke = concatBytes;
      return Ce ? ke(Uint8Array.from([Te.hasEvenY() ? 2 : 3]), Se) : ke(Uint8Array.from([4]), Se, ee.toBytes(Pe.y));
    },
    fromBytes(be) {
      const Te = be.length, Ce = be[0], Pe = be.subarray(1);
      if (Te === ne && (Ce === 2 || Ce === 3)) {
        const Se = bytesToNumberBE(Pe);
        if (!oe(Se))
          throw new Error("Point is not on curve");
        const ke = he(Se);
        let ge = ee.sqrt(ke);
        const Ae = (ge & _1n$1) === _1n$1;
        return (Ce & 1) === 1 !== Ae && (ge = ee.neg(ge)), { x: Se, y: ge };
      } else if (Te === ie && Ce === 4) {
        const Se = ee.fromBytes(Pe.subarray(0, ee.BYTES)), ke = ee.fromBytes(Pe.subarray(ee.BYTES, 2 * ee.BYTES));
        return { x: Se, y: ke };
      } else
        throw new Error(`Point of length ${Te} was invalid. Expected ${ne} compressed bytes or ${ie} uncompressed bytes`);
    }
  }), ye = (be) => bytesToHex(numberToBytesBE(be, X.nByteLength));
  function we(be) {
    const Te = te >> _1n$1;
    return be > Te;
  }
  function Ee(be) {
    return we(be) ? se(-be) : be;
  }
  const Re = (be, Te, Ce) => bytesToNumberBE(be.slice(Te, Ce));
  class Ue {
    constructor(Te, Ce, Pe) {
      this.r = Te, this.s = Ce, this.recovery = Pe, this.assertValidity();
    }
    // pair (bytes of r, bytes of s)
    static fromCompact(Te) {
      const Ce = X.nByteLength;
      return Te = ensureBytes("compactSignature", Te, Ce * 2), new Ue(Re(Te, 0, Ce), Re(Te, Ce, 2 * Ce));
    }
    // DER encoded ECDSA signature
    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
    static fromDER(Te) {
      const { r: Ce, s: Pe } = DER.toSig(ensureBytes("DER", Te));
      return new Ue(Ce, Pe);
    }
    assertValidity() {
      if (!me(this.r))
        throw new Error("r must be 0 < r < CURVE.n");
      if (!me(this.s))
        throw new Error("s must be 0 < s < CURVE.n");
    }
    addRecoveryBit(Te) {
      return new Ue(this.r, this.s, Te);
    }
    recoverPublicKey(Te) {
      const { r: Ce, s: Pe, recovery: Se } = this, ke = rt(ensureBytes("msgHash", Te));
      if (Se == null || ![0, 1, 2, 3].includes(Se))
        throw new Error("recovery id invalid");
      const ge = Se === 2 || Se === 3 ? Ce + X.n : Ce;
      if (ge >= ee.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const Ae = Se & 1 ? "03" : "02", Ge = ue.fromHex(Ae + ye(ge)), Xe = ae(ge), $e = se(-ke * Xe), Ze = se(Pe * Xe), ot = ue.BASE.multiplyAndAddUnsafe(Ge, $e, Ze);
      if (!ot)
        throw new Error("point at infinify");
      return ot.assertValidity(), ot;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return we(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new Ue(this.r, se(-this.s), this.recovery) : this;
    }
    // DER-encoded
    toDERRawBytes() {
      return hexToBytes(this.toDERHex());
    }
    toDERHex() {
      return DER.hexFromSig({ r: this.r, s: this.s });
    }
    // padded bytes of r, then padded bytes of s
    toCompactRawBytes() {
      return hexToBytes(this.toCompactHex());
    }
    toCompactHex() {
      return ye(this.r) + ye(this.s);
    }
  }
  const Me = {
    isValidPrivateKey(be) {
      try {
        return le(be), !0;
      } catch {
        return !1;
      }
    },
    normPrivateKeyToScalar: le,
    /**
     * Produces cryptographically secure private key from random of size
     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
     */
    randomPrivateKey: () => {
      const be = getMinHashLength(X.n);
      return mapHashToField(X.randomBytes(be), X.n);
    },
    /**
     * Creates precompute table for an arbitrary EC point. Makes point "cached".
     * Allows to massively speed-up `point.multiply(scalar)`.
     * @returns cached point
     * @example
     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
     * fast.multiply(privKey); // much faster ECDH now
     */
    precompute(be = 8, Te = ue.BASE) {
      return Te._setWindowSize(be), Te.multiply(BigInt(3)), Te;
    }
  };
  function De(be, Te = !0) {
    return ue.fromPrivateKey(be).toRawBytes(Te);
  }
  function Fe(be) {
    const Te = isBytes(be), Ce = typeof be == "string", Pe = (Te || Ce) && be.length;
    return Te ? Pe === ne || Pe === ie : Ce ? Pe === 2 * ne || Pe === 2 * ie : be instanceof ue;
  }
  function Ke(be, Te, Ce = !0) {
    if (Fe(be))
      throw new Error("first arg must be private key");
    if (!Fe(Te))
      throw new Error("second arg must be public key");
    return ue.fromHex(Te).multiply(le(be)).toRawBytes(Ce);
  }
  const tt = X.bits2int || function(be) {
    const Te = bytesToNumberBE(be), Ce = be.length * 8 - X.nBitLength;
    return Ce > 0 ? Te >> BigInt(Ce) : Te;
  }, rt = X.bits2int_modN || function(be) {
    return se(tt(be));
  }, it = bitMask(X.nBitLength);
  function _t(be) {
    if (typeof be != "bigint")
      throw new Error("bigint expected");
    if (!(_0n <= be && be < it))
      throw new Error(`bigint expected < 2^${X.nBitLength}`);
    return numberToBytesBE(be, X.nByteLength);
  }
  function Dt(be, Te, Ce = je) {
    if (["recovered", "canonical"].some((At) => At in Ce))
      throw new Error("sign() legacy options not supported");
    const { hash: Pe, randomBytes: Se } = X;
    let { lowS: ke, prehash: ge, extraEntropy: Ae } = Ce;
    ke == null && (ke = !0), be = ensureBytes("msgHash", be), ge && (be = ensureBytes("prehashed msgHash", Pe(be)));
    const Ge = rt(be), Xe = le(Te), $e = [_t(Xe), _t(Ge)];
    if (Ae != null) {
      const At = Ae === !0 ? Se(ee.BYTES) : Ae;
      $e.push(ensureBytes("extraEntropy", At));
    }
    const Ze = concatBytes(...$e), ot = Ge;
    function ct(At) {
      const Tt = tt(At);
      if (!me(Tt))
        return;
      const dt = ae(Tt), vt = ue.BASE.multiply(Tt).toAffine(), Ut = se(vt.x);
      if (Ut === _0n)
        return;
      const It = se(dt * se(ot + Ut * Xe));
      if (It === _0n)
        return;
      let Er = (vt.x === Ut ? 0 : 2) | Number(vt.y & _1n$1), Fr = It;
      return ke && we(It) && (Fr = Ee(It), Er ^= 1), new Ue(Ut, Fr, Er);
    }
    return { seed: Ze, k2sig: ct };
  }
  const je = { lowS: X.lowS, prehash: !1 }, ze = { lowS: X.lowS, prehash: !1 };
  function fe(be, Te, Ce = je) {
    const { seed: Pe, k2sig: Se } = Dt(be, Te, Ce), ke = X;
    return createHmacDrbg(ke.hash.outputLen, ke.nByteLength, ke.hmac)(Pe, Se);
  }
  ue.BASE._setWindowSize(8);
  function de(be, Te, Ce, Pe = ze) {
    var Se;
    const ke = be;
    if (Te = ensureBytes("msgHash", Te), Ce = ensureBytes("publicKey", Ce), "strict" in Pe)
      throw new Error("options.strict was renamed to lowS");
    const { lowS: ge, prehash: Ae } = Pe;
    let Ge, Xe;
    try {
      if (typeof ke == "string" || isBytes(ke))
        try {
          Ge = Ue.fromDER(ke);
        } catch (vt) {
          if (!(vt instanceof DER.Err))
            throw vt;
          Ge = Ue.fromCompact(ke);
        }
      else if (typeof ke == "object" && typeof ke.r == "bigint" && typeof ke.s == "bigint") {
        const { r: vt, s: Ut } = ke;
        Ge = new Ue(vt, Ut);
      } else
        throw new Error("PARSE");
      Xe = ue.fromHex(Ce);
    } catch (vt) {
      if (vt.message === "PARSE")
        throw new Error("signature must be Signature instance, Uint8Array or hex string");
      return !1;
    }
    if (ge && Ge.hasHighS())
      return !1;
    Ae && (Te = X.hash(Te));
    const { r: $e, s: Ze } = Ge, ot = rt(Te), ct = ae(Ze), At = se(ot * ct), Tt = se($e * ct), dt = (Se = ue.BASE.multiplyAndAddUnsafe(Xe, At, Tt)) == null ? void 0 : Se.toAffine();
    return dt ? se(dt.x) === $e : !1;
  }
  return {
    CURVE: X,
    getPublicKey: De,
    getSharedSecret: Ke,
    sign: fe,
    verify: de,
    ProjectivePoint: ue,
    Signature: Ue,
    utils: Me
  };
}
class HMAC extends Hash {
  constructor(X, ee) {
    super(), this.finished = !1, this.destroyed = !1, hash(X);
    const te = toBytes(ee);
    if (this.iHash = X.create(), typeof this.iHash.update != "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const ne = this.blockLen, ie = new Uint8Array(ne);
    ie.set(te.length > ne ? X.create().update(te).digest() : te);
    for (let oe = 0; oe < ie.length; oe++)
      ie[oe] ^= 54;
    this.iHash.update(ie), this.oHash = X.create();
    for (let oe = 0; oe < ie.length; oe++)
      ie[oe] ^= 106;
    this.oHash.update(ie), ie.fill(0);
  }
  update(X) {
    return exists(this), this.iHash.update(X), this;
  }
  digestInto(X) {
    exists(this), bytes(X, this.outputLen), this.finished = !0, this.iHash.digestInto(X), this.oHash.update(X), this.oHash.digestInto(X), this.destroy();
  }
  digest() {
    const X = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(X), X;
  }
  _cloneInto(X) {
    X || (X = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: ee, iHash: te, finished: ne, destroyed: ie, blockLen: oe, outputLen: se } = this;
    return X = X, X.finished = ne, X.destroyed = ie, X.blockLen = oe, X.outputLen = se, X.oHash = ee._cloneInto(X.oHash), X.iHash = te._cloneInto(X.iHash), X;
  }
  destroy() {
    this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
  }
}
const hmac = (Y, X, ee) => new HMAC(Y, X).update(ee).digest();
hmac.create = (Y, X) => new HMAC(Y, X);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function getHash(Y) {
  return {
    hash: Y,
    hmac: (X, ...ee) => hmac(Y, X, concatBytes$1(...ee)),
    randomBytes
  };
}
function createCurve(Y, X) {
  const ee = (te) => weierstrass({ ...Y, ...getHash(te) });
  return Object.freeze({ ...ee(X), create: ee });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const secp256k1P = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"), secp256k1N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"), _1n = BigInt(1), _2n = BigInt(2), divNearest = (Y, X) => (Y + X / _2n) / X;
function sqrtMod(Y) {
  const X = secp256k1P, ee = BigInt(3), te = BigInt(6), ne = BigInt(11), ie = BigInt(22), oe = BigInt(23), se = BigInt(44), ae = BigInt(88), ue = Y * Y * Y % X, le = ue * ue * Y % X, he = pow2(le, ee, X) * le % X, me = pow2(he, ee, X) * le % X, ye = pow2(me, _2n, X) * ue % X, we = pow2(ye, ne, X) * ye % X, Ee = pow2(we, ie, X) * we % X, Re = pow2(Ee, se, X) * Ee % X, Ue = pow2(Re, ae, X) * Re % X, Me = pow2(Ue, se, X) * Ee % X, De = pow2(Me, ee, X) * le % X, Fe = pow2(De, oe, X) * we % X, Ke = pow2(Fe, te, X) * ue % X, tt = pow2(Ke, _2n, X);
  if (!Fp.eql(Fp.sqr(tt), Y))
    throw new Error("Cannot find square root");
  return tt;
}
const Fp = Field(secp256k1P, void 0, void 0, { sqrt: sqrtMod }), secp256k1 = createCurve({
  a: BigInt(0),
  // equation params: a, b
  b: BigInt(7),
  // Seem to be rigid: bitcointalk.org/index.php?topic=289795.msg3183975#msg3183975
  Fp,
  // Field's prime: 2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n
  n: secp256k1N,
  // Curve order, total count of valid points in the field
  // Base point (x, y) aka generator point
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  h: BigInt(1),
  // Cofactor
  lowS: !0,
  // Allow only low-S signatures by default in sign() and verify()
  /**
   * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
   * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
   * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
   * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
   */
  endo: {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar: (Y) => {
      const X = secp256k1N, ee = BigInt("0x3086d221a7d46bcde86c90e49284eb15"), te = -_1n * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"), ne = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), ie = ee, oe = BigInt("0x100000000000000000000000000000000"), se = divNearest(ie * Y, X), ae = divNearest(-te * Y, X);
      let ue = mod(Y - se * ee - ae * ne, X), le = mod(-se * te - ae * ie, X);
      const he = ue > oe, me = le > oe;
      if (he && (ue = X - ue), me && (le = X - le), ue > oe || le > oe)
        throw new Error("splitScalar: Endomorphism failed, k=" + Y);
      return { k1neg: he, k1: ue, k2neg: me, k2: le };
    }
  }
}, sha256);
BigInt(0);
secp256k1.ProjectivePoint;
const generateKeypair = () => {
  const Y = ed25519.utils.randomPrivateKey(), X = getPublicKey(Y), ee = new Uint8Array(64);
  return ee.set(Y), ee.set(X, 32), {
    publicKey: X,
    secretKey: ee
  };
}, getPublicKey = ed25519.getPublicKey;
function isOnCurve(Y) {
  try {
    return ed25519.ExtendedPoint.fromHex(Y), !0;
  } catch {
    return !1;
  }
}
const sign = (Y, X) => ed25519.sign(Y, X.slice(0, 32)), verify = ed25519.verify, toBuffer = (Y) => Buffer$1$1.isBuffer(Y) ? Y : Y instanceof Uint8Array ? Buffer$1$1.from(Y.buffer, Y.byteOffset, Y.byteLength) : Buffer$1$1.from(Y);
class Struct {
  constructor(X) {
    Object.assign(this, X);
  }
  encode() {
    return Buffer$1$1.from(serialize_1(SOLANA_SCHEMA, this));
  }
  static decode(X) {
    return deserialize_1(SOLANA_SCHEMA, this, X);
  }
  static decodeUnchecked(X) {
    return deserializeUnchecked_1(SOLANA_SCHEMA, this, X);
  }
}
const SOLANA_SCHEMA = /* @__PURE__ */ new Map();
var _class;
let _Symbol$toStringTag;
const MAX_SEED_LENGTH = 32, PUBLIC_KEY_LENGTH = 32;
function isPublicKeyData(Y) {
  return Y._bn !== void 0;
}
let uniquePublicKeyCounter = 1;
_Symbol$toStringTag = Symbol.toStringTag;
class PublicKey extends Struct {
  /**
   * Create a new PublicKey object
   * @param value ed25519 public key as buffer or base-58 encoded string
   */
  constructor(X) {
    if (super({}), this._bn = void 0, isPublicKeyData(X))
      this._bn = X._bn;
    else {
      if (typeof X == "string") {
        const ee = bs58$3.decode(X);
        if (ee.length != PUBLIC_KEY_LENGTH)
          throw new Error("Invalid public key input");
        this._bn = new BN(ee);
      } else
        this._bn = new BN(X);
      if (this._bn.byteLength() > PUBLIC_KEY_LENGTH)
        throw new Error("Invalid public key input");
    }
  }
  /**
   * Returns a unique PublicKey for tests and benchmarks using a counter
   */
  static unique() {
    const X = new PublicKey(uniquePublicKeyCounter);
    return uniquePublicKeyCounter += 1, new PublicKey(X.toBuffer());
  }
  /**
   * Default public key value. The base58-encoded string representation is all ones (as seen below)
   * The underlying BN number is 32 bytes that are all zeros
   */
  /**
   * Checks if two publicKeys are equal
   */
  equals(X) {
    return this._bn.eq(X._bn);
  }
  /**
   * Return the base-58 representation of the public key
   */
  toBase58() {
    return bs58$3.encode(this.toBytes());
  }
  toJSON() {
    return this.toBase58();
  }
  /**
   * Return the byte array representation of the public key in big endian
   */
  toBytes() {
    const X = this.toBuffer();
    return new Uint8Array(X.buffer, X.byteOffset, X.byteLength);
  }
  /**
   * Return the Buffer representation of the public key in big endian
   */
  toBuffer() {
    const X = this._bn.toArrayLike(Buffer$1$1);
    if (X.length === PUBLIC_KEY_LENGTH)
      return X;
    const ee = Buffer$1$1.alloc(32);
    return X.copy(ee, 32 - X.length), ee;
  }
  get [_Symbol$toStringTag]() {
    return `PublicKey(${this.toString()})`;
  }
  /**
   * Return the base-58 representation of the public key
   */
  toString() {
    return this.toBase58();
  }
  /**
   * Derive a public key from another key, a seed, and a program ID.
   * The program ID will also serve as the owner of the public key, giving
   * it permission to write data to the account.
   */
  /* eslint-disable require-await */
  static async createWithSeed(X, ee, te) {
    const ne = Buffer$1$1.concat([X.toBuffer(), Buffer$1$1.from(ee), te.toBuffer()]), ie = sha256(ne);
    return new PublicKey(ie);
  }
  /**
   * Derive a program address from seeds and a program ID.
   */
  /* eslint-disable require-await */
  static createProgramAddressSync(X, ee) {
    let te = Buffer$1$1.alloc(0);
    X.forEach(function(ie) {
      if (ie.length > MAX_SEED_LENGTH)
        throw new TypeError("Max seed length exceeded");
      te = Buffer$1$1.concat([te, toBuffer(ie)]);
    }), te = Buffer$1$1.concat([te, ee.toBuffer(), Buffer$1$1.from("ProgramDerivedAddress")]);
    const ne = sha256(te);
    if (isOnCurve(ne))
      throw new Error("Invalid seeds, address must fall off the curve");
    return new PublicKey(ne);
  }
  /**
   * Async version of createProgramAddressSync
   * For backwards compatibility
   *
   * @deprecated Use {@link createProgramAddressSync} instead
   */
  /* eslint-disable require-await */
  static async createProgramAddress(X, ee) {
    return this.createProgramAddressSync(X, ee);
  }
  /**
   * Find a valid program address
   *
   * Valid program addresses must fall off the ed25519 curve.  This function
   * iterates a nonce until it finds one that when combined with the seeds
   * results in a valid program address.
   */
  static findProgramAddressSync(X, ee) {
    let te = 255, ne;
    for (; te != 0; ) {
      try {
        const ie = X.concat(Buffer$1$1.from([te]));
        ne = this.createProgramAddressSync(ie, ee);
      } catch (ie) {
        if (ie instanceof TypeError)
          throw ie;
        te--;
        continue;
      }
      return [ne, te];
    }
    throw new Error("Unable to find a viable program address nonce");
  }
  /**
   * Async version of findProgramAddressSync
   * For backwards compatibility
   *
   * @deprecated Use {@link findProgramAddressSync} instead
   */
  static async findProgramAddress(X, ee) {
    return this.findProgramAddressSync(X, ee);
  }
  /**
   * Check that a pubkey is on the ed25519 curve.
   */
  static isOnCurve(X) {
    const ee = new PublicKey(X);
    return isOnCurve(ee.toBytes());
  }
}
_class = PublicKey;
PublicKey.default = new _class("11111111111111111111111111111111");
SOLANA_SCHEMA.set(PublicKey, {
  kind: "struct",
  fields: [["_bn", "u256"]]
});
new PublicKey("BPFLoader1111111111111111111111111111111111");
const PACKET_DATA_SIZE = 1232, VERSION_PREFIX_MASK = 127, SIGNATURE_LENGTH_IN_BYTES = 64;
class TransactionExpiredBlockheightExceededError extends Error {
  constructor(X) {
    super(`Signature ${X} has expired: block height exceeded.`), this.signature = void 0, this.signature = X;
  }
}
Object.defineProperty(TransactionExpiredBlockheightExceededError.prototype, "name", {
  value: "TransactionExpiredBlockheightExceededError"
});
class TransactionExpiredTimeoutError extends Error {
  constructor(X, ee) {
    super(`Transaction was not confirmed in ${ee.toFixed(2)} seconds. It is unknown if it succeeded or failed. Check signature ${X} using the Solana Explorer or CLI tools.`), this.signature = void 0, this.signature = X;
  }
}
Object.defineProperty(TransactionExpiredTimeoutError.prototype, "name", {
  value: "TransactionExpiredTimeoutError"
});
class TransactionExpiredNonceInvalidError extends Error {
  constructor(X) {
    super(`Signature ${X} has expired: the nonce is no longer valid.`), this.signature = void 0, this.signature = X;
  }
}
Object.defineProperty(TransactionExpiredNonceInvalidError.prototype, "name", {
  value: "TransactionExpiredNonceInvalidError"
});
class MessageAccountKeys {
  constructor(X, ee) {
    this.staticAccountKeys = void 0, this.accountKeysFromLookups = void 0, this.staticAccountKeys = X, this.accountKeysFromLookups = ee;
  }
  keySegments() {
    const X = [this.staticAccountKeys];
    return this.accountKeysFromLookups && (X.push(this.accountKeysFromLookups.writable), X.push(this.accountKeysFromLookups.readonly)), X;
  }
  get(X) {
    for (const ee of this.keySegments()) {
      if (X < ee.length)
        return ee[X];
      X -= ee.length;
    }
  }
  get length() {
    return this.keySegments().flat().length;
  }
  compileInstructions(X) {
    if (this.length > 256)
      throw new Error("Account index overflow encountered during compilation");
    const ee = /* @__PURE__ */ new Map();
    this.keySegments().flat().forEach((ne, ie) => {
      ee.set(ne.toBase58(), ie);
    });
    const te = (ne) => {
      const ie = ee.get(ne.toBase58());
      if (ie === void 0)
        throw new Error("Encountered an unknown instruction account key during compilation");
      return ie;
    };
    return X.map((ne) => ({
      programIdIndex: te(ne.programId),
      accountKeyIndexes: ne.keys.map((ie) => te(ie.pubkey)),
      data: ne.data
    }));
  }
}
const publicKey$1 = (Y = "publicKey") => blob$1(32, Y), rustString = (Y = "string") => {
  const X = struct$1([u32("length"), u32("lengthPadding"), blob$1(offset(u32(), -8), "chars")], Y), ee = X.decode.bind(X), te = X.encode.bind(X), ne = X;
  return ne.decode = (ie, oe) => ee(ie, oe).chars.toString(), ne.encode = (ie, oe, se) => {
    const ae = {
      chars: Buffer$1$1.from(ie, "utf8")
    };
    return te(ae, oe, se);
  }, ne.alloc = (ie) => u32().span + u32().span + Buffer$1$1.from(ie, "utf8").length, ne;
}, authorized = (Y = "authorized") => struct$1([publicKey$1("staker"), publicKey$1("withdrawer")], Y), lockup = (Y = "lockup") => struct$1([ns64("unixTimestamp"), ns64("epoch"), publicKey$1("custodian")], Y), voteInit = (Y = "voteInit") => struct$1([publicKey$1("nodePubkey"), publicKey$1("authorizedVoter"), publicKey$1("authorizedWithdrawer"), u8("commission")], Y), voteAuthorizeWithSeedArgs = (Y = "voteAuthorizeWithSeedArgs") => struct$1([u32("voteAuthorizationType"), publicKey$1("currentAuthorityDerivedKeyOwnerPubkey"), rustString("currentAuthorityDerivedKeySeed"), publicKey$1("newAuthorized")], Y);
function getAlloc(Y, X) {
  const ee = (ne) => {
    if (ne.span >= 0)
      return ne.span;
    if (typeof ne.alloc == "function")
      return ne.alloc(X[ne.property]);
    if ("count" in ne && "elementLayout" in ne) {
      const ie = X[ne.property];
      if (Array.isArray(ie))
        return ie.length * ee(ne.elementLayout);
    } else if ("fields" in ne)
      return getAlloc({
        layout: ne
      }, X[ne.property]);
    return 0;
  };
  let te = 0;
  return Y.layout.fields.forEach((ne) => {
    te += ee(ne);
  }), te;
}
function decodeLength(Y) {
  let X = 0, ee = 0;
  for (; ; ) {
    let te = Y.shift();
    if (X |= (te & 127) << ee * 7, ee += 1, !(te & 128))
      break;
  }
  return X;
}
function encodeLength(Y, X) {
  let ee = X;
  for (; ; ) {
    let te = ee & 127;
    if (ee >>= 7, ee == 0) {
      Y.push(te);
      break;
    } else
      te |= 128, Y.push(te);
  }
}
function assert(Y, X) {
  if (!Y)
    throw new Error(X || "Assertion failed");
}
class CompiledKeys {
  constructor(X, ee) {
    this.payer = void 0, this.keyMetaMap = void 0, this.payer = X, this.keyMetaMap = ee;
  }
  static compile(X, ee) {
    const te = /* @__PURE__ */ new Map(), ne = (oe) => {
      const se = oe.toBase58();
      let ae = te.get(se);
      return ae === void 0 && (ae = {
        isSigner: !1,
        isWritable: !1,
        isInvoked: !1
      }, te.set(se, ae)), ae;
    }, ie = ne(ee);
    ie.isSigner = !0, ie.isWritable = !0;
    for (const oe of X) {
      ne(oe.programId).isInvoked = !0;
      for (const se of oe.keys) {
        const ae = ne(se.pubkey);
        ae.isSigner || (ae.isSigner = se.isSigner), ae.isWritable || (ae.isWritable = se.isWritable);
      }
    }
    return new CompiledKeys(ee, te);
  }
  getMessageComponents() {
    const X = [...this.keyMetaMap.entries()];
    assert(X.length <= 256, "Max static account keys length exceeded");
    const ee = X.filter(([, ae]) => ae.isSigner && ae.isWritable), te = X.filter(([, ae]) => ae.isSigner && !ae.isWritable), ne = X.filter(([, ae]) => !ae.isSigner && ae.isWritable), ie = X.filter(([, ae]) => !ae.isSigner && !ae.isWritable), oe = {
      numRequiredSignatures: ee.length + te.length,
      numReadonlySignedAccounts: te.length,
      numReadonlyUnsignedAccounts: ie.length
    };
    {
      assert(ee.length > 0, "Expected at least one writable signer key");
      const [ae] = ee[0];
      assert(ae === this.payer.toBase58(), "Expected first writable signer key to be the fee payer");
    }
    const se = [...ee.map(([ae]) => new PublicKey(ae)), ...te.map(([ae]) => new PublicKey(ae)), ...ne.map(([ae]) => new PublicKey(ae)), ...ie.map(([ae]) => new PublicKey(ae))];
    return [oe, se];
  }
  extractTableLookup(X) {
    const [ee, te] = this.drainKeysFoundInLookupTable(X.state.addresses, (oe) => !oe.isSigner && !oe.isInvoked && oe.isWritable), [ne, ie] = this.drainKeysFoundInLookupTable(X.state.addresses, (oe) => !oe.isSigner && !oe.isInvoked && !oe.isWritable);
    if (!(ee.length === 0 && ne.length === 0))
      return [{
        accountKey: X.key,
        writableIndexes: ee,
        readonlyIndexes: ne
      }, {
        writable: te,
        readonly: ie
      }];
  }
  /** @internal */
  drainKeysFoundInLookupTable(X, ee) {
    const te = new Array(), ne = new Array();
    for (const [ie, oe] of this.keyMetaMap.entries())
      if (ee(oe)) {
        const se = new PublicKey(ie), ae = X.findIndex((ue) => ue.equals(se));
        ae >= 0 && (assert(ae < 256, "Max lookup table index exceeded"), te.push(ae), ne.push(se), this.keyMetaMap.delete(ie));
      }
    return [te, ne];
  }
}
class Message {
  constructor(X) {
    this.header = void 0, this.accountKeys = void 0, this.recentBlockhash = void 0, this.instructions = void 0, this.indexToProgramIds = /* @__PURE__ */ new Map(), this.header = X.header, this.accountKeys = X.accountKeys.map((ee) => new PublicKey(ee)), this.recentBlockhash = X.recentBlockhash, this.instructions = X.instructions, this.instructions.forEach((ee) => this.indexToProgramIds.set(ee.programIdIndex, this.accountKeys[ee.programIdIndex]));
  }
  get version() {
    return "legacy";
  }
  get staticAccountKeys() {
    return this.accountKeys;
  }
  get compiledInstructions() {
    return this.instructions.map((X) => ({
      programIdIndex: X.programIdIndex,
      accountKeyIndexes: X.accounts,
      data: bs58$3.decode(X.data)
    }));
  }
  get addressTableLookups() {
    return [];
  }
  getAccountKeys() {
    return new MessageAccountKeys(this.staticAccountKeys);
  }
  static compile(X) {
    const ee = CompiledKeys.compile(X.instructions, X.payerKey), [te, ne] = ee.getMessageComponents(), ie = new MessageAccountKeys(ne).compileInstructions(X.instructions).map((oe) => ({
      programIdIndex: oe.programIdIndex,
      accounts: oe.accountKeyIndexes,
      data: bs58$3.encode(oe.data)
    }));
    return new Message({
      header: te,
      accountKeys: ne,
      recentBlockhash: X.recentBlockhash,
      instructions: ie
    });
  }
  isAccountSigner(X) {
    return X < this.header.numRequiredSignatures;
  }
  isAccountWritable(X) {
    const ee = this.header.numRequiredSignatures;
    if (X >= this.header.numRequiredSignatures) {
      const te = X - ee, ne = this.accountKeys.length - ee - this.header.numReadonlyUnsignedAccounts;
      return te < ne;
    } else {
      const te = ee - this.header.numReadonlySignedAccounts;
      return X < te;
    }
  }
  isProgramId(X) {
    return this.indexToProgramIds.has(X);
  }
  programIds() {
    return [...this.indexToProgramIds.values()];
  }
  nonProgramIds() {
    return this.accountKeys.filter((X, ee) => !this.isProgramId(ee));
  }
  serialize() {
    const X = this.accountKeys.length;
    let ee = [];
    encodeLength(ee, X);
    const te = this.instructions.map((he) => {
      const {
        accounts: me,
        programIdIndex: ye
      } = he, we = Array.from(bs58$3.decode(he.data));
      let Ee = [];
      encodeLength(Ee, me.length);
      let Re = [];
      return encodeLength(Re, we.length), {
        programIdIndex: ye,
        keyIndicesCount: Buffer$1$1.from(Ee),
        keyIndices: me,
        dataLength: Buffer$1$1.from(Re),
        data: we
      };
    });
    let ne = [];
    encodeLength(ne, te.length);
    let ie = Buffer$1$1.alloc(PACKET_DATA_SIZE);
    Buffer$1$1.from(ne).copy(ie);
    let oe = ne.length;
    te.forEach((he) => {
      const me = struct$1([u8("programIdIndex"), blob$1(he.keyIndicesCount.length, "keyIndicesCount"), seq(u8("keyIndex"), he.keyIndices.length, "keyIndices"), blob$1(he.dataLength.length, "dataLength"), seq(u8("userdatum"), he.data.length, "data")]).encode(he, ie, oe);
      oe += me;
    }), ie = ie.slice(0, oe);
    const se = struct$1([blob$1(1, "numRequiredSignatures"), blob$1(1, "numReadonlySignedAccounts"), blob$1(1, "numReadonlyUnsignedAccounts"), blob$1(ee.length, "keyCount"), seq(publicKey$1("key"), X, "keys"), publicKey$1("recentBlockhash")]), ae = {
      numRequiredSignatures: Buffer$1$1.from([this.header.numRequiredSignatures]),
      numReadonlySignedAccounts: Buffer$1$1.from([this.header.numReadonlySignedAccounts]),
      numReadonlyUnsignedAccounts: Buffer$1$1.from([this.header.numReadonlyUnsignedAccounts]),
      keyCount: Buffer$1$1.from(ee),
      keys: this.accountKeys.map((he) => toBuffer(he.toBytes())),
      recentBlockhash: bs58$3.decode(this.recentBlockhash)
    };
    let ue = Buffer$1$1.alloc(2048);
    const le = se.encode(ae, ue);
    return ie.copy(ue, le), ue.slice(0, le + ie.length);
  }
  /**
   * Decode a compiled message into a Message object.
   */
  static from(X) {
    let ee = [...X];
    const te = ee.shift();
    if (te !== (te & VERSION_PREFIX_MASK))
      throw new Error("Versioned messages must be deserialized with VersionedMessage.deserialize()");
    const ne = ee.shift(), ie = ee.shift(), oe = decodeLength(ee);
    let se = [];
    for (let me = 0; me < oe; me++) {
      const ye = ee.slice(0, PUBLIC_KEY_LENGTH);
      ee = ee.slice(PUBLIC_KEY_LENGTH), se.push(new PublicKey(Buffer$1$1.from(ye)));
    }
    const ae = ee.slice(0, PUBLIC_KEY_LENGTH);
    ee = ee.slice(PUBLIC_KEY_LENGTH);
    const ue = decodeLength(ee);
    let le = [];
    for (let me = 0; me < ue; me++) {
      const ye = ee.shift(), we = decodeLength(ee), Ee = ee.slice(0, we);
      ee = ee.slice(we);
      const Re = decodeLength(ee), Ue = ee.slice(0, Re), Me = bs58$3.encode(Buffer$1$1.from(Ue));
      ee = ee.slice(Re), le.push({
        programIdIndex: ye,
        accounts: Ee,
        data: Me
      });
    }
    const he = {
      header: {
        numRequiredSignatures: te,
        numReadonlySignedAccounts: ne,
        numReadonlyUnsignedAccounts: ie
      },
      recentBlockhash: bs58$3.encode(Buffer$1$1.from(ae)),
      accountKeys: se,
      instructions: le
    };
    return new Message(he);
  }
}
class MessageV0 {
  constructor(X) {
    this.header = void 0, this.staticAccountKeys = void 0, this.recentBlockhash = void 0, this.compiledInstructions = void 0, this.addressTableLookups = void 0, this.header = X.header, this.staticAccountKeys = X.staticAccountKeys, this.recentBlockhash = X.recentBlockhash, this.compiledInstructions = X.compiledInstructions, this.addressTableLookups = X.addressTableLookups;
  }
  get version() {
    return 0;
  }
  get numAccountKeysFromLookups() {
    let X = 0;
    for (const ee of this.addressTableLookups)
      X += ee.readonlyIndexes.length + ee.writableIndexes.length;
    return X;
  }
  getAccountKeys(X) {
    let ee;
    if (X && "accountKeysFromLookups" in X && X.accountKeysFromLookups) {
      if (this.numAccountKeysFromLookups != X.accountKeysFromLookups.writable.length + X.accountKeysFromLookups.readonly.length)
        throw new Error("Failed to get account keys because of a mismatch in the number of account keys from lookups");
      ee = X.accountKeysFromLookups;
    } else if (X && "addressLookupTableAccounts" in X && X.addressLookupTableAccounts)
      ee = this.resolveAddressTableLookups(X.addressLookupTableAccounts);
    else if (this.addressTableLookups.length > 0)
      throw new Error("Failed to get account keys because address table lookups were not resolved");
    return new MessageAccountKeys(this.staticAccountKeys, ee);
  }
  isAccountSigner(X) {
    return X < this.header.numRequiredSignatures;
  }
  isAccountWritable(X) {
    const ee = this.header.numRequiredSignatures, te = this.staticAccountKeys.length;
    if (X >= te) {
      const ne = X - te, ie = this.addressTableLookups.reduce((oe, se) => oe + se.writableIndexes.length, 0);
      return ne < ie;
    } else if (X >= this.header.numRequiredSignatures) {
      const ne = X - ee, ie = te - ee - this.header.numReadonlyUnsignedAccounts;
      return ne < ie;
    } else {
      const ne = ee - this.header.numReadonlySignedAccounts;
      return X < ne;
    }
  }
  resolveAddressTableLookups(X) {
    const ee = {
      writable: [],
      readonly: []
    };
    for (const te of this.addressTableLookups) {
      const ne = X.find((ie) => ie.key.equals(te.accountKey));
      if (!ne)
        throw new Error(`Failed to find address lookup table account for table key ${te.accountKey.toBase58()}`);
      for (const ie of te.writableIndexes)
        if (ie < ne.state.addresses.length)
          ee.writable.push(ne.state.addresses[ie]);
        else
          throw new Error(`Failed to find address for index ${ie} in address lookup table ${te.accountKey.toBase58()}`);
      for (const ie of te.readonlyIndexes)
        if (ie < ne.state.addresses.length)
          ee.readonly.push(ne.state.addresses[ie]);
        else
          throw new Error(`Failed to find address for index ${ie} in address lookup table ${te.accountKey.toBase58()}`);
    }
    return ee;
  }
  static compile(X) {
    const ee = CompiledKeys.compile(X.instructions, X.payerKey), te = new Array(), ne = {
      writable: new Array(),
      readonly: new Array()
    }, ie = X.addressLookupTableAccounts || [];
    for (const ue of ie) {
      const le = ee.extractTableLookup(ue);
      if (le !== void 0) {
        const [he, {
          writable: me,
          readonly: ye
        }] = le;
        te.push(he), ne.writable.push(...me), ne.readonly.push(...ye);
      }
    }
    const [oe, se] = ee.getMessageComponents(), ae = new MessageAccountKeys(se, ne).compileInstructions(X.instructions);
    return new MessageV0({
      header: oe,
      staticAccountKeys: se,
      recentBlockhash: X.recentBlockhash,
      compiledInstructions: ae,
      addressTableLookups: te
    });
  }
  serialize() {
    const X = Array();
    encodeLength(X, this.staticAccountKeys.length);
    const ee = this.serializeInstructions(), te = Array();
    encodeLength(te, this.compiledInstructions.length);
    const ne = this.serializeAddressTableLookups(), ie = Array();
    encodeLength(ie, this.addressTableLookups.length);
    const oe = struct$1([u8("prefix"), struct$1([u8("numRequiredSignatures"), u8("numReadonlySignedAccounts"), u8("numReadonlyUnsignedAccounts")], "header"), blob$1(X.length, "staticAccountKeysLength"), seq(publicKey$1(), this.staticAccountKeys.length, "staticAccountKeys"), publicKey$1("recentBlockhash"), blob$1(te.length, "instructionsLength"), blob$1(ee.length, "serializedInstructions"), blob$1(ie.length, "addressTableLookupsLength"), blob$1(ne.length, "serializedAddressTableLookups")]), se = new Uint8Array(PACKET_DATA_SIZE), ae = oe.encode({
      prefix: 128,
      header: this.header,
      staticAccountKeysLength: new Uint8Array(X),
      staticAccountKeys: this.staticAccountKeys.map((ue) => ue.toBytes()),
      recentBlockhash: bs58$3.decode(this.recentBlockhash),
      instructionsLength: new Uint8Array(te),
      serializedInstructions: ee,
      addressTableLookupsLength: new Uint8Array(ie),
      serializedAddressTableLookups: ne
    }, se);
    return se.slice(0, ae);
  }
  serializeInstructions() {
    let X = 0;
    const ee = new Uint8Array(PACKET_DATA_SIZE);
    for (const te of this.compiledInstructions) {
      const ne = Array();
      encodeLength(ne, te.accountKeyIndexes.length);
      const ie = Array();
      encodeLength(ie, te.data.length);
      const oe = struct$1([u8("programIdIndex"), blob$1(ne.length, "encodedAccountKeyIndexesLength"), seq(u8(), te.accountKeyIndexes.length, "accountKeyIndexes"), blob$1(ie.length, "encodedDataLength"), blob$1(te.data.length, "data")]);
      X += oe.encode({
        programIdIndex: te.programIdIndex,
        encodedAccountKeyIndexesLength: new Uint8Array(ne),
        accountKeyIndexes: te.accountKeyIndexes,
        encodedDataLength: new Uint8Array(ie),
        data: te.data
      }, ee, X);
    }
    return ee.slice(0, X);
  }
  serializeAddressTableLookups() {
    let X = 0;
    const ee = new Uint8Array(PACKET_DATA_SIZE);
    for (const te of this.addressTableLookups) {
      const ne = Array();
      encodeLength(ne, te.writableIndexes.length);
      const ie = Array();
      encodeLength(ie, te.readonlyIndexes.length);
      const oe = struct$1([publicKey$1("accountKey"), blob$1(ne.length, "encodedWritableIndexesLength"), seq(u8(), te.writableIndexes.length, "writableIndexes"), blob$1(ie.length, "encodedReadonlyIndexesLength"), seq(u8(), te.readonlyIndexes.length, "readonlyIndexes")]);
      X += oe.encode({
        accountKey: te.accountKey.toBytes(),
        encodedWritableIndexesLength: new Uint8Array(ne),
        writableIndexes: te.writableIndexes,
        encodedReadonlyIndexesLength: new Uint8Array(ie),
        readonlyIndexes: te.readonlyIndexes
      }, ee, X);
    }
    return ee.slice(0, X);
  }
  static deserialize(X) {
    let ee = [...X];
    const te = ee.shift(), ne = te & VERSION_PREFIX_MASK;
    assert(te !== ne, "Expected versioned message but received legacy message");
    const ie = ne;
    assert(ie === 0, `Expected versioned message with version 0 but found version ${ie}`);
    const oe = {
      numRequiredSignatures: ee.shift(),
      numReadonlySignedAccounts: ee.shift(),
      numReadonlyUnsignedAccounts: ee.shift()
    }, se = [], ae = decodeLength(ee);
    for (let we = 0; we < ae; we++)
      se.push(new PublicKey(ee.splice(0, PUBLIC_KEY_LENGTH)));
    const ue = bs58$3.encode(ee.splice(0, PUBLIC_KEY_LENGTH)), le = decodeLength(ee), he = [];
    for (let we = 0; we < le; we++) {
      const Ee = ee.shift(), Re = decodeLength(ee), Ue = ee.splice(0, Re), Me = decodeLength(ee), De = new Uint8Array(ee.splice(0, Me));
      he.push({
        programIdIndex: Ee,
        accountKeyIndexes: Ue,
        data: De
      });
    }
    const me = decodeLength(ee), ye = [];
    for (let we = 0; we < me; we++) {
      const Ee = new PublicKey(ee.splice(0, PUBLIC_KEY_LENGTH)), Re = decodeLength(ee), Ue = ee.splice(0, Re), Me = decodeLength(ee), De = ee.splice(0, Me);
      ye.push({
        accountKey: Ee,
        writableIndexes: Ue,
        readonlyIndexes: De
      });
    }
    return new MessageV0({
      header: oe,
      staticAccountKeys: se,
      recentBlockhash: ue,
      compiledInstructions: he,
      addressTableLookups: ye
    });
  }
}
let TransactionStatus = /* @__PURE__ */ function(Y) {
  return Y[Y.BLOCKHEIGHT_EXCEEDED = 0] = "BLOCKHEIGHT_EXCEEDED", Y[Y.PROCESSED = 1] = "PROCESSED", Y[Y.TIMED_OUT = 2] = "TIMED_OUT", Y[Y.NONCE_INVALID = 3] = "NONCE_INVALID", Y;
}({});
const DEFAULT_SIGNATURE = Buffer$1$1.alloc(SIGNATURE_LENGTH_IN_BYTES).fill(0);
class TransactionInstruction {
  constructor(X) {
    this.keys = void 0, this.programId = void 0, this.data = Buffer$1$1.alloc(0), this.programId = X.programId, this.keys = X.keys, X.data && (this.data = X.data);
  }
  /**
   * @internal
   */
  toJSON() {
    return {
      keys: this.keys.map(({
        pubkey: X,
        isSigner: ee,
        isWritable: te
      }) => ({
        pubkey: X.toJSON(),
        isSigner: ee,
        isWritable: te
      })),
      programId: this.programId.toJSON(),
      data: [...this.data]
    };
  }
}
class Transaction {
  /**
   * The first (payer) Transaction signature
   *
   * @returns {Buffer | null} Buffer of payer's signature
   */
  get signature() {
    return this.signatures.length > 0 ? this.signatures[0].signature : null;
  }
  /**
   * The transaction fee payer
   */
  // Construct a transaction with a blockhash and lastValidBlockHeight
  // Construct a transaction using a durable nonce
  /**
   * @deprecated `TransactionCtorFields` has been deprecated and will be removed in a future version.
   * Please supply a `TransactionBlockhashCtor` instead.
   */
  /**
   * Construct an empty Transaction
   */
  constructor(X) {
    if (this.signatures = [], this.feePayer = void 0, this.instructions = [], this.recentBlockhash = void 0, this.lastValidBlockHeight = void 0, this.nonceInfo = void 0, this.minNonceContextSlot = void 0, this._message = void 0, this._json = void 0, !!X)
      if (X.feePayer && (this.feePayer = X.feePayer), X.signatures && (this.signatures = X.signatures), Object.prototype.hasOwnProperty.call(X, "nonceInfo")) {
        const {
          minContextSlot: ee,
          nonceInfo: te
        } = X;
        this.minNonceContextSlot = ee, this.nonceInfo = te;
      } else if (Object.prototype.hasOwnProperty.call(X, "lastValidBlockHeight")) {
        const {
          blockhash: ee,
          lastValidBlockHeight: te
        } = X;
        this.recentBlockhash = ee, this.lastValidBlockHeight = te;
      } else {
        const {
          recentBlockhash: ee,
          nonceInfo: te
        } = X;
        te && (this.nonceInfo = te), this.recentBlockhash = ee;
      }
  }
  /**
   * @internal
   */
  toJSON() {
    return {
      recentBlockhash: this.recentBlockhash || null,
      feePayer: this.feePayer ? this.feePayer.toJSON() : null,
      nonceInfo: this.nonceInfo ? {
        nonce: this.nonceInfo.nonce,
        nonceInstruction: this.nonceInfo.nonceInstruction.toJSON()
      } : null,
      instructions: this.instructions.map((X) => X.toJSON()),
      signers: this.signatures.map(({
        publicKey: X
      }) => X.toJSON())
    };
  }
  /**
   * Add one or more instructions to this Transaction
   *
   * @param {Array< Transaction | TransactionInstruction | TransactionInstructionCtorFields >} items - Instructions to add to the Transaction
   */
  add(...X) {
    if (X.length === 0)
      throw new Error("No instructions");
    return X.forEach((ee) => {
      "instructions" in ee ? this.instructions = this.instructions.concat(ee.instructions) : "data" in ee && "programId" in ee && "keys" in ee ? this.instructions.push(ee) : this.instructions.push(new TransactionInstruction(ee));
    }), this;
  }
  /**
   * Compile transaction data
   */
  compileMessage() {
    if (this._message && JSON.stringify(this.toJSON()) === JSON.stringify(this._json))
      return this._message;
    let X, ee;
    if (this.nonceInfo ? (X = this.nonceInfo.nonce, this.instructions[0] != this.nonceInfo.nonceInstruction ? ee = [this.nonceInfo.nonceInstruction, ...this.instructions] : ee = this.instructions) : (X = this.recentBlockhash, ee = this.instructions), !X)
      throw new Error("Transaction recentBlockhash required");
    ee.length < 1 && console.warn("No instructions provided");
    let te;
    if (this.feePayer)
      te = this.feePayer;
    else if (this.signatures.length > 0 && this.signatures[0].publicKey)
      te = this.signatures[0].publicKey;
    else
      throw new Error("Transaction fee payer required");
    for (let Ee = 0; Ee < ee.length; Ee++)
      if (ee[Ee].programId === void 0)
        throw new Error(`Transaction instruction index ${Ee} has undefined program id`);
    const ne = [], ie = [];
    ee.forEach((Ee) => {
      Ee.keys.forEach((Ue) => {
        ie.push({
          ...Ue
        });
      });
      const Re = Ee.programId.toString();
      ne.includes(Re) || ne.push(Re);
    }), ne.forEach((Ee) => {
      ie.push({
        pubkey: new PublicKey(Ee),
        isSigner: !1,
        isWritable: !1
      });
    });
    const oe = [];
    ie.forEach((Ee) => {
      const Re = Ee.pubkey.toString(), Ue = oe.findIndex((Me) => Me.pubkey.toString() === Re);
      Ue > -1 ? (oe[Ue].isWritable = oe[Ue].isWritable || Ee.isWritable, oe[Ue].isSigner = oe[Ue].isSigner || Ee.isSigner) : oe.push(Ee);
    }), oe.sort(function(Ee, Re) {
      if (Ee.isSigner !== Re.isSigner)
        return Ee.isSigner ? -1 : 1;
      if (Ee.isWritable !== Re.isWritable)
        return Ee.isWritable ? -1 : 1;
      const Ue = {
        localeMatcher: "best fit",
        usage: "sort",
        sensitivity: "variant",
        ignorePunctuation: !1,
        numeric: !1,
        caseFirst: "lower"
      };
      return Ee.pubkey.toBase58().localeCompare(Re.pubkey.toBase58(), "en", Ue);
    });
    const se = oe.findIndex((Ee) => Ee.pubkey.equals(te));
    if (se > -1) {
      const [Ee] = oe.splice(se, 1);
      Ee.isSigner = !0, Ee.isWritable = !0, oe.unshift(Ee);
    } else
      oe.unshift({
        pubkey: te,
        isSigner: !0,
        isWritable: !0
      });
    for (const Ee of this.signatures) {
      const Re = oe.findIndex((Ue) => Ue.pubkey.equals(Ee.publicKey));
      if (Re > -1)
        oe[Re].isSigner || (oe[Re].isSigner = !0, console.warn("Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release."));
      else
        throw new Error(`unknown signer: ${Ee.publicKey.toString()}`);
    }
    let ae = 0, ue = 0, le = 0;
    const he = [], me = [];
    oe.forEach(({
      pubkey: Ee,
      isSigner: Re,
      isWritable: Ue
    }) => {
      Re ? (he.push(Ee.toString()), ae += 1, Ue || (ue += 1)) : (me.push(Ee.toString()), Ue || (le += 1));
    });
    const ye = he.concat(me), we = ee.map((Ee) => {
      const {
        data: Re,
        programId: Ue
      } = Ee;
      return {
        programIdIndex: ye.indexOf(Ue.toString()),
        accounts: Ee.keys.map((Me) => ye.indexOf(Me.pubkey.toString())),
        data: bs58$3.encode(Re)
      };
    });
    return we.forEach((Ee) => {
      assert(Ee.programIdIndex >= 0), Ee.accounts.forEach((Re) => assert(Re >= 0));
    }), new Message({
      header: {
        numRequiredSignatures: ae,
        numReadonlySignedAccounts: ue,
        numReadonlyUnsignedAccounts: le
      },
      accountKeys: ye,
      recentBlockhash: X,
      instructions: we
    });
  }
  /**
   * @internal
   */
  _compile() {
    const X = this.compileMessage(), ee = X.accountKeys.slice(0, X.header.numRequiredSignatures);
    return this.signatures.length === ee.length && this.signatures.every((te, ne) => ee[ne].equals(te.publicKey)) || (this.signatures = ee.map((te) => ({
      signature: null,
      publicKey: te
    }))), X;
  }
  /**
   * Get a buffer of the Transaction data that need to be covered by signatures
   */
  serializeMessage() {
    return this._compile().serialize();
  }
  /**
   * Get the estimated fee associated with a transaction
   *
   * @param {Connection} connection Connection to RPC Endpoint.
   *
   * @returns {Promise<number | null>} The estimated fee for the transaction
   */
  async getEstimatedFee(X) {
    return (await X.getFeeForMessage(this.compileMessage())).value;
  }
  /**
   * Specify the public keys which will be used to sign the Transaction.
   * The first signer will be used as the transaction fee payer account.
   *
   * Signatures can be added with either `partialSign` or `addSignature`
   *
   * @deprecated Deprecated since v0.84.0. Only the fee payer needs to be
   * specified and it can be set in the Transaction constructor or with the
   * `feePayer` property.
   */
  setSigners(...X) {
    if (X.length === 0)
      throw new Error("No signers");
    const ee = /* @__PURE__ */ new Set();
    this.signatures = X.filter((te) => {
      const ne = te.toString();
      return ee.has(ne) ? !1 : (ee.add(ne), !0);
    }).map((te) => ({
      signature: null,
      publicKey: te
    }));
  }
  /**
   * Sign the Transaction with the specified signers. Multiple signatures may
   * be applied to a Transaction. The first signature is considered "primary"
   * and is used identify and confirm transactions.
   *
   * If the Transaction `feePayer` is not set, the first signer will be used
   * as the transaction fee payer account.
   *
   * Transaction fields should not be modified after the first call to `sign`,
   * as doing so may invalidate the signature and cause the Transaction to be
   * rejected.
   *
   * The Transaction must be assigned a valid `recentBlockhash` before invoking this method
   *
   * @param {Array<Signer>} signers Array of signers that will sign the transaction
   */
  sign(...X) {
    if (X.length === 0)
      throw new Error("No signers");
    const ee = /* @__PURE__ */ new Set(), te = [];
    for (const ie of X) {
      const oe = ie.publicKey.toString();
      ee.has(oe) || (ee.add(oe), te.push(ie));
    }
    this.signatures = te.map((ie) => ({
      signature: null,
      publicKey: ie.publicKey
    }));
    const ne = this._compile();
    this._partialSign(ne, ...te);
  }
  /**
   * Partially sign a transaction with the specified accounts. All accounts must
   * correspond to either the fee payer or a signer account in the transaction
   * instructions.
   *
   * All the caveats from the `sign` method apply to `partialSign`
   *
   * @param {Array<Signer>} signers Array of signers that will sign the transaction
   */
  partialSign(...X) {
    if (X.length === 0)
      throw new Error("No signers");
    const ee = /* @__PURE__ */ new Set(), te = [];
    for (const ie of X) {
      const oe = ie.publicKey.toString();
      ee.has(oe) || (ee.add(oe), te.push(ie));
    }
    const ne = this._compile();
    this._partialSign(ne, ...te);
  }
  /**
   * @internal
   */
  _partialSign(X, ...ee) {
    const te = X.serialize();
    ee.forEach((ne) => {
      const ie = sign(te, ne.secretKey);
      this._addSignature(ne.publicKey, toBuffer(ie));
    });
  }
  /**
   * Add an externally created signature to a transaction. The public key
   * must correspond to either the fee payer or a signer account in the transaction
   * instructions.
   *
   * @param {PublicKey} pubkey Public key that will be added to the transaction.
   * @param {Buffer} signature An externally created signature to add to the transaction.
   */
  addSignature(X, ee) {
    this._compile(), this._addSignature(X, ee);
  }
  /**
   * @internal
   */
  _addSignature(X, ee) {
    assert(ee.length === 64);
    const te = this.signatures.findIndex((ne) => X.equals(ne.publicKey));
    if (te < 0)
      throw new Error(`unknown signer: ${X.toString()}`);
    this.signatures[te].signature = Buffer$1$1.from(ee);
  }
  /**
   * Verify signatures of a Transaction
   * Optional parameter specifies if we're expecting a fully signed Transaction or a partially signed one.
   * If no boolean is provided, we expect a fully signed Transaction by default.
   *
   * @param {boolean} [requireAllSignatures=true] Require a fully signed Transaction
   */
  verifySignatures(X = !0) {
    return !this._getMessageSignednessErrors(this.serializeMessage(), X);
  }
  /**
   * @internal
   */
  _getMessageSignednessErrors(X, ee) {
    const te = {};
    for (const {
      signature: ne,
      publicKey: ie
    } of this.signatures)
      ne === null ? ee && (te.missing || (te.missing = [])).push(ie) : verify(ne, X, ie.toBytes()) || (te.invalid || (te.invalid = [])).push(ie);
    return te.invalid || te.missing ? te : void 0;
  }
  /**
   * Serialize the Transaction in the wire format.
   *
   * @param {Buffer} [config] Config of transaction.
   *
   * @returns {Buffer} Signature of transaction in wire format.
   */
  serialize(X) {
    const {
      requireAllSignatures: ee,
      verifySignatures: te
    } = Object.assign({
      requireAllSignatures: !0,
      verifySignatures: !0
    }, X), ne = this.serializeMessage();
    if (te) {
      const ie = this._getMessageSignednessErrors(ne, ee);
      if (ie) {
        let oe = "Signature verification failed.";
        throw ie.invalid && (oe += `
Invalid signature for public key${ie.invalid.length === 1 ? "" : "(s)"} [\`${ie.invalid.map((se) => se.toBase58()).join("`, `")}\`].`), ie.missing && (oe += `
Missing signature for public key${ie.missing.length === 1 ? "" : "(s)"} [\`${ie.missing.map((se) => se.toBase58()).join("`, `")}\`].`), new Error(oe);
      }
    }
    return this._serialize(ne);
  }
  /**
   * @internal
   */
  _serialize(X) {
    const {
      signatures: ee
    } = this, te = [];
    encodeLength(te, ee.length);
    const ne = te.length + ee.length * 64 + X.length, ie = Buffer$1$1.alloc(ne);
    return assert(ee.length < 256), Buffer$1$1.from(te).copy(ie, 0), ee.forEach(({
      signature: oe
    }, se) => {
      oe !== null && (assert(oe.length === 64, "signature has invalid length"), Buffer$1$1.from(oe).copy(ie, te.length + se * 64));
    }), X.copy(ie, te.length + ee.length * 64), assert(ie.length <= PACKET_DATA_SIZE, `Transaction too large: ${ie.length} > ${PACKET_DATA_SIZE}`), ie;
  }
  /**
   * Deprecated method
   * @internal
   */
  get keys() {
    return assert(this.instructions.length === 1), this.instructions[0].keys.map((X) => X.pubkey);
  }
  /**
   * Deprecated method
   * @internal
   */
  get programId() {
    return assert(this.instructions.length === 1), this.instructions[0].programId;
  }
  /**
   * Deprecated method
   * @internal
   */
  get data() {
    return assert(this.instructions.length === 1), this.instructions[0].data;
  }
  /**
   * Parse a wire transaction into a Transaction object.
   *
   * @param {Buffer | Uint8Array | Array<number>} buffer Signature of wire Transaction
   *
   * @returns {Transaction} Transaction associated with the signature
   */
  static from(X) {
    let ee = [...X];
    const te = decodeLength(ee);
    let ne = [];
    for (let ie = 0; ie < te; ie++) {
      const oe = ee.slice(0, SIGNATURE_LENGTH_IN_BYTES);
      ee = ee.slice(SIGNATURE_LENGTH_IN_BYTES), ne.push(bs58$3.encode(Buffer$1$1.from(oe)));
    }
    return Transaction.populate(Message.from(ee), ne);
  }
  /**
   * Populate Transaction object from message and signatures
   *
   * @param {Message} message Message of transaction
   * @param {Array<string>} signatures List of signatures to assign to the transaction
   *
   * @returns {Transaction} The populated Transaction
   */
  static populate(X, ee = []) {
    const te = new Transaction();
    return te.recentBlockhash = X.recentBlockhash, X.header.numRequiredSignatures > 0 && (te.feePayer = X.accountKeys[0]), ee.forEach((ne, ie) => {
      const oe = {
        signature: ne == bs58$3.encode(DEFAULT_SIGNATURE) ? null : bs58$3.decode(ne),
        publicKey: X.accountKeys[ie]
      };
      te.signatures.push(oe);
    }), X.instructions.forEach((ne) => {
      const ie = ne.accounts.map((oe) => {
        const se = X.accountKeys[oe];
        return {
          pubkey: se,
          isSigner: te.signatures.some((ae) => ae.publicKey.toString() === se.toString()) || X.isAccountSigner(oe),
          isWritable: X.isAccountWritable(oe)
        };
      });
      te.instructions.push(new TransactionInstruction({
        keys: ie,
        programId: X.accountKeys[ne.programIdIndex],
        data: bs58$3.decode(ne.data)
      }));
    }), te._message = X, te._json = te.toJSON(), te;
  }
}
const NUM_TICKS_PER_SECOND = 160, DEFAULT_TICKS_PER_SLOT = 64, NUM_SLOTS_PER_SECOND = NUM_TICKS_PER_SECOND / DEFAULT_TICKS_PER_SLOT, MS_PER_SLOT = 1e3 / NUM_SLOTS_PER_SECOND;
new PublicKey("SysvarC1ock11111111111111111111111111111111");
new PublicKey("SysvarEpochSchedu1e111111111111111111111111");
new PublicKey("Sysvar1nstructions1111111111111111111111111");
const SYSVAR_RECENT_BLOCKHASHES_PUBKEY = new PublicKey("SysvarRecentB1ockHashes11111111111111111111"), SYSVAR_RENT_PUBKEY = new PublicKey("SysvarRent111111111111111111111111111111111");
new PublicKey("SysvarRewards111111111111111111111111111111");
new PublicKey("SysvarS1otHashes111111111111111111111111111");
new PublicKey("SysvarS1otHistory11111111111111111111111111");
new PublicKey("SysvarStakeHistory1111111111111111111111111");
async function sendAndConfirmTransaction(Y, X, ee, te) {
  const ne = te && {
    skipPreflight: te.skipPreflight,
    preflightCommitment: te.preflightCommitment || te.commitment,
    maxRetries: te.maxRetries,
    minContextSlot: te.minContextSlot
  }, ie = await Y.sendTransaction(X, ee, ne);
  let oe;
  if (X.recentBlockhash != null && X.lastValidBlockHeight != null)
    oe = (await Y.confirmTransaction({
      abortSignal: te == null ? void 0 : te.abortSignal,
      signature: ie,
      blockhash: X.recentBlockhash,
      lastValidBlockHeight: X.lastValidBlockHeight
    }, te && te.commitment)).value;
  else if (X.minNonceContextSlot != null && X.nonceInfo != null) {
    const {
      nonceInstruction: se
    } = X.nonceInfo, ae = se.keys[0].pubkey;
    oe = (await Y.confirmTransaction({
      abortSignal: te == null ? void 0 : te.abortSignal,
      minContextSlot: X.minNonceContextSlot,
      nonceAccountPubkey: ae,
      nonceValue: X.nonceInfo.nonce,
      signature: ie
    }, te && te.commitment)).value;
  } else
    (te == null ? void 0 : te.abortSignal) != null && console.warn("sendAndConfirmTransaction(): A transaction with a deprecated confirmation strategy was supplied along with an `abortSignal`. Only transactions having `lastValidBlockHeight` or a combination of `nonceInfo` and `minNonceContextSlot` are abortable."), oe = (await Y.confirmTransaction(ie, te && te.commitment)).value;
  if (oe.err)
    throw new Error(`Transaction ${ie} failed (${JSON.stringify(oe)})`);
  return ie;
}
function sleep(Y) {
  return new Promise((X) => setTimeout(X, Y));
}
function encodeData(Y, X) {
  const ee = Y.layout.span >= 0 ? Y.layout.span : getAlloc(Y, X), te = Buffer$1$1.alloc(ee), ne = Object.assign({
    instruction: Y.index
  }, X);
  return Y.layout.encode(ne, te), te;
}
const FeeCalculatorLayout = nu64$1("lamportsPerSignature"), NonceAccountLayout = struct$1([u32("version"), u32("state"), publicKey$1("authorizedPubkey"), publicKey$1("nonce"), struct$1([FeeCalculatorLayout], "feeCalculator")]), NONCE_ACCOUNT_LENGTH = NonceAccountLayout.span;
class NonceAccount {
  /**
   * @internal
   */
  constructor(X) {
    this.authorizedPubkey = void 0, this.nonce = void 0, this.feeCalculator = void 0, this.authorizedPubkey = X.authorizedPubkey, this.nonce = X.nonce, this.feeCalculator = X.feeCalculator;
  }
  /**
   * Deserialize NonceAccount from the account data.
   *
   * @param buffer account data
   * @return NonceAccount
   */
  static fromAccountData(X) {
    const ee = NonceAccountLayout.decode(toBuffer(X), 0);
    return new NonceAccount({
      authorizedPubkey: new PublicKey(ee.authorizedPubkey),
      nonce: new PublicKey(ee.nonce).toString(),
      feeCalculator: ee.feeCalculator
    });
  }
}
const encodeDecode$1 = (Y) => {
  const X = Y.decode.bind(Y), ee = Y.encode.bind(Y);
  return {
    decode: X,
    encode: ee
  };
}, bigInt$1 = (Y) => (X) => {
  const ee = blob$1(Y, X), {
    encode: te,
    decode: ne
  } = encodeDecode$1(ee), ie = ee;
  return ie.decode = (oe, se) => {
    const ae = ne(oe, se);
    return toBigIntLE_1(Buffer$1$1.from(ae));
  }, ie.encode = (oe, se, ae) => {
    const ue = toBufferLE_1(oe, Y);
    return te(ue, se, ae);
  }, ie;
}, u64$1 = bigInt$1(8), SYSTEM_INSTRUCTION_LAYOUTS = Object.freeze({
  Create: {
    index: 0,
    layout: struct$1([u32("instruction"), ns64("lamports"), ns64("space"), publicKey$1("programId")])
  },
  Assign: {
    index: 1,
    layout: struct$1([u32("instruction"), publicKey$1("programId")])
  },
  Transfer: {
    index: 2,
    layout: struct$1([u32("instruction"), u64$1("lamports")])
  },
  CreateWithSeed: {
    index: 3,
    layout: struct$1([u32("instruction"), publicKey$1("base"), rustString("seed"), ns64("lamports"), ns64("space"), publicKey$1("programId")])
  },
  AdvanceNonceAccount: {
    index: 4,
    layout: struct$1([u32("instruction")])
  },
  WithdrawNonceAccount: {
    index: 5,
    layout: struct$1([u32("instruction"), ns64("lamports")])
  },
  InitializeNonceAccount: {
    index: 6,
    layout: struct$1([u32("instruction"), publicKey$1("authorized")])
  },
  AuthorizeNonceAccount: {
    index: 7,
    layout: struct$1([u32("instruction"), publicKey$1("authorized")])
  },
  Allocate: {
    index: 8,
    layout: struct$1([u32("instruction"), ns64("space")])
  },
  AllocateWithSeed: {
    index: 9,
    layout: struct$1([u32("instruction"), publicKey$1("base"), rustString("seed"), ns64("space"), publicKey$1("programId")])
  },
  AssignWithSeed: {
    index: 10,
    layout: struct$1([u32("instruction"), publicKey$1("base"), rustString("seed"), publicKey$1("programId")])
  },
  TransferWithSeed: {
    index: 11,
    layout: struct$1([u32("instruction"), u64$1("lamports"), rustString("seed"), publicKey$1("programId")])
  },
  UpgradeNonceAccount: {
    index: 12,
    layout: struct$1([u32("instruction")])
  }
});
class SystemProgram {
  /**
   * @internal
   */
  constructor() {
  }
  /**
   * Public key that identifies the System program
   */
  /**
   * Generate a transaction instruction that creates a new account
   */
  static createAccount(X) {
    const ee = SYSTEM_INSTRUCTION_LAYOUTS.Create, te = encodeData(ee, {
      lamports: X.lamports,
      space: X.space,
      programId: toBuffer(X.programId.toBuffer())
    });
    return new TransactionInstruction({
      keys: [{
        pubkey: X.fromPubkey,
        isSigner: !0,
        isWritable: !0
      }, {
        pubkey: X.newAccountPubkey,
        isSigner: !0,
        isWritable: !0
      }],
      programId: this.programId,
      data: te
    });
  }
  /**
   * Generate a transaction instruction that transfers lamports from one account to another
   */
  static transfer(X) {
    let ee, te;
    if ("basePubkey" in X) {
      const ne = SYSTEM_INSTRUCTION_LAYOUTS.TransferWithSeed;
      ee = encodeData(ne, {
        lamports: BigInt(X.lamports),
        seed: X.seed,
        programId: toBuffer(X.programId.toBuffer())
      }), te = [{
        pubkey: X.fromPubkey,
        isSigner: !1,
        isWritable: !0
      }, {
        pubkey: X.basePubkey,
        isSigner: !0,
        isWritable: !1
      }, {
        pubkey: X.toPubkey,
        isSigner: !1,
        isWritable: !0
      }];
    } else {
      const ne = SYSTEM_INSTRUCTION_LAYOUTS.Transfer;
      ee = encodeData(ne, {
        lamports: BigInt(X.lamports)
      }), te = [{
        pubkey: X.fromPubkey,
        isSigner: !0,
        isWritable: !0
      }, {
        pubkey: X.toPubkey,
        isSigner: !1,
        isWritable: !0
      }];
    }
    return new TransactionInstruction({
      keys: te,
      programId: this.programId,
      data: ee
    });
  }
  /**
   * Generate a transaction instruction that assigns an account to a program
   */
  static assign(X) {
    let ee, te;
    if ("basePubkey" in X) {
      const ne = SYSTEM_INSTRUCTION_LAYOUTS.AssignWithSeed;
      ee = encodeData(ne, {
        base: toBuffer(X.basePubkey.toBuffer()),
        seed: X.seed,
        programId: toBuffer(X.programId.toBuffer())
      }), te = [{
        pubkey: X.accountPubkey,
        isSigner: !1,
        isWritable: !0
      }, {
        pubkey: X.basePubkey,
        isSigner: !0,
        isWritable: !1
      }];
    } else {
      const ne = SYSTEM_INSTRUCTION_LAYOUTS.Assign;
      ee = encodeData(ne, {
        programId: toBuffer(X.programId.toBuffer())
      }), te = [{
        pubkey: X.accountPubkey,
        isSigner: !0,
        isWritable: !0
      }];
    }
    return new TransactionInstruction({
      keys: te,
      programId: this.programId,
      data: ee
    });
  }
  /**
   * Generate a transaction instruction that creates a new account at
   *   an address generated with `from`, a seed, and programId
   */
  static createAccountWithSeed(X) {
    const ee = SYSTEM_INSTRUCTION_LAYOUTS.CreateWithSeed, te = encodeData(ee, {
      base: toBuffer(X.basePubkey.toBuffer()),
      seed: X.seed,
      lamports: X.lamports,
      space: X.space,
      programId: toBuffer(X.programId.toBuffer())
    });
    let ne = [{
      pubkey: X.fromPubkey,
      isSigner: !0,
      isWritable: !0
    }, {
      pubkey: X.newAccountPubkey,
      isSigner: !1,
      isWritable: !0
    }];
    return X.basePubkey != X.fromPubkey && ne.push({
      pubkey: X.basePubkey,
      isSigner: !0,
      isWritable: !1
    }), new TransactionInstruction({
      keys: ne,
      programId: this.programId,
      data: te
    });
  }
  /**
   * Generate a transaction that creates a new Nonce account
   */
  static createNonceAccount(X) {
    const ee = new Transaction();
    "basePubkey" in X && "seed" in X ? ee.add(SystemProgram.createAccountWithSeed({
      fromPubkey: X.fromPubkey,
      newAccountPubkey: X.noncePubkey,
      basePubkey: X.basePubkey,
      seed: X.seed,
      lamports: X.lamports,
      space: NONCE_ACCOUNT_LENGTH,
      programId: this.programId
    })) : ee.add(SystemProgram.createAccount({
      fromPubkey: X.fromPubkey,
      newAccountPubkey: X.noncePubkey,
      lamports: X.lamports,
      space: NONCE_ACCOUNT_LENGTH,
      programId: this.programId
    }));
    const te = {
      noncePubkey: X.noncePubkey,
      authorizedPubkey: X.authorizedPubkey
    };
    return ee.add(this.nonceInitialize(te)), ee;
  }
  /**
   * Generate an instruction to initialize a Nonce account
   */
  static nonceInitialize(X) {
    const ee = SYSTEM_INSTRUCTION_LAYOUTS.InitializeNonceAccount, te = encodeData(ee, {
      authorized: toBuffer(X.authorizedPubkey.toBuffer())
    }), ne = {
      keys: [{
        pubkey: X.noncePubkey,
        isSigner: !1,
        isWritable: !0
      }, {
        pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
        isSigner: !1,
        isWritable: !1
      }, {
        pubkey: SYSVAR_RENT_PUBKEY,
        isSigner: !1,
        isWritable: !1
      }],
      programId: this.programId,
      data: te
    };
    return new TransactionInstruction(ne);
  }
  /**
   * Generate an instruction to advance the nonce in a Nonce account
   */
  static nonceAdvance(X) {
    const ee = SYSTEM_INSTRUCTION_LAYOUTS.AdvanceNonceAccount, te = encodeData(ee), ne = {
      keys: [{
        pubkey: X.noncePubkey,
        isSigner: !1,
        isWritable: !0
      }, {
        pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
        isSigner: !1,
        isWritable: !1
      }, {
        pubkey: X.authorizedPubkey,
        isSigner: !0,
        isWritable: !1
      }],
      programId: this.programId,
      data: te
    };
    return new TransactionInstruction(ne);
  }
  /**
   * Generate a transaction instruction that withdraws lamports from a Nonce account
   */
  static nonceWithdraw(X) {
    const ee = SYSTEM_INSTRUCTION_LAYOUTS.WithdrawNonceAccount, te = encodeData(ee, {
      lamports: X.lamports
    });
    return new TransactionInstruction({
      keys: [{
        pubkey: X.noncePubkey,
        isSigner: !1,
        isWritable: !0
      }, {
        pubkey: X.toPubkey,
        isSigner: !1,
        isWritable: !0
      }, {
        pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
        isSigner: !1,
        isWritable: !1
      }, {
        pubkey: SYSVAR_RENT_PUBKEY,
        isSigner: !1,
        isWritable: !1
      }, {
        pubkey: X.authorizedPubkey,
        isSigner: !0,
        isWritable: !1
      }],
      programId: this.programId,
      data: te
    });
  }
  /**
   * Generate a transaction instruction that authorizes a new PublicKey as the authority
   * on a Nonce account.
   */
  static nonceAuthorize(X) {
    const ee = SYSTEM_INSTRUCTION_LAYOUTS.AuthorizeNonceAccount, te = encodeData(ee, {
      authorized: toBuffer(X.newAuthorizedPubkey.toBuffer())
    });
    return new TransactionInstruction({
      keys: [{
        pubkey: X.noncePubkey,
        isSigner: !1,
        isWritable: !0
      }, {
        pubkey: X.authorizedPubkey,
        isSigner: !0,
        isWritable: !1
      }],
      programId: this.programId,
      data: te
    });
  }
  /**
   * Generate a transaction instruction that allocates space in an account without funding
   */
  static allocate(X) {
    let ee, te;
    if ("basePubkey" in X) {
      const ne = SYSTEM_INSTRUCTION_LAYOUTS.AllocateWithSeed;
      ee = encodeData(ne, {
        base: toBuffer(X.basePubkey.toBuffer()),
        seed: X.seed,
        space: X.space,
        programId: toBuffer(X.programId.toBuffer())
      }), te = [{
        pubkey: X.accountPubkey,
        isSigner: !1,
        isWritable: !0
      }, {
        pubkey: X.basePubkey,
        isSigner: !0,
        isWritable: !1
      }];
    } else {
      const ne = SYSTEM_INSTRUCTION_LAYOUTS.Allocate;
      ee = encodeData(ne, {
        space: X.space
      }), te = [{
        pubkey: X.accountPubkey,
        isSigner: !0,
        isWritable: !0
      }];
    }
    return new TransactionInstruction({
      keys: te,
      programId: this.programId,
      data: ee
    });
  }
}
SystemProgram.programId = new PublicKey("11111111111111111111111111111111");
new PublicKey("BPFLoader2111111111111111111111111111111111");
function getDefaultExportFromCjs(Y) {
  return Y && Y.__esModule && Object.prototype.hasOwnProperty.call(Y, "default") ? Y.default : Y;
}
var objToString = Object.prototype.toString, objKeys = Object.keys || function(Y) {
  var X = [];
  for (var ee in Y)
    X.push(ee);
  return X;
};
function stringify(Y, X) {
  var ee, te, ne, ie, oe, se, ae;
  if (Y === !0)
    return "true";
  if (Y === !1)
    return "false";
  switch (typeof Y) {
    case "object":
      if (Y === null)
        return null;
      if (Y.toJSON && typeof Y.toJSON == "function")
        return stringify(Y.toJSON(), X);
      if (ae = objToString.call(Y), ae === "[object Array]") {
        for (ne = "[", te = Y.length - 1, ee = 0; ee < te; ee++)
          ne += stringify(Y[ee], !0) + ",";
        return te > -1 && (ne += stringify(Y[ee], !0)), ne + "]";
      } else if (ae === "[object Object]") {
        for (ie = objKeys(Y).sort(), te = ie.length, ne = "", ee = 0; ee < te; )
          oe = ie[ee], se = stringify(Y[oe], !1), se !== void 0 && (ne && (ne += ","), ne += JSON.stringify(oe) + ":" + se), ee++;
        return "{" + ne + "}";
      } else
        return JSON.stringify(Y);
    case "function":
    case "undefined":
      return X ? null : void 0;
    case "string":
      return JSON.stringify(Y);
    default:
      return isFinite(Y) ? Y : null;
  }
}
var fastStableStringify = function(Y) {
  var X = stringify(Y, !1);
  if (X !== void 0)
    return "" + X;
}, fastStableStringify$1 = /* @__PURE__ */ getDefaultExportFromCjs(fastStableStringify);
const MINIMUM_SLOT_PER_EPOCH = 32;
function trailingZeros(Y) {
  let X = 0;
  for (; Y > 1; )
    Y /= 2, X++;
  return X;
}
function nextPowerOfTwo(Y) {
  return Y === 0 ? 1 : (Y--, Y |= Y >> 1, Y |= Y >> 2, Y |= Y >> 4, Y |= Y >> 8, Y |= Y >> 16, Y |= Y >> 32, Y + 1);
}
class EpochSchedule {
  constructor(X, ee, te, ne, ie) {
    this.slotsPerEpoch = void 0, this.leaderScheduleSlotOffset = void 0, this.warmup = void 0, this.firstNormalEpoch = void 0, this.firstNormalSlot = void 0, this.slotsPerEpoch = X, this.leaderScheduleSlotOffset = ee, this.warmup = te, this.firstNormalEpoch = ne, this.firstNormalSlot = ie;
  }
  getEpoch(X) {
    return this.getEpochAndSlotIndex(X)[0];
  }
  getEpochAndSlotIndex(X) {
    if (X < this.firstNormalSlot) {
      const ee = trailingZeros(nextPowerOfTwo(X + MINIMUM_SLOT_PER_EPOCH + 1)) - trailingZeros(MINIMUM_SLOT_PER_EPOCH) - 1, te = this.getSlotsInEpoch(ee), ne = X - (te - MINIMUM_SLOT_PER_EPOCH);
      return [ee, ne];
    } else {
      const ee = X - this.firstNormalSlot, te = Math.floor(ee / this.slotsPerEpoch), ne = this.firstNormalEpoch + te, ie = ee % this.slotsPerEpoch;
      return [ne, ie];
    }
  }
  getFirstSlotInEpoch(X) {
    return X <= this.firstNormalEpoch ? (Math.pow(2, X) - 1) * MINIMUM_SLOT_PER_EPOCH : (X - this.firstNormalEpoch) * this.slotsPerEpoch + this.firstNormalSlot;
  }
  getLastSlotInEpoch(X) {
    return this.getFirstSlotInEpoch(X) + this.getSlotsInEpoch(X) - 1;
  }
  getSlotsInEpoch(X) {
    return X < this.firstNormalEpoch ? Math.pow(2, X + trailingZeros(MINIMUM_SLOT_PER_EPOCH)) : this.slotsPerEpoch;
  }
}
class SendTransactionError extends Error {
  constructor(X, ee) {
    super(X), this.logs = void 0, this.logs = ee;
  }
}
class SolanaJSONRPCError extends Error {
  constructor({
    code: X,
    message: ee,
    data: te
  }, ne) {
    super(ne != null ? `${ne}: ${ee}` : ee), this.code = void 0, this.data = void 0, this.code = X, this.data = te, this.name = "SolanaJSONRPCError";
  }
}
var fetchImpl = globalThis.fetch;
class RpcWebSocketClient extends RpcWebSocketCommonClient {
  constructor(X, ee, te) {
    const ne = (ie) => {
      const oe = createRpc(ie, {
        autoconnect: !0,
        max_reconnects: 5,
        reconnect: !0,
        reconnect_interval: 1e3,
        ...ee
      });
      return "socket" in oe ? this.underlyingSocket = oe.socket : this.underlyingSocket = oe, oe;
    };
    super(ne, X, ee, te), this.underlyingSocket = void 0;
  }
  call(...X) {
    var ee;
    const te = (ee = this.underlyingSocket) == null ? void 0 : ee.readyState;
    return te === 1 ? super.call(...X) : Promise.reject(new Error("Tried to call a JSON-RPC method `" + X[0] + "` but the socket was not `CONNECTING` or `OPEN` (`readyState` was " + te + ")"));
  }
  notify(...X) {
    var ee;
    const te = (ee = this.underlyingSocket) == null ? void 0 : ee.readyState;
    return te === 1 ? super.notify(...X) : Promise.reject(new Error("Tried to send a JSON-RPC notification `" + X[0] + "` but the socket was not `CONNECTING` or `OPEN` (`readyState` was " + te + ")"));
  }
}
function decodeData(Y, X) {
  let ee;
  try {
    ee = Y.layout.decode(X);
  } catch (te) {
    throw new Error("invalid instruction; " + te);
  }
  if (ee.typeIndex !== Y.index)
    throw new Error(`invalid account data; account type mismatch ${ee.typeIndex} != ${Y.index}`);
  return ee;
}
const LOOKUP_TABLE_META_SIZE = 56;
class AddressLookupTableAccount {
  constructor(X) {
    this.key = void 0, this.state = void 0, this.key = X.key, this.state = X.state;
  }
  isActive() {
    const X = BigInt("0xffffffffffffffff");
    return this.state.deactivationSlot === X;
  }
  static deserialize(X) {
    const ee = decodeData(LookupTableMetaLayout, X), te = X.length - LOOKUP_TABLE_META_SIZE;
    assert(te >= 0, "lookup table is invalid"), assert(te % 32 === 0, "lookup table is invalid");
    const ne = te / 32, {
      addresses: ie
    } = struct$1([seq(publicKey$1(), ne, "addresses")]).decode(X.slice(LOOKUP_TABLE_META_SIZE));
    return {
      deactivationSlot: ee.deactivationSlot,
      lastExtendedSlot: ee.lastExtendedSlot,
      lastExtendedSlotStartIndex: ee.lastExtendedStartIndex,
      authority: ee.authority.length !== 0 ? new PublicKey(ee.authority[0]) : void 0,
      addresses: ie.map((oe) => new PublicKey(oe))
    };
  }
}
const LookupTableMetaLayout = {
  index: 1,
  layout: struct$1([
    u32("typeIndex"),
    u64$1("deactivationSlot"),
    nu64$1("lastExtendedSlot"),
    u8("lastExtendedStartIndex"),
    u8(),
    // option
    seq(publicKey$1(), offset(u8(), -1), "authority")
  ])
}, URL_RE = /^[^:]+:\/\/([^:[]+|\[[^\]]+\])(:\d+)?(.*)/i;
function makeWebsocketUrl(Y) {
  const X = Y.match(URL_RE);
  if (X == null)
    throw TypeError(`Failed to validate endpoint URL \`${Y}\``);
  const [
    ee,
    // eslint-disable-line @typescript-eslint/no-unused-vars
    te,
    ne,
    ie
  ] = X, oe = Y.startsWith("https:") ? "wss:" : "ws:", se = ne == null ? null : parseInt(ne.slice(1), 10), ae = (
    // Only shift the port by +1 as a convention for ws(s) only if given endpoint
    // is explicitly specifying the endpoint port (HTTP-based RPC), assuming
    // we're directly trying to connect to solana-validator's ws listening port.
    // When the endpoint omits the port, we're connecting to the protocol
    // default ports: http(80) or https(443) and it's assumed we're behind a reverse
    // proxy which manages WebSocket upgrade and backend port redirection.
    se == null ? "" : `:${se + 1}`
  );
  return `${oe}//${te}${ae}${ie}`;
}
const PublicKeyFromString = coerce(instance(PublicKey), string(), (Y) => new PublicKey(Y)), RawAccountDataResult = tuple([string(), literal("base64")]), BufferFromRawAccountData = coerce(instance(Buffer$1$1), RawAccountDataResult, (Y) => Buffer$1$1.from(Y[0], "base64")), BLOCKHASH_CACHE_TIMEOUT_MS = 30 * 1e3;
function assertEndpointUrl(Y) {
  if (/^https?:/.test(Y) === !1)
    throw new TypeError("Endpoint URL must start with `http:` or `https:`.");
  return Y;
}
function extractCommitmentFromConfig(Y) {
  let X, ee;
  if (typeof Y == "string")
    X = Y;
  else if (Y) {
    const {
      commitment: te,
      ...ne
    } = Y;
    X = te, ee = ne;
  }
  return {
    commitment: X,
    config: ee
  };
}
function createRpcResult(Y) {
  return union([type({
    jsonrpc: literal("2.0"),
    id: string(),
    result: Y
  }), type({
    jsonrpc: literal("2.0"),
    id: string(),
    error: type({
      code: unknown(),
      message: string(),
      data: optional(any())
    })
  })]);
}
const UnknownRpcResult = createRpcResult(unknown());
function jsonRpcResult(Y) {
  return coerce(createRpcResult(Y), UnknownRpcResult, (X) => "error" in X ? X : {
    ...X,
    result: create(X.result, Y)
  });
}
function jsonRpcResultAndContext(Y) {
  return jsonRpcResult(type({
    context: type({
      slot: number()
    }),
    value: Y
  }));
}
function notificationResultAndContext(Y) {
  return type({
    context: type({
      slot: number()
    }),
    value: Y
  });
}
function versionedMessageFromResponse(Y, X) {
  return Y === 0 ? new MessageV0({
    header: X.header,
    staticAccountKeys: X.accountKeys.map((ee) => new PublicKey(ee)),
    recentBlockhash: X.recentBlockhash,
    compiledInstructions: X.instructions.map((ee) => ({
      programIdIndex: ee.programIdIndex,
      accountKeyIndexes: ee.accounts,
      data: bs58$3.decode(ee.data)
    })),
    addressTableLookups: X.addressTableLookups
  }) : new Message(X);
}
const GetInflationGovernorResult = type({
  foundation: number(),
  foundationTerm: number(),
  initial: number(),
  taper: number(),
  terminal: number()
}), GetInflationRewardResult = jsonRpcResult(array(nullable(type({
  epoch: number(),
  effectiveSlot: number(),
  amount: number(),
  postBalance: number(),
  commission: optional(nullable(number()))
})))), GetRecentPrioritizationFeesResult = array(type({
  slot: number(),
  prioritizationFee: number()
})), GetInflationRateResult = type({
  total: number(),
  validator: number(),
  foundation: number(),
  epoch: number()
}), GetEpochInfoResult = type({
  epoch: number(),
  slotIndex: number(),
  slotsInEpoch: number(),
  absoluteSlot: number(),
  blockHeight: optional(number()),
  transactionCount: optional(number())
}), GetEpochScheduleResult = type({
  slotsPerEpoch: number(),
  leaderScheduleSlotOffset: number(),
  warmup: boolean(),
  firstNormalEpoch: number(),
  firstNormalSlot: number()
}), GetLeaderScheduleResult = record(string(), array(number())), TransactionErrorResult = nullable(union([type({}), string()])), SignatureStatusResult = type({
  err: TransactionErrorResult
}), SignatureReceivedResult = literal("receivedSignature"), VersionResult = type({
  "solana-core": string(),
  "feature-set": optional(number())
}), SimulatedTransactionResponseStruct = jsonRpcResultAndContext(type({
  err: nullable(union([type({}), string()])),
  logs: nullable(array(string())),
  accounts: optional(nullable(array(nullable(type({
    executable: boolean(),
    owner: string(),
    lamports: number(),
    data: array(string()),
    rentEpoch: optional(number())
  }))))),
  unitsConsumed: optional(number()),
  returnData: optional(nullable(type({
    programId: string(),
    data: tuple([string(), literal("base64")])
  })))
})), BlockProductionResponseStruct = jsonRpcResultAndContext(type({
  byIdentity: record(string(), array(number())),
  range: type({
    firstSlot: number(),
    lastSlot: number()
  })
}));
function createRpcClient(Y, X, ee, te, ne, ie) {
  const oe = ee || fetchImpl;
  let se;
  ie != null && console.warn("You have supplied an `httpAgent` when creating a `Connection` in a browser environment.It has been ignored; `httpAgent` is only used in Node environments.");
  let ae;
  return te && (ae = async (ue, le) => {
    const he = await new Promise((me, ye) => {
      try {
        te(ue, le, (we, Ee) => me([we, Ee]));
      } catch (we) {
        ye(we);
      }
    });
    return await oe(...he);
  }), new RpcClient(async (ue, le) => {
    const he = {
      method: "POST",
      body: ue,
      agent: se,
      headers: Object.assign({
        "Content-Type": "application/json"
      }, X || {}, COMMON_HTTP_HEADERS)
    };
    try {
      let me = 5, ye, we = 500;
      for (; ae ? ye = await ae(Y, he) : ye = await oe(Y, he), !(ye.status !== 429 || ne === !0 || (me -= 1, me === 0)); )
        console.error(`Server responded with ${ye.status} ${ye.statusText}.  Retrying after ${we}ms delay...`), await sleep(we), we *= 2;
      const Ee = await ye.text();
      ye.ok ? le(null, Ee) : le(new Error(`${ye.status} ${ye.statusText}: ${Ee}`));
    } catch (me) {
      me instanceof Error && le(me);
    }
  }, {});
}
function createRpcRequest(Y) {
  return (X, ee) => new Promise((te, ne) => {
    Y.request(X, ee, (ie, oe) => {
      if (ie) {
        ne(ie);
        return;
      }
      te(oe);
    });
  });
}
function createRpcBatchRequest(Y) {
  return (X) => new Promise((ee, te) => {
    X.length === 0 && ee([]);
    const ne = X.map((ie) => Y.request(ie.methodName, ie.args));
    Y.request(ne, (ie, oe) => {
      if (ie) {
        te(ie);
        return;
      }
      ee(oe);
    });
  });
}
const GetInflationGovernorRpcResult = jsonRpcResult(GetInflationGovernorResult), GetInflationRateRpcResult = jsonRpcResult(GetInflationRateResult), GetRecentPrioritizationFeesRpcResult = jsonRpcResult(GetRecentPrioritizationFeesResult), GetEpochInfoRpcResult = jsonRpcResult(GetEpochInfoResult), GetEpochScheduleRpcResult = jsonRpcResult(GetEpochScheduleResult), GetLeaderScheduleRpcResult = jsonRpcResult(GetLeaderScheduleResult), SlotRpcResult = jsonRpcResult(number()), GetSupplyRpcResult = jsonRpcResultAndContext(type({
  total: number(),
  circulating: number(),
  nonCirculating: number(),
  nonCirculatingAccounts: array(PublicKeyFromString)
})), TokenAmountResult = type({
  amount: string(),
  uiAmount: nullable(number()),
  decimals: number(),
  uiAmountString: optional(string())
}), GetTokenLargestAccountsResult = jsonRpcResultAndContext(array(type({
  address: PublicKeyFromString,
  amount: string(),
  uiAmount: nullable(number()),
  decimals: number(),
  uiAmountString: optional(string())
}))), GetTokenAccountsByOwner = jsonRpcResultAndContext(array(type({
  pubkey: PublicKeyFromString,
  account: type({
    executable: boolean(),
    owner: PublicKeyFromString,
    lamports: number(),
    data: BufferFromRawAccountData,
    rentEpoch: number()
  })
}))), ParsedAccountDataResult = type({
  program: string(),
  parsed: unknown(),
  space: number()
}), GetParsedTokenAccountsByOwner = jsonRpcResultAndContext(array(type({
  pubkey: PublicKeyFromString,
  account: type({
    executable: boolean(),
    owner: PublicKeyFromString,
    lamports: number(),
    data: ParsedAccountDataResult,
    rentEpoch: number()
  })
}))), GetLargestAccountsRpcResult = jsonRpcResultAndContext(array(type({
  lamports: number(),
  address: PublicKeyFromString
}))), AccountInfoResult = type({
  executable: boolean(),
  owner: PublicKeyFromString,
  lamports: number(),
  data: BufferFromRawAccountData,
  rentEpoch: number()
}), KeyedAccountInfoResult = type({
  pubkey: PublicKeyFromString,
  account: AccountInfoResult
}), ParsedOrRawAccountData = coerce(union([instance(Buffer$1$1), ParsedAccountDataResult]), union([RawAccountDataResult, ParsedAccountDataResult]), (Y) => Array.isArray(Y) ? create(Y, BufferFromRawAccountData) : Y), ParsedAccountInfoResult = type({
  executable: boolean(),
  owner: PublicKeyFromString,
  lamports: number(),
  data: ParsedOrRawAccountData,
  rentEpoch: number()
}), KeyedParsedAccountInfoResult = type({
  pubkey: PublicKeyFromString,
  account: ParsedAccountInfoResult
}), StakeActivationResult = type({
  state: union([literal("active"), literal("inactive"), literal("activating"), literal("deactivating")]),
  active: number(),
  inactive: number()
}), GetConfirmedSignaturesForAddress2RpcResult = jsonRpcResult(array(type({
  signature: string(),
  slot: number(),
  err: TransactionErrorResult,
  memo: nullable(string()),
  blockTime: optional(nullable(number()))
}))), GetSignaturesForAddressRpcResult = jsonRpcResult(array(type({
  signature: string(),
  slot: number(),
  err: TransactionErrorResult,
  memo: nullable(string()),
  blockTime: optional(nullable(number()))
}))), AccountNotificationResult = type({
  subscription: number(),
  result: notificationResultAndContext(AccountInfoResult)
}), ProgramAccountInfoResult = type({
  pubkey: PublicKeyFromString,
  account: AccountInfoResult
}), ProgramAccountNotificationResult = type({
  subscription: number(),
  result: notificationResultAndContext(ProgramAccountInfoResult)
}), SlotInfoResult = type({
  parent: number(),
  slot: number(),
  root: number()
}), SlotNotificationResult = type({
  subscription: number(),
  result: SlotInfoResult
}), SlotUpdateResult = union([type({
  type: union([literal("firstShredReceived"), literal("completed"), literal("optimisticConfirmation"), literal("root")]),
  slot: number(),
  timestamp: number()
}), type({
  type: literal("createdBank"),
  parent: number(),
  slot: number(),
  timestamp: number()
}), type({
  type: literal("frozen"),
  slot: number(),
  timestamp: number(),
  stats: type({
    numTransactionEntries: number(),
    numSuccessfulTransactions: number(),
    numFailedTransactions: number(),
    maxTransactionsPerEntry: number()
  })
}), type({
  type: literal("dead"),
  slot: number(),
  timestamp: number(),
  err: string()
})]), SlotUpdateNotificationResult = type({
  subscription: number(),
  result: SlotUpdateResult
}), SignatureNotificationResult = type({
  subscription: number(),
  result: notificationResultAndContext(union([SignatureStatusResult, SignatureReceivedResult]))
}), RootNotificationResult = type({
  subscription: number(),
  result: number()
}), ContactInfoResult = type({
  pubkey: string(),
  gossip: nullable(string()),
  tpu: nullable(string()),
  rpc: nullable(string()),
  version: nullable(string())
}), VoteAccountInfoResult = type({
  votePubkey: string(),
  nodePubkey: string(),
  activatedStake: number(),
  epochVoteAccount: boolean(),
  epochCredits: array(tuple([number(), number(), number()])),
  commission: number(),
  lastVote: number(),
  rootSlot: nullable(number())
}), GetVoteAccounts = jsonRpcResult(type({
  current: array(VoteAccountInfoResult),
  delinquent: array(VoteAccountInfoResult)
})), ConfirmationStatus = union([literal("processed"), literal("confirmed"), literal("finalized")]), SignatureStatusResponse = type({
  slot: number(),
  confirmations: nullable(number()),
  err: TransactionErrorResult,
  confirmationStatus: optional(ConfirmationStatus)
}), GetSignatureStatusesRpcResult = jsonRpcResultAndContext(array(nullable(SignatureStatusResponse))), GetMinimumBalanceForRentExemptionRpcResult = jsonRpcResult(number()), AddressTableLookupStruct = type({
  accountKey: PublicKeyFromString,
  writableIndexes: array(number()),
  readonlyIndexes: array(number())
}), ConfirmedTransactionResult = type({
  signatures: array(string()),
  message: type({
    accountKeys: array(string()),
    header: type({
      numRequiredSignatures: number(),
      numReadonlySignedAccounts: number(),
      numReadonlyUnsignedAccounts: number()
    }),
    instructions: array(type({
      accounts: array(number()),
      data: string(),
      programIdIndex: number()
    })),
    recentBlockhash: string(),
    addressTableLookups: optional(array(AddressTableLookupStruct))
  })
}), AnnotatedAccountKey = type({
  pubkey: PublicKeyFromString,
  signer: boolean(),
  writable: boolean(),
  source: optional(union([literal("transaction"), literal("lookupTable")]))
}), ConfirmedTransactionAccountsModeResult = type({
  accountKeys: array(AnnotatedAccountKey),
  signatures: array(string())
}), ParsedInstructionResult = type({
  parsed: unknown(),
  program: string(),
  programId: PublicKeyFromString
}), RawInstructionResult = type({
  accounts: array(PublicKeyFromString),
  data: string(),
  programId: PublicKeyFromString
}), InstructionResult = union([RawInstructionResult, ParsedInstructionResult]), UnknownInstructionResult = union([type({
  parsed: unknown(),
  program: string(),
  programId: string()
}), type({
  accounts: array(string()),
  data: string(),
  programId: string()
})]), ParsedOrRawInstruction = coerce(InstructionResult, UnknownInstructionResult, (Y) => "accounts" in Y ? create(Y, RawInstructionResult) : create(Y, ParsedInstructionResult)), ParsedConfirmedTransactionResult = type({
  signatures: array(string()),
  message: type({
    accountKeys: array(AnnotatedAccountKey),
    instructions: array(ParsedOrRawInstruction),
    recentBlockhash: string(),
    addressTableLookups: optional(nullable(array(AddressTableLookupStruct)))
  })
}), TokenBalanceResult = type({
  accountIndex: number(),
  mint: string(),
  owner: optional(string()),
  uiTokenAmount: TokenAmountResult
}), LoadedAddressesResult = type({
  writable: array(PublicKeyFromString),
  readonly: array(PublicKeyFromString)
}), ConfirmedTransactionMetaResult = type({
  err: TransactionErrorResult,
  fee: number(),
  innerInstructions: optional(nullable(array(type({
    index: number(),
    instructions: array(type({
      accounts: array(number()),
      data: string(),
      programIdIndex: number()
    }))
  })))),
  preBalances: array(number()),
  postBalances: array(number()),
  logMessages: optional(nullable(array(string()))),
  preTokenBalances: optional(nullable(array(TokenBalanceResult))),
  postTokenBalances: optional(nullable(array(TokenBalanceResult))),
  loadedAddresses: optional(LoadedAddressesResult),
  computeUnitsConsumed: optional(number())
}), ParsedConfirmedTransactionMetaResult = type({
  err: TransactionErrorResult,
  fee: number(),
  innerInstructions: optional(nullable(array(type({
    index: number(),
    instructions: array(ParsedOrRawInstruction)
  })))),
  preBalances: array(number()),
  postBalances: array(number()),
  logMessages: optional(nullable(array(string()))),
  preTokenBalances: optional(nullable(array(TokenBalanceResult))),
  postTokenBalances: optional(nullable(array(TokenBalanceResult))),
  loadedAddresses: optional(LoadedAddressesResult),
  computeUnitsConsumed: optional(number())
}), TransactionVersionStruct = union([literal(0), literal("legacy")]), RewardsResult = type({
  pubkey: string(),
  lamports: number(),
  postBalance: nullable(number()),
  rewardType: nullable(string()),
  commission: optional(nullable(number()))
}), GetBlockRpcResult = jsonRpcResult(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number(),
  transactions: array(type({
    transaction: ConfirmedTransactionResult,
    meta: nullable(ConfirmedTransactionMetaResult),
    version: optional(TransactionVersionStruct)
  })),
  rewards: optional(array(RewardsResult)),
  blockTime: nullable(number()),
  blockHeight: nullable(number())
}))), GetNoneModeBlockRpcResult = jsonRpcResult(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number(),
  rewards: optional(array(RewardsResult)),
  blockTime: nullable(number()),
  blockHeight: nullable(number())
}))), GetAccountsModeBlockRpcResult = jsonRpcResult(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number(),
  transactions: array(type({
    transaction: ConfirmedTransactionAccountsModeResult,
    meta: nullable(ConfirmedTransactionMetaResult),
    version: optional(TransactionVersionStruct)
  })),
  rewards: optional(array(RewardsResult)),
  blockTime: nullable(number()),
  blockHeight: nullable(number())
}))), GetParsedBlockRpcResult = jsonRpcResult(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number(),
  transactions: array(type({
    transaction: ParsedConfirmedTransactionResult,
    meta: nullable(ParsedConfirmedTransactionMetaResult),
    version: optional(TransactionVersionStruct)
  })),
  rewards: optional(array(RewardsResult)),
  blockTime: nullable(number()),
  blockHeight: nullable(number())
}))), GetParsedAccountsModeBlockRpcResult = jsonRpcResult(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number(),
  transactions: array(type({
    transaction: ConfirmedTransactionAccountsModeResult,
    meta: nullable(ParsedConfirmedTransactionMetaResult),
    version: optional(TransactionVersionStruct)
  })),
  rewards: optional(array(RewardsResult)),
  blockTime: nullable(number()),
  blockHeight: nullable(number())
}))), GetParsedNoneModeBlockRpcResult = jsonRpcResult(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number(),
  rewards: optional(array(RewardsResult)),
  blockTime: nullable(number()),
  blockHeight: nullable(number())
}))), GetConfirmedBlockRpcResult = jsonRpcResult(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number(),
  transactions: array(type({
    transaction: ConfirmedTransactionResult,
    meta: nullable(ConfirmedTransactionMetaResult)
  })),
  rewards: optional(array(RewardsResult)),
  blockTime: nullable(number())
}))), GetBlockSignaturesRpcResult = jsonRpcResult(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number(),
  signatures: array(string()),
  blockTime: nullable(number())
}))), GetTransactionRpcResult = jsonRpcResult(nullable(type({
  slot: number(),
  meta: nullable(ConfirmedTransactionMetaResult),
  blockTime: optional(nullable(number())),
  transaction: ConfirmedTransactionResult,
  version: optional(TransactionVersionStruct)
}))), GetParsedTransactionRpcResult = jsonRpcResult(nullable(type({
  slot: number(),
  transaction: ParsedConfirmedTransactionResult,
  meta: nullable(ParsedConfirmedTransactionMetaResult),
  blockTime: optional(nullable(number())),
  version: optional(TransactionVersionStruct)
}))), GetRecentBlockhashAndContextRpcResult = jsonRpcResultAndContext(type({
  blockhash: string(),
  feeCalculator: type({
    lamportsPerSignature: number()
  })
})), GetLatestBlockhashRpcResult = jsonRpcResultAndContext(type({
  blockhash: string(),
  lastValidBlockHeight: number()
})), IsBlockhashValidRpcResult = jsonRpcResultAndContext(boolean()), PerfSampleResult = type({
  slot: number(),
  numTransactions: number(),
  numSlots: number(),
  samplePeriodSecs: number()
}), GetRecentPerformanceSamplesRpcResult = jsonRpcResult(array(PerfSampleResult)), GetFeeCalculatorRpcResult = jsonRpcResultAndContext(nullable(type({
  feeCalculator: type({
    lamportsPerSignature: number()
  })
}))), RequestAirdropRpcResult = jsonRpcResult(string()), SendTransactionRpcResult = jsonRpcResult(string()), LogsResult = type({
  err: TransactionErrorResult,
  logs: array(string()),
  signature: string()
}), LogsNotificationResult = type({
  result: notificationResultAndContext(LogsResult),
  subscription: number()
}), COMMON_HTTP_HEADERS = {
  "solana-client": "js/0.0.0-development"
};
class Connection {
  /**
   * Establish a JSON RPC connection
   *
   * @param endpoint URL to the fullnode JSON RPC endpoint
   * @param commitmentOrConfig optional default commitment level or optional ConnectionConfig configuration object
   */
  constructor(X, ee) {
    this._commitment = void 0, this._confirmTransactionInitialTimeout = void 0, this._rpcEndpoint = void 0, this._rpcWsEndpoint = void 0, this._rpcClient = void 0, this._rpcRequest = void 0, this._rpcBatchRequest = void 0, this._rpcWebSocket = void 0, this._rpcWebSocketConnected = !1, this._rpcWebSocketHeartbeat = null, this._rpcWebSocketIdleTimeout = null, this._rpcWebSocketGeneration = 0, this._disableBlockhashCaching = !1, this._pollingBlockhash = !1, this._blockhashInfo = {
      latestBlockhash: null,
      lastFetch: 0,
      transactionSignatures: [],
      simulatedSignatures: []
    }, this._nextClientSubscriptionId = 0, this._subscriptionDisposeFunctionsByClientSubscriptionId = {}, this._subscriptionHashByClientSubscriptionId = {}, this._subscriptionStateChangeCallbacksByHash = {}, this._subscriptionCallbacksByServerSubscriptionId = {}, this._subscriptionsByHash = {}, this._subscriptionsAutoDisposedByRpc = /* @__PURE__ */ new Set(), this.getBlockHeight = /* @__PURE__ */ (() => {
      const ue = {};
      return async (le) => {
        const {
          commitment: he,
          config: me
        } = extractCommitmentFromConfig(le), ye = this._buildArgs([], he, void 0, me), we = fastStableStringify$1(ye);
        return ue[we] = ue[we] ?? (async () => {
          try {
            const Ee = await this._rpcRequest("getBlockHeight", ye), Re = create(Ee, jsonRpcResult(number()));
            if ("error" in Re)
              throw new SolanaJSONRPCError(Re.error, "failed to get block height information");
            return Re.result;
          } finally {
            delete ue[we];
          }
        })(), await ue[we];
      };
    })();
    let te, ne, ie, oe, se, ae;
    ee && typeof ee == "string" ? this._commitment = ee : ee && (this._commitment = ee.commitment, this._confirmTransactionInitialTimeout = ee.confirmTransactionInitialTimeout, te = ee.wsEndpoint, ne = ee.httpHeaders, ie = ee.fetch, oe = ee.fetchMiddleware, se = ee.disableRetryOnRateLimit, ae = ee.httpAgent), this._rpcEndpoint = assertEndpointUrl(X), this._rpcWsEndpoint = te || makeWebsocketUrl(X), this._rpcClient = createRpcClient(X, ne, ie, oe, se, ae), this._rpcRequest = createRpcRequest(this._rpcClient), this._rpcBatchRequest = createRpcBatchRequest(this._rpcClient), this._rpcWebSocket = new RpcWebSocketClient(this._rpcWsEndpoint, {
      autoconnect: !1,
      max_reconnects: 1 / 0
    }), this._rpcWebSocket.on("open", this._wsOnOpen.bind(this)), this._rpcWebSocket.on("error", this._wsOnError.bind(this)), this._rpcWebSocket.on("close", this._wsOnClose.bind(this)), this._rpcWebSocket.on("accountNotification", this._wsOnAccountNotification.bind(this)), this._rpcWebSocket.on("programNotification", this._wsOnProgramAccountNotification.bind(this)), this._rpcWebSocket.on("slotNotification", this._wsOnSlotNotification.bind(this)), this._rpcWebSocket.on("slotsUpdatesNotification", this._wsOnSlotUpdatesNotification.bind(this)), this._rpcWebSocket.on("signatureNotification", this._wsOnSignatureNotification.bind(this)), this._rpcWebSocket.on("rootNotification", this._wsOnRootNotification.bind(this)), this._rpcWebSocket.on("logsNotification", this._wsOnLogsNotification.bind(this));
  }
  /**
   * The default commitment used for requests
   */
  get commitment() {
    return this._commitment;
  }
  /**
   * The RPC endpoint
   */
  get rpcEndpoint() {
    return this._rpcEndpoint;
  }
  /**
   * Fetch the balance for the specified public key, return with context
   */
  async getBalanceAndContext(X, ee) {
    const {
      commitment: te,
      config: ne
    } = extractCommitmentFromConfig(ee), ie = this._buildArgs([X.toBase58()], te, void 0, ne), oe = await this._rpcRequest("getBalance", ie), se = create(oe, jsonRpcResultAndContext(number()));
    if ("error" in se)
      throw new SolanaJSONRPCError(se.error, `failed to get balance for ${X.toBase58()}`);
    return se.result;
  }
  /**
   * Fetch the balance for the specified public key
   */
  async getBalance(X, ee) {
    return await this.getBalanceAndContext(X, ee).then((te) => te.value).catch((te) => {
      throw new Error("failed to get balance of account " + X.toBase58() + ": " + te);
    });
  }
  /**
   * Fetch the estimated production time of a block
   */
  async getBlockTime(X) {
    const ee = await this._rpcRequest("getBlockTime", [X]), te = create(ee, jsonRpcResult(nullable(number())));
    if ("error" in te)
      throw new SolanaJSONRPCError(te.error, `failed to get block time for slot ${X}`);
    return te.result;
  }
  /**
   * Fetch the lowest slot that the node has information about in its ledger.
   * This value may increase over time if the node is configured to purge older ledger data
   */
  async getMinimumLedgerSlot() {
    const X = await this._rpcRequest("minimumLedgerSlot", []), ee = create(X, jsonRpcResult(number()));
    if ("error" in ee)
      throw new SolanaJSONRPCError(ee.error, "failed to get minimum ledger slot");
    return ee.result;
  }
  /**
   * Fetch the slot of the lowest confirmed block that has not been purged from the ledger
   */
  async getFirstAvailableBlock() {
    const X = await this._rpcRequest("getFirstAvailableBlock", []), ee = create(X, SlotRpcResult);
    if ("error" in ee)
      throw new SolanaJSONRPCError(ee.error, "failed to get first available block");
    return ee.result;
  }
  /**
   * Fetch information about the current supply
   */
  async getSupply(X) {
    let ee = {};
    typeof X == "string" ? ee = {
      commitment: X
    } : X ? ee = {
      ...X,
      commitment: X && X.commitment || this.commitment
    } : ee = {
      commitment: this.commitment
    };
    const te = await this._rpcRequest("getSupply", [ee]), ne = create(te, GetSupplyRpcResult);
    if ("error" in ne)
      throw new SolanaJSONRPCError(ne.error, "failed to get supply");
    return ne.result;
  }
  /**
   * Fetch the current supply of a token mint
   */
  async getTokenSupply(X, ee) {
    const te = this._buildArgs([X.toBase58()], ee), ne = await this._rpcRequest("getTokenSupply", te), ie = create(ne, jsonRpcResultAndContext(TokenAmountResult));
    if ("error" in ie)
      throw new SolanaJSONRPCError(ie.error, "failed to get token supply");
    return ie.result;
  }
  /**
   * Fetch the current balance of a token account
   */
  async getTokenAccountBalance(X, ee) {
    const te = this._buildArgs([X.toBase58()], ee), ne = await this._rpcRequest("getTokenAccountBalance", te), ie = create(ne, jsonRpcResultAndContext(TokenAmountResult));
    if ("error" in ie)
      throw new SolanaJSONRPCError(ie.error, "failed to get token account balance");
    return ie.result;
  }
  /**
   * Fetch all the token accounts owned by the specified account
   *
   * @return {Promise<RpcResponseAndContext<GetProgramAccountsResponse>}
   */
  async getTokenAccountsByOwner(X, ee, te) {
    const {
      commitment: ne,
      config: ie
    } = extractCommitmentFromConfig(te);
    let oe = [X.toBase58()];
    "mint" in ee ? oe.push({
      mint: ee.mint.toBase58()
    }) : oe.push({
      programId: ee.programId.toBase58()
    });
    const se = this._buildArgs(oe, ne, "base64", ie), ae = await this._rpcRequest("getTokenAccountsByOwner", se), ue = create(ae, GetTokenAccountsByOwner);
    if ("error" in ue)
      throw new SolanaJSONRPCError(ue.error, `failed to get token accounts owned by account ${X.toBase58()}`);
    return ue.result;
  }
  /**
   * Fetch parsed token accounts owned by the specified account
   *
   * @return {Promise<RpcResponseAndContext<Array<{pubkey: PublicKey, account: AccountInfo<ParsedAccountData>}>>>}
   */
  async getParsedTokenAccountsByOwner(X, ee, te) {
    let ne = [X.toBase58()];
    "mint" in ee ? ne.push({
      mint: ee.mint.toBase58()
    }) : ne.push({
      programId: ee.programId.toBase58()
    });
    const ie = this._buildArgs(ne, te, "jsonParsed"), oe = await this._rpcRequest("getTokenAccountsByOwner", ie), se = create(oe, GetParsedTokenAccountsByOwner);
    if ("error" in se)
      throw new SolanaJSONRPCError(se.error, `failed to get token accounts owned by account ${X.toBase58()}`);
    return se.result;
  }
  /**
   * Fetch the 20 largest accounts with their current balances
   */
  async getLargestAccounts(X) {
    const ee = {
      ...X,
      commitment: X && X.commitment || this.commitment
    }, te = ee.filter || ee.commitment ? [ee] : [], ne = await this._rpcRequest("getLargestAccounts", te), ie = create(ne, GetLargestAccountsRpcResult);
    if ("error" in ie)
      throw new SolanaJSONRPCError(ie.error, "failed to get largest accounts");
    return ie.result;
  }
  /**
   * Fetch the 20 largest token accounts with their current balances
   * for a given mint.
   */
  async getTokenLargestAccounts(X, ee) {
    const te = this._buildArgs([X.toBase58()], ee), ne = await this._rpcRequest("getTokenLargestAccounts", te), ie = create(ne, GetTokenLargestAccountsResult);
    if ("error" in ie)
      throw new SolanaJSONRPCError(ie.error, "failed to get token largest accounts");
    return ie.result;
  }
  /**
   * Fetch all the account info for the specified public key, return with context
   */
  async getAccountInfoAndContext(X, ee) {
    const {
      commitment: te,
      config: ne
    } = extractCommitmentFromConfig(ee), ie = this._buildArgs([X.toBase58()], te, "base64", ne), oe = await this._rpcRequest("getAccountInfo", ie), se = create(oe, jsonRpcResultAndContext(nullable(AccountInfoResult)));
    if ("error" in se)
      throw new SolanaJSONRPCError(se.error, `failed to get info about account ${X.toBase58()}`);
    return se.result;
  }
  /**
   * Fetch parsed account info for the specified public key
   */
  async getParsedAccountInfo(X, ee) {
    const {
      commitment: te,
      config: ne
    } = extractCommitmentFromConfig(ee), ie = this._buildArgs([X.toBase58()], te, "jsonParsed", ne), oe = await this._rpcRequest("getAccountInfo", ie), se = create(oe, jsonRpcResultAndContext(nullable(ParsedAccountInfoResult)));
    if ("error" in se)
      throw new SolanaJSONRPCError(se.error, `failed to get info about account ${X.toBase58()}`);
    return se.result;
  }
  /**
   * Fetch all the account info for the specified public key
   */
  async getAccountInfo(X, ee) {
    try {
      return (await this.getAccountInfoAndContext(X, ee)).value;
    } catch (te) {
      throw new Error("failed to get info about account " + X.toBase58() + ": " + te);
    }
  }
  /**
   * Fetch all the account info for multiple accounts specified by an array of public keys, return with context
   */
  async getMultipleParsedAccounts(X, ee) {
    const {
      commitment: te,
      config: ne
    } = extractCommitmentFromConfig(ee), ie = X.map((ue) => ue.toBase58()), oe = this._buildArgs([ie], te, "jsonParsed", ne), se = await this._rpcRequest("getMultipleAccounts", oe), ae = create(se, jsonRpcResultAndContext(array(nullable(ParsedAccountInfoResult))));
    if ("error" in ae)
      throw new SolanaJSONRPCError(ae.error, `failed to get info for accounts ${ie}`);
    return ae.result;
  }
  /**
   * Fetch all the account info for multiple accounts specified by an array of public keys, return with context
   */
  async getMultipleAccountsInfoAndContext(X, ee) {
    const {
      commitment: te,
      config: ne
    } = extractCommitmentFromConfig(ee), ie = X.map((ue) => ue.toBase58()), oe = this._buildArgs([ie], te, "base64", ne), se = await this._rpcRequest("getMultipleAccounts", oe), ae = create(se, jsonRpcResultAndContext(array(nullable(AccountInfoResult))));
    if ("error" in ae)
      throw new SolanaJSONRPCError(ae.error, `failed to get info for accounts ${ie}`);
    return ae.result;
  }
  /**
   * Fetch all the account info for multiple accounts specified by an array of public keys
   */
  async getMultipleAccountsInfo(X, ee) {
    return (await this.getMultipleAccountsInfoAndContext(X, ee)).value;
  }
  /**
   * Returns epoch activation information for a stake account that has been delegated
   */
  async getStakeActivation(X, ee, te) {
    const {
      commitment: ne,
      config: ie
    } = extractCommitmentFromConfig(ee), oe = this._buildArgs([X.toBase58()], ne, void 0, {
      ...ie,
      epoch: te ?? (ie == null ? void 0 : ie.epoch)
    }), se = await this._rpcRequest("getStakeActivation", oe), ae = create(se, jsonRpcResult(StakeActivationResult));
    if ("error" in ae)
      throw new SolanaJSONRPCError(ae.error, `failed to get Stake Activation ${X.toBase58()}`);
    return ae.result;
  }
  /**
   * Fetch all the accounts owned by the specified program id
   *
   * @return {Promise<Array<{pubkey: PublicKey, account: AccountInfo<Buffer>}>>}
   */
  // eslint-disable-next-line no-dupe-class-members
  // eslint-disable-next-line no-dupe-class-members
  async getProgramAccounts(X, ee) {
    const {
      commitment: te,
      config: ne
    } = extractCommitmentFromConfig(ee), {
      encoding: ie,
      ...oe
    } = ne || {}, se = this._buildArgs([X.toBase58()], te, ie || "base64", oe), ae = await this._rpcRequest("getProgramAccounts", se), ue = array(KeyedAccountInfoResult), le = oe.withContext === !0 ? create(ae, jsonRpcResultAndContext(ue)) : create(ae, jsonRpcResult(ue));
    if ("error" in le)
      throw new SolanaJSONRPCError(le.error, `failed to get accounts owned by program ${X.toBase58()}`);
    return le.result;
  }
  /**
   * Fetch and parse all the accounts owned by the specified program id
   *
   * @return {Promise<Array<{pubkey: PublicKey, account: AccountInfo<Buffer | ParsedAccountData>}>>}
   */
  async getParsedProgramAccounts(X, ee) {
    const {
      commitment: te,
      config: ne
    } = extractCommitmentFromConfig(ee), ie = this._buildArgs([X.toBase58()], te, "jsonParsed", ne), oe = await this._rpcRequest("getProgramAccounts", ie), se = create(oe, jsonRpcResult(array(KeyedParsedAccountInfoResult)));
    if ("error" in se)
      throw new SolanaJSONRPCError(se.error, `failed to get accounts owned by program ${X.toBase58()}`);
    return se.result;
  }
  /** @deprecated Instead, call `confirmTransaction` and pass in {@link TransactionConfirmationStrategy} */
  // eslint-disable-next-line no-dupe-class-members
  // eslint-disable-next-line no-dupe-class-members
  async confirmTransaction(X, ee) {
    var te;
    let ne;
    if (typeof X == "string")
      ne = X;
    else {
      const oe = X;
      if ((te = oe.abortSignal) != null && te.aborted)
        return Promise.reject(oe.abortSignal.reason);
      ne = oe.signature;
    }
    let ie;
    try {
      ie = bs58$3.decode(ne);
    } catch {
      throw new Error("signature must be base58 encoded: " + ne);
    }
    return assert(ie.length === 64, "signature has invalid length"), typeof X == "string" ? await this.confirmTransactionUsingLegacyTimeoutStrategy({
      commitment: ee || this.commitment,
      signature: ne
    }) : "lastValidBlockHeight" in X ? await this.confirmTransactionUsingBlockHeightExceedanceStrategy({
      commitment: ee || this.commitment,
      strategy: X
    }) : await this.confirmTransactionUsingDurableNonceStrategy({
      commitment: ee || this.commitment,
      strategy: X
    });
  }
  getCancellationPromise(X) {
    return new Promise((ee, te) => {
      X != null && (X.aborted ? te(X.reason) : X.addEventListener("abort", () => {
        te(X.reason);
      }));
    });
  }
  getTransactionConfirmationPromise({
    commitment: X,
    signature: ee
  }) {
    let te, ne, ie = !1;
    const oe = new Promise((se, ae) => {
      try {
        te = this.onSignature(ee, (le, he) => {
          te = void 0;
          const me = {
            context: he,
            value: le
          };
          se({
            __type: TransactionStatus.PROCESSED,
            response: me
          });
        }, X);
        const ue = new Promise((le) => {
          te == null ? le() : ne = this._onSubscriptionStateChange(te, (he) => {
            he === "subscribed" && le();
          });
        });
        (async () => {
          if (await ue, ie)
            return;
          const le = await this.getSignatureStatus(ee);
          if (ie || le == null)
            return;
          const {
            context: he,
            value: me
          } = le;
          if (me != null)
            if (me != null && me.err)
              ae(me.err);
            else {
              switch (X) {
                case "confirmed":
                case "single":
                case "singleGossip": {
                  if (me.confirmationStatus === "processed")
                    return;
                  break;
                }
                case "finalized":
                case "max":
                case "root": {
                  if (me.confirmationStatus === "processed" || me.confirmationStatus === "confirmed")
                    return;
                  break;
                }
                case "processed":
                case "recent":
              }
              ie = !0, se({
                __type: TransactionStatus.PROCESSED,
                response: {
                  context: he,
                  value: me
                }
              });
            }
        })();
      } catch (ue) {
        ae(ue);
      }
    });
    return {
      abortConfirmation: () => {
        ne && (ne(), ne = void 0), te != null && (this.removeSignatureListener(te), te = void 0);
      },
      confirmationPromise: oe
    };
  }
  async confirmTransactionUsingBlockHeightExceedanceStrategy({
    commitment: X,
    strategy: {
      abortSignal: ee,
      lastValidBlockHeight: te,
      signature: ne
    }
  }) {
    let ie = !1;
    const oe = new Promise((he) => {
      const me = async () => {
        try {
          return await this.getBlockHeight(X);
        } catch {
          return -1;
        }
      };
      (async () => {
        let ye = await me();
        if (!ie) {
          for (; ye <= te; )
            if (await sleep(1e3), ie || (ye = await me(), ie))
              return;
          he({
            __type: TransactionStatus.BLOCKHEIGHT_EXCEEDED
          });
        }
      })();
    }), {
      abortConfirmation: se,
      confirmationPromise: ae
    } = this.getTransactionConfirmationPromise({
      commitment: X,
      signature: ne
    }), ue = this.getCancellationPromise(ee);
    let le;
    try {
      const he = await Promise.race([ue, ae, oe]);
      if (he.__type === TransactionStatus.PROCESSED)
        le = he.response;
      else
        throw new TransactionExpiredBlockheightExceededError(ne);
    } finally {
      ie = !0, se();
    }
    return le;
  }
  async confirmTransactionUsingDurableNonceStrategy({
    commitment: X,
    strategy: {
      abortSignal: ee,
      minContextSlot: te,
      nonceAccountPubkey: ne,
      nonceValue: ie,
      signature: oe
    }
  }) {
    let se = !1;
    const ae = new Promise((ye) => {
      let we = ie, Ee = null;
      const Re = async () => {
        try {
          const {
            context: Ue,
            value: Me
          } = await this.getNonceAndContext(ne, {
            commitment: X,
            minContextSlot: te
          });
          return Ee = Ue.slot, Me == null ? void 0 : Me.nonce;
        } catch {
          return we;
        }
      };
      (async () => {
        if (we = await Re(), !se)
          for (; ; ) {
            if (ie !== we) {
              ye({
                __type: TransactionStatus.NONCE_INVALID,
                slotInWhichNonceDidAdvance: Ee
              });
              return;
            }
            if (await sleep(2e3), se || (we = await Re(), se))
              return;
          }
      })();
    }), {
      abortConfirmation: ue,
      confirmationPromise: le
    } = this.getTransactionConfirmationPromise({
      commitment: X,
      signature: oe
    }), he = this.getCancellationPromise(ee);
    let me;
    try {
      const ye = await Promise.race([he, le, ae]);
      if (ye.__type === TransactionStatus.PROCESSED)
        me = ye.response;
      else {
        let we;
        for (; ; ) {
          const Ee = await this.getSignatureStatus(oe);
          if (Ee == null)
            break;
          if (Ee.context.slot < (ye.slotInWhichNonceDidAdvance ?? te)) {
            await sleep(400);
            continue;
          }
          we = Ee;
          break;
        }
        if (we != null && we.value) {
          const Ee = X || "finalized", {
            confirmationStatus: Re
          } = we.value;
          switch (Ee) {
            case "processed":
            case "recent":
              if (Re !== "processed" && Re !== "confirmed" && Re !== "finalized")
                throw new TransactionExpiredNonceInvalidError(oe);
              break;
            case "confirmed":
            case "single":
            case "singleGossip":
              if (Re !== "confirmed" && Re !== "finalized")
                throw new TransactionExpiredNonceInvalidError(oe);
              break;
            case "finalized":
            case "max":
            case "root":
              if (Re !== "finalized")
                throw new TransactionExpiredNonceInvalidError(oe);
              break;
            default:
          }
          me = {
            context: we.context,
            value: {
              err: we.value.err
            }
          };
        } else
          throw new TransactionExpiredNonceInvalidError(oe);
      }
    } finally {
      se = !0, ue();
    }
    return me;
  }
  async confirmTransactionUsingLegacyTimeoutStrategy({
    commitment: X,
    signature: ee
  }) {
    let te;
    const ne = new Promise((ae) => {
      let ue = this._confirmTransactionInitialTimeout || 6e4;
      switch (X) {
        case "processed":
        case "recent":
        case "single":
        case "confirmed":
        case "singleGossip": {
          ue = this._confirmTransactionInitialTimeout || 3e4;
          break;
        }
      }
      te = setTimeout(() => ae({
        __type: TransactionStatus.TIMED_OUT,
        timeoutMs: ue
      }), ue);
    }), {
      abortConfirmation: ie,
      confirmationPromise: oe
    } = this.getTransactionConfirmationPromise({
      commitment: X,
      signature: ee
    });
    let se;
    try {
      const ae = await Promise.race([oe, ne]);
      if (ae.__type === TransactionStatus.PROCESSED)
        se = ae.response;
      else
        throw new TransactionExpiredTimeoutError(ee, ae.timeoutMs / 1e3);
    } finally {
      clearTimeout(te), ie();
    }
    return se;
  }
  /**
   * Return the list of nodes that are currently participating in the cluster
   */
  async getClusterNodes() {
    const X = await this._rpcRequest("getClusterNodes", []), ee = create(X, jsonRpcResult(array(ContactInfoResult)));
    if ("error" in ee)
      throw new SolanaJSONRPCError(ee.error, "failed to get cluster nodes");
    return ee.result;
  }
  /**
   * Return the list of nodes that are currently participating in the cluster
   */
  async getVoteAccounts(X) {
    const ee = this._buildArgs([], X), te = await this._rpcRequest("getVoteAccounts", ee), ne = create(te, GetVoteAccounts);
    if ("error" in ne)
      throw new SolanaJSONRPCError(ne.error, "failed to get vote accounts");
    return ne.result;
  }
  /**
   * Fetch the current slot that the node is processing
   */
  async getSlot(X) {
    const {
      commitment: ee,
      config: te
    } = extractCommitmentFromConfig(X), ne = this._buildArgs([], ee, void 0, te), ie = await this._rpcRequest("getSlot", ne), oe = create(ie, jsonRpcResult(number()));
    if ("error" in oe)
      throw new SolanaJSONRPCError(oe.error, "failed to get slot");
    return oe.result;
  }
  /**
   * Fetch the current slot leader of the cluster
   */
  async getSlotLeader(X) {
    const {
      commitment: ee,
      config: te
    } = extractCommitmentFromConfig(X), ne = this._buildArgs([], ee, void 0, te), ie = await this._rpcRequest("getSlotLeader", ne), oe = create(ie, jsonRpcResult(string()));
    if ("error" in oe)
      throw new SolanaJSONRPCError(oe.error, "failed to get slot leader");
    return oe.result;
  }
  /**
   * Fetch `limit` number of slot leaders starting from `startSlot`
   *
   * @param startSlot fetch slot leaders starting from this slot
   * @param limit number of slot leaders to return
   */
  async getSlotLeaders(X, ee) {
    const te = [X, ee], ne = await this._rpcRequest("getSlotLeaders", te), ie = create(ne, jsonRpcResult(array(PublicKeyFromString)));
    if ("error" in ie)
      throw new SolanaJSONRPCError(ie.error, "failed to get slot leaders");
    return ie.result;
  }
  /**
   * Fetch the current status of a signature
   */
  async getSignatureStatus(X, ee) {
    const {
      context: te,
      value: ne
    } = await this.getSignatureStatuses([X], ee);
    assert(ne.length === 1);
    const ie = ne[0];
    return {
      context: te,
      value: ie
    };
  }
  /**
   * Fetch the current statuses of a batch of signatures
   */
  async getSignatureStatuses(X, ee) {
    const te = [X];
    ee && te.push(ee);
    const ne = await this._rpcRequest("getSignatureStatuses", te), ie = create(ne, GetSignatureStatusesRpcResult);
    if ("error" in ie)
      throw new SolanaJSONRPCError(ie.error, "failed to get signature status");
    return ie.result;
  }
  /**
   * Fetch the current transaction count of the cluster
   */
  async getTransactionCount(X) {
    const {
      commitment: ee,
      config: te
    } = extractCommitmentFromConfig(X), ne = this._buildArgs([], ee, void 0, te), ie = await this._rpcRequest("getTransactionCount", ne), oe = create(ie, jsonRpcResult(number()));
    if ("error" in oe)
      throw new SolanaJSONRPCError(oe.error, "failed to get transaction count");
    return oe.result;
  }
  /**
   * Fetch the current total currency supply of the cluster in lamports
   *
   * @deprecated Deprecated since v1.2.8. Please use {@link getSupply} instead.
   */
  async getTotalSupply(X) {
    return (await this.getSupply({
      commitment: X,
      excludeNonCirculatingAccountsList: !0
    })).value.total;
  }
  /**
   * Fetch the cluster InflationGovernor parameters
   */
  async getInflationGovernor(X) {
    const ee = this._buildArgs([], X), te = await this._rpcRequest("getInflationGovernor", ee), ne = create(te, GetInflationGovernorRpcResult);
    if ("error" in ne)
      throw new SolanaJSONRPCError(ne.error, "failed to get inflation");
    return ne.result;
  }
  /**
   * Fetch the inflation reward for a list of addresses for an epoch
   */
  async getInflationReward(X, ee, te) {
    const {
      commitment: ne,
      config: ie
    } = extractCommitmentFromConfig(te), oe = this._buildArgs([X.map((ue) => ue.toBase58())], ne, void 0, {
      ...ie,
      epoch: ee ?? (ie == null ? void 0 : ie.epoch)
    }), se = await this._rpcRequest("getInflationReward", oe), ae = create(se, GetInflationRewardResult);
    if ("error" in ae)
      throw new SolanaJSONRPCError(ae.error, "failed to get inflation reward");
    return ae.result;
  }
  /**
   * Fetch the specific inflation values for the current epoch
   */
  async getInflationRate() {
    const X = await this._rpcRequest("getInflationRate", []), ee = create(X, GetInflationRateRpcResult);
    if ("error" in ee)
      throw new SolanaJSONRPCError(ee.error, "failed to get inflation rate");
    return ee.result;
  }
  /**
   * Fetch the Epoch Info parameters
   */
  async getEpochInfo(X) {
    const {
      commitment: ee,
      config: te
    } = extractCommitmentFromConfig(X), ne = this._buildArgs([], ee, void 0, te), ie = await this._rpcRequest("getEpochInfo", ne), oe = create(ie, GetEpochInfoRpcResult);
    if ("error" in oe)
      throw new SolanaJSONRPCError(oe.error, "failed to get epoch info");
    return oe.result;
  }
  /**
   * Fetch the Epoch Schedule parameters
   */
  async getEpochSchedule() {
    const X = await this._rpcRequest("getEpochSchedule", []), ee = create(X, GetEpochScheduleRpcResult);
    if ("error" in ee)
      throw new SolanaJSONRPCError(ee.error, "failed to get epoch schedule");
    const te = ee.result;
    return new EpochSchedule(te.slotsPerEpoch, te.leaderScheduleSlotOffset, te.warmup, te.firstNormalEpoch, te.firstNormalSlot);
  }
  /**
   * Fetch the leader schedule for the current epoch
   * @return {Promise<RpcResponseAndContext<LeaderSchedule>>}
   */
  async getLeaderSchedule() {
    const X = await this._rpcRequest("getLeaderSchedule", []), ee = create(X, GetLeaderScheduleRpcResult);
    if ("error" in ee)
      throw new SolanaJSONRPCError(ee.error, "failed to get leader schedule");
    return ee.result;
  }
  /**
   * Fetch the minimum balance needed to exempt an account of `dataLength`
   * size from rent
   */
  async getMinimumBalanceForRentExemption(X, ee) {
    const te = this._buildArgs([X], ee), ne = await this._rpcRequest("getMinimumBalanceForRentExemption", te), ie = create(ne, GetMinimumBalanceForRentExemptionRpcResult);
    return "error" in ie ? (console.warn("Unable to fetch minimum balance for rent exemption"), 0) : ie.result;
  }
  /**
   * Fetch a recent blockhash from the cluster, return with context
   * @return {Promise<RpcResponseAndContext<{blockhash: Blockhash, feeCalculator: FeeCalculator}>>}
   *
   * @deprecated Deprecated since Solana v1.8.0. Please use {@link getLatestBlockhash} instead.
   */
  async getRecentBlockhashAndContext(X) {
    const ee = this._buildArgs([], X), te = await this._rpcRequest("getRecentBlockhash", ee), ne = create(te, GetRecentBlockhashAndContextRpcResult);
    if ("error" in ne)
      throw new SolanaJSONRPCError(ne.error, "failed to get recent blockhash");
    return ne.result;
  }
  /**
   * Fetch recent performance samples
   * @return {Promise<Array<PerfSample>>}
   */
  async getRecentPerformanceSamples(X) {
    const ee = await this._rpcRequest("getRecentPerformanceSamples", X ? [X] : []), te = create(ee, GetRecentPerformanceSamplesRpcResult);
    if ("error" in te)
      throw new SolanaJSONRPCError(te.error, "failed to get recent performance samples");
    return te.result;
  }
  /**
   * Fetch the fee calculator for a recent blockhash from the cluster, return with context
   *
   * @deprecated Deprecated since Solana v1.8.0. Please use {@link getFeeForMessage} instead.
   */
  async getFeeCalculatorForBlockhash(X, ee) {
    const te = this._buildArgs([X], ee), ne = await this._rpcRequest("getFeeCalculatorForBlockhash", te), ie = create(ne, GetFeeCalculatorRpcResult);
    if ("error" in ie)
      throw new SolanaJSONRPCError(ie.error, "failed to get fee calculator");
    const {
      context: oe,
      value: se
    } = ie.result;
    return {
      context: oe,
      value: se !== null ? se.feeCalculator : null
    };
  }
  /**
   * Fetch the fee for a message from the cluster, return with context
   */
  async getFeeForMessage(X, ee) {
    const te = toBuffer(X.serialize()).toString("base64"), ne = this._buildArgs([te], ee), ie = await this._rpcRequest("getFeeForMessage", ne), oe = create(ie, jsonRpcResultAndContext(nullable(number())));
    if ("error" in oe)
      throw new SolanaJSONRPCError(oe.error, "failed to get fee for message");
    if (oe.result === null)
      throw new Error("invalid blockhash");
    return oe.result;
  }
  /**
   * Fetch a list of prioritization fees from recent blocks.
   */
  async getRecentPrioritizationFees(X) {
    var ee;
    const te = (ee = X == null ? void 0 : X.lockedWritableAccounts) == null ? void 0 : ee.map((se) => se.toBase58()), ne = te != null && te.length ? [te] : [], ie = await this._rpcRequest("getRecentPrioritizationFees", ne), oe = create(ie, GetRecentPrioritizationFeesRpcResult);
    if ("error" in oe)
      throw new SolanaJSONRPCError(oe.error, "failed to get recent prioritization fees");
    return oe.result;
  }
  /**
   * Fetch a recent blockhash from the cluster
   * @return {Promise<{blockhash: Blockhash, feeCalculator: FeeCalculator}>}
   *
   * @deprecated Deprecated since Solana v1.8.0. Please use {@link getLatestBlockhash} instead.
   */
  async getRecentBlockhash(X) {
    try {
      return (await this.getRecentBlockhashAndContext(X)).value;
    } catch (ee) {
      throw new Error("failed to get recent blockhash: " + ee);
    }
  }
  /**
   * Fetch the latest blockhash from the cluster
   * @return {Promise<BlockhashWithExpiryBlockHeight>}
   */
  async getLatestBlockhash(X) {
    try {
      return (await this.getLatestBlockhashAndContext(X)).value;
    } catch (ee) {
      throw new Error("failed to get recent blockhash: " + ee);
    }
  }
  /**
   * Fetch the latest blockhash from the cluster
   * @return {Promise<BlockhashWithExpiryBlockHeight>}
   */
  async getLatestBlockhashAndContext(X) {
    const {
      commitment: ee,
      config: te
    } = extractCommitmentFromConfig(X), ne = this._buildArgs([], ee, void 0, te), ie = await this._rpcRequest("getLatestBlockhash", ne), oe = create(ie, GetLatestBlockhashRpcResult);
    if ("error" in oe)
      throw new SolanaJSONRPCError(oe.error, "failed to get latest blockhash");
    return oe.result;
  }
  /**
   * Returns whether a blockhash is still valid or not
   */
  async isBlockhashValid(X, ee) {
    const {
      commitment: te,
      config: ne
    } = extractCommitmentFromConfig(ee), ie = this._buildArgs([X], te, void 0, ne), oe = await this._rpcRequest("isBlockhashValid", ie), se = create(oe, IsBlockhashValidRpcResult);
    if ("error" in se)
      throw new SolanaJSONRPCError(se.error, "failed to determine if the blockhash `" + X + "`is valid");
    return se.result;
  }
  /**
   * Fetch the node version
   */
  async getVersion() {
    const X = await this._rpcRequest("getVersion", []), ee = create(X, jsonRpcResult(VersionResult));
    if ("error" in ee)
      throw new SolanaJSONRPCError(ee.error, "failed to get version");
    return ee.result;
  }
  /**
   * Fetch the genesis hash
   */
  async getGenesisHash() {
    const X = await this._rpcRequest("getGenesisHash", []), ee = create(X, jsonRpcResult(string()));
    if ("error" in ee)
      throw new SolanaJSONRPCError(ee.error, "failed to get genesis hash");
    return ee.result;
  }
  /**
   * Fetch a processed block from the cluster.
   *
   * @deprecated Instead, call `getBlock` using a `GetVersionedBlockConfig` by
   * setting the `maxSupportedTransactionVersion` property.
   */
  /**
   * @deprecated Instead, call `getBlock` using a `GetVersionedBlockConfig` by
   * setting the `maxSupportedTransactionVersion` property.
   */
  // eslint-disable-next-line no-dupe-class-members
  /**
   * @deprecated Instead, call `getBlock` using a `GetVersionedBlockConfig` by
   * setting the `maxSupportedTransactionVersion` property.
   */
  // eslint-disable-next-line no-dupe-class-members
  /**
   * Fetch a processed block from the cluster.
   */
  // eslint-disable-next-line no-dupe-class-members
  // eslint-disable-next-line no-dupe-class-members
  // eslint-disable-next-line no-dupe-class-members
  /**
   * Fetch a processed block from the cluster.
   */
  // eslint-disable-next-line no-dupe-class-members
  async getBlock(X, ee) {
    const {
      commitment: te,
      config: ne
    } = extractCommitmentFromConfig(ee), ie = this._buildArgsAtLeastConfirmed([X], te, void 0, ne), oe = await this._rpcRequest("getBlock", ie);
    try {
      switch (ne == null ? void 0 : ne.transactionDetails) {
        case "accounts": {
          const se = create(oe, GetAccountsModeBlockRpcResult);
          if ("error" in se)
            throw se.error;
          return se.result;
        }
        case "none": {
          const se = create(oe, GetNoneModeBlockRpcResult);
          if ("error" in se)
            throw se.error;
          return se.result;
        }
        default: {
          const se = create(oe, GetBlockRpcResult);
          if ("error" in se)
            throw se.error;
          const {
            result: ae
          } = se;
          return ae ? {
            ...ae,
            transactions: ae.transactions.map(({
              transaction: ue,
              meta: le,
              version: he
            }) => ({
              meta: le,
              transaction: {
                ...ue,
                message: versionedMessageFromResponse(he, ue.message)
              },
              version: he
            }))
          } : null;
        }
      }
    } catch (se) {
      throw new SolanaJSONRPCError(se, "failed to get confirmed block");
    }
  }
  /**
   * Fetch parsed transaction details for a confirmed or finalized block
   */
  // eslint-disable-next-line no-dupe-class-members
  // eslint-disable-next-line no-dupe-class-members
  // eslint-disable-next-line no-dupe-class-members
  async getParsedBlock(X, ee) {
    const {
      commitment: te,
      config: ne
    } = extractCommitmentFromConfig(ee), ie = this._buildArgsAtLeastConfirmed([X], te, "jsonParsed", ne), oe = await this._rpcRequest("getBlock", ie);
    try {
      switch (ne == null ? void 0 : ne.transactionDetails) {
        case "accounts": {
          const se = create(oe, GetParsedAccountsModeBlockRpcResult);
          if ("error" in se)
            throw se.error;
          return se.result;
        }
        case "none": {
          const se = create(oe, GetParsedNoneModeBlockRpcResult);
          if ("error" in se)
            throw se.error;
          return se.result;
        }
        default: {
          const se = create(oe, GetParsedBlockRpcResult);
          if ("error" in se)
            throw se.error;
          return se.result;
        }
      }
    } catch (se) {
      throw new SolanaJSONRPCError(se, "failed to get block");
    }
  }
  /*
   * Returns recent block production information from the current or previous epoch
   */
  async getBlockProduction(X) {
    let ee, te;
    if (typeof X == "string")
      te = X;
    else if (X) {
      const {
        commitment: se,
        ...ae
      } = X;
      te = se, ee = ae;
    }
    const ne = this._buildArgs([], te, "base64", ee), ie = await this._rpcRequest("getBlockProduction", ne), oe = create(ie, BlockProductionResponseStruct);
    if ("error" in oe)
      throw new SolanaJSONRPCError(oe.error, "failed to get block production information");
    return oe.result;
  }
  /**
   * Fetch a confirmed or finalized transaction from the cluster.
   *
   * @deprecated Instead, call `getTransaction` using a
   * `GetVersionedTransactionConfig` by setting the
   * `maxSupportedTransactionVersion` property.
   */
  /**
   * Fetch a confirmed or finalized transaction from the cluster.
   */
  // eslint-disable-next-line no-dupe-class-members
  /**
   * Fetch a confirmed or finalized transaction from the cluster.
   */
  // eslint-disable-next-line no-dupe-class-members
  async getTransaction(X, ee) {
    const {
      commitment: te,
      config: ne
    } = extractCommitmentFromConfig(ee), ie = this._buildArgsAtLeastConfirmed([X], te, void 0, ne), oe = await this._rpcRequest("getTransaction", ie), se = create(oe, GetTransactionRpcResult);
    if ("error" in se)
      throw new SolanaJSONRPCError(se.error, "failed to get transaction");
    const ae = se.result;
    return ae && {
      ...ae,
      transaction: {
        ...ae.transaction,
        message: versionedMessageFromResponse(ae.version, ae.transaction.message)
      }
    };
  }
  /**
   * Fetch parsed transaction details for a confirmed or finalized transaction
   */
  async getParsedTransaction(X, ee) {
    const {
      commitment: te,
      config: ne
    } = extractCommitmentFromConfig(ee), ie = this._buildArgsAtLeastConfirmed([X], te, "jsonParsed", ne), oe = await this._rpcRequest("getTransaction", ie), se = create(oe, GetParsedTransactionRpcResult);
    if ("error" in se)
      throw new SolanaJSONRPCError(se.error, "failed to get transaction");
    return se.result;
  }
  /**
   * Fetch parsed transaction details for a batch of confirmed transactions
   */
  async getParsedTransactions(X, ee) {
    const {
      commitment: te,
      config: ne
    } = extractCommitmentFromConfig(ee), ie = X.map((oe) => ({
      methodName: "getTransaction",
      args: this._buildArgsAtLeastConfirmed([oe], te, "jsonParsed", ne)
    }));
    return (await this._rpcBatchRequest(ie)).map((oe) => {
      const se = create(oe, GetParsedTransactionRpcResult);
      if ("error" in se)
        throw new SolanaJSONRPCError(se.error, "failed to get transactions");
      return se.result;
    });
  }
  /**
   * Fetch transaction details for a batch of confirmed transactions.
   * Similar to {@link getParsedTransactions} but returns a {@link TransactionResponse}.
   *
   * @deprecated Instead, call `getTransactions` using a
   * `GetVersionedTransactionConfig` by setting the
   * `maxSupportedTransactionVersion` property.
   */
  /**
   * Fetch transaction details for a batch of confirmed transactions.
   * Similar to {@link getParsedTransactions} but returns a {@link
   * VersionedTransactionResponse}.
   */
  // eslint-disable-next-line no-dupe-class-members
  /**
   * Fetch transaction details for a batch of confirmed transactions.
   * Similar to {@link getParsedTransactions} but returns a {@link
   * VersionedTransactionResponse}.
   */
  // eslint-disable-next-line no-dupe-class-members
  async getTransactions(X, ee) {
    const {
      commitment: te,
      config: ne
    } = extractCommitmentFromConfig(ee), ie = X.map((oe) => ({
      methodName: "getTransaction",
      args: this._buildArgsAtLeastConfirmed([oe], te, void 0, ne)
    }));
    return (await this._rpcBatchRequest(ie)).map((oe) => {
      const se = create(oe, GetTransactionRpcResult);
      if ("error" in se)
        throw new SolanaJSONRPCError(se.error, "failed to get transactions");
      const ae = se.result;
      return ae && {
        ...ae,
        transaction: {
          ...ae.transaction,
          message: versionedMessageFromResponse(ae.version, ae.transaction.message)
        }
      };
    });
  }
  /**
   * Fetch a list of Transactions and transaction statuses from the cluster
   * for a confirmed block.
   *
   * @deprecated Deprecated since v1.13.0. Please use {@link getBlock} instead.
   */
  async getConfirmedBlock(X, ee) {
    const te = this._buildArgsAtLeastConfirmed([X], ee), ne = await this._rpcRequest("getConfirmedBlock", te), ie = create(ne, GetConfirmedBlockRpcResult);
    if ("error" in ie)
      throw new SolanaJSONRPCError(ie.error, "failed to get confirmed block");
    const oe = ie.result;
    if (!oe)
      throw new Error("Confirmed block " + X + " not found");
    const se = {
      ...oe,
      transactions: oe.transactions.map(({
        transaction: ae,
        meta: ue
      }) => {
        const le = new Message(ae.message);
        return {
          meta: ue,
          transaction: {
            ...ae,
            message: le
          }
        };
      })
    };
    return {
      ...se,
      transactions: se.transactions.map(({
        transaction: ae,
        meta: ue
      }) => ({
        meta: ue,
        transaction: Transaction.populate(ae.message, ae.signatures)
      }))
    };
  }
  /**
   * Fetch confirmed blocks between two slots
   */
  async getBlocks(X, ee, te) {
    const ne = this._buildArgsAtLeastConfirmed(ee !== void 0 ? [X, ee] : [X], te), ie = await this._rpcRequest("getBlocks", ne), oe = create(ie, jsonRpcResult(array(number())));
    if ("error" in oe)
      throw new SolanaJSONRPCError(oe.error, "failed to get blocks");
    return oe.result;
  }
  /**
   * Fetch a list of Signatures from the cluster for a block, excluding rewards
   */
  async getBlockSignatures(X, ee) {
    const te = this._buildArgsAtLeastConfirmed([X], ee, void 0, {
      transactionDetails: "signatures",
      rewards: !1
    }), ne = await this._rpcRequest("getBlock", te), ie = create(ne, GetBlockSignaturesRpcResult);
    if ("error" in ie)
      throw new SolanaJSONRPCError(ie.error, "failed to get block");
    const oe = ie.result;
    if (!oe)
      throw new Error("Block " + X + " not found");
    return oe;
  }
  /**
   * Fetch a list of Signatures from the cluster for a confirmed block, excluding rewards
   *
   * @deprecated Deprecated since Solana v1.8.0. Please use {@link getBlockSignatures} instead.
   */
  async getConfirmedBlockSignatures(X, ee) {
    const te = this._buildArgsAtLeastConfirmed([X], ee, void 0, {
      transactionDetails: "signatures",
      rewards: !1
    }), ne = await this._rpcRequest("getConfirmedBlock", te), ie = create(ne, GetBlockSignaturesRpcResult);
    if ("error" in ie)
      throw new SolanaJSONRPCError(ie.error, "failed to get confirmed block");
    const oe = ie.result;
    if (!oe)
      throw new Error("Confirmed block " + X + " not found");
    return oe;
  }
  /**
   * Fetch a transaction details for a confirmed transaction
   *
   * @deprecated Deprecated since Solana v1.8.0. Please use {@link getTransaction} instead.
   */
  async getConfirmedTransaction(X, ee) {
    const te = this._buildArgsAtLeastConfirmed([X], ee), ne = await this._rpcRequest("getConfirmedTransaction", te), ie = create(ne, GetTransactionRpcResult);
    if ("error" in ie)
      throw new SolanaJSONRPCError(ie.error, "failed to get transaction");
    const oe = ie.result;
    if (!oe)
      return oe;
    const se = new Message(oe.transaction.message), ae = oe.transaction.signatures;
    return {
      ...oe,
      transaction: Transaction.populate(se, ae)
    };
  }
  /**
   * Fetch parsed transaction details for a confirmed transaction
   *
   * @deprecated Deprecated since Solana v1.8.0. Please use {@link getParsedTransaction} instead.
   */
  async getParsedConfirmedTransaction(X, ee) {
    const te = this._buildArgsAtLeastConfirmed([X], ee, "jsonParsed"), ne = await this._rpcRequest("getConfirmedTransaction", te), ie = create(ne, GetParsedTransactionRpcResult);
    if ("error" in ie)
      throw new SolanaJSONRPCError(ie.error, "failed to get confirmed transaction");
    return ie.result;
  }
  /**
   * Fetch parsed transaction details for a batch of confirmed transactions
   *
   * @deprecated Deprecated since Solana v1.8.0. Please use {@link getParsedTransactions} instead.
   */
  async getParsedConfirmedTransactions(X, ee) {
    const te = X.map((ne) => ({
      methodName: "getConfirmedTransaction",
      args: this._buildArgsAtLeastConfirmed([ne], ee, "jsonParsed")
    }));
    return (await this._rpcBatchRequest(te)).map((ne) => {
      const ie = create(ne, GetParsedTransactionRpcResult);
      if ("error" in ie)
        throw new SolanaJSONRPCError(ie.error, "failed to get confirmed transactions");
      return ie.result;
    });
  }
  /**
   * Fetch a list of all the confirmed signatures for transactions involving an address
   * within a specified slot range. Max range allowed is 10,000 slots.
   *
   * @deprecated Deprecated since v1.3. Please use {@link getConfirmedSignaturesForAddress2} instead.
   *
   * @param address queried address
   * @param startSlot start slot, inclusive
   * @param endSlot end slot, inclusive
   */
  async getConfirmedSignaturesForAddress(X, ee, te) {
    let ne = {}, ie = await this.getFirstAvailableBlock();
    for (; !("until" in ne) && (ee--, !(ee <= 0 || ee < ie)); )
      try {
        const se = await this.getConfirmedBlockSignatures(ee, "finalized");
        se.signatures.length > 0 && (ne.until = se.signatures[se.signatures.length - 1].toString());
      } catch (se) {
        if (se instanceof Error && se.message.includes("skipped"))
          continue;
        throw se;
      }
    let oe = await this.getSlot("finalized");
    for (; !("before" in ne) && (te++, !(te > oe)); )
      try {
        const se = await this.getConfirmedBlockSignatures(te);
        se.signatures.length > 0 && (ne.before = se.signatures[se.signatures.length - 1].toString());
      } catch (se) {
        if (se instanceof Error && se.message.includes("skipped"))
          continue;
        throw se;
      }
    return (await this.getConfirmedSignaturesForAddress2(X, ne)).map((se) => se.signature);
  }
  /**
   * Returns confirmed signatures for transactions involving an
   * address backwards in time from the provided signature or most recent confirmed block
   *
   *
   * @param address queried address
   * @param options
   */
  async getConfirmedSignaturesForAddress2(X, ee, te) {
    const ne = this._buildArgsAtLeastConfirmed([X.toBase58()], te, void 0, ee), ie = await this._rpcRequest("getConfirmedSignaturesForAddress2", ne), oe = create(ie, GetConfirmedSignaturesForAddress2RpcResult);
    if ("error" in oe)
      throw new SolanaJSONRPCError(oe.error, "failed to get confirmed signatures for address");
    return oe.result;
  }
  /**
   * Returns confirmed signatures for transactions involving an
   * address backwards in time from the provided signature or most recent confirmed block
   *
   *
   * @param address queried address
   * @param options
   */
  async getSignaturesForAddress(X, ee, te) {
    const ne = this._buildArgsAtLeastConfirmed([X.toBase58()], te, void 0, ee), ie = await this._rpcRequest("getSignaturesForAddress", ne), oe = create(ie, GetSignaturesForAddressRpcResult);
    if ("error" in oe)
      throw new SolanaJSONRPCError(oe.error, "failed to get signatures for address");
    return oe.result;
  }
  async getAddressLookupTable(X, ee) {
    const {
      context: te,
      value: ne
    } = await this.getAccountInfoAndContext(X, ee);
    let ie = null;
    return ne !== null && (ie = new AddressLookupTableAccount({
      key: X,
      state: AddressLookupTableAccount.deserialize(ne.data)
    })), {
      context: te,
      value: ie
    };
  }
  /**
   * Fetch the contents of a Nonce account from the cluster, return with context
   */
  async getNonceAndContext(X, ee) {
    const {
      context: te,
      value: ne
    } = await this.getAccountInfoAndContext(X, ee);
    let ie = null;
    return ne !== null && (ie = NonceAccount.fromAccountData(ne.data)), {
      context: te,
      value: ie
    };
  }
  /**
   * Fetch the contents of a Nonce account from the cluster
   */
  async getNonce(X, ee) {
    return await this.getNonceAndContext(X, ee).then((te) => te.value).catch((te) => {
      throw new Error("failed to get nonce for account " + X.toBase58() + ": " + te);
    });
  }
  /**
   * Request an allocation of lamports to the specified address
   *
   * ```typescript
   * import { Connection, PublicKey, LAMPORTS_PER_SOL } from "@solana/web3.js";
   *
   * (async () => {
   *   const connection = new Connection("https://api.testnet.solana.com", "confirmed");
   *   const myAddress = new PublicKey("2nr1bHFT86W9tGnyvmYW4vcHKsQB3sVQfnddasz4kExM");
   *   const signature = await connection.requestAirdrop(myAddress, LAMPORTS_PER_SOL);
   *   await connection.confirmTransaction(signature);
   * })();
   * ```
   */
  async requestAirdrop(X, ee) {
    const te = await this._rpcRequest("requestAirdrop", [X.toBase58(), ee]), ne = create(te, RequestAirdropRpcResult);
    if ("error" in ne)
      throw new SolanaJSONRPCError(ne.error, `airdrop to ${X.toBase58()} failed`);
    return ne.result;
  }
  /**
   * @internal
   */
  async _blockhashWithExpiryBlockHeight(X) {
    if (!X) {
      for (; this._pollingBlockhash; )
        await sleep(100);
      const ee = Date.now() - this._blockhashInfo.lastFetch >= BLOCKHASH_CACHE_TIMEOUT_MS;
      if (this._blockhashInfo.latestBlockhash !== null && !ee)
        return this._blockhashInfo.latestBlockhash;
    }
    return await this._pollNewBlockhash();
  }
  /**
   * @internal
   */
  async _pollNewBlockhash() {
    this._pollingBlockhash = !0;
    try {
      const X = Date.now(), ee = this._blockhashInfo.latestBlockhash, te = ee ? ee.blockhash : null;
      for (let ne = 0; ne < 50; ne++) {
        const ie = await this.getLatestBlockhash("finalized");
        if (te !== ie.blockhash)
          return this._blockhashInfo = {
            latestBlockhash: ie,
            lastFetch: Date.now(),
            transactionSignatures: [],
            simulatedSignatures: []
          }, ie;
        await sleep(MS_PER_SLOT / 2);
      }
      throw new Error(`Unable to obtain a new blockhash after ${Date.now() - X}ms`);
    } finally {
      this._pollingBlockhash = !1;
    }
  }
  /**
   * get the stake minimum delegation
   */
  async getStakeMinimumDelegation(X) {
    const {
      commitment: ee,
      config: te
    } = extractCommitmentFromConfig(X), ne = this._buildArgs([], ee, "base64", te), ie = await this._rpcRequest("getStakeMinimumDelegation", ne), oe = create(ie, jsonRpcResultAndContext(number()));
    if ("error" in oe)
      throw new SolanaJSONRPCError(oe.error, "failed to get stake minimum delegation");
    return oe.result;
  }
  /**
   * Simulate a transaction
   *
   * @deprecated Instead, call {@link simulateTransaction} with {@link
   * VersionedTransaction} and {@link SimulateTransactionConfig} parameters
   */
  /**
   * Simulate a transaction
   */
  // eslint-disable-next-line no-dupe-class-members
  /**
   * Simulate a transaction
   */
  // eslint-disable-next-line no-dupe-class-members
  async simulateTransaction(X, ee, te) {
    if ("message" in X) {
      const ye = X.serialize(), we = Buffer$1$1.from(ye).toString("base64");
      if (Array.isArray(ee) || te !== void 0)
        throw new Error("Invalid arguments");
      const Ee = ee || {};
      Ee.encoding = "base64", "commitment" in Ee || (Ee.commitment = this.commitment);
      const Re = [we, Ee], Ue = await this._rpcRequest("simulateTransaction", Re), Me = create(Ue, SimulatedTransactionResponseStruct);
      if ("error" in Me)
        throw new Error("failed to simulate transaction: " + Me.error.message);
      return Me.result;
    }
    let ne;
    if (X instanceof Transaction) {
      let ye = X;
      ne = new Transaction(), ne.feePayer = ye.feePayer, ne.instructions = X.instructions, ne.nonceInfo = ye.nonceInfo, ne.signatures = ye.signatures;
    } else
      ne = Transaction.populate(X), ne._message = ne._json = void 0;
    if (ee !== void 0 && !Array.isArray(ee))
      throw new Error("Invalid arguments");
    const ie = ee;
    if (ne.nonceInfo && ie)
      ne.sign(...ie);
    else {
      let ye = this._disableBlockhashCaching;
      for (; ; ) {
        const we = await this._blockhashWithExpiryBlockHeight(ye);
        if (ne.lastValidBlockHeight = we.lastValidBlockHeight, ne.recentBlockhash = we.blockhash, !ie)
          break;
        if (ne.sign(...ie), !ne.signature)
          throw new Error("!signature");
        const Ee = ne.signature.toString("base64");
        if (!this._blockhashInfo.simulatedSignatures.includes(Ee) && !this._blockhashInfo.transactionSignatures.includes(Ee)) {
          this._blockhashInfo.simulatedSignatures.push(Ee);
          break;
        } else
          ye = !0;
      }
    }
    const oe = ne._compile(), se = oe.serialize(), ae = ne._serialize(se).toString("base64"), ue = {
      encoding: "base64",
      commitment: this.commitment
    };
    if (te) {
      const ye = (Array.isArray(te) ? te : oe.nonProgramIds()).map((we) => we.toBase58());
      ue.accounts = {
        encoding: "base64",
        addresses: ye
      };
    }
    ie && (ue.sigVerify = !0);
    const le = [ae, ue], he = await this._rpcRequest("simulateTransaction", le), me = create(he, SimulatedTransactionResponseStruct);
    if ("error" in me) {
      let ye;
      if ("data" in me.error && (ye = me.error.data.logs, ye && Array.isArray(ye))) {
        const we = `
    `, Ee = we + ye.join(we);
        console.error(me.error.message, Ee);
      }
      throw new SendTransactionError("failed to simulate transaction: " + me.error.message, ye);
    }
    return me.result;
  }
  /**
   * Sign and send a transaction
   *
   * @deprecated Instead, call {@link sendTransaction} with a {@link
   * VersionedTransaction}
   */
  /**
   * Send a signed transaction
   */
  // eslint-disable-next-line no-dupe-class-members
  /**
   * Sign and send a transaction
   */
  // eslint-disable-next-line no-dupe-class-members
  async sendTransaction(X, ee, te) {
    if ("version" in X) {
      if (ee && Array.isArray(ee))
        throw new Error("Invalid arguments");
      const oe = X.serialize();
      return await this.sendRawTransaction(oe, ee);
    }
    if (ee === void 0 || !Array.isArray(ee))
      throw new Error("Invalid arguments");
    const ne = ee;
    if (X.nonceInfo)
      X.sign(...ne);
    else {
      let oe = this._disableBlockhashCaching;
      for (; ; ) {
        const se = await this._blockhashWithExpiryBlockHeight(oe);
        if (X.lastValidBlockHeight = se.lastValidBlockHeight, X.recentBlockhash = se.blockhash, X.sign(...ne), !X.signature)
          throw new Error("!signature");
        const ae = X.signature.toString("base64");
        if (this._blockhashInfo.transactionSignatures.includes(ae))
          oe = !0;
        else {
          this._blockhashInfo.transactionSignatures.push(ae);
          break;
        }
      }
    }
    const ie = X.serialize();
    return await this.sendRawTransaction(ie, te);
  }
  /**
   * Send a transaction that has already been signed and serialized into the
   * wire format
   */
  async sendRawTransaction(X, ee) {
    const te = toBuffer(X).toString("base64");
    return await this.sendEncodedTransaction(te, ee);
  }
  /**
   * Send a transaction that has already been signed, serialized into the
   * wire format, and encoded as a base64 string
   */
  async sendEncodedTransaction(X, ee) {
    const te = {
      encoding: "base64"
    }, ne = ee && ee.skipPreflight, ie = ee && ee.preflightCommitment || this.commitment;
    ee && ee.maxRetries != null && (te.maxRetries = ee.maxRetries), ee && ee.minContextSlot != null && (te.minContextSlot = ee.minContextSlot), ne && (te.skipPreflight = ne), ie && (te.preflightCommitment = ie);
    const oe = [X, te], se = await this._rpcRequest("sendTransaction", oe), ae = create(se, SendTransactionRpcResult);
    if ("error" in ae) {
      let ue;
      throw "data" in ae.error && (ue = ae.error.data.logs), new SendTransactionError("failed to send transaction: " + ae.error.message, ue);
    }
    return ae.result;
  }
  /**
   * @internal
   */
  _wsOnOpen() {
    this._rpcWebSocketConnected = !0, this._rpcWebSocketHeartbeat = setInterval(() => {
      (async () => {
        try {
          await this._rpcWebSocket.notify("ping");
        } catch {
        }
      })();
    }, 5e3), this._updateSubscriptions();
  }
  /**
   * @internal
   */
  _wsOnError(X) {
    this._rpcWebSocketConnected = !1, console.error("ws error:", X.message);
  }
  /**
   * @internal
   */
  _wsOnClose(X) {
    if (this._rpcWebSocketConnected = !1, this._rpcWebSocketGeneration = (this._rpcWebSocketGeneration + 1) % Number.MAX_SAFE_INTEGER, this._rpcWebSocketIdleTimeout && (clearTimeout(this._rpcWebSocketIdleTimeout), this._rpcWebSocketIdleTimeout = null), this._rpcWebSocketHeartbeat && (clearInterval(this._rpcWebSocketHeartbeat), this._rpcWebSocketHeartbeat = null), X === 1e3) {
      this._updateSubscriptions();
      return;
    }
    this._subscriptionCallbacksByServerSubscriptionId = {}, Object.entries(this._subscriptionsByHash).forEach(([ee, te]) => {
      this._setSubscription(ee, {
        ...te,
        state: "pending"
      });
    });
  }
  /**
   * @internal
   */
  _setSubscription(X, ee) {
    var te;
    const ne = (te = this._subscriptionsByHash[X]) == null ? void 0 : te.state;
    if (this._subscriptionsByHash[X] = ee, ne !== ee.state) {
      const ie = this._subscriptionStateChangeCallbacksByHash[X];
      ie && ie.forEach((oe) => {
        try {
          oe(ee.state);
        } catch {
        }
      });
    }
  }
  /**
   * @internal
   */
  _onSubscriptionStateChange(X, ee) {
    var te;
    const ne = this._subscriptionHashByClientSubscriptionId[X];
    if (ne == null)
      return () => {
      };
    const ie = (te = this._subscriptionStateChangeCallbacksByHash)[ne] || (te[ne] = /* @__PURE__ */ new Set());
    return ie.add(ee), () => {
      ie.delete(ee), ie.size === 0 && delete this._subscriptionStateChangeCallbacksByHash[ne];
    };
  }
  /**
   * @internal
   */
  async _updateSubscriptions() {
    if (Object.keys(this._subscriptionsByHash).length === 0) {
      this._rpcWebSocketConnected && (this._rpcWebSocketConnected = !1, this._rpcWebSocketIdleTimeout = setTimeout(() => {
        this._rpcWebSocketIdleTimeout = null;
        try {
          this._rpcWebSocket.close();
        } catch (te) {
          te instanceof Error && console.log(`Error when closing socket connection: ${te.message}`);
        }
      }, 500));
      return;
    }
    if (this._rpcWebSocketIdleTimeout !== null && (clearTimeout(this._rpcWebSocketIdleTimeout), this._rpcWebSocketIdleTimeout = null, this._rpcWebSocketConnected = !0), !this._rpcWebSocketConnected) {
      this._rpcWebSocket.connect();
      return;
    }
    const X = this._rpcWebSocketGeneration, ee = () => X === this._rpcWebSocketGeneration;
    await Promise.all(
      // Don't be tempted to change this to `Object.entries`. We call
      // `_updateSubscriptions` recursively when processing the state,
      // so it's important that we look up the *current* version of
      // each subscription, every time we process a hash.
      Object.keys(this._subscriptionsByHash).map(async (te) => {
        const ne = this._subscriptionsByHash[te];
        if (ne !== void 0)
          switch (ne.state) {
            case "pending":
            case "unsubscribed":
              if (ne.callbacks.size === 0) {
                delete this._subscriptionsByHash[te], ne.state === "unsubscribed" && delete this._subscriptionCallbacksByServerSubscriptionId[ne.serverSubscriptionId], await this._updateSubscriptions();
                return;
              }
              await (async () => {
                const {
                  args: ie,
                  method: oe
                } = ne;
                try {
                  this._setSubscription(te, {
                    ...ne,
                    state: "subscribing"
                  });
                  const se = await this._rpcWebSocket.call(oe, ie);
                  this._setSubscription(te, {
                    ...ne,
                    serverSubscriptionId: se,
                    state: "subscribed"
                  }), this._subscriptionCallbacksByServerSubscriptionId[se] = ne.callbacks, await this._updateSubscriptions();
                } catch (se) {
                  if (se instanceof Error && console.error(`${oe} error for argument`, ie, se.message), !ee())
                    return;
                  this._setSubscription(te, {
                    ...ne,
                    state: "pending"
                  }), await this._updateSubscriptions();
                }
              })();
              break;
            case "subscribed":
              ne.callbacks.size === 0 && await (async () => {
                const {
                  serverSubscriptionId: ie,
                  unsubscribeMethod: oe
                } = ne;
                if (this._subscriptionsAutoDisposedByRpc.has(ie))
                  this._subscriptionsAutoDisposedByRpc.delete(ie);
                else {
                  this._setSubscription(te, {
                    ...ne,
                    state: "unsubscribing"
                  }), this._setSubscription(te, {
                    ...ne,
                    state: "unsubscribing"
                  });
                  try {
                    await this._rpcWebSocket.call(oe, [ie]);
                  } catch (se) {
                    if (se instanceof Error && console.error(`${oe} error:`, se.message), !ee())
                      return;
                    this._setSubscription(te, {
                      ...ne,
                      state: "subscribed"
                    }), await this._updateSubscriptions();
                    return;
                  }
                }
                this._setSubscription(te, {
                  ...ne,
                  state: "unsubscribed"
                }), await this._updateSubscriptions();
              })();
              break;
          }
      })
    );
  }
  /**
   * @internal
   */
  _handleServerNotification(X, ee) {
    const te = this._subscriptionCallbacksByServerSubscriptionId[X];
    te !== void 0 && te.forEach((ne) => {
      try {
        ne(
          ...ee
        );
      } catch (ie) {
        console.error(ie);
      }
    });
  }
  /**
   * @internal
   */
  _wsOnAccountNotification(X) {
    const {
      result: ee,
      subscription: te
    } = create(X, AccountNotificationResult);
    this._handleServerNotification(te, [ee.value, ee.context]);
  }
  /**
   * @internal
   */
  _makeSubscription(X, ee) {
    const te = this._nextClientSubscriptionId++, ne = fastStableStringify$1(
      [X.method, ee],
      !0
      /* isArrayProp */
    ), ie = this._subscriptionsByHash[ne];
    return ie === void 0 ? this._subscriptionsByHash[ne] = {
      ...X,
      args: ee,
      callbacks: /* @__PURE__ */ new Set([X.callback]),
      state: "pending"
    } : ie.callbacks.add(X.callback), this._subscriptionHashByClientSubscriptionId[te] = ne, this._subscriptionDisposeFunctionsByClientSubscriptionId[te] = async () => {
      delete this._subscriptionDisposeFunctionsByClientSubscriptionId[te], delete this._subscriptionHashByClientSubscriptionId[te];
      const oe = this._subscriptionsByHash[ne];
      assert(oe !== void 0, `Could not find a \`Subscription\` when tearing down client subscription #${te}`), oe.callbacks.delete(X.callback), await this._updateSubscriptions();
    }, this._updateSubscriptions(), te;
  }
  /**
   * Register a callback to be invoked whenever the specified account changes
   *
   * @param publicKey Public key of the account to monitor
   * @param callback Function to invoke whenever the account is changed
   * @param commitment Specify the commitment level account changes must reach before notification
   * @return subscription id
   */
  onAccountChange(X, ee, te) {
    const ne = this._buildArgs(
      [X.toBase58()],
      te || this._commitment || "finalized",
      // Apply connection/server default.
      "base64"
    );
    return this._makeSubscription({
      callback: ee,
      method: "accountSubscribe",
      unsubscribeMethod: "accountUnsubscribe"
    }, ne);
  }
  /**
   * Deregister an account notification callback
   *
   * @param id client subscription id to deregister
   */
  async removeAccountChangeListener(X) {
    await this._unsubscribeClientSubscription(X, "account change");
  }
  /**
   * @internal
   */
  _wsOnProgramAccountNotification(X) {
    const {
      result: ee,
      subscription: te
    } = create(X, ProgramAccountNotificationResult);
    this._handleServerNotification(te, [{
      accountId: ee.value.pubkey,
      accountInfo: ee.value.account
    }, ee.context]);
  }
  /**
   * Register a callback to be invoked whenever accounts owned by the
   * specified program change
   *
   * @param programId Public key of the program to monitor
   * @param callback Function to invoke whenever the account is changed
   * @param commitment Specify the commitment level account changes must reach before notification
   * @param filters The program account filters to pass into the RPC method
   * @return subscription id
   */
  onProgramAccountChange(X, ee, te, ne) {
    const ie = this._buildArgs(
      [X.toBase58()],
      te || this._commitment || "finalized",
      // Apply connection/server default.
      "base64",
      ne ? {
        filters: ne
      } : void 0
      /* extra */
    );
    return this._makeSubscription({
      callback: ee,
      method: "programSubscribe",
      unsubscribeMethod: "programUnsubscribe"
    }, ie);
  }
  /**
   * Deregister an account notification callback
   *
   * @param id client subscription id to deregister
   */
  async removeProgramAccountChangeListener(X) {
    await this._unsubscribeClientSubscription(X, "program account change");
  }
  /**
   * Registers a callback to be invoked whenever logs are emitted.
   */
  onLogs(X, ee, te) {
    const ne = this._buildArgs(
      [typeof X == "object" ? {
        mentions: [X.toString()]
      } : X],
      te || this._commitment || "finalized"
      // Apply connection/server default.
    );
    return this._makeSubscription({
      callback: ee,
      method: "logsSubscribe",
      unsubscribeMethod: "logsUnsubscribe"
    }, ne);
  }
  /**
   * Deregister a logs callback.
   *
   * @param id client subscription id to deregister.
   */
  async removeOnLogsListener(X) {
    await this._unsubscribeClientSubscription(X, "logs");
  }
  /**
   * @internal
   */
  _wsOnLogsNotification(X) {
    const {
      result: ee,
      subscription: te
    } = create(X, LogsNotificationResult);
    this._handleServerNotification(te, [ee.value, ee.context]);
  }
  /**
   * @internal
   */
  _wsOnSlotNotification(X) {
    const {
      result: ee,
      subscription: te
    } = create(X, SlotNotificationResult);
    this._handleServerNotification(te, [ee]);
  }
  /**
   * Register a callback to be invoked upon slot changes
   *
   * @param callback Function to invoke whenever the slot changes
   * @return subscription id
   */
  onSlotChange(X) {
    return this._makeSubscription(
      {
        callback: X,
        method: "slotSubscribe",
        unsubscribeMethod: "slotUnsubscribe"
      },
      []
      /* args */
    );
  }
  /**
   * Deregister a slot notification callback
   *
   * @param id client subscription id to deregister
   */
  async removeSlotChangeListener(X) {
    await this._unsubscribeClientSubscription(X, "slot change");
  }
  /**
   * @internal
   */
  _wsOnSlotUpdatesNotification(X) {
    const {
      result: ee,
      subscription: te
    } = create(X, SlotUpdateNotificationResult);
    this._handleServerNotification(te, [ee]);
  }
  /**
   * Register a callback to be invoked upon slot updates. {@link SlotUpdate}'s
   * may be useful to track live progress of a cluster.
   *
   * @param callback Function to invoke whenever the slot updates
   * @return subscription id
   */
  onSlotUpdate(X) {
    return this._makeSubscription(
      {
        callback: X,
        method: "slotsUpdatesSubscribe",
        unsubscribeMethod: "slotsUpdatesUnsubscribe"
      },
      []
      /* args */
    );
  }
  /**
   * Deregister a slot update notification callback
   *
   * @param id client subscription id to deregister
   */
  async removeSlotUpdateListener(X) {
    await this._unsubscribeClientSubscription(X, "slot update");
  }
  /**
   * @internal
   */
  async _unsubscribeClientSubscription(X, ee) {
    const te = this._subscriptionDisposeFunctionsByClientSubscriptionId[X];
    te ? await te() : console.warn(`Ignored unsubscribe request because an active subscription with id \`${X}\` for '${ee}' events could not be found.`);
  }
  _buildArgs(X, ee, te, ne) {
    const ie = ee || this._commitment;
    if (ie || te || ne) {
      let oe = {};
      te && (oe.encoding = te), ie && (oe.commitment = ie), ne && (oe = Object.assign(oe, ne)), X.push(oe);
    }
    return X;
  }
  /**
   * @internal
   */
  _buildArgsAtLeastConfirmed(X, ee, te, ne) {
    const ie = ee || this._commitment;
    if (ie && !["confirmed", "finalized"].includes(ie))
      throw new Error("Using Connection with default commitment: `" + this._commitment + "`, but method requires at least `confirmed`");
    return this._buildArgs(X, ee, te, ne);
  }
  /**
   * @internal
   */
  _wsOnSignatureNotification(X) {
    const {
      result: ee,
      subscription: te
    } = create(X, SignatureNotificationResult);
    ee.value !== "receivedSignature" && this._subscriptionsAutoDisposedByRpc.add(te), this._handleServerNotification(te, ee.value === "receivedSignature" ? [{
      type: "received"
    }, ee.context] : [{
      type: "status",
      result: ee.value
    }, ee.context]);
  }
  /**
   * Register a callback to be invoked upon signature updates
   *
   * @param signature Transaction signature string in base 58
   * @param callback Function to invoke on signature notifications
   * @param commitment Specify the commitment level signature must reach before notification
   * @return subscription id
   */
  onSignature(X, ee, te) {
    const ne = this._buildArgs(
      [X],
      te || this._commitment || "finalized"
      // Apply connection/server default.
    ), ie = this._makeSubscription({
      callback: (oe, se) => {
        if (oe.type === "status") {
          ee(oe.result, se);
          try {
            this.removeSignatureListener(ie);
          } catch {
          }
        }
      },
      method: "signatureSubscribe",
      unsubscribeMethod: "signatureUnsubscribe"
    }, ne);
    return ie;
  }
  /**
   * Register a callback to be invoked when a transaction is
   * received and/or processed.
   *
   * @param signature Transaction signature string in base 58
   * @param callback Function to invoke on signature notifications
   * @param options Enable received notifications and set the commitment
   *   level that signature must reach before notification
   * @return subscription id
   */
  onSignatureWithOptions(X, ee, te) {
    const {
      commitment: ne,
      ...ie
    } = {
      ...te,
      commitment: te && te.commitment || this._commitment || "finalized"
      // Apply connection/server default.
    }, oe = this._buildArgs([X], ne, void 0, ie), se = this._makeSubscription({
      callback: (ae, ue) => {
        ee(ae, ue);
        try {
          this.removeSignatureListener(se);
        } catch {
        }
      },
      method: "signatureSubscribe",
      unsubscribeMethod: "signatureUnsubscribe"
    }, oe);
    return se;
  }
  /**
   * Deregister a signature notification callback
   *
   * @param id client subscription id to deregister
   */
  async removeSignatureListener(X) {
    await this._unsubscribeClientSubscription(X, "signature result");
  }
  /**
   * @internal
   */
  _wsOnRootNotification(X) {
    const {
      result: ee,
      subscription: te
    } = create(X, RootNotificationResult);
    this._handleServerNotification(te, [ee]);
  }
  /**
   * Register a callback to be invoked upon root changes
   *
   * @param callback Function to invoke whenever the root changes
   * @return subscription id
   */
  onRootChange(X) {
    return this._makeSubscription(
      {
        callback: X,
        method: "rootSubscribe",
        unsubscribeMethod: "rootUnsubscribe"
      },
      []
      /* args */
    );
  }
  /**
   * Deregister a root notification callback
   *
   * @param id client subscription id to deregister
   */
  async removeRootChangeListener(X) {
    await this._unsubscribeClientSubscription(X, "root change");
  }
}
class Keypair {
  /**
   * Create a new keypair instance.
   * Generate random keypair if no {@link Ed25519Keypair} is provided.
   *
   * @param {Ed25519Keypair} keypair ed25519 keypair
   */
  constructor(X) {
    this._keypair = void 0, this._keypair = X ?? generateKeypair();
  }
  /**
   * Generate a new random keypair
   *
   * @returns {Keypair} Keypair
   */
  static generate() {
    return new Keypair(generateKeypair());
  }
  /**
   * Create a keypair from a raw secret key byte array.
   *
   * This method should only be used to recreate a keypair from a previously
   * generated secret key. Generating keypairs from a random seed should be done
   * with the {@link Keypair.fromSeed} method.
   *
   * @throws error if the provided secret key is invalid and validation is not skipped.
   *
   * @param secretKey secret key byte array
   * @param options skip secret key validation
   *
   * @returns {Keypair} Keypair
   */
  static fromSecretKey(X, ee) {
    if (X.byteLength !== 64)
      throw new Error("bad secret key size");
    const te = X.slice(32, 64);
    if (!ee || !ee.skipValidation) {
      const ne = X.slice(0, 32), ie = getPublicKey(ne);
      for (let oe = 0; oe < 32; oe++)
        if (te[oe] !== ie[oe])
          throw new Error("provided secretKey is invalid");
    }
    return new Keypair({
      publicKey: te,
      secretKey: X
    });
  }
  /**
   * Generate a keypair from a 32 byte seed.
   *
   * @param seed seed byte array
   *
   * @returns {Keypair} Keypair
   */
  static fromSeed(X) {
    const ee = getPublicKey(X), te = new Uint8Array(64);
    return te.set(X), te.set(ee, 32), new Keypair({
      publicKey: ee,
      secretKey: te
    });
  }
  /**
   * The public key for this keypair
   *
   * @returns {PublicKey} PublicKey
   */
  get publicKey() {
    return new PublicKey(this._keypair.publicKey);
  }
  /**
   * The raw secret key for this keypair
   * @returns {Uint8Array} Secret key in an array of Uint8 bytes
   */
  get secretKey() {
    return new Uint8Array(this._keypair.secretKey);
  }
}
Object.freeze({
  CreateLookupTable: {
    index: 0,
    layout: struct$1([u32("instruction"), u64$1("recentSlot"), u8("bumpSeed")])
  },
  FreezeLookupTable: {
    index: 1,
    layout: struct$1([u32("instruction")])
  },
  ExtendLookupTable: {
    index: 2,
    layout: struct$1([u32("instruction"), u64$1(), seq(publicKey$1(), offset(u32(), -8), "addresses")])
  },
  DeactivateLookupTable: {
    index: 3,
    layout: struct$1([u32("instruction")])
  },
  CloseLookupTable: {
    index: 4,
    layout: struct$1([u32("instruction")])
  }
});
new PublicKey("AddressLookupTab1e1111111111111111111111111");
const COMPUTE_BUDGET_INSTRUCTION_LAYOUTS = Object.freeze({
  RequestUnits: {
    index: 0,
    layout: struct$1([u8("instruction"), u32("units"), u32("additionalFee")])
  },
  RequestHeapFrame: {
    index: 1,
    layout: struct$1([u8("instruction"), u32("bytes")])
  },
  SetComputeUnitLimit: {
    index: 2,
    layout: struct$1([u8("instruction"), u32("units")])
  },
  SetComputeUnitPrice: {
    index: 3,
    layout: struct$1([u8("instruction"), u64$1("microLamports")])
  }
});
class ComputeBudgetProgram {
  /**
   * @internal
   */
  constructor() {
  }
  /**
   * Public key that identifies the Compute Budget program
   */
  /**
   * @deprecated Instead, call {@link setComputeUnitLimit} and/or {@link setComputeUnitPrice}
   */
  static requestUnits(X) {
    const ee = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestUnits, te = encodeData(ee, X);
    return new TransactionInstruction({
      keys: [],
      programId: this.programId,
      data: te
    });
  }
  static requestHeapFrame(X) {
    const ee = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestHeapFrame, te = encodeData(ee, X);
    return new TransactionInstruction({
      keys: [],
      programId: this.programId,
      data: te
    });
  }
  static setComputeUnitLimit(X) {
    const ee = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitLimit, te = encodeData(ee, X);
    return new TransactionInstruction({
      keys: [],
      programId: this.programId,
      data: te
    });
  }
  static setComputeUnitPrice(X) {
    const ee = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitPrice, te = encodeData(ee, {
      microLamports: BigInt(X.microLamports)
    });
    return new TransactionInstruction({
      keys: [],
      programId: this.programId,
      data: te
    });
  }
}
ComputeBudgetProgram.programId = new PublicKey("ComputeBudget111111111111111111111111111111");
struct$1([u8("numSignatures"), u8("padding"), u16("signatureOffset"), u16("signatureInstructionIndex"), u16("publicKeyOffset"), u16("publicKeyInstructionIndex"), u16("messageDataOffset"), u16("messageDataSize"), u16("messageInstructionIndex")]);
new PublicKey("Ed25519SigVerify111111111111111111111111111");
secp256k1.utils.isValidPrivateKey;
secp256k1.getPublicKey;
struct$1([u8("numSignatures"), u16("signatureOffset"), u8("signatureInstructionIndex"), u16("ethAddressOffset"), u8("ethAddressInstructionIndex"), u16("messageDataOffset"), u16("messageDataSize"), u8("messageInstructionIndex"), blob$1(20, "ethAddress"), blob$1(64, "signature"), u8("recoveryId")]);
new PublicKey("KeccakSecp256k11111111111111111111111111111");
var _class2;
new PublicKey("StakeConfig11111111111111111111111111111111");
class Lockup {
  /**
   * Create a new Lockup object
   */
  constructor(X, ee, te) {
    this.unixTimestamp = void 0, this.epoch = void 0, this.custodian = void 0, this.unixTimestamp = X, this.epoch = ee, this.custodian = te;
  }
  /**
   * Default, inactive Lockup value
   */
}
_class2 = Lockup;
Lockup.default = new _class2(0, 0, PublicKey.default);
Object.freeze({
  Initialize: {
    index: 0,
    layout: struct$1([u32("instruction"), authorized(), lockup()])
  },
  Authorize: {
    index: 1,
    layout: struct$1([u32("instruction"), publicKey$1("newAuthorized"), u32("stakeAuthorizationType")])
  },
  Delegate: {
    index: 2,
    layout: struct$1([u32("instruction")])
  },
  Split: {
    index: 3,
    layout: struct$1([u32("instruction"), ns64("lamports")])
  },
  Withdraw: {
    index: 4,
    layout: struct$1([u32("instruction"), ns64("lamports")])
  },
  Deactivate: {
    index: 5,
    layout: struct$1([u32("instruction")])
  },
  Merge: {
    index: 7,
    layout: struct$1([u32("instruction")])
  },
  AuthorizeWithSeed: {
    index: 8,
    layout: struct$1([u32("instruction"), publicKey$1("newAuthorized"), u32("stakeAuthorizationType"), rustString("authoritySeed"), publicKey$1("authorityOwner")])
  }
});
new PublicKey("Stake11111111111111111111111111111111111111");
Object.freeze({
  InitializeAccount: {
    index: 0,
    layout: struct$1([u32("instruction"), voteInit()])
  },
  Authorize: {
    index: 1,
    layout: struct$1([u32("instruction"), publicKey$1("newAuthorized"), u32("voteAuthorizationType")])
  },
  Withdraw: {
    index: 3,
    layout: struct$1([u32("instruction"), ns64("lamports")])
  },
  AuthorizeWithSeed: {
    index: 10,
    layout: struct$1([u32("instruction"), voteAuthorizeWithSeedArgs()])
  }
});
new PublicKey("Vote111111111111111111111111111111111111111");
new PublicKey("Va1idator1nfo111111111111111111111111111111");
type({
  name: string(),
  website: optional(string()),
  details: optional(string()),
  keybaseUsername: optional(string())
});
new PublicKey("Vote111111111111111111111111111111111111111");
struct$1([
  publicKey$1("nodePubkey"),
  publicKey$1("authorizedWithdrawer"),
  u8("commission"),
  nu64$1(),
  // votes.length
  seq(struct$1([nu64$1("slot"), u32("confirmationCount")]), offset(u32(), -8), "votes"),
  u8("rootSlotValid"),
  nu64$1("rootSlot"),
  nu64$1(),
  // authorizedVoters.length
  seq(struct$1([nu64$1("epoch"), publicKey$1("authorizedVoter")]), offset(u32(), -8), "authorizedVoters"),
  struct$1([seq(struct$1([publicKey$1("authorizedPubkey"), nu64$1("epochOfLastAuthorizedSwitch"), nu64$1("targetEpoch")]), 32, "buf"), nu64$1("idx"), u8("isEmpty")], "priorVoters"),
  nu64$1(),
  // epochCredits.length
  seq(struct$1([nu64$1("epoch"), nu64$1("credits"), nu64$1("prevCredits")]), offset(u32(), -8), "epochCredits"),
  struct$1([nu64$1("slot"), nu64$1("timestamp")], "lastTimestamp")
]);
const LAMPORTS_PER_SOL = 1e9;
function base(Y) {
  if (Y.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var X = new Uint8Array(256), ee = 0; ee < X.length; ee++)
    X[ee] = 255;
  for (var te = 0; te < Y.length; te++) {
    var ne = Y.charAt(te), ie = ne.charCodeAt(0);
    if (X[ie] !== 255)
      throw new TypeError(ne + " is ambiguous");
    X[ie] = te;
  }
  var oe = Y.length, se = Y.charAt(0), ae = Math.log(oe) / Math.log(256), ue = Math.log(256) / Math.log(oe);
  function le(ye) {
    if (ye instanceof Uint8Array || (ArrayBuffer.isView(ye) ? ye = new Uint8Array(ye.buffer, ye.byteOffset, ye.byteLength) : Array.isArray(ye) && (ye = Uint8Array.from(ye))), !(ye instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (ye.length === 0)
      return "";
    for (var we = 0, Ee = 0, Re = 0, Ue = ye.length; Re !== Ue && ye[Re] === 0; )
      Re++, we++;
    for (var Me = (Ue - Re) * ue + 1 >>> 0, De = new Uint8Array(Me); Re !== Ue; ) {
      for (var Fe = ye[Re], Ke = 0, tt = Me - 1; (Fe !== 0 || Ke < Ee) && tt !== -1; tt--, Ke++)
        Fe += 256 * De[tt] >>> 0, De[tt] = Fe % oe >>> 0, Fe = Fe / oe >>> 0;
      if (Fe !== 0)
        throw new Error("Non-zero carry");
      Ee = Ke, Re++;
    }
    for (var rt = Me - Ee; rt !== Me && De[rt] === 0; )
      rt++;
    for (var it = se.repeat(we); rt < Me; ++rt)
      it += Y.charAt(De[rt]);
    return it;
  }
  function he(ye) {
    if (typeof ye != "string")
      throw new TypeError("Expected String");
    if (ye.length === 0)
      return new Uint8Array();
    for (var we = 0, Ee = 0, Re = 0; ye[we] === se; )
      Ee++, we++;
    for (var Ue = (ye.length - we) * ae + 1 >>> 0, Me = new Uint8Array(Ue); ye[we]; ) {
      var De = X[ye.charCodeAt(we)];
      if (De === 255)
        return;
      for (var Fe = 0, Ke = Ue - 1; (De !== 0 || Fe < Re) && Ke !== -1; Ke--, Fe++)
        De += oe * Me[Ke] >>> 0, Me[Ke] = De % 256 >>> 0, De = De / 256 >>> 0;
      if (De !== 0)
        throw new Error("Non-zero carry");
      Re = Fe, we++;
    }
    for (var tt = Ue - Re; tt !== Ue && Me[tt] === 0; )
      tt++;
    for (var rt = new Uint8Array(Ee + (Ue - tt)), it = Ee; tt !== Ue; )
      rt[it++] = Me[tt++];
    return rt;
  }
  function me(ye) {
    var we = he(ye);
    if (we)
      return we;
    throw new Error("Non-base" + oe + " character");
  }
  return {
    encode: le,
    decodeUnsafe: he,
    decode: me
  };
}
var src = base;
const basex = src, ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
var bs58 = basex(ALPHABET);
const bs58$1 = /* @__PURE__ */ getDefaultExportFromCjs$2(bs58);
class Layout {
  constructor(X, ee) {
    if (!Number.isInteger(X))
      throw new TypeError("span must be an integer");
    this.span = X, this.property = ee;
  }
  /** Function to create an Object into which decoded properties will
   * be written.
   *
   * Used only for layouts that {@link Layout#decode|decode} to Object
   * instances, which means:
   * * {@link Structure}
   * * {@link Union}
   * * {@link VariantLayout}
   * * {@link BitStructure}
   *
   * If left undefined the JavaScript representation of these layouts
   * will be Object instances.
   *
   * See {@link bindConstructorLayout}.
   */
  makeDestinationObject() {
    return {};
  }
  /**
   * Decode from a Buffer into an JavaScript value.
   *
   * @param {Buffer} b - the buffer from which encoded data is read.
   *
   * @param {Number} [offset] - the offset at which the encoded data
   * starts.  If absent a zero offset is inferred.
   *
   * @returns {(Number|Array|Object)} - the value of the decoded data.
   *
   * @abstract
   */
  decode(X, ee) {
    throw new Error("Layout is abstract");
  }
  /**
   * Encode a JavaScript value into a Buffer.
   *
   * @param {(Number|Array|Object)} src - the value to be encoded into
   * the buffer.  The type accepted depends on the (sub-)type of {@link
   * Layout}.
   *
   * @param {Buffer} b - the buffer into which encoded data will be
   * written.
   *
   * @param {Number} [offset] - the offset at which the encoded data
   * starts.  If absent a zero offset is inferred.
   *
   * @returns {Number} - the number of bytes encoded, including the
   * space skipped for internal padding, but excluding data such as
   * {@link Sequence#count|lengths} when stored {@link
   * ExternalLayout|externally}.  This is the adjustment to `offset`
   * producing the offset where data for the next layout would be
   * written.
   *
   * @abstract
   */
  encode(X, ee, te) {
    throw new Error("Layout is abstract");
  }
  /**
   * Calculate the span of a specific instance of a layout.
   *
   * @param {Buffer} b - the buffer that contains an encoded instance.
   *
   * @param {Number} [offset] - the offset at which the encoded instance
   * starts.  If absent a zero offset is inferred.
   *
   * @return {Number} - the number of bytes covered by the layout
   * instance.  If this method is not overridden in a subclass the
   * definition-time constant {@link Layout#span|span} will be
   * returned.
   *
   * @throws {RangeError} - if the length of the value cannot be
   * determined.
   */
  getSpan(X, ee) {
    if (0 > this.span)
      throw new RangeError("indeterminate span");
    return this.span;
  }
  /**
   * Replicate the layout using a new property.
   *
   * This function must be used to get a structurally-equivalent layout
   * with a different name since all {@link Layout} instances are
   * immutable.
   *
   * **NOTE** This is a shallow copy.  All fields except {@link
   * Layout#property|property} are strictly equal to the origin layout.
   *
   * @param {String} property - the value for {@link
   * Layout#property|property} in the replica.
   *
   * @returns {Layout} - the copy with {@link Layout#property|property}
   * set to `property`.
   */
  replicate(X) {
    const ee = Object.create(this.constructor.prototype);
    return Object.assign(ee, this), ee.property = X, ee;
  }
  /**
   * Create an object from layout properties and an array of values.
   *
   * **NOTE** This function returns `undefined` if invoked on a layout
   * that does not return its value as an Object.  Objects are
   * returned for things that are a {@link Structure}, which includes
   * {@link VariantLayout|variant layouts} if they are structures, and
   * excludes {@link Union}s.  If you want this feature for a union
   * you must use {@link Union.getVariant|getVariant} to select the
   * desired layout.
   *
   * @param {Array} values - an array of values that correspond to the
   * default order for properties.  As with {@link Layout#decode|decode}
   * layout elements that have no property name are skipped when
   * iterating over the array values.  Only the top-level properties are
   * assigned; arguments are not assigned to properties of contained
   * layouts.  Any unused values are ignored.
   *
   * @return {(Object|undefined)}
   */
  fromArray(X) {
  }
}
function nameWithProperty(Y, X) {
  return X.property ? Y + "[" + X.property + "]" : Y;
}
class ExternalLayout extends Layout {
  /**
   * Return `true` iff the external layout decodes to an unsigned
   * integer layout.
   *
   * In that case it can be used as the source of {@link
   * Sequence#count|Sequence counts}, {@link Blob#length|Blob lengths},
   * or as {@link UnionLayoutDiscriminator#layout|external union
   * discriminators}.
   *
   * @abstract
   */
  isCount() {
    throw new Error("ExternalLayout is abstract");
  }
}
const V2E32 = Math.pow(2, 32);
function divmodInt64(Y) {
  const X = Math.floor(Y / V2E32), ee = Y - X * V2E32;
  return { hi32: X, lo32: ee };
}
function roundedInt64(Y, X) {
  return Y * V2E32 + X;
}
class NearUInt64 extends Layout {
  constructor(X) {
    super(8, X);
  }
  /** @override */
  decode(X, ee) {
    ee === void 0 && (ee = 0);
    const te = X.readUInt32LE(ee), ne = X.readUInt32LE(ee + 4);
    return roundedInt64(ne, te);
  }
  /** @override */
  encode(X, ee, te) {
    te === void 0 && (te = 0);
    const ne = divmodInt64(X);
    return ee.writeUInt32LE(ne.lo32, te), ee.writeUInt32LE(ne.hi32, te + 4), 8;
  }
}
class Structure extends Layout {
  constructor(X, ee, te) {
    if (!(Array.isArray(X) && X.reduce((ie, oe) => ie && oe instanceof Layout, !0)))
      throw new TypeError("fields must be array of Layout instances");
    typeof ee == "boolean" && te === void 0 && (te = ee, ee = void 0);
    for (const ie of X)
      if (0 > ie.span && ie.property === void 0)
        throw new Error("fields cannot contain unnamed variable-length layout");
    let ne = -1;
    try {
      ne = X.reduce((ie, oe) => ie + oe.getSpan(), 0);
    } catch {
    }
    super(ne, ee), this.fields = X, this.decodePrefixes = !!te;
  }
  /** @override */
  getSpan(X, ee) {
    if (0 <= this.span)
      return this.span;
    ee === void 0 && (ee = 0);
    let te = 0;
    try {
      te = this.fields.reduce((ne, ie) => {
        const oe = ie.getSpan(X, ee);
        return ee += oe, ne + oe;
      }, 0);
    } catch {
      throw new RangeError("indeterminate span");
    }
    return te;
  }
  /** @override */
  decode(X, ee) {
    ee === void 0 && (ee = 0);
    const te = this.makeDestinationObject();
    for (const ne of this.fields)
      if (ne.property !== void 0 && (te[ne.property] = ne.decode(X, ee)), ee += ne.getSpan(X, ee), this.decodePrefixes && X.length === ee)
        break;
    return te;
  }
  /** Implement {@link Layout#encode|encode} for {@link Structure}.
   *
   * If `src` is missing a property for a member with a defined {@link
   * Layout#property|property} the corresponding region of the buffer is
   * left unmodified. */
  encode(X, ee, te) {
    te === void 0 && (te = 0);
    const ne = te;
    let ie = 0, oe = 0;
    for (const se of this.fields) {
      let ae = se.span;
      if (oe = 0 < ae ? ae : 0, se.property !== void 0) {
        const ue = X[se.property];
        ue !== void 0 && (oe = se.encode(ue, ee, te), 0 > ae && (ae = se.getSpan(ee, te)));
      }
      ie = te, te += ae;
    }
    return ie + oe - ne;
  }
  /** @override */
  fromArray(X) {
    const ee = this.makeDestinationObject();
    for (const te of this.fields)
      te.property !== void 0 && 0 < X.length && (ee[te.property] = X.shift());
    return ee;
  }
  /**
   * Get access to the layout of a given property.
   *
   * @param {String} property - the structure member of interest.
   *
   * @return {Layout} - the layout associated with `property`, or
   * undefined if there is no such property.
   */
  layoutFor(X) {
    if (typeof X != "string")
      throw new TypeError("property must be string");
    for (const ee of this.fields)
      if (ee.property === X)
        return ee;
  }
  /**
   * Get the offset of a structure member.
   *
   * @param {String} property - the structure member of interest.
   *
   * @return {Number} - the offset in bytes to the start of `property`
   * within the structure, or undefined if `property` is not a field
   * within the structure.  If the property is a member but follows a
   * variable-length structure member a negative number will be
   * returned.
   */
  offsetOf(X) {
    if (typeof X != "string")
      throw new TypeError("property must be string");
    let ee = 0;
    for (const te of this.fields) {
      if (te.property === X)
        return ee;
      0 > te.span ? ee = -1 : 0 <= ee && (ee += te.span);
    }
  }
}
let Blob$3 = class extends Layout {
  constructor(Y, X) {
    if (!(Y instanceof ExternalLayout && Y.isCount() || Number.isInteger(Y) && 0 <= Y))
      throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");
    let ee = -1;
    Y instanceof ExternalLayout || (ee = Y), super(ee, X), this.length = Y;
  }
  /** @override */
  getSpan(Y, X) {
    let ee = this.span;
    return 0 > ee && (ee = this.length.decode(Y, X)), ee;
  }
  /** @override */
  decode(Y, X) {
    X === void 0 && (X = 0);
    let ee = this.span;
    return 0 > ee && (ee = this.length.decode(Y, X)), Y.slice(X, X + ee);
  }
  /** Implement {@link Layout#encode|encode} for {@link Blob}.
   *
   * **NOTE** If {@link Layout#count|count} is an instance of {@link
   * ExternalLayout} then the length of `src` will be encoded as the
   * count after `src` is encoded. */
  encode(Y, X, ee) {
    let te = this.length;
    if (this.length instanceof ExternalLayout && (te = Y.length), !(Buffer$e.isBuffer(Y) && te === Y.length))
      throw new TypeError(nameWithProperty("Blob.encode", this) + " requires (length " + te + ") Buffer as src");
    if (ee + te > X.length)
      throw new RangeError("encoding overruns Buffer");
    return X.write(Y.toString("hex"), ee, te, "hex"), this.length instanceof ExternalLayout && this.length.encode(te, X, ee), te;
  }
};
var nu64 = (Y) => new NearUInt64(Y), struct = (Y, X, ee) => new Structure(Y, X, ee), blob = (Y, X) => new Blob$3(Y, X);
const TOKEN_PROGRAM_ID = new PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");
new PublicKey("TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb");
const ASSOCIATED_TOKEN_PROGRAM_ID = new PublicKey("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL");
new PublicKey("So11111111111111111111111111111111111111112");
new PublicKey("9pan9bMn5HatX4EJdBwg9VgCa7Uz5HL8N1m5D3NdXejP");
const encodeDecode = (Y) => {
  const X = Y.decode.bind(Y), ee = Y.encode.bind(Y);
  return { decode: X, encode: ee };
}, bigInt = (Y) => (X) => {
  const ee = blob$1(Y, X), { encode: te, decode: ne } = encodeDecode(ee), ie = ee;
  return ie.decode = (oe, se) => {
    const ae = ne(oe, se);
    return toBigIntLE_1(Buffer$e.from(ae));
  }, ie.encode = (oe, se, ae) => {
    const ue = toBufferLE_1(oe, Y);
    return te(ue, se, ae);
  }, ie;
}, u64 = bigInt(8), bool = (Y) => {
  const X = u8(Y), { encode: ee, decode: te } = encodeDecode(X), ne = X;
  return ne.decode = (ie, oe) => !!te(ie, oe), ne.encode = (ie, oe, se) => {
    const ae = Number(ie);
    return ee(ae, oe, se);
  }, ne;
}, publicKey = (Y) => {
  const X = blob$1(32, Y), { encode: ee, decode: te } = encodeDecode(X), ne = X;
  return ne.decode = (ie, oe) => {
    const se = te(ie, oe);
    return new PublicKey(se);
  }, ne.encode = (ie, oe, se) => {
    const ae = ie.toBuffer();
    return ee(ae, oe, se);
  }, ne;
};
class TokenError extends Error {
  constructor(X) {
    super(X);
  }
}
class TokenAccountNotFoundError extends TokenError {
  constructor() {
    super(...arguments), this.name = "TokenAccountNotFoundError";
  }
}
class TokenInvalidAccountError extends TokenError {
  constructor() {
    super(...arguments), this.name = "TokenInvalidAccountError";
  }
}
class TokenInvalidAccountOwnerError extends TokenError {
  constructor() {
    super(...arguments), this.name = "TokenInvalidAccountOwnerError";
  }
}
class TokenInvalidAccountSizeError extends TokenError {
  constructor() {
    super(...arguments), this.name = "TokenInvalidAccountSizeError";
  }
}
class TokenInvalidMintError extends TokenError {
  constructor() {
    super(...arguments), this.name = "TokenInvalidMintError";
  }
}
class TokenInvalidOwnerError extends TokenError {
  constructor() {
    super(...arguments), this.name = "TokenInvalidOwnerError";
  }
}
class TokenOwnerOffCurveError extends TokenError {
  constructor() {
    super(...arguments), this.name = "TokenOwnerOffCurveError";
  }
}
var TokenInstruction;
(function(Y) {
  Y[Y.InitializeMint = 0] = "InitializeMint", Y[Y.InitializeAccount = 1] = "InitializeAccount", Y[Y.InitializeMultisig = 2] = "InitializeMultisig", Y[Y.Transfer = 3] = "Transfer", Y[Y.Approve = 4] = "Approve", Y[Y.Revoke = 5] = "Revoke", Y[Y.SetAuthority = 6] = "SetAuthority", Y[Y.MintTo = 7] = "MintTo", Y[Y.Burn = 8] = "Burn", Y[Y.CloseAccount = 9] = "CloseAccount", Y[Y.FreezeAccount = 10] = "FreezeAccount", Y[Y.ThawAccount = 11] = "ThawAccount", Y[Y.TransferChecked = 12] = "TransferChecked", Y[Y.ApproveChecked = 13] = "ApproveChecked", Y[Y.MintToChecked = 14] = "MintToChecked", Y[Y.BurnChecked = 15] = "BurnChecked", Y[Y.InitializeAccount2 = 16] = "InitializeAccount2", Y[Y.SyncNative = 17] = "SyncNative", Y[Y.InitializeAccount3 = 18] = "InitializeAccount3", Y[Y.InitializeMultisig2 = 19] = "InitializeMultisig2", Y[Y.InitializeMint2 = 20] = "InitializeMint2", Y[Y.GetAccountDataSize = 21] = "GetAccountDataSize", Y[Y.InitializeImmutableOwner = 22] = "InitializeImmutableOwner", Y[Y.AmountToUiAmount = 23] = "AmountToUiAmount", Y[Y.UiAmountToAmount = 24] = "UiAmountToAmount", Y[Y.InitializeMintCloseAuthority = 25] = "InitializeMintCloseAuthority", Y[Y.TransferFeeExtension = 26] = "TransferFeeExtension", Y[Y.ConfidentialTransferExtension = 27] = "ConfidentialTransferExtension", Y[Y.DefaultAccountStateExtension = 28] = "DefaultAccountStateExtension", Y[Y.Reallocate = 29] = "Reallocate", Y[Y.MemoTransferExtension = 30] = "MemoTransferExtension", Y[Y.CreateNativeMint = 31] = "CreateNativeMint", Y[Y.InitializeNonTransferableMint = 32] = "InitializeNonTransferableMint", Y[Y.InterestBearingMintExtension = 33] = "InterestBearingMintExtension", Y[Y.CpiGuardExtension = 34] = "CpiGuardExtension", Y[Y.InitializePermanentDelegate = 35] = "InitializePermanentDelegate", Y[Y.TransferHookExtension = 36] = "TransferHookExtension", Y[Y.MetadataPointerExtension = 39] = "MetadataPointerExtension", Y[Y.GroupPointerExtension = 40] = "GroupPointerExtension", Y[Y.GroupMemberPointerExtension = 41] = "GroupMemberPointerExtension";
})(TokenInstruction || (TokenInstruction = {}));
function addSigners(Y, X, ee) {
  if (ee.length) {
    Y.push({ pubkey: X, isSigner: !1, isWritable: !1 });
    for (const te of ee)
      Y.push({
        pubkey: te instanceof PublicKey ? te : te.publicKey,
        isSigner: !0,
        isWritable: !1
      });
  } else
    Y.push({ pubkey: X, isSigner: !0, isWritable: !1 });
  return Y;
}
function getSigners(Y, X) {
  return Y instanceof PublicKey ? [Y, X] : [Y.publicKey, [Y]];
}
var AccountType;
(function(Y) {
  Y[Y.Uninitialized = 0] = "Uninitialized", Y[Y.Mint = 1] = "Mint", Y[Y.Account = 2] = "Account";
})(AccountType || (AccountType = {}));
const ACCOUNT_TYPE_SIZE = 1, MultisigLayout = struct$1([
  u8("m"),
  u8("n"),
  bool("isInitialized"),
  publicKey("signer1"),
  publicKey("signer2"),
  publicKey("signer3"),
  publicKey("signer4"),
  publicKey("signer5"),
  publicKey("signer6"),
  publicKey("signer7"),
  publicKey("signer8"),
  publicKey("signer9"),
  publicKey("signer10"),
  publicKey("signer11")
]), MULTISIG_SIZE = MultisigLayout.span;
var AccountState;
(function(Y) {
  Y[Y.Uninitialized = 0] = "Uninitialized", Y[Y.Initialized = 1] = "Initialized", Y[Y.Frozen = 2] = "Frozen";
})(AccountState || (AccountState = {}));
const AccountLayout = struct$1([
  publicKey("mint"),
  publicKey("owner"),
  u64("amount"),
  u32("delegateOption"),
  publicKey("delegate"),
  u8("state"),
  u32("isNativeOption"),
  u64("isNative"),
  u64("delegatedAmount"),
  u32("closeAuthorityOption"),
  publicKey("closeAuthority")
]), ACCOUNT_SIZE = AccountLayout.span;
async function getAccount$1(Y, X, ee, te = TOKEN_PROGRAM_ID) {
  const ne = await Y.getAccountInfo(X, ee);
  return unpackAccount(X, ne, te);
}
function unpackAccount(Y, X, ee = TOKEN_PROGRAM_ID) {
  if (!X)
    throw new TokenAccountNotFoundError();
  if (!X.owner.equals(ee))
    throw new TokenInvalidAccountOwnerError();
  if (X.data.length < ACCOUNT_SIZE)
    throw new TokenInvalidAccountSizeError();
  const te = AccountLayout.decode(X.data.slice(0, ACCOUNT_SIZE));
  let ne = Buffer$e.alloc(0);
  if (X.data.length > ACCOUNT_SIZE) {
    if (X.data.length === MULTISIG_SIZE)
      throw new TokenInvalidAccountSizeError();
    if (X.data[ACCOUNT_SIZE] != AccountType.Account)
      throw new TokenInvalidAccountError();
    ne = X.data.slice(ACCOUNT_SIZE + ACCOUNT_TYPE_SIZE);
  }
  return {
    address: Y,
    mint: te.mint,
    owner: te.owner,
    amount: te.amount,
    delegate: te.delegateOption ? te.delegate : null,
    delegatedAmount: te.delegatedAmount,
    isInitialized: te.state !== AccountState.Uninitialized,
    isFrozen: te.state === AccountState.Frozen,
    isNative: !!te.isNativeOption,
    rentExemptReserve: te.isNativeOption ? te.isNative : null,
    closeAuthority: te.closeAuthorityOption ? te.closeAuthority : null,
    tlvData: ne
  };
}
const MintLayout = struct$1([
  u32("mintAuthorityOption"),
  publicKey("mintAuthority"),
  u64("supply"),
  u8("decimals"),
  bool("isInitialized"),
  u32("freezeAuthorityOption"),
  publicKey("freezeAuthority")
]), MINT_SIZE = MintLayout.span;
async function getMint(Y, X, ee, te = TOKEN_PROGRAM_ID) {
  const ne = await Y.getAccountInfo(X, ee);
  return unpackMint(X, ne, te);
}
function unpackMint(Y, X, ee = TOKEN_PROGRAM_ID) {
  if (!X)
    throw new TokenAccountNotFoundError();
  if (!X.owner.equals(ee))
    throw new TokenInvalidAccountOwnerError();
  if (X.data.length < MINT_SIZE)
    throw new TokenInvalidAccountSizeError();
  const te = MintLayout.decode(X.data.slice(0, MINT_SIZE));
  let ne = Buffer$e.alloc(0);
  if (X.data.length > MINT_SIZE) {
    if (X.data.length <= ACCOUNT_SIZE)
      throw new TokenInvalidAccountSizeError();
    if (X.data.length === MULTISIG_SIZE)
      throw new TokenInvalidAccountSizeError();
    if (X.data[ACCOUNT_SIZE] != AccountType.Mint)
      throw new TokenInvalidMintError();
    ne = X.data.slice(ACCOUNT_SIZE + ACCOUNT_TYPE_SIZE);
  }
  return {
    address: Y,
    mintAuthority: te.mintAuthorityOption ? te.mintAuthority : null,
    supply: te.supply,
    decimals: te.decimals,
    isInitialized: te.isInitialized,
    freezeAuthority: te.freezeAuthorityOption ? te.freezeAuthority : null,
    tlvData: ne
  };
}
async function getAssociatedTokenAddress(Y, X, ee = !1, te = TOKEN_PROGRAM_ID, ne = ASSOCIATED_TOKEN_PROGRAM_ID) {
  if (!ee && !PublicKey.isOnCurve(X.toBuffer()))
    throw new TokenOwnerOffCurveError();
  const [ie] = await PublicKey.findProgramAddress([X.toBuffer(), te.toBuffer(), Y.toBuffer()], ne);
  return ie;
}
function getAssociatedTokenAddressSync(Y, X, ee = !1, te = TOKEN_PROGRAM_ID, ne = ASSOCIATED_TOKEN_PROGRAM_ID) {
  if (!ee && !PublicKey.isOnCurve(X.toBuffer()))
    throw new TokenOwnerOffCurveError();
  const [ie] = PublicKey.findProgramAddressSync([X.toBuffer(), te.toBuffer(), Y.toBuffer()], ne);
  return ie;
}
function createAssociatedTokenAccountInstruction(Y, X, ee, te, ne = TOKEN_PROGRAM_ID, ie = ASSOCIATED_TOKEN_PROGRAM_ID) {
  return buildAssociatedTokenAccountInstruction(Y, X, ee, te, Buffer$e.alloc(0), ne, ie);
}
function buildAssociatedTokenAccountInstruction(Y, X, ee, te, ne, ie = TOKEN_PROGRAM_ID, oe = ASSOCIATED_TOKEN_PROGRAM_ID) {
  const se = [
    { pubkey: Y, isSigner: !0, isWritable: !0 },
    { pubkey: X, isSigner: !1, isWritable: !0 },
    { pubkey: ee, isSigner: !1, isWritable: !1 },
    { pubkey: te, isSigner: !1, isWritable: !1 },
    { pubkey: SystemProgram.programId, isSigner: !1, isWritable: !1 },
    { pubkey: ie, isSigner: !1, isWritable: !1 }
  ];
  return new TransactionInstruction({
    keys: se,
    programId: oe,
    data: ne
  });
}
async function getOrCreateAssociatedTokenAccount(Y, X, ee, te, ne = !1, ie, oe, se = TOKEN_PROGRAM_ID, ae = ASSOCIATED_TOKEN_PROGRAM_ID) {
  const ue = getAssociatedTokenAddressSync(ee, te, ne, se, ae);
  let le;
  try {
    le = await getAccount$1(Y, ue, ie, se);
  } catch (he) {
    if (he instanceof TokenAccountNotFoundError || he instanceof TokenInvalidAccountOwnerError) {
      try {
        const me = new Transaction().add(createAssociatedTokenAccountInstruction(X.publicKey, ue, te, ee, se, ae));
        await sendAndConfirmTransaction(Y, me, [X], oe);
      } catch {
      }
      le = await getAccount$1(Y, ue, ie, se);
    } else
      throw he;
  }
  if (!le.mint.equals(ee))
    throw new TokenInvalidMintError();
  if (!le.owner.equals(te))
    throw new TokenInvalidOwnerError();
  return le;
}
const transferInstructionData = struct$1([u8("instruction"), u64("amount")]);
function createTransferInstruction(Y, X, ee, te, ne = [], ie = TOKEN_PROGRAM_ID) {
  const oe = addSigners([
    { pubkey: Y, isSigner: !1, isWritable: !0 },
    { pubkey: X, isSigner: !1, isWritable: !0 }
  ], ee, ne), se = Buffer$e.alloc(transferInstructionData.span);
  return transferInstructionData.encode({
    instruction: TokenInstruction.Transfer,
    amount: BigInt(te)
  }, se), new TransactionInstruction({ keys: oe, programId: ie, data: se });
}
async function transfer(Y, X, ee, te, ne, ie, oe = [], se, ae = TOKEN_PROGRAM_ID) {
  const [ue, le] = getSigners(ne, oe), he = new Transaction().add(createTransferInstruction(ee, te, ue, ie, oe, ae));
  return await sendAndConfirmTransaction(Y, he, [X, ...le], se);
}
var naclUtil$1 = { exports: {} };
(function(Y) {
  (function(X, ee) {
    Y.exports ? Y.exports = ee() : (X.nacl || (X.nacl = {}), X.nacl.util = ee());
  })(commonjsGlobal, function() {
    var X = {};
    function ee(te) {
      if (!/^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/.test(te))
        throw new TypeError("invalid encoding");
    }
    return X.decodeUTF8 = function(te) {
      if (typeof te != "string")
        throw new TypeError("expected string");
      var ne, ie = unescape(encodeURIComponent(te)), oe = new Uint8Array(ie.length);
      for (ne = 0; ne < ie.length; ne++)
        oe[ne] = ie.charCodeAt(ne);
      return oe;
    }, X.encodeUTF8 = function(te) {
      var ne, ie = [];
      for (ne = 0; ne < te.length; ne++)
        ie.push(String.fromCharCode(te[ne]));
      return decodeURIComponent(escape(ie.join("")));
    }, typeof atob > "u" ? typeof Buffer$e.from < "u" ? (X.encodeBase64 = function(te) {
      return Buffer$e.from(te).toString("base64");
    }, X.decodeBase64 = function(te) {
      return ee(te), new Uint8Array(Array.prototype.slice.call(Buffer$e.from(te, "base64"), 0));
    }) : (X.encodeBase64 = function(te) {
      return new Buffer$e(te).toString("base64");
    }, X.decodeBase64 = function(te) {
      return ee(te), new Uint8Array(Array.prototype.slice.call(new Buffer$e(te, "base64"), 0));
    }) : (X.encodeBase64 = function(te) {
      var ne, ie = [], oe = te.length;
      for (ne = 0; ne < oe; ne++)
        ie.push(String.fromCharCode(te[ne]));
      return btoa(ie.join(""));
    }, X.decodeBase64 = function(te) {
      ee(te);
      var ne, ie = atob(te), oe = new Uint8Array(ie.length);
      for (ne = 0; ne < ie.length; ne++)
        oe[ne] = ie.charCodeAt(ne);
      return oe;
    }), X;
  });
})(naclUtil$1);
var naclUtilExports = naclUtil$1.exports;
const naclUtil = /* @__PURE__ */ getDefaultExportFromCjs$2(naclUtilExports), viewInExplorerLink = (Y) => `https://solscan.io/tx/${Y}`, customErrorMessage = (Y) => {
  const X = Y == null ? void 0 : Y.message, ee = Y == null ? void 0 : Y.reason;
  return X != null && X.includes("custom program error: 0x1") ? "Insufficient funds" : ee != null && ee.includes("TokenAccountNotFoundError") ? "TokenAccountNotFoundError" : X;
};
class Solana {
  constructor() {
    this.rpcUrl = "https://solana-mainnet.g.alchemy.com/v2/TY0C-d-2TTj6GHquKvUdOJ60QthiahUL", this.ACCOUNT_LAYOUT = struct([
      blob(32, "mint"),
      blob(32, "owner"),
      nu64("amount"),
      blob(93)
    ]), this.connection = new Connection(this.rpcUrl, {
      commitment: "confirmed"
    });
  }
  async createWallet(X, ee) {
    const te = mnemonicToSeedSync_1(X), ne = dist.derivePath(
      `m/44'/501'/${ee}'/0'`,
      te
    ).key, ie = Keypair.fromSeed(ne);
    return {
      privateKey: bs58$1.encode(ie.secretKey),
      // keyPair.secretKey.toString(),
      address: ie.publicKey.toBase58()
    };
  }
  async getBalance(X, ee) {
    var te;
    try {
      let ne;
      const ie = new PublicKey(X);
      if (ee) {
        const oe = new PublicKey(ee), se = await this.connection.getTokenAccountsByOwner(
          ie,
          {
            mint: new PublicKey(ee)
          }
        ), ae = (te = (await this.connection.getTokenSupply(
          oe
        )).value) == null ? void 0 : te.decimals;
        return ne = se.value.length > 0 ? this.ACCOUNT_LAYOUT.decode(se.value[0].account.data).amount : 0, {
          balanceInUnits: ne,
          decimals: ae,
          balance: ne / 10 ** ae
        };
      }
      return ne = await this.connection.getBalance(ie), {
        balanceInUnits: ne,
        balance: ne / LAMPORTS_PER_SOL
      };
    } catch (ne) {
      throw ne;
    }
  }
  async getSendFee(X, ee, te, ne) {
    try {
      const ie = new PublicKey(X), oe = await this.connection.getLatestBlockhash(), se = await this.getSendTxnObject(
        X,
        ee,
        te,
        ne,
        oe
      );
      se.feePayer = ie;
      const ae = await se.getEstimatedFee(this.connection);
      if (console.log(
        `Estimated ${te} ${ne || "SOL"} transfer cost: ${ae} lamports`
      ), ae) {
        const ue = ae / LAMPORTS_PER_SOL;
        return { success: !0, fee: { eth: ue == null ? void 0 : ue.toString(), usd: "0" } };
      } else
        return {
          success: !1,
          message: "Fees returned null, please try again!"
        };
    } catch (ie) {
      return console.error(ie), { success: !1, message: customErrorMessage(ie) };
    }
  }
  async getSendTxnObject(X, ee, te, ne, ie) {
    const oe = new PublicKey(ee), se = new PublicKey(X);
    let ae = new Transaction(
      ie ? {
        recentBlockhash: ie.blockhash
      } : {}
    );
    if (ne) {
      const ue = await getMint(
        this.connection,
        new PublicKey(ne)
      ), le = await getAssociatedTokenAddress(
        ue.address,
        // mint
        se
        // owner
      ), he = await getAssociatedTokenAddress(
        ue.address,
        oe
      );
      ae.add(
        createTransferInstruction(
          le,
          he,
          se,
          te * 10 ** ue.decimals
          // parse the amount
        )
      );
    } else
      ae.add(
        SystemProgram.transfer({
          fromPubkey: se,
          toPubkey: oe,
          lamports: LAMPORTS_PER_SOL * te
        })
      );
    return ae;
  }
  async send({
    privateKey: X,
    fromAddress: ee,
    recipientAddress: te,
    amount: ne,
    tokenAddress: ie
  }) {
    try {
      const oe = this.getPayer(X);
      let se;
      if (ie) {
        const ae = new PublicKey(te), ue = await getMint(
          this.connection,
          new PublicKey(ie)
        ), le = await getOrCreateAssociatedTokenAccount(
          this.connection,
          oe,
          // payer
          ue.address,
          // mint
          oe.publicKey
          // owner
        ), he = await getOrCreateAssociatedTokenAccount(
          this.connection,
          oe,
          ue.address,
          ae
        );
        se = await transfer(
          this.connection,
          oe,
          le.address,
          he.address,
          oe.publicKey,
          ne * 10 ** ue.decimals,
          // parse the amount
          void 0,
          { commitment: "processed" }
        );
      } else {
        const ae = await this.getSendTxnObject(
          ee,
          te,
          ne,
          ie
        );
        se = await sendAndConfirmTransaction(
          this.connection,
          ae,
          [oe],
          { commitment: "processed" }
        );
      }
      return {
        success: !0,
        data: {
          txnId: se,
          viewInExplorer: viewInExplorerLink(se),
          wait: async () => {
            console.log(`Waiting for ${viewInExplorerLink(se)}`), await this.waitForTransaction(se);
          }
        }
      };
    } catch (oe) {
      return console.error(oe), { success: !1, message: customErrorMessage(oe) };
    }
  }
  async getSendNftFee(X, ee, te) {
    const ne = new PublicKey(X), ie = await this.connection.getLatestBlockhash(), oe = await this.getSendNftTxnObject(
      X,
      ee,
      te,
      ie
    );
    oe.feePayer = ne;
    const se = await oe.getEstimatedFee(this.connection);
    if (se) {
      const ae = se / LAMPORTS_PER_SOL;
      return { success: !0, fee: { eth: ae == null ? void 0 : ae.toString(), usd: "0" } };
    } else
      return {
        success: !1,
        message: "Fees returned null, please try again!"
      };
  }
  async getSendNftTxnObject(X, ee, te, ne) {
    const ie = new PublicKey(X), oe = new PublicKey(ee), se = new PublicKey(te);
    let ae = new Transaction(
      ne ? {
        recentBlockhash: ne.blockhash
      } : {}
    );
    const ue = await getAssociatedTokenAddress(
      se,
      ie
    ), le = await getAssociatedTokenAddress(
      se,
      oe
    );
    return ae.add(
      createTransferInstruction(
        ue,
        le,
        ie,
        1,
        // Amount is 1 because NFTs are unique
        []
      )
    ), ae;
  }
  async sendNft({
    privateKey: X,
    recipientAddress: ee,
    tokenAddress: te
  }) {
    try {
      console.log(`Sending NFT ${te} to ${ee}`);
      const ne = this.getPayer(X), ie = new PublicKey(ee), oe = new PublicKey(te);
      console.log("Fetching sender token account...");
      const se = await getAssociatedTokenAddress(
        oe,
        ne.publicKey
      );
      console.log("Fetching receiver token account...");
      const ae = await getAssociatedTokenAddress(
        // this.connection,
        // sender,
        oe,
        ie
        // undefined
        // 'processed'
        // { maxRetries: 5 }
      ), ue = ComputeBudgetProgram.setComputeUnitPrice({
        microLamports: 10
      });
      let le = new Transaction().add(ue);
      await this.checkIfTokenAccountExists(ae) || (console.log("Create Receiver token account!"), le.add(
        createAssociatedTokenAccountInstruction(
          ne.publicKey,
          ae,
          ie,
          oe
        )
      )), le.add(
        createTransferInstruction(
          se,
          ae,
          ne.publicKey,
          1
          // Amount is 1 because NFTs are unique
        )
      );
      const he = await this.connection.sendTransaction(le, [
        ne
      ]);
      return {
        success: !0,
        data: {
          txnId: he,
          viewInExplorer: viewInExplorerLink(he),
          wait: async () => {
            console.log(`Waiting for ${viewInExplorerLink(he)}`), await this.waitForTransaction(he);
          }
        }
      };
    } catch (ne) {
      return console.error("Error during NFT transfer:", ne), { success: !1, message: customErrorMessage(ne) };
    }
  }
  getPayer(X) {
    let ee;
    return X.split(",").length > 1 ? ee = new Uint8Array(X.split(",")) : ee = bs58$1.decode(X), Keypair.fromSecretKey(ee, {
      skipValidation: !1
    });
  }
  // https://solanacookbook.com/references/keypairs-and-wallets.html#how-to-sign-and-verify-messages-with-wallets
  async signMessage(X, ee) {
    const te = naclUtil.decodeUTF8(ee), ne = nacl.sign.detached(te, bs58$1.decode(X));
    return Buffer$e.from(ne).toString("hex");
  }
  async verifySignature(X, ee, te) {
    const ne = naclUtil.decodeUTF8(ee), ie = bs58$1.decode(te);
    return nacl.sign.detached.verify(
      ne,
      Buffer$e.from(X, "hex"),
      ie
    );
  }
  async waitForTransaction(X, ee, te) {
    return ee && ee > 10 ? await this.connection.confirmTransaction(X, "finalized") : await this.connection.confirmTransaction(X, "confirmed"), !0;
  }
  async checkIfTokenAccountExists(X) {
    try {
      return await getAccount$1(
        this.connection,
        X,
        "confirmed",
        TOKEN_PROGRAM_ID
      ), !0;
    } catch (ee) {
      const te = ee;
      if (te.name === "TokenAccountNotFoundError")
        return !1;
      throw te;
    }
  }
}
const alchemyKey = "kcuWVV9ss_iLWJ2Lw6xdHbmtZYixfY7Z", rpcUrls = {
  MUMBAI: `https://polygon-mumbai.g.alchemy.com/v2/${alchemyKey}`,
  //'https://polygon-mumbai.blockpi.network/v1/rpc/public',
  ETH: "https://eth.llamarpc.com",
  POLYGON: `https://polygon-mainnet.g.alchemy.com/v2/${alchemyKey}`,
  // 'https://polygon.llamarpc.com',
  AVALANCHE: "https://avalanche-c-chain.publicnode.com",
  ARBITRUM: "https://arbitrum-one.publicnode.com",
  BINANCE: "https://bsc.publicnode.com",
  OPTIMISM: "https://optimism.meowrpc.com",
  FANTOM: "https://fantom.publicnode.com",
  FUSE: "https://rpc.fuse.io",
  MANTA: "https://1rpc.io/manta",
  "MANTA-TESTNET": "https://manta-testnet.calderachain.xyz/http",
  METIS: "https://metis-pokt.nodies.app",
  "METIS-TESTNET": "https://goerli.gateway.metisdevops.link",
  MANTLE: "https://rpc.mantle.xyz",
  "MANTLE-TESTNET": "https://rpc.testnet.mantle.xyz"
};
class ChainController {
  constructor(X, ee) {
    SY(this, "rpcUrl"), SY(this, "chainName"), this.rpcUrl = ee || rpcUrls[X], this.chainName = X;
  }
  async readContract(X) {
    try {
      const { contractAddress: ee, abi: te, functionName: ne, args: ie } = X, { contract: oe } = await this.getContract(ee, te);
      return { success: !0, data: await oe[ne](...ie) };
    } catch (ee) {
      return console.error(ee), { success: !1, message: "Error reading contract", error: ee };
    }
  }
  async getContract(X, ee) {
    try {
      const te = ee;
      return {
        contract: new Contract(
          X,
          te,
          this.getProvider()
        )
      };
    } catch {
      throw new Error("Error making contract instance");
    }
  }
  getProvider() {
    return new JsonRpcProvider(this.rpcUrl);
  }
  async waitForTransaction(X, ee, te) {
    return this.chainName == "SOLANA" ? await new Solana().waitForTransaction(X, ee) : await this.getProvider().waitForTransaction(
      X,
      ee,
      te
    );
  }
}
const readContract = async ({
  chainName: Y,
  contractDetails: X,
  rpcUrl: ee
}) => {
  try {
    return await new ChainController(Y, ee).readContract(X);
  } catch (te) {
    return console.error(te), { success: !1, message: "Error in readContract", error: te };
  }
}, send = async (Y, X, ee = triaAuthUrl, te = "mainnet", ne, ie) => {
  if (wagmiConnected(Y))
    return await new bY({
      config: Y,
      baseUrl: apiUrl[te],
      walletType: { embedded: !1 },
      selectedChainName: X.chainName,
      environment: te
    }).send({
      ...X,
      recipientTriaName: X.recepientAddress
    });
  if (triaConnected()) {
    const oe = createEncodedData({
      ...X,
      ...ie,
      aa: ne
    }), se = `${ee}/send/${oe}`;
    return createIframe(se, "sdkSend"), new Promise((ae, ue) => {
      const le = (he) => {
        var me;
        if (he.origin !== ee)
          return;
        let ye;
        try {
          ye = JSON.parse(he.data);
        } catch {
          ye = he.data;
        }
        (ye == null ? void 0 : ye.type) === "closeIframe" && (ye == null ? void 0 : ye.callFrom) === "send" && ((me = document.getElementById("sdkSend")) == null || me.remove(), window.removeEventListener("message", le), ae(ye == null ? void 0 : ye.data));
      };
      window.addEventListener("message", le);
    });
  } else
    return { success: !1, message: "Metamask and Tria not connected!" };
};
let getRandomValues;
const rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues && (getRandomValues = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto), !getRandomValues))
    throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
  return getRandomValues(rnds8);
}
const byteToHex = [];
for (let Y = 0; Y < 256; ++Y)
  byteToHex.push((Y + 256).toString(16).slice(1));
function unsafeStringify(Y, X = 0) {
  return byteToHex[Y[X + 0]] + byteToHex[Y[X + 1]] + byteToHex[Y[X + 2]] + byteToHex[Y[X + 3]] + "-" + byteToHex[Y[X + 4]] + byteToHex[Y[X + 5]] + "-" + byteToHex[Y[X + 6]] + byteToHex[Y[X + 7]] + "-" + byteToHex[Y[X + 8]] + byteToHex[Y[X + 9]] + "-" + byteToHex[Y[X + 10]] + byteToHex[Y[X + 11]] + byteToHex[Y[X + 12]] + byteToHex[Y[X + 13]] + byteToHex[Y[X + 14]] + byteToHex[Y[X + 15]];
}
const randomUUID = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto), native = {
  randomUUID
};
function v4(Y, X, ee) {
  if (native.randomUUID && !X && !Y)
    return native.randomUUID();
  Y = Y || {};
  const te = Y.random || (Y.rng || rng)();
  if (te[6] = te[6] & 15 | 64, te[8] = te[8] & 63 | 128, X) {
    ee = ee || 0;
    for (let ne = 0; ne < 16; ++ne)
      X[ee + ne] = te[ne];
    return X;
  }
  return unsafeStringify(te);
}
const writeContract = async (Y, X, ee = triaAuthUrl, te = "mainnet", ne, ie) => {
  if (wagmiConnected(Y))
    return await new bY({
      config: Y,
      baseUrl: apiUrl[te],
      walletType: { embedded: !1 },
      selectedChainName: X.chainName,
      environment: te
    }).callContract(X.contractDetails);
  if (triaConnected()) {
    const oe = v4(), se = createEncodedData({ userId: oe }), ae = createEncodedData({
      ...X,
      ...ie,
      aa: ne
    }), ue = `${ee}/mint/${se}`;
    return createIframe(ue, "sdkMint"), new Promise((le, he) => {
      const me = (ye) => {
        var we, Ee;
        if (ye.origin !== ee)
          return;
        let Re;
        try {
          Re = JSON.parse(ye.data);
        } catch {
          Re = ye.data;
        }
        if ((Re == null ? void 0 : Re.type) === "sendParams" && (Re == null ? void 0 : Re.callFrom) === "mint") {
          const Ue = (we = Re == null ? void 0 : Re.data) == null ? void 0 : we.userId;
          socket.emit("messageV2", {
            userId: Ue,
            message: ae
          });
        } else
          (Re == null ? void 0 : Re.type) === "closeIframe" && (Re == null ? void 0 : Re.callFrom) === "mint" && ((Ee = document.getElementById("sdkMint")) == null || Ee.remove(), window.removeEventListener("message", me), le(Re == null ? void 0 : Re.data));
      };
      window.addEventListener("message", me);
    });
  } else
    return { success: !1, message: "Metamask and Tria not connected!" };
}, getAccount = (Y) => {
  let X = null;
  const ee = triaConnected(), te = wagmiConnected(Y);
  if (ee) {
    const ne = localStorage.getItem(TRIA_WALLET_STORE);
    ne && (X = JSON.parse(ne));
  } else if (te) {
    const { address: ne } = getAccount$2(Y);
    ne && (X = {
      triaName: null,
      evm: {
        address: ne
      }
    });
  }
  return X;
}, disconnect = async (Y) => {
  if (triaConnected() && (window.localStorage.removeItem(storageKeys.TRIA_WALLET_STORE), window.localStorage.removeItem(storageKeys.PERSIST_ROOT)), wagmiConnected(Y))
    try {
      window.localStorage.getItem("wagmi.connected") && window.localStorage.removeItem("wagmi.connected");
      const X = await disconnect$1(Y);
      console.log("disconnect wagmi result - ", X);
    } catch (X) {
      console.log("disconnect wagmi error - ", X);
    }
};
class TriaConnector {
  constructor({ authUrl: X, walletUrl: ee }) {
    SY(this, "globalData"), SY(this, "authUrl"), SY(this, "walletUrl"), SY(this, "authResponse", (te) => {
      if (!(te.origin === this.walletUrl || te.origin === this.authUrl))
        return;
      const ne = this.parseEventData(te), ie = ne == null ? void 0 : ne.type;
      ie && (this.isSignUpEvent(ie) ? this.setTriaStore(ne) : ie === eventTypes.switchChain ? this.setSelectedChain(ne) : (ie === eventTypes.disconnect || ie === eventTypes.logout) && this.disconnect(ne), this.globalData.set(`${ie}`, ne));
    }), this.globalData = /* @__PURE__ */ new Map(), this.authUrl = X, this.walletUrl = ee, this.initializeEventListener();
  }
  setTriaStore(X) {
    if (X != null && X.success) {
      window.localStorage.setItem(
        TRIA_WALLET_STORE,
        JSON.stringify(X.data)
      );
      const ee = new Event(eventTypes.triaStoreSet);
      window.dispatchEvent(ee);
    } else
      console.log("Sign up or Login failed!!");
  }
  disconnect(X) {
    X != null && X.success && window.localStorage.removeItem(TRIA_WALLET_STORE);
  }
  setSelectedChain(X) {
    var ee;
    window.localStorage.setItem(
      TRIA_WALLET_SELECTED_CHAIN,
      (ee = X == null ? void 0 : X.data) == null ? void 0 : ee.chainName
    );
  }
  isSignUpEvent(X) {
    return X.includes("Sign up") || X === "Log in";
  }
  parseEventData(X) {
    let ee;
    try {
      ee = JSON.parse(X.data);
    } catch {
      ee = X.data;
    }
    return ee;
  }
  initializeEventListener() {
    window.addEventListener("message", this.authResponse);
  }
  cleanup() {
    window.removeEventListener("message", this.authResponse);
  }
  getGlobalData() {
    return this.globalData;
  }
}
var __defProp$1 = Object.defineProperty, __getOwnPropDesc$1 = Object.getOwnPropertyDescriptor, __decorateClass$1 = (Y, X, ee, te) => {
  for (var ne = te > 1 ? void 0 : te ? __getOwnPropDesc$1(X, ee) : X, ie = Y.length - 1, oe; ie >= 0; ie--)
    (oe = Y[ie]) && (ne = (te ? oe(X, ee, ne) : oe(ne)) || ne);
  return te && ne && __defProp$1(X, ee, ne), ne;
};
let AuthBasic = class extends s$1 {
  constructor() {
    super(...arguments), this.darkMode = !1, this.dappName = "", this.logo = "", this.iframeUrl = "", this.otpIframeUrl = "", this.signupIframeUrl = "", this.eventData = null, this.otpLogin = !1, this.signUp = !1, this.handleMessage = (Y) => {
      if (Y.origin == "https://auth-tria-lit.vercel.app" || Y.origin == "https://auth-tria.vercel.app" || Y.origin == "https://auth.tria.so") {
        let X;
        try {
          X = JSON.parse(Y.data), console.log("TRIA_EVENT", X);
        } catch {
        }
        X && X.type === eventTypes.passMessage && X.message.type === "otpLogin" && (this.eventData = X, this.otpLogin = !0, this.signUp = !1), X && X.type === eventTypes.passMessage && X.message.go_back === !0 && (this.eventData = null, this.otpLogin = !1, this.signUp = !1), X && X.type === eventTypes.passMessage && X.message.accountExists === !1 && (this.eventData = X, this.otpLogin = !1, this.signUp = !0), X && X.type === eventTypes.socialSignUp && X.success === !0 && this.dispatchEvent(
          new CustomEvent("TRIA_LOGIN", {
            detail: X,
            bubbles: !0,
            composed: !0
          })
        ), X && X.type === eventTypes.triaSignUp && X.success === !0 && this.dispatchEvent(
          new CustomEvent("TRIA_LOGIN", {
            detail: X,
            bubbles: !0,
            composed: !0
          })
        ), X && X.type === eventTypes.emailPwSignUp && X.success === !0 && this.dispatchEvent(
          new CustomEvent("TRIA_LOGIN", {
            detail: X,
            bubbles: !0,
            composed: !0
          })
        ), X && X.type === eventTypes.logIn && this.dispatchEvent(
          new CustomEvent("TRIA_LOGIN", {
            detail: X,
            bubbles: !0,
            composed: !0
          })
        );
      }
    };
  }
  connectedCallback() {
    super.connectedCallback(), this.addMessageListener();
  }
  disconnectedCallback() {
    this.removeMessageListener(), super.disconnectedCallback();
  }
  addMessageListener() {
    window.addEventListener("message", this.handleMessage);
  }
  removeMessageListener() {
    window.removeEventListener("message", this.handleMessage);
  }
  createRenderRoot() {
    return this;
  }
  get step() {
    return this.signUp ? `${this.signupIframeUrl}/${this.eventData.message.social}/${this.eventData.message.userId}/${this.eventData.message.username}/${this.eventData.message.token}` : this.otpIframeUrl;
  }
  render() {
    return x$2`
      <div
        class="bg-[${this.darkMode ? "#101010" : "white"}] w-[448px] h-[840px] rounded-20 overflow-hidden shadow-md p-4 flex flex-col rounded-2xl"
        style="background-color: ${this.darkMode ? "#101010" : "white"};"
      >
        <iframe
          class="otp-iframe ${this.otpLogin || this.signUp ? "active" : ""}"
          src="${this.step}"
          allow="publickey-credentials-get"
        ></iframe>
        <div
          class="auth-content ${this.otpLogin || this.signUp ? "hidden" : ""}"
        >
          <div class="w-full h-2/5 pt-28">
            <div
              class="w-full flex flex-col justify-center items-center space-y-6"
            >
              <img class="drop-shadow-white" src="${this.logo}" />
              <div class="text-white text-lg text-opacity-80 tracking-wider">
                Log in with ${this.dappName}
              </div>
            </div>
          </div>
          <div class="h-3/5 flex flex-col justify-end pb-2">
            <div class="pb-2">
              <auth-content
                .darkMode="${this.darkMode}"
                .iframeUrl="${this.iframeUrl}"
              ></auth-content>
            </div>
            <div class="flex justify-center items-center">
              <img class="w-4 flex-none mr-1" src="${TriaMiniLogo}" />
              <div
                class="text-tr-gray-light text-opacity-80 text-sm tracking-wider"
              >
                Powered by Tria
              </div>
            </div>
          </div>
        </div>
      </div>
    `;
  }
};
__decorateClass$1([
  n$1({ type: Boolean })
], AuthBasic.prototype, "darkMode", 2);
__decorateClass$1([
  n$1({ type: String })
], AuthBasic.prototype, "dappName", 2);
__decorateClass$1([
  n$1({ type: String })
], AuthBasic.prototype, "logo", 2);
__decorateClass$1([
  n$1({ type: String })
], AuthBasic.prototype, "iframeUrl", 2);
__decorateClass$1([
  n$1({ type: String })
], AuthBasic.prototype, "otpIframeUrl", 2);
__decorateClass$1([
  n$1({ type: String })
], AuthBasic.prototype, "signupIframeUrl", 2);
__decorateClass$1([
  r$3()
], AuthBasic.prototype, "eventData", 2);
__decorateClass$1([
  r$3()
], AuthBasic.prototype, "otpLogin", 2);
__decorateClass$1([
  r$3()
], AuthBasic.prototype, "signUp", 2);
AuthBasic = __decorateClass$1([
  t$1("auth-basic")
], AuthBasic);
const styles = i$5`
  external-wallets {
    width: 100%;
  }

  auth-basic {
    width: 448px;
    height: 840px;
    transform: scale(0.7);
  }

  .auth-content {
    height: 100%;
    transition: opacity 0.5s ease-in-out, visibility 0.5s ease-in-out;
  }
  .auth-content.hidden {
    opacity: 0;
    visibility: hidden;
  }

  .otp-iframe {
    width: 314px;
    height: 586px;
    border-radius: 20px;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%) scale(1.4);
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.5s ease-in-out, visibility 0.5s ease-in-out,
      transform 0.5s ease-in-out;
  }
  .otp-iframe.active {
    opacity: 1;
    visibility: visible;
    transform: translate(-50%, -50%) scale(1.4);
  }

  .wallet-button {
    width: 145px;
    height: 135px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
  }

  .rotating-glow-container {
    --gradient-color: rgba(255, 255, 255, 1);
    --gradient-shadow-color: rgba(255, 255, 255, 0.4);
  }
`, TWStyles = i$5` /*
! tailwindcss v3.4.1 | MIT License | https://tailwindcss.com
*/

/*
1. Prevent padding and border from affecting element width. (https://github.com/mozdevs/cssremedy/issues/4)
2. Allow adding a border to an element by just adding a border-width. (https://github.com/tailwindcss/tailwindcss/pull/116)
*/

*,
::before,
::after {
  box-sizing: border-box;
  /* 1 */
  border-width: 0;
  /* 2 */
  border-style: solid;
  /* 2 */
  border-color: currentColor;
  /* 2 */
}

::before,
::after {
  --tw-content: '';
}

/*
1. Use a consistent sensible line-height in all browsers.
2. Prevent adjustments of font size after orientation changes in iOS.
3. Use a more readable tab size.
4. Use the user's configured sans font-family by default.
5. Use the user's configured sans font-feature-settings by default.
6. Use the user's configured sans font-variation-settings by default.
7. Disable tap highlights on iOS
*/

html,
:host {
  line-height: 1.5;
  /* 1 */
  -webkit-text-size-adjust: 100%;
  /* 2 */
  -moz-tab-size: 4;
  /* 3 */
  -o-tab-size: 4;
     tab-size: 4;
  /* 3 */
  font-family: "Montserrat", sans-serif;
  /* 4 */
  font-feature-settings: normal;
  /* 5 */
  font-variation-settings: normal;
  /* 6 */
  -webkit-tap-highlight-color: transparent;
  /* 7 */
}

/*
1. Remove the margin in all browsers.
2. Inherit line-height from html so users can set them as a class directly on the html element.
*/

body {
  margin: 0;
  /* 1 */
  line-height: inherit;
  /* 2 */
}

/*
1. Add the correct height in Firefox.
2. Correct the inheritance of border color in Firefox. (https://bugzilla.mozilla.org/show_bug.cgi?id=190655)
3. Ensure horizontal rules are visible by default.
*/

hr {
  height: 0;
  /* 1 */
  color: inherit;
  /* 2 */
  border-top-width: 1px;
  /* 3 */
}

/*
Add the correct text decoration in Chrome, Edge, and Safari.
*/

abbr:where([title]) {
  -webkit-text-decoration: underline dotted;
          text-decoration: underline dotted;
}

/*
Remove the default font size and weight for headings.
*/

h1,
h2,
h3,
h4,
h5,
h6 {
  font-size: inherit;
  font-weight: inherit;
}

/*
Reset links to optimize for opt-in styling instead of opt-out.
*/

a {
  color: inherit;
  text-decoration: inherit;
}

/*
Add the correct font weight in Edge and Safari.
*/

b,
strong {
  font-weight: bolder;
}

/*
1. Use the user's configured mono font-family by default.
2. Use the user's configured mono font-feature-settings by default.
3. Use the user's configured mono font-variation-settings by default.
4. Correct the odd em font sizing in all browsers.
*/

code,
kbd,
samp,
pre {
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  /* 1 */
  font-feature-settings: normal;
  /* 2 */
  font-variation-settings: normal;
  /* 3 */
  font-size: 1em;
  /* 4 */
}

/*
Add the correct font size in all browsers.
*/

small {
  font-size: 80%;
}

/*
Prevent sub and sup elements from affecting the line height in all browsers.
*/

sub,
sup {
  font-size: 75%;
  line-height: 0;
  position: relative;
  vertical-align: baseline;
}

sub {
  bottom: -0.25em;
}

sup {
  top: -0.5em;
}

/*
1. Remove text indentation from table contents in Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=999088, https://bugs.webkit.org/show_bug.cgi?id=201297)
2. Correct table border color inheritance in all Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=935729, https://bugs.webkit.org/show_bug.cgi?id=195016)
3. Remove gaps between table borders by default.
*/

table {
  text-indent: 0;
  /* 1 */
  border-color: inherit;
  /* 2 */
  border-collapse: collapse;
  /* 3 */
}

/*
1. Change the font styles in all browsers.
2. Remove the margin in Firefox and Safari.
3. Remove default padding in all browsers.
*/

button,
input,
optgroup,
select,
textarea {
  font-family: inherit;
  /* 1 */
  font-feature-settings: inherit;
  /* 1 */
  font-variation-settings: inherit;
  /* 1 */
  font-size: 100%;
  /* 1 */
  font-weight: inherit;
  /* 1 */
  line-height: inherit;
  /* 1 */
  color: inherit;
  /* 1 */
  margin: 0;
  /* 2 */
  padding: 0;
  /* 3 */
}

/*
Remove the inheritance of text transform in Edge and Firefox.
*/

button,
select {
  text-transform: none;
}

/*
1. Correct the inability to style clickable types in iOS and Safari.
2. Remove default button styles.
*/

button,
[type='button'],
[type='reset'],
[type='submit'] {
  -webkit-appearance: button;
  /* 1 */
  background-color: transparent;
  /* 2 */
  background-image: none;
  /* 2 */
}

/*
Use the modern Firefox focus style for all focusable elements.
*/

:-moz-focusring {
  outline: auto;
}

/*
Remove the additional :invalid styles in Firefox. (https://github.com/mozilla/gecko-dev/blob/2f9eacd9d3d995c937b4251a5557d95d494c9be1/layout/style/res/forms.css#L728-L737)
*/

:-moz-ui-invalid {
  box-shadow: none;
}

/*
Add the correct vertical alignment in Chrome and Firefox.
*/

progress {
  vertical-align: baseline;
}

/*
Correct the cursor style of increment and decrement buttons in Safari.
*/

::-webkit-inner-spin-button,
::-webkit-outer-spin-button {
  height: auto;
}

/*
1. Correct the odd appearance in Chrome and Safari.
2. Correct the outline style in Safari.
*/

[type='search'] {
  -webkit-appearance: textfield;
  /* 1 */
  outline-offset: -2px;
  /* 2 */
}

/*
Remove the inner padding in Chrome and Safari on macOS.
*/

::-webkit-search-decoration {
  -webkit-appearance: none;
}

/*
1. Correct the inability to style clickable types in iOS and Safari.
2. Change font properties to inherit in Safari.
*/

::-webkit-file-upload-button {
  -webkit-appearance: button;
  /* 1 */
  font: inherit;
  /* 2 */
}

/*
Add the correct display in Chrome and Safari.
*/

summary {
  display: list-item;
}

/*
Removes the default spacing and border for appropriate elements.
*/

blockquote,
dl,
dd,
h1,
h2,
h3,
h4,
h5,
h6,
hr,
figure,
p,
pre {
  margin: 0;
}

fieldset {
  margin: 0;
  padding: 0;
}

legend {
  padding: 0;
}

ol,
ul,
menu {
  list-style: none;
  margin: 0;
  padding: 0;
}

/*
Reset default styling for dialogs.
*/

dialog {
  padding: 0;
}

/*
Prevent resizing textareas horizontally by default.
*/

textarea {
  resize: vertical;
}

/*
1. Reset the default placeholder opacity in Firefox. (https://github.com/tailwindlabs/tailwindcss/issues/3300)
2. Set the default placeholder color to the user's configured gray 400 color.
*/

input::-moz-placeholder, textarea::-moz-placeholder {
  opacity: 1;
  /* 1 */
  color: #9ca3af;
  /* 2 */
}

input::placeholder,
textarea::placeholder {
  opacity: 1;
  /* 1 */
  color: #9ca3af;
  /* 2 */
}

/*
Set the default cursor for buttons.
*/

button,
[role="button"] {
  cursor: pointer;
}

/*
Make sure disabled buttons don't get the pointer cursor.
*/

:disabled {
  cursor: default;
}

/*
1. Make replaced elements display: block by default. (https://github.com/mozdevs/cssremedy/issues/14)
2. Add vertical-align: middle to align replaced elements more sensibly by default. (https://github.com/jensimmons/cssremedy/issues/14#issuecomment-634934210)
   This can trigger a poorly considered lint error in some tools but is included by design.
*/

img,
svg,
video,
canvas,
audio,
iframe,
embed,
object {
  display: block;
  /* 1 */
  vertical-align: middle;
  /* 2 */
}

/*
Constrain images and videos to the parent width and preserve their intrinsic aspect ratio. (https://github.com/mozdevs/cssremedy/issues/14)
*/

img,
video {
  max-width: 100%;
  height: auto;
}

/* Make elements with the HTML hidden attribute stay hidden by default */

[hidden] {
  display: none;
}

*, ::before, ::after {
  --tw-border-spacing-x: 0;
  --tw-border-spacing-y: 0;
  --tw-translate-x: 0;
  --tw-translate-y: 0;
  --tw-rotate: 0;
  --tw-skew-x: 0;
  --tw-skew-y: 0;
  --tw-scale-x: 1;
  --tw-scale-y: 1;
  --tw-pan-x:  ;
  --tw-pan-y:  ;
  --tw-pinch-zoom:  ;
  --tw-scroll-snap-strictness: proximity;
  --tw-gradient-from-position:  ;
  --tw-gradient-via-position:  ;
  --tw-gradient-to-position:  ;
  --tw-ordinal:  ;
  --tw-slashed-zero:  ;
  --tw-numeric-figure:  ;
  --tw-numeric-spacing:  ;
  --tw-numeric-fraction:  ;
  --tw-ring-inset:  ;
  --tw-ring-offset-width: 0px;
  --tw-ring-offset-color: #fff;
  --tw-ring-color: rgb(59 130 246 / 0.5);
  --tw-ring-offset-shadow: 0 0 #0000;
  --tw-ring-shadow: 0 0 #0000;
  --tw-shadow: 0 0 #0000;
  --tw-shadow-colored: 0 0 #0000;
  --tw-blur:  ;
  --tw-brightness:  ;
  --tw-contrast:  ;
  --tw-grayscale:  ;
  --tw-hue-rotate:  ;
  --tw-invert:  ;
  --tw-saturate:  ;
  --tw-sepia:  ;
  --tw-drop-shadow:  ;
  --tw-backdrop-blur:  ;
  --tw-backdrop-brightness:  ;
  --tw-backdrop-contrast:  ;
  --tw-backdrop-grayscale:  ;
  --tw-backdrop-hue-rotate:  ;
  --tw-backdrop-invert:  ;
  --tw-backdrop-opacity:  ;
  --tw-backdrop-saturate:  ;
  --tw-backdrop-sepia:  ;
}

::backdrop {
  --tw-border-spacing-x: 0;
  --tw-border-spacing-y: 0;
  --tw-translate-x: 0;
  --tw-translate-y: 0;
  --tw-rotate: 0;
  --tw-skew-x: 0;
  --tw-skew-y: 0;
  --tw-scale-x: 1;
  --tw-scale-y: 1;
  --tw-pan-x:  ;
  --tw-pan-y:  ;
  --tw-pinch-zoom:  ;
  --tw-scroll-snap-strictness: proximity;
  --tw-gradient-from-position:  ;
  --tw-gradient-via-position:  ;
  --tw-gradient-to-position:  ;
  --tw-ordinal:  ;
  --tw-slashed-zero:  ;
  --tw-numeric-figure:  ;
  --tw-numeric-spacing:  ;
  --tw-numeric-fraction:  ;
  --tw-ring-inset:  ;
  --tw-ring-offset-width: 0px;
  --tw-ring-offset-color: #fff;
  --tw-ring-color: rgb(59 130 246 / 0.5);
  --tw-ring-offset-shadow: 0 0 #0000;
  --tw-ring-shadow: 0 0 #0000;
  --tw-shadow: 0 0 #0000;
  --tw-shadow-colored: 0 0 #0000;
  --tw-blur:  ;
  --tw-brightness:  ;
  --tw-contrast:  ;
  --tw-grayscale:  ;
  --tw-hue-rotate:  ;
  --tw-invert:  ;
  --tw-saturate:  ;
  --tw-sepia:  ;
  --tw-drop-shadow:  ;
  --tw-backdrop-blur:  ;
  --tw-backdrop-brightness:  ;
  --tw-backdrop-contrast:  ;
  --tw-backdrop-grayscale:  ;
  --tw-backdrop-hue-rotate:  ;
  --tw-backdrop-invert:  ;
  --tw-backdrop-opacity:  ;
  --tw-backdrop-saturate:  ;
  --tw-backdrop-sepia:  ;
}

.container {
  width: 100%;
}

@media (min-width: 640px) {
  .container {
    max-width: 640px;
  }
}

@media (min-width: 768px) {
  .container {
    max-width: 768px;
  }
}

@media (min-width: 1024px) {
  .container {
    max-width: 1024px;
  }
}

@media (min-width: 1280px) {
  .container {
    max-width: 1280px;
  }
}

@media (min-width: 1536px) {
  .container {
    max-width: 1536px;
  }
}

.visible {
  visibility: visible;
}

.collapse {
  visibility: collapse;
}

.static {
  position: static;
}

.fixed {
  position: fixed;
}

.absolute {
  position: absolute;
}

.relative {
  position: relative;
}

.bottom-4 {
  bottom: 1rem;
}

.left-1 {
  left: 0.25rem;
}

.right-2 {
  right: 0.5rem;
}

.top-1 {
  top: 0.25rem;
}

.m-2 {
  margin: 0.5rem;
}

.mx-auto {
  margin-left: auto;
  margin-right: auto;
}

.my-auto {
  margin-top: auto;
  margin-bottom: auto;
}

.mb-4 {
  margin-bottom: 1rem;
}

.mr-1 {
  margin-right: 0.25rem;
}

.mr-2 {
  margin-right: 0.5rem;
}

.mr-4 {
  margin-right: 1rem;
}

.mt-10 {
  margin-top: 2.5rem;
}

.block {
  display: block;
}

.flex {
  display: flex;
}

.inline-flex {
  display: inline-flex;
}

.table {
  display: table;
}

.contents {
  display: contents;
}

.hidden {
  display: none;
}

.h-0 {
  height: 0px;
}

.h-1 {
  height: 0.25rem;
}

.h-1\\/2 {
  height: 50%;
}

.h-2 {
  height: 0.5rem;
}

.h-2\\/5 {
  height: 40%;
}

.h-3 {
  height: 0.75rem;
}

.h-3\\/5 {
  height: 60%;
}

.h-32 {
  height: 8rem;
}

.h-\\[365px\\] {
  height: 365px;
}

.h-\\[840px\\] {
  height: 840px;
}

.w-10 {
  width: 2.5rem;
}

.w-12 {
  width: 3rem;
}

.w-28 {
  width: 7rem;
}

.w-4 {
  width: 1rem;
}

.w-8 {
  width: 2rem;
}

.w-\\[375px\\] {
  width: 375px;
}

.w-\\[416px\\] {
  width: 416px;
}

.w-\\[448px\\] {
  width: 448px;
}

.w-full {
  width: 100%;
}

.flex-1 {
  flex: 1 1 0%;
}

.flex-none {
  flex: none;
}

.flex-shrink {
  flex-shrink: 1;
}

.flex-grow {
  flex-grow: 1;
}

.border-collapse {
  border-collapse: collapse;
}

.-translate-x-1 {
  --tw-translate-x: -0.25rem;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}

.-translate-y-1 {
  --tw-translate-y: -0.25rem;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}

.scale-125 {
  --tw-scale-x: 1.25;
  --tw-scale-y: 1.25;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}

.scale-150 {
  --tw-scale-x: 1.5;
  --tw-scale-y: 1.5;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}

.scale-75 {
  --tw-scale-x: .75;
  --tw-scale-y: .75;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}

.transform {
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}

.cursor-pointer {
  cursor: pointer;
}

.resize {
  resize: both;
}

.flex-col {
  flex-direction: column;
}

.items-center {
  align-items: center;
}

.justify-end {
  justify-content: flex-end;
}

.justify-center {
  justify-content: center;
}

.justify-between {
  justify-content: space-between;
}

.gap-2 {
  gap: 0.5rem;
}

.space-x-2 > :not([hidden]) ~ :not([hidden]) {
  --tw-space-x-reverse: 0;
  margin-right: calc(0.5rem * var(--tw-space-x-reverse));
  margin-left: calc(0.5rem * calc(1 - var(--tw-space-x-reverse)));
}

.space-x-4 > :not([hidden]) ~ :not([hidden]) {
  --tw-space-x-reverse: 0;
  margin-right: calc(1rem * var(--tw-space-x-reverse));
  margin-left: calc(1rem * calc(1 - var(--tw-space-x-reverse)));
}

.space-x-8 > :not([hidden]) ~ :not([hidden]) {
  --tw-space-x-reverse: 0;
  margin-right: calc(2rem * var(--tw-space-x-reverse));
  margin-left: calc(2rem * calc(1 - var(--tw-space-x-reverse)));
}

.space-y-4 > :not([hidden]) ~ :not([hidden]) {
  --tw-space-y-reverse: 0;
  margin-top: calc(1rem * calc(1 - var(--tw-space-y-reverse)));
  margin-bottom: calc(1rem * var(--tw-space-y-reverse));
}

.space-y-6 > :not([hidden]) ~ :not([hidden]) {
  --tw-space-y-reverse: 0;
  margin-top: calc(1.5rem * calc(1 - var(--tw-space-y-reverse)));
  margin-bottom: calc(1.5rem * var(--tw-space-y-reverse));
}

.overflow-hidden {
  overflow: hidden;
}

.break-words {
  overflow-wrap: break-word;
}

.rounded-2xl {
  border-radius: 1rem;
}

.rounded-full {
  border-radius: 9999px;
}

.rounded-lg {
  border-radius: 0.5rem;
}

.rounded-md {
  border-radius: 0.375rem;
}

.border {
  border-width: 1px;
}

.border-2 {
  border-width: 2px;
}

.border-solid {
  border-style: solid;
}

.border-tr-purple {
  --tw-border-opacity: 1;
  border-color: rgb(167 139 250 / var(--tw-border-opacity));
}

.border-white {
  --tw-border-opacity: 1;
  border-color: rgb(255 255 255 / var(--tw-border-opacity));
}

.border-opacity-10 {
  --tw-border-opacity: 0.1;
}

.border-opacity-30 {
  --tw-border-opacity: 0.3;
}

.border-opacity-50 {
  --tw-border-opacity: 0.5;
}

.border-opacity-90 {
  --tw-border-opacity: 0.9;
}

.bg-\\[\\#007bff\\] {
  --tw-bg-opacity: 1;
  background-color: rgb(0 123 255 / var(--tw-bg-opacity));
}

.bg-white {
  --tw-bg-opacity: 1;
  background-color: rgb(255 255 255 / var(--tw-bg-opacity));
}

.object-contain {
  -o-object-fit: contain;
     object-fit: contain;
}

.p-0 {
  padding: 0px;
}

.p-0\\.5 {
  padding: 0.125rem;
}

.p-1 {
  padding: 0.25rem;
}

.p-2 {
  padding: 0.5rem;
}

.p-4 {
  padding: 1rem;
}

.px-4 {
  padding-left: 1rem;
  padding-right: 1rem;
}

.pb-10 {
  padding-bottom: 2.5rem;
}

.pb-2 {
  padding-bottom: 0.5rem;
}

.pb-3 {
  padding-bottom: 0.75rem;
}

.pl-3 {
  padding-left: 0.75rem;
}

.pl-3\\.5 {
  padding-left: 0.875rem;
}

.pr-5 {
  padding-right: 1.25rem;
}

.pt-10 {
  padding-top: 2.5rem;
}

.pt-12 {
  padding-top: 3rem;
}

.pt-16 {
  padding-top: 4rem;
}

.pt-20 {
  padding-top: 5rem;
}

.pt-24 {
  padding-top: 6rem;
}

.pt-28 {
  padding-top: 7rem;
}

.pt-3 {
  padding-top: 0.75rem;
}

.pt-8 {
  padding-top: 2rem;
}

.text-center {
  text-align: center;
}

.font-sans {
  font-family: "Montserrat", sans-serif;
}

.text-lg {
  font-size: 1.125rem;
  line-height: 1.75rem;
}

.text-sm {
  font-size: 0.875rem;
  line-height: 1.25rem;
}

.text-xs {
  font-size: 0.75rem;
  line-height: 1rem;
}

.font-medium {
  font-weight: 500;
}

.font-semibold {
  font-weight: 600;
}

.uppercase {
  text-transform: uppercase;
}

.leading-4 {
  line-height: 1rem;
}

.tracking-wide {
  letter-spacing: 0.025em;
}

.tracking-wider {
  letter-spacing: 0.05em;
}

.text-tr-gray-light {
  --tw-text-opacity: 1;
  color: rgb(128 128 128 / var(--tw-text-opacity));
}

.text-white {
  --tw-text-opacity: 1;
  color: rgb(255 255 255 / var(--tw-text-opacity));
}

.text-opacity-10 {
  --tw-text-opacity: 0.1;
}

.text-opacity-40 {
  --tw-text-opacity: 0.4;
}

.text-opacity-80 {
  --tw-text-opacity: 0.8;
}

.underline {
  text-decoration-line: underline;
}

.antialiased {
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

.shadow {
  --tw-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);
  --tw-shadow-colored: 0 1px 3px 0 var(--tw-shadow-color), 0 1px 2px -1px var(--tw-shadow-color);
  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);
}

.shadow-lg {
  --tw-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
  --tw-shadow-colored: 0 10px 15px -3px var(--tw-shadow-color), 0 4px 6px -4px var(--tw-shadow-color);
  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);
}

.shadow-md {
  --tw-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
  --tw-shadow-colored: 0 4px 6px -1px var(--tw-shadow-color), 0 2px 4px -2px var(--tw-shadow-color);
  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);
}

.outline {
  outline-style: solid;
}

.blur {
  --tw-blur: blur(8px);
  filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow);
}

.drop-shadow {
  --tw-drop-shadow: drop-shadow(0 1px 2px rgb(0 0 0 / 0.1)) drop-shadow(0 1px 1px rgb(0 0 0 / 0.06));
  filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow);
}

.drop-shadow-lg {
  --tw-drop-shadow: drop-shadow(0 10px 8px rgb(0 0 0 / 0.04)) drop-shadow(0 4px 3px rgb(0 0 0 / 0.1));
  filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow);
}

.drop-shadow-white {
  --tw-drop-shadow: drop-shadow(0px 0px 6px rgba(255, 255, 255, 0.1));
  filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow);
}

.grayscale {
  --tw-grayscale: grayscale(100%);
  filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow);
}

.filter {
  filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow);
}

.backdrop-filter {
  -webkit-backdrop-filter: var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia);
          backdrop-filter: var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia);
}

.transition {
  transition-property: color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, -webkit-backdrop-filter;
  transition-property: color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter;
  transition-property: color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter, -webkit-backdrop-filter;
  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
  transition-duration: 150ms;
}

.transition-all {
  transition-property: all;
  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
  transition-duration: 150ms;
}

.transition-transform {
  transition-property: transform;
  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
  transition-duration: 150ms;
}

.duration-150 {
  transition-duration: 150ms;
}

.duration-200 {
  transition-duration: 200ms;
}

.duration-300 {
  transition-duration: 300ms;
}

.ease-in {
  transition-timing-function: cubic-bezier(0.4, 0, 1, 1);
}

.ease-in-out {
  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
}

.ease-out {
  transition-timing-function: cubic-bezier(0, 0, 0.2, 1);
}

.hover\\:scale-110:hover {
  --tw-scale-x: 1.1;
  --tw-scale-y: 1.1;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}
 `;
var __defProp = Object.defineProperty, __getOwnPropDesc = Object.getOwnPropertyDescriptor, __decorateClass = (Y, X, ee, te) => {
  for (var ne = te > 1 ? void 0 : te ? __getOwnPropDesc(X, ee) : X, ie = Y.length - 1, oe; ie >= 0; ie--)
    (oe = Y[ie]) && (ne = (te ? oe(X, ee, ne) : oe(ne)) || ne);
  return te && ne && __defProp(X, ee, ne), ne;
};
let TriaAuth$1 = class extends s$1 {
  constructor() {
    super(), this.darkMode = !0, this.triaStaging = !1, this.dappName = "My Dapp", this.logo = "https://svgshare.com/i/11sN.svg", this.clientId = "", this.chain = "MUMBAI", this.environment = "mainnet", this.dappDetails = {
      dappDomain: "http://localhost:3000/",
      dappLogo: "https://svgshare.com/i/11sN.svg"
    }, new TriaConnector({
      authUrl: this.triaStaging ? "https://auth-tria.vercel.app" : "https://auth.tria.so",
      walletUrl: "https://wallet.tria.so"
    });
  }
  connectedCallback() {
    super.connectedCallback();
    const X = window.localStorage.getItem("wagmi.connected");
    if (X && X === "true" && document.cookie !== "") {
      const ee = cookieToInitialState(
        config$1,
        `; ${document.cookie}`
      );
      if (ee) {
        const { onMount: te } = hydrate(config$1, {
          initialState: ee,
          reconnectOnMount: !0
        });
        te();
      }
    }
  }
  // social logins iframe
  get iframeUrl() {
    return this.triaStaging ? `https://auth-tria.vercel.app/SocialLoginIframe/?dappName=${this.dappName}&dappLogo=${this.logo}&darkMode=${this.darkMode}&clientId=${this.clientId}` : `https://auth.tria.so/SocialLoginIframe/?dappName=${this.dappName}&dappLogo=${this.logo}&darkMode=${this.darkMode}&clientId=${this.clientId}`;
  }
  // hidden iframe that listens for auth events in the background
  get authIframeUrl() {
    return this.triaStaging ? "https://auth-tria.vercel.app/verified" : "https://auth.tria.so/verified";
  }
  // otp login iframe
  get otpIframeUrl() {
    return this.triaStaging ? `https://auth-tria.vercel.app/phoneEmailOtp/?&dappName=${this.dappName}&dappLogo=${this.logo}&darkMode=${this.darkMode}&defaultCountryCode=60` : `https://auth.tria.so/phoneEmailOtp/?&dappName=${this.dappName}&dappLogo=${this.logo}&darkMode=${this.darkMode}&defaultCountryCode=60`;
  }
  get signupIframeUrl() {
    return this.triaStaging ? "https://auth-tria.vercel.app/signUpUserNameIframe" : "https://auth.tria.so/signUpUserNameIframe";
  }
  configure({
    chain: X,
    environment: ee,
    dappDetails: te,
    aa: ne,
    rpcUrl: ie
  }) {
    this.chain = X, this.environment = ee, this.dappDetails = te, this.aa = ne, this.rpcUrl = ie;
  }
  render() {
    return x$2`
      <auth-basic
        ?darkMode="${this.darkMode}"
        dappName="${this.dappName}"
        logo="${this.logo}"
        iframeUrl="${this.iframeUrl}"
        otpIframeUrl="${this.otpIframeUrl}"
        signupIframeUrl="${this.signupIframeUrl}"
      ></auth-basic>
    `;
  }
  getAccount() {
    return getAccount(config$1);
  }
  isAuthenticated() {
    return !!getAccount(config$1);
  }
  async disconnect() {
    await disconnect(config$1);
    const X = {
      type: "Log out",
      success: !0
    }, ee = new CustomEvent("TRIA_LOGOUT", {
      detail: X,
      bubbles: !0,
      composed: !0
    });
    this.dispatchEvent(ee);
  }
  async send(X, ee, te) {
    return await send(
      config$1,
      { amount: X, recepientAddress: ee, chainName: this.chain, tokenAddress: te },
      triaAuthUrl,
      this.environment,
      this.aa,
      this.dappDetails
    );
  }
  async signMessage(X) {
    return await signMessage(
      config$1,
      {
        message: X,
        chainName: this.chain
      },
      triaAuthUrl,
      this.environment,
      this.aa,
      this.dappDetails
    );
  }
  async writeContract(X, ee) {
    return await writeContract(
      config$1,
      {
        chainName: this.chain,
        contractDetails: X,
        payToken: ee
      },
      triaAuthUrl,
      this.environment,
      this.aa,
      this.dappDetails
    );
  }
  async readContract(X) {
    return await readContract({
      chainName: this.chain,
      contractDetails: X,
      rpcUrl: this.rpcUrl
    });
  }
  // public async sendNft(
  //   calldata: SendNftParams,
  //   environment: ENV,
  //   aa?: AaDetails,
  //   dappDetails?: dappDetails
  // ) {
  //   return await sendNft(
  //     this.triaContext.config,
  //     calldata,
  //     triaAuthUrl,
  //     environment,
  //     aa,
  //     dappDetails
  //   );
  // }
  // private async listenForAccessToken() {
  //   return await listenForAccessToken({});
  // }
  // private async listenIdToken() {
  //   return await listenIdToken({});
  // }
};
TriaAuth$1.styles = [
  TWStyles,
  styles,
  i$5`
      :host {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        display: flex;
        justify-content: center;
        align-items: center;
        background: rgba(0, 0, 0, 0.5);
        backdrop-filter: blur(5px);
      }
    `
];
__decorateClass([
  n$1({ type: Boolean })
], TriaAuth$1.prototype, "darkMode", 2);
__decorateClass([
  n$1({ type: Boolean })
], TriaAuth$1.prototype, "triaStaging", 2);
__decorateClass([
  n$1({ type: String })
], TriaAuth$1.prototype, "dappName", 2);
__decorateClass([
  n$1({ type: String })
], TriaAuth$1.prototype, "logo", 2);
__decorateClass([
  n$1({ type: String })
], TriaAuth$1.prototype, "clientId", 2);
__decorateClass([
  r$3()
], TriaAuth$1.prototype, "chain", 2);
__decorateClass([
  r$3()
], TriaAuth$1.prototype, "environment", 2);
__decorateClass([
  r$3()
], TriaAuth$1.prototype, "dappDetails", 2);
__decorateClass([
  r$3()
], TriaAuth$1.prototype, "aa", 2);
__decorateClass([
  r$3()
], TriaAuth$1.prototype, "rpcUrl", 2);
TriaAuth$1 = __decorateClass([
  t$1("tria-auth")
], TriaAuth$1);
class AuthManager {
  constructor(X) {
    if (!X || Object.keys(X).length === 0)
      throw new Error(
        "AuthManager requires an options object with at least one property."
      );
    this.authElement = null, this.options = X, this.init();
  }
  init() {
    this.authElement = document.createElement("tria-auth"), Object.entries(this.options).forEach(([X, ee]) => {
      this.authElement[X] = ee;
    }), this.authElement.addEventListener("TRIA_LOGIN", () => {
      this.remove();
    }), this.authElement.connectedCallback(), this.insertAuthIframe();
  }
  // configure chain setup and environment
  configure(X) {
    if (this.authElement)
      return this.authElement.configure(X);
  }
  // Method to render the TriaAuth component
  login() {
    this.authElement && !this.authElement.isConnected && document.body.appendChild(this.authElement);
  }
  // Method to remove the TriaAuth component from the DOM
  remove() {
    this.authElement && this.authElement.isConnected && document.body.removeChild(this.authElement);
  }
  // Wrapper methods for TriaAuth's public methods
  getAccount() {
    return this.authElement ? this.authElement.getAccount() : null;
  }
  isAuthenticated() {
    return this.authElement ? this.authElement.isAuthenticated() : !1;
  }
  async disconnect() {
    this.authElement && await this.authElement.disconnect();
  }
  async send(X, ee, te) {
    if (this.authElement)
      return await this.authElement.send(
        X,
        ee,
        te
      );
  }
  async signMessage(X) {
    if (this.authElement)
      return await this.authElement.signMessage(X);
  }
  async writeContract(X, ee) {
    if (this.authElement)
      return await this.authElement.writeContract(X, ee);
  }
  async readContract(X) {
    if (this.authElement)
      return await this.authElement.readContract(X);
  }
  // Method to insert auth iframe
  insertAuthIframe() {
    const X = document.createElement("iframe");
    X.src = this.authElement ? this.authElement.authIframeUrl : "", X.title = "Auth Verification", X.style.display = "none", document.body.appendChild(X);
  }
  // Method to add a listener for a specific event
  addEventListener(X, ee) {
    this.authElement && this.authElement.addEventListener(X, ee);
  }
  // Method to remove a listener for a specific event
  removeEventListener(X, ee) {
    this.authElement && this.authElement.removeEventListener(X, ee);
  }
}
const TriaAuth = TriaAuth$1;
export {
  AuthManager as A,
  Bs as B,
  LA as L,
  Os as O,
  TriaAuth as T,
  ZD as Z,
  _0 as _,
  _f as a,
  Le as b,
  Za as c,
  getDefaultExportFromCjs$4 as d,
  es as e,
  commonjsGlobal$2 as f,
  getAugmentedNamespace$2 as g,
  b as h,
  pA as p,
  ss as s
};
